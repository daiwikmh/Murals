import{z as t}from"zod";import{InvalidInputError as e,PrivyErrorCode as i}from"@privy-io/api-base";import{Pagination as a}from"../api.mjs";import{SolanaWalletAddress as o,WalletAddress as n}from"../core.mjs";import{PrivateKeyExportInput as r}from"./export.mjs";import"bs58";import"libphonenumber-js/max";import"viem";const s=t.string().regex(/^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$/,"Chain ID must be a valid CAIP-2 chain ID, e.g. 'eip155:1'");let l=t.object({address:o.optional(),chain_type:t.literal("solana").optional()}),d=t.object({address:n.optional(),chain_type:t.literal("ethereum").optional()});const c=t.enum(["root","manager","delegated-actions"]).nullable(),h=t.object({method:t.literal("signTransaction"),params:t.object({transaction:t.string(),encoding:t.literal("base64")})}).merge(l),g=t.object({method:t.literal("signAndSendTransaction"),caip2:s,params:t.object({transaction:t.string(),encoding:t.literal("base64")})}).merge(l),m=t.object({method:t.literal("signMessage"),params:t.object({message:t.string(),encoding:t.literal("base64")})}).merge(l),p=t.string().startsWith("0x").refine((t=>!t.includes(".")),"Invalid hex string: must start with '0x' and not contain decimal points"),_=t.custom((t=>"string"==typeof t&&t.startsWith("0x")));let b=t.number().int().nonnegative().safe();const u=t.union([p,b],{invalid_type_error:"Invalid quantity: must be either a hex string starting with '0x' or a non-negative integer."}),y=t.object({from:n.optional(),to:n.optional(),chain_id:u.optional(),nonce:u.optional(),data:p.optional(),value:u.optional(),type:t.union([t.literal(0),t.literal(1),t.literal(2)]).optional(),gas_limit:u.optional(),gas_price:u.optional(),max_fee_per_gas:u.optional(),max_priority_fee_per_gas:u.optional()}),j=t.object({method:t.literal("eth_signTransaction"),params:t.object({transaction:y})}).merge(d),z=t.object({method:t.literal("eth_sendTransaction"),caip2:s,params:t.object({transaction:y})}).merge(d),v=t.object({message:t.string(),encoding:t.union([t.literal("utf-8"),t.literal("hex")])}),f=t.object({method:t.literal("personal_sign"),params:v}).merge(d),x=t.object({method:t.literal("secp256k1_sign"),params:t.object({hash:_})}).merge(d),k=t.record(t.string(),t.any()),I=t.object({name:t.string(),version:t.string(),chainId:t.number(),verifyingContract:t.string()}).merge(t.object({}).catchall(t.any())),w=t.union([I,k]),A=t.record(t.array(t.object({name:t.string(),type:t.string()}))),T=t.object({method:t.literal("eth_signTypedData_v4"),params:t.object({typed_data:t.object({domain:w,types:A,message:t.record(t.string(),t.any()),primary_type:t.string()})})}).merge(d),D=t.object({address:t.string(),method:t.literal("exportPrivateKey"),params:r}),P=t.discriminatedUnion("method",[j,z,f,T,x]),W=t.discriminatedUnion("method",[h,g,m]),C=t.union([P,W,D]),O=t.object({method:t.literal("signTransaction"),data:t.object({signed_transaction:t.string(),encoding:t.literal("base64")})}),U=t.object({method:t.literal("signAndSendTransaction"),data:t.object({transaction_id:t.string().optional(),hash:t.string(),caip2:s}).optional(),error:t.object({code:t.string(),message:t.string()}).optional()}),q=t.object({method:t.literal("signMessage"),data:t.object({signature:t.string(),encoding:t.literal("base64")})}),K=t.object({method:t.literal("eth_signTransaction"),data:t.object({signed_transaction:t.string(),encoding:t.literal("rlp")})}),L=t.object({method:t.literal("eth_sendTransaction"),data:t.object({transaction_id:t.string().optional(),hash:t.string(),caip2:s}).optional(),error:t.object({code:t.string(),message:t.string()}).optional()}),M=t.object({method:t.literal("personal_sign"),data:t.object({signature:t.string(),encoding:t.literal("hex")})}),N=t.object({method:t.literal("secp256k1_sign"),data:t.object({signature:p,encoding:t.literal("hex")})}),S=t.object({method:t.literal("eth_signTypedData_v4"),data:t.object({signature:t.string(),encoding:t.literal("hex")})}),V=t.object({method:t.literal("exportPrivateKey"),data:r}),R=t.discriminatedUnion("method",[O,U,q,K,L,M,N,S,V]),Z=t.object({display_name:t.string().optional(),public_key:t.string(),role:c.optional()});let $=t.union([t.literal("solana"),t.literal("ethereum")]);const B=t.object({id:t.string(),address:t.string(),created_at:t.number(),chain_type:$,policy_ids:t.array(t.string()),authorization_threshold:t.number().optional(),additional_signers:t.array(t.object({signer_id:t.string().cuid2()})),owner_id:t.string().cuid2().nullable()}),E=t.string().cuid2(),F=t.string(),G=t.object({public_key:F}),H={owner:G.nullable().optional(),owner_id:E.nullable().optional()},J=t.array(t.object({signer_id:E}).strict()),Q=t.object({chain_type:$,policy_ids:t.array(t.string()).max(1).optional(),authorization_key_ids:t.array(t.string()).optional(),authorization_threshold:t.number().optional(),additional_signers:J.optional(),...H}),X=Q.refine((t=>{let e=void 0!==t.authorization_key_ids||void 0!==t.authorization_threshold,i=void 0!==t.additional_signers;return!e||!i}),"Please provide either additional_signers or authorization_key_ids, not both").refine((t=>void 0===t.authorization_threshold||t.authorization_threshold>=1&&t.authorization_key_ids&&t.authorization_threshold<=t.authorization_key_ids.length),{message:"If specified, authorization_threshold must be an integer between 1 and the length of authorization_key_ids."}).refine((t=>!t.owner||!t.owner_id),{message:"Only one of owner or owner_id can be provided."}).catch((t=>{throw new e(t.error.message,i.INVALID_DATA)})),Y=t.object({id:t.string(),chain_type:$,address:t.string(),authorization_threshold:t.number().optional()}),tt=t.object({wallet_id:t.string({required_error:"Wallet ID must be provided",invalid_type_error:"Wallet ID is not a valid string"}).min(1)}).catch((({error:t})=>{throw new e(t.message,i.INVALID_DATA)})),et=t.object({id:t.string()}),it=t.object({id:t.string(),display_name:t.string().nullable(),public_key:t.string(),role:c,created_at:t.number()}),at=t.object({id:t.string(),display_name:t.string().nullable(),public_key:t.string(),created_at:t.number()}),ot=a.extend({chain_type:$.optional()}).strict(),nt=t.object({policy_ids:t.array(t.string()).max(1,"Only one policy ID can be set").optional(),authorization_key_ids:t.array(t.string()).optional(),authorization_threshold:t.number().optional(),additional_signers:J.optional()}).strict().superRefine(((t,e)=>{Object.values(t).every((t=>null==t))&&e.addIssue({code:"custom",message:"At least one field must be provided"}),void 0!==t.authorization_threshold&&0!==t.authorization_threshold&&(t.authorization_threshold<0&&e.addIssue({code:"custom",path:["authorization_threshold"],message:"`authorization_threshold` must be non-negative if specified."}),void 0===t.authorization_key_ids&&e.addIssue({code:"custom",path:["authorization_key_ids"],message:"An array of `authorization_key_ids` must be provided for a non-zero `authorization_threshold`."}),t.authorization_key_ids&&t.authorization_threshold>t.authorization_key_ids.length&&e.addIssue({code:"custom",path:["authorization_threshold"],message:"`authorization_threshold` must be non-negative if specified."}))}));export{J as AdditionalSignerInput,it as AuthorizationKeyDashboardResponse,at as AuthorizationKeyResponse,c as AuthorizationKeyRole,Q as BaseWalletApiCreateInput,s as CAIP2,I as CurrentTypedDataDomainInputParams,_ as Hash,p as Hex,E as KeyQuorumId,k as LegacyTypedDataDomainInputParams,G as OwnerInput,H as OwnerInputFields,F as P256PublicKey,u as Quantity,w as TypedDataDomainInputParams,A as TypedDataTypesInputParams,y as UnsignedEthereumTransaction,X as WalletApiCreateInput,Y as WalletApiCreateResponse,f as WalletApiEthereumPersonalSignRpcInput,v as WalletApiEthereumPersonalSignRpcInputParams,M as WalletApiEthereumPersonalSignRpcResponse,P as WalletApiEthereumRpcInput,x as WalletApiEthereumSecp256k1SignRpcInput,N as WalletApiEthereumSecp256k1SignRpcResponse,z as WalletApiEthereumSendTransactionRpcInput,L as WalletApiEthereumSendTransactionRpcResponse,j as WalletApiEthereumSignTransactionRpcInput,K as WalletApiEthereumSignTransactionRpcResponse,T as WalletApiEthereumSignTypedDataRpcInput,S as WalletApiEthereumSignTypedDataRpcResponse,D as WalletApiExportPrivateKeyRpcInput,V as WalletApiExportPrivateKeyRpcResponse,Z as WalletApiRegisterAuthorizationKeyInput,et as WalletApiRevokeAuthorizationKeyInput,C as WalletApiRpcInput,R as WalletApiRpcResponse,W as WalletApiSolanaRpcInput,g as WalletApiSolanaSignAndSendTransactionRpcInput,U as WalletApiSolanaSignAndSendTransactionRpcResponse,m as WalletApiSolanaSignMessageRpcInput,q as WalletApiSolanaSignMessageRpcResponse,h as WalletApiSolanaSignTransactionRpcInput,O as WalletApiSolanaSignTransactionRpcResponse,tt as WalletIdFromPath,B as WalletResponse,nt as WalletUpdateInput,ot as WalletsSearchInput};
