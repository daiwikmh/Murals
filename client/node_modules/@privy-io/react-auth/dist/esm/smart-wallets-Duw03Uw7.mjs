import{useRef as e,useState as t,useCallback as r}from"react";import{http as n,createPublicClient as a}from"viem";import{n as i,f as s,an as o,u as l,l as c,m as d,a as u,ax as p,aw as m,av as y}from"./privy-provider-pLXGnpXL.mjs";import{P as g,u as h}from"./internal-context-D5bEplez.mjs";import{g as f}from"./getEmbeddedConnectedWallet-CSSBWE2p.mjs";import{createSmartAccountClient as w}from"permissionless";import{toThirdwebSmartAccount as P,toLightSmartAccount as I,toBiconomySmartAccount as v,toEcdsaKernelSmartAccount as F,toSafeSmartAccount as W}from"permissionless/accounts";import{createPimlicoClient as x}from"permissionless/clients/pimlico";import{toCoinbaseSmartAccount as G,entryPoint06Address as C,entryPoint07Address as T}from"viem/account-abstraction";import{THIRDWEB as M,COINBASE_SMART_WALLET as O,LIGHT_ACCOUNT as S,BICONOMY as b,KERNEL as U,SAFE as A}from"@privy-io/js-sdk-core";let D={address:C,version:"0.6"},V={address:T,version:"0.7"},_=({owner:e,smartWalletType:t,publicClient:r})=>{switch(t){case A:return W({client:r,entryPoint:V,owners:[e],version:"1.4.1"});case U:return F({client:r,version:"0.3.1",entryPoint:V,owners:[e]});case b:return v({client:r,owners:[e],entryPoint:D});case S:return I({client:r,entryPoint:D,owner:e,version:"1.1.0"});case O:return async function({client:e,owner:t}){let[r]=await t.request({method:"eth_accounts"});if(!r)throw Error("Unable to request embedded owner for eth_accounts");return await G({client:e,owners:[{type:"local",source:"privy",address:r,sign:async({hash:e})=>await t.request({method:"secp256k1_sign",params:[e]})}]})}({client:r,owner:e});case M:return P({client:r,entryPoint:V,owner:e});default:throw Error(`Invalid smart account type: ${t}.`)}};const B=({calls:e,chain:t,maxPriorityFeePerGas:r,maxFeePerGas:n,nonce:a})=>e.map((e=>({to:e.to||void 0,data:e.data,value:e.value,chainId:t.id,nonce:a,maxFeePerGas:n,maxPriorityFeePerGas:r}))),N=async({chain:e,paymasterContext:t,embeddedWallet:r,user:s,smartWalletsConfig:o,rpcConfig:l,privyAppId:c})=>{if(!o?.enabled||!s||!r)return;let d=await r.getEthereumProvider(),u=o?.configuredNetworks.find((t=>t.chainId===`eip155:${e.id}`));if(!u)throw new g(`The chain ${e.name} (eip155:${e.id}) must be configured in the smart wallet configuration in your dashboard`);let p=s.smartWallet?.smartWalletType??o.smartWalletType,m=i(e,l,c),y=a({chain:e,transport:n(m)}),h=t??u.paymasterContext,f=await(async({owner:e,smartWalletType:t,chain:r,publicClient:a,bundlerUrl:i,paymasterUrl:s,paymasterContext:o})=>{let l=await _({owner:e,smartWalletType:t,publicClient:a}),c=x({transport:n(i),entryPoint:l.entryPoint}),d=s?x({transport:n(s),entryPoint:l.entryPoint}):void 0;return w({account:l,chain:r,paymaster:d,paymasterContext:o,bundlerTransport:n(i),userOperation:{estimateFeesPerGas:async()=>{if(["public.pimlico.io","api.pimlico.io"].some((e=>i.includes(e))))return await c.getUserOperationGasPrice().then((e=>e.fast));if(["rpc.zerodev.app"].some((e=>i.includes(e))))return(await c.request({method:"zd_getUserOperationGasPrice",params:[]})).fast;if(["g.alchemy.com"].some((e=>i.includes(e)))){let[e,t]=await Promise.all([a.getBlock({blockTag:"latest"}),c.request({method:"rundler_maxPriorityFeePerGas",params:[]})]);if(!e.baseFeePerGas||!t)throw Error("Failed to get block or maxPriorityFeePerGasEstimate");return{maxFeePerGas:150n*e.baseFeePerGas/100n+BigInt(t.toString()),maxPriorityFeePerGas:BigInt(t.toString())}}{let e=await a.estimateFeesPerGas(),t=i.includes("api.developer.coinbase.com")?175n:150n;return{...e,maxFeePerGas:e.maxFeePerGas*t/100n,maxPriorityFeePerGas:e.maxPriorityFeePerGas*t/100n}}}}})})({owner:d,smartWalletType:p,chain:e,publicClient:y,paymasterContext:h,...u});if(!f)throw new g(`Failed to create smart wallet client for chain ${e.name} (eip155:${e.id})`);return f},$=({clientConfig:n,smartWalletsConfig:a})=>{let{hideWalletUIs:i,openPrivyModal:w,appId:P,isHeadlessSigning:I}=h(),v=s(),{setModalData:F}=o(),{user:W}=l(),{chains:x}=s(),{chainId:G,clients:C,setChainId:T,chainIdState:M}=(()=>{let r=e(),[n,a]=t();return{clients:e({}),setChainId:e=>{r.current=e,a(e)},chainId:r,chainIdState:n}})(),O=x.find((e=>e.id===M)),{wallets:S}=c(),b=f(S),U=d(W),A=r((async()=>G.current),[G]),D=r((async({id:e})=>{if(!C.current[e]){let t=await N({chain:x.find((t=>t.id===e)),embeddedWallet:b,user:W,paymasterContext:n?.paymasterContext,smartWalletsConfig:a,rpcConfig:v.rpcConfig,privyAppId:P});t&&(C.current[e]=t)}T(e)}),[x,n,S,W,a]);return{wrapSmartAccountClient:e=>{C.current[e.chain.id]=e,M||T(e.chain.id);return{...e,sendTransaction:async(e,t)=>{let r=C.current[G.current];if(!r)throw new g(`Smart wallet client for chain (eip155:${G.current}) not found`);if(delete e.account,I({showWalletUIs:t?.uiOptions?.showWalletUIs}))return i.current=!0,await r.sendTransaction(e).finally((()=>i.current=!1));let n=[];"calls"in e&&void 0!==e.calls?n=[...e.calls]:"to"in e&&(n=[{to:e.to,value:e.value||BigInt(0),data:e.data||"0x"}]);let a=async()=>{if(!r.paymaster)return!1;let{paymasterAndData:t,paymasterData:a}=await r.prepareUserOperation({calls:n,maxFeePerGas:e.maxFeePerGas,maxPriorityFeePerGas:e.maxPriorityFeePerGas,nonce:e.nonce?BigInt(e.nonce):void 0});return Number(t??a??0)>0};return new Promise((async(s,o)=>{i.current=!0;let{entropyId:l,entropyIdVerifier:c}=u(W);F({connectWallet:{recoveryMethod:U.recoveryMethod,connectingWalletAddress:U.address,entropyId:l,entropyIdVerifier:c,onCompleteNavigateTo:p,onFailure:()=>{}},sendTransaction:{transactionRequests:B({calls:n,chain:r.chain,maxPriorityFeePerGas:e.maxPriorityFeePerGas,maxFeePerGas:e.maxFeePerGas,nonce:e.nonce?BigInt(e.nonce):void 0}),transactingWalletIndex:0,transactingWalletAddress:r.account.address,entropyId:l,entropyIdVerifier:c,getIsSponsored:a,signOnly:!1,onConfirm:()=>r.sendTransaction(e),onSuccess:e=>s(e.hash),onFailure:o,uiOptions:t?.uiOptions??{}}}),w(m)})).finally((()=>{i.current=!1}))},signMessage:async(e,t)=>{let r=C.current[G.current];if(!r)throw new g(`Smart wallet client for chain (eip155:${G.current}) not found`);return I({showWalletUIs:t?.uiOptions?.showWalletUIs})?(i.current=!0,await r.signMessage(e).finally((()=>i.current=!1))):new Promise((async(n,a)=>{let{entropyId:s,entropyIdVerifier:o}=u(W);i.current=!0,F({connectWallet:{recoveryMethod:U.recoveryMethod,connectingWalletAddress:U.address,entropyId:s,entropyIdVerifier:o,onCompleteNavigateTo:y,onFailure:()=>{}},signMessage:{method:"personal_sign",data:"string"==typeof e.message?e.message:e.message.raw.toString(),confirmAndSign:()=>r.signMessage(e),onSuccess:e=>n(e),onFailure:a,uiOptions:t?.uiOptions??{}}}),w(m)})).finally((()=>{i.current=!1}))},signTypedData:async(e,t)=>{let r=C.current[G.current];if(!r)throw new g(`Smart wallet client for chain (eip155:${G.current}) not found`);return delete e.account,I({showWalletUIs:t?.uiOptions?.showWalletUIs})?(i.current=!0,await r.signTypedData(e).finally((()=>i.current=!1))):new Promise((async(n,a)=>{i.current=!0;let{entropyId:s,entropyIdVerifier:o}=u(W);F({connectWallet:{recoveryMethod:U.recoveryMethod,connectingWalletAddress:U.address,entropyId:s,entropyIdVerifier:o,onCompleteNavigateTo:y,onFailure:()=>{}},signMessage:{method:"eth_signTypedData_v4",data:e,confirmAndSign:()=>r.signTypedData(e),onSuccess:e=>n(e),onFailure:a,uiOptions:t?.uiOptions??{}}}),w(m)})).finally((()=>{i.current=!1}))},getChainId:A,chain:O,switchChain:D}}}},q=()=>{let{hideWalletUIs:e,openPrivyModal:t,isHeadlessSigning:r}=h(),{setModalData:n}=o(),{user:a}=l(),i=d(a);return{wrapSmartAccountClientWithUIs:s=>({...s,sendTransaction:async(o,l)=>{if(r({showWalletUIs:l?.uiOptions?.showWalletUIs}))return e.current=!0,await s.sendTransaction(o).finally((()=>e.current=!1));let c=[];"calls"in o&&void 0!==o.calls?c=[...o.calls]:"to"in o&&(c=[{to:o.to,value:o.value||BigInt(0),data:o.data||"0x"}]);let d=async()=>{if(!s.paymaster)return!1;let{paymasterAndData:e,paymasterData:t}=await s.prepareUserOperation({calls:c,maxFeePerGas:o.maxFeePerGas,maxPriorityFeePerGas:o.maxPriorityFeePerGas,nonce:o.nonce?BigInt(o.nonce):void 0});return Number(e??t??0)>0};return new Promise((async(r,y)=>{e.current=!0;let{entropyId:g,entropyIdVerifier:h}=u(a);n({connectWallet:{recoveryMethod:i.recoveryMethod,connectingWalletAddress:i.address,entropyId:g,entropyIdVerifier:h,onCompleteNavigateTo:p,onFailure:()=>{}},sendTransaction:{transactionRequests:B({calls:c,chain:s.chain,maxPriorityFeePerGas:o.maxPriorityFeePerGas,maxFeePerGas:o.maxFeePerGas,nonce:o.nonce?BigInt(o.nonce):void 0}),transactingWalletIndex:0,transactingWalletAddress:s.account.address,entropyId:g,entropyIdVerifier:h,getIsSponsored:d,signOnly:!1,onConfirm:()=>s.sendTransaction(o),onSuccess:e=>r(e.hash),onFailure:y,uiOptions:l?.uiOptions??{}}}),t(m)})).finally((()=>{e.current=!1}))},signMessage:async(o,l)=>r({showWalletUIs:l?.uiOptions?.showWalletUIs})?(e.current=!0,await s.signMessage(o).finally((()=>e.current=!1))):new Promise((async(r,c)=>{let{entropyId:d,entropyIdVerifier:p}=u(a);e.current=!0,n({connectWallet:{recoveryMethod:i.recoveryMethod,connectingWalletAddress:i.address,entropyId:d,entropyIdVerifier:p,onCompleteNavigateTo:y,onFailure:()=>{}},signMessage:{method:"personal_sign",data:"string"==typeof o.message?o.message:o.message.raw.toString(),confirmAndSign:()=>s.signMessage(o),onSuccess:e=>r(e),onFailure:c,uiOptions:l?.uiOptions??{}}}),t(m)})).finally((()=>{e.current=!1})),signTypedData:async(o,l)=>r({showWalletUIs:l?.uiOptions?.showWalletUIs})?(e.current=!0,await s.signTypedData(o).finally((()=>e.current=!1))):new Promise((async(r,c)=>{e.current=!0;let{entropyId:d,entropyIdVerifier:p}=u(a);n({connectWallet:{recoveryMethod:i.recoveryMethod,connectingWalletAddress:i.address,entropyId:d,entropyIdVerifier:p,onCompleteNavigateTo:y,onFailure:()=>{}},signMessage:{method:"eth_signTypedData_v4",data:o,confirmAndSign:()=>s.signTypedData(o),onSuccess:e=>r(e),onFailure:c,uiOptions:l?.uiOptions??{}}}),t(m)})).finally((()=>{e.current=!1}))})}};export{$ as a,B as c,N as g,q as u};
