"use strict";var e=require("./privy-provider-ChgF3evV.js"),r=require("react"),t=require("./internal-context-GxD_jR-e.js"),o=require("./useActiveWallet-DhWoee28.js"),i=require("./frame-BE5iw8D5.js"),n=require("viem"),s=require("viem/utils"),a=require("@privy-io/js-sdk-core"),u=require("./getEmbeddedConnectedWallet-DTU4T9TJ.js");require("react/jsx-runtime"),require("mipd"),require("react-device-detect"),require("uuid"),require("jose"),require("eventemitter3"),require("@coinbase/wallet-sdk"),require("@marsidev/react-turnstile"),require("styled-components"),require("tinycolor2"),require("@heroicons/react/24/outline/DevicePhoneMobileIcon"),require("@heroicons/react/24/outline/FingerPrintIcon"),require("@heroicons/react/24/outline/PhoneIcon"),require("@heroicons/react/24/outline/ShieldCheckIcon"),require("@heroicons/react/24/outline/ArrowLeftIcon"),require("@heroicons/react/24/outline/ArrowRightIcon"),require("@heroicons/react/24/outline/QuestionMarkCircleIcon"),require("@heroicons/react/24/outline/XMarkIcon"),require("@heroicons/react/24/outline/ChevronDownIcon"),require("@heroicons/react/24/outline/CalendarIcon"),require("@heroicons/react/24/outline/ExclamationTriangleIcon"),require("@headlessui/react"),require("@walletconnect/ethereum-provider"),require("zustand"),require("fast-password-entropy"),require("secure-password-utilities"),require("secure-password-utilities/wordlists"),require("@heroicons/react/24/outline/UserCircleIcon"),require("@heroicons/react/24/outline/EnvelopeIcon"),require("@heroicons/react/20/solid/CheckIcon"),require("@heroicons/react/24/outline/WalletIcon"),require("@heroicons/react/24/outline/CheckIcon"),require("@heroicons/react/24/outline/Square2StackIcon"),require("@heroicons/react/24/outline/ExclamationCircleIcon"),require("@heroicons/react/24/outline/ArrowTopRightOnSquareIcon"),require("@heroicons/react/24/solid/DocumentCheckIcon"),require("@heroicons/react/24/solid/XCircleIcon"),require("@heroicons/react/24/solid/CheckCircleIcon"),require("qrcode"),require("@heroicons/react/24/outline/ChevronRightIcon"),require("@heroicons/react/24/outline/LockClosedIcon"),require("@heroicons/react/24/outline/PencilSquareIcon"),require("@heroicons/react/24/outline/ArrowPathIcon"),require("@heroicons/react/24/outline/EyeIcon"),require("@heroicons/react/24/outline/EyeSlashIcon"),require("@heroicons/react/24/outline/KeyIcon"),require("@heroicons/react/24/outline/ArrowDownTrayIcon"),require("@heroicons/react/24/outline/ClipboardDocumentCheckIcon"),require("@heroicons/react/24/outline/DocumentDuplicateIcon"),require("@heroicons/react/24/solid/LockClosedIcon"),require("@heroicons/react/24/outline/CheckCircleIcon"),require("@heroicons/react/24/outline/InformationCircleIcon"),require("@heroicons/react/24/outline/CreditCardIcon"),require("@heroicons/react/24/outline/QrCodeIcon"),require("@heroicons/react/24/solid/ArrowsRightLeftIcon"),require("@heroicons/react/24/outline/GlobeAltIcon"),require("ofetch"),require("@heroicons/react/24/outline"),require("@heroicons/react/24/outline/ClipboardDocumentIcon"),require("@heroicons/react/24/outline/CloudArrowUpIcon"),require("@heroicons/react/24/outline/NoSymbolIcon"),require("@heroicons/react/24/outline/ClockIcon"),require("@heroicons/react/24/outline/TrashIcon"),require("@heroicons/react/24/solid/CheckBadgeIcon"),require("@heroicons/react/24/solid/IdentificationIcon"),require("@heroicons/react/24/outline/MinusCircleIcon"),require("@heroicons/react/24/outline/ArrowRightEndOnRectangleIcon"),require("@heroicons/react/24/solid/ShieldCheckIcon"),require("js-cookie");let l=async(e,r,o,i,n)=>{if(!e)throw i("linkAccount","onError",t.PrivyErrorCode.MUST_BE_AUTHENTICATED,{linkMethod:n}),new t.PrivyClientError("User must be authenticated before linking an account.");if(!r?.linkedAccounts.some((e=>e.type.includes(n))))throw new t.PrivyClientError(`OAuth account of type ${n} not linked to the account.`);await o(n)};exports.Captcha=e.Captcha,exports.ConnectorManager=e.ConnectorManager,exports.EthereumWalletConnector=e.EthereumWalletConnector,exports.LoginModal=e.LoginModal,exports.PrivyClient=e.PrivyClient,exports.PrivyProvider=e.PrivyProvider,exports.VERSION=e.VERSION,exports.WalletConnector=e.WalletConnector,exports.errorIndicatesMaxMfaRetries=e.errorIndicatesMaxMfaRetries,exports.errorIndicatesMfaTimeout=e.errorIndicatesMfaTimeout,exports.errorIndicatesMfaVerificationFailed=e.errorIndicatesMfaVerificationFailed,exports.getAccessToken=e.getCustomerAccessToken,exports.useCreateWallet=e.useCreateWallet,exports.useIdentityToken=e.useIdentityToken,exports.useImportWallet=e.useImportWallet,exports.useLogout=e.useLogout,exports.useMfa=e.useMfa,exports.useMfaEnrollment=e.useMfaEnrollment,exports.usePrivy=e.usePrivy,exports.useRegisterMfaListener=e.useRegisterMfaListener,exports.useSolanaWallets=e.useSolanaWallets,exports.useSyncJwtBasedAuthState=e.useSyncJwtBasedAuthState,exports.useWallets=e.useWallets,exports.useActiveWallet=o.useActiveWallet,exports.useConnectWallet=o.useConnectWallet,exports.useFundWallet=o.useFundWallet,exports.useLogin=o.useLogin,Object.defineProperty(exports,"SUPPORTED_CHAINS",{enumerable:!0,get:function(){return a.DEFAULT_SUPPORTED_CHAINS}}),Object.defineProperty(exports,"addPrivyRpcToChain",{enumerable:!0,get:function(){return a.addPrivyRpcToChain}}),Object.defineProperty(exports,"addRpcUrlOverrideToChain",{enumerable:!0,get:function(){return a.addRpcUrlOverrideToChain}}),exports.getEmbeddedConnectedWallet=u.getEmbeddedConnectedWallet,exports.useConnectCoinbaseSmartWallet=()=>{let{connectCoinbaseSmartWallet:e}=t.usePrivyInternal();return{connectCoinbaseSmartWallet:e}},exports.useConnectOrCreateWallet=r=>{let{connectOrCreateWallet:t}=e.usePrivyContext();return e.usePrivyEventSubscription("connectOrCreateWallet",r),{connectOrCreateWallet:t}},exports.useCrossAppAccounts=()=>{let{startCrossAppAuthFlow:r,unlinkCrossAppAccount:t,signMessageWithCrossAppWallet:o,signTypedDataWithCrossAppWallet:i,sendTransactionWithCrossAppWallet:n}=e.usePrivyContext();return{loginWithCrossAppAccount:({appId:e})=>r({appId:e,action:"login"}),linkCrossAppAccount:({appId:e})=>r({appId:e,action:"link"}),unlinkCrossAppAccount:t,signMessage:o,signTypedData:i,sendTransaction:n}},exports.useCustomAuth=r=>{let t=e.useJwtAuthFlowState();return e.usePrivyEventSubscription("customAuth",r),{status:t}},exports.useDelegatedActions=()=>{let{revokeDelegatedWallets:e,delegateWallet:r}=t.usePrivyInternal();return{delegateWallet:async({address:e,chainType:t})=>await r({address:e,chainType:t,showDelegationUIs:!0}),revokeWallets:async()=>await e({showDelegationUIs:!0})}},exports.useFarcasterSigner=function(){let{getFarcasterSignerPublicKey:r,signFarcasterMessage:t,requestFarcasterSignerFromWarpcast:o}=e.usePrivyContext();return{getFarcasterSignerPublicKey:r,signFarcasterMessage:t,requestFarcasterSignerFromWarpcast:o}},exports.useGuestAccounts=function(){let r=e.useAppConfig(),{getAccessToken:o}=e.usePrivyContext(),i=e.useEmitPrivyEvent(),{client:n,setUser:s,setAuthenticated:a,setIsNewUser:u,initializeWalletProxy:l}=t.usePrivyInternal(),{create:c}=e.useCreateWalletInternal();return{createGuestAccount:async()=>{if(!r.id||!n)throw Error("SDK not yet ready");n.startAuthFlow(new e.GuestFlow(r.id));try{let d=await n.authenticate(),h=d.user,p=d.isNewUser??!1;if(!h)throw new t.PrivyClientError("Unable to authenticate guest account");let y=await o(),C=await l(e.WALLET_PROXY_TIMEOUT);if(y&&C)try{let t=e.shouldCreateEmbeddedEthWallet(h,r.embeddedWallets.ethereum.createOnLogin),o=e.shouldCreateEmbeddedSolWallet(h,r.embeddedWallets.solana.createOnLogin);t&&o?(h=(await c({chainType:"ethereum",latestUser:h})).user,h=(await c({chainType:"solana",latestUser:h})).user):o?h=(await c({chainType:"solana",latestUser:h})).user:t?h=(await c({chainType:"ethereum",latestUser:h})).user:s(h)}catch(e){s(h),console.warn("Unable to create embedded wallet for guest account")}return u(p),a(!0),i("login","onComplete",{user:h,isNewUser:p,wasAlreadyAuthenticated:!1,loginMethod:"guest",loginAccount:null}),h}catch(e){throw i("login","onError",e.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),e}}}},exports.useHeadlessDelegatedActions=()=>{let{revokeDelegatedWallets:e,delegateWallet:r}=t.usePrivyInternal();return{delegateWallet:async({address:e,chainType:t})=>await r({address:e,chainType:t,showDelegationUIs:!1}),revokeWallets:async()=>await e({showDelegationUIs:!1})}},exports.useLinkAccount=function(t){let{linkEmail:o,linkPhone:i,linkWallet:n,linkGoogle:s,linkApple:a,linkTwitter:u,linkDiscord:l,linkGithub:c,linkLinkedIn:d,linkTiktok:h,linkSpotify:p,linkInstagram:y,linkTelegram:C,linkFarcaster:w}=r.useContext(e.PrivyContext);return e.usePrivyEventSubscription("linkAccount",t),{linkEmail:o,linkPhone:i,linkWallet:n,linkGoogle:s,linkApple:a,linkTwitter:u,linkDiscord:l,linkGithub:c,linkLinkedIn:d,linkTiktok:h,linkSpotify:p,linkInstagram:y,linkFarcaster:w,linkTelegram:C}},exports.useLinkWithPasskey=e=>{let{initLinkWithPasskey:o,linkWithPasskey:i,passkeyAuthState:n,setPasskeyAuthState:s}=t.usePrivyInternal();return{linkWithPasskey:r.useCallback((async()=>{try{await o();let r=await i();if(!r)throw Error("Error, user not found");let t=r.linkedAccounts.filter((e=>"passkey"===e.type)).sort(((e,r)=>r.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime()))[0];e?.onSuccess?.({user:r,linkMethod:"passkey",linkedAccount:t})}catch(r){throw s({status:"error",error:r}),e?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:"passkey"}),r}}),[i]),state:n}},exports.useLinkWithSiwe=o=>{let i=e.useCaptcha(),{siweState:n,setSiweState:s,linkWithSiwe:a,generateSiweMessage:u}=t.usePrivyInternal();return{generateSiweMessage:r.useCallback((async({address:e,chainId:r})=>{try{if(!e||!r)throw Error("wallet address and chainId required to generate nonce");return await u({address:e,chainId:r}).then((e=>e))}catch(e){throw s({status:"error",error:e}),o?.onError?.(e.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),e}}),[u]),linkWithSiwe:r.useCallback((async({signature:r,message:n,chainId:u,walletClientType:l,connectorType:c})=>{try{if(i.enabled&&"success"!==i.status)throw new e.CaptchaError(i.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);let{user:s,linkedAccount:d}=await a({message:n,signature:r,chainId:u,walletClientType:l,connectorType:c});d&&o?.onSuccess?.({user:s,linkMethod:"siwe",linkedAccount:d})}catch(r){throw s({status:"error",error:r}),o?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),r}}),[a,i.status]),state:n}},exports.useLoginWithEmail=o=>{let i=e.useCaptcha(),{emailOtpState:n,setEmailOtpState:s,initLoginWithEmail:a,loginWithCode:u}=t.usePrivyInternal();return{sendCode:r.useCallback((async({email:r,disableSignup:n})=>{try{let o;if(!r)throw Error("Email required to send OTP code");if(i.enabled&&"error"===i.status)throw new e.CaptchaError(i.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);return i.enabled&&"success"!==i.status&&(i.execute(),o=await i.waitForResult()),await a({email:r,captchaToken:o,disableSignup:n,withPrivyUi:!1})}catch(r){throw s({status:"error",error:r}),o?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[a]),loginWithCode:r.useCallback((async({code:r})=>{try{if(i.enabled&&"error"===i.status)throw new e.CaptchaError(i.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);let{user:n,isNewUser:s,wasAlreadyAuthenticated:a,linkedAccount:l}=await u(r);o?.onComplete?.({user:n,isNewUser:s,wasAlreadyAuthenticated:a,loginMethod:"email",loginAccount:l})}catch(r){throw s({status:"error",error:r}),o?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[u,i.status]),state:n}},exports.useLoginWithFarcasterV2=()=>{let{client:e,setAuthenticated:o,setUser:n}=t.usePrivyInternal();return r.useMemo((()=>({init:async()=>{if(!e)throw new t.PrivyClientError("Must initialize Privy client first.");let r=new i.FarcasterFramesFlow;return e.startAuthFlow(r),await r.init()},login:async({fid:r,message:s,signature:a})=>{if(!e)throw new t.PrivyClientError("Must initialize Privy client first.");if(!(e.authFlow instanceof i.FarcasterFramesFlow))throw new t.PrivyClientError("Must initialize Farcaster frame flow first.");e.authFlow.setAuthData({message:s,signature:a,fid:r});let{user:u}=await e.authenticate();if(!u)throw new t.PrivyClientError("Failed to login with Farcaster V2");return n(u),o(!0),{user:u}}})),[e,n,o])},exports.useLoginWithOAuth=o=>{e.usePrivyEventSubscription("login",o);let i=e.useCaptcha(),n=e.useIsServerConfigLoaded(),{ready:s,user:a}=e.usePrivyContext(),{initLoginWithHeadlessOAuth:u,loginWithHeadlessOAuth:l,oAuthState:c,setOAuthState:d,isHeadlessOAuthLoading:h}=t.usePrivyInternal(),p=r.useCallback((async r=>{try{if(i.enabled&&"success"!==i.status)throw new e.CaptchaError(i.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);return await u(r.provider,i.token,r.disableSignup)}catch(r){throw d({status:"error",error:r}),r}}),[u,i]),y=r.useCallback((async()=>{let r=e.detectCompletingOAuthFlow();try{if(a)return console.warn("Cannot login with OAuth when already logged in"),a;if(!r.inProgress)throw Error("Cannot login with OAuth because no OAuth flow is in progress");if(r.popupFlow)return}catch(r){throw d({status:"error",error:r}),r}try{return await l(r)}catch(r){throw d({status:"error",error:r}),r}finally{e.stripUrlOAuthParamsAndRemoveStateCode()}}),[l]);return r.useEffect((()=>{let r=e.detectCompletingOAuthFlow();s&&n&&r.inProgress&&!r.withPrivyUi&&!r.popupFlow&&y().catch((()=>{}))}),[s,n]),{initOAuth:p,loading:h,state:c}},exports.useLoginWithPasskey=o=>{let i=e.useCaptcha(),{initLoginWithPasskey:n,loginWithPasskey:s,passkeyAuthState:a,setPasskeyAuthState:u}=t.usePrivyInternal();return{loginWithPasskey:r.useCallback((async r=>{try{let a;if(i.enabled&&"error"===i.status)throw new e.CaptchaError(i.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);i.enabled&&"success"!==i.status&&(i.execute(),a=await i.waitForResult()),await n({captchaToken:a,withPrivyUi:!1});let{user:u,isNewUser:l,wasAlreadyAuthenticated:c,loginAccount:d}=await s(r);o?.onComplete?.({user:u,isNewUser:l,wasAlreadyAuthenticated:c,loginMethod:"passkey",loginAccount:d})}catch(r){throw u({status:"error",error:r}),o?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[s,i.status]),state:a}},exports.useLoginWithSms=o=>{let i=e.useCaptcha(),{smsOtpState:n,setSmsOtpState:s,initLoginWithSms:a,loginWithCode:u}=t.usePrivyInternal();return{sendCode:r.useCallback((async({phoneNumber:r,disableSignup:n})=>{try{let o;if(!r)throw Error("SMS required to send OTP code");if(i.enabled&&"error"===i.status)throw new e.CaptchaError(i.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);return i.enabled&&"success"!==i.status&&(i.execute(),o=await i.waitForResult()),await a({phoneNumber:r,captchaToken:o,disableSignup:n,withPrivyUi:!1})}catch(r){throw s({status:"error",error:r}),o?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[a]),loginWithCode:r.useCallback((async({code:r})=>{try{if(i.enabled&&"success"!==i.status)throw new e.CaptchaError(i.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);let{user:n,isNewUser:s,wasAlreadyAuthenticated:a,linkedAccount:l}=await u(r);o?.onComplete?.({user:n,isNewUser:s,wasAlreadyAuthenticated:a,loginMethod:"sms",loginAccount:l})}catch(r){throw s({status:"error",error:r}),o?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[u,i.status]),state:n}},exports.useLoginWithTelegram=o=>{let i=e.useCaptcha(),{initLoginWithTelegram:n,loginWithTelegram:s,telegramAuthState:a,setTelegramAuthState:u}=t.usePrivyInternal();return{login:r.useCallback((async r=>{try{if(i.enabled&&"success"!==i.status)throw new e.CaptchaError(i.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);await n(i.token,r?.disableSignup);let{user:a,isNewUser:u,loginAccount:l,wasAlreadyAuthenticated:c}=await s({intent:"login"});o?.onComplete?.({user:a,isNewUser:u,wasAlreadyAuthenticated:c,loginMethod:"telegram",loginAccount:l})}catch(r){throw u({status:"error",error:r}),o?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[n,s,i]),state:a}},exports.useModalStatus=()=>{let{isModalOpen:t}=r.useContext(e.PrivyContext);return{isOpen:t}},exports.useOAuthTokens=function(r){let{authenticated:o,user:i}=e.usePrivyContext(),{initLoginWithOAuth:n}=t.usePrivyInternal(),s=e.useEmitPrivyEvent();return e.usePrivyEventSubscription("oAuthAuthorization",r),{reauthorize:e=>l(o,i,n,s,e.provider)}},exports.useRecoverEmbeddedWallet=()=>{let{user:o}=e.usePrivyContext(),{walletProxy:i}=t.usePrivyInternal();return{recover:r.useCallback((async r=>{if(!i)throw Error("Wallet proxy is not ready");let n=await e.getAccessToken();if(!o||!n)throw new t.PrivyClientError("User must be logged in before attempting to modify the recovery method.");let{entropyId:s,entropyIdVerifier:a}=e.getEntropyDetailsForUser(o);try{await i.recover({entropyId:s,entropyIdVerifier:a,accessToken:n,...r})}catch{throw new t.PrivyClientError("Unable to recover wallets")}}),[i,o])}},exports.useSendTransaction=function(t){let{sendTransaction:o}=r.useContext(e.PrivyContext);return e.usePrivyEventSubscription("sendTransaction",t),{sendTransaction:o}},exports.useSetWalletPassword=function(t){let{setWalletPassword:o}=r.useContext(e.PrivyContext);return e.usePrivyEventSubscription("setWalletPassword",t),{setWalletPassword:o}},exports.useSetWalletRecovery=function(t){let{setWalletRecovery:o}=r.useContext(e.PrivyContext);return e.usePrivyEventSubscription("setWalletRecovery",t),{setWalletRecovery:o}},exports.useSignAuthorization=()=>{let{ready:o,wallets:i}=e.useWallets(),{user:a}=e.usePrivyContext(),{rpcConfig:u,chains:l,appId:c}=t.usePrivyInternal();return{signAuthorization:r.useCallback((async(r,t)=>{if(!a)throw Error("User must be authenticated before signing with a Privy wallet");if(!o)throw Error("Wallets are not ready");let d=t?.address??e.getPrivyEthereumWallet(a)?.address??n.zeroAddress,h=i.find((e=>n.getAddress(e.address)===n.getAddress(d)));if(!h)throw Error("Signing wallet not found.");let p=r.chainId??Number(h.chainId.split(":")[1]),y=l.find((e=>e.id===p));if(!y)throw Error("Error, chain not configured in PrivyProvider config");let C=n.createWalletClient({account:d,chain:y,transport:n.http(e.getJsonRpcEndpointFromChain(y,u,c))}),w=await C.prepareAuthorization({...r}),g=await h.getEthereumProvider(),A=await g.request({method:"secp256k1_sign",params:[s.hashAuthorization(w)]});return{...w,...n.parseSignature(A)}}),[o,i,a,l])}},exports.useSignMessage=function(t){let{signMessage:o}=r.useContext(e.PrivyContext);return e.usePrivyEventSubscription("signMessage",t),{signMessage:o}},exports.useSignTransaction=function(){let{signTransaction:t}=r.useContext(e.PrivyContext);return{signTransaction:t}},exports.useSignTypedData=function(t){let{signTypedData:o}=r.useContext(e.PrivyContext);return e.usePrivyEventSubscription("signTypedData",t),{signTypedData:o}},exports.useSignupWithPasskey=o=>{let i=e.useCaptcha(),{initSignupWithPasskey:n,signupWithPasskey:s,passkeyAuthState:a,setPasskeyAuthState:u}=t.usePrivyInternal();return{signupWithPasskey:r.useCallback((async()=>{try{let r;if(i.enabled&&"error"===i.status)throw new e.CaptchaError(i.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);i.enabled&&"success"!==i.status&&(i.execute(),r=await i.waitForResult()),await n({captchaToken:r,withPrivyUi:!1});let{user:a,isNewUser:u,wasAlreadyAuthenticated:l,loginAccount:c}=await s();o?.onComplete?.({user:a,isNewUser:u,wasAlreadyAuthenticated:l,loginMethod:"passkey",loginAccount:c})}catch(e){throw u({status:"error",error:e}),o?.onError?.(e.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),e}}),[s,i.status]),state:a}},exports.useSubscribeToJwtAuthWithFlag=function({isAuthenticated:t,isLoading:o,...i}){let n=r.useRef();r.useEffect((()=>{o||n.current?.()}),[t,o]);let s=r.useCallback((e=>(n.current=e,()=>{n.current=void 0})),[]);return e.useSyncJwtBasedAuthState({...i,subscribe:s})},exports.useToken=function(t){let{getAccessToken:o}=r.useContext(e.PrivyContext);return e.usePrivyEventSubscription("accessToken",t),{getAccessToken:o}},exports.useUpdateAccount=function(t){let{updateEmail:o,updatePhone:i}=r.useContext(e.PrivyContext);return e.usePrivyEventSubscription("update",t),{updateEmail:o,updatePhone:i}},exports.useUser=()=>{let{setUser:o,client:i}=r.useContext(t.InternalPrivyContext),{user:n}=r.useContext(e.PrivyContext);return{user:n,refreshUser:r.useCallback((async()=>{let e=await(i?.updateUserAndIdToken());return o(e??null),e}),[i,o])}};
