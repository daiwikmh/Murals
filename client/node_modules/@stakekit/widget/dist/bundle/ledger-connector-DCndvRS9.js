var ln = Object.defineProperty;
var hn = (n, e, t) => e in n ? ln(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t;
var T = (n, e, t) => hn(n, typeof e != "symbol" ? e + "" : e, t);
import { I as mn, _ as pn, S as fn, J as v, n as V, K as gn, L as At, w as _e, N as we, r as yn, O as Dt, t as vn, y as Fe, M as ve, Q as _t, R as _n } from "./en_US-FEVFXARA-Bt5B3GiI.js";
import { E as xn } from "./events-CnywZz7I.js";
import { L as wn } from "./index-Chfa4EHr.js";
function bn(n) {
  return mn(n == null ? void 0 : n.lift);
}
function En(n) {
  return function(e) {
    if (bn(e))
      return e.lift(function(t) {
        try {
          return n(t, this);
        } catch (r) {
          this.error(r);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function Tn(n, e, t, r, s) {
  return new Sn(n, e, t, r, s);
}
var Sn = function(n) {
  pn(e, n);
  function e(t, r, s, a, o, c) {
    var l = n.call(this, t) || this;
    return l.onFinalize = o, l.shouldUnsubscribe = c, l._next = r ? function(h) {
      try {
        r(h);
      } catch (p) {
        t.error(p);
      }
    } : n.prototype._next, l._error = a ? function(h) {
      try {
        a(h);
      } catch (p) {
        t.error(p);
      } finally {
        this.unsubscribe();
      }
    } : n.prototype._error, l._complete = s ? function() {
      try {
        s();
      } catch (h) {
        t.error(h);
      } finally {
        this.unsubscribe();
      }
    } : n.prototype._complete, l;
  }
  return e.prototype.unsubscribe = function() {
    var t;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var r = this.closed;
      n.prototype.unsubscribe.call(this), !r && ((t = this.onFinalize) === null || t === void 0 || t.call(this));
    }
  }, e;
}(fn);
function Rn(n, e) {
  return En(function(t, r) {
    var s = 0;
    t.subscribe(Tn(r, function(a) {
      r.next(n.call(e, a, s++));
    }));
  });
}
function xt({ id: n, name: e, address: t, currency: r, balance: s, spendableBalance: a, blockHeight: o, lastSyncDate: c, parentAccountId: l }) {
  return {
    id: n,
    name: e,
    address: t,
    currency: r,
    balance: new v(s),
    spendableBalance: new v(a),
    blockHeight: o,
    lastSyncDate: new Date(c),
    parentAccountId: l
  };
}
var S;
(function(n) {
  n.assertEqual = (s) => s;
  function e(s) {
  }
  n.assertIs = e;
  function t(s) {
    throw new Error();
  }
  n.assertNever = t, n.arrayToEnum = (s) => {
    const a = {};
    for (const o of s)
      a[o] = o;
    return a;
  }, n.getValidEnumValues = (s) => {
    const a = n.objectKeys(s).filter((c) => typeof s[s[c]] != "number"), o = {};
    for (const c of a)
      o[c] = s[c];
    return n.objectValues(o);
  }, n.objectValues = (s) => n.objectKeys(s).map(function(a) {
    return s[a];
  }), n.objectKeys = typeof Object.keys == "function" ? (s) => Object.keys(s) : (s) => {
    const a = [];
    for (const o in s)
      Object.prototype.hasOwnProperty.call(s, o) && a.push(o);
    return a;
  }, n.find = (s, a) => {
    for (const o of s)
      if (a(o))
        return o;
  }, n.isInteger = typeof Number.isInteger == "function" ? (s) => Number.isInteger(s) : (s) => typeof s == "number" && isFinite(s) && Math.floor(s) === s;
  function r(s, a = " | ") {
    return s.map((o) => typeof o == "string" ? `'${o}'` : o).join(a);
  }
  n.joinValues = r, n.jsonStringifyReplacer = (s, a) => typeof a == "bigint" ? a.toString() : a;
})(S || (S = {}));
var it;
(function(n) {
  n.mergeShapes = (e, t) => ({
    ...e,
    ...t
    // second overwrites first
  });
})(it || (it = {}));
const f = S.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), X = (n) => {
  switch (typeof n) {
    case "undefined":
      return f.undefined;
    case "string":
      return f.string;
    case "number":
      return isNaN(n) ? f.nan : f.number;
    case "boolean":
      return f.boolean;
    case "function":
      return f.function;
    case "bigint":
      return f.bigint;
    case "symbol":
      return f.symbol;
    case "object":
      return Array.isArray(n) ? f.array : n === null ? f.null : n.then && typeof n.then == "function" && n.catch && typeof n.catch == "function" ? f.promise : typeof Map < "u" && n instanceof Map ? f.map : typeof Set < "u" && n instanceof Set ? f.set : typeof Date < "u" && n instanceof Date ? f.date : f.object;
    default:
      return f.unknown;
  }
}, m = S.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), Cn = (n) => JSON.stringify(n, null, 2).replace(/"([^"]+)":/g, "$1:");
class Z extends Error {
  constructor(e) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const t = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, t) : this.__proto__ = t, this.name = "ZodError", this.issues = e;
  }
  get errors() {
    return this.issues;
  }
  format(e) {
    const t = e || function(a) {
      return a.message;
    }, r = { _errors: [] }, s = (a) => {
      for (const o of a.issues)
        if (o.code === "invalid_union")
          o.unionErrors.map(s);
        else if (o.code === "invalid_return_type")
          s(o.returnTypeError);
        else if (o.code === "invalid_arguments")
          s(o.argumentsError);
        else if (o.path.length === 0)
          r._errors.push(t(o));
        else {
          let c = r, l = 0;
          for (; l < o.path.length; ) {
            const h = o.path[l];
            l === o.path.length - 1 ? (c[h] = c[h] || { _errors: [] }, c[h]._errors.push(t(o))) : c[h] = c[h] || { _errors: [] }, c = c[h], l++;
          }
        }
    };
    return s(this), r;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, S.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (t) => t.message) {
    const t = {}, r = [];
    for (const s of this.issues)
      s.path.length > 0 ? (t[s.path[0]] = t[s.path[0]] || [], t[s.path[0]].push(e(s))) : r.push(e(s));
    return { formErrors: r, fieldErrors: t };
  }
  get formErrors() {
    return this.flatten();
  }
}
Z.create = (n) => new Z(n);
const Ee = (n, e) => {
  let t;
  switch (n.code) {
    case m.invalid_type:
      n.received === f.undefined ? t = "Required" : t = `Expected ${n.expected}, received ${n.received}`;
      break;
    case m.invalid_literal:
      t = `Invalid literal value, expected ${JSON.stringify(n.expected, S.jsonStringifyReplacer)}`;
      break;
    case m.unrecognized_keys:
      t = `Unrecognized key(s) in object: ${S.joinValues(n.keys, ", ")}`;
      break;
    case m.invalid_union:
      t = "Invalid input";
      break;
    case m.invalid_union_discriminator:
      t = `Invalid discriminator value. Expected ${S.joinValues(n.options)}`;
      break;
    case m.invalid_enum_value:
      t = `Invalid enum value. Expected ${S.joinValues(n.options)}, received '${n.received}'`;
      break;
    case m.invalid_arguments:
      t = "Invalid function arguments";
      break;
    case m.invalid_return_type:
      t = "Invalid function return type";
      break;
    case m.invalid_date:
      t = "Invalid date";
      break;
    case m.invalid_string:
      typeof n.validation == "object" ? "includes" in n.validation ? (t = `Invalid input: must include "${n.validation.includes}"`, typeof n.validation.position == "number" && (t = `${t} at one or more positions greater than or equal to ${n.validation.position}`)) : "startsWith" in n.validation ? t = `Invalid input: must start with "${n.validation.startsWith}"` : "endsWith" in n.validation ? t = `Invalid input: must end with "${n.validation.endsWith}"` : S.assertNever(n.validation) : n.validation !== "regex" ? t = `Invalid ${n.validation}` : t = "Invalid";
      break;
    case m.too_small:
      n.type === "array" ? t = `Array must contain ${n.exact ? "exactly" : n.inclusive ? "at least" : "more than"} ${n.minimum} element(s)` : n.type === "string" ? t = `String must contain ${n.exact ? "exactly" : n.inclusive ? "at least" : "over"} ${n.minimum} character(s)` : n.type === "number" ? t = `Number must be ${n.exact ? "exactly equal to " : n.inclusive ? "greater than or equal to " : "greater than "}${n.minimum}` : n.type === "date" ? t = `Date must be ${n.exact ? "exactly equal to " : n.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(n.minimum))}` : t = "Invalid input";
      break;
    case m.too_big:
      n.type === "array" ? t = `Array must contain ${n.exact ? "exactly" : n.inclusive ? "at most" : "less than"} ${n.maximum} element(s)` : n.type === "string" ? t = `String must contain ${n.exact ? "exactly" : n.inclusive ? "at most" : "under"} ${n.maximum} character(s)` : n.type === "number" ? t = `Number must be ${n.exact ? "exactly" : n.inclusive ? "less than or equal to" : "less than"} ${n.maximum}` : n.type === "bigint" ? t = `BigInt must be ${n.exact ? "exactly" : n.inclusive ? "less than or equal to" : "less than"} ${n.maximum}` : n.type === "date" ? t = `Date must be ${n.exact ? "exactly" : n.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(n.maximum))}` : t = "Invalid input";
      break;
    case m.custom:
      t = "Invalid input";
      break;
    case m.invalid_intersection_types:
      t = "Intersection results could not be merged";
      break;
    case m.not_multiple_of:
      t = `Number must be a multiple of ${n.multipleOf}`;
      break;
    case m.not_finite:
      t = "Number must be finite";
      break;
    default:
      t = e.defaultError, S.assertNever(n);
  }
  return { message: t };
};
let Pt = Ee;
function Nn(n) {
  Pt = n;
}
function qe() {
  return Pt;
}
const We = (n) => {
  const { data: e, path: t, errorMaps: r, issueData: s } = n, a = [...t, ...s.path || []], o = {
    ...s,
    path: a
  };
  let c = "";
  const l = r.filter((h) => !!h).slice().reverse();
  for (const h of l)
    c = h(o, { data: e, defaultError: c }).message;
  return {
    ...s,
    path: a,
    message: s.message || c
  };
}, In = [];
function g(n, e) {
  const t = We({
    issueData: e,
    data: n.data,
    path: n.path,
    errorMaps: [
      n.common.contextualErrorMap,
      n.schemaErrorMap,
      qe(),
      Ee
      // then global default map
    ].filter((r) => !!r)
  });
  n.common.issues.push(t);
}
class D {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, t) {
    const r = [];
    for (const s of t) {
      if (s.status === "aborted")
        return x;
      s.status === "dirty" && e.dirty(), r.push(s.value);
    }
    return { status: e.value, value: r };
  }
  static async mergeObjectAsync(e, t) {
    const r = [];
    for (const s of t)
      r.push({
        key: await s.key,
        value: await s.value
      });
    return D.mergeObjectSync(e, r);
  }
  static mergeObjectSync(e, t) {
    const r = {};
    for (const s of t) {
      const { key: a, value: o } = s;
      if (a.status === "aborted" || o.status === "aborted")
        return x;
      a.status === "dirty" && e.dirty(), o.status === "dirty" && e.dirty(), a.value !== "__proto__" && (typeof o.value < "u" || s.alwaysSet) && (r[a.value] = o.value);
    }
    return { status: e.value, value: r };
  }
}
const x = Object.freeze({
  status: "aborted"
}), Lt = (n) => ({ status: "dirty", value: n }), P = (n) => ({ status: "valid", value: n }), ot = (n) => n.status === "aborted", ct = (n) => n.status === "dirty", Te = (n) => n.status === "valid", He = (n) => typeof Promise < "u" && n instanceof Promise;
var y;
(function(n) {
  n.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, n.toString = (e) => typeof e == "string" ? e : e == null ? void 0 : e.message;
})(y || (y = {}));
class $ {
  constructor(e, t, r, s) {
    this._cachedPath = [], this.parent = e, this.data = t, this._path = r, this._key = s;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const wt = (n, e) => {
  if (Te(e))
    return { success: !0, data: e.value };
  if (!n.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const t = new Z(n.common.issues);
      return this._error = t, this._error;
    }
  };
};
function w(n) {
  if (!n)
    return {};
  const { errorMap: e, invalid_type_error: t, required_error: r, description: s } = n;
  if (e && (t || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: s } : { errorMap: (o, c) => o.code !== "invalid_type" ? { message: c.defaultError } : typeof c.data > "u" ? { message: r ?? c.defaultError } : { message: t ?? c.defaultError }, description: s };
}
class E {
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return X(e.data);
  }
  _getOrReturnCtx(e, t) {
    return t || {
      common: e.parent.common,
      data: e.data,
      parsedType: X(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new D(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: X(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const t = this._parse(e);
    if (He(t))
      throw new Error("Synchronous parse encountered promise.");
    return t;
  }
  _parseAsync(e) {
    const t = this._parse(e);
    return Promise.resolve(t);
  }
  parse(e, t) {
    const r = this.safeParse(e, t);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(e, t) {
    var r;
    const s = {
      common: {
        issues: [],
        async: (r = t == null ? void 0 : t.async) !== null && r !== void 0 ? r : !1,
        contextualErrorMap: t == null ? void 0 : t.errorMap
      },
      path: (t == null ? void 0 : t.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: X(e)
    }, a = this._parseSync({ data: e, path: s.path, parent: s });
    return wt(s, a);
  }
  async parseAsync(e, t) {
    const r = await this.safeParseAsync(e, t);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(e, t) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: t == null ? void 0 : t.errorMap,
        async: !0
      },
      path: (t == null ? void 0 : t.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: X(e)
    }, s = this._parse({ data: e, path: r.path, parent: r }), a = await (He(s) ? s : Promise.resolve(s));
    return wt(r, a);
  }
  refine(e, t) {
    const r = (s) => typeof t == "string" || typeof t > "u" ? { message: t } : typeof t == "function" ? t(s) : t;
    return this._refinement((s, a) => {
      const o = e(s), c = () => a.addIssue({
        code: m.custom,
        ...r(s)
      });
      return typeof Promise < "u" && o instanceof Promise ? o.then((l) => l ? !0 : (c(), !1)) : o ? !0 : (c(), !1);
    });
  }
  refinement(e, t) {
    return this._refinement((r, s) => e(r) ? !0 : (s.addIssue(typeof t == "function" ? t(r, s) : t), !1));
  }
  _refinement(e) {
    return new B({
      schema: this,
      typeName: _.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  optional() {
    return K.create(this, this._def);
  }
  nullable() {
    return ie.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return F.create(this, this._def);
  }
  promise() {
    return me.create(this, this._def);
  }
  or(e) {
    return Ne.create([this, e], this._def);
  }
  and(e) {
    return Ie.create(this, e, this._def);
  }
  transform(e) {
    return new B({
      ...w(this._def),
      schema: this,
      typeName: _.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const t = typeof e == "function" ? e : () => e;
    return new Pe({
      ...w(this._def),
      innerType: this,
      defaultValue: t,
      typeName: _.ZodDefault
    });
  }
  brand() {
    return new Ut({
      typeName: _.ZodBranded,
      type: this,
      ...w(this._def)
    });
  }
  catch(e) {
    const t = typeof e == "function" ? e : () => e;
    return new Xe({
      ...w(this._def),
      innerType: this,
      catchValue: t,
      typeName: _.ZodCatch
    });
  }
  describe(e) {
    const t = this.constructor;
    return new t({
      ...this._def,
      description: e
    });
  }
  pipe(e) {
    return Le.create(this, e);
  }
  readonly() {
    return Qe.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const kn = /^c[^\s-]{8,}$/i, On = /^[a-z][a-z0-9]*$/, An = /^[0-9A-HJKMNP-TV-Z]{26}$/, Dn = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, Pn = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, Ln = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let st;
const Mn = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, Un = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, jn = (n) => n.precision ? n.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${n.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${n.precision}}Z$`) : n.precision === 0 ? n.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : n.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function Zn(n, e) {
  return !!((e === "v4" || !e) && Mn.test(n) || (e === "v6" || !e) && Un.test(n));
}
class j extends E {
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== f.string) {
      const a = this._getOrReturnCtx(e);
      return g(
        a,
        {
          code: m.invalid_type,
          expected: f.string,
          received: a.parsedType
        }
        //
      ), x;
    }
    const r = new D();
    let s;
    for (const a of this._def.checks)
      if (a.kind === "min")
        e.data.length < a.value && (s = this._getOrReturnCtx(e, s), g(s, {
          code: m.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), r.dirty());
      else if (a.kind === "max")
        e.data.length > a.value && (s = this._getOrReturnCtx(e, s), g(s, {
          code: m.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), r.dirty());
      else if (a.kind === "length") {
        const o = e.data.length > a.value, c = e.data.length < a.value;
        (o || c) && (s = this._getOrReturnCtx(e, s), o ? g(s, {
          code: m.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }) : c && g(s, {
          code: m.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }), r.dirty());
      } else if (a.kind === "email")
        Pn.test(e.data) || (s = this._getOrReturnCtx(e, s), g(s, {
          validation: "email",
          code: m.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "emoji")
        st || (st = new RegExp(Ln, "u")), st.test(e.data) || (s = this._getOrReturnCtx(e, s), g(s, {
          validation: "emoji",
          code: m.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "uuid")
        Dn.test(e.data) || (s = this._getOrReturnCtx(e, s), g(s, {
          validation: "uuid",
          code: m.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "cuid")
        kn.test(e.data) || (s = this._getOrReturnCtx(e, s), g(s, {
          validation: "cuid",
          code: m.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "cuid2")
        On.test(e.data) || (s = this._getOrReturnCtx(e, s), g(s, {
          validation: "cuid2",
          code: m.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "ulid")
        An.test(e.data) || (s = this._getOrReturnCtx(e, s), g(s, {
          validation: "ulid",
          code: m.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "url")
        try {
          new URL(e.data);
        } catch {
          s = this._getOrReturnCtx(e, s), g(s, {
            validation: "url",
            code: m.invalid_string,
            message: a.message
          }), r.dirty();
        }
      else a.kind === "regex" ? (a.regex.lastIndex = 0, a.regex.test(e.data) || (s = this._getOrReturnCtx(e, s), g(s, {
        validation: "regex",
        code: m.invalid_string,
        message: a.message
      }), r.dirty())) : a.kind === "trim" ? e.data = e.data.trim() : a.kind === "includes" ? e.data.includes(a.value, a.position) || (s = this._getOrReturnCtx(e, s), g(s, {
        code: m.invalid_string,
        validation: { includes: a.value, position: a.position },
        message: a.message
      }), r.dirty()) : a.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : a.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : a.kind === "startsWith" ? e.data.startsWith(a.value) || (s = this._getOrReturnCtx(e, s), g(s, {
        code: m.invalid_string,
        validation: { startsWith: a.value },
        message: a.message
      }), r.dirty()) : a.kind === "endsWith" ? e.data.endsWith(a.value) || (s = this._getOrReturnCtx(e, s), g(s, {
        code: m.invalid_string,
        validation: { endsWith: a.value },
        message: a.message
      }), r.dirty()) : a.kind === "datetime" ? jn(a).test(e.data) || (s = this._getOrReturnCtx(e, s), g(s, {
        code: m.invalid_string,
        validation: "datetime",
        message: a.message
      }), r.dirty()) : a.kind === "ip" ? Zn(e.data, a.version) || (s = this._getOrReturnCtx(e, s), g(s, {
        validation: "ip",
        code: m.invalid_string,
        message: a.message
      }), r.dirty()) : S.assertNever(a);
    return { status: r.value, value: e.data };
  }
  _regex(e, t, r) {
    return this.refinement((s) => e.test(s), {
      validation: t,
      code: m.invalid_string,
      ...y.errToObj(r)
    });
  }
  _addCheck(e) {
    return new j({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...y.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...y.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ...y.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...y.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...y.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...y.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ...y.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ...y.errToObj(e) });
  }
  datetime(e) {
    var t;
    return typeof e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
      offset: (t = e == null ? void 0 : e.offset) !== null && t !== void 0 ? t : !1,
      ...y.errToObj(e == null ? void 0 : e.message)
    });
  }
  regex(e, t) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...y.errToObj(t)
    });
  }
  includes(e, t) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: t == null ? void 0 : t.position,
      ...y.errToObj(t == null ? void 0 : t.message)
    });
  }
  startsWith(e, t) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...y.errToObj(t)
    });
  }
  endsWith(e, t) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...y.errToObj(t)
    });
  }
  min(e, t) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...y.errToObj(t)
    });
  }
  max(e, t) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...y.errToObj(t)
    });
  }
  length(e, t) {
    return this._addCheck({
      kind: "length",
      value: e,
      ...y.errToObj(t)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(e) {
    return this.min(1, y.errToObj(e));
  }
  trim() {
    return new j({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new j({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new j({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get minLength() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
}
j.create = (n) => {
  var e;
  return new j({
    checks: [],
    typeName: _.ZodString,
    coerce: (e = n == null ? void 0 : n.coerce) !== null && e !== void 0 ? e : !1,
    ...w(n)
  });
};
function Fn(n, e) {
  const t = (n.toString().split(".")[1] || "").length, r = (e.toString().split(".")[1] || "").length, s = t > r ? t : r, a = parseInt(n.toFixed(s).replace(".", "")), o = parseInt(e.toFixed(s).replace(".", ""));
  return a % o / Math.pow(10, s);
}
class J extends E {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== f.number) {
      const a = this._getOrReturnCtx(e);
      return g(a, {
        code: m.invalid_type,
        expected: f.number,
        received: a.parsedType
      }), x;
    }
    let r;
    const s = new D();
    for (const a of this._def.checks)
      a.kind === "int" ? S.isInteger(e.data) || (r = this._getOrReturnCtx(e, r), g(r, {
        code: m.invalid_type,
        expected: "integer",
        received: "float",
        message: a.message
      }), s.dirty()) : a.kind === "min" ? (a.inclusive ? e.data < a.value : e.data <= a.value) && (r = this._getOrReturnCtx(e, r), g(r, {
        code: m.too_small,
        minimum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), s.dirty()) : a.kind === "max" ? (a.inclusive ? e.data > a.value : e.data >= a.value) && (r = this._getOrReturnCtx(e, r), g(r, {
        code: m.too_big,
        maximum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), s.dirty()) : a.kind === "multipleOf" ? Fn(e.data, a.value) !== 0 && (r = this._getOrReturnCtx(e, r), g(r, {
        code: m.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), s.dirty()) : a.kind === "finite" ? Number.isFinite(e.data) || (r = this._getOrReturnCtx(e, r), g(r, {
        code: m.not_finite,
        message: a.message
      }), s.dirty()) : S.assertNever(a);
    return { status: s.value, value: e.data };
  }
  gte(e, t) {
    return this.setLimit("min", e, !0, y.toString(t));
  }
  gt(e, t) {
    return this.setLimit("min", e, !1, y.toString(t));
  }
  lte(e, t) {
    return this.setLimit("max", e, !0, y.toString(t));
  }
  lt(e, t) {
    return this.setLimit("max", e, !1, y.toString(t));
  }
  setLimit(e, t, r, s) {
    return new J({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: t,
          inclusive: r,
          message: y.toString(s)
        }
      ]
    });
  }
  _addCheck(e) {
    return new J({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: y.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: y.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: y.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: y.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: y.toString(e)
    });
  }
  multipleOf(e, t) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: y.toString(t)
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: y.toString(e)
    });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: y.toString(e)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: y.toString(e)
    });
  }
  get minValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && S.isInteger(e.value));
  }
  get isFinite() {
    let e = null, t = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return !0;
      r.kind === "min" ? (t === null || r.value > t) && (t = r.value) : r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    }
    return Number.isFinite(t) && Number.isFinite(e);
  }
}
J.create = (n) => new J({
  checks: [],
  typeName: _.ZodNumber,
  coerce: (n == null ? void 0 : n.coerce) || !1,
  ...w(n)
});
class Q extends E {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = BigInt(e.data)), this._getType(e) !== f.bigint) {
      const a = this._getOrReturnCtx(e);
      return g(a, {
        code: m.invalid_type,
        expected: f.bigint,
        received: a.parsedType
      }), x;
    }
    let r;
    const s = new D();
    for (const a of this._def.checks)
      a.kind === "min" ? (a.inclusive ? e.data < a.value : e.data <= a.value) && (r = this._getOrReturnCtx(e, r), g(r, {
        code: m.too_small,
        type: "bigint",
        minimum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), s.dirty()) : a.kind === "max" ? (a.inclusive ? e.data > a.value : e.data >= a.value) && (r = this._getOrReturnCtx(e, r), g(r, {
        code: m.too_big,
        type: "bigint",
        maximum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), s.dirty()) : a.kind === "multipleOf" ? e.data % a.value !== BigInt(0) && (r = this._getOrReturnCtx(e, r), g(r, {
        code: m.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), s.dirty()) : S.assertNever(a);
    return { status: s.value, value: e.data };
  }
  gte(e, t) {
    return this.setLimit("min", e, !0, y.toString(t));
  }
  gt(e, t) {
    return this.setLimit("min", e, !1, y.toString(t));
  }
  lte(e, t) {
    return this.setLimit("max", e, !0, y.toString(t));
  }
  lt(e, t) {
    return this.setLimit("max", e, !1, y.toString(t));
  }
  setLimit(e, t, r, s) {
    return new Q({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: t,
          inclusive: r,
          message: y.toString(s)
        }
      ]
    });
  }
  _addCheck(e) {
    return new Q({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: y.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: y.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: y.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: y.toString(e)
    });
  }
  multipleOf(e, t) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: y.toString(t)
    });
  }
  get minValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
}
Q.create = (n) => {
  var e;
  return new Q({
    checks: [],
    typeName: _.ZodBigInt,
    coerce: (e = n == null ? void 0 : n.coerce) !== null && e !== void 0 ? e : !1,
    ...w(n)
  });
};
class Se extends E {
  _parse(e) {
    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== f.boolean) {
      const r = this._getOrReturnCtx(e);
      return g(r, {
        code: m.invalid_type,
        expected: f.boolean,
        received: r.parsedType
      }), x;
    }
    return P(e.data);
  }
}
Se.create = (n) => new Se({
  typeName: _.ZodBoolean,
  coerce: (n == null ? void 0 : n.coerce) || !1,
  ...w(n)
});
class se extends E {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== f.date) {
      const a = this._getOrReturnCtx(e);
      return g(a, {
        code: m.invalid_type,
        expected: f.date,
        received: a.parsedType
      }), x;
    }
    if (isNaN(e.data.getTime())) {
      const a = this._getOrReturnCtx(e);
      return g(a, {
        code: m.invalid_date
      }), x;
    }
    const r = new D();
    let s;
    for (const a of this._def.checks)
      a.kind === "min" ? e.data.getTime() < a.value && (s = this._getOrReturnCtx(e, s), g(s, {
        code: m.too_small,
        message: a.message,
        inclusive: !0,
        exact: !1,
        minimum: a.value,
        type: "date"
      }), r.dirty()) : a.kind === "max" ? e.data.getTime() > a.value && (s = this._getOrReturnCtx(e, s), g(s, {
        code: m.too_big,
        message: a.message,
        inclusive: !0,
        exact: !1,
        maximum: a.value,
        type: "date"
      }), r.dirty()) : S.assertNever(a);
    return {
      status: r.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new se({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, t) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: y.toString(t)
    });
  }
  max(e, t) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: y.toString(t)
    });
  }
  get minDate() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e != null ? new Date(e) : null;
  }
}
se.create = (n) => new se({
  checks: [],
  coerce: (n == null ? void 0 : n.coerce) || !1,
  typeName: _.ZodDate,
  ...w(n)
});
class Ge extends E {
  _parse(e) {
    if (this._getType(e) !== f.symbol) {
      const r = this._getOrReturnCtx(e);
      return g(r, {
        code: m.invalid_type,
        expected: f.symbol,
        received: r.parsedType
      }), x;
    }
    return P(e.data);
  }
}
Ge.create = (n) => new Ge({
  typeName: _.ZodSymbol,
  ...w(n)
});
class Re extends E {
  _parse(e) {
    if (this._getType(e) !== f.undefined) {
      const r = this._getOrReturnCtx(e);
      return g(r, {
        code: m.invalid_type,
        expected: f.undefined,
        received: r.parsedType
      }), x;
    }
    return P(e.data);
  }
}
Re.create = (n) => new Re({
  typeName: _.ZodUndefined,
  ...w(n)
});
class Ce extends E {
  _parse(e) {
    if (this._getType(e) !== f.null) {
      const r = this._getOrReturnCtx(e);
      return g(r, {
        code: m.invalid_type,
        expected: f.null,
        received: r.parsedType
      }), x;
    }
    return P(e.data);
  }
}
Ce.create = (n) => new Ce({
  typeName: _.ZodNull,
  ...w(n)
});
class he extends E {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(e) {
    return P(e.data);
  }
}
he.create = (n) => new he({
  typeName: _.ZodAny,
  ...w(n)
});
class re extends E {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(e) {
    return P(e.data);
  }
}
re.create = (n) => new re({
  typeName: _.ZodUnknown,
  ...w(n)
});
class Y extends E {
  _parse(e) {
    const t = this._getOrReturnCtx(e);
    return g(t, {
      code: m.invalid_type,
      expected: f.never,
      received: t.parsedType
    }), x;
  }
}
Y.create = (n) => new Y({
  typeName: _.ZodNever,
  ...w(n)
});
class Ke extends E {
  _parse(e) {
    if (this._getType(e) !== f.undefined) {
      const r = this._getOrReturnCtx(e);
      return g(r, {
        code: m.invalid_type,
        expected: f.void,
        received: r.parsedType
      }), x;
    }
    return P(e.data);
  }
}
Ke.create = (n) => new Ke({
  typeName: _.ZodVoid,
  ...w(n)
});
class F extends E {
  _parse(e) {
    const { ctx: t, status: r } = this._processInputParams(e), s = this._def;
    if (t.parsedType !== f.array)
      return g(t, {
        code: m.invalid_type,
        expected: f.array,
        received: t.parsedType
      }), x;
    if (s.exactLength !== null) {
      const o = t.data.length > s.exactLength.value, c = t.data.length < s.exactLength.value;
      (o || c) && (g(t, {
        code: o ? m.too_big : m.too_small,
        minimum: c ? s.exactLength.value : void 0,
        maximum: o ? s.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: s.exactLength.message
      }), r.dirty());
    }
    if (s.minLength !== null && t.data.length < s.minLength.value && (g(t, {
      code: m.too_small,
      minimum: s.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: s.minLength.message
    }), r.dirty()), s.maxLength !== null && t.data.length > s.maxLength.value && (g(t, {
      code: m.too_big,
      maximum: s.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: s.maxLength.message
    }), r.dirty()), t.common.async)
      return Promise.all([...t.data].map((o, c) => s.type._parseAsync(new $(t, o, t.path, c)))).then((o) => D.mergeArray(r, o));
    const a = [...t.data].map((o, c) => s.type._parseSync(new $(t, o, t.path, c)));
    return D.mergeArray(r, a);
  }
  get element() {
    return this._def.type;
  }
  min(e, t) {
    return new F({
      ...this._def,
      minLength: { value: e, message: y.toString(t) }
    });
  }
  max(e, t) {
    return new F({
      ...this._def,
      maxLength: { value: e, message: y.toString(t) }
    });
  }
  length(e, t) {
    return new F({
      ...this._def,
      exactLength: { value: e, message: y.toString(t) }
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
F.create = (n, e) => new F({
  type: n,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: _.ZodArray,
  ...w(e)
});
function ce(n) {
  if (n instanceof C) {
    const e = {};
    for (const t in n.shape) {
      const r = n.shape[t];
      e[t] = K.create(ce(r));
    }
    return new C({
      ...n._def,
      shape: () => e
    });
  } else return n instanceof F ? new F({
    ...n._def,
    type: ce(n.element)
  }) : n instanceof K ? K.create(ce(n.unwrap())) : n instanceof ie ? ie.create(ce(n.unwrap())) : n instanceof q ? q.create(n.items.map((e) => ce(e))) : n;
}
class C extends E {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), t = S.objectKeys(e);
    return this._cached = { shape: e, keys: t };
  }
  _parse(e) {
    if (this._getType(e) !== f.object) {
      const h = this._getOrReturnCtx(e);
      return g(h, {
        code: m.invalid_type,
        expected: f.object,
        received: h.parsedType
      }), x;
    }
    const { status: r, ctx: s } = this._processInputParams(e), { shape: a, keys: o } = this._getCached(), c = [];
    if (!(this._def.catchall instanceof Y && this._def.unknownKeys === "strip"))
      for (const h in s.data)
        o.includes(h) || c.push(h);
    const l = [];
    for (const h of o) {
      const p = a[h], b = s.data[h];
      l.push({
        key: { status: "valid", value: h },
        value: p._parse(new $(s, b, s.path, h)),
        alwaysSet: h in s.data
      });
    }
    if (this._def.catchall instanceof Y) {
      const h = this._def.unknownKeys;
      if (h === "passthrough")
        for (const p of c)
          l.push({
            key: { status: "valid", value: p },
            value: { status: "valid", value: s.data[p] }
          });
      else if (h === "strict")
        c.length > 0 && (g(s, {
          code: m.unrecognized_keys,
          keys: c
        }), r.dirty());
      else if (h !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const h = this._def.catchall;
      for (const p of c) {
        const b = s.data[p];
        l.push({
          key: { status: "valid", value: p },
          value: h._parse(
            new $(s, b, s.path, p)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: p in s.data
        });
      }
    }
    return s.common.async ? Promise.resolve().then(async () => {
      const h = [];
      for (const p of l) {
        const b = await p.key;
        h.push({
          key: b,
          value: await p.value,
          alwaysSet: p.alwaysSet
        });
      }
      return h;
    }).then((h) => D.mergeObjectSync(r, h)) : D.mergeObjectSync(r, l);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return y.errToObj, new C({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (t, r) => {
          var s, a, o, c;
          const l = (o = (a = (s = this._def).errorMap) === null || a === void 0 ? void 0 : a.call(s, t, r).message) !== null && o !== void 0 ? o : r.defaultError;
          return t.code === "unrecognized_keys" ? {
            message: (c = y.errToObj(e).message) !== null && c !== void 0 ? c : l
          } : {
            message: l
          };
        }
      } : {}
    });
  }
  strip() {
    return new C({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new C({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(e) {
    return new C({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(e) {
    return new C({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e._def.shape()
      }),
      typeName: _.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(e, t) {
    return this.augment({ [e]: t });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(e) {
    return new C({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const t = {};
    return S.objectKeys(e).forEach((r) => {
      e[r] && this.shape[r] && (t[r] = this.shape[r]);
    }), new C({
      ...this._def,
      shape: () => t
    });
  }
  omit(e) {
    const t = {};
    return S.objectKeys(this.shape).forEach((r) => {
      e[r] || (t[r] = this.shape[r]);
    }), new C({
      ...this._def,
      shape: () => t
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return ce(this);
  }
  partial(e) {
    const t = {};
    return S.objectKeys(this.shape).forEach((r) => {
      const s = this.shape[r];
      e && !e[r] ? t[r] = s : t[r] = s.optional();
    }), new C({
      ...this._def,
      shape: () => t
    });
  }
  required(e) {
    const t = {};
    return S.objectKeys(this.shape).forEach((r) => {
      if (e && !e[r])
        t[r] = this.shape[r];
      else {
        let a = this.shape[r];
        for (; a instanceof K; )
          a = a._def.innerType;
        t[r] = a;
      }
    }), new C({
      ...this._def,
      shape: () => t
    });
  }
  keyof() {
    return Mt(S.objectKeys(this.shape));
  }
}
C.create = (n, e) => new C({
  shape: () => n,
  unknownKeys: "strip",
  catchall: Y.create(),
  typeName: _.ZodObject,
  ...w(e)
});
C.strictCreate = (n, e) => new C({
  shape: () => n,
  unknownKeys: "strict",
  catchall: Y.create(),
  typeName: _.ZodObject,
  ...w(e)
});
C.lazycreate = (n, e) => new C({
  shape: n,
  unknownKeys: "strip",
  catchall: Y.create(),
  typeName: _.ZodObject,
  ...w(e)
});
class Ne extends E {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e), r = this._def.options;
    function s(a) {
      for (const c of a)
        if (c.result.status === "valid")
          return c.result;
      for (const c of a)
        if (c.result.status === "dirty")
          return t.common.issues.push(...c.ctx.common.issues), c.result;
      const o = a.map((c) => new Z(c.ctx.common.issues));
      return g(t, {
        code: m.invalid_union,
        unionErrors: o
      }), x;
    }
    if (t.common.async)
      return Promise.all(r.map(async (a) => {
        const o = {
          ...t,
          common: {
            ...t.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await a._parseAsync({
            data: t.data,
            path: t.path,
            parent: o
          }),
          ctx: o
        };
      })).then(s);
    {
      let a;
      const o = [];
      for (const l of r) {
        const h = {
          ...t,
          common: {
            ...t.common,
            issues: []
          },
          parent: null
        }, p = l._parseSync({
          data: t.data,
          path: t.path,
          parent: h
        });
        if (p.status === "valid")
          return p;
        p.status === "dirty" && !a && (a = { result: p, ctx: h }), h.common.issues.length && o.push(h.common.issues);
      }
      if (a)
        return t.common.issues.push(...a.ctx.common.issues), a.result;
      const c = o.map((l) => new Z(l));
      return g(t, {
        code: m.invalid_union,
        unionErrors: c
      }), x;
    }
  }
  get options() {
    return this._def.options;
  }
}
Ne.create = (n, e) => new Ne({
  options: n,
  typeName: _.ZodUnion,
  ...w(e)
});
const Ve = (n) => n instanceof Oe ? Ve(n.schema) : n instanceof B ? Ve(n.innerType()) : n instanceof Ae ? [n.value] : n instanceof ee ? n.options : n instanceof De ? Object.keys(n.enum) : n instanceof Pe ? Ve(n._def.innerType) : n instanceof Re ? [void 0] : n instanceof Ce ? [null] : null;
class tt extends E {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    if (t.parsedType !== f.object)
      return g(t, {
        code: m.invalid_type,
        expected: f.object,
        received: t.parsedType
      }), x;
    const r = this.discriminator, s = t.data[r], a = this.optionsMap.get(s);
    return a ? t.common.async ? a._parseAsync({
      data: t.data,
      path: t.path,
      parent: t
    }) : a._parseSync({
      data: t.data,
      path: t.path,
      parent: t
    }) : (g(t, {
      code: m.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [r]
    }), x);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(e, t, r) {
    const s = /* @__PURE__ */ new Map();
    for (const a of t) {
      const o = Ve(a.shape[e]);
      if (!o)
        throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
      for (const c of o) {
        if (s.has(c))
          throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(c)}`);
        s.set(c, a);
      }
    }
    return new tt({
      typeName: _.ZodDiscriminatedUnion,
      discriminator: e,
      options: t,
      optionsMap: s,
      ...w(r)
    });
  }
}
function ut(n, e) {
  const t = X(n), r = X(e);
  if (n === e)
    return { valid: !0, data: n };
  if (t === f.object && r === f.object) {
    const s = S.objectKeys(e), a = S.objectKeys(n).filter((c) => s.indexOf(c) !== -1), o = { ...n, ...e };
    for (const c of a) {
      const l = ut(n[c], e[c]);
      if (!l.valid)
        return { valid: !1 };
      o[c] = l.data;
    }
    return { valid: !0, data: o };
  } else if (t === f.array && r === f.array) {
    if (n.length !== e.length)
      return { valid: !1 };
    const s = [];
    for (let a = 0; a < n.length; a++) {
      const o = n[a], c = e[a], l = ut(o, c);
      if (!l.valid)
        return { valid: !1 };
      s.push(l.data);
    }
    return { valid: !0, data: s };
  } else return t === f.date && r === f.date && +n == +e ? { valid: !0, data: n } : { valid: !1 };
}
class Ie extends E {
  _parse(e) {
    const { status: t, ctx: r } = this._processInputParams(e), s = (a, o) => {
      if (ot(a) || ot(o))
        return x;
      const c = ut(a.value, o.value);
      return c.valid ? ((ct(a) || ct(o)) && t.dirty(), { status: t.value, value: c.data }) : (g(r, {
        code: m.invalid_intersection_types
      }), x);
    };
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([a, o]) => s(a, o)) : s(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }));
  }
}
Ie.create = (n, e, t) => new Ie({
  left: n,
  right: e,
  typeName: _.ZodIntersection,
  ...w(t)
});
class q extends E {
  _parse(e) {
    const { status: t, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== f.array)
      return g(r, {
        code: m.invalid_type,
        expected: f.array,
        received: r.parsedType
      }), x;
    if (r.data.length < this._def.items.length)
      return g(r, {
        code: m.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), x;
    !this._def.rest && r.data.length > this._def.items.length && (g(r, {
      code: m.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), t.dirty());
    const a = [...r.data].map((o, c) => {
      const l = this._def.items[c] || this._def.rest;
      return l ? l._parse(new $(r, o, r.path, c)) : null;
    }).filter((o) => !!o);
    return r.common.async ? Promise.all(a).then((o) => D.mergeArray(t, o)) : D.mergeArray(t, a);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new q({
      ...this._def,
      rest: e
    });
  }
}
q.create = (n, e) => {
  if (!Array.isArray(n))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new q({
    items: n,
    typeName: _.ZodTuple,
    rest: null,
    ...w(e)
  });
};
class ke extends E {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: t, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== f.object)
      return g(r, {
        code: m.invalid_type,
        expected: f.object,
        received: r.parsedType
      }), x;
    const s = [], a = this._def.keyType, o = this._def.valueType;
    for (const c in r.data)
      s.push({
        key: a._parse(new $(r, c, r.path, c)),
        value: o._parse(new $(r, r.data[c], r.path, c))
      });
    return r.common.async ? D.mergeObjectAsync(t, s) : D.mergeObjectSync(t, s);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, t, r) {
    return t instanceof E ? new ke({
      keyType: e,
      valueType: t,
      typeName: _.ZodRecord,
      ...w(r)
    }) : new ke({
      keyType: j.create(),
      valueType: e,
      typeName: _.ZodRecord,
      ...w(t)
    });
  }
}
class Ye extends E {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: t, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== f.map)
      return g(r, {
        code: m.invalid_type,
        expected: f.map,
        received: r.parsedType
      }), x;
    const s = this._def.keyType, a = this._def.valueType, o = [...r.data.entries()].map(([c, l], h) => ({
      key: s._parse(new $(r, c, r.path, [h, "key"])),
      value: a._parse(new $(r, l, r.path, [h, "value"]))
    }));
    if (r.common.async) {
      const c = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const l of o) {
          const h = await l.key, p = await l.value;
          if (h.status === "aborted" || p.status === "aborted")
            return x;
          (h.status === "dirty" || p.status === "dirty") && t.dirty(), c.set(h.value, p.value);
        }
        return { status: t.value, value: c };
      });
    } else {
      const c = /* @__PURE__ */ new Map();
      for (const l of o) {
        const h = l.key, p = l.value;
        if (h.status === "aborted" || p.status === "aborted")
          return x;
        (h.status === "dirty" || p.status === "dirty") && t.dirty(), c.set(h.value, p.value);
      }
      return { status: t.value, value: c };
    }
  }
}
Ye.create = (n, e, t) => new Ye({
  valueType: e,
  keyType: n,
  typeName: _.ZodMap,
  ...w(t)
});
class ae extends E {
  _parse(e) {
    const { status: t, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== f.set)
      return g(r, {
        code: m.invalid_type,
        expected: f.set,
        received: r.parsedType
      }), x;
    const s = this._def;
    s.minSize !== null && r.data.size < s.minSize.value && (g(r, {
      code: m.too_small,
      minimum: s.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: s.minSize.message
    }), t.dirty()), s.maxSize !== null && r.data.size > s.maxSize.value && (g(r, {
      code: m.too_big,
      maximum: s.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: s.maxSize.message
    }), t.dirty());
    const a = this._def.valueType;
    function o(l) {
      const h = /* @__PURE__ */ new Set();
      for (const p of l) {
        if (p.status === "aborted")
          return x;
        p.status === "dirty" && t.dirty(), h.add(p.value);
      }
      return { status: t.value, value: h };
    }
    const c = [...r.data.values()].map((l, h) => a._parse(new $(r, l, r.path, h)));
    return r.common.async ? Promise.all(c).then((l) => o(l)) : o(c);
  }
  min(e, t) {
    return new ae({
      ...this._def,
      minSize: { value: e, message: y.toString(t) }
    });
  }
  max(e, t) {
    return new ae({
      ...this._def,
      maxSize: { value: e, message: y.toString(t) }
    });
  }
  size(e, t) {
    return this.min(e, t).max(e, t);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
ae.create = (n, e) => new ae({
  valueType: n,
  minSize: null,
  maxSize: null,
  typeName: _.ZodSet,
  ...w(e)
});
class de extends E {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    if (t.parsedType !== f.function)
      return g(t, {
        code: m.invalid_type,
        expected: f.function,
        received: t.parsedType
      }), x;
    function r(c, l) {
      return We({
        data: c,
        path: t.path,
        errorMaps: [
          t.common.contextualErrorMap,
          t.schemaErrorMap,
          qe(),
          Ee
        ].filter((h) => !!h),
        issueData: {
          code: m.invalid_arguments,
          argumentsError: l
        }
      });
    }
    function s(c, l) {
      return We({
        data: c,
        path: t.path,
        errorMaps: [
          t.common.contextualErrorMap,
          t.schemaErrorMap,
          qe(),
          Ee
        ].filter((h) => !!h),
        issueData: {
          code: m.invalid_return_type,
          returnTypeError: l
        }
      });
    }
    const a = { errorMap: t.common.contextualErrorMap }, o = t.data;
    if (this._def.returns instanceof me) {
      const c = this;
      return P(async function(...l) {
        const h = new Z([]), p = await c._def.args.parseAsync(l, a).catch((L) => {
          throw h.addIssue(r(l, L)), h;
        }), b = await Reflect.apply(o, this, p);
        return await c._def.returns._def.type.parseAsync(b, a).catch((L) => {
          throw h.addIssue(s(b, L)), h;
        });
      });
    } else {
      const c = this;
      return P(function(...l) {
        const h = c._def.args.safeParse(l, a);
        if (!h.success)
          throw new Z([r(l, h.error)]);
        const p = Reflect.apply(o, this, h.data), b = c._def.returns.safeParse(p, a);
        if (!b.success)
          throw new Z([s(p, b.error)]);
        return b.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new de({
      ...this._def,
      args: q.create(e).rest(re.create())
    });
  }
  returns(e) {
    return new de({
      ...this._def,
      returns: e
    });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, t, r) {
    return new de({
      args: e || q.create([]).rest(re.create()),
      returns: t || re.create(),
      typeName: _.ZodFunction,
      ...w(r)
    });
  }
}
class Oe extends E {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    return this._def.getter()._parse({ data: t.data, path: t.path, parent: t });
  }
}
Oe.create = (n, e) => new Oe({
  getter: n,
  typeName: _.ZodLazy,
  ...w(e)
});
class Ae extends E {
  _parse(e) {
    if (e.data !== this._def.value) {
      const t = this._getOrReturnCtx(e);
      return g(t, {
        received: t.data,
        code: m.invalid_literal,
        expected: this._def.value
      }), x;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
}
Ae.create = (n, e) => new Ae({
  value: n,
  typeName: _.ZodLiteral,
  ...w(e)
});
function Mt(n, e) {
  return new ee({
    values: n,
    typeName: _.ZodEnum,
    ...w(e)
  });
}
class ee extends E {
  _parse(e) {
    if (typeof e.data != "string") {
      const t = this._getOrReturnCtx(e), r = this._def.values;
      return g(t, {
        expected: S.joinValues(r),
        received: t.parsedType,
        code: m.invalid_type
      }), x;
    }
    if (this._def.values.indexOf(e.data) === -1) {
      const t = this._getOrReturnCtx(e), r = this._def.values;
      return g(t, {
        received: t.data,
        code: m.invalid_enum_value,
        options: r
      }), x;
    }
    return P(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const t of this._def.values)
      e[t] = t;
    return e;
  }
  get Values() {
    const e = {};
    for (const t of this._def.values)
      e[t] = t;
    return e;
  }
  get Enum() {
    const e = {};
    for (const t of this._def.values)
      e[t] = t;
    return e;
  }
  extract(e) {
    return ee.create(e);
  }
  exclude(e) {
    return ee.create(this.options.filter((t) => !e.includes(t)));
  }
}
ee.create = Mt;
class De extends E {
  _parse(e) {
    const t = S.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(e);
    if (r.parsedType !== f.string && r.parsedType !== f.number) {
      const s = S.objectValues(t);
      return g(r, {
        expected: S.joinValues(s),
        received: r.parsedType,
        code: m.invalid_type
      }), x;
    }
    if (t.indexOf(e.data) === -1) {
      const s = S.objectValues(t);
      return g(r, {
        received: r.data,
        code: m.invalid_enum_value,
        options: s
      }), x;
    }
    return P(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
De.create = (n, e) => new De({
  values: n,
  typeName: _.ZodNativeEnum,
  ...w(e)
});
class me extends E {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    if (t.parsedType !== f.promise && t.common.async === !1)
      return g(t, {
        code: m.invalid_type,
        expected: f.promise,
        received: t.parsedType
      }), x;
    const r = t.parsedType === f.promise ? t.data : Promise.resolve(t.data);
    return P(r.then((s) => this._def.type.parseAsync(s, {
      path: t.path,
      errorMap: t.common.contextualErrorMap
    })));
  }
}
me.create = (n, e) => new me({
  type: n,
  typeName: _.ZodPromise,
  ...w(e)
});
class B extends E {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === _.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e) {
    const { status: t, ctx: r } = this._processInputParams(e), s = this._def.effect || null, a = {
      addIssue: (o) => {
        g(r, o), o.fatal ? t.abort() : t.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (a.addIssue = a.addIssue.bind(a), s.type === "preprocess") {
      const o = s.transform(r.data, a);
      return r.common.issues.length ? {
        status: "dirty",
        value: r.data
      } : r.common.async ? Promise.resolve(o).then((c) => this._def.schema._parseAsync({
        data: c,
        path: r.path,
        parent: r
      })) : this._def.schema._parseSync({
        data: o,
        path: r.path,
        parent: r
      });
    }
    if (s.type === "refinement") {
      const o = (c) => {
        const l = s.refinement(c, a);
        if (r.common.async)
          return Promise.resolve(l);
        if (l instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return c;
      };
      if (r.common.async === !1) {
        const c = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return c.status === "aborted" ? x : (c.status === "dirty" && t.dirty(), o(c.value), { status: t.value, value: c.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((c) => c.status === "aborted" ? x : (c.status === "dirty" && t.dirty(), o(c.value).then(() => ({ status: t.value, value: c.value }))));
    }
    if (s.type === "transform")
      if (r.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!Te(o))
          return o;
        const c = s.transform(o.value, a);
        if (c instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: t.value, value: c };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((o) => Te(o) ? Promise.resolve(s.transform(o.value, a)).then((c) => ({ status: t.value, value: c })) : o);
    S.assertNever(s);
  }
}
B.create = (n, e, t) => new B({
  schema: n,
  typeName: _.ZodEffects,
  effect: e,
  ...w(t)
});
B.createWithPreprocess = (n, e, t) => new B({
  schema: e,
  effect: { type: "preprocess", transform: n },
  typeName: _.ZodEffects,
  ...w(t)
});
class K extends E {
  _parse(e) {
    return this._getType(e) === f.undefined ? P(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
K.create = (n, e) => new K({
  innerType: n,
  typeName: _.ZodOptional,
  ...w(e)
});
class ie extends E {
  _parse(e) {
    return this._getType(e) === f.null ? P(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ie.create = (n, e) => new ie({
  innerType: n,
  typeName: _.ZodNullable,
  ...w(e)
});
class Pe extends E {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    let r = t.data;
    return t.parsedType === f.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: t.path,
      parent: t
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
Pe.create = (n, e) => new Pe({
  innerType: n,
  typeName: _.ZodDefault,
  defaultValue: typeof e.default == "function" ? e.default : () => e.default,
  ...w(e)
});
class Xe extends E {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e), r = {
      ...t,
      common: {
        ...t.common,
        issues: []
      }
    }, s = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: {
        ...r
      }
    });
    return He(s) ? s.then((a) => ({
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new Z(r.common.issues);
        },
        input: r.data
      })
    })) : {
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new Z(r.common.issues);
        },
        input: r.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
Xe.create = (n, e) => new Xe({
  innerType: n,
  typeName: _.ZodCatch,
  catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
  ...w(e)
});
class Je extends E {
  _parse(e) {
    if (this._getType(e) !== f.nan) {
      const r = this._getOrReturnCtx(e);
      return g(r, {
        code: m.invalid_type,
        expected: f.nan,
        received: r.parsedType
      }), x;
    }
    return { status: "valid", value: e.data };
  }
}
Je.create = (n) => new Je({
  typeName: _.ZodNaN,
  ...w(n)
});
const Bn = Symbol("zod_brand");
class Ut extends E {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e), r = t.data;
    return this._def.type._parse({
      data: r,
      path: t.path,
      parent: t
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class Le extends E {
  _parse(e) {
    const { status: t, ctx: r } = this._processInputParams(e);
    if (r.common.async)
      return (async () => {
        const a = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return a.status === "aborted" ? x : a.status === "dirty" ? (t.dirty(), Lt(a.value)) : this._def.out._parseAsync({
          data: a.value,
          path: r.path,
          parent: r
        });
      })();
    {
      const s = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return s.status === "aborted" ? x : s.status === "dirty" ? (t.dirty(), {
        status: "dirty",
        value: s.value
      }) : this._def.out._parseSync({
        data: s.value,
        path: r.path,
        parent: r
      });
    }
  }
  static create(e, t) {
    return new Le({
      in: e,
      out: t,
      typeName: _.ZodPipeline
    });
  }
}
class Qe extends E {
  _parse(e) {
    const t = this._def.innerType._parse(e);
    return Te(t) && (t.value = Object.freeze(t.value)), t;
  }
}
Qe.create = (n, e) => new Qe({
  innerType: n,
  typeName: _.ZodReadonly,
  ...w(e)
});
const jt = (n, e = {}, t) => n ? he.create().superRefine((r, s) => {
  var a, o;
  if (!n(r)) {
    const c = typeof e == "function" ? e(r) : typeof e == "string" ? { message: e } : e, l = (o = (a = c.fatal) !== null && a !== void 0 ? a : t) !== null && o !== void 0 ? o : !0, h = typeof c == "string" ? { message: c } : c;
    s.addIssue({ code: "custom", ...h, fatal: l });
  }
}) : he.create(), zn = {
  object: C.lazycreate
};
var _;
(function(n) {
  n.ZodString = "ZodString", n.ZodNumber = "ZodNumber", n.ZodNaN = "ZodNaN", n.ZodBigInt = "ZodBigInt", n.ZodBoolean = "ZodBoolean", n.ZodDate = "ZodDate", n.ZodSymbol = "ZodSymbol", n.ZodUndefined = "ZodUndefined", n.ZodNull = "ZodNull", n.ZodAny = "ZodAny", n.ZodUnknown = "ZodUnknown", n.ZodNever = "ZodNever", n.ZodVoid = "ZodVoid", n.ZodArray = "ZodArray", n.ZodObject = "ZodObject", n.ZodUnion = "ZodUnion", n.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", n.ZodIntersection = "ZodIntersection", n.ZodTuple = "ZodTuple", n.ZodRecord = "ZodRecord", n.ZodMap = "ZodMap", n.ZodSet = "ZodSet", n.ZodFunction = "ZodFunction", n.ZodLazy = "ZodLazy", n.ZodLiteral = "ZodLiteral", n.ZodEnum = "ZodEnum", n.ZodEffects = "ZodEffects", n.ZodNativeEnum = "ZodNativeEnum", n.ZodOptional = "ZodOptional", n.ZodNullable = "ZodNullable", n.ZodDefault = "ZodDefault", n.ZodCatch = "ZodCatch", n.ZodPromise = "ZodPromise", n.ZodBranded = "ZodBranded", n.ZodPipeline = "ZodPipeline", n.ZodReadonly = "ZodReadonly";
})(_ || (_ = {}));
const Vn = (n, e = {
  message: `Input not instance of ${n.name}`
}) => jt((t) => t instanceof n, e), Zt = j.create, Ft = J.create, $n = Je.create, qn = Q.create, Bt = Se.create, Wn = se.create, Hn = Ge.create, Gn = Re.create, Kn = Ce.create, Yn = he.create, Xn = re.create, Jn = Y.create, Qn = Ke.create, er = F.create, tr = C.create, nr = C.strictCreate, rr = Ne.create, sr = tt.create, ar = Ie.create, ir = q.create, or = ke.create, cr = Ye.create, ur = ae.create, dr = de.create, lr = Oe.create, hr = Ae.create, mr = ee.create, pr = De.create, fr = me.create, bt = B.create, gr = K.create, yr = ie.create, vr = B.createWithPreprocess, _r = Le.create, xr = () => Zt().optional(), wr = () => Ft().optional(), br = () => Bt().optional(), Er = {
  string: (n) => j.create({ ...n, coerce: !0 }),
  number: (n) => J.create({ ...n, coerce: !0 }),
  boolean: (n) => Se.create({
    ...n,
    coerce: !0
  }),
  bigint: (n) => Q.create({ ...n, coerce: !0 }),
  date: (n) => se.create({ ...n, coerce: !0 })
}, Tr = x;
var i = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: Ee,
  setErrorMap: Nn,
  getErrorMap: qe,
  makeIssue: We,
  EMPTY_PATH: In,
  addIssueToContext: g,
  ParseStatus: D,
  INVALID: x,
  DIRTY: Lt,
  OK: P,
  isAborted: ot,
  isDirty: ct,
  isValid: Te,
  isAsync: He,
  get util() {
    return S;
  },
  get objectUtil() {
    return it;
  },
  ZodParsedType: f,
  getParsedType: X,
  ZodType: E,
  ZodString: j,
  ZodNumber: J,
  ZodBigInt: Q,
  ZodBoolean: Se,
  ZodDate: se,
  ZodSymbol: Ge,
  ZodUndefined: Re,
  ZodNull: Ce,
  ZodAny: he,
  ZodUnknown: re,
  ZodNever: Y,
  ZodVoid: Ke,
  ZodArray: F,
  ZodObject: C,
  ZodUnion: Ne,
  ZodDiscriminatedUnion: tt,
  ZodIntersection: Ie,
  ZodTuple: q,
  ZodRecord: ke,
  ZodMap: Ye,
  ZodSet: ae,
  ZodFunction: de,
  ZodLazy: Oe,
  ZodLiteral: Ae,
  ZodEnum: ee,
  ZodNativeEnum: De,
  ZodPromise: me,
  ZodEffects: B,
  ZodTransformer: B,
  ZodOptional: K,
  ZodNullable: ie,
  ZodDefault: Pe,
  ZodCatch: Xe,
  ZodNaN: Je,
  BRAND: Bn,
  ZodBranded: Ut,
  ZodPipeline: Le,
  ZodReadonly: Qe,
  custom: jt,
  Schema: E,
  ZodSchema: E,
  late: zn,
  get ZodFirstPartyTypeKind() {
    return _;
  },
  coerce: Er,
  any: Yn,
  array: er,
  bigint: qn,
  boolean: Bt,
  date: Wn,
  discriminatedUnion: sr,
  effect: bt,
  enum: mr,
  function: dr,
  instanceof: Vn,
  intersection: ar,
  lazy: lr,
  literal: hr,
  map: cr,
  nan: $n,
  nativeEnum: pr,
  never: Jn,
  null: Kn,
  nullable: yr,
  number: Ft,
  object: tr,
  oboolean: br,
  onumber: wr,
  optional: gr,
  ostring: xr,
  pipeline: _r,
  preprocess: vr,
  promise: fr,
  record: or,
  set: ur,
  strictObject: nr,
  string: Zt,
  symbol: Hn,
  transformer: bt,
  tuple: ir,
  undefined: Gn,
  union: rr,
  unknown: Xn,
  void: Qn,
  NEVER: Tr,
  ZodIssueCode: m,
  quotelessJson: Cn,
  ZodError: Z
});
const zt = i.object({
  id: i.string(),
  name: i.string(),
  address: i.string(),
  currency: i.string(),
  balance: i.string(),
  spendableBalance: i.string(),
  blockHeight: i.union([i.number(), i.undefined()]),
  lastSyncDate: i.string(),
  parentAccountId: i.string().optional()
}), Vt = i.enum(["CryptoCurrency", "TokenCurrency"]), Sr = i.enum(["ERC20"]), $t = i.object({
  color: i.string(),
  ticker: i.string(),
  id: i.string(),
  name: i.string(),
  decimals: i.number()
}), Rr = $t.extend({
  type: i.literal(Vt.enum.CryptoCurrency),
  family: i.string()
}), Cr = $t.extend({
  type: i.literal(Vt.enum.TokenCurrency),
  parent: i.string()
}), Nr = Cr.extend({
  standard: Sr,
  contract: i.string()
}), Ir = i.discriminatedUnion("type", [
  Rr,
  Nr
]), N = i.object({
  amount: i.string(),
  recipient: i.string()
}), kr = [
  "algorand",
  "bitcoin",
  "cardano",
  "casper",
  "celo",
  "crypto_org",
  "cosmos",
  "elrond",
  "ethereum",
  "filecoin",
  "hedera",
  "internet_computer",
  "near",
  "neo",
  "polkadot",
  "ripple",
  "solana",
  "stacks",
  "stellar",
  "tezos",
  "ton",
  "tron",
  "vechain"
], I = i.enum(kr), Or = ({ family: n, mode: e, fees: t, assetId: r, memo: s, amount: a, recipient: o }) => ({
  family: n,
  amount: a.toString(),
  recipient: o,
  fees: t ? t.toString() : void 0,
  memo: s,
  mode: e,
  assetId: r
}), Ar = ({ family: n, mode: e, fees: t, assetId: r, memo: s, amount: a, recipient: o }) => ({
  family: n,
  amount: new v(a),
  recipient: o,
  fees: t ? new v(t) : void 0,
  memo: s,
  mode: e,
  assetId: r
});
function Dr({ family: n, amount: e, recipient: t, feePerByte: r, opReturnData: s }) {
  return {
    family: n,
    amount: e.toString(),
    recipient: t,
    feePerByte: r == null ? void 0 : r.toString(),
    opReturnDataHex: s == null ? void 0 : s.toString("hex")
  };
}
function Pr({ family: n, amount: e, recipient: t, feePerByte: r, opReturnDataHex: s }) {
  return {
    family: n,
    amount: new v(e),
    recipient: t,
    feePerByte: r ? new v(r) : void 0,
    opReturnData: s ? V.from(s, "hex") : void 0
  };
}
function Lr({ amount: n, family: e, fees: t = void 0, index: r = void 0, mode: s, recipient: a }) {
  return {
    amount: n.toString(),
    family: e,
    fees: t ? t.toString() : void 0,
    index: r,
    mode: s,
    recipient: a
  };
}
function Mr({ amount: n, family: e, fees: t = void 0, index: r = void 0, mode: s, recipient: a }) {
  return {
    amount: new v(n),
    family: e,
    fees: t ? new v(t) : void 0,
    index: r,
    mode: s,
    recipient: a
  };
}
const Ur = ({ amount: n, recipient: e, family: t, mode: r, fees: s, gas: a, memo: o, sourceValidator: c, validators: l }) => ({
  amount: n.toString(),
  recipient: e,
  family: t,
  mode: r,
  fees: s ? s.toString() : void 0,
  gas: a ? a.toString() : void 0,
  memo: o,
  sourceValidator: c ?? void 0,
  validators: l ? l.map((h) => ({
    ...h,
    amount: h.amount.toString()
  })) : void 0
}), jr = ({ amount: n, recipient: e, family: t, mode: r, fees: s, gas: a, memo: o, sourceValidator: c, validators: l }) => ({
  amount: new v(n),
  recipient: e,
  family: t,
  mode: r,
  fees: s ? new v(s) : void 0,
  gas: a ? new v(a) : void 0,
  memo: o,
  sourceValidator: c ?? void 0,
  validators: l ? l.map((h) => ({
    ...h,
    amount: new v(h.amount)
  })) : void 0
}), Zr = ({ family: n, mode: e, fees: t, amount: r, recipient: s }) => ({
  family: n,
  amount: r.toString(),
  recipient: s,
  fees: t ? t.toString() : void 0,
  mode: e
}), Fr = ({ family: n, mode: e, fees: t, amount: r, recipient: s }) => ({
  family: n,
  amount: new v(r),
  recipient: s,
  fees: t ? new v(t) : void 0,
  mode: e
});
function Br({ family: n, amount: e, recipient: t, nonce: r, data: s, gasPrice: a, gasLimit: o, maxPriorityFeePerGas: c, maxFeePerGas: l }) {
  return {
    family: n,
    amount: e.toString(),
    recipient: t,
    nonce: r,
    data: s ? s.toString("hex") : void 0,
    gasPrice: a ? a.toString() : void 0,
    gasLimit: o ? o.toString() : void 0,
    maxPriorityFeePerGas: c ? c.toString() : void 0,
    maxFeePerGas: l ? l.toString() : void 0
  };
}
function zr({ family: n, amount: e, recipient: t, nonce: r, data: s, gasPrice: a, gasLimit: o, maxPriorityFeePerGas: c, maxFeePerGas: l }) {
  return {
    family: n,
    amount: new v(e),
    recipient: t,
    nonce: r,
    data: s ? V.from(s, "hex") : void 0,
    gasPrice: a ? new v(a) : void 0,
    gasLimit: o ? new v(o) : void 0,
    maxPriorityFeePerGas: c ? new v(c) : void 0,
    maxFeePerGas: l ? new v(l) : void 0
  };
}
function Vr({ amount: n, recipient: e, family: t, mode: r, fees: s }) {
  return {
    amount: n.toString(),
    recipient: e,
    family: t,
    mode: r,
    fees: s == null ? void 0 : s.toString()
  };
}
function $r({ amount: n, recipient: e, family: t, mode: r, fees: s }) {
  return {
    amount: new v(n),
    recipient: e,
    family: t,
    mode: r,
    fees: s ? new v(s) : void 0
  };
}
function qr({ amount: n, family: e, memo: t = void 0, recipient: r }) {
  return {
    amount: n.toString(),
    family: e,
    memo: t,
    recipient: r
  };
}
function Wr({ amount: n, family: e, memo: t = void 0, recipient: r }) {
  return {
    amount: new v(n),
    family: e,
    memo: t,
    recipient: r
  };
}
function Hr({ amount: n, data: e = void 0, family: t, method: r, nonce: s, params: a = void 0, gasLimit: o, gasFeeCap: c, gasPremium: l, recipient: h, version: p }) {
  return {
    amount: n.toString(),
    data: e ? e.toString("hex") : void 0,
    family: t,
    gasLimit: o.toNumber(),
    gasFeeCap: c.toString(),
    gasPremium: l.toString(),
    method: r,
    nonce: s,
    params: a,
    recipient: h,
    version: p
  };
}
function Gr({ amount: n, data: e = void 0, family: t, method: r, nonce: s, params: a = void 0, gasLimit: o, gasFeeCap: c, gasPremium: l, recipient: h, version: p }) {
  return {
    amount: new v(n),
    data: e ? V.from(e, "hex") : void 0,
    family: t,
    gasLimit: new v(o),
    gasFeeCap: new v(c),
    gasPremium: new v(l),
    nonce: s,
    method: r,
    params: a,
    recipient: h,
    version: p
  };
}
function Kr({ amount: n, recipient: e, family: t }) {
  return {
    amount: n.toString(),
    recipient: e,
    family: t
  };
}
function Yr({ amount: n, recipient: e, family: t }) {
  return {
    amount: new v(n),
    recipient: e,
    family: t
  };
}
const Xr = ({ amount: n, recipient: e, family: t, mode: r, fee: s, era: a, validators: o, numOfSlashingSpans: c, rewardDestination: l }) => ({
  amount: n.toString(),
  recipient: e,
  family: t,
  mode: r,
  fee: s ? s.toString() : void 0,
  era: a,
  validators: o,
  numOfSlashingSpans: c,
  rewardDestination: l
}), Jr = ({ amount: n, recipient: e, family: t, mode: r, fee: s, era: a, validators: o, numOfSlashingSpans: c, rewardDestination: l }) => ({
  amount: new v(n),
  recipient: e,
  family: t,
  mode: r,
  fee: s ? new v(s) : void 0,
  era: a,
  validators: o,
  numOfSlashingSpans: c,
  rewardDestination: l
}), Qr = ({ family: n, fee: e, tag: t, amount: r, recipient: s }) => ({
  family: n,
  amount: r.toString(),
  recipient: s,
  fee: e ? e.toString() : void 0,
  tag: t
}), es = ({ family: n, fee: e, tag: t, amount: r, recipient: s }) => ({
  family: n,
  amount: new v(r),
  recipient: s,
  fee: e ? new v(e) : void 0,
  tag: t
}), ts = ({ amount: n, recipient: e, family: t, fees: r, memoType: s, memoValue: a }) => ({
  amount: n.toString(),
  recipient: e,
  family: t,
  fees: r ? r.toString() : void 0,
  memoType: s,
  memoValue: a
}), ns = ({ amount: n, recipient: e, family: t, fees: r, memoType: s, memoValue: a }) => ({
  amount: new v(n),
  recipient: e,
  family: t,
  fees: r ? new v(r) : void 0,
  memoType: s,
  memoValue: a
}), rs = ({ amount: n, recipient: e, family: t, mode: r, fees: s, gasLimit: a }) => ({
  amount: n.toString(),
  recipient: e,
  family: t,
  mode: r,
  fees: s ? s.toString() : void 0,
  gasLimit: a ? a.toString() : void 0
}), ss = ({ amount: n, recipient: e, family: t, mode: r, fees: s, gasLimit: a }) => ({
  amount: new v(n),
  recipient: e,
  family: t,
  mode: r,
  fees: s ? new v(s) : void 0,
  gasLimit: a ? new v(a) : void 0
}), as = ({ amount: n, recipient: e, family: t, fees: r, comment: s }) => ({
  amount: n.toString(),
  recipient: e,
  family: t,
  fees: r.toString(),
  comment: s
}), is = ({ amount: n, recipient: e, family: t, fees: r, comment: s }) => ({
  amount: new v(n),
  recipient: e,
  family: t,
  fees: new v(r),
  comment: s
}), os = ({ amount: n, recipient: e, family: t, mode: r, resource: s, duration: a, votes: o }) => ({
  amount: n.toString(),
  recipient: e,
  family: t,
  mode: r,
  resource: s,
  duration: a,
  votes: o
}), cs = ({ amount: n, recipient: e, family: t, mode: r, resource: s, duration: a, votes: o }) => ({
  amount: new v(n),
  recipient: e,
  family: t,
  mode: r,
  resource: s,
  duration: a,
  votes: o
});
function us({ amount: n, data: e, family: t, fees: r, gasLimit: s, mode: a, recipient: o }) {
  return {
    family: t,
    amount: n.toString(),
    recipient: o,
    mode: a,
    fees: r ? r.toString() : void 0,
    data: e,
    gasLimit: s
  };
}
function ds({ amount: n, data: e, family: t, fees: r, gasLimit: s, mode: a, recipient: o }) {
  return {
    family: t,
    mode: a,
    amount: new v(n),
    recipient: o,
    fees: r ? new v(r) : void 0,
    data: e,
    gasLimit: s
  };
}
function ls({ amount: n, family: e, fees: t, memo: r, mode: s, recipient: a }) {
  return {
    amount: n.toString(),
    family: e,
    fees: t ? t.toString() : void 0,
    memo: r,
    mode: s,
    recipient: a
  };
}
function hs({ amount: n, family: e, fees: t, memo: r, mode: s, recipient: a }) {
  return {
    amount: new v(n),
    family: e,
    fees: t ? new v(t) : void 0,
    memo: r,
    mode: s,
    recipient: a
  };
}
function ms({ amount: n, family: e, model: t, recipient: r }) {
  return {
    amount: n.toString(),
    family: e,
    model: JSON.stringify(t),
    recipient: r
  };
}
function ps({ family: n, amount: e, model: t, recipient: r }) {
  return {
    amount: new v(e),
    family: n,
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    model: JSON.parse(t),
    recipient: r
  };
}
const fs = ({ amount: n, recipient: e, family: t, estimatedFees: r, body: s }) => ({
  amount: n.toString(),
  recipient: e,
  family: t,
  estimatedFees: r,
  body: s
}), gs = ({ amount: n, recipient: e, family: t, estimatedFees: r, body: s }) => ({
  amount: new v(n),
  recipient: e,
  family: t,
  estimatedFees: r,
  body: s
}), ys = ({ amount: n, recipient: e, family: t, fee: r, nonce: s, memo: a, network: o, anchorMode: c }) => ({
  amount: n.toString(),
  recipient: e,
  family: t,
  fee: r == null ? void 0 : r.toString(),
  nonce: s == null ? void 0 : s.toString(),
  memo: a,
  network: o,
  anchorMode: c
}), vs = ({ amount: n, recipient: e, family: t, fee: r, nonce: s, memo: a, network: o, anchorMode: c }) => ({
  amount: new v(n),
  recipient: e,
  family: t,
  fee: r ? new v(r) : void 0,
  nonce: s ? new v(s) : void 0,
  memo: a,
  network: o === "mainnet" ? o : "testnet",
  anchorMode: c
}), _s = ({ amount: n, recipient: e, family: t, fees: r, memo: s }) => ({
  amount: n.toFixed(),
  recipient: e,
  family: t,
  fees: r.toString(),
  memo: s
}), xs = ({ amount: n, recipient: e, family: t, fees: r, memo: s }) => ({
  amount: new v(n),
  recipient: e,
  family: t,
  fees: new v(r),
  memo: s
}), ws = ({ amount: n, recipient: e, family: t, fees: r, transferId: s }) => ({
  amount: n.toFixed(),
  recipient: e,
  family: t,
  fees: r.toString(),
  transferId: s
}), bs = ({ amount: n, recipient: e, family: t, fees: r, transferId: s }) => ({
  amount: new v(n),
  recipient: e,
  family: t,
  fees: new v(r),
  transferId: s
});
function be(n) {
  switch (n.family) {
    case "ethereum":
      return Br(n);
    case "bitcoin":
      return Dr(n);
    case "algorand":
      return Or(n);
    case "crypto_org":
      return Zr(n);
    case "ripple":
      return Qr(n);
    case "celo":
      return Lr(n);
    case "cosmos":
      return Ur(n);
    case "hedera":
      return qr(n);
    case "filecoin":
      return Hr(n);
    case "tezos":
      return rs(n);
    case "polkadot":
      return Xr(n);
    case "stellar":
      return ts(n);
    case "ton":
      return as(n);
    case "tron":
      return os(n);
    case "near":
      return Vr(n);
    case "neo":
      return Kr(n);
    case "elrond":
      return us(n);
    case "cardano":
      return ls(n);
    case "solana":
      return ms(n);
    case "vechain":
      return fs(n);
    case "stacks":
      return ys(n);
    case "internet_computer":
      return _s(n);
    case "casper":
      return ws(n);
    default:
      return n;
  }
}
function Es(n) {
  switch (n.family) {
    case "ethereum":
      return zr(n);
    case "bitcoin":
      return Pr(n);
    case "algorand":
      return Ar(n);
    case "crypto_org":
      return Fr(n);
    case "ripple":
      return es(n);
    case "celo":
      return Mr(n);
    case "cosmos":
      return jr(n);
    case "hedera":
      return Wr(n);
    case "filecoin":
      return Gr(n);
    case "tezos":
      return ss(n);
    case "polkadot":
      return Jr(n);
    case "stellar":
      return ns(n);
    case "ton":
      return is(n);
    case "tron":
      return cs(n);
    case "near":
      return $r(n);
    case "neo":
      return Yr(n);
    case "elrond":
      return ds(n);
    case "cardano":
      return hs(n);
    case "solana":
      return ps(n);
    case "vechain":
      return gs(n);
    case "stacks":
      return vs(n);
    case "internet_computer":
      return xs(n);
    case "casper":
      return bs(n);
    default:
      return n;
  }
}
const Ts = i.enum([
  "send",
  "optIn",
  "claimReward",
  "optOut"
]), Ss = N.extend({
  family: i.literal(I.enum.algorand),
  mode: Ts,
  fees: i.string().optional(),
  assetId: i.string().optional(),
  memo: i.string().optional()
}), Rs = N.extend({
  family: i.literal(I.enum.bitcoin),
  feePerByte: i.string().optional(),
  opReturnDataHex: i.string().max(160).optional()
}), Cs = i.enum([
  "send",
  "lock",
  "unlock",
  "withdraw",
  "vote",
  "revoke",
  "activate",
  "register"
]), Ns = N.extend({
  family: i.literal(I.enum.celo),
  fees: i.string().optional().nullable(),
  mode: Cs,
  index: i.number().optional().nullable()
}), Is = i.enum([
  "send",
  "delegate",
  "undelegate",
  "redelegate",
  "claimReward",
  "claimRewardCompound"
]), ks = i.object({
  address: i.string(),
  amount: i.string()
}), Os = N.extend({
  family: i.literal(I.enum.cosmos),
  mode: Is,
  fees: i.string().optional(),
  gas: i.string().optional(),
  memo: i.string().optional(),
  sourceValidator: i.string().optional(),
  validators: i.array(ks).optional()
}), As = N.extend({
  family: i.literal(I.enum.crypto_org),
  mode: i.string(),
  fees: i.string().optional()
}), Ds = N.extend({
  family: i.literal(I.enum.ethereum),
  nonce: i.number().optional(),
  data: i.string().optional(),
  gasPrice: i.string().optional(),
  gasLimit: i.string().optional(),
  maxPriorityFeePerGas: i.string().optional(),
  maxFeePerGas: i.string().optional()
}), Ps = N.extend({
  family: i.literal(I.enum.near),
  mode: i.string(),
  fees: i.string().optional()
}), Ls = N.extend({
  family: i.literal(I.enum.neo)
}), Ms = i.enum([
  "send",
  "bond",
  "unbond",
  "rebond",
  "withdrawUnbonded",
  "setController",
  "nominate",
  "chill",
  "claimReward"
]), Us = i.enum([
  "Staked",
  "Stash",
  "Controller",
  "Account",
  "None"
]), js = N.extend({
  family: i.literal(I.enum.polkadot),
  mode: Ms,
  fee: i.string().optional(),
  era: i.number().optional(),
  validators: i.array(i.string()).optional(),
  rewardDestination: Us.optional(),
  numOfSlashingSpans: i.number().optional()
}), Zs = N.extend({
  family: i.literal(I.enum.ripple),
  fee: i.string().optional(),
  tag: i.number()
}), Fs = N.extend({
  family: i.literal(I.enum.solana),
  model: i.string()
}), Bs = i.enum([
  "MEMO_TEXT",
  "MEMO_ID",
  "MEMO_HASH",
  "MEMO_RETURN"
]), zs = N.extend({
  family: i.literal(I.enum.stellar),
  fees: i.string().optional(),
  memoType: Bs.optional(),
  memoValue: i.string().optional()
}), Vs = i.enum([
  "send",
  "delegate",
  "undelegate"
]), $s = N.extend({
  family: i.literal(I.enum.tezos),
  mode: Vs,
  fees: i.string().optional(),
  gasLimit: i.string().optional()
}), qs = i.object({
  isEncrypted: i.boolean(),
  text: i.string()
}), Ws = N.extend({
  family: i.literal(I.enum.ton),
  fees: i.string(),
  comment: qs
}), Hs = i.enum([
  "send",
  "freeze",
  "unfreeze",
  "vote",
  "claimReward",
  "withdrawExpireUnfreeze",
  "unDelegateResource",
  "legacyUnfreeze"
]), Gs = i.enum(["BANDWIDTH", "ENERGY"]), Ks = i.object({
  address: i.string(),
  voteCount: i.number()
}), Ys = N.extend({
  family: i.literal(I.enum.tron),
  mode: Hs,
  resource: Gs.optional(),
  duration: i.number().optional(),
  votes: i.array(Ks).optional()
}), Xs = N.extend({
  family: i.literal(I.enum.hedera),
  memo: i.string().max(100).optional()
}), Js = N.extend({
  data: i.string().optional(),
  family: i.literal(I.enum.filecoin),
  gasLimit: i.number(),
  gasFeeCap: i.string(),
  gasPremium: i.string(),
  method: i.number(),
  nonce: i.number(),
  params: i.string().optional(),
  version: i.number()
});
i.enum([
  "send",
  "delegate",
  "reDelegateRewards",
  "unDelegate",
  "claimRewards",
  "withdraw"
]);
const Qs = N.extend({
  family: i.literal(I.enum.elrond),
  mode: i.union([
    i.literal("send"),
    i.literal("delegate"),
    i.literal("reDelegateRewards"),
    i.literal("unDelegate"),
    i.literal("claimRewards"),
    i.literal("withdraw")
  ]),
  fees: i.string().optional(),
  data: i.string().optional(),
  gasLimit: i.number()
}), ea = N.extend({
  family: i.literal(I.enum.cardano),
  fees: i.string().optional(),
  mode: i.string(),
  memo: i.string().optional()
}), ta = i.object({
  to: i.string().nullable(),
  value: i.union([i.string(), i.number()]),
  data: i.string()
}), na = i.object({
  chainTag: i.number(),
  blockRef: i.string(),
  expiration: i.number(),
  clauses: i.array(ta),
  gasPriceCoef: i.number(),
  gas: i.union([i.string(), i.number()]),
  dependsOn: i.string().nullable(),
  nonce: i.union([i.string(), i.number()]),
  reserved: i.object({
    features: i.number().optional(),
    unused: i.array(i.any()).optional()
  }).optional()
}), ra = N.extend({
  family: i.literal(I.enum.vechain),
  estimatedFees: i.string(),
  body: na
}), sa = N.extend({
  family: i.literal(I.enum.stacks),
  fee: i.string().optional(),
  nonce: i.string().optional(),
  memo: i.string().optional(),
  network: i.string(),
  anchorMode: i.number()
}), aa = N.extend({
  family: i.literal(I.enum.internet_computer),
  fees: i.string(),
  memo: i.string().optional()
}), ia = N.extend({
  family: i.literal(I.enum.casper),
  fees: i.string(),
  transferId: i.string().optional()
}), dt = i.discriminatedUnion("family", [
  Ss,
  Rs,
  Ns,
  Os,
  As,
  Ds,
  Xs,
  Js,
  Ps,
  Ls,
  js,
  Zs,
  zs,
  $s,
  Ws,
  Ys,
  Qs,
  ea,
  Fs,
  ra,
  sa,
  aa,
  ia
]);
class qt {
  constructor(e) {
    T(this, "prefix", "");
    this.prefix = e ? `[${e}] ` : "";
  }
  log(e, ...t) {
  }
  warn(e, ...t) {
  }
  debug(e, ...t) {
  }
  error(e, ...t) {
  }
}
const oa = new qt("WindowMessage");
class ca {
  constructor(e = window, t = oa) {
    T(this, "target");
    T(this, "logger");
    T(this, "_onMessage");
    T(this, "connect", () => {
      var e;
      this.target.addEventListener("message", this._onMessageEvent, !1), (e = this.target.document) == null || e.addEventListener("message", this._onMessageEvent, !1), this.logger.debug("event listeners registered");
    });
    T(this, "disconnect", () => {
      var e;
      this.target.removeEventListener("message", this._onMessageEvent, !1), (e = this.target.document) == null || e.removeEventListener("message", this._onMessageEvent, !1), this.logger.debug("event listeners unregistered");
    });
    T(this, "_onMessageEvent", (e) => {
      if (this._onMessage)
        if (this.logger.debug("received message event", e), e.data && typeof e.data == "string")
          try {
            const t = e.data;
            Date.now() > 0 ? (this.logger.log("received message", t), this._onMessage(t)) : this.logger.debug("not a wallet API message");
          } catch (t) {
            this.logger.warn("parse error"), t instanceof Error && this._onMessage(t.message);
          }
        else
          this.logger.debug("ignoring message same origin");
      else
        this.logger.debug("no handler registered");
    });
    T(this, "send", (e) => {
      var t;
      try {
        return this.target.ReactNativeWebView ? (this.logger.log("sending message (ReactNativeWebview)", e), this.target.ReactNativeWebView.postMessage(e)) : this.target.ElectronWebview ? (this.logger.log("sending message (ElectronWebview)", e), this.target.ElectronWebview.postMessage(e)) : (this.logger.log("sending message", e), (t = this.target.top) == null || t.postMessage(e, "*")), Promise.resolve();
      } catch (r) {
        return this.logger.error("unexpected error on send", r), Promise.reject(r);
      }
    });
    this.target = e, this.logger = t;
  }
  set onMessage(e) {
    this._onMessage = e;
  }
  get onMessage() {
    return this._onMessage;
  }
}
var Et;
(function(n) {
  n.Slow = "slow", n.Medium = "medium", n.Fast = "fast";
})(Et || (Et = {}));
var Tt;
(function(n) {
  n.Blue = "blue", n.NanoS = "nanoS", n.NanoX = "nanoX";
})(Tt || (Tt = {}));
var St;
(function(n) {
  n[n.SWAP = 0] = "SWAP", n[n.SELL = 1] = "SELL", n[n.FUND = 2] = "FUND";
})(St || (St = {}));
const fe = i.enum([
  "NOT_IMPLEMENTED_BY_WALLET",
  "ACCOUNT_NOT_FOUND",
  "CURRENCY_NOT_FOUND",
  "PERMISSION_DENIED",
  "UNKNOWN_ERROR",
  "UNAUTHORIZED_STORE"
]), ua = i.object({
  code: i.literal(fe.enum.NOT_IMPLEMENTED_BY_WALLET),
  message: i.string(),
  data: i.object({
    methodId: i.string()
  })
}), da = i.object({
  code: i.literal(fe.enum.ACCOUNT_NOT_FOUND),
  message: i.string(),
  data: i.object({
    accountId: i.string()
  })
}), la = i.object({
  code: i.literal(fe.enum.CURRENCY_NOT_FOUND),
  message: i.string(),
  data: i.object({
    currencyId: i.string()
  })
}), ha = i.object({
  code: i.literal(fe.enum.PERMISSION_DENIED),
  message: i.string(),
  data: i.object({
    methodId: i.string()
  })
}), ma = i.object({
  name: i.string().optional(),
  message: i.string().optional(),
  stack: i.string().optional(),
  cause: i.unknown().optional(),
  code: i.string().optional()
}), pa = i.object({
  code: i.literal(fe.enum.UNKNOWN_ERROR),
  message: i.string(),
  data: ma.passthrough()
}), fa = i.object({
  code: i.literal(fe.enum.UNAUTHORIZED_STORE),
  message: i.string(),
  data: i.object({
    storeId: i.string()
  })
}), ga = i.discriminatedUnion("code", [
  ua,
  da,
  la,
  ha,
  pa,
  fa
]);
function ya(n) {
  return {
    code: "UNKNOWN_ERROR",
    message: "an unhandled error was thrown",
    data: n
  };
}
class Rt extends Error {
  constructor(t) {
    super(t.message);
    T(this, "errorData");
    this.errorData = t;
  }
  /**
   * Retrieve error code
   * @returns error code
   */
  getCode() {
    return this.errorData.code;
  }
  /**
   * Retrieve underlying data info
   * @returns data info
   */
  getData() {
    return this.errorData;
  }
}
class H extends Error {
  constructor(t) {
    super(t.message);
    T(this, "err");
    this.err = t;
  }
  /**
   * Retrieve error code
   * @returns error code
   */
  getCode() {
    return this.err.code;
  }
  /**
   * Retrieve underlying data info
   * @returns data info
   */
  getData() {
    return this.err.data;
  }
}
var G;
(function(n) {
  n[n.PARSE_ERROR = -32700] = "PARSE_ERROR", n[n.INVALID_REQUEST = -32600] = "INVALID_REQUEST", n[n.METHOD_NOT_FOUND = -32601] = "METHOD_NOT_FOUND", n[n.INVALID_PARAMS = -32602] = "INVALID_PARAMS", n[n.INTERNAL_ERROR = -32603] = "INTERNAL_ERROR", n[n.SERVER_ERROR = -32e3] = "SERVER_ERROR";
})(G || (G = {}));
const lt = i.union([i.string(), i.number(), i.null()]), va = i.object({
  jsonrpc: i.literal("2.0"),
  method: i.string(),
  params: i.any(),
  id: lt.optional()
}).strict(), _a = i.object({
  code: i.number(),
  message: i.string(),
  data: i.any().optional()
}).strict(), xa = i.object({
  jsonrpc: i.literal("2.0"),
  id: lt,
  result: i.object({}).passthrough().optional()
}).strict(), wa = i.object({
  jsonrpc: i.literal("2.0"),
  id: lt,
  error: _a
}).strict(), ba = i.union([
  wa,
  xa
]), Ea = i.union([va, ba]);
function Ta(n) {
  try {
    const e = JSON.parse(n);
    return Ea.parse(e);
  } catch (e) {
    throw e instanceof SyntaxError ? new H({
      code: G.PARSE_ERROR,
      message: "parse error"
    }) : e instanceof i.ZodError ? new H({
      code: G.INVALID_REQUEST,
      message: "invalid request"
    }) : e;
  }
}
function Ct(n) {
  return {
    jsonrpc: "2.0",
    ...n
  };
}
const Wt = {}, Ht = {}, Gt = (n, e) => {
  Ht[n] = e;
}, u = (n) => {
  class e extends Error {
    constructor(r, s, a) {
      if (super(r || n, a), Object.setPrototypeOf(this, e.prototype), this.name = n, s)
        for (const o in s)
          this[o] = s[o];
      if (a && Sa(a) && "cause" in a && !("cause" in this)) {
        const o = a.cause;
        this.cause = o, "stack" in o && (this.stack = this.stack + `
CAUSE: ` + o.stack);
      }
    }
  }
  return Wt[n] = e, e;
};
function Sa(n) {
  return typeof n == "object";
}
const Kt = (n) => {
  if (n && typeof n == "object") {
    try {
      if (typeof n.message == "string") {
        const t = JSON.parse(n.message);
        t.message && t.name && (n = t);
      }
    } catch {
    }
    let e;
    if (typeof n.name == "string") {
      const { name: t } = n, r = Ht[t];
      if (r)
        e = r(n);
      else {
        let s = t === "Error" ? Error : Wt[t];
        s || (s = u(t)), e = Object.create(s.prototype);
        try {
          for (const a in n)
            n.hasOwnProperty(a) && (e[a] = n[a]);
        } catch {
        }
      }
    } else
      typeof n.message == "string" && (e = new Error(n.message));
    return e && !e.stack && Error.captureStackTrace && Error.captureStackTrace(e, Kt), e;
  }
  return new Error(String(n));
}, Ra = (n) => n && (typeof n == "object" ? Yt(n, []) : typeof n == "function" ? `[Function: ${n.name || "anonymous"}]` : n);
function Yt(n, e) {
  const t = {};
  e.push(n);
  for (const r of Object.keys(n)) {
    const s = n[r];
    if (typeof s != "function") {
      if (!s || typeof s != "object") {
        t[r] = s;
        continue;
      }
      if (e.indexOf(n[r]) === -1) {
        t[r] = Yt(n[r], e.slice(0));
        continue;
      }
      t[r] = "[Circular]";
    }
  }
  return typeof n.name == "string" && (t.name = n.name), typeof n.message == "string" && (t.message = n.message), typeof n.stack == "string" && (t.stack = n.stack), t;
}
u("AccountNameRequired");
u("AccountNotSupported");
u("AmountRequired");
u("BluetoothRequired");
u("BtcUnmatchedApp");
u("CantOpenDevice");
u("CashAddrNotSupported");
u("ClaimRewardsFeesWarning");
u("CurrencyNotSupported");
u("DeviceAppVerifyNotSupported");
u("DeviceGenuineSocketEarlyClose");
u("DeviceNotGenuine");
u("DeviceOnDashboardExpected");
u("DeviceOnDashboardUnexpected");
u("DeviceInOSUExpected");
u("DeviceHalted");
u("DeviceNameInvalid");
u("DeviceSocketFail");
u("DeviceSocketNoBulkStatus");
u("DeviceSocketNoBulkStatus");
u("UnresponsiveDeviceError");
u("DisconnectedDevice");
u("DisconnectedDeviceDuringOperation");
u("DeviceExtractOnboardingStateError");
u("DeviceOnboardingStatePollingError");
u("EnpointConfig");
u("EthAppPleaseEnableContractData");
u("FeeEstimationFailed");
u("FirmwareNotRecognized");
u("HardResetFail");
u("InvalidXRPTag");
u("InvalidAddress");
u("InvalidNonce");
u("InvalidAddressBecauseDestinationIsAlsoSource");
u("LatestMCUInstalledError");
u("UnknownMCU");
u("LedgerAPIError");
u("LedgerAPIErrorWithMessage");
u("LedgerAPINotAvailable");
u("ManagerAppAlreadyInstalled");
u("ManagerAppRelyOnBTC");
u("ManagerAppDepInstallRequired");
u("ManagerAppDepUninstallRequired");
u("ManagerDeviceLocked");
u("ManagerFirmwareNotEnoughSpace");
u("ManagerNotEnoughSpace");
u("ManagerUninstallBTCDep");
u("NetworkDown");
u("NetworkError");
u("NoAddressesFound");
u("NotEnoughBalance");
u("NotEnoughBalanceToDelegate");
u("NotEnoughBalanceInParentAccount");
u("NotEnoughSpendableBalance");
u("NotEnoughBalanceBecauseDestinationNotCreated");
u("NoAccessToCamera");
u("NotEnoughGas");
u("NotEnoughGasSwap");
u("NotSupportedLegacyAddress");
u("GasLessThanEstimate");
u("PriorityFeeTooLow");
u("PriorityFeeTooHigh");
u("PriorityFeeHigherThanMaxFee");
u("MaxFeeTooLow");
u("PasswordsDontMatch");
u("PasswordIncorrect");
u("RecommendSubAccountsToEmpty");
u("RecommendUndelegation");
u("TimeoutTagged");
u("UnexpectedBootloader");
u("MCUNotGenuineToDashboard");
u("RecipientRequired");
u("UnavailableTezosOriginatedAccountReceive");
u("UnavailableTezosOriginatedAccountSend");
u("UpdateFetchFileFail");
u("UpdateIncorrectHash");
u("UpdateIncorrectSig");
u("UpdateYourApp");
u("UserRefusedDeviceNameChange");
u("UserRefusedAddress");
u("UserRefusedFirmwareUpdate");
u("UserRefusedAllowManager");
u("UserRefusedOnDevice");
u("ExpertModeRequired");
u("TransportOpenUserCancelled");
u("TransportInterfaceNotAvailable");
u("TransportRaceCondition");
u("TransportWebUSBGestureRequired");
u("TransactionHasBeenValidatedError");
u("TransportExchangeTimeoutError");
u("DeviceShouldStayInApp");
u("WebsocketConnectionError");
u("WebsocketConnectionFailed");
u("WrongDeviceForAccount");
u("WrongAppForCurrency");
u("ETHAddressNonEIP");
u("CantScanQRCode");
u("FeeNotLoaded");
u("FeeNotLoadedSwap");
u("FeeRequired");
u("FeeTooHigh");
u("PendingOperation");
u("SyncError");
u("PairingFailed");
u("PeerRemovedPairing");
u("GenuineCheckFailed");
u("LedgerAPI4xx");
u("LedgerAPI5xx");
u("FirmwareOrAppUpdateRequired");
u("ReplacementTransactionUnderpriced");
u("OpReturnSizeLimit");
u("DustLimit");
u("LanguageNotFound");
u("NoDBPathGiven");
u("DBWrongPassword");
u("DBNotReset");
var Nt;
(function(n) {
  n.Unknown = "Unknown", n.LocationServicesDisabled = "LocationServicesDisabled", n.LocationServicesUnauthorized = "LocationServicesUnauthorized", n.BluetoothScanStartFailed = "BluetoothScanStartFailed";
})(Nt || (Nt = {}));
let Ca = class extends Error {
  constructor(e, t) {
    const r = "TransportError";
    super(e || r), this.name = r, this.message = e, this.stack = new Error(e).stack, this.id = t;
  }
};
Gt("TransportError", (n) => new Ca(n.message, n.id));
const $e = {
  ACCESS_CONDITION_NOT_FULFILLED: 38916,
  ALGORITHM_NOT_SUPPORTED: 38020,
  CLA_NOT_SUPPORTED: 28160,
  CODE_BLOCKED: 38976,
  CODE_NOT_INITIALIZED: 38914,
  COMMAND_INCOMPATIBLE_FILE_STRUCTURE: 27009,
  CONDITIONS_OF_USE_NOT_SATISFIED: 27013,
  CONTRADICTION_INVALIDATION: 38928,
  CONTRADICTION_SECRET_CODE_STATUS: 38920,
  CUSTOM_IMAGE_BOOTLOADER: 26159,
  CUSTOM_IMAGE_EMPTY: 26158,
  FILE_ALREADY_EXISTS: 27273,
  FILE_NOT_FOUND: 37892,
  GP_AUTH_FAILED: 25344,
  HALTED: 28586,
  INCONSISTENT_FILE: 37896,
  INCORRECT_DATA: 27264,
  INCORRECT_LENGTH: 26368,
  INCORRECT_P1_P2: 27392,
  INS_NOT_SUPPORTED: 27904,
  DEVICE_NOT_ONBOARDED: 27911,
  DEVICE_NOT_ONBOARDED_2: 26129,
  INVALID_KCV: 38021,
  INVALID_OFFSET: 37890,
  LICENSING: 28482,
  LOCKED_DEVICE: 21781,
  MAX_VALUE_REACHED: 38992,
  MEMORY_PROBLEM: 37440,
  MISSING_CRITICAL_PARAMETER: 26624,
  NO_EF_SELECTED: 37888,
  NOT_ENOUGH_MEMORY_SPACE: 27268,
  OK: 36864,
  PIN_REMAINING_ATTEMPTS: 25536,
  REFERENCED_DATA_NOT_FOUND: 27272,
  SECURITY_STATUS_NOT_SATISFIED: 27010,
  TECHNICAL_PROBLEM: 28416,
  UNKNOWN_APDU: 27906,
  USER_REFUSED_ON_DEVICE: 21761,
  NOT_ENOUGH_SPACE: 20738
};
function Na(n) {
  switch (n) {
    case 26368:
      return "Incorrect length";
    case 26624:
      return "Missing critical parameter";
    case 27010:
      return "Security not satisfied (dongle locked or have invalid access rights)";
    case 27013:
      return "Condition of use not satisfied (denied by the user?)";
    case 27264:
      return "Invalid data received";
    case 27392:
      return "Invalid parameter received";
    case 21781:
      return "Locked device";
  }
  if (28416 <= n && n <= 28671)
    return "Internal error, please report";
}
let Xt = class Jt extends Error {
  /**
   * @param statusCode The error status code coming from a Transport implementation
   * @param options containing:
   *  - canBeMappedToChildError: enable the mapping of TransportStatusError to an error extending/inheriting from it
   *  . Ex: LockedDeviceError. Default to true.
   */
  constructor(e, { canBeMappedToChildError: t = !0 } = {}) {
    const r = Object.keys($e).find((c) => $e[c] === e) || "UNKNOWN_ERROR", s = Na(e) || r, a = e.toString(16), o = `Ledger device: ${s} (0x${a})`;
    if (super(o), this.name = "TransportStatusError", this.statusCode = e, this.statusText = r, Object.setPrototypeOf(this, Jt.prototype), t && e === $e.LOCKED_DEVICE)
      return new Ia(o);
  }
}, Ia = class Qt extends Xt {
  constructor(e) {
    super($e.LOCKED_DEVICE, { canBeMappedToChildError: !1 }), e && (this.message = e), this.name = "LockedDeviceError", Object.setPrototypeOf(this, Qt.prototype);
  }
};
Gt("TransportStatusError", (n) => new Xt(n.statusCode));
let Be;
const ka = new Uint8Array(16);
function Oa() {
  if (!Be && (Be = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Be))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return Be(ka);
}
const A = [];
for (let n = 0; n < 256; ++n)
  A.push((n + 256).toString(16).slice(1));
function Aa(n, e = 0) {
  return A[n[e + 0]] + A[n[e + 1]] + A[n[e + 2]] + A[n[e + 3]] + "-" + A[n[e + 4]] + A[n[e + 5]] + "-" + A[n[e + 6]] + A[n[e + 7]] + "-" + A[n[e + 8]] + A[n[e + 9]] + "-" + A[n[e + 10]] + A[n[e + 11]] + A[n[e + 12]] + A[n[e + 13]] + A[n[e + 14]] + A[n[e + 15]];
}
const Da = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), It = {
  randomUUID: Da
};
function Pa(n, e, t) {
  if (It.randomUUID && !e && !n)
    return It.randomUUID();
  n = n || {};
  const r = n.random || (n.rng || Oa)();
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, Aa(r);
}
class La {
  constructor(e, t) {
    T(this, "transport");
    T(this, "requestHandlers");
    T(this, "ongoingRequests", {});
    this.transport = e, this.requestHandlers = t, this.transport.onMessage = (r) => {
      this.handleMessage(r);
    };
  }
  _request(e) {
    return new Promise((t, r) => {
      if (!e.id) {
        r(new Error("requests need to have an id"));
        return;
      }
      const s = (a) => {
        if ("error" in a) {
          if (a.error.code === G.SERVER_ERROR) {
            const o = ga.parse(a.error.data);
            if (o.code === "UNKNOWN_ERROR") {
              r(Kt(o.data));
              return;
            }
            r(new Rt(o));
            return;
          }
          r(new H(a.error));
          return;
        }
        t(a.result);
      };
      this.ongoingRequests[e.id] = s, this.transport.send(JSON.stringify(e));
    });
  }
  _notify(e) {
    this.transport.send(JSON.stringify(e));
  }
  request(e, t) {
    const r = Pa();
    return this._request({
      id: r,
      jsonrpc: "2.0",
      method: e,
      params: t
    });
  }
  notify(e, t) {
    return this._notify({
      jsonrpc: "2.0",
      method: e,
      params: t
    });
  }
  async handleRpcRequest(e) {
    try {
      const t = await this.onRequest(e);
      if (e.id) {
        const r = Ct({
          id: e.id,
          result: t
        });
        this.transport.send(JSON.stringify(r));
      }
    } catch (t) {
      if (t instanceof i.ZodError)
        throw new H({
          code: G.INVALID_PARAMS,
          message: t.message,
          data: t.flatten()
        });
      if (t instanceof Rt)
        throw new H({
          code: G.SERVER_ERROR,
          message: "unexpected server error",
          data: t.getData()
        });
      if (t instanceof H)
        throw t;
      let r = Ra(t);
      throw r = typeof r == "string" || !r ? { message: r } : r, new H({
        code: G.SERVER_ERROR,
        message: "unexpected server error",
        data: ya(r)
      });
    }
  }
  async handleMessage(e) {
    let t = !1, r;
    try {
      const s = Ta(e);
      r = s.id, "method" in s ? await this.handleRpcRequest(s) : (t = !0, this.handleRpcResponse(s));
    } catch (s) {
      if (t)
        throw s;
      if (s instanceof H) {
        const a = Ct({
          id: r ?? null,
          error: {
            code: s.getCode(),
            message: s.message,
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            data: s.getData()
          }
        });
        this.transport.send(JSON.stringify(a));
        return;
      }
      throw s;
    }
  }
  handleRpcResponse(e) {
    if (!e.id)
      return;
    const t = this.ongoingRequests[e.id];
    if (!t)
      throw new Error(`no ongoingRequest ${e.id}`);
    t(e);
  }
}
const Ma = i.object({
  currencyIds: i.array(i.string()).optional()
}).optional(), Ua = i.object({
  rawAccounts: i.array(zt)
}), ja = {
  params: Ma,
  result: Ua
}, Za = i.object({
  accountId: i.string(),
  tokenCurrency: i.string().optional()
}), Fa = i.object({
  address: i.string()
}), Ba = {
  params: Za,
  result: Fa
}, za = i.object({
  currencyIds: i.array(i.string()).optional()
}), Va = i.object({
  rawAccount: zt
}), $a = {
  params: za,
  result: Va
}, qa = i.object({
  accountId: i.string(),
  derivationPath: i.string().optional()
}), Wa = i.object({
  address: i.string()
}), Ha = {
  params: qa,
  result: Wa
}, Ga = i.object({
  accountId: i.string(),
  derivationPath: i.string().optional()
}), Ka = i.object({
  publicKey: i.string()
}), Ya = {
  params: Ga,
  result: Ka
}, Xa = i.object({
  accountId: i.string()
}), Ja = i.object({
  xPub: i.string()
}), Qa = {
  params: Xa,
  result: Ja
}, ei = i.object({
  currencyIds: i.array(i.string()).optional()
}).optional(), ti = i.object({
  currencies: i.array(Ir)
}), ni = {
  params: ei,
  result: ti
}, en = i.enum([
  "blue",
  "nanoS",
  "nanoSP",
  "nanoX",
  "stax",
  "europa"
]), ri = i.object({
  transportId: i.string()
}), si = i.object({
  transportId: i.string()
}), ai = {
  params: ri,
  result: si
}, ii = i.object({
  apduHex: i.string(),
  transportId: i.string()
}), oi = i.object({
  responseHex: i.string()
}), ci = {
  params: ii,
  result: oi
}, ui = i.object({
  /** ID of the device to select */
  deviceId: i.string()
}), di = i.object({
  transportId: i.string()
}), li = {
  params: ui,
  result: di
}, hi = i.object({
  /** Select the BOLOS App. If undefined selects BOLOS */
  appName: i.string().optional(),
  /**
   * Checks the BOLOS App version range. If undefined no checks
   * Can be any ranges supported here: https://github.com/npm/node-semver#ranges
   */
  appVersionRange: i.string().optional(),
  /**
   * Checks the BOLOS Firmware version range. If undefined no checks
   * Can be any ranges supported here: https://github.com/npm/node-semver#ranges
   */
  firmwareVersionRange: i.string().optional(),
  /**
   * Checks if the device is seeded. If undefined no checks
   */
  seeded: i.boolean().optional(),
  /**
   * Checks if the device matches one of the types. If undefined no checks
   */
  devices: en.array().nonempty().optional()
}), mi = i.object({
  deviceId: i.string()
}), pi = {
  params: hi,
  result: mi
}, fi = i.object({
  /** Select the BOLOS App. If undefined selects BOLOS */
  appName: i.string().optional(),
  /**
   * Checks the BOLOS App version range. If undefined no checks
   * Can be any ranges supported here: https://github.com/npm/node-semver#ranges
   */
  appVersionRange: i.string().optional(),
  /**
   * Checks the BOLOS Firmware version range. If undefined no checks
   * Can be any ranges supported here: https://github.com/npm/node-semver#ranges
   */
  firmwareVersionRange: i.string().optional(),
  /**
   * Checks if the device is seeded. If undefined no checks
   */
  seeded: i.boolean().optional(),
  /**
   * Checks if the device matches one of the types. If undefined no checks
   */
  devices: en.array().nonempty().optional()
}), gi = i.object({
  transportId: i.string()
}), yi = {
  params: fi,
  result: gi
}, vi = i.enum(["SLOW", "MEDIUM", "FAST", "CUSTOM"]), ht = i.object({
  provider: i.string(),
  fromAccountId: i.string(),
  rawTransaction: dt,
  hexBinaryPayload: i.string(),
  hexSignature: i.string(),
  feeStrategy: vi,
  tokenCurrency: i.string().optional()
}), _i = ht.extend({
  exchangeType: i.literal("FUND")
}), xi = ht.extend({
  exchangeType: i.literal("SELL")
}), wi = ht.extend({
  exchangeType: i.literal("SWAP"),
  toAccountId: i.string(),
  swapId: i.string(),
  rate: i.number()
}), bi = i.discriminatedUnion("exchangeType", [
  _i,
  xi,
  wi
]), Ei = i.object({
  transactionHash: i.string()
}), at = {
  params: bi,
  result: Ei
}, Ti = i.enum([
  "SWAP",
  "SELL",
  "FUND",
  "SWAP_NG",
  "SELL_NG",
  "FUND_NG"
]), Si = i.object({
  exchangeType: Ti
}), Ri = i.object({
  transactionId: i.string()
}), Ci = {
  params: Si,
  result: Ri
}, Ni = i.object({
  accountId: i.string(),
  hexMessage: i.string(),
  meta: i.record(i.string(), i.unknown()).optional()
}), Ii = i.object({
  hexSignedMessage: i.string()
}), ki = {
  params: Ni,
  result: Ii
}, Oi = i.object({
  key: i.string().min(1),
  storeId: i.string().min(1).optional()
}), Ai = i.object({
  value: i.string().optional()
}), Di = {
  params: Oi,
  result: Ai
}, Pi = i.object({
  key: i.string(),
  value: i.string(),
  storeId: i.string().optional()
}), Li = i.void().optional(), Mi = {
  params: Pi,
  result: Li
}, Ui = i.object({
  hwAppId: i.string().optional(),
  dependencies: i.array(i.string()).optional()
}), ji = i.object({
  accountId: i.string(),
  rawTransaction: dt,
  options: Ui.optional(),
  meta: i.record(i.string(), i.unknown()).optional(),
  tokenCurrency: i.string().optional()
}), Zi = i.object({
  signedTransactionHex: i.string()
}), Fi = {
  params: ji,
  result: Zi
}, Bi = i.object({
  hwAppId: i.string().optional(),
  dependencies: i.array(i.string()).optional()
}), zi = i.object({
  accountId: i.string(),
  rawTransaction: dt,
  options: Bi.optional(),
  meta: i.record(i.string(), i.unknown()).optional(),
  tokenCurrency: i.string().optional()
}), Vi = i.object({
  transactionHash: i.string()
}), $i = {
  params: zi,
  result: Vi
}, qi = i.object({}), Wi = i.object({
  methodIds: i.array(i.string())
}), Hi = {
  params: qi,
  result: Wi
}, Gi = i.object({}), Ki = i.object({
  tracking: i.boolean(),
  wallet: i.object({
    name: i.string(),
    version: i.string()
  })
}), Yi = {
  params: Gi,
  result: Ki
}, Xi = i.object({}), Ji = i.object({
  userId: i.string()
}), Qi = {
  params: Xi,
  result: Ji
};
i.enum([
  "account.list",
  "account.receive",
  "account.request",
  "currency.list",
  "device.close",
  "device.exchange",
  "device.transport",
  "message.sign",
  "transaction.sign",
  "transaction.signAndBroadcast",
  "wallet.capabilities",
  "wallet.info",
  "wallet.userId"
]);
const eo = {}, to = {}, tn = (n, e) => {
  to[n] = e;
}, d = (n) => {
  class e extends Error {
    constructor(r, s, a) {
      if (super(r || n, a), Object.setPrototypeOf(this, e.prototype), this.name = n, s)
        for (const o in s)
          this[o] = s[o];
      if (a && no(a) && "cause" in a && !("cause" in this)) {
        const o = a.cause;
        this.cause = o, "stack" in o && (this.stack = this.stack + `
CAUSE: ` + o.stack);
      }
    }
  }
  return eo[n] = e, e;
};
function no(n) {
  return typeof n == "object";
}
d("AccountNameRequired");
d("AccountNotSupported");
d("AmountRequired");
d("BluetoothRequired");
d("BtcUnmatchedApp");
d("CantOpenDevice");
d("CashAddrNotSupported");
d("ClaimRewardsFeesWarning");
d("CurrencyNotSupported");
d("DeviceAppVerifyNotSupported");
d("DeviceGenuineSocketEarlyClose");
d("DeviceNotGenuine");
d("DeviceOnDashboardExpected");
d("DeviceOnDashboardUnexpected");
d("DeviceInOSUExpected");
d("DeviceHalted");
d("DeviceNameInvalid");
d("DeviceSocketFail");
d("DeviceSocketNoBulkStatus");
d("DeviceSocketNoBulkStatus");
d("UnresponsiveDeviceError");
d("DisconnectedDevice");
d("DisconnectedDeviceDuringOperation");
d("DeviceExtractOnboardingStateError");
d("DeviceOnboardingStatePollingError");
d("EnpointConfig");
d("EthAppPleaseEnableContractData");
d("FeeEstimationFailed");
d("FirmwareNotRecognized");
d("HardResetFail");
d("InvalidXRPTag");
d("InvalidAddress");
d("InvalidNonce");
d("InvalidAddressBecauseDestinationIsAlsoSource");
d("LatestMCUInstalledError");
d("UnknownMCU");
d("LedgerAPIError");
d("LedgerAPIErrorWithMessage");
d("LedgerAPINotAvailable");
d("ManagerAppAlreadyInstalled");
d("ManagerAppRelyOnBTC");
d("ManagerAppDepInstallRequired");
d("ManagerAppDepUninstallRequired");
d("ManagerDeviceLocked");
d("ManagerFirmwareNotEnoughSpace");
d("ManagerNotEnoughSpace");
d("ManagerUninstallBTCDep");
d("NetworkDown");
d("NetworkError");
d("NoAddressesFound");
d("NotEnoughBalance");
d("NotEnoughBalanceToDelegate");
d("NotEnoughBalanceInParentAccount");
d("NotEnoughSpendableBalance");
d("NotEnoughBalanceBecauseDestinationNotCreated");
d("NoAccessToCamera");
d("NotEnoughGas");
d("NotEnoughGasSwap");
d("NotSupportedLegacyAddress");
d("GasLessThanEstimate");
d("PriorityFeeTooLow");
d("PriorityFeeTooHigh");
d("PriorityFeeHigherThanMaxFee");
d("MaxFeeTooLow");
d("PasswordsDontMatch");
d("PasswordIncorrect");
d("RecommendSubAccountsToEmpty");
d("RecommendUndelegation");
d("TimeoutTagged");
d("UnexpectedBootloader");
d("MCUNotGenuineToDashboard");
d("RecipientRequired");
d("UnavailableTezosOriginatedAccountReceive");
d("UnavailableTezosOriginatedAccountSend");
d("UpdateFetchFileFail");
d("UpdateIncorrectHash");
d("UpdateIncorrectSig");
d("UpdateYourApp");
d("UserRefusedDeviceNameChange");
d("UserRefusedAddress");
d("UserRefusedFirmwareUpdate");
d("UserRefusedAllowManager");
d("UserRefusedOnDevice");
d("ExpertModeRequired");
d("TransportOpenUserCancelled");
d("TransportInterfaceNotAvailable");
const ro = d("TransportRaceCondition");
d("TransportWebUSBGestureRequired");
d("TransactionHasBeenValidatedError");
d("TransportExchangeTimeoutError");
d("DeviceShouldStayInApp");
d("WebsocketConnectionError");
d("WebsocketConnectionFailed");
d("WrongDeviceForAccount");
d("WrongAppForCurrency");
d("ETHAddressNonEIP");
d("CantScanQRCode");
d("FeeNotLoaded");
d("FeeNotLoadedSwap");
d("FeeRequired");
d("FeeTooHigh");
d("PendingOperation");
d("SyncError");
d("PairingFailed");
d("PeerRemovedPairing");
d("GenuineCheckFailed");
d("LedgerAPI4xx");
d("LedgerAPI5xx");
d("FirmwareOrAppUpdateRequired");
d("ReplacementTransactionUnderpriced");
d("OpReturnSizeLimit");
d("DustLimit");
d("LanguageNotFound");
d("NoDBPathGiven");
d("DBWrongPassword");
d("DBNotReset");
var kt;
(function(n) {
  n.Unknown = "Unknown", n.LocationServicesDisabled = "LocationServicesDisabled", n.LocationServicesUnauthorized = "LocationServicesUnauthorized", n.BluetoothScanStartFailed = "BluetoothScanStartFailed";
})(kt || (kt = {}));
class xe extends Error {
  constructor(e, t) {
    const r = "TransportError";
    super(e || r), this.name = r, this.message = e, this.stack = new Error(e).stack, this.id = t;
  }
}
tn("TransportError", (n) => new xe(n.message, n.id));
const le = {
  ACCESS_CONDITION_NOT_FULFILLED: 38916,
  ALGORITHM_NOT_SUPPORTED: 38020,
  CLA_NOT_SUPPORTED: 28160,
  CODE_BLOCKED: 38976,
  CODE_NOT_INITIALIZED: 38914,
  COMMAND_INCOMPATIBLE_FILE_STRUCTURE: 27009,
  CONDITIONS_OF_USE_NOT_SATISFIED: 27013,
  CONTRADICTION_INVALIDATION: 38928,
  CONTRADICTION_SECRET_CODE_STATUS: 38920,
  CUSTOM_IMAGE_BOOTLOADER: 26159,
  CUSTOM_IMAGE_EMPTY: 26158,
  FILE_ALREADY_EXISTS: 27273,
  FILE_NOT_FOUND: 37892,
  GP_AUTH_FAILED: 25344,
  HALTED: 28586,
  INCONSISTENT_FILE: 37896,
  INCORRECT_DATA: 27264,
  INCORRECT_LENGTH: 26368,
  INCORRECT_P1_P2: 27392,
  INS_NOT_SUPPORTED: 27904,
  DEVICE_NOT_ONBOARDED: 27911,
  DEVICE_NOT_ONBOARDED_2: 26129,
  INVALID_KCV: 38021,
  INVALID_OFFSET: 37890,
  LICENSING: 28482,
  LOCKED_DEVICE: 21781,
  MAX_VALUE_REACHED: 38992,
  MEMORY_PROBLEM: 37440,
  MISSING_CRITICAL_PARAMETER: 26624,
  NO_EF_SELECTED: 37888,
  NOT_ENOUGH_MEMORY_SPACE: 27268,
  OK: 36864,
  PIN_REMAINING_ATTEMPTS: 25536,
  REFERENCED_DATA_NOT_FOUND: 27272,
  SECURITY_STATUS_NOT_SATISFIED: 27010,
  TECHNICAL_PROBLEM: 28416,
  UNKNOWN_APDU: 27906,
  USER_REFUSED_ON_DEVICE: 21761,
  NOT_ENOUGH_SPACE: 20738
};
function so(n) {
  switch (n) {
    case 26368:
      return "Incorrect length";
    case 26624:
      return "Missing critical parameter";
    case 27010:
      return "Security not satisfied (dongle locked or have invalid access rights)";
    case 27013:
      return "Condition of use not satisfied (denied by the user?)";
    case 27264:
      return "Invalid data received";
    case 27392:
      return "Invalid parameter received";
    case 21781:
      return "Locked device";
  }
  if (28416 <= n && n <= 28671)
    return "Internal error, please report";
}
class pe extends Error {
  /**
   * @param statusCode The error status code coming from a Transport implementation
   * @param options containing:
   *  - canBeMappedToChildError: enable the mapping of TransportStatusError to an error extending/inheriting from it
   *  . Ex: LockedDeviceError. Default to true.
   */
  constructor(e, { canBeMappedToChildError: t = !0 } = {}) {
    const r = Object.keys(le).find((c) => le[c] === e) || "UNKNOWN_ERROR", s = so(e) || r, a = e.toString(16), o = `Ledger device: ${s} (0x${a})`;
    if (super(o), this.name = "TransportStatusError", this.statusCode = e, this.statusText = r, Object.setPrototypeOf(this, pe.prototype), t && e === le.LOCKED_DEVICE)
      return new mt(o);
  }
}
class mt extends pe {
  constructor(e) {
    super(le.LOCKED_DEVICE, { canBeMappedToChildError: !1 }), e && (this.message = e), this.name = "LockedDeviceError", Object.setPrototypeOf(this, mt.prototype);
  }
}
tn("TransportStatusError", (n) => new pe(n.statusCode));
var ze = function(n, e, t, r) {
  function s(a) {
    return a instanceof t ? a : new t(function(o) {
      o(a);
    });
  }
  return new (t || (t = Promise))(function(a, o) {
    function c(p) {
      try {
        h(r.next(p));
      } catch (b) {
        o(b);
      }
    }
    function l(p) {
      try {
        h(r.throw(p));
      } catch (b) {
        o(b);
      }
    }
    function h(p) {
      p.done ? a(p.value) : s(p.value).then(c, l);
    }
    h((r = r.apply(n, e || [])).next());
  });
};
const ao = "transport";
class pt {
  constructor({ context: e, logType: t } = {}) {
    this.exchangeTimeout = 3e4, this.unresponsiveTimeout = 15e3, this.deviceModel = null, this._events = new xn(), this.send = (r, s, a, o, c = V.alloc(0), l = [le.OK], { abortTimeoutMs: h } = {}) => ze(this, void 0, void 0, function* () {
      const p = this.tracer.withUpdatedContext({ function: "send" });
      if (c.length >= 256)
        throw p.trace("data.length exceeded 256 bytes limit", { dataLength: c.length }), new xe("data.length exceed 256 bytes limit. Got: " + c.length, "DataLengthTooBig");
      p.trace("Starting an exchange", { abortTimeoutMs: h });
      const b = yield this.exchange(
        // The size of the data is added in 1 byte just before `data`
        V.concat([V.from([r, s, a, o]), V.from([c.length]), c]),
        { abortTimeoutMs: h }
      );
      p.trace("Received response from exchange");
      const O = b.readUInt16BE(b.length - 2);
      if (!l.some((L) => L === O))
        throw new pe(O);
      return b;
    }), this._appAPIlock = null, this.tracer = new wn(t ?? ao, e);
  }
  /**
   * Send data to the device using a low level API.
   * It's recommended to use the "send" method for a higher level API.
   * @param {Buffer} apdu - The data to send.
   * @param {Object} options - Contains optional options for the exchange function
   *  - abortTimeoutMs: stop the exchange after a given timeout. Another timeout exists
   *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.
   * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.
   */
  exchange(e, { abortTimeoutMs: t } = {}) {
    throw new Error("exchange not implemented");
  }
  /**
   * Send apdus in batch to the device using a low level API.
   * The default implementation is to call exchange for each apdu.
   * @param {Array<Buffer>} apdus - array of apdus to send.
   * @param {Observer<Buffer>} observer - an observer that will receive the response of each apdu.
   * @returns {Subscription} A Subscription object on which you can call ".unsubscribe()" to stop sending apdus.
   */
  exchangeBulk(e, t) {
    let r = !1;
    const s = () => {
      r = !0;
    };
    return ze(this, void 0, void 0, function* () {
      if (!r)
        for (const o of e) {
          const c = yield this.exchange(o);
          if (r)
            return;
          const l = c.readUInt16BE(c.length - 2);
          if (l !== le.OK)
            throw new pe(l);
          t.next(c);
        }
    }).then(() => !r && t.complete(), (o) => !r && t.error(o)), { unsubscribe: s };
  }
  /**
   * Set the "scramble key" for the next data exchanges with the device.
   * Each app can have a different scramble key and it is set internally during instantiation.
   * @param {string} key - The scramble key to set.
   * deprecated This method is no longer needed for modern transports and should be migrated away from.
   * no @ before deprecated as it breaks documentationjs on version 14.0.2
   * https://github.com/documentationjs/documentation/issues/1596
   */
  setScrambleKey(e) {
  }
  /**
   * Close the connection with the device.
   *
   * Note: for certain transports (hw-transport-node-hid-singleton for ex), once the promise resolved,
   * the transport instance is actually still cached, and the device is disconnected only after a defined timeout.
   * But for the consumer of the Transport, this does not matter and it can consider the transport to be closed.
   *
   * @returns {Promise<void>} A promise that resolves when the transport is closed.
   */
  close() {
    return Promise.resolve();
  }
  /**
   * Listen for an event on the transport instance.
   * Transport implementations may have specific events. Common events include:
   * "disconnect" : triggered when the transport is disconnected.
   * @param {string} eventName - The name of the event to listen for.
   * @param {(...args: Array<any>) => any} cb - The callback function to be invoked when the event occurs.
   */
  on(e, t) {
    this._events.on(e, t);
  }
  /**
   * Stop listening to an event on an instance of transport.
   */
  off(e, t) {
    this._events.removeListener(e, t);
  }
  emit(e, ...t) {
    this._events.emit(e, ...t);
  }
  /**
   * Enable or not logs of the binary exchange
   */
  setDebugMode() {
  }
  /**
   * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)
   */
  setExchangeTimeout(e) {
    this.exchangeTimeout = e;
  }
  /**
   * Define the delay before emitting "unresponsive" on an exchange that does not respond
   */
  setExchangeUnresponsiveTimeout(e) {
    this.unresponsiveTimeout = e;
  }
  /**
   * create() allows to open the first descriptor available or
   * throw if there is none or if timeout is reached.
   * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)
   * @example
  TransportFoo.create().then(transport => ...)
   */
  static create(e = 3e3, t) {
    return new Promise((r, s) => {
      let a = !1;
      const o = this.listen({
        next: (l) => {
          a = !0, o && o.unsubscribe(), c && clearTimeout(c), this.open(l.descriptor, e).then(r, s);
        },
        error: (l) => {
          c && clearTimeout(c), s(l);
        },
        complete: () => {
          c && clearTimeout(c), a || s(new xe(this.ErrorMessage_NoDeviceFound, "NoDeviceFound"));
        }
      }), c = t ? setTimeout(() => {
        o.unsubscribe(), s(new xe(this.ErrorMessage_ListenTimeout, "ListenTimeout"));
      }, t) : null;
    });
  }
  /**
   * Wrapper to make an exchange "atomic" (blocking any other exchange)
   *
   * It also handles "unresponsiveness" by emitting "unresponsive" and "responsive" events.
   *
   * @param f The exchange job, using the transport to run
   * @returns a Promise resolving with the output of the given job
   */
  exchangeAtomicImpl(e) {
    return ze(this, void 0, void 0, function* () {
      const t = this.tracer.withUpdatedContext({
        function: "exchangeAtomicImpl",
        unresponsiveTimeout: this.unresponsiveTimeout
      });
      if (this.exchangeBusyPromise)
        throw t.trace("Atomic exchange is already busy"), new ro("An action was already pending on the Ledger device. Please deny or reconnect.");
      let r;
      const s = new Promise((c) => {
        r = c;
      });
      this.exchangeBusyPromise = s;
      let a = !1;
      const o = setTimeout(() => {
        t.trace('Timeout reached, emitting Transport event "unresponsive"', {
          unresponsiveTimeout: this.unresponsiveTimeout
        }), a = !0, this.emit("unresponsive");
      }, this.unresponsiveTimeout);
      try {
        const c = yield e();
        return a && (t.trace("Device was unresponsive, emitting responsive"), this.emit("responsive")), c;
      } finally {
        t.trace("Finalize, clearing busy guard"), clearTimeout(o), r && r(), this.exchangeBusyPromise = null;
      }
    });
  }
  decorateAppAPIMethods(e, t, r) {
    for (const s of t)
      e[s] = this.decorateAppAPIMethod(s, e[s], e, r);
  }
  decorateAppAPIMethod(e, t, r, s) {
    return (...a) => ze(this, void 0, void 0, function* () {
      const { _appAPIlock: o } = this;
      if (o)
        return Promise.reject(new xe("Ledger Device is busy (lock " + o + ")", "TransportLocked"));
      try {
        return this._appAPIlock = e, this.setScrambleKey(s), yield t.apply(r, a);
      } finally {
        this._appAPIlock = null;
      }
    });
  }
  /**
   * Sets the context used by the logging/tracing mechanism
   *
   * Useful when re-using (cached) the same Transport instance,
   * but with a new tracing context.
   *
   * @param context A TraceContext, that can undefined to reset the context
   */
  setTraceContext(e) {
    this.tracer = this.tracer.withContext(e);
  }
  /**
   * Updates the context used by the logging/tracing mechanism
   *
   * The update only overrides the key-value that are already defined in the current context.
   *
   * @param contextToAdd A TraceContext that will be added to the current context
   */
  updateTraceContext(e) {
    this.tracer.updateContext(e);
  }
  /**
   * Gets the tracing context of the transport instance
   */
  getTraceContext() {
    return this.tracer.getContext();
  }
}
pt.ErrorMessage_ListenTimeout = "No Ledger device found (timeout)";
pt.ErrorMessage_NoDeviceFound = "No Ledger device found";
const ue = class ue extends pt {
  constructor(t, r) {
    super();
    T(this, "walletApi");
    T(this, "transportId");
    this.transportId = r, this.walletApi = t;
  }
  /**
   * Create a Ledger transport with the Wallet API transport
   */
  static open({ walletApi: t, transportId: r }) {
    return Promise.resolve(new ue(t, r));
  }
  /**
   * Exchange with the device using APDU protocol.
   * @param apdu
   * @returns a promise of apdu response
   * @throws {@link RpcError} if an error occurred on server side
   */
  async exchange(t) {
    const r = t.toString("hex"), s = await this.walletApi.request("device.exchange", {
      transportId: this.transportId,
      apduHex: r
    }), a = ci.result.parse(s);
    return V.from(a.responseHex, "hex");
  }
  // eslint-disable-next-line class-methods-use-this
  setScrambleKey() {
  }
  /**
   * Close the current transport communication.
   *
   * @throws {@link RpcError} if an error occurred on server side
   */
  async close() {
    const t = await this.walletApi.request("device.close", {
      transportId: this.transportId
    });
    ai.result.parse(t);
  }
};
/**
 * Check if Wallet API transport is supported.
 */
T(ue, "isSupported", () => Promise.resolve(!0)), /**
 * This transport is not discoverable
 */
T(ue, "list", () => Promise.resolve([])), T(ue, "listen", (t) => ({
  unsubscribe: () => {
  }
}));
let et = ue;
class io {
  constructor(e) {
    T(this, "client");
    this.client = e;
  }
  /**
   * List accounts added by user on the connected wallet
   *
   * @param params - Filters for currencies
   *
   * @returns The list of accounts on the connected wallet
   * @throws {@link RpcError} if an error occurred on server side
   */
  async list(e) {
    const t = await this.client.request("account.list", {
      currencyIds: e == null ? void 0 : e.currencyIds
    });
    return ja.result.parse(t).rawAccounts.map(xt);
  }
  /**
   * Ask the connected wallet for an account matching a specific set of critterias.
   *
   * @param params - Parameters of the request.
   *
   * @returns The account selected by the user
   * @throws {@link RpcError} if an error occurred on server side
   */
  async request(e) {
    const t = await this.client.request("account.request", {
      currencyIds: e == null ? void 0 : e.currencyIds
    }), r = $a.result.parse(t);
    return xt(r.rawAccount);
  }
  /**
   * Let user verify it's account address on his device through Ledger Live
   *
   * @param accountId - id of the account
   *
   * @returns The verified address or an error message if the verification doesn't succeed
   */
  async receive(e) {
    const t = await this.client.request("account.receive", {
      accountId: e
    });
    return Ba.result.parse(t).address;
  }
}
class oo {
  constructor(e) {
    T(this, "client");
    this.client = e;
  }
  /**
   *
   * @param accountId id of the bitcoin account
   * @param derivationPath The derivation path is a relative derivation path from the account
   * e.g to get the first public address of an account, one will request for the “0/0“ derivation path
   * @returns the address of the account for a given derivation path
   *
   * @throws {@link ServerError} if an error occurred on server side
   */
  async getAddress(e, t) {
    const r = await this.client.request("bitcoin.getAddress", {
      accountId: e,
      derivationPath: t
    });
    return Ha.result.parse(r).address;
  }
  /**
   *
   * @param accountId id of the bitcoin account
   * @param derivationPath The derivation path is a relative derivation path from the account
   * e.g to get the first public key of an account, one will request for the “0/0“ derivation path
   * @returns a raw hexadecimal public key of a bitcoin account at the given derivation path
   *
   * @throws {@link ServerError} if an error occurred on server side
   */
  async getPublicKey(e, t) {
    const r = await this.client.request("bitcoin.getPublicKey", {
      accountId: e,
      derivationPath: t
    });
    return Ya.result.parse(r).publicKey;
  }
  /**
   *
   * @param accountId id of the bitcoin account
   * @returns the xpub of the account
   *
   * @throws {@link ServerError} if an error occurred on server side
   */
  async getXPub(e) {
    const t = await this.client.request("bitcoin.getXPub", {
      accountId: e
    });
    return Qa.result.parse(t).xPub;
  }
}
class co {
  constructor(e) {
    T(this, "client");
    this.client = e;
  }
  /**
   * List cryptocurrencies supported by the connected wallet, providing filters by name or ticker
   *
   * @param params - Filters for currencies
   *
   * @returns The list of corresponding cryptocurrencies
   * @throws {@link RpcError} if an error occurred on server side
   *
   * @beta Filtering not yet implemented
   */
  async list(e) {
    const t = await this.client.request("currency.list", {
      currencyIds: e == null ? void 0 : e.currencyIds
    });
    return ni.result.parse(t).currencies;
  }
}
class uo {
  constructor(e) {
    T(this, "client");
    this.client = e;
  }
  /**
   * Open low-level transport in the connected wallet
   *
   * @param params - Params for the transport
   *
   * @returns An instance of Transport compatible with @ledgerhq/hw-transport
   * @throws {@link RpcError} if an error occurred on server side
   */
  async transport(e) {
    const t = await this.client.request("device.transport", e), r = yi.result.parse(t);
    return et.open({
      walletApi: this.client,
      transportId: r.transportId
    });
  }
  /**
   * Open low-level transport in the connected wallet
   *
   * @param params - Params to open the transport
   *
   * @returns An instance of Transport compatible with @ledgerhq/hw-transport
   * @throws {@link RpcError} if an error occurred on server side
   */
  async open(e) {
    const t = await this.client.request("device.open", e), r = li.result.parse(t);
    return et.open({
      walletApi: this.client,
      transportId: r.transportId
    });
  }
  /**
   * Select a device in the connected wallet
   *
   * @param params - Params to select and check the device
   *
   * @returns A deviceId to use with the `device.open` method
   * @throws {@link RpcError} if an error occurred on server side
   */
  async select(e) {
    const t = await this.client.request("device.select", e);
    return pi.result.parse(t);
  }
}
class lo {
  constructor(e) {
    T(this, "client");
    this.client = e;
  }
  /**
   * @alpha
   * Start the exchange process by generating a nonce on Ledger device
   * @param exchangeType - used by the exchange transport to discern between swap/sell/fund
   *
   * @returns - A transaction ID used to complete the exchange process
   */
  async start(e) {
    const t = await this.client.request("exchange.start", {
      exchangeType: e
    });
    return Ci.result.parse(t).transactionId;
  }
  /**
   * @alpha
   * Complete an exchange swap process by passing by the exchange content and its signature.
   * User will be prompted on its device to approve the swap exchange operation.
   * If the exchange is validated, the transaction is then signed and broadcasted to the network.
   * @param provider - Used to verify the signature
   * @param fromAccountId - Identifier of the account used as a source for the tx or parent account (for "new token")
   * @param toAccountId - Identifier of the account or parent account (for "new token") used as a destination
   * @param swapId - Identifier of the swap used by backend
   * @param rate - Swap rate in the transaction
   * @param tokenCurrency - "new token" used in the transaction, not listed yet in wallet-api list
   * @param transaction - Transaction containing the recipient and amount
   * @param binaryPayload - Blueprint of the data that we'll allow signing
   * @param signature - Ensures the source of the payload
   * @param feesStrategy - Slow / Medium / Fast
   *
   * @returns - The broadcasted transaction hash.
   */
  async completeSwap({ provider: e, fromAccountId: t, toAccountId: r, swapId: s, rate: a, transaction: o, binaryPayload: c, signature: l, feeStrategy: h, tokenCurrency: p }) {
    const b = await this.client.request("exchange.complete", {
      exchangeType: "SWAP",
      provider: e,
      fromAccountId: t,
      toAccountId: r,
      swapId: s,
      rate: a,
      rawTransaction: be(o),
      hexBinaryPayload: c.toString("hex"),
      hexSignature: l.toString("hex"),
      feeStrategy: h,
      tokenCurrency: p
    });
    return at.result.parse(b).transactionHash;
  }
  /**
   * @alpha
   * Complete an exchange sell process by passing by the exchange content and its signature.
   * User will be prompted on its device to approve the sell exchange operation.
   * If the exchange is validated, the transaction is then signed and broadcasted to the network.
   * @param provider - Used to verify the signature
   * @param fromAccountId - Identifier of the account used as a source for the tx
   * @param transaction - Transaction containing the recipient and amount
   * @param binaryPayload - Blueprint of the data that we'll allow signing
   * @param signature - Ensures the source of the payload
   * @param feesStrategy - Slow / Medium / Fast
   *
   * @returns - The broadcasted transaction hash.
   */
  async completeSell({ provider: e, fromAccountId: t, transaction: r, binaryPayload: s, signature: a, feeStrategy: o }) {
    const c = await this.client.request("exchange.complete", {
      exchangeType: "SELL",
      provider: e,
      fromAccountId: t,
      rawTransaction: be(r),
      hexBinaryPayload: s.toString("hex"),
      hexSignature: a.toString("hex"),
      feeStrategy: o
    });
    return at.result.parse(c).transactionHash;
  }
  /**
   * @alpha
   * Complete an exchange fund process by passing by the exchange content and its signature.
   * User will be prompted on its device to approve the fund exchange operation.
   * If the exchange is validated, the transaction is then signed and broadcasted to the network.
   * @param provider - Used to verify the signature
   * @param fromAccountId - Identifier of the account used as a source for the tx
   * @param transaction - Transaction containing the recipient and amount
   * @param binaryPayload - Blueprint of the data that we'll allow signing
   * @param signature - Ensures the source of the payload
   * @param feesStrategy - Slow / Medium / Fast
   *
   * @returns - The broadcasted transaction hash.
   */
  async completeFund({ provider: e, fromAccountId: t, transaction: r, binaryPayload: s, signature: a, feeStrategy: o, tokenCurrency: c }) {
    const l = await this.client.request("exchange.complete", {
      exchangeType: "FUND",
      provider: e,
      fromAccountId: t,
      rawTransaction: be(r),
      hexBinaryPayload: s.toString("hex"),
      hexSignature: a.toString("hex"),
      feeStrategy: o,
      tokenCurrency: c
    });
    return at.result.parse(l).transactionHash;
  }
}
class ho {
  constructor(e) {
    T(this, "client");
    this.client = e;
  }
  /**
   * Let the user sign the provided message.
   * In Ethereum context, this is an [EIP-191 message](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-191.md)
   * or an [EIP-712 message](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md)
   * @param accountId - Ledger Live id of the account
   * @param message - Message the user should sign
   *
   * @returns Message signed
   * @throws {@link RpcError} if an error occurred on server side
   */
  async sign(e, t, r) {
    const s = await this.client.request("message.sign", {
      accountId: e,
      hexMessage: t.toString("hex"),
      meta: r
    }), a = ki.result.parse(s);
    return V.from(a.hexSignedMessage, "hex");
  }
}
class mo {
  constructor(e) {
    T(this, "client");
    this.client = e;
  }
  async get(e, t) {
    const r = await this.client.request("storage.get", {
      key: e,
      storeId: t
    });
    return Di.result.parse(r).value;
  }
  async set(e, t, r) {
    const s = await this.client.request("storage.set", {
      key: e,
      value: t,
      storeId: r
    });
    return Mi.result.parse(s);
  }
}
class po {
  constructor(e) {
    T(this, "client");
    this.client = e;
  }
  /**
   * Let the user sign a transaction that won't be broadcasted by the connected wallet
   * @param accountId - id of the account
   * @param transaction - The transaction object in the currency family-specific format
   * @param options - Extra parameters
   *
   * @returns The raw signed transaction
   * @throws {@link RpcError} if an error occurred on server side
   */
  async sign(e, t, r, s) {
    const a = await this.client.request("transaction.sign", {
      accountId: e,
      rawTransaction: be(t),
      options: r,
      meta: s
    }), o = Fi.result.parse(a);
    return V.from(o.signedTransactionHex, "hex");
  }
  /**
   * Let the user sign and broadcast a transaction
   * @param accountId - id of the account
   * @param transaction - The transaction object in the currency family-specific format
   * @param options - Extra parameters
   *
   * @returns The transaction hash
   * @throws {@link RpcError} if an error occurred on server side
   */
  async signAndBroadcast(e, t, r, s) {
    const a = await this.client.request("transaction.signAndBroadcast", {
      accountId: e,
      rawTransaction: be(t),
      options: r,
      meta: s
    });
    return $i.result.parse(a).transactionHash;
  }
}
class fo {
  constructor(e) {
    T(this, "client");
    this.client = e;
  }
  /**
   *
   * @returns the userId
   *
   * @throws {@link ServerError} if an error occurred on server side
   */
  async userId() {
    const e = await this.client.request("wallet.userId", {});
    return Qi.result.parse(e).userId;
  }
  /**
   *
   * @returns The wallet infos
   *
   * @throws {@link ServerError} if an error occurred on server side
   */
  async info() {
    const e = await this.client.request("wallet.info", {});
    return Yi.result.parse(e);
  }
  /**
   * List the wallet's implemented methodIds
   *
   * @returns The list of implemented method ids
   * @throws {@link RpcError} if an error occurred on server side
   *
   * @beta Filtering not yet implemented
   */
  async capabilities() {
    const e = await this.client.request("wallet.capabilities", {});
    return Hi.result.parse(e).methodIds;
  }
}
const go = new qt("Wallet-API-Client"), Ot = {
  "event.account.updated": (n) => Promise.resolve()
};
class yo extends La {
  constructor(t, r = go, s, a = {}) {
    super(t, { ...Ot, ...a });
    /**
     * Instance of the Account module
     */
    T(this, "account");
    /**
     * Instance of the Bitcoin module
     */
    T(this, "bitcoin");
    /**
     * Instance of the Currency module
     */
    T(this, "currency");
    /**
     * Instance of the Device module
     */
    T(this, "device");
    /**
     * Instance of the Message module
     */
    T(this, "message");
    /**
     * Instance of the Storage module
     */
    T(this, "storage");
    /**
     * Instance of the Transaction module
     */
    T(this, "transaction");
    /**
     * Instance of the Wallet module
     */
    T(this, "wallet");
    /**
     * Instance of the Wallet module
     */
    T(this, "exchange");
    /**
     * Instance of the Custom module
     */
    T(this, "custom");
    T(this, "logger");
    this.logger = r, this.account = new io(this), this.bitcoin = new oo(this), this.currency = new co(this), this.device = new uo(this), this.message = new ho(this), this.storage = new mo(this), this.transaction = new po(this), this.wallet = new fo(this), this.exchange = new lo(this), this.custom = s ? s(this) : {};
  }
  setEventHandlers(t) {
    this.requestHandlers = { ...Ot, ...t };
  }
  onRequest(t) {
    this.logger.log(t.method);
    const r = this.requestHandlers[t.method];
    if (!r)
      throw new H({
        code: G.METHOD_NOT_FOUND,
        message: "method not found"
      });
    return r(t);
  }
}
const vo = ({
  accounts: n,
  ledgerCurrencies: e,
  enabledChainsMap: t
}) => {
  const { accountsFamilies: r, accountsCurrencies: s } = n.reduce(
    (o, c) => (o.accountsFamilies.add(e.get(c.currency)), o.accountsCurrencies.add(c.currency), o),
    { accountsFamilies: /* @__PURE__ */ new Set(), accountsCurrencies: /* @__PURE__ */ new Set() }
  ), a = gn(At).reduce(
    (o, [c, l]) => {
      const h = Object.keys(l).reduce((p, b) => {
        var oe, te, Me, ge;
        const O = l[b], L = ((oe = t.evm[O.skChainName]) == null ? void 0 : oe.wagmiChain) || ((te = t.cosmos[O.skChainName]) == null ? void 0 : te.wagmiChain) || ((Me = t.misc[O.skChainName]) == null ? void 0 : Me.wagmiChain) || ((ge = t.substrate[O.skChainName]) == null ? void 0 : ge.wagmiChain);
        return L ? r.has(O.family) && (b === "*" || s.has(O.currencyId)) ? { ...p, [b]: { ...O, chain: L, enabled: !0 } } : { ...p, [b]: { ...O, chain: L, enabled: !1 } } : p;
      }, {});
      return { ...o, [c]: h };
    },
    {}
  );
  return Object.keys(a).reduce(
    (o, c) => {
      const l = a[c], h = Object.keys(l).reduce((p, b) => (p.set(b, l[b]), p), /* @__PURE__ */ new Map());
      return o.set(c, h), o;
    },
    /* @__PURE__ */ new Map()
  );
}, _o = (n) => _e(
  () => n.currency.list({
    currencyIds: Object.values(At).flatMap(
      (e) => Object.values(e).map((t) => t.currencyId)
    )
  })
).map((e) => e.reduce(
  (t, r) => (r.type === "CryptoCurrency" ? t.cryptoCurrency.set(r.id, r.family) : t.tokenCurrency.push(r), t),
  { cryptoCurrency: /* @__PURE__ */ new Map(), tokenCurrency: [] }
)).map((e) => (e.tokenCurrency.forEach((t) => {
  const r = e.cryptoCurrency.get(t.parent);
  r && e.cryptoCurrency.set(t.id, r);
}), e.cryptoCurrency)).mapLeft((e) => new Error("could not get currencies")), xo = ({
  walletDetailsParams: n,
  enabledChainsMap: e,
  queryParams: t
}) => vn((r) => {
  const s = "N/A", a = new Fe([]), o = new Fe([]), c = new Fe(void 0), l = c.pipe(Rn((R) => R == null ? void 0 : R.id));
  let h = [];
  const p = new Fe([]);
  let b = null, O = null, L = null;
  const oe = new ca();
  oe.connect();
  const te = new yo(oe), Me = async () => {
    var yt;
    r.emitter.emit("message", { type: "connecting" });
    const R = (await _o(te)).unsafeCoerce(), M = (await _e(() => te.account.list()).mapLeft((k) => new Error("could not get accounts"))).unsafeCoerce(), U = vo({
      ledgerCurrencies: R,
      accounts: M,
      enabledChainsMap: e
    });
    O = new Map(
      [...U.values()].flatMap(
        (k) => [...k.values()].map((z) => [z.chain.id, z.currencyId])
      )
    ), L = U;
    const { enabled: je, disabled: W } = [
      ...U.values()
    ].reduce(
      (k, z) => (z.forEach((ne) => {
        ne.enabled ? k.enabled.push(ne.chain) : k.disabled.push(ne.chain);
      }), k),
      { enabled: [], disabled: [] }
    );
    a.next([...je, ...W]), o.next(W), h = M;
    const nt = M.reduce(
      (k, z) => {
        const ne = R.get(z.currency);
        if (!ne) return k;
        const rt = U.get(
          ne
        );
        if (!ne || !rt) return k;
        const vt = rt.get("*") || rt.get(z.currency);
        return vt && k.push({ account: z, chainItem: vt }), k;
      },
      []
    );
    if (!nt.length) {
      const k = ve.fromNullable(
        (yt = U.get("ethereum")) == null ? void 0 : yt.get("ethereum")
      ).extractNullable();
      if (!k) throw new Error("Default chain not found");
      return p.next([]), b = k, ye([s]), Ue(k.chain.id.toString()), {
        accounts: [s],
        chainId: k.chain.id
      };
    }
    const gt = ve.fromNullable(t.accountId).chain(
      (k) => ve.encase(() => {
        const [, , , z] = k.split(":");
        return z;
      })
    ).extractNullable(), Ze = _t.find(
      (k) => (!gt || k.account.address === gt) && k.chainItem.skChainName === t.network,
      nt
    ).altLazy(() => _t.head(nt)).toEither(new Error("Account not found")).unsafeCoerce();
    return c.next(Ze.account), b = Ze.chainItem, p.next(ge().unsafeCoerce()), ye([Ze.account.address]), Ue(b.chain.id.toString()), {
      accounts: [Ze.account.address],
      chainId: b.chain.id
    };
  }, ge = () => ve.fromNullable(b).toEither(new Error("Current chain not found")).map(
    (R) => h.filter((M) => M.currency === R.currencyId)
  ), ye = (R) => {
    R.length === 0 ? r.emitter.emit("disconnect") : r.emitter.emit("change", { accounts: R });
  }, Ue = (R) => {
    r.emitter.emit("change", { chainId: _n(R) });
  }, nn = () => {
    r.emitter.emit("disconnect");
  }, rn = async () => ({}), sn = async () => Dt(), an = async () => oe.disconnect(), on = async () => {
    const R = b == null ? void 0 : b.chain.id;
    if (!R) throw new Error("Chain not found");
    return R;
  }, cn = async () => {
    var R;
    return [(R = c.value) == null ? void 0 : R.address];
  }, un = (R) => {
    c.next(R), ye([R.address]);
  }, dn = (R) => _e.liftEither(
    ve.fromNullable(
      O == null ? void 0 : O.get(R.id)
    ).toEither(new Error("Chain not found"))
  ).chain(
    (M) => _e(
      () => te.account.request({ currencyIds: [M] })
    ).mapLeft((U) => new Error("could not request account"))
  ).chain((M) => (h.push(M), a.next([...a.value, R]), o.next(
    o.value.filter((U) => U.id !== R.id)
  ), _e(() => ft({ chainId: R.id })))).mapLeft((M) => new Error("failed to switch to new chain")), ft = async ({ chainId: R }) => {
    const M = b;
    if (!M || !L)
      throw new Error("Chain not found");
    const U = [...L.values()].flatMap((W) => [...W.values()]).find((W) => W.chain.id === R);
    if (!U) throw new Error("Chain not found");
    if (M.chain.id !== U.chain.id || !c.value) {
      b = U;
      const W = ge().unsafeCoerce();
      p.next(W), c.next(W[0]);
    }
    const je = c.value;
    if (!je) throw new Error("Account not found");
    return Ue(R.toString()), ye([je.address]), U.chain;
  };
  return {
    ...n,
    id: we.id,
    name: we.name,
    type: we.type,
    connect: Me,
    onAccountsChanged: ye,
    onChainChanged: Ue,
    onDisconnect: nn,
    getProvider: rn,
    isAuthorized: sn,
    getChainId: on,
    disconnect: an,
    switchChain: ft,
    getAccounts: cn,
    switchAccount: un,
    requestAndSwitchAccount: dn,
    walletApiClient: te,
    $accountsOnCurrentChain: p,
    $filteredChains: a.asObservable(),
    $currentAccountId: l,
    $disabledChains: o.asObservable(),
    noAccountPlaceholder: s,
    deserializeTransaction: Es
  };
}), Ro = ({
  enabledChainsMap: n,
  queryParams: e
}) => ({
  groupName: "Ledger Live",
  wallets: [
    () => ({
      id: we.id,
      name: we.name,
      iconUrl: yn.ledgerLogo,
      iconBackground: "#fff",
      hidden: () => !Dt(),
      createConnector: (t) => xo({
        walletDetailsParams: t,
        enabledChainsMap: n,
        queryParams: e
      })
    })
  ]
});
export {
  Ro as ledgerLiveConnector
};
//# sourceMappingURL=ledger-connector-DCndvRS9.js.map
