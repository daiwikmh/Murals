var uae = Object.defineProperty;
var WL = (e) => {
  throw TypeError(e);
};
var dae = (e, t, n) => t in e ? uae(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var Ms = (e, t, n) => dae(e, typeof t != "symbol" ? t + "" : t, n), TR = (e, t, n) => t.has(e) || WL("Cannot " + n);
var ke = (e, t, n) => (TR(e, t, "read from private field"), n ? n.call(e) : t.get(e)), An = (e, t, n) => t.has(e) ? WL("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n), Bt = (e, t, n, r) => (TR(e, t, "write to private field"), r ? r.call(e, n) : t.set(e, n), n), Yn = (e, t, n) => (TR(e, t, "access private method"), n);
var fk = (e, t, n, r) => ({
  set _(i) {
    Bt(e, t, i, n);
  },
  get _() {
    return ke(e, t, r);
  }
});
function qz(e, t) {
  for (var n = 0; n < t.length; n++) {
    const r = t[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const i in r)
        if (i !== "default" && !(i in e)) {
          const o = Object.getOwnPropertyDescriptor(r, i);
          o && Object.defineProperty(e, i, o.get ? o : {
            enumerable: !0,
            get: () => r[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
function fae(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Wz = { exports: {} }, Qi = Wz.exports = {}, Tu, _u;
function SI() {
  throw new Error("setTimeout has not been defined");
}
function kI() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? Tu = setTimeout : Tu = SI;
  } catch {
    Tu = SI;
  }
  try {
    typeof clearTimeout == "function" ? _u = clearTimeout : _u = kI;
  } catch {
    _u = kI;
  }
})();
function Gz(e) {
  if (Tu === setTimeout)
    return setTimeout(e, 0);
  if ((Tu === SI || !Tu) && setTimeout)
    return Tu = setTimeout, setTimeout(e, 0);
  try {
    return Tu(e, 0);
  } catch {
    try {
      return Tu.call(null, e, 0);
    } catch {
      return Tu.call(this, e, 0);
    }
  }
}
function hae(e) {
  if (_u === clearTimeout)
    return clearTimeout(e);
  if ((_u === kI || !_u) && clearTimeout)
    return _u = clearTimeout, clearTimeout(e);
  try {
    return _u(e);
  } catch {
    try {
      return _u.call(null, e);
    } catch {
      return _u.call(this, e);
    }
  }
}
var Ud = [], Rg = !1, km, Jk = -1;
function pae() {
  !Rg || !km || (Rg = !1, km.length ? Ud = km.concat(Ud) : Jk = -1, Ud.length && Kz());
}
function Kz() {
  if (!Rg) {
    var e = Gz(pae);
    Rg = !0;
    for (var t = Ud.length; t; ) {
      for (km = Ud, Ud = []; ++Jk < t; )
        km && km[Jk].run();
      Jk = -1, t = Ud.length;
    }
    km = null, Rg = !1, hae(e);
  }
}
Qi.nextTick = function(e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var n = 1; n < arguments.length; n++)
      t[n - 1] = arguments[n];
  Ud.push(new Yz(e, t)), Ud.length === 1 && !Rg && Gz(Kz);
};
function Yz(e, t) {
  this.fun = e, this.array = t;
}
Yz.prototype.run = function() {
  this.fun.apply(null, this.array);
};
Qi.title = "browser";
Qi.browser = !0;
Qi.env = {};
Qi.argv = [];
Qi.version = "";
Qi.versions = {};
function sf() {
}
Qi.on = sf;
Qi.addListener = sf;
Qi.once = sf;
Qi.off = sf;
Qi.removeListener = sf;
Qi.removeAllListeners = sf;
Qi.emit = sf;
Qi.prependListener = sf;
Qi.prependOnceListener = sf;
Qi.listeners = function(e) {
  return [];
};
Qi.binding = function(e) {
  throw new Error("process.binding is not supported");
};
Qi.cwd = function() {
  return "/";
};
Qi.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
Qi.umask = function() {
  return 0;
};
var mae = Wz.exports;
const ct = /* @__PURE__ */ fae(mae);
var v1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function DC(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function aje(e) {
  if (e.__esModule) return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[r];
      }
    });
  }), n;
}
var AI = { exports: {} }, Zw = {}, TI = { exports: {} }, er = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var GL;
function yae() {
  if (GL) return er;
  GL = 1;
  var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), s = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), f = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), y = Symbol.iterator;
  function v(ce) {
    return ce === null || typeof ce != "object" ? null : (ce = y && ce[y] || ce["@@iterator"], typeof ce == "function" ? ce : null);
  }
  var w = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, C = Object.assign, x = {};
  function A(ce, pe, Ee) {
    this.props = ce, this.context = pe, this.refs = x, this.updater = Ee || w;
  }
  A.prototype.isReactComponent = {}, A.prototype.setState = function(ce, pe) {
    if (typeof ce != "object" && typeof ce != "function" && ce != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, ce, pe, "setState");
  }, A.prototype.forceUpdate = function(ce) {
    this.updater.enqueueForceUpdate(this, ce, "forceUpdate");
  };
  function R() {
  }
  R.prototype = A.prototype;
  function I(ce, pe, Ee) {
    this.props = ce, this.context = pe, this.refs = x, this.updater = Ee || w;
  }
  var D = I.prototype = new R();
  D.constructor = I, C(D, A.prototype), D.isPureReactComponent = !0;
  var M = Array.isArray, L = Object.prototype.hasOwnProperty, j = { current: null }, F = { key: !0, ref: !0, __self: !0, __source: !0 };
  function O(ce, pe, Ee) {
    var Se, Me = {}, Fe = null, st = null;
    if (pe != null) for (Se in pe.ref !== void 0 && (st = pe.ref), pe.key !== void 0 && (Fe = "" + pe.key), pe) L.call(pe, Se) && !F.hasOwnProperty(Se) && (Me[Se] = pe[Se]);
    var mt = arguments.length - 2;
    if (mt === 1) Me.children = Ee;
    else if (1 < mt) {
      for (var yt = Array(mt), Ut = 0; Ut < mt; Ut++) yt[Ut] = arguments[Ut + 2];
      Me.children = yt;
    }
    if (ce && ce.defaultProps) for (Se in mt = ce.defaultProps, mt) Me[Se] === void 0 && (Me[Se] = mt[Se]);
    return { $$typeof: e, type: ce, key: Fe, ref: st, props: Me, _owner: j.current };
  }
  function z(ce, pe) {
    return { $$typeof: e, type: ce.type, key: pe, ref: ce.ref, props: ce.props, _owner: ce._owner };
  }
  function H(ce) {
    return typeof ce == "object" && ce !== null && ce.$$typeof === e;
  }
  function Q(ce) {
    var pe = { "=": "=0", ":": "=2" };
    return "$" + ce.replace(/[=:]/g, function(Ee) {
      return pe[Ee];
    });
  }
  var Y = /\/+/g;
  function ee(ce, pe) {
    return typeof ce == "object" && ce !== null && ce.key != null ? Q("" + ce.key) : pe.toString(36);
  }
  function ie(ce, pe, Ee, Se, Me) {
    var Fe = typeof ce;
    (Fe === "undefined" || Fe === "boolean") && (ce = null);
    var st = !1;
    if (ce === null) st = !0;
    else switch (Fe) {
      case "string":
      case "number":
        st = !0;
        break;
      case "object":
        switch (ce.$$typeof) {
          case e:
          case t:
            st = !0;
        }
    }
    if (st) return st = ce, Me = Me(st), ce = Se === "" ? "." + ee(st, 0) : Se, M(Me) ? (Ee = "", ce != null && (Ee = ce.replace(Y, "$&/") + "/"), ie(Me, pe, Ee, "", function(Ut) {
      return Ut;
    })) : Me != null && (H(Me) && (Me = z(Me, Ee + (!Me.key || st && st.key === Me.key ? "" : ("" + Me.key).replace(Y, "$&/") + "/") + ce)), pe.push(Me)), 1;
    if (st = 0, Se = Se === "" ? "." : Se + ":", M(ce)) for (var mt = 0; mt < ce.length; mt++) {
      Fe = ce[mt];
      var yt = Se + ee(Fe, mt);
      st += ie(Fe, pe, Ee, yt, Me);
    }
    else if (yt = v(ce), typeof yt == "function") for (ce = yt.call(ce), mt = 0; !(Fe = ce.next()).done; ) Fe = Fe.value, yt = Se + ee(Fe, mt++), st += ie(Fe, pe, Ee, yt, Me);
    else if (Fe === "object") throw pe = String(ce), Error("Objects are not valid as a React child (found: " + (pe === "[object Object]" ? "object with keys {" + Object.keys(ce).join(", ") + "}" : pe) + "). If you meant to render a collection of children, use an array instead.");
    return st;
  }
  function X(ce, pe, Ee) {
    if (ce == null) return ce;
    var Se = [], Me = 0;
    return ie(ce, Se, "", "", function(Fe) {
      return pe.call(Ee, Fe, Me++);
    }), Se;
  }
  function Z(ce) {
    if (ce._status === -1) {
      var pe = ce._result;
      pe = pe(), pe.then(function(Ee) {
        (ce._status === 0 || ce._status === -1) && (ce._status = 1, ce._result = Ee);
      }, function(Ee) {
        (ce._status === 0 || ce._status === -1) && (ce._status = 2, ce._result = Ee);
      }), ce._status === -1 && (ce._status = 0, ce._result = pe);
    }
    if (ce._status === 1) return ce._result.default;
    throw ce._result;
  }
  var J = { current: null }, K = { transition: null }, oe = { ReactCurrentDispatcher: J, ReactCurrentBatchConfig: K, ReactCurrentOwner: j };
  function be() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  return er.Children = { map: X, forEach: function(ce, pe, Ee) {
    X(ce, function() {
      pe.apply(this, arguments);
    }, Ee);
  }, count: function(ce) {
    var pe = 0;
    return X(ce, function() {
      pe++;
    }), pe;
  }, toArray: function(ce) {
    return X(ce, function(pe) {
      return pe;
    }) || [];
  }, only: function(ce) {
    if (!H(ce)) throw Error("React.Children.only expected to receive a single React element child.");
    return ce;
  } }, er.Component = A, er.Fragment = n, er.Profiler = i, er.PureComponent = I, er.StrictMode = r, er.Suspense = u, er.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = oe, er.act = be, er.cloneElement = function(ce, pe, Ee) {
    if (ce == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + ce + ".");
    var Se = C({}, ce.props), Me = ce.key, Fe = ce.ref, st = ce._owner;
    if (pe != null) {
      if (pe.ref !== void 0 && (Fe = pe.ref, st = j.current), pe.key !== void 0 && (Me = "" + pe.key), ce.type && ce.type.defaultProps) var mt = ce.type.defaultProps;
      for (yt in pe) L.call(pe, yt) && !F.hasOwnProperty(yt) && (Se[yt] = pe[yt] === void 0 && mt !== void 0 ? mt[yt] : pe[yt]);
    }
    var yt = arguments.length - 2;
    if (yt === 1) Se.children = Ee;
    else if (1 < yt) {
      mt = Array(yt);
      for (var Ut = 0; Ut < yt; Ut++) mt[Ut] = arguments[Ut + 2];
      Se.children = mt;
    }
    return { $$typeof: e, type: ce.type, key: Me, ref: Fe, props: Se, _owner: st };
  }, er.createContext = function(ce) {
    return ce = { $$typeof: s, _currentValue: ce, _currentValue2: ce, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, ce.Provider = { $$typeof: o, _context: ce }, ce.Consumer = ce;
  }, er.createElement = O, er.createFactory = function(ce) {
    var pe = O.bind(null, ce);
    return pe.type = ce, pe;
  }, er.createRef = function() {
    return { current: null };
  }, er.forwardRef = function(ce) {
    return { $$typeof: c, render: ce };
  }, er.isValidElement = H, er.lazy = function(ce) {
    return { $$typeof: p, _payload: { _status: -1, _result: ce }, _init: Z };
  }, er.memo = function(ce, pe) {
    return { $$typeof: f, type: ce, compare: pe === void 0 ? null : pe };
  }, er.startTransition = function(ce) {
    var pe = K.transition;
    K.transition = {};
    try {
      ce();
    } finally {
      K.transition = pe;
    }
  }, er.unstable_act = be, er.useCallback = function(ce, pe) {
    return J.current.useCallback(ce, pe);
  }, er.useContext = function(ce) {
    return J.current.useContext(ce);
  }, er.useDebugValue = function() {
  }, er.useDeferredValue = function(ce) {
    return J.current.useDeferredValue(ce);
  }, er.useEffect = function(ce, pe) {
    return J.current.useEffect(ce, pe);
  }, er.useId = function() {
    return J.current.useId();
  }, er.useImperativeHandle = function(ce, pe, Ee) {
    return J.current.useImperativeHandle(ce, pe, Ee);
  }, er.useInsertionEffect = function(ce, pe) {
    return J.current.useInsertionEffect(ce, pe);
  }, er.useLayoutEffect = function(ce, pe) {
    return J.current.useLayoutEffect(ce, pe);
  }, er.useMemo = function(ce, pe) {
    return J.current.useMemo(ce, pe);
  }, er.useReducer = function(ce, pe, Ee) {
    return J.current.useReducer(ce, pe, Ee);
  }, er.useRef = function(ce) {
    return J.current.useRef(ce);
  }, er.useState = function(ce) {
    return J.current.useState(ce);
  }, er.useSyncExternalStore = function(ce, pe, Ee) {
    return J.current.useSyncExternalStore(ce, pe, Ee);
  }, er.useTransition = function() {
    return J.current.useTransition();
  }, er.version = "18.3.1", er;
}
var g1 = { exports: {} };
g1.exports;
var KL;
function vae() {
  return KL || (KL = 1, function(e, t) {
    ct.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var n = "18.3.1", r = Symbol.for("react.element"), i = Symbol.for("react.portal"), o = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), c = Symbol.for("react.profiler"), u = Symbol.for("react.provider"), f = Symbol.for("react.context"), p = Symbol.for("react.forward_ref"), y = Symbol.for("react.suspense"), v = Symbol.for("react.suspense_list"), w = Symbol.for("react.memo"), C = Symbol.for("react.lazy"), x = Symbol.for("react.offscreen"), A = Symbol.iterator, R = "@@iterator";
      function I(W) {
        if (W === null || typeof W != "object")
          return null;
        var ve = A && W[A] || W[R];
        return typeof ve == "function" ? ve : null;
      }
      var D = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, M = {
        transition: null
      }, L = {
        current: null,
        // Used to reproduce behavior of `batchedUpdates` in legacy mode.
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1
      }, j = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, F = {}, O = null;
      function z(W) {
        O = W;
      }
      F.setExtraStackFrame = function(W) {
        O = W;
      }, F.getCurrentStack = null, F.getStackAddendum = function() {
        var W = "";
        O && (W += O);
        var ve = F.getCurrentStack;
        return ve && (W += ve() || ""), W;
      };
      var H = !1, Q = !1, Y = !1, ee = !1, ie = !1, X = {
        ReactCurrentDispatcher: D,
        ReactCurrentBatchConfig: M,
        ReactCurrentOwner: j
      };
      X.ReactDebugCurrentFrame = F, X.ReactCurrentActQueue = L;
      function Z(W) {
        {
          for (var ve = arguments.length, Be = new Array(ve > 1 ? ve - 1 : 0), We = 1; We < ve; We++)
            Be[We - 1] = arguments[We];
          K("warn", W, Be);
        }
      }
      function J(W) {
        {
          for (var ve = arguments.length, Be = new Array(ve > 1 ? ve - 1 : 0), We = 1; We < ve; We++)
            Be[We - 1] = arguments[We];
          K("error", W, Be);
        }
      }
      function K(W, ve, Be) {
        {
          var We = X.ReactDebugCurrentFrame, ft = We.getStackAddendum();
          ft !== "" && (ve += "%s", Be = Be.concat([ft]));
          var rn = Be.map(function(vt) {
            return String(vt);
          });
          rn.unshift("Warning: " + ve), Function.prototype.apply.call(console[W], console, rn);
        }
      }
      var oe = {};
      function be(W, ve) {
        {
          var Be = W.constructor, We = Be && (Be.displayName || Be.name) || "ReactClass", ft = We + "." + ve;
          if (oe[ft])
            return;
          J("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", ve, We), oe[ft] = !0;
        }
      }
      var ce = {
        /**
         * Checks whether or not this composite component is mounted.
         * @param {ReactClass} publicInstance The instance we want to test.
         * @return {boolean} True if mounted, false otherwise.
         * @protected
         * @final
         */
        isMounted: function(W) {
          return !1;
        },
        /**
         * Forces an update. This should only be invoked when it is known with
         * certainty that we are **not** in a DOM transaction.
         *
         * You may want to call this when you know that some deeper aspect of the
         * component's state has changed but `setState` was not called.
         *
         * This will not invoke `shouldComponentUpdate`, but it will invoke
         * `componentWillUpdate` and `componentDidUpdate`.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueForceUpdate: function(W, ve, Be) {
          be(W, "forceUpdate");
        },
        /**
         * Replaces all of the state. Always use this or `setState` to mutate state.
         * You should treat `this.state` as immutable.
         *
         * There is no guarantee that `this.state` will be immediately updated, so
         * accessing `this.state` after calling this method may return the old value.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} completeState Next state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueReplaceState: function(W, ve, Be, We) {
          be(W, "replaceState");
        },
        /**
         * Sets a subset of the state. This only exists because _pendingState is
         * internal. This provides a merging strategy that is not available to deep
         * properties which is confusing. TODO: Expose pendingState or don't use it
         * during the merge.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} partialState Next partial state to be merged with state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} Name of the calling function in the public API.
         * @internal
         */
        enqueueSetState: function(W, ve, Be, We) {
          be(W, "setState");
        }
      }, pe = Object.assign, Ee = {};
      Object.freeze(Ee);
      function Se(W, ve, Be) {
        this.props = W, this.context = ve, this.refs = Ee, this.updater = Be || ce;
      }
      Se.prototype.isReactComponent = {}, Se.prototype.setState = function(W, ve) {
        if (typeof W != "object" && typeof W != "function" && W != null)
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, W, ve, "setState");
      }, Se.prototype.forceUpdate = function(W) {
        this.updater.enqueueForceUpdate(this, W, "forceUpdate");
      };
      {
        var Me = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        }, Fe = function(W, ve) {
          Object.defineProperty(Se.prototype, W, {
            get: function() {
              Z("%s(...) is deprecated in plain JavaScript React classes. %s", ve[0], ve[1]);
            }
          });
        };
        for (var st in Me)
          Me.hasOwnProperty(st) && Fe(st, Me[st]);
      }
      function mt() {
      }
      mt.prototype = Se.prototype;
      function yt(W, ve, Be) {
        this.props = W, this.context = ve, this.refs = Ee, this.updater = Be || ce;
      }
      var Ut = yt.prototype = new mt();
      Ut.constructor = yt, pe(Ut, Se.prototype), Ut.isPureReactComponent = !0;
      function hn() {
        var W = {
          current: null
        };
        return Object.seal(W), W;
      }
      var wn = Array.isArray;
      function Ot(W) {
        return wn(W);
      }
      function xt(W) {
        {
          var ve = typeof Symbol == "function" && Symbol.toStringTag, Be = ve && W[Symbol.toStringTag] || W.constructor.name || "Object";
          return Be;
        }
      }
      function zt(W) {
        try {
          return Pn(W), !1;
        } catch {
          return !0;
        }
      }
      function Pn(W) {
        return "" + W;
      }
      function Fn(W) {
        if (zt(W))
          return J("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", xt(W)), Pn(W);
      }
      function tr(W, ve, Be) {
        var We = W.displayName;
        if (We)
          return We;
        var ft = ve.displayName || ve.name || "";
        return ft !== "" ? Be + "(" + ft + ")" : Be;
      }
      function or(W) {
        return W.displayName || "Context";
      }
      function ar(W) {
        if (W == null)
          return null;
        if (typeof W.tag == "number" && J("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof W == "function")
          return W.displayName || W.name || null;
        if (typeof W == "string")
          return W;
        switch (W) {
          case o:
            return "Fragment";
          case i:
            return "Portal";
          case c:
            return "Profiler";
          case s:
            return "StrictMode";
          case y:
            return "Suspense";
          case v:
            return "SuspenseList";
        }
        if (typeof W == "object")
          switch (W.$$typeof) {
            case f:
              var ve = W;
              return or(ve) + ".Consumer";
            case u:
              var Be = W;
              return or(Be._context) + ".Provider";
            case p:
              return tr(W, W.render, "ForwardRef");
            case w:
              var We = W.displayName || null;
              return We !== null ? We : ar(W.type) || "Memo";
            case C: {
              var ft = W, rn = ft._payload, vt = ft._init;
              try {
                return ar(vt(rn));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var Cr = Object.prototype.hasOwnProperty, Un = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, $n, gr, Tt;
      Tt = {};
      function qt(W) {
        if (Cr.call(W, "ref")) {
          var ve = Object.getOwnPropertyDescriptor(W, "ref").get;
          if (ve && ve.isReactWarning)
            return !1;
        }
        return W.ref !== void 0;
      }
      function gt(W) {
        if (Cr.call(W, "key")) {
          var ve = Object.getOwnPropertyDescriptor(W, "key").get;
          if (ve && ve.isReactWarning)
            return !1;
        }
        return W.key !== void 0;
      }
      function Ht(W, ve) {
        var Be = function() {
          $n || ($n = !0, J("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ve));
        };
        Be.isReactWarning = !0, Object.defineProperty(W, "key", {
          get: Be,
          configurable: !0
        });
      }
      function br(W, ve) {
        var Be = function() {
          gr || (gr = !0, J("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ve));
        };
        Be.isReactWarning = !0, Object.defineProperty(W, "ref", {
          get: Be,
          configurable: !0
        });
      }
      function ne(W) {
        if (typeof W.ref == "string" && j.current && W.__self && j.current.stateNode !== W.__self) {
          var ve = ar(j.current.type);
          Tt[ve] || (J('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', ve, W.ref), Tt[ve] = !0);
        }
      }
      var N = function(W, ve, Be, We, ft, rn, vt) {
        var dn = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: r,
          // Built-in properties that belong on the element
          type: W,
          key: ve,
          ref: Be,
          props: vt,
          // Record the component responsible for creating this element.
          _owner: rn
        };
        return dn._store = {}, Object.defineProperty(dn._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(dn, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: We
        }), Object.defineProperty(dn, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: ft
        }), Object.freeze && (Object.freeze(dn.props), Object.freeze(dn)), dn;
      };
      function U(W, ve, Be) {
        var We, ft = {}, rn = null, vt = null, dn = null, Gn = null;
        if (ve != null) {
          qt(ve) && (vt = ve.ref, ne(ve)), gt(ve) && (Fn(ve.key), rn = "" + ve.key), dn = ve.__self === void 0 ? null : ve.__self, Gn = ve.__source === void 0 ? null : ve.__source;
          for (We in ve)
            Cr.call(ve, We) && !Un.hasOwnProperty(We) && (ft[We] = ve[We]);
        }
        var ur = arguments.length - 2;
        if (ur === 1)
          ft.children = Be;
        else if (ur > 1) {
          for (var Lr = Array(ur), Rr = 0; Rr < ur; Rr++)
            Lr[Rr] = arguments[Rr + 2];
          Object.freeze && Object.freeze(Lr), ft.children = Lr;
        }
        if (W && W.defaultProps) {
          var jr = W.defaultProps;
          for (We in jr)
            ft[We] === void 0 && (ft[We] = jr[We]);
        }
        if (rn || vt) {
          var zr = typeof W == "function" ? W.displayName || W.name || "Unknown" : W;
          rn && Ht(ft, zr), vt && br(ft, zr);
        }
        return N(W, rn, vt, dn, Gn, j.current, ft);
      }
      function le(W, ve) {
        var Be = N(W.type, ve, W.ref, W._self, W._source, W._owner, W.props);
        return Be;
      }
      function Ce(W, ve, Be) {
        if (W == null)
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + W + ".");
        var We, ft = pe({}, W.props), rn = W.key, vt = W.ref, dn = W._self, Gn = W._source, ur = W._owner;
        if (ve != null) {
          qt(ve) && (vt = ve.ref, ur = j.current), gt(ve) && (Fn(ve.key), rn = "" + ve.key);
          var Lr;
          W.type && W.type.defaultProps && (Lr = W.type.defaultProps);
          for (We in ve)
            Cr.call(ve, We) && !Un.hasOwnProperty(We) && (ve[We] === void 0 && Lr !== void 0 ? ft[We] = Lr[We] : ft[We] = ve[We]);
        }
        var Rr = arguments.length - 2;
        if (Rr === 1)
          ft.children = Be;
        else if (Rr > 1) {
          for (var jr = Array(Rr), zr = 0; zr < Rr; zr++)
            jr[zr] = arguments[zr + 2];
          ft.children = jr;
        }
        return N(W.type, rn, vt, dn, Gn, ur, ft);
      }
      function Te(W) {
        return typeof W == "object" && W !== null && W.$$typeof === r;
      }
      var Ve = ".", kt = ":";
      function bn(W) {
        var ve = /[=:]/g, Be = {
          "=": "=0",
          ":": "=2"
        }, We = W.replace(ve, function(ft) {
          return Be[ft];
        });
        return "$" + We;
      }
      var Wt = !1, xn = /\/+/g;
      function St(W) {
        return W.replace(xn, "$&/");
      }
      function Qn(W, ve) {
        return typeof W == "object" && W !== null && W.key != null ? (Fn(W.key), bn("" + W.key)) : ve.toString(36);
      }
      function Nr(W, ve, Be, We, ft) {
        var rn = typeof W;
        (rn === "undefined" || rn === "boolean") && (W = null);
        var vt = !1;
        if (W === null)
          vt = !0;
        else
          switch (rn) {
            case "string":
            case "number":
              vt = !0;
              break;
            case "object":
              switch (W.$$typeof) {
                case r:
                case i:
                  vt = !0;
              }
          }
        if (vt) {
          var dn = W, Gn = ft(dn), ur = We === "" ? Ve + Qn(dn, 0) : We;
          if (Ot(Gn)) {
            var Lr = "";
            ur != null && (Lr = St(ur) + "/"), Nr(Gn, ve, Lr, "", function(Jb) {
              return Jb;
            });
          } else Gn != null && (Te(Gn) && (Gn.key && (!dn || dn.key !== Gn.key) && Fn(Gn.key), Gn = le(
            Gn,
            // Keep both the (mapped) and old keys if they differ, just as
            // traverseAllChildren used to do for objects as children
            Be + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
            (Gn.key && (!dn || dn.key !== Gn.key) ? (
              // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
              // eslint-disable-next-line react-internal/safe-string-coercion
              St("" + Gn.key) + "/"
            ) : "") + ur
          )), ve.push(Gn));
          return 1;
        }
        var Rr, jr, zr = 0, Zn = We === "" ? Ve : We + kt;
        if (Ot(W))
          for (var sc = 0; sc < W.length; sc++)
            Rr = W[sc], jr = Zn + Qn(Rr, sc), zr += Nr(Rr, ve, Be, jr, ft);
        else {
          var yf = I(W);
          if (typeof yf == "function") {
            var pp = W;
            yf === pp.entries && (Wt || Z("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Wt = !0);
            for (var Xb = yf.call(pp), Js, mp = 0; !(Js = Xb.next()).done; )
              Rr = Js.value, jr = Zn + Qn(Rr, mp++), zr += Nr(Rr, ve, Be, jr, ft);
          } else if (rn === "object") {
            var yp = String(W);
            throw new Error("Objects are not valid as a React child (found: " + (yp === "[object Object]" ? "object with keys {" + Object.keys(W).join(", ") + "}" : yp) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return zr;
      }
      function bi(W, ve, Be) {
        if (W == null)
          return W;
        var We = [], ft = 0;
        return Nr(W, We, "", "", function(rn) {
          return ve.call(Be, rn, ft++);
        }), We;
      }
      function Do(W) {
        var ve = 0;
        return bi(W, function() {
          ve++;
        }), ve;
      }
      function la(W, ve, Be) {
        bi(W, function() {
          ve.apply(this, arguments);
        }, Be);
      }
      function ja(W) {
        return bi(W, function(ve) {
          return ve;
        }) || [];
      }
      function Mo(W) {
        if (!Te(W))
          throw new Error("React.Children.only expected to receive a single React element child.");
        return W;
      }
      function ri(W) {
        var ve = {
          $$typeof: f,
          // As a workaround to support multiple concurrent renderers, we categorize
          // some renderers as primary and others as secondary. We only expect
          // there to be two concurrent renderers at most: React Native (primary) and
          // Fabric (secondary); React DOM (primary) and React ART (secondary).
          // Secondary renderers store their context values on separate fields.
          _currentValue: W,
          _currentValue2: W,
          // Used to track how many concurrent renderers this context currently
          // supports within in a single renderer. Such as parallel server rendering.
          _threadCount: 0,
          // These are circular
          Provider: null,
          Consumer: null,
          // Add these to use same hidden class in VM as ServerContext
          _defaultValue: null,
          _globalName: null
        };
        ve.Provider = {
          $$typeof: u,
          _context: ve
        };
        var Be = !1, We = !1, ft = !1;
        {
          var rn = {
            $$typeof: f,
            _context: ve
          };
          Object.defineProperties(rn, {
            Provider: {
              get: function() {
                return We || (We = !0, J("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), ve.Provider;
              },
              set: function(vt) {
                ve.Provider = vt;
              }
            },
            _currentValue: {
              get: function() {
                return ve._currentValue;
              },
              set: function(vt) {
                ve._currentValue = vt;
              }
            },
            _currentValue2: {
              get: function() {
                return ve._currentValue2;
              },
              set: function(vt) {
                ve._currentValue2 = vt;
              }
            },
            _threadCount: {
              get: function() {
                return ve._threadCount;
              },
              set: function(vt) {
                ve._threadCount = vt;
              }
            },
            Consumer: {
              get: function() {
                return Be || (Be = !0, J("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), ve.Consumer;
              }
            },
            displayName: {
              get: function() {
                return ve.displayName;
              },
              set: function(vt) {
                ft || (Z("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", vt), ft = !0);
              }
            }
          }), ve.Consumer = rn;
        }
        return ve._currentRenderer = null, ve._currentRenderer2 = null, ve;
      }
      var ui = -1, ji = 0, _i = 1, ho = 2;
      function wi(W) {
        if (W._status === ui) {
          var ve = W._result, Be = ve();
          if (Be.then(function(rn) {
            if (W._status === ji || W._status === ui) {
              var vt = W;
              vt._status = _i, vt._result = rn;
            }
          }, function(rn) {
            if (W._status === ji || W._status === ui) {
              var vt = W;
              vt._status = ho, vt._result = rn;
            }
          }), W._status === ui) {
            var We = W;
            We._status = ji, We._result = Be;
          }
        }
        if (W._status === _i) {
          var ft = W._result;
          return ft === void 0 && J(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, ft), "default" in ft || J(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, ft), ft.default;
        } else
          throw W._result;
      }
      function we(W) {
        var ve = {
          // We use these fields to store the result.
          _status: ui,
          _result: W
        }, Be = {
          $$typeof: C,
          _payload: ve,
          _init: wi
        };
        {
          var We, ft;
          Object.defineProperties(Be, {
            defaultProps: {
              configurable: !0,
              get: function() {
                return We;
              },
              set: function(rn) {
                J("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), We = rn, Object.defineProperty(Be, "defaultProps", {
                  enumerable: !0
                });
              }
            },
            propTypes: {
              configurable: !0,
              get: function() {
                return ft;
              },
              set: function(rn) {
                J("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), ft = rn, Object.defineProperty(Be, "propTypes", {
                  enumerable: !0
                });
              }
            }
          });
        }
        return Be;
      }
      function Ae(W) {
        W != null && W.$$typeof === w ? J("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof W != "function" ? J("forwardRef requires a render function but was given %s.", W === null ? "null" : typeof W) : W.length !== 0 && W.length !== 2 && J("forwardRef render functions accept exactly two parameters: props and ref. %s", W.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), W != null && (W.defaultProps != null || W.propTypes != null) && J("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        var ve = {
          $$typeof: p,
          render: W
        };
        {
          var Be;
          Object.defineProperty(ve, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return Be;
            },
            set: function(We) {
              Be = We, !W.name && !W.displayName && (W.displayName = We);
            }
          });
        }
        return ve;
      }
      var ye;
      ye = Symbol.for("react.module.reference");
      function re(W) {
        return !!(typeof W == "string" || typeof W == "function" || W === o || W === c || ie || W === s || W === y || W === v || ee || W === x || H || Q || Y || typeof W == "object" && W !== null && (W.$$typeof === C || W.$$typeof === w || W.$$typeof === u || W.$$typeof === f || W.$$typeof === p || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        W.$$typeof === ye || W.getModuleId !== void 0));
      }
      function _e(W, ve) {
        re(W) || J("memo: The first argument must be a component. Instead received: %s", W === null ? "null" : typeof W);
        var Be = {
          $$typeof: w,
          type: W,
          compare: ve === void 0 ? null : ve
        };
        {
          var We;
          Object.defineProperty(Be, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return We;
            },
            set: function(ft) {
              We = ft, !W.name && !W.displayName && (W.displayName = ft);
            }
          });
        }
        return Be;
      }
      function Pe() {
        var W = D.current;
        return W === null && J(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), W;
      }
      function Qe(W) {
        var ve = Pe();
        if (W._context !== void 0) {
          var Be = W._context;
          Be.Consumer === W ? J("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : Be.Provider === W && J("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return ve.useContext(W);
      }
      function Ke(W) {
        var ve = Pe();
        return ve.useState(W);
      }
      function lt(W, ve, Be) {
        var We = Pe();
        return We.useReducer(W, ve, Be);
      }
      function tt(W) {
        var ve = Pe();
        return ve.useRef(W);
      }
      function ot(W, ve) {
        var Be = Pe();
        return Be.useEffect(W, ve);
      }
      function cn(W, ve) {
        var Be = Pe();
        return Be.useInsertionEffect(W, ve);
      }
      function Qt(W, ve) {
        var Be = Pe();
        return Be.useLayoutEffect(W, ve);
      }
      function on(W, ve) {
        var Be = Pe();
        return Be.useCallback(W, ve);
      }
      function pn(W, ve) {
        var Be = Pe();
        return Be.useMemo(W, ve);
      }
      function sr(W, ve, Be) {
        var We = Pe();
        return We.useImperativeHandle(W, ve, Be);
      }
      function tn(W, ve) {
        {
          var Be = Pe();
          return Be.useDebugValue(W, ve);
        }
      }
      function Ur() {
        var W = Pe();
        return W.useTransition();
      }
      function xr(W) {
        var ve = Pe();
        return ve.useDeferredValue(W);
      }
      function vn() {
        var W = Pe();
        return W.useId();
      }
      function ii(W, ve, Be) {
        var We = Pe();
        return We.useSyncExternalStore(W, ve, Be);
      }
      var qo = 0, Xi, Po, Ci, cs, Zt, Er, xi;
      function _r() {
      }
      _r.__reactDisabledLog = !0;
      function Ji() {
        {
          if (qo === 0) {
            Xi = console.log, Po = console.info, Ci = console.warn, cs = console.error, Zt = console.group, Er = console.groupCollapsed, xi = console.groupEnd;
            var W = {
              configurable: !0,
              enumerable: !0,
              value: _r,
              writable: !0
            };
            Object.defineProperties(console, {
              info: W,
              log: W,
              warn: W,
              error: W,
              group: W,
              groupCollapsed: W,
              groupEnd: W
            });
          }
          qo++;
        }
      }
      function Fa() {
        {
          if (qo--, qo === 0) {
            var W = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: pe({}, W, {
                value: Xi
              }),
              info: pe({}, W, {
                value: Po
              }),
              warn: pe({}, W, {
                value: Ci
              }),
              error: pe({}, W, {
                value: cs
              }),
              group: pe({}, W, {
                value: Zt
              }),
              groupCollapsed: pe({}, W, {
                value: Er
              }),
              groupEnd: pe({}, W, {
                value: xi
              })
            });
          }
          qo < 0 && J("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var Wo = X.ReactCurrentDispatcher, po;
      function Ua(W, ve, Be) {
        {
          if (po === void 0)
            try {
              throw Error();
            } catch (ft) {
              var We = ft.stack.trim().match(/\n( *(at )?)/);
              po = We && We[1] || "";
            }
          return `
` + po + W;
        }
      }
      var us = !1, yl;
      {
        var Qc = typeof WeakMap == "function" ? WeakMap : Map;
        yl = new Qc();
      }
      function oc(W, ve) {
        if (!W || us)
          return "";
        {
          var Be = yl.get(W);
          if (Be !== void 0)
            return Be;
        }
        var We;
        us = !0;
        var ft = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var rn;
        rn = Wo.current, Wo.current = null, Ji();
        try {
          if (ve) {
            var vt = function() {
              throw Error();
            };
            if (Object.defineProperty(vt.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(vt, []);
              } catch (Zn) {
                We = Zn;
              }
              Reflect.construct(W, [], vt);
            } else {
              try {
                vt.call();
              } catch (Zn) {
                We = Zn;
              }
              W.call(vt.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (Zn) {
              We = Zn;
            }
            W();
          }
        } catch (Zn) {
          if (Zn && We && typeof Zn.stack == "string") {
            for (var dn = Zn.stack.split(`
`), Gn = We.stack.split(`
`), ur = dn.length - 1, Lr = Gn.length - 1; ur >= 1 && Lr >= 0 && dn[ur] !== Gn[Lr]; )
              Lr--;
            for (; ur >= 1 && Lr >= 0; ur--, Lr--)
              if (dn[ur] !== Gn[Lr]) {
                if (ur !== 1 || Lr !== 1)
                  do
                    if (ur--, Lr--, Lr < 0 || dn[ur] !== Gn[Lr]) {
                      var Rr = `
` + dn[ur].replace(" at new ", " at ");
                      return W.displayName && Rr.includes("<anonymous>") && (Rr = Rr.replace("<anonymous>", W.displayName)), typeof W == "function" && yl.set(W, Rr), Rr;
                    }
                  while (ur >= 1 && Lr >= 0);
                break;
              }
          }
        } finally {
          us = !1, Wo.current = rn, Fa(), Error.prepareStackTrace = ft;
        }
        var jr = W ? W.displayName || W.name : "", zr = jr ? Ua(jr) : "";
        return typeof W == "function" && yl.set(W, zr), zr;
      }
      function Gs(W, ve, Be) {
        return oc(W, !1);
      }
      function hp(W) {
        var ve = W.prototype;
        return !!(ve && ve.isReactComponent);
      }
      function ds(W, ve, Be) {
        if (W == null)
          return "";
        if (typeof W == "function")
          return oc(W, hp(W));
        if (typeof W == "string")
          return Ua(W);
        switch (W) {
          case y:
            return Ua("Suspense");
          case v:
            return Ua("SuspenseList");
        }
        if (typeof W == "object")
          switch (W.$$typeof) {
            case p:
              return Gs(W.render);
            case w:
              return ds(W.type, ve, Be);
            case C: {
              var We = W, ft = We._payload, rn = We._init;
              try {
                return ds(rn(ft), ve, Be);
              } catch {
              }
            }
          }
        return "";
      }
      var nr = {}, Xc = X.ReactDebugCurrentFrame;
      function ac(W) {
        if (W) {
          var ve = W._owner, Be = ds(W.type, W._source, ve ? ve.type : null);
          Xc.setExtraStackFrame(Be);
        } else
          Xc.setExtraStackFrame(null);
      }
      function Jc(W, ve, Be, We, ft) {
        {
          var rn = Function.call.bind(Cr);
          for (var vt in W)
            if (rn(W, vt)) {
              var dn = void 0;
              try {
                if (typeof W[vt] != "function") {
                  var Gn = Error((We || "React class") + ": " + Be + " type `" + vt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof W[vt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw Gn.name = "Invariant Violation", Gn;
                }
                dn = W[vt](ve, vt, We, Be, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ur) {
                dn = ur;
              }
              dn && !(dn instanceof Error) && (ac(ft), J("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", We || "React class", Be, vt, typeof dn), ac(null)), dn instanceof Error && !(dn.message in nr) && (nr[dn.message] = !0, ac(ft), J("Failed %s type: %s", Be, dn.message), ac(null));
            }
        }
      }
      function Hn(W) {
        if (W) {
          var ve = W._owner, Be = ds(W.type, W._source, ve ? ve.type : null);
          z(Be);
        } else
          z(null);
      }
      var Zc;
      Zc = !1;
      function eu() {
        if (j.current) {
          var W = ar(j.current.type);
          if (W)
            return `

Check the render method of \`` + W + "`.";
        }
        return "";
      }
      function En(W) {
        if (W !== void 0) {
          var ve = W.fileName.replace(/^.*[\\\/]/, ""), Be = W.lineNumber;
          return `

Check your code at ` + ve + ":" + Be + ".";
        }
        return "";
      }
      function fs(W) {
        return W != null ? En(W.__source) : "";
      }
      var Br = {};
      function Zi(W) {
        var ve = eu();
        if (!ve) {
          var Be = typeof W == "string" ? W : W.displayName || W.name;
          Be && (ve = `

Check the top-level render call using <` + Be + ">.");
        }
        return ve;
      }
      function Fi(W, ve) {
        if (!(!W._store || W._store.validated || W.key != null)) {
          W._store.validated = !0;
          var Be = Zi(ve);
          if (!Br[Be]) {
            Br[Be] = !0;
            var We = "";
            W && W._owner && W._owner !== j.current && (We = " It was passed a child from " + ar(W._owner.type) + "."), Hn(W), J('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Be, We), Hn(null);
          }
        }
      }
      function vl(W, ve) {
        if (typeof W == "object") {
          if (Ot(W))
            for (var Be = 0; Be < W.length; Be++) {
              var We = W[Be];
              Te(We) && Fi(We, ve);
            }
          else if (Te(W))
            W._store && (W._store.validated = !0);
          else if (W) {
            var ft = I(W);
            if (typeof ft == "function" && ft !== W.entries)
              for (var rn = ft.call(W), vt; !(vt = rn.next()).done; )
                Te(vt.value) && Fi(vt.value, ve);
          }
        }
      }
      function Hr(W) {
        {
          var ve = W.type;
          if (ve == null || typeof ve == "string")
            return;
          var Be;
          if (typeof ve == "function")
            Be = ve.propTypes;
          else if (typeof ve == "object" && (ve.$$typeof === p || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          ve.$$typeof === w))
            Be = ve.propTypes;
          else
            return;
          if (Be) {
            var We = ar(ve);
            Jc(Be, W.props, "prop", We, W);
          } else if (ve.PropTypes !== void 0 && !Zc) {
            Zc = !0;
            var ft = ar(ve);
            J("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ft || "Unknown");
          }
          typeof ve.getDefaultProps == "function" && !ve.getDefaultProps.isReactClassApproved && J("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function lr(W) {
        {
          for (var ve = Object.keys(W.props), Be = 0; Be < ve.length; Be++) {
            var We = ve[Be];
            if (We !== "children" && We !== "key") {
              Hn(W), J("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", We), Hn(null);
              break;
            }
          }
          W.ref !== null && (Hn(W), J("Invalid attribute `ref` supplied to `React.Fragment`."), Hn(null));
        }
      }
      function Yu(W, ve, Be) {
        var We = re(W);
        if (!We) {
          var ft = "";
          (W === void 0 || typeof W == "object" && W !== null && Object.keys(W).length === 0) && (ft += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var rn = fs(ve);
          rn ? ft += rn : ft += eu();
          var vt;
          W === null ? vt = "null" : Ot(W) ? vt = "array" : W !== void 0 && W.$$typeof === r ? (vt = "<" + (ar(W.type) || "Unknown") + " />", ft = " Did you accidentally export a JSX literal instead of a component?") : vt = typeof W, J("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", vt, ft);
        }
        var dn = U.apply(this, arguments);
        if (dn == null)
          return dn;
        if (We)
          for (var Gn = 2; Gn < arguments.length; Gn++)
            vl(arguments[Gn], W);
        return W === o ? lr(dn) : Hr(dn), dn;
      }
      var di = !1;
      function Xr(W) {
        var ve = Yu.bind(null, W);
        return ve.type = W, di || (di = !0, Z("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(ve, "type", {
          enumerable: !1,
          get: function() {
            return Z("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
              value: W
            }), W;
          }
        }), ve;
      }
      function hs(W, ve, Be) {
        for (var We = Ce.apply(this, arguments), ft = 2; ft < arguments.length; ft++)
          vl(arguments[ft], We.type);
        return Hr(We), We;
      }
      function Qu(W, ve) {
        var Be = M.transition;
        M.transition = {};
        var We = M.transition;
        M.transition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          W();
        } finally {
          if (M.transition = Be, Be === null && We._updatedFibers) {
            var ft = We._updatedFibers.size;
            ft > 10 && Z("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), We._updatedFibers.clear();
          }
        }
      }
      var Ks = !1, Ys = null;
      function mf(W) {
        if (Ys === null)
          try {
            var ve = ("require" + Math.random()).slice(0, 7), Be = e && e[ve];
            Ys = Be.call(e, "timers").setImmediate;
          } catch {
            Ys = function(ft) {
              Ks === !1 && (Ks = !0, typeof MessageChannel > "u" && J("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
              var rn = new MessageChannel();
              rn.port1.onmessage = ft, rn.port2.postMessage(void 0);
            };
          }
        return Ys(W);
      }
      var ca = 0, Qs = !1;
      function Xs(W) {
        {
          var ve = ca;
          ca++, L.current === null && (L.current = []);
          var Be = L.isBatchingLegacy, We;
          try {
            if (L.isBatchingLegacy = !0, We = W(), !Be && L.didScheduleLegacyUpdate) {
              var ft = L.current;
              ft !== null && (L.didScheduleLegacyUpdate = !1, It(ft));
            }
          } catch (jr) {
            throw fe(ve), jr;
          } finally {
            L.isBatchingLegacy = Be;
          }
          if (We !== null && typeof We == "object" && typeof We.then == "function") {
            var rn = We, vt = !1, dn = {
              then: function(jr, zr) {
                vt = !0, rn.then(function(Zn) {
                  fe(ve), ca === 0 ? Ie(Zn, jr, zr) : jr(Zn);
                }, function(Zn) {
                  fe(ve), zr(Zn);
                });
              }
            };
            return !Qs && typeof Promise < "u" && Promise.resolve().then(function() {
            }).then(function() {
              vt || (Qs = !0, J("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            }), dn;
          } else {
            var Gn = We;
            if (fe(ve), ca === 0) {
              var ur = L.current;
              ur !== null && (It(ur), L.current = null);
              var Lr = {
                then: function(jr, zr) {
                  L.current === null ? (L.current = [], Ie(Gn, jr, zr)) : jr(Gn);
                }
              };
              return Lr;
            } else {
              var Rr = {
                then: function(jr, zr) {
                  jr(Gn);
                }
              };
              return Rr;
            }
          }
        }
      }
      function fe(W) {
        W !== ca - 1 && J("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), ca = W;
      }
      function Ie(W, ve, Be) {
        {
          var We = L.current;
          if (We !== null)
            try {
              It(We), mf(function() {
                We.length === 0 ? (L.current = null, ve(W)) : Ie(W, ve, Be);
              });
            } catch (ft) {
              Be(ft);
            }
          else
            ve(W);
        }
      }
      var $e = !1;
      function It(W) {
        if (!$e) {
          $e = !0;
          var ve = 0;
          try {
            for (; ve < W.length; ve++) {
              var Be = W[ve];
              do
                Be = Be(!0);
              while (Be !== null);
            }
            W.length = 0;
          } catch (We) {
            throw W = W.slice(ve + 1), We;
          } finally {
            $e = !1;
          }
        }
      }
      var jn = Yu, cr = hs, Sr = Xr, Nn = {
        map: bi,
        forEach: la,
        count: Do,
        toArray: ja,
        only: Mo
      };
      t.Children = Nn, t.Component = Se, t.Fragment = o, t.Profiler = c, t.PureComponent = yt, t.StrictMode = s, t.Suspense = y, t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = X, t.act = Xs, t.cloneElement = cr, t.createContext = ri, t.createElement = jn, t.createFactory = Sr, t.createRef = hn, t.forwardRef = Ae, t.isValidElement = Te, t.lazy = we, t.memo = _e, t.startTransition = Qu, t.unstable_act = Xs, t.useCallback = on, t.useContext = Qe, t.useDebugValue = tn, t.useDeferredValue = xr, t.useEffect = ot, t.useId = vn, t.useImperativeHandle = sr, t.useInsertionEffect = cn, t.useLayoutEffect = Qt, t.useMemo = pn, t.useReducer = lt, t.useRef = tt, t.useState = Ke, t.useSyncExternalStore = ii, t.useTransition = Ur, t.version = n, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(g1, g1.exports)), g1.exports;
}
ct.env.NODE_ENV === "production" ? TI.exports = yae() : TI.exports = vae();
var k = TI.exports;
const $ = /* @__PURE__ */ DC(k), Qz = /* @__PURE__ */ qz({
  __proto__: null,
  default: $
}, [k]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var YL;
function gae() {
  if (YL) return Zw;
  YL = 1;
  var e = k, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(c, u, f) {
    var p, y = {}, v = null, w = null;
    f !== void 0 && (v = "" + f), u.key !== void 0 && (v = "" + u.key), u.ref !== void 0 && (w = u.ref);
    for (p in u) r.call(u, p) && !o.hasOwnProperty(p) && (y[p] = u[p]);
    if (c && c.defaultProps) for (p in u = c.defaultProps, u) y[p] === void 0 && (y[p] = u[p]);
    return { $$typeof: t, type: c, key: v, ref: w, props: y, _owner: i.current };
  }
  return Zw.Fragment = n, Zw.jsx = s, Zw.jsxs = s, Zw;
}
var e1 = {}, QL;
function bae() {
  return QL || (QL = 1, ct.env.NODE_ENV !== "production" && function() {
    var e = k, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), c = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), f = Symbol.for("react.suspense"), p = Symbol.for("react.suspense_list"), y = Symbol.for("react.memo"), v = Symbol.for("react.lazy"), w = Symbol.for("react.offscreen"), C = Symbol.iterator, x = "@@iterator";
    function A(re) {
      if (re === null || typeof re != "object")
        return null;
      var _e = C && re[C] || re[x];
      return typeof _e == "function" ? _e : null;
    }
    var R = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function I(re) {
      {
        for (var _e = arguments.length, Pe = new Array(_e > 1 ? _e - 1 : 0), Qe = 1; Qe < _e; Qe++)
          Pe[Qe - 1] = arguments[Qe];
        D("error", re, Pe);
      }
    }
    function D(re, _e, Pe) {
      {
        var Qe = R.ReactDebugCurrentFrame, Ke = Qe.getStackAddendum();
        Ke !== "" && (_e += "%s", Pe = Pe.concat([Ke]));
        var lt = Pe.map(function(tt) {
          return String(tt);
        });
        lt.unshift("Warning: " + _e), Function.prototype.apply.call(console[re], console, lt);
      }
    }
    var M = !1, L = !1, j = !1, F = !1, O = !1, z;
    z = Symbol.for("react.module.reference");
    function H(re) {
      return !!(typeof re == "string" || typeof re == "function" || re === r || re === o || O || re === i || re === f || re === p || F || re === w || M || L || j || typeof re == "object" && re !== null && (re.$$typeof === v || re.$$typeof === y || re.$$typeof === s || re.$$typeof === c || re.$$typeof === u || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      re.$$typeof === z || re.getModuleId !== void 0));
    }
    function Q(re, _e, Pe) {
      var Qe = re.displayName;
      if (Qe)
        return Qe;
      var Ke = _e.displayName || _e.name || "";
      return Ke !== "" ? Pe + "(" + Ke + ")" : Pe;
    }
    function Y(re) {
      return re.displayName || "Context";
    }
    function ee(re) {
      if (re == null)
        return null;
      if (typeof re.tag == "number" && I("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof re == "function")
        return re.displayName || re.name || null;
      if (typeof re == "string")
        return re;
      switch (re) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case o:
          return "Profiler";
        case i:
          return "StrictMode";
        case f:
          return "Suspense";
        case p:
          return "SuspenseList";
      }
      if (typeof re == "object")
        switch (re.$$typeof) {
          case c:
            var _e = re;
            return Y(_e) + ".Consumer";
          case s:
            var Pe = re;
            return Y(Pe._context) + ".Provider";
          case u:
            return Q(re, re.render, "ForwardRef");
          case y:
            var Qe = re.displayName || null;
            return Qe !== null ? Qe : ee(re.type) || "Memo";
          case v: {
            var Ke = re, lt = Ke._payload, tt = Ke._init;
            try {
              return ee(tt(lt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var ie = Object.assign, X = 0, Z, J, K, oe, be, ce, pe;
    function Ee() {
    }
    Ee.__reactDisabledLog = !0;
    function Se() {
      {
        if (X === 0) {
          Z = console.log, J = console.info, K = console.warn, oe = console.error, be = console.group, ce = console.groupCollapsed, pe = console.groupEnd;
          var re = {
            configurable: !0,
            enumerable: !0,
            value: Ee,
            writable: !0
          };
          Object.defineProperties(console, {
            info: re,
            log: re,
            warn: re,
            error: re,
            group: re,
            groupCollapsed: re,
            groupEnd: re
          });
        }
        X++;
      }
    }
    function Me() {
      {
        if (X--, X === 0) {
          var re = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: ie({}, re, {
              value: Z
            }),
            info: ie({}, re, {
              value: J
            }),
            warn: ie({}, re, {
              value: K
            }),
            error: ie({}, re, {
              value: oe
            }),
            group: ie({}, re, {
              value: be
            }),
            groupCollapsed: ie({}, re, {
              value: ce
            }),
            groupEnd: ie({}, re, {
              value: pe
            })
          });
        }
        X < 0 && I("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Fe = R.ReactCurrentDispatcher, st;
    function mt(re, _e, Pe) {
      {
        if (st === void 0)
          try {
            throw Error();
          } catch (Ke) {
            var Qe = Ke.stack.trim().match(/\n( *(at )?)/);
            st = Qe && Qe[1] || "";
          }
        return `
` + st + re;
      }
    }
    var yt = !1, Ut;
    {
      var hn = typeof WeakMap == "function" ? WeakMap : Map;
      Ut = new hn();
    }
    function wn(re, _e) {
      if (!re || yt)
        return "";
      {
        var Pe = Ut.get(re);
        if (Pe !== void 0)
          return Pe;
      }
      var Qe;
      yt = !0;
      var Ke = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var lt;
      lt = Fe.current, Fe.current = null, Se();
      try {
        if (_e) {
          var tt = function() {
            throw Error();
          };
          if (Object.defineProperty(tt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(tt, []);
            } catch (Ur) {
              Qe = Ur;
            }
            Reflect.construct(re, [], tt);
          } else {
            try {
              tt.call();
            } catch (Ur) {
              Qe = Ur;
            }
            re.call(tt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ur) {
            Qe = Ur;
          }
          re();
        }
      } catch (Ur) {
        if (Ur && Qe && typeof Ur.stack == "string") {
          for (var ot = Ur.stack.split(`
`), cn = Qe.stack.split(`
`), Qt = ot.length - 1, on = cn.length - 1; Qt >= 1 && on >= 0 && ot[Qt] !== cn[on]; )
            on--;
          for (; Qt >= 1 && on >= 0; Qt--, on--)
            if (ot[Qt] !== cn[on]) {
              if (Qt !== 1 || on !== 1)
                do
                  if (Qt--, on--, on < 0 || ot[Qt] !== cn[on]) {
                    var pn = `
` + ot[Qt].replace(" at new ", " at ");
                    return re.displayName && pn.includes("<anonymous>") && (pn = pn.replace("<anonymous>", re.displayName)), typeof re == "function" && Ut.set(re, pn), pn;
                  }
                while (Qt >= 1 && on >= 0);
              break;
            }
        }
      } finally {
        yt = !1, Fe.current = lt, Me(), Error.prepareStackTrace = Ke;
      }
      var sr = re ? re.displayName || re.name : "", tn = sr ? mt(sr) : "";
      return typeof re == "function" && Ut.set(re, tn), tn;
    }
    function Ot(re, _e, Pe) {
      return wn(re, !1);
    }
    function xt(re) {
      var _e = re.prototype;
      return !!(_e && _e.isReactComponent);
    }
    function zt(re, _e, Pe) {
      if (re == null)
        return "";
      if (typeof re == "function")
        return wn(re, xt(re));
      if (typeof re == "string")
        return mt(re);
      switch (re) {
        case f:
          return mt("Suspense");
        case p:
          return mt("SuspenseList");
      }
      if (typeof re == "object")
        switch (re.$$typeof) {
          case u:
            return Ot(re.render);
          case y:
            return zt(re.type, _e, Pe);
          case v: {
            var Qe = re, Ke = Qe._payload, lt = Qe._init;
            try {
              return zt(lt(Ke), _e, Pe);
            } catch {
            }
          }
        }
      return "";
    }
    var Pn = Object.prototype.hasOwnProperty, Fn = {}, tr = R.ReactDebugCurrentFrame;
    function or(re) {
      if (re) {
        var _e = re._owner, Pe = zt(re.type, re._source, _e ? _e.type : null);
        tr.setExtraStackFrame(Pe);
      } else
        tr.setExtraStackFrame(null);
    }
    function ar(re, _e, Pe, Qe, Ke) {
      {
        var lt = Function.call.bind(Pn);
        for (var tt in re)
          if (lt(re, tt)) {
            var ot = void 0;
            try {
              if (typeof re[tt] != "function") {
                var cn = Error((Qe || "React class") + ": " + Pe + " type `" + tt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof re[tt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw cn.name = "Invariant Violation", cn;
              }
              ot = re[tt](_e, tt, Qe, Pe, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Qt) {
              ot = Qt;
            }
            ot && !(ot instanceof Error) && (or(Ke), I("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Qe || "React class", Pe, tt, typeof ot), or(null)), ot instanceof Error && !(ot.message in Fn) && (Fn[ot.message] = !0, or(Ke), I("Failed %s type: %s", Pe, ot.message), or(null));
          }
      }
    }
    var Cr = Array.isArray;
    function Un(re) {
      return Cr(re);
    }
    function $n(re) {
      {
        var _e = typeof Symbol == "function" && Symbol.toStringTag, Pe = _e && re[Symbol.toStringTag] || re.constructor.name || "Object";
        return Pe;
      }
    }
    function gr(re) {
      try {
        return Tt(re), !1;
      } catch {
        return !0;
      }
    }
    function Tt(re) {
      return "" + re;
    }
    function qt(re) {
      if (gr(re))
        return I("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", $n(re)), Tt(re);
    }
    var gt = R.ReactCurrentOwner, Ht = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, br, ne, N;
    N = {};
    function U(re) {
      if (Pn.call(re, "ref")) {
        var _e = Object.getOwnPropertyDescriptor(re, "ref").get;
        if (_e && _e.isReactWarning)
          return !1;
      }
      return re.ref !== void 0;
    }
    function le(re) {
      if (Pn.call(re, "key")) {
        var _e = Object.getOwnPropertyDescriptor(re, "key").get;
        if (_e && _e.isReactWarning)
          return !1;
      }
      return re.key !== void 0;
    }
    function Ce(re, _e) {
      if (typeof re.ref == "string" && gt.current && _e && gt.current.stateNode !== _e) {
        var Pe = ee(gt.current.type);
        N[Pe] || (I('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', ee(gt.current.type), re.ref), N[Pe] = !0);
      }
    }
    function Te(re, _e) {
      {
        var Pe = function() {
          br || (br = !0, I("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", _e));
        };
        Pe.isReactWarning = !0, Object.defineProperty(re, "key", {
          get: Pe,
          configurable: !0
        });
      }
    }
    function Ve(re, _e) {
      {
        var Pe = function() {
          ne || (ne = !0, I("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", _e));
        };
        Pe.isReactWarning = !0, Object.defineProperty(re, "ref", {
          get: Pe,
          configurable: !0
        });
      }
    }
    var kt = function(re, _e, Pe, Qe, Ke, lt, tt) {
      var ot = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: re,
        key: _e,
        ref: Pe,
        props: tt,
        // Record the component responsible for creating this element.
        _owner: lt
      };
      return ot._store = {}, Object.defineProperty(ot._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ot, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Qe
      }), Object.defineProperty(ot, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ke
      }), Object.freeze && (Object.freeze(ot.props), Object.freeze(ot)), ot;
    };
    function bn(re, _e, Pe, Qe, Ke) {
      {
        var lt, tt = {}, ot = null, cn = null;
        Pe !== void 0 && (qt(Pe), ot = "" + Pe), le(_e) && (qt(_e.key), ot = "" + _e.key), U(_e) && (cn = _e.ref, Ce(_e, Ke));
        for (lt in _e)
          Pn.call(_e, lt) && !Ht.hasOwnProperty(lt) && (tt[lt] = _e[lt]);
        if (re && re.defaultProps) {
          var Qt = re.defaultProps;
          for (lt in Qt)
            tt[lt] === void 0 && (tt[lt] = Qt[lt]);
        }
        if (ot || cn) {
          var on = typeof re == "function" ? re.displayName || re.name || "Unknown" : re;
          ot && Te(tt, on), cn && Ve(tt, on);
        }
        return kt(re, ot, cn, Ke, Qe, gt.current, tt);
      }
    }
    var Wt = R.ReactCurrentOwner, xn = R.ReactDebugCurrentFrame;
    function St(re) {
      if (re) {
        var _e = re._owner, Pe = zt(re.type, re._source, _e ? _e.type : null);
        xn.setExtraStackFrame(Pe);
      } else
        xn.setExtraStackFrame(null);
    }
    var Qn;
    Qn = !1;
    function Nr(re) {
      return typeof re == "object" && re !== null && re.$$typeof === t;
    }
    function bi() {
      {
        if (Wt.current) {
          var re = ee(Wt.current.type);
          if (re)
            return `

Check the render method of \`` + re + "`.";
        }
        return "";
      }
    }
    function Do(re) {
      return "";
    }
    var la = {};
    function ja(re) {
      {
        var _e = bi();
        if (!_e) {
          var Pe = typeof re == "string" ? re : re.displayName || re.name;
          Pe && (_e = `

Check the top-level render call using <` + Pe + ">.");
        }
        return _e;
      }
    }
    function Mo(re, _e) {
      {
        if (!re._store || re._store.validated || re.key != null)
          return;
        re._store.validated = !0;
        var Pe = ja(_e);
        if (la[Pe])
          return;
        la[Pe] = !0;
        var Qe = "";
        re && re._owner && re._owner !== Wt.current && (Qe = " It was passed a child from " + ee(re._owner.type) + "."), St(re), I('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Pe, Qe), St(null);
      }
    }
    function ri(re, _e) {
      {
        if (typeof re != "object")
          return;
        if (Un(re))
          for (var Pe = 0; Pe < re.length; Pe++) {
            var Qe = re[Pe];
            Nr(Qe) && Mo(Qe, _e);
          }
        else if (Nr(re))
          re._store && (re._store.validated = !0);
        else if (re) {
          var Ke = A(re);
          if (typeof Ke == "function" && Ke !== re.entries)
            for (var lt = Ke.call(re), tt; !(tt = lt.next()).done; )
              Nr(tt.value) && Mo(tt.value, _e);
        }
      }
    }
    function ui(re) {
      {
        var _e = re.type;
        if (_e == null || typeof _e == "string")
          return;
        var Pe;
        if (typeof _e == "function")
          Pe = _e.propTypes;
        else if (typeof _e == "object" && (_e.$$typeof === u || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        _e.$$typeof === y))
          Pe = _e.propTypes;
        else
          return;
        if (Pe) {
          var Qe = ee(_e);
          ar(Pe, re.props, "prop", Qe, re);
        } else if (_e.PropTypes !== void 0 && !Qn) {
          Qn = !0;
          var Ke = ee(_e);
          I("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Ke || "Unknown");
        }
        typeof _e.getDefaultProps == "function" && !_e.getDefaultProps.isReactClassApproved && I("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ji(re) {
      {
        for (var _e = Object.keys(re.props), Pe = 0; Pe < _e.length; Pe++) {
          var Qe = _e[Pe];
          if (Qe !== "children" && Qe !== "key") {
            St(re), I("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Qe), St(null);
            break;
          }
        }
        re.ref !== null && (St(re), I("Invalid attribute `ref` supplied to `React.Fragment`."), St(null));
      }
    }
    var _i = {};
    function ho(re, _e, Pe, Qe, Ke, lt) {
      {
        var tt = H(re);
        if (!tt) {
          var ot = "";
          (re === void 0 || typeof re == "object" && re !== null && Object.keys(re).length === 0) && (ot += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var cn = Do();
          cn ? ot += cn : ot += bi();
          var Qt;
          re === null ? Qt = "null" : Un(re) ? Qt = "array" : re !== void 0 && re.$$typeof === t ? (Qt = "<" + (ee(re.type) || "Unknown") + " />", ot = " Did you accidentally export a JSX literal instead of a component?") : Qt = typeof re, I("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Qt, ot);
        }
        var on = bn(re, _e, Pe, Ke, lt);
        if (on == null)
          return on;
        if (tt) {
          var pn = _e.children;
          if (pn !== void 0)
            if (Qe)
              if (Un(pn)) {
                for (var sr = 0; sr < pn.length; sr++)
                  ri(pn[sr], re);
                Object.freeze && Object.freeze(pn);
              } else
                I("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              ri(pn, re);
        }
        if (Pn.call(_e, "key")) {
          var tn = ee(re), Ur = Object.keys(_e).filter(function(ii) {
            return ii !== "key";
          }), xr = Ur.length > 0 ? "{key: someKey, " + Ur.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!_i[tn + xr]) {
            var vn = Ur.length > 0 ? "{" + Ur.join(": ..., ") + ": ...}" : "{}";
            I(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, xr, tn, vn, tn), _i[tn + xr] = !0;
          }
        }
        return re === r ? ji(on) : ui(on), on;
      }
    }
    function wi(re, _e, Pe) {
      return ho(re, _e, Pe, !0);
    }
    function we(re, _e, Pe) {
      return ho(re, _e, Pe, !1);
    }
    var Ae = we, ye = wi;
    e1.Fragment = r, e1.jsx = Ae, e1.jsxs = ye;
  }()), e1;
}
ct.env.NODE_ENV === "production" ? AI.exports = gae() : AI.exports = bae();
var S = AI.exports, Ib = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(e) {
    return this.listeners.add(e), this.onSubscribe(), () => {
      this.listeners.delete(e), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, Yg = typeof window > "u" || "Deno" in globalThis;
function zl() {
}
function wae(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function _I(e) {
  return typeof e == "number" && e >= 0 && e !== 1 / 0;
}
function Xz(e, t) {
  return Math.max(e + (t || 0) - Date.now(), 0);
}
function Og(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Lc(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function XL(e, t) {
  const {
    type: n = "all",
    exact: r,
    fetchStatus: i,
    predicate: o,
    queryKey: s,
    stale: c
  } = e;
  if (s) {
    if (r) {
      if (t.queryHash !== qD(s, t.options))
        return !1;
    } else if (!z1(t.queryKey, s))
      return !1;
  }
  if (n !== "all") {
    const u = t.isActive();
    if (n === "active" && !u || n === "inactive" && u)
      return !1;
  }
  return !(typeof c == "boolean" && t.isStale() !== c || i && i !== t.state.fetchStatus || o && !o(t));
}
function JL(e, t) {
  const { exact: n, status: r, predicate: i, mutationKey: o } = e;
  if (o) {
    if (!t.options.mutationKey)
      return !1;
    if (n) {
      if (Wm(t.options.mutationKey) !== Wm(o))
        return !1;
    } else if (!z1(t.options.mutationKey, o))
      return !1;
  }
  return !(r && t.state.status !== r || i && !i(t));
}
function qD(e, t) {
  return ((t == null ? void 0 : t.queryKeyHashFn) || Wm)(e);
}
function Wm(e) {
  return JSON.stringify(
    e,
    (t, n) => OI(n) ? Object.keys(n).sort().reduce((r, i) => (r[i] = n[i], r), {}) : n
  );
}
function z1(e, t) {
  return e === t ? !0 : typeof e != typeof t ? !1 : e && t && typeof e == "object" && typeof t == "object" ? !Object.keys(t).some((n) => !z1(e[n], t[n])) : !1;
}
function RI(e, t) {
  if (e === t)
    return e;
  const n = ZL(e) && ZL(t);
  if (n || OI(e) && OI(t)) {
    const r = n ? e : Object.keys(e), i = r.length, o = n ? t : Object.keys(t), s = o.length, c = n ? [] : {};
    let u = 0;
    for (let f = 0; f < s; f++) {
      const p = n ? f : o[f];
      (!n && r.includes(p) || n) && e[p] === void 0 && t[p] === void 0 ? (c[p] = void 0, u++) : (c[p] = RI(e[p], t[p]), c[p] === e[p] && e[p] !== void 0 && u++);
    }
    return i === s && u === i ? e : c;
  }
  return t;
}
function C4(e, t) {
  if (!t || Object.keys(e).length !== Object.keys(t).length)
    return !1;
  for (const n in e)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function ZL(e) {
  return Array.isArray(e) && e.length === Object.keys(e).length;
}
function OI(e) {
  if (!ej(e))
    return !1;
  const t = e.constructor;
  if (t === void 0)
    return !0;
  const n = t.prototype;
  return !(!ej(n) || !n.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(e) !== Object.prototype);
}
function ej(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Cae(e) {
  return new Promise((t) => {
    setTimeout(t, e);
  });
}
function II(e, t, n) {
  if (typeof n.structuralSharing == "function")
    return n.structuralSharing(e, t);
  if (n.structuralSharing !== !1) {
    if (ct.env.NODE_ENV !== "production")
      try {
        return RI(e, t);
      } catch {
      }
    return RI(e, t);
  }
  return t;
}
function xae(e, t, n = 0) {
  const r = [...e, t];
  return n && r.length > n ? r.slice(1) : r;
}
function Eae(e, t, n = 0) {
  const r = [t, ...e];
  return n && r.length > n ? r.slice(0, -1) : r;
}
var DI = Symbol();
function Jz(e, t) {
  return ct.env.NODE_ENV !== "production" && e.queryFn, !e.queryFn && (t != null && t.initialPromise) ? () => t.initialPromise : !e.queryFn || e.queryFn === DI ? () => Promise.reject(new Error(`Missing queryFn: '${e.queryHash}'`)) : e.queryFn;
}
var Mm, _h, Bg, Pz, Sae = (Pz = class extends Ib {
  constructor() {
    super();
    An(this, Mm);
    An(this, _h);
    An(this, Bg);
    Bt(this, Bg, (t) => {
      if (!Yg && window.addEventListener) {
        const n = () => t();
        return window.addEventListener("visibilitychange", n, !1), () => {
          window.removeEventListener("visibilitychange", n);
        };
      }
    });
  }
  onSubscribe() {
    ke(this, _h) || this.setEventListener(ke(this, Bg));
  }
  onUnsubscribe() {
    var t;
    this.hasListeners() || ((t = ke(this, _h)) == null || t.call(this), Bt(this, _h, void 0));
  }
  setEventListener(t) {
    var n;
    Bt(this, Bg, t), (n = ke(this, _h)) == null || n.call(this), Bt(this, _h, t((r) => {
      typeof r == "boolean" ? this.setFocused(r) : this.onFocus();
    }));
  }
  setFocused(t) {
    ke(this, Mm) !== t && (Bt(this, Mm, t), this.onFocus());
  }
  onFocus() {
    const t = this.isFocused();
    this.listeners.forEach((n) => {
      n(t);
    });
  }
  isFocused() {
    var t;
    return typeof ke(this, Mm) == "boolean" ? ke(this, Mm) : ((t = globalThis.document) == null ? void 0 : t.visibilityState) !== "hidden";
  }
}, Mm = new WeakMap(), _h = new WeakMap(), Bg = new WeakMap(), Pz), WD = new Sae(), Lg, Rh, jg, Nz, kae = (Nz = class extends Ib {
  constructor() {
    super();
    An(this, Lg, !0);
    An(this, Rh);
    An(this, jg);
    Bt(this, jg, (t) => {
      if (!Yg && window.addEventListener) {
        const n = () => t(!0), r = () => t(!1);
        return window.addEventListener("online", n, !1), window.addEventListener("offline", r, !1), () => {
          window.removeEventListener("online", n), window.removeEventListener("offline", r);
        };
      }
    });
  }
  onSubscribe() {
    ke(this, Rh) || this.setEventListener(ke(this, jg));
  }
  onUnsubscribe() {
    var t;
    this.hasListeners() || ((t = ke(this, Rh)) == null || t.call(this), Bt(this, Rh, void 0));
  }
  setEventListener(t) {
    var n;
    Bt(this, jg, t), (n = ke(this, Rh)) == null || n.call(this), Bt(this, Rh, t(this.setOnline.bind(this)));
  }
  setOnline(t) {
    ke(this, Lg) !== t && (Bt(this, Lg, t), this.listeners.forEach((r) => {
      r(t);
    }));
  }
  isOnline() {
    return ke(this, Lg);
  }
}, Lg = new WeakMap(), Rh = new WeakMap(), jg = new WeakMap(), Nz), x4 = new kae();
function Aae(e) {
  return Math.min(1e3 * 2 ** e, 3e4);
}
function Zz(e) {
  return (e ?? "online") === "online" ? x4.isOnline() : !0;
}
var eV = class extends Error {
  constructor(e) {
    super("CancelledError"), this.revert = e == null ? void 0 : e.revert, this.silent = e == null ? void 0 : e.silent;
  }
};
function _R(e) {
  return e instanceof eV;
}
function tV(e) {
  let t = !1, n = 0, r = !1, i, o, s;
  const c = new Promise((R, I) => {
    o = R, s = I;
  }), u = (R) => {
    var I;
    r || (C(new eV(R)), (I = e.abort) == null || I.call(e));
  }, f = () => {
    t = !0;
  }, p = () => {
    t = !1;
  }, y = () => WD.isFocused() && (e.networkMode === "always" || x4.isOnline()) && e.canRun(), v = () => Zz(e.networkMode) && e.canRun(), w = (R) => {
    var I;
    r || (r = !0, (I = e.onSuccess) == null || I.call(e, R), i == null || i(), o(R));
  }, C = (R) => {
    var I;
    r || (r = !0, (I = e.onError) == null || I.call(e, R), i == null || i(), s(R));
  }, x = () => new Promise((R) => {
    var I;
    i = (D) => {
      (r || y()) && R(D);
    }, (I = e.onPause) == null || I.call(e);
  }).then(() => {
    var R;
    i = void 0, r || (R = e.onContinue) == null || R.call(e);
  }), A = () => {
    if (r)
      return;
    let R;
    const I = n === 0 ? e.initialPromise : void 0;
    try {
      R = I ?? e.fn();
    } catch (D) {
      R = Promise.reject(D);
    }
    Promise.resolve(R).then(w).catch((D) => {
      var O;
      if (r)
        return;
      const M = e.retry ?? (Yg ? 0 : 3), L = e.retryDelay ?? Aae, j = typeof L == "function" ? L(n, D) : L, F = M === !0 || typeof M == "number" && n < M || typeof M == "function" && M(n, D);
      if (t || !F) {
        C(D);
        return;
      }
      n++, (O = e.onFail) == null || O.call(e, n, D), Cae(j).then(() => y() ? void 0 : x()).then(() => {
        t ? C(D) : A();
      });
    });
  };
  return {
    promise: c,
    cancel: u,
    continue: () => (i == null || i(), c),
    cancelRetry: f,
    continueRetry: p,
    canStart: v,
    start: () => (v() ? A() : x().then(A), c)
  };
}
function Tae() {
  let e = [], t = 0, n = (c) => {
    c();
  }, r = (c) => {
    c();
  }, i = (c) => setTimeout(c, 0);
  const o = (c) => {
    t ? e.push(c) : i(() => {
      n(c);
    });
  }, s = () => {
    const c = e;
    e = [], c.length && i(() => {
      r(() => {
        c.forEach((u) => {
          n(u);
        });
      });
    });
  };
  return {
    batch: (c) => {
      let u;
      t++;
      try {
        u = c();
      } finally {
        t--, t || s();
      }
      return u;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (c) => (...u) => {
      o(() => {
        c(...u);
      });
    },
    schedule: o,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (c) => {
      n = c;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (c) => {
      r = c;
    },
    setScheduler: (c) => {
      i = c;
    }
  };
}
var Ao = Tae(), Pm, Bz, nV = (Bz = class {
  constructor() {
    An(this, Pm);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), _I(this.gcTime) && Bt(this, Pm, setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(e) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      e ?? (Yg ? 1 / 0 : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    ke(this, Pm) && (clearTimeout(ke(this, Pm)), Bt(this, Pm, void 0));
  }
}, Pm = new WeakMap(), Bz), Fg, Ug, Ul, Aa, _C, Nm, Nc, Ld, Lz, _ae = (Lz = class extends nV {
  constructor(t) {
    super();
    An(this, Nc);
    An(this, Fg);
    An(this, Ug);
    An(this, Ul);
    An(this, Aa);
    An(this, _C);
    An(this, Nm);
    Bt(this, Nm, !1), Bt(this, _C, t.defaultOptions), this.setOptions(t.options), this.observers = [], Bt(this, Ul, t.cache), this.queryKey = t.queryKey, this.queryHash = t.queryHash, Bt(this, Fg, Rae(this.options)), this.state = t.state ?? ke(this, Fg), this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    var t;
    return (t = ke(this, Aa)) == null ? void 0 : t.promise;
  }
  setOptions(t) {
    this.options = { ...ke(this, _C), ...t }, this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && ke(this, Ul).remove(this);
  }
  setData(t, n) {
    const r = II(this.state.data, t, this.options);
    return Yn(this, Nc, Ld).call(this, {
      data: r,
      type: "success",
      dataUpdatedAt: n == null ? void 0 : n.updatedAt,
      manual: n == null ? void 0 : n.manual
    }), r;
  }
  setState(t, n) {
    Yn(this, Nc, Ld).call(this, { type: "setState", state: t, setStateOptions: n });
  }
  cancel(t) {
    var r, i;
    const n = (r = ke(this, Aa)) == null ? void 0 : r.promise;
    return (i = ke(this, Aa)) == null || i.cancel(t), n ? n.then(zl).catch(zl) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(ke(this, Fg));
  }
  isActive() {
    return this.observers.some(
      (t) => Lc(t.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 && !this.isActive();
  }
  isStale() {
    return this.state.isInvalidated ? !0 : this.getObserversCount() > 0 ? this.observers.some(
      (t) => t.getCurrentResult().isStale
    ) : this.state.data === void 0;
  }
  isStaleByTime(t = 0) {
    return this.state.isInvalidated || this.state.data === void 0 || !Xz(this.state.dataUpdatedAt, t);
  }
  onFocus() {
    var n;
    const t = this.observers.find((r) => r.shouldFetchOnWindowFocus());
    t == null || t.refetch({ cancelRefetch: !1 }), (n = ke(this, Aa)) == null || n.continue();
  }
  onOnline() {
    var n;
    const t = this.observers.find((r) => r.shouldFetchOnReconnect());
    t == null || t.refetch({ cancelRefetch: !1 }), (n = ke(this, Aa)) == null || n.continue();
  }
  addObserver(t) {
    this.observers.includes(t) || (this.observers.push(t), this.clearGcTimeout(), ke(this, Ul).notify({ type: "observerAdded", query: this, observer: t }));
  }
  removeObserver(t) {
    this.observers.includes(t) && (this.observers = this.observers.filter((n) => n !== t), this.observers.length || (ke(this, Aa) && (ke(this, Nm) ? ke(this, Aa).cancel({ revert: !0 }) : ke(this, Aa).cancelRetry()), this.scheduleGc()), ke(this, Ul).notify({ type: "observerRemoved", query: this, observer: t }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || Yn(this, Nc, Ld).call(this, { type: "invalidate" });
  }
  fetch(t, n) {
    var u, f, p;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && (n != null && n.cancelRefetch))
        this.cancel({ silent: !0 });
      else if (ke(this, Aa))
        return ke(this, Aa).continueRetry(), ke(this, Aa).promise;
    }
    if (t && this.setOptions(t), !this.options.queryFn) {
      const y = this.observers.find((v) => v.options.queryFn);
      y && this.setOptions(y.options);
    }
    ct.env.NODE_ENV !== "production" && Array.isArray(this.options.queryKey);
    const r = new AbortController(), i = (y) => {
      Object.defineProperty(y, "signal", {
        enumerable: !0,
        get: () => (Bt(this, Nm, !0), r.signal)
      });
    }, o = () => {
      const y = Jz(this.options, n), v = {
        queryKey: this.queryKey,
        meta: this.meta
      };
      return i(v), Bt(this, Nm, !1), this.options.persister ? this.options.persister(
        y,
        v,
        this
      ) : y(v);
    }, s = {
      fetchOptions: n,
      options: this.options,
      queryKey: this.queryKey,
      state: this.state,
      fetchFn: o
    };
    i(s), (u = this.options.behavior) == null || u.onFetch(
      s,
      this
    ), Bt(this, Ug, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((f = s.fetchOptions) == null ? void 0 : f.meta)) && Yn(this, Nc, Ld).call(this, { type: "fetch", meta: (p = s.fetchOptions) == null ? void 0 : p.meta });
    const c = (y) => {
      var v, w, C, x;
      _R(y) && y.silent || Yn(this, Nc, Ld).call(this, {
        type: "error",
        error: y
      }), _R(y) || ((w = (v = ke(this, Ul).config).onError) == null || w.call(
        v,
        y,
        this
      ), (x = (C = ke(this, Ul).config).onSettled) == null || x.call(
        C,
        this.state.data,
        y,
        this
      )), this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1;
    };
    return Bt(this, Aa, tV({
      initialPromise: n == null ? void 0 : n.initialPromise,
      fn: s.fetchFn,
      abort: r.abort.bind(r),
      onSuccess: (y) => {
        var v, w, C, x;
        if (y === void 0) {
          ct.env.NODE_ENV, c(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        try {
          this.setData(y);
        } catch (A) {
          c(A);
          return;
        }
        (w = (v = ke(this, Ul).config).onSuccess) == null || w.call(v, y, this), (x = (C = ke(this, Ul).config).onSettled) == null || x.call(
          C,
          y,
          this.state.error,
          this
        ), this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1;
      },
      onError: c,
      onFail: (y, v) => {
        Yn(this, Nc, Ld).call(this, { type: "failed", failureCount: y, error: v });
      },
      onPause: () => {
        Yn(this, Nc, Ld).call(this, { type: "pause" });
      },
      onContinue: () => {
        Yn(this, Nc, Ld).call(this, { type: "continue" });
      },
      retry: s.options.retry,
      retryDelay: s.options.retryDelay,
      networkMode: s.options.networkMode,
      canRun: () => !0
    })), ke(this, Aa).start();
  }
}, Fg = new WeakMap(), Ug = new WeakMap(), Ul = new WeakMap(), Aa = new WeakMap(), _C = new WeakMap(), Nm = new WeakMap(), Nc = new WeakSet(), Ld = function(t) {
  const n = (r) => {
    switch (t.type) {
      case "failed":
        return {
          ...r,
          fetchFailureCount: t.failureCount,
          fetchFailureReason: t.error
        };
      case "pause":
        return {
          ...r,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...r,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...r,
          ...rV(r.data, this.options),
          fetchMeta: t.meta ?? null
        };
      case "success":
        return {
          ...r,
          data: t.data,
          dataUpdateCount: r.dataUpdateCount + 1,
          dataUpdatedAt: t.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: !1,
          status: "success",
          ...!t.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
      case "error":
        const i = t.error;
        return _R(i) && i.revert && ke(this, Ug) ? { ...ke(this, Ug), fetchStatus: "idle" } : {
          ...r,
          error: i,
          errorUpdateCount: r.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: r.fetchFailureCount + 1,
          fetchFailureReason: i,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...r,
          isInvalidated: !0
        };
      case "setState":
        return {
          ...r,
          ...t.state
        };
    }
  };
  this.state = n(this.state), Ao.batch(() => {
    this.observers.forEach((r) => {
      r.onQueryUpdate();
    }), ke(this, Ul).notify({ query: this, type: "updated", action: t });
  });
}, Lz);
function rV(e, t) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: Zz(t.networkMode) ? "fetching" : "paused",
    ...e === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function Rae(e) {
  const t = typeof e.initialData == "function" ? e.initialData() : e.initialData, n = t !== void 0, r = n ? typeof e.initialDataUpdatedAt == "function" ? e.initialDataUpdatedAt() : e.initialDataUpdatedAt : 0;
  return {
    data: t,
    dataUpdateCount: 0,
    dataUpdatedAt: n ? r ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: n ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var Ru, jz, Oae = (jz = class extends Ib {
  constructor(t = {}) {
    super();
    An(this, Ru);
    this.config = t, Bt(this, Ru, /* @__PURE__ */ new Map());
  }
  build(t, n, r) {
    const i = n.queryKey, o = n.queryHash ?? qD(i, n);
    let s = this.get(o);
    return s || (s = new _ae({
      cache: this,
      queryKey: i,
      queryHash: o,
      options: t.defaultQueryOptions(n),
      state: r,
      defaultOptions: t.getQueryDefaults(i)
    }), this.add(s)), s;
  }
  add(t) {
    ke(this, Ru).has(t.queryHash) || (ke(this, Ru).set(t.queryHash, t), this.notify({
      type: "added",
      query: t
    }));
  }
  remove(t) {
    const n = ke(this, Ru).get(t.queryHash);
    n && (t.destroy(), n === t && ke(this, Ru).delete(t.queryHash), this.notify({ type: "removed", query: t }));
  }
  clear() {
    Ao.batch(() => {
      this.getAll().forEach((t) => {
        this.remove(t);
      });
    });
  }
  get(t) {
    return ke(this, Ru).get(t);
  }
  getAll() {
    return [...ke(this, Ru).values()];
  }
  find(t) {
    const n = { exact: !0, ...t };
    return this.getAll().find(
      (r) => XL(n, r)
    );
  }
  findAll(t = {}) {
    const n = this.getAll();
    return Object.keys(t).length > 0 ? n.filter((r) => XL(t, r)) : n;
  }
  notify(t) {
    Ao.batch(() => {
      this.listeners.forEach((n) => {
        n(t);
      });
    });
  }
  onFocus() {
    Ao.batch(() => {
      this.getAll().forEach((t) => {
        t.onFocus();
      });
    });
  }
  onOnline() {
    Ao.batch(() => {
      this.getAll().forEach((t) => {
        t.onOnline();
      });
    });
  }
}, Ru = new WeakMap(), jz), Ou, Ja, Bm, Iu, Eh, Fz, Iae = (Fz = class extends nV {
  constructor(t) {
    super();
    An(this, Iu);
    An(this, Ou);
    An(this, Ja);
    An(this, Bm);
    this.mutationId = t.mutationId, Bt(this, Ja, t.mutationCache), Bt(this, Ou, []), this.state = t.state || iV(), this.setOptions(t.options), this.scheduleGc();
  }
  setOptions(t) {
    this.options = t, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(t) {
    ke(this, Ou).includes(t) || (ke(this, Ou).push(t), this.clearGcTimeout(), ke(this, Ja).notify({
      type: "observerAdded",
      mutation: this,
      observer: t
    }));
  }
  removeObserver(t) {
    Bt(this, Ou, ke(this, Ou).filter((n) => n !== t)), this.scheduleGc(), ke(this, Ja).notify({
      type: "observerRemoved",
      mutation: this,
      observer: t
    });
  }
  optionalRemove() {
    ke(this, Ou).length || (this.state.status === "pending" ? this.scheduleGc() : ke(this, Ja).remove(this));
  }
  continue() {
    var t;
    return ((t = ke(this, Bm)) == null ? void 0 : t.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(t) {
    var i, o, s, c, u, f, p, y, v, w, C, x, A, R, I, D, M, L, j, F;
    Bt(this, Bm, tV({
      fn: () => this.options.mutationFn ? this.options.mutationFn(t) : Promise.reject(new Error("No mutationFn found")),
      onFail: (O, z) => {
        Yn(this, Iu, Eh).call(this, { type: "failed", failureCount: O, error: z });
      },
      onPause: () => {
        Yn(this, Iu, Eh).call(this, { type: "pause" });
      },
      onContinue: () => {
        Yn(this, Iu, Eh).call(this, { type: "continue" });
      },
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => ke(this, Ja).canRun(this)
    }));
    const n = this.state.status === "pending", r = !ke(this, Bm).canStart();
    try {
      if (!n) {
        Yn(this, Iu, Eh).call(this, { type: "pending", variables: t, isPaused: r }), await ((o = (i = ke(this, Ja).config).onMutate) == null ? void 0 : o.call(
          i,
          t,
          this
        ));
        const z = await ((c = (s = this.options).onMutate) == null ? void 0 : c.call(s, t));
        z !== this.state.context && Yn(this, Iu, Eh).call(this, {
          type: "pending",
          context: z,
          variables: t,
          isPaused: r
        });
      }
      const O = await ke(this, Bm).start();
      return await ((f = (u = ke(this, Ja).config).onSuccess) == null ? void 0 : f.call(
        u,
        O,
        t,
        this.state.context,
        this
      )), await ((y = (p = this.options).onSuccess) == null ? void 0 : y.call(p, O, t, this.state.context)), await ((w = (v = ke(this, Ja).config).onSettled) == null ? void 0 : w.call(
        v,
        O,
        null,
        this.state.variables,
        this.state.context,
        this
      )), await ((x = (C = this.options).onSettled) == null ? void 0 : x.call(C, O, null, t, this.state.context)), Yn(this, Iu, Eh).call(this, { type: "success", data: O }), O;
    } catch (O) {
      try {
        throw await ((R = (A = ke(this, Ja).config).onError) == null ? void 0 : R.call(
          A,
          O,
          t,
          this.state.context,
          this
        )), await ((D = (I = this.options).onError) == null ? void 0 : D.call(
          I,
          O,
          t,
          this.state.context
        )), await ((L = (M = ke(this, Ja).config).onSettled) == null ? void 0 : L.call(
          M,
          void 0,
          O,
          this.state.variables,
          this.state.context,
          this
        )), await ((F = (j = this.options).onSettled) == null ? void 0 : F.call(
          j,
          void 0,
          O,
          t,
          this.state.context
        )), O;
      } finally {
        Yn(this, Iu, Eh).call(this, { type: "error", error: O });
      }
    } finally {
      ke(this, Ja).runNext(this);
    }
  }
}, Ou = new WeakMap(), Ja = new WeakMap(), Bm = new WeakMap(), Iu = new WeakSet(), Eh = function(t) {
  const n = (r) => {
    switch (t.type) {
      case "failed":
        return {
          ...r,
          failureCount: t.failureCount,
          failureReason: t.error
        };
      case "pause":
        return {
          ...r,
          isPaused: !0
        };
      case "continue":
        return {
          ...r,
          isPaused: !1
        };
      case "pending":
        return {
          ...r,
          context: t.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: t.isPaused,
          status: "pending",
          variables: t.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...r,
          data: t.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: !1
        };
      case "error":
        return {
          ...r,
          data: void 0,
          error: t.error,
          failureCount: r.failureCount + 1,
          failureReason: t.error,
          isPaused: !1,
          status: "error"
        };
    }
  };
  this.state = n(this.state), Ao.batch(() => {
    ke(this, Ou).forEach((r) => {
      r.onMutationUpdate(t);
    }), ke(this, Ja).notify({
      mutation: this,
      type: "updated",
      action: t
    });
  });
}, Fz);
function iV() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var al, RC, Uz, Dae = (Uz = class extends Ib {
  constructor(t = {}) {
    super();
    An(this, al);
    An(this, RC);
    this.config = t, Bt(this, al, /* @__PURE__ */ new Map()), Bt(this, RC, Date.now());
  }
  build(t, n, r) {
    const i = new Iae({
      mutationCache: this,
      mutationId: ++fk(this, RC)._,
      options: t.defaultMutationOptions(n),
      state: r
    });
    return this.add(i), i;
  }
  add(t) {
    const n = hk(t), r = ke(this, al).get(n) ?? [];
    r.push(t), ke(this, al).set(n, r), this.notify({ type: "added", mutation: t });
  }
  remove(t) {
    var r;
    const n = hk(t);
    if (ke(this, al).has(n)) {
      const i = (r = ke(this, al).get(n)) == null ? void 0 : r.filter((o) => o !== t);
      i && (i.length === 0 ? ke(this, al).delete(n) : ke(this, al).set(n, i));
    }
    this.notify({ type: "removed", mutation: t });
  }
  canRun(t) {
    var r;
    const n = (r = ke(this, al).get(hk(t))) == null ? void 0 : r.find((i) => i.state.status === "pending");
    return !n || n === t;
  }
  runNext(t) {
    var r;
    const n = (r = ke(this, al).get(hk(t))) == null ? void 0 : r.find((i) => i !== t && i.state.isPaused);
    return (n == null ? void 0 : n.continue()) ?? Promise.resolve();
  }
  clear() {
    Ao.batch(() => {
      this.getAll().forEach((t) => {
        this.remove(t);
      });
    });
  }
  getAll() {
    return [...ke(this, al).values()].flat();
  }
  find(t) {
    const n = { exact: !0, ...t };
    return this.getAll().find(
      (r) => JL(n, r)
    );
  }
  findAll(t = {}) {
    return this.getAll().filter((n) => JL(t, n));
  }
  notify(t) {
    Ao.batch(() => {
      this.listeners.forEach((n) => {
        n(t);
      });
    });
  }
  resumePausedMutations() {
    const t = this.getAll().filter((n) => n.state.isPaused);
    return Ao.batch(
      () => Promise.all(
        t.map((n) => n.continue().catch(zl))
      )
    );
  }
}, al = new WeakMap(), RC = new WeakMap(), Uz);
function hk(e) {
  var t;
  return ((t = e.options.scope) == null ? void 0 : t.id) ?? String(e.mutationId);
}
function E4(e) {
  return {
    onFetch: (t, n) => {
      var p, y, v, w, C;
      const r = t.options, i = (v = (y = (p = t.fetchOptions) == null ? void 0 : p.meta) == null ? void 0 : y.fetchMore) == null ? void 0 : v.direction, o = ((w = t.state.data) == null ? void 0 : w.pages) || [], s = ((C = t.state.data) == null ? void 0 : C.pageParams) || [];
      let c = { pages: [], pageParams: [] }, u = 0;
      const f = async () => {
        let x = !1;
        const A = (D) => {
          Object.defineProperty(D, "signal", {
            enumerable: !0,
            get: () => (t.signal.aborted ? x = !0 : t.signal.addEventListener("abort", () => {
              x = !0;
            }), t.signal)
          });
        }, R = Jz(t.options, t.fetchOptions), I = async (D, M, L) => {
          if (x)
            return Promise.reject();
          if (M == null && D.pages.length)
            return Promise.resolve(D);
          const j = {
            queryKey: t.queryKey,
            pageParam: M,
            direction: L ? "backward" : "forward",
            meta: t.options.meta
          };
          A(j);
          const F = await R(
            j
          ), { maxPages: O } = t.options, z = L ? Eae : xae;
          return {
            pages: z(D.pages, F, O),
            pageParams: z(D.pageParams, M, O)
          };
        };
        if (i && o.length) {
          const D = i === "backward", M = D ? oV : MI, L = {
            pages: o,
            pageParams: s
          }, j = M(r, L);
          c = await I(L, j, D);
        } else {
          const D = e ?? o.length;
          do {
            const M = u === 0 ? s[0] ?? r.initialPageParam : MI(r, c);
            if (u > 0 && M == null)
              break;
            c = await I(c, M), u++;
          } while (u < D);
        }
        return c;
      };
      t.options.persister ? t.fetchFn = () => {
        var x, A;
        return (A = (x = t.options).persister) == null ? void 0 : A.call(
          x,
          f,
          {
            queryKey: t.queryKey,
            meta: t.options.meta,
            signal: t.signal
          },
          n
        );
      } : t.fetchFn = f;
    }
  };
}
function MI(e, { pages: t, pageParams: n }) {
  const r = t.length - 1;
  return t.length > 0 ? e.getNextPageParam(
    t[r],
    t,
    n[r],
    n
  ) : void 0;
}
function oV(e, { pages: t, pageParams: n }) {
  var r;
  return t.length > 0 ? (r = e.getPreviousPageParam) == null ? void 0 : r.call(e, t[0], t, n[0], n) : void 0;
}
function Mae(e, t) {
  return t ? MI(e, t) != null : !1;
}
function Pae(e, t) {
  return !t || !e.getPreviousPageParam ? !1 : oV(e, t) != null;
}
var Mi, Oh, Ih, zg, Vg, Dh, $g, Hg, zz, Nae = (zz = class {
  constructor(e = {}) {
    An(this, Mi);
    An(this, Oh);
    An(this, Ih);
    An(this, zg);
    An(this, Vg);
    An(this, Dh);
    An(this, $g);
    An(this, Hg);
    Bt(this, Mi, e.queryCache || new Oae()), Bt(this, Oh, e.mutationCache || new Dae()), Bt(this, Ih, e.defaultOptions || {}), Bt(this, zg, /* @__PURE__ */ new Map()), Bt(this, Vg, /* @__PURE__ */ new Map()), Bt(this, Dh, 0);
  }
  mount() {
    fk(this, Dh)._++, ke(this, Dh) === 1 && (Bt(this, $g, WD.subscribe(async (e) => {
      e && (await this.resumePausedMutations(), ke(this, Mi).onFocus());
    })), Bt(this, Hg, x4.subscribe(async (e) => {
      e && (await this.resumePausedMutations(), ke(this, Mi).onOnline());
    })));
  }
  unmount() {
    var e, t;
    fk(this, Dh)._--, ke(this, Dh) === 0 && ((e = ke(this, $g)) == null || e.call(this), Bt(this, $g, void 0), (t = ke(this, Hg)) == null || t.call(this), Bt(this, Hg, void 0));
  }
  isFetching(e) {
    return ke(this, Mi).findAll({ ...e, fetchStatus: "fetching" }).length;
  }
  isMutating(e) {
    return ke(this, Oh).findAll({ ...e, status: "pending" }).length;
  }
  getQueryData(e) {
    var n;
    const t = this.defaultQueryOptions({ queryKey: e });
    return (n = ke(this, Mi).get(t.queryHash)) == null ? void 0 : n.state.data;
  }
  ensureQueryData(e) {
    const t = this.getQueryData(e.queryKey);
    if (t === void 0)
      return this.fetchQuery(e);
    {
      const n = this.defaultQueryOptions(e), r = ke(this, Mi).build(this, n);
      return e.revalidateIfStale && r.isStaleByTime(Og(n.staleTime, r)) && this.prefetchQuery(n), Promise.resolve(t);
    }
  }
  getQueriesData(e) {
    return ke(this, Mi).findAll(e).map(({ queryKey: t, state: n }) => {
      const r = n.data;
      return [t, r];
    });
  }
  setQueryData(e, t, n) {
    const r = this.defaultQueryOptions({ queryKey: e }), i = ke(this, Mi).get(
      r.queryHash
    ), o = i == null ? void 0 : i.state.data, s = wae(t, o);
    if (s !== void 0)
      return ke(this, Mi).build(this, r).setData(s, { ...n, manual: !0 });
  }
  setQueriesData(e, t, n) {
    return Ao.batch(
      () => ke(this, Mi).findAll(e).map(({ queryKey: r }) => [
        r,
        this.setQueryData(r, t, n)
      ])
    );
  }
  getQueryState(e) {
    var n;
    const t = this.defaultQueryOptions({ queryKey: e });
    return (n = ke(this, Mi).get(t.queryHash)) == null ? void 0 : n.state;
  }
  removeQueries(e) {
    const t = ke(this, Mi);
    Ao.batch(() => {
      t.findAll(e).forEach((n) => {
        t.remove(n);
      });
    });
  }
  resetQueries(e, t) {
    const n = ke(this, Mi), r = {
      type: "active",
      ...e
    };
    return Ao.batch(() => (n.findAll(e).forEach((i) => {
      i.reset();
    }), this.refetchQueries(r, t)));
  }
  cancelQueries(e = {}, t = {}) {
    const n = { revert: !0, ...t }, r = Ao.batch(
      () => ke(this, Mi).findAll(e).map((i) => i.cancel(n))
    );
    return Promise.all(r).then(zl).catch(zl);
  }
  invalidateQueries(e = {}, t = {}) {
    return Ao.batch(() => {
      if (ke(this, Mi).findAll(e).forEach((r) => {
        r.invalidate();
      }), e.refetchType === "none")
        return Promise.resolve();
      const n = {
        ...e,
        type: e.refetchType ?? e.type ?? "active"
      };
      return this.refetchQueries(n, t);
    });
  }
  refetchQueries(e = {}, t) {
    const n = {
      ...t,
      cancelRefetch: (t == null ? void 0 : t.cancelRefetch) ?? !0
    }, r = Ao.batch(
      () => ke(this, Mi).findAll(e).filter((i) => !i.isDisabled()).map((i) => {
        let o = i.fetch(void 0, n);
        return n.throwOnError || (o = o.catch(zl)), i.state.fetchStatus === "paused" ? Promise.resolve() : o;
      })
    );
    return Promise.all(r).then(zl);
  }
  fetchQuery(e) {
    const t = this.defaultQueryOptions(e);
    t.retry === void 0 && (t.retry = !1);
    const n = ke(this, Mi).build(this, t);
    return n.isStaleByTime(
      Og(t.staleTime, n)
    ) ? n.fetch(t) : Promise.resolve(n.state.data);
  }
  prefetchQuery(e) {
    return this.fetchQuery(e).then(zl).catch(zl);
  }
  fetchInfiniteQuery(e) {
    return e.behavior = E4(e.pages), this.fetchQuery(e);
  }
  prefetchInfiniteQuery(e) {
    return this.fetchInfiniteQuery(e).then(zl).catch(zl);
  }
  ensureInfiniteQueryData(e) {
    return e.behavior = E4(e.pages), this.ensureQueryData(e);
  }
  resumePausedMutations() {
    return x4.isOnline() ? ke(this, Oh).resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return ke(this, Mi);
  }
  getMutationCache() {
    return ke(this, Oh);
  }
  getDefaultOptions() {
    return ke(this, Ih);
  }
  setDefaultOptions(e) {
    Bt(this, Ih, e);
  }
  setQueryDefaults(e, t) {
    ke(this, zg).set(Wm(e), {
      queryKey: e,
      defaultOptions: t
    });
  }
  getQueryDefaults(e) {
    const t = [...ke(this, zg).values()];
    let n = {};
    return t.forEach((r) => {
      z1(e, r.queryKey) && (n = { ...n, ...r.defaultOptions });
    }), n;
  }
  setMutationDefaults(e, t) {
    ke(this, Vg).set(Wm(e), {
      mutationKey: e,
      defaultOptions: t
    });
  }
  getMutationDefaults(e) {
    const t = [...ke(this, Vg).values()];
    let n = {};
    return t.forEach((r) => {
      z1(e, r.mutationKey) && (n = { ...n, ...r.defaultOptions });
    }), n;
  }
  defaultQueryOptions(e) {
    if (e._defaulted)
      return e;
    const t = {
      ...ke(this, Ih).queries,
      ...this.getQueryDefaults(e.queryKey),
      ...e,
      _defaulted: !0
    };
    return t.queryHash || (t.queryHash = qD(
      t.queryKey,
      t
    )), t.refetchOnReconnect === void 0 && (t.refetchOnReconnect = t.networkMode !== "always"), t.throwOnError === void 0 && (t.throwOnError = !!t.suspense), !t.networkMode && t.persister && (t.networkMode = "offlineFirst"), t.enabled !== !0 && t.queryFn === DI && (t.enabled = !1), t;
  }
  defaultMutationOptions(e) {
    return e != null && e._defaulted ? e : {
      ...ke(this, Ih).mutations,
      ...(e == null ? void 0 : e.mutationKey) && this.getMutationDefaults(e.mutationKey),
      ...e,
      _defaulted: !0
    };
  }
  clear() {
    ke(this, Mi).clear(), ke(this, Oh).clear();
  }
}, Mi = new WeakMap(), Oh = new WeakMap(), Ih = new WeakMap(), zg = new WeakMap(), Vg = new WeakMap(), Dh = new WeakMap(), $g = new WeakMap(), Hg = new WeakMap(), zz), Ls, pr, OC, Za, Lm, qg, Du, IC, Wg, Gg, jm, Fm, Mh, Kg, Mr, b1, PI, NI, BI, LI, jI, FI, UI, sV, Vz, aV = (Vz = class extends Ib {
  constructor(t, n) {
    super();
    An(this, Mr);
    An(this, Ls);
    An(this, pr);
    An(this, OC);
    An(this, Za);
    An(this, Lm);
    An(this, qg);
    An(this, Du);
    An(this, IC);
    An(this, Wg);
    // This property keeps track of the last query with defined data.
    // It will be used to pass the previous data and query to the placeholder function between renders.
    An(this, Gg);
    An(this, jm);
    An(this, Fm);
    An(this, Mh);
    An(this, Kg, /* @__PURE__ */ new Set());
    this.options = n, Bt(this, Ls, t), Bt(this, Du, null), this.bindMethods(), this.setOptions(n);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    this.listeners.size === 1 && (ke(this, pr).addObserver(this), tj(ke(this, pr), this.options) ? Yn(this, Mr, b1).call(this) : this.updateResult(), Yn(this, Mr, LI).call(this));
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return zI(
      ke(this, pr),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return zI(
      ke(this, pr),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), Yn(this, Mr, jI).call(this), Yn(this, Mr, FI).call(this), ke(this, pr).removeObserver(this);
  }
  setOptions(t, n) {
    const r = this.options, i = ke(this, pr);
    if (this.options = ke(this, Ls).defaultQueryOptions(t), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof Lc(this.options.enabled, ke(this, pr)) != "boolean")
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    Yn(this, Mr, UI).call(this), ke(this, pr).setOptions(this.options), r._defaulted && !C4(this.options, r) && ke(this, Ls).getQueryCache().notify({
      type: "observerOptionsUpdated",
      query: ke(this, pr),
      observer: this
    });
    const o = this.hasListeners();
    o && nj(
      ke(this, pr),
      i,
      this.options,
      r
    ) && Yn(this, Mr, b1).call(this), this.updateResult(n), o && (ke(this, pr) !== i || Lc(this.options.enabled, ke(this, pr)) !== Lc(r.enabled, ke(this, pr)) || Og(this.options.staleTime, ke(this, pr)) !== Og(r.staleTime, ke(this, pr))) && Yn(this, Mr, PI).call(this);
    const s = Yn(this, Mr, NI).call(this);
    o && (ke(this, pr) !== i || Lc(this.options.enabled, ke(this, pr)) !== Lc(r.enabled, ke(this, pr)) || s !== ke(this, Mh)) && Yn(this, Mr, BI).call(this, s);
  }
  getOptimisticResult(t) {
    const n = ke(this, Ls).getQueryCache().build(ke(this, Ls), t), r = this.createResult(n, t);
    return Lae(this, r) && (Bt(this, Za, r), Bt(this, qg, this.options), Bt(this, Lm, ke(this, pr).state)), r;
  }
  getCurrentResult() {
    return ke(this, Za);
  }
  trackResult(t, n) {
    const r = {};
    return Object.keys(t).forEach((i) => {
      Object.defineProperty(r, i, {
        configurable: !1,
        enumerable: !0,
        get: () => (this.trackProp(i), n == null || n(i), t[i])
      });
    }), r;
  }
  trackProp(t) {
    ke(this, Kg).add(t);
  }
  getCurrentQuery() {
    return ke(this, pr);
  }
  refetch({ ...t } = {}) {
    return this.fetch({
      ...t
    });
  }
  fetchOptimistic(t) {
    const n = ke(this, Ls).defaultQueryOptions(t), r = ke(this, Ls).getQueryCache().build(ke(this, Ls), n);
    return r.isFetchingOptimistic = !0, r.fetch().then(() => this.createResult(r, n));
  }
  fetch(t) {
    return Yn(this, Mr, b1).call(this, {
      ...t,
      cancelRefetch: t.cancelRefetch ?? !0
    }).then(() => (this.updateResult(), ke(this, Za)));
  }
  createResult(t, n) {
    var F;
    const r = ke(this, pr), i = this.options, o = ke(this, Za), s = ke(this, Lm), c = ke(this, qg), f = t !== r ? t.state : ke(this, OC), { state: p } = t;
    let y = { ...p }, v = !1, w;
    if (n._optimisticResults) {
      const O = this.hasListeners(), z = !O && tj(t, n), H = O && nj(t, r, n, i);
      (z || H) && (y = {
        ...y,
        ...rV(p.data, t.options)
      }), n._optimisticResults === "isRestoring" && (y.fetchStatus = "idle");
    }
    let { error: C, errorUpdatedAt: x, status: A } = y;
    if (n.select && y.data !== void 0)
      if (o && y.data === (s == null ? void 0 : s.data) && n.select === ke(this, IC))
        w = ke(this, Wg);
      else
        try {
          Bt(this, IC, n.select), w = n.select(y.data), w = II(o == null ? void 0 : o.data, w, n), Bt(this, Wg, w), Bt(this, Du, null);
        } catch (O) {
          Bt(this, Du, O);
        }
    else
      w = y.data;
    if (n.placeholderData !== void 0 && w === void 0 && A === "pending") {
      let O;
      if (o != null && o.isPlaceholderData && n.placeholderData === (c == null ? void 0 : c.placeholderData))
        O = o.data;
      else if (O = typeof n.placeholderData == "function" ? n.placeholderData(
        (F = ke(this, Gg)) == null ? void 0 : F.state.data,
        ke(this, Gg)
      ) : n.placeholderData, n.select && O !== void 0)
        try {
          O = n.select(O), Bt(this, Du, null);
        } catch (z) {
          Bt(this, Du, z);
        }
      O !== void 0 && (A = "success", w = II(
        o == null ? void 0 : o.data,
        O,
        n
      ), v = !0);
    }
    ke(this, Du) && (C = ke(this, Du), w = ke(this, Wg), x = Date.now(), A = "error");
    const R = y.fetchStatus === "fetching", I = A === "pending", D = A === "error", M = I && R, L = w !== void 0;
    return {
      status: A,
      fetchStatus: y.fetchStatus,
      isPending: I,
      isSuccess: A === "success",
      isError: D,
      isInitialLoading: M,
      isLoading: M,
      data: w,
      dataUpdatedAt: y.dataUpdatedAt,
      error: C,
      errorUpdatedAt: x,
      failureCount: y.fetchFailureCount,
      failureReason: y.fetchFailureReason,
      errorUpdateCount: y.errorUpdateCount,
      isFetched: y.dataUpdateCount > 0 || y.errorUpdateCount > 0,
      isFetchedAfterMount: y.dataUpdateCount > f.dataUpdateCount || y.errorUpdateCount > f.errorUpdateCount,
      isFetching: R,
      isRefetching: R && !I,
      isLoadingError: D && !L,
      isPaused: y.fetchStatus === "paused",
      isPlaceholderData: v,
      isRefetchError: D && L,
      isStale: GD(t, n),
      refetch: this.refetch
    };
  }
  updateResult(t) {
    const n = ke(this, Za), r = this.createResult(ke(this, pr), this.options);
    if (Bt(this, Lm, ke(this, pr).state), Bt(this, qg, this.options), ke(this, Lm).data !== void 0 && Bt(this, Gg, ke(this, pr)), C4(r, n))
      return;
    Bt(this, Za, r);
    const i = {}, o = () => {
      if (!n)
        return !0;
      const { notifyOnChangeProps: s } = this.options, c = typeof s == "function" ? s() : s;
      if (c === "all" || !c && !ke(this, Kg).size)
        return !0;
      const u = new Set(
        c ?? ke(this, Kg)
      );
      return this.options.throwOnError && u.add("error"), Object.keys(ke(this, Za)).some((f) => {
        const p = f;
        return ke(this, Za)[p] !== n[p] && u.has(p);
      });
    };
    (t == null ? void 0 : t.listeners) !== !1 && o() && (i.listeners = !0), Yn(this, Mr, sV).call(this, { ...i, ...t });
  }
  onQueryUpdate() {
    this.updateResult(), this.hasListeners() && Yn(this, Mr, LI).call(this);
  }
}, Ls = new WeakMap(), pr = new WeakMap(), OC = new WeakMap(), Za = new WeakMap(), Lm = new WeakMap(), qg = new WeakMap(), Du = new WeakMap(), IC = new WeakMap(), Wg = new WeakMap(), Gg = new WeakMap(), jm = new WeakMap(), Fm = new WeakMap(), Mh = new WeakMap(), Kg = new WeakMap(), Mr = new WeakSet(), b1 = function(t) {
  Yn(this, Mr, UI).call(this);
  let n = ke(this, pr).fetch(
    this.options,
    t
  );
  return t != null && t.throwOnError || (n = n.catch(zl)), n;
}, PI = function() {
  Yn(this, Mr, jI).call(this);
  const t = Og(
    this.options.staleTime,
    ke(this, pr)
  );
  if (Yg || ke(this, Za).isStale || !_I(t))
    return;
  const r = Xz(ke(this, Za).dataUpdatedAt, t) + 1;
  Bt(this, jm, setTimeout(() => {
    ke(this, Za).isStale || this.updateResult();
  }, r));
}, NI = function() {
  return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(ke(this, pr)) : this.options.refetchInterval) ?? !1;
}, BI = function(t) {
  Yn(this, Mr, FI).call(this), Bt(this, Mh, t), !(Yg || Lc(this.options.enabled, ke(this, pr)) === !1 || !_I(ke(this, Mh)) || ke(this, Mh) === 0) && Bt(this, Fm, setInterval(() => {
    (this.options.refetchIntervalInBackground || WD.isFocused()) && Yn(this, Mr, b1).call(this);
  }, ke(this, Mh)));
}, LI = function() {
  Yn(this, Mr, PI).call(this), Yn(this, Mr, BI).call(this, Yn(this, Mr, NI).call(this));
}, jI = function() {
  ke(this, jm) && (clearTimeout(ke(this, jm)), Bt(this, jm, void 0));
}, FI = function() {
  ke(this, Fm) && (clearInterval(ke(this, Fm)), Bt(this, Fm, void 0));
}, UI = function() {
  const t = ke(this, Ls).getQueryCache().build(ke(this, Ls), this.options);
  if (t === ke(this, pr))
    return;
  const n = ke(this, pr);
  Bt(this, pr, t), Bt(this, OC, t.state), this.hasListeners() && (n == null || n.removeObserver(this), t.addObserver(this));
}, sV = function(t) {
  Ao.batch(() => {
    t.listeners && this.listeners.forEach((n) => {
      n(ke(this, Za));
    }), ke(this, Ls).getQueryCache().notify({
      query: ke(this, pr),
      type: "observerResultsUpdated"
    });
  });
}, Vz);
function Bae(e, t) {
  return Lc(t.enabled, e) !== !1 && e.state.data === void 0 && !(e.state.status === "error" && t.retryOnMount === !1);
}
function tj(e, t) {
  return Bae(e, t) || e.state.data !== void 0 && zI(e, t, t.refetchOnMount);
}
function zI(e, t, n) {
  if (Lc(t.enabled, e) !== !1) {
    const r = typeof n == "function" ? n(e) : n;
    return r === "always" || r !== !1 && GD(e, t);
  }
  return !1;
}
function nj(e, t, n, r) {
  return (e !== t || Lc(r.enabled, e) === !1) && (!n.suspense || e.state.status !== "error") && GD(e, n);
}
function GD(e, t) {
  return Lc(t.enabled, e) !== !1 && e.isStaleByTime(Og(t.staleTime, e));
}
function Lae(e, t) {
  return !C4(e.getCurrentResult(), t);
}
var jae = class extends aV {
  constructor(e, t) {
    super(e, t);
  }
  bindMethods() {
    super.bindMethods(), this.fetchNextPage = this.fetchNextPage.bind(this), this.fetchPreviousPage = this.fetchPreviousPage.bind(this);
  }
  setOptions(e, t) {
    super.setOptions(
      {
        ...e,
        behavior: E4()
      },
      t
    );
  }
  getOptimisticResult(e) {
    return e.behavior = E4(), super.getOptimisticResult(e);
  }
  fetchNextPage(e) {
    return this.fetch({
      ...e,
      meta: {
        fetchMore: { direction: "forward" }
      }
    });
  }
  fetchPreviousPage(e) {
    return this.fetch({
      ...e,
      meta: {
        fetchMore: { direction: "backward" }
      }
    });
  }
  createResult(e, t) {
    var C, x;
    const { state: n } = e, r = super.createResult(e, t), { isFetching: i, isRefetching: o, isError: s, isRefetchError: c } = r, u = (x = (C = n.fetchMeta) == null ? void 0 : C.fetchMore) == null ? void 0 : x.direction, f = s && u === "forward", p = i && u === "forward", y = s && u === "backward", v = i && u === "backward";
    return {
      ...r,
      fetchNextPage: this.fetchNextPage,
      fetchPreviousPage: this.fetchPreviousPage,
      hasNextPage: Mae(t, n.data),
      hasPreviousPage: Pae(t, n.data),
      isFetchNextPageError: f,
      isFetchingNextPage: p,
      isFetchPreviousPageError: y,
      isFetchingPreviousPage: v,
      isRefetchError: c && !f && !y,
      isRefetching: o && !p && !v
    };
  }
}, Ph, Nh, js, jd, Yd, Zk, VI, $z, Fae = ($z = class extends Ib {
  constructor(n, r) {
    super();
    An(this, Yd);
    An(this, Ph);
    An(this, Nh);
    An(this, js);
    An(this, jd);
    Bt(this, Ph, n), this.setOptions(r), this.bindMethods(), Yn(this, Yd, Zk).call(this);
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this);
  }
  setOptions(n) {
    var i;
    const r = this.options;
    this.options = ke(this, Ph).defaultMutationOptions(n), C4(this.options, r) || ke(this, Ph).getMutationCache().notify({
      type: "observerOptionsUpdated",
      mutation: ke(this, js),
      observer: this
    }), r != null && r.mutationKey && this.options.mutationKey && Wm(r.mutationKey) !== Wm(this.options.mutationKey) ? this.reset() : ((i = ke(this, js)) == null ? void 0 : i.state.status) === "pending" && ke(this, js).setOptions(this.options);
  }
  onUnsubscribe() {
    var n;
    this.hasListeners() || (n = ke(this, js)) == null || n.removeObserver(this);
  }
  onMutationUpdate(n) {
    Yn(this, Yd, Zk).call(this), Yn(this, Yd, VI).call(this, n);
  }
  getCurrentResult() {
    return ke(this, Nh);
  }
  reset() {
    var n;
    (n = ke(this, js)) == null || n.removeObserver(this), Bt(this, js, void 0), Yn(this, Yd, Zk).call(this), Yn(this, Yd, VI).call(this);
  }
  mutate(n, r) {
    var i;
    return Bt(this, jd, r), (i = ke(this, js)) == null || i.removeObserver(this), Bt(this, js, ke(this, Ph).getMutationCache().build(ke(this, Ph), this.options)), ke(this, js).addObserver(this), ke(this, js).execute(n);
  }
}, Ph = new WeakMap(), Nh = new WeakMap(), js = new WeakMap(), jd = new WeakMap(), Yd = new WeakSet(), Zk = function() {
  var r;
  const n = ((r = ke(this, js)) == null ? void 0 : r.state) ?? iV();
  Bt(this, Nh, {
    ...n,
    isPending: n.status === "pending",
    isSuccess: n.status === "success",
    isError: n.status === "error",
    isIdle: n.status === "idle",
    mutate: this.mutate,
    reset: this.reset
  });
}, VI = function(n) {
  Ao.batch(() => {
    var r, i, o, s, c, u, f, p;
    if (ke(this, jd) && this.hasListeners()) {
      const y = ke(this, Nh).variables, v = ke(this, Nh).context;
      (n == null ? void 0 : n.type) === "success" ? ((i = (r = ke(this, jd)).onSuccess) == null || i.call(r, n.data, y, v), (s = (o = ke(this, jd)).onSettled) == null || s.call(o, n.data, null, y, v)) : (n == null ? void 0 : n.type) === "error" && ((u = (c = ke(this, jd)).onError) == null || u.call(c, n.error, y, v), (p = (f = ke(this, jd)).onSettled) == null || p.call(
        f,
        void 0,
        n.error,
        y,
        v
      ));
    }
    this.listeners.forEach((y) => {
      y(ke(this, Nh));
    });
  });
}, $z), lV = k.createContext(
  void 0
), cV = (e) => {
  const t = k.useContext(lV);
  if (!t)
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  return t;
}, Uae = ({
  client: e,
  children: t
}) => (k.useEffect(() => (e.mount(), () => {
  e.unmount();
}), [e]), /* @__PURE__ */ S.jsx(lV.Provider, { value: e, children: t })), uV = k.createContext(!1), zae = () => k.useContext(uV);
uV.Provider;
function Vae() {
  let e = !1;
  return {
    clearReset: () => {
      e = !1;
    },
    reset: () => {
      e = !0;
    },
    isReset: () => e
  };
}
var $ae = k.createContext(Vae()), Hae = () => k.useContext($ae);
function dV(e, t) {
  return typeof e == "function" ? e(...t) : !!e;
}
function qae() {
}
var Wae = (e, t) => {
  (e.suspense || e.throwOnError) && (t.isReset() || (e.retryOnMount = !1));
}, Gae = (e) => {
  k.useEffect(() => {
    e.clearReset();
  }, [e]);
}, Kae = ({
  result: e,
  errorResetBoundary: t,
  throwOnError: n,
  query: r
}) => e.isError && !t.isReset() && !e.isFetching && r && dV(n, [e.error, r]), Yae = (e) => {
  e.suspense && (typeof e.staleTime != "number" && (e.staleTime = 1e3), typeof e.gcTime == "number" && (e.gcTime = Math.max(e.gcTime, 1e3)));
}, Qae = (e, t) => (e == null ? void 0 : e.suspense) && t.isPending, Xae = (e, t, n) => t.fetchOptimistic(e).catch(() => {
  n.clearReset();
});
function fV(e, t, n) {
  var f, p, y, v;
  if (ct.env.NODE_ENV !== "production" && (typeof e != "object" || Array.isArray(e)))
    throw new Error(
      'Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'
    );
  const r = cV(), i = zae(), o = Hae(), s = r.defaultQueryOptions(e);
  (p = (f = r.getDefaultOptions().queries) == null ? void 0 : f._experimental_beforeQuery) == null || p.call(
    f,
    s
  ), s._optimisticResults = i ? "isRestoring" : "optimistic", Yae(s), Wae(s, o), Gae(o);
  const [c] = k.useState(
    () => new t(
      r,
      s
    )
  ), u = c.getOptimisticResult(s);
  if (k.useSyncExternalStore(
    k.useCallback(
      (w) => {
        const C = i ? () => {
        } : c.subscribe(Ao.batchCalls(w));
        return c.updateResult(), C;
      },
      [c, i]
    ),
    () => c.getCurrentResult(),
    () => c.getCurrentResult()
  ), k.useEffect(() => {
    c.setOptions(s, { listeners: !1 });
  }, [s, c]), Qae(s, u))
    throw Xae(s, c, o);
  if (Kae({
    result: u,
    errorResetBoundary: o,
    throwOnError: s.throwOnError,
    query: r.getQueryCache().get(s.queryHash)
  }))
    throw u.error;
  return (v = (y = r.getDefaultOptions().queries) == null ? void 0 : y._experimental_afterQuery) == null || v.call(
    y,
    s,
    u
  ), s.notifyOnChangeProps ? u : c.trackResult(u);
}
function Qr(e, t) {
  return fV(e, aV);
}
function ec(e, t) {
  const n = cV(), [r] = k.useState(
    () => new Fae(
      n,
      e
    )
  );
  k.useEffect(() => {
    r.setOptions(e);
  }, [r, e]);
  const i = k.useSyncExternalStore(
    k.useCallback(
      (s) => r.subscribe(Ao.batchCalls(s)),
      [r]
    ),
    () => r.getCurrentResult(),
    () => r.getCurrentResult()
  ), o = k.useCallback(
    (s, c) => {
      r.mutate(s, c).catch(qae);
    },
    [r]
  );
  if (i.error && dV(r.options.throwOnError, [i.error]))
    throw i.error;
  return { ...i, mutate: o, mutateAsync: i.mutate };
}
function Jae(e, t) {
  return fV(
    e,
    jae
  );
}
const Zae = {
  type: "logger",
  log(e) {
    this.output("log", e);
  },
  warn(e) {
    this.output("warn", e);
  },
  error(e) {
    this.output("error", e);
  },
  output(e, t) {
    console && console[e];
  }
};
class S4 {
  constructor(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(t, n);
  }
  init(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = n.prefix || "i18next:", this.logger = t || Zae, this.options = n, this.debug = n.debug;
  }
  log() {
    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
      n[r] = arguments[r];
    return this.forward(n, "log", "", !0);
  }
  warn() {
    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
      n[r] = arguments[r];
    return this.forward(n, "warn", "", !0);
  }
  error() {
    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
      n[r] = arguments[r];
    return this.forward(n, "error", "");
  }
  deprecate() {
    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
      n[r] = arguments[r];
    return this.forward(n, "warn", "WARNING DEPRECATED: ", !0);
  }
  forward(t, n, r, i) {
    return i && !this.debug ? null : (typeof t[0] == "string" && (t[0] = `${r}${this.prefix} ${t[0]}`), this.logger[n](t));
  }
  create(t) {
    return new S4(this.logger, {
      prefix: `${this.prefix}:${t}:`,
      ...this.options
    });
  }
  clone(t) {
    return t = t || this.options, t.prefix = t.prefix || this.prefix, new S4(this.logger, t);
  }
}
var Nu = new S4();
let y8 = class {
  constructor() {
    this.observers = {};
  }
  on(t, n) {
    return t.split(" ").forEach((r) => {
      this.observers[r] || (this.observers[r] = /* @__PURE__ */ new Map());
      const i = this.observers[r].get(n) || 0;
      this.observers[r].set(n, i + 1);
    }), this;
  }
  off(t, n) {
    if (this.observers[t]) {
      if (!n) {
        delete this.observers[t];
        return;
      }
      this.observers[t].delete(n);
    }
  }
  emit(t) {
    for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
      r[i - 1] = arguments[i];
    this.observers[t] && Array.from(this.observers[t].entries()).forEach((s) => {
      let [c, u] = s;
      for (let f = 0; f < u; f++)
        c(...r);
    }), this.observers["*"] && Array.from(this.observers["*"].entries()).forEach((s) => {
      let [c, u] = s;
      for (let f = 0; f < u; f++)
        c.apply(c, [t, ...r]);
    });
  }
};
const t1 = () => {
  let e, t;
  const n = new Promise((r, i) => {
    e = r, t = i;
  });
  return n.resolve = e, n.reject = t, n;
}, rj = (e) => e == null ? "" : "" + e, ese = (e, t, n) => {
  e.forEach((r) => {
    t[r] && (n[r] = t[r]);
  });
}, tse = /###/g, ij = (e) => e && e.indexOf("###") > -1 ? e.replace(tse, ".") : e, oj = (e) => !e || typeof e == "string", I1 = (e, t, n) => {
  const r = typeof t != "string" ? t : t.split(".");
  let i = 0;
  for (; i < r.length - 1; ) {
    if (oj(e)) return {};
    const o = ij(r[i]);
    !e[o] && n && (e[o] = new n()), Object.prototype.hasOwnProperty.call(e, o) ? e = e[o] : e = {}, ++i;
  }
  return oj(e) ? {} : {
    obj: e,
    k: ij(r[i])
  };
}, aj = (e, t, n) => {
  const {
    obj: r,
    k: i
  } = I1(e, t, Object);
  if (r !== void 0 || t.length === 1) {
    r[i] = n;
    return;
  }
  let o = t[t.length - 1], s = t.slice(0, t.length - 1), c = I1(e, s, Object);
  for (; c.obj === void 0 && s.length; )
    o = `${s[s.length - 1]}.${o}`, s = s.slice(0, s.length - 1), c = I1(e, s, Object), c && c.obj && typeof c.obj[`${c.k}.${o}`] < "u" && (c.obj = void 0);
  c.obj[`${c.k}.${o}`] = n;
}, nse = (e, t, n, r) => {
  const {
    obj: i,
    k: o
  } = I1(e, t, Object);
  i[o] = i[o] || [], i[o].push(n);
}, k4 = (e, t) => {
  const {
    obj: n,
    k: r
  } = I1(e, t);
  if (n)
    return n[r];
}, rse = (e, t, n) => {
  const r = k4(e, n);
  return r !== void 0 ? r : k4(t, n);
}, hV = (e, t, n) => {
  for (const r in t)
    r !== "__proto__" && r !== "constructor" && (r in e ? typeof e[r] == "string" || e[r] instanceof String || typeof t[r] == "string" || t[r] instanceof String ? n && (e[r] = t[r]) : hV(e[r], t[r], n) : e[r] = t[r]);
  return e;
}, ng = (e) => e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var ise = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
const ose = (e) => typeof e == "string" ? e.replace(/[&<>"'\/]/g, (t) => ise[t]) : e;
class ase {
  constructor(t) {
    this.capacity = t, this.regExpMap = /* @__PURE__ */ new Map(), this.regExpQueue = [];
  }
  getRegExp(t) {
    const n = this.regExpMap.get(t);
    if (n !== void 0)
      return n;
    const r = new RegExp(t);
    return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()), this.regExpMap.set(t, r), this.regExpQueue.push(t), r;
  }
}
const sse = [" ", ",", "?", "!", ";"], lse = new ase(20), cse = (e, t, n) => {
  t = t || "", n = n || "";
  const r = sse.filter((s) => t.indexOf(s) < 0 && n.indexOf(s) < 0);
  if (r.length === 0) return !0;
  const i = lse.getRegExp(`(${r.map((s) => s === "?" ? "\\?" : s).join("|")})`);
  let o = !i.test(e);
  if (!o) {
    const s = e.indexOf(n);
    s > 0 && !i.test(e.substring(0, s)) && (o = !0);
  }
  return o;
}, $I = function(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!e) return;
  if (e[t]) return e[t];
  const r = t.split(n);
  let i = e;
  for (let o = 0; o < r.length; ) {
    if (!i || typeof i != "object")
      return;
    let s, c = "";
    for (let u = o; u < r.length; ++u)
      if (u !== o && (c += n), c += r[u], s = i[c], s !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof s) > -1 && u < r.length - 1)
          continue;
        o += u - o + 1;
        break;
      }
    i = s;
  }
  return i;
}, A4 = (e) => e && e.indexOf("_") > 0 ? e.replace("_", "-") : e;
class sj extends y8 {
  constructor(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super(), this.data = t || {}, this.options = n, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0);
  }
  addNamespaces(t) {
    this.options.ns.indexOf(t) < 0 && this.options.ns.push(t);
  }
  removeNamespaces(t) {
    const n = this.options.ns.indexOf(t);
    n > -1 && this.options.ns.splice(n, 1);
  }
  getResource(t, n, r) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const o = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator, s = i.ignoreJSONStructure !== void 0 ? i.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let c;
    t.indexOf(".") > -1 ? c = t.split(".") : (c = [t, n], r && (Array.isArray(r) ? c.push(...r) : typeof r == "string" && o ? c.push(...r.split(o)) : c.push(r)));
    const u = k4(this.data, c);
    return !u && !n && !r && t.indexOf(".") > -1 && (t = c[0], n = c[1], r = c.slice(2).join(".")), u || !s || typeof r != "string" ? u : $I(this.data && this.data[t] && this.data[t][n], r, o);
  }
  addResource(t, n, r, i) {
    let o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: !1
    };
    const s = o.keySeparator !== void 0 ? o.keySeparator : this.options.keySeparator;
    let c = [t, n];
    r && (c = c.concat(s ? r.split(s) : r)), t.indexOf(".") > -1 && (c = t.split("."), i = n, n = c[1]), this.addNamespaces(n), aj(this.data, c, i), o.silent || this.emit("added", t, n, r, i);
  }
  addResources(t, n, r) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: !1
    };
    for (const o in r)
      (typeof r[o] == "string" || Array.isArray(r[o])) && this.addResource(t, n, o, r[o], {
        silent: !0
      });
    i.silent || this.emit("added", t, n, r);
  }
  addResourceBundle(t, n, r, i, o) {
    let s = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: !1,
      skipCopy: !1
    }, c = [t, n];
    t.indexOf(".") > -1 && (c = t.split("."), i = r, r = n, n = c[1]), this.addNamespaces(n);
    let u = k4(this.data, c) || {};
    s.skipCopy || (r = JSON.parse(JSON.stringify(r))), i ? hV(u, r, o) : u = {
      ...u,
      ...r
    }, aj(this.data, c, u), s.silent || this.emit("added", t, n, r);
  }
  removeResourceBundle(t, n) {
    this.hasResourceBundle(t, n) && delete this.data[t][n], this.removeNamespaces(n), this.emit("removed", t, n);
  }
  hasResourceBundle(t, n) {
    return this.getResource(t, n) !== void 0;
  }
  getResourceBundle(t, n) {
    return n || (n = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? {
      ...this.getResource(t, n)
    } : this.getResource(t, n);
  }
  getDataByLanguage(t) {
    return this.data[t];
  }
  hasLanguageSomeTranslations(t) {
    const n = this.getDataByLanguage(t);
    return !!(n && Object.keys(n) || []).find((i) => n[i] && Object.keys(n[i]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var pV = {
  processors: {},
  addPostProcessor(e) {
    this.processors[e.name] = e;
  },
  handle(e, t, n, r, i) {
    return e.forEach((o) => {
      this.processors[o] && (t = this.processors[o].process(t, n, r, i));
    }), t;
  }
};
const lj = {};
class T4 extends y8 {
  constructor(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), ese(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], t, this), this.options = n, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.logger = Nu.create("translator");
  }
  changeLanguage(t) {
    t && (this.language = t);
  }
  exists(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (t == null)
      return !1;
    const r = this.resolve(t, n);
    return r && r.res !== void 0;
  }
  extractFromKey(t, n) {
    let r = n.nsSeparator !== void 0 ? n.nsSeparator : this.options.nsSeparator;
    r === void 0 && (r = ":");
    const i = n.keySeparator !== void 0 ? n.keySeparator : this.options.keySeparator;
    let o = n.ns || this.options.defaultNS || [];
    const s = r && t.indexOf(r) > -1, c = !this.options.userDefinedKeySeparator && !n.keySeparator && !this.options.userDefinedNsSeparator && !n.nsSeparator && !cse(t, r, i);
    if (s && !c) {
      const u = t.match(this.interpolator.nestingRegexp);
      if (u && u.length > 0)
        return {
          key: t,
          namespaces: o
        };
      const f = t.split(r);
      (r !== i || r === i && this.options.ns.indexOf(f[0]) > -1) && (o = f.shift()), t = f.join(i);
    }
    return typeof o == "string" && (o = [o]), {
      key: t,
      namespaces: o
    };
  }
  translate(t, n, r) {
    if (typeof n != "object" && this.options.overloadTranslationOptionHandler && (n = this.options.overloadTranslationOptionHandler(arguments)), typeof n == "object" && (n = {
      ...n
    }), n || (n = {}), t == null) return "";
    Array.isArray(t) || (t = [String(t)]);
    const i = n.returnDetails !== void 0 ? n.returnDetails : this.options.returnDetails, o = n.keySeparator !== void 0 ? n.keySeparator : this.options.keySeparator, {
      key: s,
      namespaces: c
    } = this.extractFromKey(t[t.length - 1], n), u = c[c.length - 1], f = n.lng || this.language, p = n.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (f && f.toLowerCase() === "cimode") {
      if (p) {
        const M = n.nsSeparator || this.options.nsSeparator;
        return i ? {
          res: `${u}${M}${s}`,
          usedKey: s,
          exactUsedKey: s,
          usedLng: f,
          usedNS: u,
          usedParams: this.getUsedParamsDetails(n)
        } : `${u}${M}${s}`;
      }
      return i ? {
        res: s,
        usedKey: s,
        exactUsedKey: s,
        usedLng: f,
        usedNS: u,
        usedParams: this.getUsedParamsDetails(n)
      } : s;
    }
    const y = this.resolve(t, n);
    let v = y && y.res;
    const w = y && y.usedKey || s, C = y && y.exactUsedKey || s, x = Object.prototype.toString.apply(v), A = ["[object Number]", "[object Function]", "[object RegExp]"], R = n.joinArrays !== void 0 ? n.joinArrays : this.options.joinArrays, I = !this.i18nFormat || this.i18nFormat.handleAsObject;
    if (I && v && (typeof v != "string" && typeof v != "boolean" && typeof v != "number") && A.indexOf(x) < 0 && !(typeof R == "string" && Array.isArray(v))) {
      if (!n.returnObjects && !this.options.returnObjects) {
        this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        const M = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(w, v, {
          ...n,
          ns: c
        }) : `key '${s} (${this.language})' returned an object instead of string.`;
        return i ? (y.res = M, y.usedParams = this.getUsedParamsDetails(n), y) : M;
      }
      if (o) {
        const M = Array.isArray(v), L = M ? [] : {}, j = M ? C : w;
        for (const F in v)
          if (Object.prototype.hasOwnProperty.call(v, F)) {
            const O = `${j}${o}${F}`;
            L[F] = this.translate(O, {
              ...n,
              joinArrays: !1,
              ns: c
            }), L[F] === O && (L[F] = v[F]);
          }
        v = L;
      }
    } else if (I && typeof R == "string" && Array.isArray(v))
      v = v.join(R), v && (v = this.extendTranslation(v, t, n, r));
    else {
      let M = !1, L = !1;
      const j = n.count !== void 0 && typeof n.count != "string", F = T4.hasDefaultValue(n), O = j ? this.pluralResolver.getSuffix(f, n.count, n) : "", z = n.ordinal && j ? this.pluralResolver.getSuffix(f, n.count, {
        ordinal: !1
      }) : "", H = j && !n.ordinal && n.count === 0 && this.pluralResolver.shouldUseIntlApi(), Q = H && n[`defaultValue${this.options.pluralSeparator}zero`] || n[`defaultValue${O}`] || n[`defaultValue${z}`] || n.defaultValue;
      !this.isValidLookup(v) && F && (M = !0, v = Q), this.isValidLookup(v) || (L = !0, v = s);
      const ee = (n.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && L ? void 0 : v, ie = F && Q !== v && this.options.updateMissing;
      if (L || M || ie) {
        if (this.logger.log(ie ? "updateKey" : "missingKey", f, u, s, ie ? Q : v), o) {
          const K = this.resolve(s, {
            ...n,
            keySeparator: !1
          });
          K && K.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let X = [];
        const Z = this.languageUtils.getFallbackCodes(this.options.fallbackLng, n.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && Z && Z[0])
          for (let K = 0; K < Z.length; K++)
            X.push(Z[K]);
        else this.options.saveMissingTo === "all" ? X = this.languageUtils.toResolveHierarchy(n.lng || this.language) : X.push(n.lng || this.language);
        const J = (K, oe, be) => {
          const ce = F && be !== v ? be : ee;
          this.options.missingKeyHandler ? this.options.missingKeyHandler(K, u, oe, ce, ie, n) : this.backendConnector && this.backendConnector.saveMissing && this.backendConnector.saveMissing(K, u, oe, ce, ie, n), this.emit("missingKey", K, u, oe, v);
        };
        this.options.saveMissing && (this.options.saveMissingPlurals && j ? X.forEach((K) => {
          const oe = this.pluralResolver.getSuffixes(K, n);
          H && n[`defaultValue${this.options.pluralSeparator}zero`] && oe.indexOf(`${this.options.pluralSeparator}zero`) < 0 && oe.push(`${this.options.pluralSeparator}zero`), oe.forEach((be) => {
            J([K], s + be, n[`defaultValue${be}`] || Q);
          });
        }) : J(X, s, Q));
      }
      v = this.extendTranslation(v, t, n, y, r), L && v === s && this.options.appendNamespaceToMissingKey && (v = `${u}:${s}`), (L || M) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? v = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${u}:${s}` : s, M ? v : void 0) : v = this.options.parseMissingKeyHandler(v));
    }
    return i ? (y.res = v, y.usedParams = this.getUsedParamsDetails(n), y) : v;
  }
  extendTranslation(t, n, r, i, o) {
    var s = this;
    if (this.i18nFormat && this.i18nFormat.parse)
      t = this.i18nFormat.parse(t, {
        ...this.options.interpolation.defaultVariables,
        ...r
      }, r.lng || this.language || i.usedLng, i.usedNS, i.usedKey, {
        resolved: i
      });
    else if (!r.skipInterpolation) {
      r.interpolation && this.interpolator.init({
        ...r,
        interpolation: {
          ...this.options.interpolation,
          ...r.interpolation
        }
      });
      const f = typeof t == "string" && (r && r.interpolation && r.interpolation.skipOnVariables !== void 0 ? r.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let p;
      if (f) {
        const v = t.match(this.interpolator.nestingRegexp);
        p = v && v.length;
      }
      let y = r.replace && typeof r.replace != "string" ? r.replace : r;
      if (this.options.interpolation.defaultVariables && (y = {
        ...this.options.interpolation.defaultVariables,
        ...y
      }), t = this.interpolator.interpolate(t, y, r.lng || this.language || i.usedLng, r), f) {
        const v = t.match(this.interpolator.nestingRegexp), w = v && v.length;
        p < w && (r.nest = !1);
      }
      !r.lng && this.options.compatibilityAPI !== "v1" && i && i.res && (r.lng = this.language || i.usedLng), r.nest !== !1 && (t = this.interpolator.nest(t, function() {
        for (var v = arguments.length, w = new Array(v), C = 0; C < v; C++)
          w[C] = arguments[C];
        return o && o[0] === w[0] && !r.context ? (s.logger.warn(`It seems you are nesting recursively key: ${w[0]} in key: ${n[0]}`), null) : s.translate(...w, n);
      }, r)), r.interpolation && this.interpolator.reset();
    }
    const c = r.postProcess || this.options.postProcess, u = typeof c == "string" ? [c] : c;
    return t != null && u && u.length && r.applyPostProcessor !== !1 && (t = pV.handle(u, t, n, this.options && this.options.postProcessPassResolved ? {
      i18nResolved: {
        ...i,
        usedParams: this.getUsedParamsDetails(r)
      },
      ...r
    } : r, this)), t;
  }
  resolve(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r, i, o, s, c;
    return typeof t == "string" && (t = [t]), t.forEach((u) => {
      if (this.isValidLookup(r)) return;
      const f = this.extractFromKey(u, n), p = f.key;
      i = p;
      let y = f.namespaces;
      this.options.fallbackNS && (y = y.concat(this.options.fallbackNS));
      const v = n.count !== void 0 && typeof n.count != "string", w = v && !n.ordinal && n.count === 0 && this.pluralResolver.shouldUseIntlApi(), C = n.context !== void 0 && (typeof n.context == "string" || typeof n.context == "number") && n.context !== "", x = n.lngs ? n.lngs : this.languageUtils.toResolveHierarchy(n.lng || this.language, n.fallbackLng);
      y.forEach((A) => {
        this.isValidLookup(r) || (c = A, !lj[`${x[0]}-${A}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(c) && (lj[`${x[0]}-${A}`] = !0, this.logger.warn(`key "${i}" for languages "${x.join(", ")}" won't get resolved as namespace "${c}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), x.forEach((R) => {
          if (this.isValidLookup(r)) return;
          s = R;
          const I = [p];
          if (this.i18nFormat && this.i18nFormat.addLookupKeys)
            this.i18nFormat.addLookupKeys(I, p, R, A, n);
          else {
            let M;
            v && (M = this.pluralResolver.getSuffix(R, n.count, n));
            const L = `${this.options.pluralSeparator}zero`, j = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (v && (I.push(p + M), n.ordinal && M.indexOf(j) === 0 && I.push(p + M.replace(j, this.options.pluralSeparator)), w && I.push(p + L)), C) {
              const F = `${p}${this.options.contextSeparator}${n.context}`;
              I.push(F), v && (I.push(F + M), n.ordinal && M.indexOf(j) === 0 && I.push(F + M.replace(j, this.options.pluralSeparator)), w && I.push(F + L));
            }
          }
          let D;
          for (; D = I.pop(); )
            this.isValidLookup(r) || (o = D, r = this.getResource(R, A, D, n));
        }));
      });
    }), {
      res: r,
      usedKey: i,
      exactUsedKey: o,
      usedLng: s,
      usedNS: c
    };
  }
  isValidLookup(t) {
    return t !== void 0 && !(!this.options.returnNull && t === null) && !(!this.options.returnEmptyString && t === "");
  }
  getResource(t, n, r) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(t, n, r, i) : this.resourceStore.getResource(t, n, r, i);
  }
  getUsedParamsDetails() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const n = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"], r = t.replace && typeof t.replace != "string";
    let i = r ? t.replace : t;
    if (r && typeof t.count < "u" && (i.count = t.count), this.options.interpolation.defaultVariables && (i = {
      ...this.options.interpolation.defaultVariables,
      ...i
    }), !r) {
      i = {
        ...i
      };
      for (const o of n)
        delete i[o];
    }
    return i;
  }
  static hasDefaultValue(t) {
    const n = "defaultValue";
    for (const r in t)
      if (Object.prototype.hasOwnProperty.call(t, r) && n === r.substring(0, n.length) && t[r] !== void 0)
        return !0;
    return !1;
  }
}
const RR = (e) => e.charAt(0).toUpperCase() + e.slice(1);
class cj {
  constructor(t) {
    this.options = t, this.supportedLngs = this.options.supportedLngs || !1, this.logger = Nu.create("languageUtils");
  }
  getScriptPartFromCode(t) {
    if (t = A4(t), !t || t.indexOf("-") < 0) return null;
    const n = t.split("-");
    return n.length === 2 || (n.pop(), n[n.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(n.join("-"));
  }
  getLanguagePartFromCode(t) {
    if (t = A4(t), !t || t.indexOf("-") < 0) return t;
    const n = t.split("-");
    return this.formatLanguageCode(n[0]);
  }
  formatLanguageCode(t) {
    if (typeof t == "string" && t.indexOf("-") > -1) {
      const n = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
      let r = t.split("-");
      return this.options.lowerCaseLng ? r = r.map((i) => i.toLowerCase()) : r.length === 2 ? (r[0] = r[0].toLowerCase(), r[1] = r[1].toUpperCase(), n.indexOf(r[1].toLowerCase()) > -1 && (r[1] = RR(r[1].toLowerCase()))) : r.length === 3 && (r[0] = r[0].toLowerCase(), r[1].length === 2 && (r[1] = r[1].toUpperCase()), r[0] !== "sgn" && r[2].length === 2 && (r[2] = r[2].toUpperCase()), n.indexOf(r[1].toLowerCase()) > -1 && (r[1] = RR(r[1].toLowerCase())), n.indexOf(r[2].toLowerCase()) > -1 && (r[2] = RR(r[2].toLowerCase()))), r.join("-");
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? t.toLowerCase() : t;
  }
  isSupportedCode(t) {
    return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (t = this.getLanguagePartFromCode(t)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(t) > -1;
  }
  getBestMatchFromCodes(t) {
    if (!t) return null;
    let n;
    return t.forEach((r) => {
      if (n) return;
      const i = this.formatLanguageCode(r);
      (!this.options.supportedLngs || this.isSupportedCode(i)) && (n = i);
    }), !n && this.options.supportedLngs && t.forEach((r) => {
      if (n) return;
      const i = this.getLanguagePartFromCode(r);
      if (this.isSupportedCode(i)) return n = i;
      n = this.options.supportedLngs.find((o) => {
        if (o === i) return o;
        if (!(o.indexOf("-") < 0 && i.indexOf("-") < 0) && (o.indexOf("-") > 0 && i.indexOf("-") < 0 && o.substring(0, o.indexOf("-")) === i || o.indexOf(i) === 0 && i.length > 1))
          return o;
      });
    }), n || (n = this.getFallbackCodes(this.options.fallbackLng)[0]), n;
  }
  getFallbackCodes(t, n) {
    if (!t) return [];
    if (typeof t == "function" && (t = t(n)), typeof t == "string" && (t = [t]), Array.isArray(t)) return t;
    if (!n) return t.default || [];
    let r = t[n];
    return r || (r = t[this.getScriptPartFromCode(n)]), r || (r = t[this.formatLanguageCode(n)]), r || (r = t[this.getLanguagePartFromCode(n)]), r || (r = t.default), r || [];
  }
  toResolveHierarchy(t, n) {
    const r = this.getFallbackCodes(n || this.options.fallbackLng || [], t), i = [], o = (s) => {
      s && (this.isSupportedCode(s) ? i.push(s) : this.logger.warn(`rejecting language code not found in supportedLngs: ${s}`));
    };
    return typeof t == "string" && (t.indexOf("-") > -1 || t.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && o(this.formatLanguageCode(t)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && o(this.getScriptPartFromCode(t)), this.options.load !== "currentOnly" && o(this.getLanguagePartFromCode(t))) : typeof t == "string" && o(this.formatLanguageCode(t)), r.forEach((s) => {
      i.indexOf(s) < 0 && o(this.formatLanguageCode(s));
    }), i;
  }
}
let use = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}], dse = {
  1: (e) => +(e > 1),
  2: (e) => +(e != 1),
  3: (e) => 0,
  4: (e) => e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2,
  5: (e) => e == 0 ? 0 : e == 1 ? 1 : e == 2 ? 2 : e % 100 >= 3 && e % 100 <= 10 ? 3 : e % 100 >= 11 ? 4 : 5,
  6: (e) => e == 1 ? 0 : e >= 2 && e <= 4 ? 1 : 2,
  7: (e) => e == 1 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2,
  8: (e) => e == 1 ? 0 : e == 2 ? 1 : e != 8 && e != 11 ? 2 : 3,
  9: (e) => +(e >= 2),
  10: (e) => e == 1 ? 0 : e == 2 ? 1 : e < 7 ? 2 : e < 11 ? 3 : 4,
  11: (e) => e == 1 || e == 11 ? 0 : e == 2 || e == 12 ? 1 : e > 2 && e < 20 ? 2 : 3,
  12: (e) => +(e % 10 != 1 || e % 100 == 11),
  13: (e) => +(e !== 0),
  14: (e) => e == 1 ? 0 : e == 2 ? 1 : e == 3 ? 2 : 3,
  15: (e) => e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2,
  16: (e) => e % 10 == 1 && e % 100 != 11 ? 0 : e !== 0 ? 1 : 2,
  17: (e) => e == 1 || e % 10 == 1 && e % 100 != 11 ? 0 : 1,
  18: (e) => e == 0 ? 0 : e == 1 ? 1 : 2,
  19: (e) => e == 1 ? 0 : e == 0 || e % 100 > 1 && e % 100 < 11 ? 1 : e % 100 > 10 && e % 100 < 20 ? 2 : 3,
  20: (e) => e == 1 ? 0 : e == 0 || e % 100 > 0 && e % 100 < 20 ? 1 : 2,
  21: (e) => e % 100 == 1 ? 1 : e % 100 == 2 ? 2 : e % 100 == 3 || e % 100 == 4 ? 3 : 0,
  22: (e) => e == 1 ? 0 : e == 2 ? 1 : (e < 0 || e > 10) && e % 10 == 0 ? 2 : 3
};
const fse = ["v1", "v2", "v3"], hse = ["v4"], uj = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
}, pse = () => {
  const e = {};
  return use.forEach((t) => {
    t.lngs.forEach((n) => {
      e[n] = {
        numbers: t.nr,
        plurals: dse[t.fc]
      };
    });
  }), e;
};
class mse {
  constructor(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = t, this.options = n, this.logger = Nu.create("pluralResolver"), (!this.options.compatibilityJSON || hse.includes(this.options.compatibilityJSON)) && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = pse(), this.pluralRulesCache = {};
  }
  addRule(t, n) {
    this.rules[t] = n;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.shouldUseIntlApi())
      try {
        const r = A4(t === "dev" ? "en" : t), i = n.ordinal ? "ordinal" : "cardinal", o = JSON.stringify({
          cleanedCode: r,
          type: i
        });
        if (o in this.pluralRulesCache)
          return this.pluralRulesCache[o];
        const s = new Intl.PluralRules(r, {
          type: i
        });
        return this.pluralRulesCache[o] = s, s;
      } catch {
        return;
      }
    return this.rules[t] || this.rules[this.languageUtils.getLanguagePartFromCode(t)];
  }
  needsPlural(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const r = this.getRule(t, n);
    return this.shouldUseIntlApi() ? r && r.resolvedOptions().pluralCategories.length > 1 : r && r.numbers.length > 1;
  }
  getPluralFormsOfKey(t, n) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(t, r).map((i) => `${n}${i}`);
  }
  getSuffixes(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const r = this.getRule(t, n);
    return r ? this.shouldUseIntlApi() ? r.resolvedOptions().pluralCategories.sort((i, o) => uj[i] - uj[o]).map((i) => `${this.options.prepend}${n.ordinal ? `ordinal${this.options.prepend}` : ""}${i}`) : r.numbers.map((i) => this.getSuffix(t, i, n)) : [];
  }
  getSuffix(t, n) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const i = this.getRule(t, r);
    return i ? this.shouldUseIntlApi() ? `${this.options.prepend}${r.ordinal ? `ordinal${this.options.prepend}` : ""}${i.select(n)}` : this.getSuffixRetroCompatible(i, n) : (this.logger.warn(`no plural rule found for: ${t}`), "");
  }
  getSuffixRetroCompatible(t, n) {
    const r = t.noAbs ? t.plurals(n) : t.plurals(Math.abs(n));
    let i = t.numbers[r];
    this.options.simplifyPluralSuffix && t.numbers.length === 2 && t.numbers[0] === 1 && (i === 2 ? i = "plural" : i === 1 && (i = ""));
    const o = () => this.options.prepend && i.toString() ? this.options.prepend + i.toString() : i.toString();
    return this.options.compatibilityJSON === "v1" ? i === 1 ? "" : typeof i == "number" ? `_plural_${i.toString()}` : o() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && t.numbers.length === 2 && t.numbers[0] === 1 ? o() : this.options.prepend && r.toString() ? this.options.prepend + r.toString() : r.toString();
  }
  shouldUseIntlApi() {
    return !fse.includes(this.options.compatibilityJSON);
  }
}
const dj = function(e, t, n) {
  let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".", i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, o = rse(e, t, n);
  return !o && i && typeof n == "string" && (o = $I(e, n, r), o === void 0 && (o = $I(t, n, r))), o;
}, OR = (e) => e.replace(/\$/g, "$$$$");
class yse {
  constructor() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = Nu.create("interpolator"), this.options = t, this.format = t.interpolation && t.interpolation.format || ((n) => n), this.init(t);
  }
  init() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    t.interpolation || (t.interpolation = {
      escapeValue: !0
    });
    const {
      escape: n,
      escapeValue: r,
      useRawValueToEscape: i,
      prefix: o,
      prefixEscaped: s,
      suffix: c,
      suffixEscaped: u,
      formatSeparator: f,
      unescapeSuffix: p,
      unescapePrefix: y,
      nestingPrefix: v,
      nestingPrefixEscaped: w,
      nestingSuffix: C,
      nestingSuffixEscaped: x,
      nestingOptionsSeparator: A,
      maxReplaces: R,
      alwaysFormat: I
    } = t.interpolation;
    this.escape = n !== void 0 ? n : ose, this.escapeValue = r !== void 0 ? r : !0, this.useRawValueToEscape = i !== void 0 ? i : !1, this.prefix = o ? ng(o) : s || "{{", this.suffix = c ? ng(c) : u || "}}", this.formatSeparator = f || ",", this.unescapePrefix = p ? "" : y || "-", this.unescapeSuffix = this.unescapePrefix ? "" : p || "", this.nestingPrefix = v ? ng(v) : w || ng("$t("), this.nestingSuffix = C ? ng(C) : x || ng(")"), this.nestingOptionsSeparator = A || ",", this.maxReplaces = R || 1e3, this.alwaysFormat = I !== void 0 ? I : !1, this.resetRegExp();
  }
  reset() {
    this.options && this.init(this.options);
  }
  resetRegExp() {
    const t = (n, r) => n && n.source === r ? (n.lastIndex = 0, n) : new RegExp(r, "g");
    this.regexp = t(this.regexp, `${this.prefix}(.+?)${this.suffix}`), this.regexpUnescape = t(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`), this.nestingRegexp = t(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
  }
  interpolate(t, n, r, i) {
    let o, s, c;
    const u = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {}, f = (w) => {
      if (w.indexOf(this.formatSeparator) < 0) {
        const R = dj(n, u, w, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(R, void 0, r, {
          ...i,
          ...n,
          interpolationkey: w
        }) : R;
      }
      const C = w.split(this.formatSeparator), x = C.shift().trim(), A = C.join(this.formatSeparator).trim();
      return this.format(dj(n, u, x, this.options.keySeparator, this.options.ignoreJSONStructure), A, r, {
        ...i,
        ...n,
        interpolationkey: x
      });
    };
    this.resetRegExp();
    const p = i && i.missingInterpolationHandler || this.options.missingInterpolationHandler, y = i && i.interpolation && i.interpolation.skipOnVariables !== void 0 ? i.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    return [{
      regex: this.regexpUnescape,
      safeValue: (w) => OR(w)
    }, {
      regex: this.regexp,
      safeValue: (w) => this.escapeValue ? OR(this.escape(w)) : OR(w)
    }].forEach((w) => {
      for (c = 0; o = w.regex.exec(t); ) {
        const C = o[1].trim();
        if (s = f(C), s === void 0)
          if (typeof p == "function") {
            const A = p(t, o, i);
            s = typeof A == "string" ? A : "";
          } else if (i && Object.prototype.hasOwnProperty.call(i, C))
            s = "";
          else if (y) {
            s = o[0];
            continue;
          } else
            this.logger.warn(`missed to pass in variable ${C} for interpolating ${t}`), s = "";
        else typeof s != "string" && !this.useRawValueToEscape && (s = rj(s));
        const x = w.safeValue(s);
        if (t = t.replace(o[0], x), y ? (w.regex.lastIndex += s.length, w.regex.lastIndex -= o[0].length) : w.regex.lastIndex = 0, c++, c >= this.maxReplaces)
          break;
      }
    }), t;
  }
  nest(t, n) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i, o, s;
    const c = (u, f) => {
      const p = this.nestingOptionsSeparator;
      if (u.indexOf(p) < 0) return u;
      const y = u.split(new RegExp(`${p}[ ]*{`));
      let v = `{${y[1]}`;
      u = y[0], v = this.interpolate(v, s);
      const w = v.match(/'/g), C = v.match(/"/g);
      (w && w.length % 2 === 0 && !C || C.length % 2 !== 0) && (v = v.replace(/'/g, '"'));
      try {
        s = JSON.parse(v), f && (s = {
          ...f,
          ...s
        });
      } catch (x) {
        return this.logger.warn(`failed parsing options string in nesting for key ${u}`, x), `${u}${p}${v}`;
      }
      return s.defaultValue && s.defaultValue.indexOf(this.prefix) > -1 && delete s.defaultValue, u;
    };
    for (; i = this.nestingRegexp.exec(t); ) {
      let u = [];
      s = {
        ...r
      }, s = s.replace && typeof s.replace != "string" ? s.replace : s, s.applyPostProcessor = !1, delete s.defaultValue;
      let f = !1;
      if (i[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(i[1])) {
        const p = i[1].split(this.formatSeparator).map((y) => y.trim());
        i[1] = p.shift(), u = p, f = !0;
      }
      if (o = n(c.call(this, i[1].trim(), s), s), o && i[0] === t && typeof o != "string") return o;
      typeof o != "string" && (o = rj(o)), o || (this.logger.warn(`missed to resolve ${i[1]} for nesting ${t}`), o = ""), f && (o = u.reduce((p, y) => this.format(p, y, r.lng, {
        ...r,
        interpolationkey: i[1].trim()
      }), o.trim())), t = t.replace(i[0], o), this.regexp.lastIndex = 0;
    }
    return t;
  }
}
const vse = (e) => {
  let t = e.toLowerCase().trim();
  const n = {};
  if (e.indexOf("(") > -1) {
    const r = e.split("(");
    t = r[0].toLowerCase().trim();
    const i = r[1].substring(0, r[1].length - 1);
    t === "currency" && i.indexOf(":") < 0 ? n.currency || (n.currency = i.trim()) : t === "relativetime" && i.indexOf(":") < 0 ? n.range || (n.range = i.trim()) : i.split(";").forEach((s) => {
      if (s) {
        const [c, ...u] = s.split(":"), f = u.join(":").trim().replace(/^'+|'+$/g, ""), p = c.trim();
        n[p] || (n[p] = f), f === "false" && (n[p] = !1), f === "true" && (n[p] = !0), isNaN(f) || (n[p] = parseInt(f, 10));
      }
    });
  }
  return {
    formatName: t,
    formatOptions: n
  };
}, rg = (e) => {
  const t = {};
  return (n, r, i) => {
    let o = i;
    i && i.interpolationkey && i.formatParams && i.formatParams[i.interpolationkey] && i[i.interpolationkey] && (o = {
      ...o,
      [i.interpolationkey]: void 0
    });
    const s = r + JSON.stringify(o);
    let c = t[s];
    return c || (c = e(A4(r), i), t[s] = c), c(n);
  };
};
class gse {
  constructor() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = Nu.create("formatter"), this.options = t, this.formats = {
      number: rg((n, r) => {
        const i = new Intl.NumberFormat(n, {
          ...r
        });
        return (o) => i.format(o);
      }),
      currency: rg((n, r) => {
        const i = new Intl.NumberFormat(n, {
          ...r,
          style: "currency"
        });
        return (o) => i.format(o);
      }),
      datetime: rg((n, r) => {
        const i = new Intl.DateTimeFormat(n, {
          ...r
        });
        return (o) => i.format(o);
      }),
      relativetime: rg((n, r) => {
        const i = new Intl.RelativeTimeFormat(n, {
          ...r
        });
        return (o) => i.format(o, r.range || "day");
      }),
      list: rg((n, r) => {
        const i = new Intl.ListFormat(n, {
          ...r
        });
        return (o) => i.format(o);
      })
    }, this.init(t);
  }
  init(t) {
    const r = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    }).interpolation;
    this.formatSeparator = r.formatSeparator ? r.formatSeparator : r.formatSeparator || ",";
  }
  add(t, n) {
    this.formats[t.toLowerCase().trim()] = n;
  }
  addCached(t, n) {
    this.formats[t.toLowerCase().trim()] = rg(n);
  }
  format(t, n, r) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const o = n.split(this.formatSeparator);
    if (o.length > 1 && o[0].indexOf("(") > 1 && o[0].indexOf(")") < 0 && o.find((c) => c.indexOf(")") > -1)) {
      const c = o.findIndex((u) => u.indexOf(")") > -1);
      o[0] = [o[0], ...o.splice(1, c)].join(this.formatSeparator);
    }
    return o.reduce((c, u) => {
      const {
        formatName: f,
        formatOptions: p
      } = vse(u);
      if (this.formats[f]) {
        let y = c;
        try {
          const v = i && i.formatParams && i.formatParams[i.interpolationkey] || {}, w = v.locale || v.lng || i.locale || i.lng || r;
          y = this.formats[f](c, w, {
            ...p,
            ...i,
            ...v
          });
        } catch (v) {
          this.logger.warn(v);
        }
        return y;
      } else
        this.logger.warn(`there was no format function for ${f}`);
      return c;
    }, t);
  }
}
const bse = (e, t) => {
  e.pending[t] !== void 0 && (delete e.pending[t], e.pendingCount--);
};
class wse extends y8 {
  constructor(t, n, r) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super(), this.backend = t, this.store = n, this.services = r, this.languageUtils = r.languageUtils, this.options = i, this.logger = Nu.create("backendConnector"), this.waitingReads = [], this.maxParallelReads = i.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = i.maxRetries >= 0 ? i.maxRetries : 5, this.retryTimeout = i.retryTimeout >= 1 ? i.retryTimeout : 350, this.state = {}, this.queue = [], this.backend && this.backend.init && this.backend.init(r, i.backend, i);
  }
  queueLoad(t, n, r, i) {
    const o = {}, s = {}, c = {}, u = {};
    return t.forEach((f) => {
      let p = !0;
      n.forEach((y) => {
        const v = `${f}|${y}`;
        !r.reload && this.store.hasResourceBundle(f, y) ? this.state[v] = 2 : this.state[v] < 0 || (this.state[v] === 1 ? s[v] === void 0 && (s[v] = !0) : (this.state[v] = 1, p = !1, s[v] === void 0 && (s[v] = !0), o[v] === void 0 && (o[v] = !0), u[y] === void 0 && (u[y] = !0)));
      }), p || (c[f] = !0);
    }), (Object.keys(o).length || Object.keys(s).length) && this.queue.push({
      pending: s,
      pendingCount: Object.keys(s).length,
      loaded: {},
      errors: [],
      callback: i
    }), {
      toLoad: Object.keys(o),
      pending: Object.keys(s),
      toLoadLanguages: Object.keys(c),
      toLoadNamespaces: Object.keys(u)
    };
  }
  loaded(t, n, r) {
    const i = t.split("|"), o = i[0], s = i[1];
    n && this.emit("failedLoading", o, s, n), !n && r && this.store.addResourceBundle(o, s, r, void 0, void 0, {
      skipCopy: !0
    }), this.state[t] = n ? -1 : 2, n && r && (this.state[t] = 0);
    const c = {};
    this.queue.forEach((u) => {
      nse(u.loaded, [o], s), bse(u, t), n && u.errors.push(n), u.pendingCount === 0 && !u.done && (Object.keys(u.loaded).forEach((f) => {
        c[f] || (c[f] = {});
        const p = u.loaded[f];
        p.length && p.forEach((y) => {
          c[f][y] === void 0 && (c[f][y] = !0);
        });
      }), u.done = !0, u.errors.length ? u.callback(u.errors) : u.callback());
    }), this.emit("loaded", c), this.queue = this.queue.filter((u) => !u.done);
  }
  read(t, n, r) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout, s = arguments.length > 5 ? arguments[5] : void 0;
    if (!t.length) return s(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng: t,
        ns: n,
        fcName: r,
        tried: i,
        wait: o,
        callback: s
      });
      return;
    }
    this.readingCalls++;
    const c = (f, p) => {
      if (this.readingCalls--, this.waitingReads.length > 0) {
        const y = this.waitingReads.shift();
        this.read(y.lng, y.ns, y.fcName, y.tried, y.wait, y.callback);
      }
      if (f && p && i < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, t, n, r, i + 1, o * 2, s);
        }, o);
        return;
      }
      s(f, p);
    }, u = this.backend[r].bind(this.backend);
    if (u.length === 2) {
      try {
        const f = u(t, n);
        f && typeof f.then == "function" ? f.then((p) => c(null, p)).catch(c) : c(null, f);
      } catch (f) {
        c(f);
      }
      return;
    }
    return u(t, n, c);
  }
  prepareLoading(t, n) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend)
      return this.logger.warn("No backend was added via i18next.use. Will not load resources."), i && i();
    typeof t == "string" && (t = this.languageUtils.toResolveHierarchy(t)), typeof n == "string" && (n = [n]);
    const o = this.queueLoad(t, n, r, i);
    if (!o.toLoad.length)
      return o.pending.length || i(), null;
    o.toLoad.forEach((s) => {
      this.loadOne(s);
    });
  }
  load(t, n, r) {
    this.prepareLoading(t, n, {}, r);
  }
  reload(t, n, r) {
    this.prepareLoading(t, n, {
      reload: !0
    }, r);
  }
  loadOne(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const r = t.split("|"), i = r[0], o = r[1];
    this.read(i, o, "read", void 0, void 0, (s, c) => {
      s && this.logger.warn(`${n}loading namespace ${o} for language ${i} failed`, s), !s && c && this.logger.log(`${n}loaded namespace ${o} for language ${i}`, c), this.loaded(t, s, c);
    });
  }
  saveMissing(t, n, r, i, o) {
    let s = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {}, c = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(n)) {
      this.logger.warn(`did not save key "${r}" as the namespace "${n}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (!(r == null || r === "")) {
      if (this.backend && this.backend.create) {
        const u = {
          ...s,
          isUpdate: o
        }, f = this.backend.create.bind(this.backend);
        if (f.length < 6)
          try {
            let p;
            f.length === 5 ? p = f(t, n, r, i, u) : p = f(t, n, r, i), p && typeof p.then == "function" ? p.then((y) => c(null, y)).catch(c) : c(null, p);
          } catch (p) {
            c(p);
          }
        else
          f(t, n, r, i, c, u);
      }
      !t || !t[0] || this.store.addResource(t[0], n, r, i);
    }
  }
}
const fj = () => ({
  debug: !1,
  initImmediate: !0,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: !1,
  supportedLngs: !1,
  nonExplicitSupportedLngs: !1,
  load: "all",
  preload: !1,
  simplifyPluralSuffix: !0,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: !1,
  saveMissing: !1,
  updateMissing: !1,
  saveMissingTo: "fallback",
  saveMissingPlurals: !0,
  missingKeyHandler: !1,
  missingInterpolationHandler: !1,
  postProcess: !1,
  postProcessPassResolved: !1,
  returnNull: !1,
  returnEmptyString: !0,
  returnObjects: !1,
  joinArrays: !1,
  returnedObjectHandler: !1,
  parseMissingKeyHandler: !1,
  appendNamespaceToMissingKey: !1,
  appendNamespaceToCIMode: !1,
  overloadTranslationOptionHandler: (e) => {
    let t = {};
    if (typeof e[1] == "object" && (t = e[1]), typeof e[1] == "string" && (t.defaultValue = e[1]), typeof e[2] == "string" && (t.tDescription = e[2]), typeof e[2] == "object" || typeof e[3] == "object") {
      const n = e[3] || e[2];
      Object.keys(n).forEach((r) => {
        t[r] = n[r];
      });
    }
    return t;
  },
  interpolation: {
    escapeValue: !0,
    format: (e) => e,
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: !0
  }
}), hj = (e) => (typeof e.ns == "string" && (e.ns = [e.ns]), typeof e.fallbackLng == "string" && (e.fallbackLng = [e.fallbackLng]), typeof e.fallbackNS == "string" && (e.fallbackNS = [e.fallbackNS]), e.supportedLngs && e.supportedLngs.indexOf("cimode") < 0 && (e.supportedLngs = e.supportedLngs.concat(["cimode"])), e), pk = () => {
}, Cse = (e) => {
  Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((n) => {
    typeof e[n] == "function" && (e[n] = e[n].bind(e));
  });
};
let mV = class HI extends y8 {
  constructor() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 ? arguments[1] : void 0;
    if (super(), this.options = hj(t), this.services = {}, this.logger = Nu, this.modules = {
      external: []
    }, Cse(this), n && !this.isInitialized && !t.isClone) {
      if (!this.options.initImmediate)
        return this.init(t, n), this;
      setTimeout(() => {
        this.init(t, n);
      }, 0);
    }
  }
  init() {
    var t = this;
    let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = arguments.length > 1 ? arguments[1] : void 0;
    this.isInitializing = !0, typeof n == "function" && (r = n, n = {}), !n.defaultNS && n.defaultNS !== !1 && n.ns && (typeof n.ns == "string" ? n.defaultNS = n.ns : n.ns.indexOf("translation") < 0 && (n.defaultNS = n.ns[0]));
    const i = fj();
    this.options = {
      ...i,
      ...this.options,
      ...hj(n)
    }, this.options.compatibilityAPI !== "v1" && (this.options.interpolation = {
      ...i.interpolation,
      ...this.options.interpolation
    }), n.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = n.keySeparator), n.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = n.nsSeparator);
    const o = (p) => p ? typeof p == "function" ? new p() : p : null;
    if (!this.options.isClone) {
      this.modules.logger ? Nu.init(o(this.modules.logger), this.options) : Nu.init(null, this.options);
      let p;
      this.modules.formatter ? p = this.modules.formatter : typeof Intl < "u" && (p = gse);
      const y = new cj(this.options);
      this.store = new sj(this.options.resources, this.options);
      const v = this.services;
      v.logger = Nu, v.resourceStore = this.store, v.languageUtils = y, v.pluralResolver = new mse(y, {
        prepend: this.options.pluralSeparator,
        compatibilityJSON: this.options.compatibilityJSON,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      }), p && (!this.options.interpolation.format || this.options.interpolation.format === i.interpolation.format) && (v.formatter = o(p), v.formatter.init(v, this.options), this.options.interpolation.format = v.formatter.format.bind(v.formatter)), v.interpolator = new yse(this.options), v.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      }, v.backendConnector = new wse(o(this.modules.backend), v.resourceStore, v, this.options), v.backendConnector.on("*", function(w) {
        for (var C = arguments.length, x = new Array(C > 1 ? C - 1 : 0), A = 1; A < C; A++)
          x[A - 1] = arguments[A];
        t.emit(w, ...x);
      }), this.modules.languageDetector && (v.languageDetector = o(this.modules.languageDetector), v.languageDetector.init && v.languageDetector.init(v, this.options.detection, this.options)), this.modules.i18nFormat && (v.i18nFormat = o(this.modules.i18nFormat), v.i18nFormat.init && v.i18nFormat.init(this)), this.translator = new T4(this.services, this.options), this.translator.on("*", function(w) {
        for (var C = arguments.length, x = new Array(C > 1 ? C - 1 : 0), A = 1; A < C; A++)
          x[A - 1] = arguments[A];
        t.emit(w, ...x);
      }), this.modules.external.forEach((w) => {
        w.init && w.init(this);
      });
    }
    if (this.format = this.options.interpolation.format, r || (r = pk), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const p = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      p.length > 0 && p[0] !== "dev" && (this.options.lng = p[0]);
    }
    !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"), ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach((p) => {
      this[p] = function() {
        return t.store[p](...arguments);
      };
    }), ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach((p) => {
      this[p] = function() {
        return t.store[p](...arguments), t;
      };
    });
    const u = t1(), f = () => {
      const p = (y, v) => {
        this.isInitializing = !1, this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"), this.isInitialized = !0, this.options.isClone || this.logger.log("initialized", this.options), this.emit("initialized", this.options), u.resolve(v), r(y, v);
      };
      if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized) return p(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, p);
    };
    return this.options.resources || !this.options.initImmediate ? f() : setTimeout(f, 0), u;
  }
  loadResources(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pk;
    const i = typeof t == "string" ? t : this.language;
    if (typeof t == "function" && (r = t), !this.options.resources || this.options.partialBundledLanguages) {
      if (i && i.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return r();
      const o = [], s = (c) => {
        if (!c || c === "cimode") return;
        this.services.languageUtils.toResolveHierarchy(c).forEach((f) => {
          f !== "cimode" && o.indexOf(f) < 0 && o.push(f);
        });
      };
      i ? s(i) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach((u) => s(u)), this.options.preload && this.options.preload.forEach((c) => s(c)), this.services.backendConnector.load(o, this.options.ns, (c) => {
        !c && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language), r(c);
      });
    } else
      r(null);
  }
  reloadResources(t, n, r) {
    const i = t1();
    return typeof t == "function" && (r = t, t = void 0), typeof n == "function" && (r = n, n = void 0), t || (t = this.languages), n || (n = this.options.ns), r || (r = pk), this.services.backendConnector.reload(t, n, (o) => {
      i.resolve(), r(o);
    }), i;
  }
  use(t) {
    if (!t) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!t.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    return t.type === "backend" && (this.modules.backend = t), (t.type === "logger" || t.log && t.warn && t.error) && (this.modules.logger = t), t.type === "languageDetector" && (this.modules.languageDetector = t), t.type === "i18nFormat" && (this.modules.i18nFormat = t), t.type === "postProcessor" && pV.addPostProcessor(t), t.type === "formatter" && (this.modules.formatter = t), t.type === "3rdParty" && this.modules.external.push(t), this;
  }
  setResolvedLanguage(t) {
    if (!(!t || !this.languages) && !(["cimode", "dev"].indexOf(t) > -1))
      for (let n = 0; n < this.languages.length; n++) {
        const r = this.languages[n];
        if (!(["cimode", "dev"].indexOf(r) > -1) && this.store.hasLanguageSomeTranslations(r)) {
          this.resolvedLanguage = r;
          break;
        }
      }
  }
  changeLanguage(t, n) {
    var r = this;
    this.isLanguageChangingTo = t;
    const i = t1();
    this.emit("languageChanging", t);
    const o = (u) => {
      this.language = u, this.languages = this.services.languageUtils.toResolveHierarchy(u), this.resolvedLanguage = void 0, this.setResolvedLanguage(u);
    }, s = (u, f) => {
      f ? (o(f), this.translator.changeLanguage(f), this.isLanguageChangingTo = void 0, this.emit("languageChanged", f), this.logger.log("languageChanged", f)) : this.isLanguageChangingTo = void 0, i.resolve(function() {
        return r.t(...arguments);
      }), n && n(u, function() {
        return r.t(...arguments);
      });
    }, c = (u) => {
      !t && !u && this.services.languageDetector && (u = []);
      const f = typeof u == "string" ? u : this.services.languageUtils.getBestMatchFromCodes(u);
      f && (this.language || o(f), this.translator.language || this.translator.changeLanguage(f), this.services.languageDetector && this.services.languageDetector.cacheUserLanguage && this.services.languageDetector.cacheUserLanguage(f)), this.loadResources(f, (p) => {
        s(p, f);
      });
    };
    return !t && this.services.languageDetector && !this.services.languageDetector.async ? c(this.services.languageDetector.detect()) : !t && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(c) : this.services.languageDetector.detect(c) : c(t), i;
  }
  getFixedT(t, n, r) {
    var i = this;
    const o = function(s, c) {
      let u;
      if (typeof c != "object") {
        for (var f = arguments.length, p = new Array(f > 2 ? f - 2 : 0), y = 2; y < f; y++)
          p[y - 2] = arguments[y];
        u = i.options.overloadTranslationOptionHandler([s, c].concat(p));
      } else
        u = {
          ...c
        };
      u.lng = u.lng || o.lng, u.lngs = u.lngs || o.lngs, u.ns = u.ns || o.ns, u.keyPrefix !== "" && (u.keyPrefix = u.keyPrefix || r || o.keyPrefix);
      const v = i.options.keySeparator || ".";
      let w;
      return u.keyPrefix && Array.isArray(s) ? w = s.map((C) => `${u.keyPrefix}${v}${C}`) : w = u.keyPrefix ? `${u.keyPrefix}${v}${s}` : s, i.t(w, u);
    };
    return typeof t == "string" ? o.lng = t : o.lngs = t, o.ns = n, o.keyPrefix = r, o;
  }
  t() {
    return this.translator && this.translator.translate(...arguments);
  }
  exists() {
    return this.translator && this.translator.exists(...arguments);
  }
  setDefaultNamespace(t) {
    this.options.defaultNS = t;
  }
  hasLoadedNamespace(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized)
      return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
    if (!this.languages || !this.languages.length)
      return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
    const r = n.lng || this.resolvedLanguage || this.languages[0], i = this.options ? this.options.fallbackLng : !1, o = this.languages[this.languages.length - 1];
    if (r.toLowerCase() === "cimode") return !0;
    const s = (c, u) => {
      const f = this.services.backendConnector.state[`${c}|${u}`];
      return f === -1 || f === 0 || f === 2;
    };
    if (n.precheck) {
      const c = n.precheck(this, s);
      if (c !== void 0) return c;
    }
    return !!(this.hasResourceBundle(r, t) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || s(r, t) && (!i || s(o, t)));
  }
  loadNamespaces(t, n) {
    const r = t1();
    return this.options.ns ? (typeof t == "string" && (t = [t]), t.forEach((i) => {
      this.options.ns.indexOf(i) < 0 && this.options.ns.push(i);
    }), this.loadResources((i) => {
      r.resolve(), n && n(i);
    }), r) : (n && n(), Promise.resolve());
  }
  loadLanguages(t, n) {
    const r = t1();
    typeof t == "string" && (t = [t]);
    const i = this.options.preload || [], o = t.filter((s) => i.indexOf(s) < 0 && this.services.languageUtils.isSupportedCode(s));
    return o.length ? (this.options.preload = i.concat(o), this.loadResources((s) => {
      r.resolve(), n && n(s);
    }), r) : (n && n(), Promise.resolve());
  }
  dir(t) {
    if (t || (t = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !t) return "rtl";
    const n = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"], r = this.services && this.services.languageUtils || new cj(fj());
    return n.indexOf(r.getLanguagePartFromCode(t)) > -1 || t.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 ? arguments[1] : void 0;
    return new HI(t, n);
  }
  cloneInstance() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pk;
    const r = t.forkResourceStore;
    r && delete t.forkResourceStore;
    const i = {
      ...this.options,
      ...t,
      isClone: !0
    }, o = new HI(i);
    return (t.debug !== void 0 || t.prefix !== void 0) && (o.logger = o.logger.clone(t)), ["store", "services", "language"].forEach((c) => {
      o[c] = this[c];
    }), o.services = {
      ...this.services
    }, o.services.utils = {
      hasLoadedNamespace: o.hasLoadedNamespace.bind(o)
    }, r && (o.store = new sj(this.store.data, i), o.services.resourceStore = o.store), o.translator = new T4(o.services, i), o.translator.on("*", function(c) {
      for (var u = arguments.length, f = new Array(u > 1 ? u - 1 : 0), p = 1; p < u; p++)
        f[p - 1] = arguments[p];
      o.emit(c, ...f);
    }), o.init(i, n), o.translator.options = i, o.translator.backendConnector.services.utils = {
      hasLoadedNamespace: o.hasLoadedNamespace.bind(o)
    }, o;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
};
const ls = mV.createInstance();
ls.createInstance = mV.createInstance;
const xse = ls.createInstance;
ls.dir;
ls.init;
ls.loadResources;
ls.reloadResources;
ls.use;
ls.changeLanguage;
ls.getFixedT;
ls.t;
ls.exists;
ls.setDefaultNamespace;
ls.hasLoadedNamespace;
ls.loadNamespaces;
ls.loadLanguages;
const {
  slice: Ese,
  forEach: Sse
} = [];
function kse(e) {
  return Sse.call(Ese.call(arguments, 1), (t) => {
    if (t)
      for (const n in t)
        e[n] === void 0 && (e[n] = t[n]);
  }), e;
}
const pj = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/, Ase = (e, t, n) => {
  const r = n || {};
  r.path = r.path || "/";
  const i = encodeURIComponent(t);
  let o = `${e}=${i}`;
  if (r.maxAge > 0) {
    const s = r.maxAge - 0;
    if (Number.isNaN(s)) throw new Error("maxAge should be a Number");
    o += `; Max-Age=${Math.floor(s)}`;
  }
  if (r.domain) {
    if (!pj.test(r.domain))
      throw new TypeError("option domain is invalid");
    o += `; Domain=${r.domain}`;
  }
  if (r.path) {
    if (!pj.test(r.path))
      throw new TypeError("option path is invalid");
    o += `; Path=${r.path}`;
  }
  if (r.expires) {
    if (typeof r.expires.toUTCString != "function")
      throw new TypeError("option expires is invalid");
    o += `; Expires=${r.expires.toUTCString()}`;
  }
  if (r.httpOnly && (o += "; HttpOnly"), r.secure && (o += "; Secure"), r.sameSite)
    switch (typeof r.sameSite == "string" ? r.sameSite.toLowerCase() : r.sameSite) {
      case !0:
        o += "; SameSite=Strict";
        break;
      case "lax":
        o += "; SameSite=Lax";
        break;
      case "strict":
        o += "; SameSite=Strict";
        break;
      case "none":
        o += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  return o;
}, mj = {
  create(e, t, n, r) {
    let i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      path: "/",
      sameSite: "strict"
    };
    n && (i.expires = /* @__PURE__ */ new Date(), i.expires.setTime(i.expires.getTime() + n * 60 * 1e3)), r && (i.domain = r), document.cookie = Ase(e, encodeURIComponent(t), i);
  },
  read(e) {
    const t = `${e}=`, n = document.cookie.split(";");
    for (let r = 0; r < n.length; r++) {
      let i = n[r];
      for (; i.charAt(0) === " "; ) i = i.substring(1, i.length);
      if (i.indexOf(t) === 0) return i.substring(t.length, i.length);
    }
    return null;
  },
  remove(e) {
    this.create(e, "", -1);
  }
};
var Tse = {
  name: "cookie",
  // Deconstruct the options object and extract the lookupCookie property
  lookup(e) {
    let {
      lookupCookie: t
    } = e;
    if (t && typeof document < "u")
      return mj.read(t) || void 0;
  },
  // Deconstruct the options object and extract the lookupCookie, cookieMinutes, cookieDomain, and cookieOptions properties
  cacheUserLanguage(e, t) {
    let {
      lookupCookie: n,
      cookieMinutes: r,
      cookieDomain: i,
      cookieOptions: o
    } = t;
    n && typeof document < "u" && mj.create(n, e, r, i, o);
  }
}, _se = {
  name: "querystring",
  // Deconstruct the options object and extract the lookupQuerystring property
  lookup(e) {
    var r;
    let {
      lookupQuerystring: t
    } = e, n;
    if (typeof window < "u") {
      let {
        search: i
      } = window.location;
      !window.location.search && ((r = window.location.hash) == null ? void 0 : r.indexOf("?")) > -1 && (i = window.location.hash.substring(window.location.hash.indexOf("?")));
      const s = i.substring(1).split("&");
      for (let c = 0; c < s.length; c++) {
        const u = s[c].indexOf("=");
        u > 0 && s[c].substring(0, u) === t && (n = s[c].substring(u + 1));
      }
    }
    return n;
  }
};
let n1 = null;
const yj = () => {
  if (n1 !== null) return n1;
  try {
    n1 = window !== "undefined" && window.localStorage !== null;
    const e = "i18next.translate.boo";
    window.localStorage.setItem(e, "foo"), window.localStorage.removeItem(e);
  } catch {
    n1 = !1;
  }
  return n1;
};
var Rse = {
  name: "localStorage",
  // Deconstruct the options object and extract the lookupLocalStorage property
  lookup(e) {
    let {
      lookupLocalStorage: t
    } = e;
    if (t && yj())
      return window.localStorage.getItem(t) || void 0;
  },
  // Deconstruct the options object and extract the lookupLocalStorage property
  cacheUserLanguage(e, t) {
    let {
      lookupLocalStorage: n
    } = t;
    n && yj() && window.localStorage.setItem(n, e);
  }
};
let r1 = null;
const vj = () => {
  if (r1 !== null) return r1;
  try {
    r1 = window !== "undefined" && window.sessionStorage !== null;
    const e = "i18next.translate.boo";
    window.sessionStorage.setItem(e, "foo"), window.sessionStorage.removeItem(e);
  } catch {
    r1 = !1;
  }
  return r1;
};
var Ose = {
  name: "sessionStorage",
  lookup(e) {
    let {
      lookupSessionStorage: t
    } = e;
    if (t && vj())
      return window.sessionStorage.getItem(t) || void 0;
  },
  cacheUserLanguage(e, t) {
    let {
      lookupSessionStorage: n
    } = t;
    n && vj() && window.sessionStorage.setItem(n, e);
  }
}, Ise = {
  name: "navigator",
  lookup(e) {
    const t = [];
    if (typeof navigator < "u") {
      const {
        languages: n,
        userLanguage: r,
        language: i
      } = navigator;
      if (n)
        for (let o = 0; o < n.length; o++)
          t.push(n[o]);
      r && t.push(r), i && t.push(i);
    }
    return t.length > 0 ? t : void 0;
  }
}, Dse = {
  name: "htmlTag",
  // Deconstruct the options object and extract the htmlTag property
  lookup(e) {
    let {
      htmlTag: t
    } = e, n;
    const r = t || (typeof document < "u" ? document.documentElement : null);
    return r && typeof r.getAttribute == "function" && (n = r.getAttribute("lang")), n;
  }
}, Mse = {
  name: "path",
  // Deconstruct the options object and extract the lookupFromPathIndex property
  lookup(e) {
    var i;
    let {
      lookupFromPathIndex: t
    } = e;
    if (typeof window > "u") return;
    const n = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
    return Array.isArray(n) ? (i = n[typeof t == "number" ? t : 0]) == null ? void 0 : i.replace("/", "") : void 0;
  }
}, Pse = {
  name: "subdomain",
  lookup(e) {
    var i, o;
    let {
      lookupFromSubdomainIndex: t
    } = e;
    const n = typeof t == "number" ? t + 1 : 1, r = typeof window < "u" && ((o = (i = window.location) == null ? void 0 : i.hostname) == null ? void 0 : o.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i));
    if (r)
      return r[n];
  }
};
function Nse() {
  return {
    order: ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"],
    lookupQuerystring: "lng",
    lookupCookie: "i18next",
    lookupLocalStorage: "i18nextLng",
    lookupSessionStorage: "i18nextLng",
    // cache user language
    caches: ["localStorage"],
    excludeCacheFor: ["cimode"],
    // cookieMinutes: 10,
    // cookieDomain: 'myDomain'
    convertDetectedLanguage: (e) => e
  };
}
class yV {
  constructor(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.type = "languageDetector", this.detectors = {}, this.init(t, n);
  }
  init(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    this.services = t || {
      languageUtils: {}
    }, this.options = kse(n, this.options || {}, Nse()), typeof this.options.convertDetectedLanguage == "string" && this.options.convertDetectedLanguage.indexOf("15897") > -1 && (this.options.convertDetectedLanguage = (i) => i.replace("-", "_")), this.options.lookupFromUrlIndex && (this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex), this.i18nOptions = r, this.addDetector(Tse), this.addDetector(_se), this.addDetector(Rse), this.addDetector(Ose), this.addDetector(Ise), this.addDetector(Dse), this.addDetector(Mse), this.addDetector(Pse);
  }
  addDetector(t) {
    return this.detectors[t.name] = t, this;
  }
  detect(t) {
    t || (t = this.options.order);
    let n = [];
    return t.forEach((r) => {
      if (this.detectors[r]) {
        let i = this.detectors[r].lookup(this.options);
        i && typeof i == "string" && (i = [i]), i && (n = n.concat(i));
      }
    }), n = n.map((r) => this.options.convertDetectedLanguage(r)), this.services.languageUtils.getBestMatchFromCodes ? n : n.length > 0 ? n[0] : null;
  }
  cacheUserLanguage(t, n) {
    n || (n = this.options.caches), n && (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(t) > -1 || n.forEach((r) => {
      this.detectors[r] && this.detectors[r].cacheUserLanguage(t, this.options);
    }));
  }
}
yV.type = "languageDetector";
var Bse = {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  embed: !0,
  hr: !0,
  img: !0,
  input: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0
};
const Lse = /* @__PURE__ */ DC(Bse);
var jse = /\s([^'"/\s><]+?)[\s/>]|([^\s=]+)=\s?(".*?"|'.*?')/g;
function gj(e) {
  var t = { type: "tag", name: "", voidElement: !1, attrs: {}, children: [] }, n = e.match(/<\/?([^\s]+?)[/\s>]/);
  if (n && (t.name = n[1], (Lse[n[1]] || e.charAt(e.length - 2) === "/") && (t.voidElement = !0), t.name.startsWith("!--"))) {
    var r = e.indexOf("-->");
    return { type: "comment", comment: r !== -1 ? e.slice(4, r) : "" };
  }
  for (var i = new RegExp(jse), o = null; (o = i.exec(e)) !== null; ) if (o[0].trim()) if (o[1]) {
    var s = o[1].trim(), c = [s, ""];
    s.indexOf("=") > -1 && (c = s.split("=")), t.attrs[c[0]] = c[1], i.lastIndex--;
  } else o[2] && (t.attrs[o[2]] = o[3].trim().substring(1, o[3].length - 1));
  return t;
}
var Fse = /<[a-zA-Z0-9\-\!\/](?:"[^"]*"|'[^']*'|[^'">])*>/g, Use = /^\s*$/, zse = /* @__PURE__ */ Object.create(null);
function vV(e, t) {
  switch (t.type) {
    case "text":
      return e + t.content;
    case "tag":
      return e += "<" + t.name + (t.attrs ? function(n) {
        var r = [];
        for (var i in n) r.push(i + '="' + n[i] + '"');
        return r.length ? " " + r.join(" ") : "";
      }(t.attrs) : "") + (t.voidElement ? "/>" : ">"), t.voidElement ? e : e + t.children.reduce(vV, "") + "</" + t.name + ">";
    case "comment":
      return e + "<!--" + t.comment + "-->";
  }
}
var Vse = { parse: function(e, t) {
  t || (t = {}), t.components || (t.components = zse);
  var n, r = [], i = [], o = -1, s = !1;
  if (e.indexOf("<") !== 0) {
    var c = e.indexOf("<");
    r.push({ type: "text", content: c === -1 ? e : e.substring(0, c) });
  }
  return e.replace(Fse, function(u, f) {
    if (s) {
      if (u !== "</" + n.name + ">") return;
      s = !1;
    }
    var p, y = u.charAt(1) !== "/", v = u.startsWith("<!--"), w = f + u.length, C = e.charAt(w);
    if (v) {
      var x = gj(u);
      return o < 0 ? (r.push(x), r) : ((p = i[o]).children.push(x), r);
    }
    if (y && (o++, (n = gj(u)).type === "tag" && t.components[n.name] && (n.type = "component", s = !0), n.voidElement || s || !C || C === "<" || n.children.push({ type: "text", content: e.slice(w, e.indexOf("<", w)) }), o === 0 && r.push(n), (p = i[o - 1]) && p.children.push(n), i[o] = n), (!y || n.voidElement) && (o > -1 && (n.voidElement || n.name === u.slice(2, -1)) && (o--, n = o === -1 ? r : i[o]), !s && C !== "<" && C)) {
      p = o === -1 ? r : i[o].children;
      var A = e.indexOf("<", w), R = e.slice(w, A === -1 ? void 0 : A);
      Use.test(R) && (R = " "), (A > -1 && o + p.length >= 0 || R !== " ") && p.push({ type: "text", content: R });
    }
  }), r;
}, stringify: function(e) {
  return e.reduce(function(t, n) {
    return t + vV("", n);
  }, "");
} };
const e4 = (...e) => {
  console != null && console.warn && ql(e[0]) && (e[0] = `react-i18next:: ${e[0]}`);
}, bj = {}, _4 = (...e) => {
  ql(e[0]) && bj[e[0]] || (ql(e[0]) && (bj[e[0]] = /* @__PURE__ */ new Date()), e4(...e));
}, gV = (e, t) => () => {
  if (e.isInitialized)
    t();
  else {
    const n = () => {
      setTimeout(() => {
        e.off("initialized", n);
      }, 0), t();
    };
    e.on("initialized", n);
  }
}, wj = (e, t, n) => {
  e.loadNamespaces(t, gV(e, n));
}, Cj = (e, t, n, r) => {
  ql(n) && (n = [n]), n.forEach((i) => {
    e.options.ns.indexOf(i) < 0 && e.options.ns.push(i);
  }), e.loadLanguages(t, gV(e, r));
}, $se = (e, t, n = {}) => !t.languages || !t.languages.length ? (_4("i18n.languages were undefined or empty", t.languages), !0) : t.hasLoadedNamespace(e, {
  lng: n.lng,
  precheck: (r, i) => {
    var o;
    if (((o = n.bindI18n) == null ? void 0 : o.indexOf("languageChanging")) > -1 && r.services.backendConnector.backend && r.isLanguageChangingTo && !i(r.isLanguageChangingTo, e)) return !1;
  }
}), ql = (e) => typeof e == "string", vg = (e) => typeof e == "object" && e !== null, Hse = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g, qse = {
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"',
  "&nbsp;": " ",
  "&#160;": " ",
  "&copy;": "",
  "&#169;": "",
  "&reg;": "",
  "&#174;": "",
  "&hellip;": "",
  "&#8230;": "",
  "&#x2F;": "/",
  "&#47;": "/"
}, Wse = (e) => qse[e], Gse = (e) => e.replace(Hse, Wse);
let qI = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: !0,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: !0,
  unescape: Gse
};
const Kse = (e = {}) => {
  qI = {
    ...qI,
    ...e
  };
}, bV = () => qI;
let wV;
const Yse = (e) => {
  wV = e;
}, KD = () => wV, IR = (e, t) => {
  var r;
  if (!e) return !1;
  const n = ((r = e.props) == null ? void 0 : r.children) ?? e.children;
  return t ? n.length > 0 : !!n;
}, DR = (e) => {
  var n, r;
  if (!e) return [];
  const t = ((n = e.props) == null ? void 0 : n.children) ?? e.children;
  return (r = e.props) != null && r.i18nIsDynamicList ? gg(t) : t;
}, Qse = (e) => Array.isArray(e) && e.every(k.isValidElement), gg = (e) => Array.isArray(e) ? e : [e], Xse = (e, t) => {
  const n = {
    ...t
  };
  return n.props = Object.assign(e.props, t.props), n;
}, CV = (e, t) => {
  if (!e) return "";
  let n = "";
  const r = gg(e), i = t != null && t.transSupportBasicHtmlNodes ? t.transKeepBasicHtmlNodesFor ?? [] : [];
  return r.forEach((o, s) => {
    if (ql(o))
      n += `${o}`;
    else if (k.isValidElement(o)) {
      const {
        props: c,
        type: u
      } = o, f = Object.keys(c).length, p = i.indexOf(u) > -1, y = c.children;
      if (!y && p && !f)
        n += `<${u}/>`;
      else if (!y && (!p || f) || c.i18nIsDynamicList)
        n += `<${s}></${s}>`;
      else if (p && f === 1 && ql(y))
        n += `<${u}>${y}</${u}>`;
      else {
        const v = CV(y, t);
        n += `<${s}>${v}</${s}>`;
      }
    } else if (o === null)
      e4("Trans: the passed in value is invalid - seems you passed in a null child.");
    else if (vg(o)) {
      const {
        format: c,
        ...u
      } = o, f = Object.keys(u);
      if (f.length === 1) {
        const p = c ? `${f[0]}, ${c}` : f[0];
        n += `{{${p}}}`;
      } else
        e4("react-i18next: the passed in object contained more than one variable - the object should look like {{ value, format }} where format is optional.", o);
    } else
      e4("Trans: the passed in value is invalid - seems you passed in a variable like {number} - please pass in variables for interpolation as full objects like {{number}}.", o);
  }), n;
}, Jse = (e, t, n, r, i, o) => {
  if (t === "") return [];
  const s = r.transKeepBasicHtmlNodesFor || [], c = t && new RegExp(s.map((A) => `<${A}`).join("|")).test(t);
  if (!e && !c && !o) return [t];
  const u = {}, f = (A) => {
    gg(A).forEach((I) => {
      ql(I) || (IR(I) ? f(DR(I)) : vg(I) && !k.isValidElement(I) && Object.assign(u, I));
    });
  };
  f(e);
  const p = Vse.parse(`<0>${t}</0>`), y = {
    ...u,
    ...i
  }, v = (A, R, I) => {
    var L;
    const D = DR(A), M = C(D, R.children, I);
    return Qse(D) && M.length === 0 || (L = A.props) != null && L.i18nIsDynamicList ? D : M;
  }, w = (A, R, I, D, M) => {
    A.dummy ? (A.children = R, I.push(k.cloneElement(A, {
      key: D
    }, M ? void 0 : R))) : I.push(...k.Children.map([A], (L) => {
      const j = {
        ...L.props
      };
      return delete j.i18nIsDynamicList, k.createElement(L.type, {
        ...j,
        key: D,
        ref: L.ref
      }, M ? null : R);
    }));
  }, C = (A, R, I) => {
    const D = gg(A);
    return gg(R).reduce((L, j, F) => {
      var z, H;
      const O = ((H = (z = j.children) == null ? void 0 : z[0]) == null ? void 0 : H.content) && n.services.interpolator.interpolate(j.children[0].content, y, n.language);
      if (j.type === "tag") {
        let Q = D[parseInt(j.name, 10)];
        I.length === 1 && !Q && (Q = I[0][j.name]), Q || (Q = {});
        const Y = Object.keys(j.attrs).length !== 0 ? Xse({
          props: j.attrs
        }, Q) : Q, ee = k.isValidElement(Y), ie = ee && IR(j, !0) && !j.voidElement, X = c && vg(Y) && Y.dummy && !ee, Z = vg(e) && Object.hasOwnProperty.call(e, j.name);
        if (ql(Y)) {
          const J = n.services.interpolator.interpolate(Y, y, n.language);
          L.push(J);
        } else if (IR(Y) || ie) {
          const J = v(Y, j, I);
          w(Y, J, L, F);
        } else if (X) {
          const J = C(D, j.children, I);
          w(Y, J, L, F);
        } else if (Number.isNaN(parseFloat(j.name)))
          if (Z) {
            const J = v(Y, j, I);
            w(Y, J, L, F, j.voidElement);
          } else if (r.transSupportBasicHtmlNodes && s.indexOf(j.name) > -1)
            if (j.voidElement)
              L.push(k.createElement(j.name, {
                key: `${j.name}-${F}`
              }));
            else {
              const J = C(D, j.children, I);
              L.push(k.createElement(j.name, {
                key: `${j.name}-${F}`
              }, J));
            }
          else if (j.voidElement)
            L.push(`<${j.name} />`);
          else {
            const J = C(D, j.children, I);
            L.push(`<${j.name}>${J}</${j.name}>`);
          }
        else if (vg(Y) && !ee) {
          const J = j.children[0] ? O : null;
          J && L.push(J);
        } else
          w(Y, O, L, F, j.children.length !== 1 || !O);
      } else if (j.type === "text") {
        const Q = r.transWrapTextNodes, Y = o ? r.unescape(n.services.interpolator.interpolate(j.content, y, n.language)) : n.services.interpolator.interpolate(j.content, y, n.language);
        Q ? L.push(k.createElement(Q, {
          key: `${j.name}-${F}`
        }, Y)) : L.push(Y);
      }
      return L;
    }, []);
  }, x = C([{
    dummy: !0,
    children: e || []
  }], p, gg(e || []));
  return DR(x[0]);
};
function Zse({
  children: e,
  count: t,
  parent: n,
  i18nKey: r,
  context: i,
  tOptions: o = {},
  values: s,
  defaults: c,
  components: u,
  ns: f,
  i18n: p,
  t: y,
  shouldUnescape: v,
  ...w
}) {
  var Q, Y, ee, ie, X, Z;
  const C = p || KD();
  if (!C)
    return _4("You will need to pass in an i18next instance by using i18nextReactModule"), e;
  const x = y || C.t.bind(C) || ((J) => J), A = {
    ...bV(),
    ...(Q = C.options) == null ? void 0 : Q.react
  };
  let R = f || x.ns || ((Y = C.options) == null ? void 0 : Y.defaultNS);
  R = ql(R) ? [R] : R || ["translation"];
  const I = CV(e, A), D = c || I || A.transEmptyNodeValue || r, {
    hashTransKey: M
  } = A, L = r || (M ? M(I || D) : I || D);
  (ie = (ee = C.options) == null ? void 0 : ee.interpolation) != null && ie.defaultVariables && (s = s && Object.keys(s).length > 0 ? {
    ...s,
    ...C.options.interpolation.defaultVariables
  } : {
    ...C.options.interpolation.defaultVariables
  });
  const j = s || t !== void 0 && !((Z = (X = C.options) == null ? void 0 : X.interpolation) != null && Z.alwaysFormat) || !e ? o.interpolation : {
    interpolation: {
      ...o.interpolation,
      prefix: "#$?",
      suffix: "?$#"
    }
  }, F = {
    ...o,
    context: i || o.context,
    count: t,
    ...s,
    ...j,
    defaultValue: D,
    ns: R
  }, O = L ? x(L, F) : D;
  u && Object.keys(u).forEach((J) => {
    const K = u[J];
    if (typeof K.type == "function" || !K.props || !K.props.children || O.indexOf(`${J}/>`) < 0 && O.indexOf(`${J} />`) < 0) return;
    function oe() {
      return k.createElement(k.Fragment, null, K);
    }
    u[J] = k.createElement(oe);
  });
  const z = Jse(u || e, O, C, A, F, v), H = n ?? A.defaultTransParent;
  return H ? k.createElement(H, w, z) : z;
}
const ele = {
  type: "3rdParty",
  init(e) {
    Kse(e.options.react), Yse(e);
  }
}, YD = k.createContext();
class tle {
  constructor() {
    this.usedNamespaces = {};
  }
  addUsedNamespaces(t) {
    t.forEach((n) => {
      var r;
      (r = this.usedNamespaces)[n] ?? (r[n] = !0);
    });
  }
  getUsedNamespaces() {
    return Object.keys(this.usedNamespaces);
  }
}
function _a({
  children: e,
  count: t,
  parent: n,
  i18nKey: r,
  context: i,
  tOptions: o = {},
  values: s,
  defaults: c,
  components: u,
  ns: f,
  i18n: p,
  t: y,
  shouldUnescape: v,
  ...w
}) {
  var I;
  const {
    i18n: C,
    defaultNS: x
  } = k.useContext(YD) || {}, A = p || C || KD(), R = y || (A == null ? void 0 : A.t.bind(A));
  return Zse({
    children: e,
    count: t,
    parent: n,
    i18nKey: r,
    context: i,
    tOptions: o,
    values: s,
    defaults: c,
    components: u,
    ns: f || (R == null ? void 0 : R.ns) || x || ((I = A == null ? void 0 : A.options) == null ? void 0 : I.defaultNS),
    i18n: A,
    t: y,
    shouldUnescape: v,
    ...w
  });
}
const nle = (e, t) => {
  const n = k.useRef();
  return k.useEffect(() => {
    n.current = e;
  }, [e, t]), n.current;
}, xV = (e, t, n, r) => e.getFixedT(t, n, r), rle = (e, t, n, r) => k.useCallback(xV(e, t, n, r), [e, t, n, r]), ln = (e, t = {}) => {
  var M, L, j, F;
  const {
    i18n: n
  } = t, {
    i18n: r,
    defaultNS: i
  } = k.useContext(YD) || {}, o = n || r || KD();
  if (o && !o.reportNamespaces && (o.reportNamespaces = new tle()), !o) {
    _4("You will need to pass in an i18next instance by using initReactI18next");
    const O = (H, Q) => ql(Q) ? Q : vg(Q) && ql(Q.defaultValue) ? Q.defaultValue : Array.isArray(H) ? H[H.length - 1] : H, z = [O, {}, !1];
    return z.t = O, z.i18n = {}, z.ready = !1, z;
  }
  (M = o.options.react) != null && M.wait && _4("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  const s = {
    ...bV(),
    ...o.options.react,
    ...t
  }, {
    useSuspense: c,
    keyPrefix: u
  } = s;
  let f = i || ((L = o.options) == null ? void 0 : L.defaultNS);
  f = ql(f) ? [f] : f || ["translation"], (F = (j = o.reportNamespaces).addUsedNamespaces) == null || F.call(j, f);
  const p = (o.isInitialized || o.initializedStoreOnce) && f.every((O) => $se(O, o, s)), y = rle(o, t.lng || null, s.nsMode === "fallback" ? f : f[0], u), v = () => y, w = () => xV(o, t.lng || null, s.nsMode === "fallback" ? f : f[0], u), [C, x] = k.useState(v);
  let A = f.join();
  t.lng && (A = `${t.lng}${A}`);
  const R = nle(A), I = k.useRef(!0);
  k.useEffect(() => {
    const {
      bindI18n: O,
      bindI18nStore: z
    } = s;
    I.current = !0, !p && !c && (t.lng ? Cj(o, t.lng, f, () => {
      I.current && x(w);
    }) : wj(o, f, () => {
      I.current && x(w);
    })), p && R && R !== A && I.current && x(w);
    const H = () => {
      I.current && x(w);
    };
    return O && (o == null || o.on(O, H)), z && (o == null || o.store.on(z, H)), () => {
      I.current = !1, o && (O == null || O.split(" ").forEach((Q) => o.off(Q, H))), z && o && z.split(" ").forEach((Q) => o.store.off(Q, H));
    };
  }, [o, A]), k.useEffect(() => {
    I.current && p && x(v);
  }, [o, u, p]);
  const D = [C, o, p];
  if (D.t = C, D.i18n = o, D.ready = p, p || !p && !c) return D;
  throw new Promise((O) => {
    t.lng ? Cj(o, t.lng, f, () => O()) : wj(o, f, () => O());
  });
};
function ile({
  i18n: e,
  defaultNS: t,
  children: n
}) {
  const r = k.useMemo(() => ({
    i18n: e,
    defaultNS: t
  }), [e, t]);
  return k.createElement(YD.Provider, {
    value: r
  }, n);
}
const WI = globalThis || void 0 || self;
function EV(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: ole } = Object.prototype, { getPrototypeOf: QD } = Object, v8 = /* @__PURE__ */ ((e) => (t) => {
  const n = ole.call(t);
  return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), qc = (e) => (e = e.toLowerCase(), (t) => v8(t) === e), g8 = (e) => (t) => typeof t === e, { isArray: Db } = Array, V1 = g8("undefined");
function ale(e) {
  return e !== null && !V1(e) && e.constructor !== null && !V1(e.constructor) && cl(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const SV = qc("ArrayBuffer");
function sle(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && SV(e.buffer), t;
}
const lle = g8("string"), cl = g8("function"), kV = g8("number"), b8 = (e) => e !== null && typeof e == "object", cle = (e) => e === !0 || e === !1, t4 = (e) => {
  if (v8(e) !== "object")
    return !1;
  const t = QD(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, ule = qc("Date"), dle = qc("File"), fle = qc("Blob"), hle = qc("FileList"), ple = (e) => b8(e) && cl(e.pipe), mle = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || cl(e.append) && ((t = v8(e)) === "formdata" || // detect form-data instance
  t === "object" && cl(e.toString) && e.toString() === "[object FormData]"));
}, yle = qc("URLSearchParams"), [vle, gle, ble, wle] = ["ReadableStream", "Request", "Response", "Headers"].map(qc), Cle = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function MC(e, t, { allOwnKeys: n = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let r, i;
  if (typeof e != "object" && (e = [e]), Db(e))
    for (r = 0, i = e.length; r < i; r++)
      t.call(null, e[r], r, e);
  else {
    const o = n ? Object.getOwnPropertyNames(e) : Object.keys(e), s = o.length;
    let c;
    for (r = 0; r < s; r++)
      c = o[r], t.call(null, e[c], c, e);
  }
}
function AV(e, t) {
  t = t.toLowerCase();
  const n = Object.keys(e);
  let r = n.length, i;
  for (; r-- > 0; )
    if (i = n[r], t === i.toLowerCase())
      return i;
  return null;
}
const Am = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : WI, TV = (e) => !V1(e) && e !== Am;
function GI() {
  const { caseless: e } = TV(this) && this || {}, t = {}, n = (r, i) => {
    const o = e && AV(t, i) || i;
    t4(t[o]) && t4(r) ? t[o] = GI(t[o], r) : t4(r) ? t[o] = GI({}, r) : Db(r) ? t[o] = r.slice() : t[o] = r;
  };
  for (let r = 0, i = arguments.length; r < i; r++)
    arguments[r] && MC(arguments[r], n);
  return t;
}
const xle = (e, t, n, { allOwnKeys: r } = {}) => (MC(t, (i, o) => {
  n && cl(i) ? e[o] = EV(i, n) : e[o] = i;
}, { allOwnKeys: r }), e), Ele = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), Sle = (e, t, n, r) => {
  e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), n && Object.assign(e.prototype, n);
}, kle = (e, t, n, r) => {
  let i, o, s;
  const c = {};
  if (t = t || {}, e == null) return t;
  do {
    for (i = Object.getOwnPropertyNames(e), o = i.length; o-- > 0; )
      s = i[o], (!r || r(s, e, t)) && !c[s] && (t[s] = e[s], c[s] = !0);
    e = n !== !1 && QD(e);
  } while (e && (!n || n(e, t)) && e !== Object.prototype);
  return t;
}, Ale = (e, t, n) => {
  e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
  const r = e.indexOf(t, n);
  return r !== -1 && r === n;
}, Tle = (e) => {
  if (!e) return null;
  if (Db(e)) return e;
  let t = e.length;
  if (!kV(t)) return null;
  const n = new Array(t);
  for (; t-- > 0; )
    n[t] = e[t];
  return n;
}, _le = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && QD(Uint8Array)), Rle = (e, t) => {
  const r = (e && e[Symbol.iterator]).call(e);
  let i;
  for (; (i = r.next()) && !i.done; ) {
    const o = i.value;
    t.call(e, o[0], o[1]);
  }
}, Ole = (e, t) => {
  let n;
  const r = [];
  for (; (n = e.exec(t)) !== null; )
    r.push(n);
  return r;
}, Ile = qc("HTMLFormElement"), Dle = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(n, r, i) {
    return r.toUpperCase() + i;
  }
), xj = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), Mle = qc("RegExp"), _V = (e, t) => {
  const n = Object.getOwnPropertyDescriptors(e), r = {};
  MC(n, (i, o) => {
    let s;
    (s = t(i, o, e)) !== !1 && (r[o] = s || i);
  }), Object.defineProperties(e, r);
}, Ple = (e) => {
  _V(e, (t, n) => {
    if (cl(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const r = e[n];
    if (cl(r)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, Nle = (e, t) => {
  const n = {}, r = (i) => {
    i.forEach((o) => {
      n[o] = !0;
    });
  };
  return Db(e) ? r(e) : r(String(e).split(t)), n;
}, Ble = () => {
}, Lle = (e, t) => e != null && Number.isFinite(e = +e) ? e : t, MR = "abcdefghijklmnopqrstuvwxyz", Ej = "0123456789", RV = {
  DIGIT: Ej,
  ALPHA: MR,
  ALPHA_DIGIT: MR + MR.toUpperCase() + Ej
}, jle = (e = 16, t = RV.ALPHA_DIGIT) => {
  let n = "";
  const { length: r } = t;
  for (; e--; )
    n += t[Math.random() * r | 0];
  return n;
};
function Fle(e) {
  return !!(e && cl(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const Ule = (e) => {
  const t = new Array(10), n = (r, i) => {
    if (b8(r)) {
      if (t.indexOf(r) >= 0)
        return;
      if (!("toJSON" in r)) {
        t[i] = r;
        const o = Db(r) ? [] : {};
        return MC(r, (s, c) => {
          const u = n(s, i + 1);
          !V1(u) && (o[c] = u);
        }), t[i] = void 0, o;
      }
    }
    return r;
  };
  return n(e, 0);
}, zle = qc("AsyncFunction"), Vle = (e) => e && (b8(e) || cl(e)) && cl(e.then) && cl(e.catch), OV = ((e, t) => e ? setImmediate : t ? ((n, r) => (Am.addEventListener("message", ({ source: i, data: o }) => {
  i === Am && o === n && r.length && r.shift()();
}, !1), (i) => {
  r.push(i), Am.postMessage(n, "*");
}))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(
  typeof setImmediate == "function",
  cl(Am.postMessage)
), $le = typeof queueMicrotask < "u" ? queueMicrotask.bind(Am) : typeof ct < "u" && ct.nextTick || OV, Xe = {
  isArray: Db,
  isArrayBuffer: SV,
  isBuffer: ale,
  isFormData: mle,
  isArrayBufferView: sle,
  isString: lle,
  isNumber: kV,
  isBoolean: cle,
  isObject: b8,
  isPlainObject: t4,
  isReadableStream: vle,
  isRequest: gle,
  isResponse: ble,
  isHeaders: wle,
  isUndefined: V1,
  isDate: ule,
  isFile: dle,
  isBlob: fle,
  isRegExp: Mle,
  isFunction: cl,
  isStream: ple,
  isURLSearchParams: yle,
  isTypedArray: _le,
  isFileList: hle,
  forEach: MC,
  merge: GI,
  extend: xle,
  trim: Cle,
  stripBOM: Ele,
  inherits: Sle,
  toFlatObject: kle,
  kindOf: v8,
  kindOfTest: qc,
  endsWith: Ale,
  toArray: Tle,
  forEachEntry: Rle,
  matchAll: Ole,
  isHTMLForm: Ile,
  hasOwnProperty: xj,
  hasOwnProp: xj,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: _V,
  freezeMethods: Ple,
  toObjectSet: Nle,
  toCamelCase: Dle,
  noop: Ble,
  toFiniteNumber: Lle,
  findKey: AV,
  global: Am,
  isContextDefined: TV,
  ALPHABET: RV,
  generateString: jle,
  isSpecCompliantForm: Fle,
  toJSONObject: Ule,
  isAsyncFn: zle,
  isThenable: Vle,
  setImmediate: OV,
  asap: $le
};
var Io = {}, w8 = {};
w8.byteLength = Wle;
w8.toByteArray = Kle;
w8.fromByteArray = Xle;
var Mu = [], Fl = [], Hle = typeof Uint8Array < "u" ? Uint8Array : Array, PR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var ig = 0, qle = PR.length; ig < qle; ++ig)
  Mu[ig] = PR[ig], Fl[PR.charCodeAt(ig)] = ig;
Fl[45] = 62;
Fl[95] = 63;
function IV(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var n = e.indexOf("=");
  n === -1 && (n = t);
  var r = n === t ? 0 : 4 - n % 4;
  return [n, r];
}
function Wle(e) {
  var t = IV(e), n = t[0], r = t[1];
  return (n + r) * 3 / 4 - r;
}
function Gle(e, t, n) {
  return (t + n) * 3 / 4 - n;
}
function Kle(e) {
  var t, n = IV(e), r = n[0], i = n[1], o = new Hle(Gle(e, r, i)), s = 0, c = i > 0 ? r - 4 : r, u;
  for (u = 0; u < c; u += 4)
    t = Fl[e.charCodeAt(u)] << 18 | Fl[e.charCodeAt(u + 1)] << 12 | Fl[e.charCodeAt(u + 2)] << 6 | Fl[e.charCodeAt(u + 3)], o[s++] = t >> 16 & 255, o[s++] = t >> 8 & 255, o[s++] = t & 255;
  return i === 2 && (t = Fl[e.charCodeAt(u)] << 2 | Fl[e.charCodeAt(u + 1)] >> 4, o[s++] = t & 255), i === 1 && (t = Fl[e.charCodeAt(u)] << 10 | Fl[e.charCodeAt(u + 1)] << 4 | Fl[e.charCodeAt(u + 2)] >> 2, o[s++] = t >> 8 & 255, o[s++] = t & 255), o;
}
function Yle(e) {
  return Mu[e >> 18 & 63] + Mu[e >> 12 & 63] + Mu[e >> 6 & 63] + Mu[e & 63];
}
function Qle(e, t, n) {
  for (var r, i = [], o = t; o < n; o += 3)
    r = (e[o] << 16 & 16711680) + (e[o + 1] << 8 & 65280) + (e[o + 2] & 255), i.push(Yle(r));
  return i.join("");
}
function Xle(e) {
  for (var t, n = e.length, r = n % 3, i = [], o = 16383, s = 0, c = n - r; s < c; s += o)
    i.push(Qle(e, s, s + o > c ? c : s + o));
  return r === 1 ? (t = e[n - 1], i.push(
    Mu[t >> 2] + Mu[t << 4 & 63] + "=="
  )) : r === 2 && (t = (e[n - 2] << 8) + e[n - 1], i.push(
    Mu[t >> 10] + Mu[t >> 4 & 63] + Mu[t << 2 & 63] + "="
  )), i.join("");
}
var XD = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
XD.read = function(e, t, n, r, i) {
  var o, s, c = i * 8 - r - 1, u = (1 << c) - 1, f = u >> 1, p = -7, y = n ? i - 1 : 0, v = n ? -1 : 1, w = e[t + y];
  for (y += v, o = w & (1 << -p) - 1, w >>= -p, p += c; p > 0; o = o * 256 + e[t + y], y += v, p -= 8)
    ;
  for (s = o & (1 << -p) - 1, o >>= -p, p += r; p > 0; s = s * 256 + e[t + y], y += v, p -= 8)
    ;
  if (o === 0)
    o = 1 - f;
  else {
    if (o === u)
      return s ? NaN : (w ? -1 : 1) * (1 / 0);
    s = s + Math.pow(2, r), o = o - f;
  }
  return (w ? -1 : 1) * s * Math.pow(2, o - r);
};
XD.write = function(e, t, n, r, i, o) {
  var s, c, u, f = o * 8 - i - 1, p = (1 << f) - 1, y = p >> 1, v = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, w = r ? 0 : o - 1, C = r ? 1 : -1, x = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (c = isNaN(t) ? 1 : 0, s = p) : (s = Math.floor(Math.log(t) / Math.LN2), t * (u = Math.pow(2, -s)) < 1 && (s--, u *= 2), s + y >= 1 ? t += v / u : t += v * Math.pow(2, 1 - y), t * u >= 2 && (s++, u /= 2), s + y >= p ? (c = 0, s = p) : s + y >= 1 ? (c = (t * u - 1) * Math.pow(2, i), s = s + y) : (c = t * Math.pow(2, y - 1) * Math.pow(2, i), s = 0)); i >= 8; e[n + w] = c & 255, w += C, c /= 256, i -= 8)
    ;
  for (s = s << i | c, f += i; f > 0; e[n + w] = s & 255, w += C, s /= 256, f -= 8)
    ;
  e[n + w - C] |= x * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  const t = w8, n = XD, r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = p, e.SlowBuffer = L, e.INSPECT_MAX_BYTES = 50;
  const i = 2147483647;
  e.kMaxLength = i;
  const { Uint8Array: o, ArrayBuffer: s, SharedArrayBuffer: c } = globalThis;
  p.TYPED_ARRAY_SUPPORT = u(), !p.TYPED_ARRAY_SUPPORT && typeof console < "u";
  function u() {
    try {
      const ne = new o(1), N = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(N, o.prototype), Object.setPrototypeOf(ne, N), ne.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(p.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (p.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(p.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (p.isBuffer(this))
        return this.byteOffset;
    }
  });
  function f(ne) {
    if (ne > i)
      throw new RangeError('The value "' + ne + '" is invalid for option "size"');
    const N = new o(ne);
    return Object.setPrototypeOf(N, p.prototype), N;
  }
  function p(ne, N, U) {
    if (typeof ne == "number") {
      if (typeof N == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return C(ne);
    }
    return y(ne, N, U);
  }
  p.poolSize = 8192;
  function y(ne, N, U) {
    if (typeof ne == "string")
      return x(ne, N);
    if (s.isView(ne))
      return R(ne);
    if (ne == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ne
      );
    if (Tt(ne, s) || ne && Tt(ne.buffer, s) || typeof c < "u" && (Tt(ne, c) || ne && Tt(ne.buffer, c)))
      return I(ne, N, U);
    if (typeof ne == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const le = ne.valueOf && ne.valueOf();
    if (le != null && le !== ne)
      return p.from(le, N, U);
    const Ce = D(ne);
    if (Ce) return Ce;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof ne[Symbol.toPrimitive] == "function")
      return p.from(ne[Symbol.toPrimitive]("string"), N, U);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ne
    );
  }
  p.from = function(ne, N, U) {
    return y(ne, N, U);
  }, Object.setPrototypeOf(p.prototype, o.prototype), Object.setPrototypeOf(p, o);
  function v(ne) {
    if (typeof ne != "number")
      throw new TypeError('"size" argument must be of type number');
    if (ne < 0)
      throw new RangeError('The value "' + ne + '" is invalid for option "size"');
  }
  function w(ne, N, U) {
    return v(ne), ne <= 0 ? f(ne) : N !== void 0 ? typeof U == "string" ? f(ne).fill(N, U) : f(ne).fill(N) : f(ne);
  }
  p.alloc = function(ne, N, U) {
    return w(ne, N, U);
  };
  function C(ne) {
    return v(ne), f(ne < 0 ? 0 : M(ne) | 0);
  }
  p.allocUnsafe = function(ne) {
    return C(ne);
  }, p.allocUnsafeSlow = function(ne) {
    return C(ne);
  };
  function x(ne, N) {
    if ((typeof N != "string" || N === "") && (N = "utf8"), !p.isEncoding(N))
      throw new TypeError("Unknown encoding: " + N);
    const U = j(ne, N) | 0;
    let le = f(U);
    const Ce = le.write(ne, N);
    return Ce !== U && (le = le.slice(0, Ce)), le;
  }
  function A(ne) {
    const N = ne.length < 0 ? 0 : M(ne.length) | 0, U = f(N);
    for (let le = 0; le < N; le += 1)
      U[le] = ne[le] & 255;
    return U;
  }
  function R(ne) {
    if (Tt(ne, o)) {
      const N = new o(ne);
      return I(N.buffer, N.byteOffset, N.byteLength);
    }
    return A(ne);
  }
  function I(ne, N, U) {
    if (N < 0 || ne.byteLength < N)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (ne.byteLength < N + (U || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let le;
    return N === void 0 && U === void 0 ? le = new o(ne) : U === void 0 ? le = new o(ne, N) : le = new o(ne, N, U), Object.setPrototypeOf(le, p.prototype), le;
  }
  function D(ne) {
    if (p.isBuffer(ne)) {
      const N = M(ne.length) | 0, U = f(N);
      return U.length === 0 || ne.copy(U, 0, 0, N), U;
    }
    if (ne.length !== void 0)
      return typeof ne.length != "number" || qt(ne.length) ? f(0) : A(ne);
    if (ne.type === "Buffer" && Array.isArray(ne.data))
      return A(ne.data);
  }
  function M(ne) {
    if (ne >= i)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
    return ne | 0;
  }
  function L(ne) {
    return +ne != ne && (ne = 0), p.alloc(+ne);
  }
  p.isBuffer = function(N) {
    return N != null && N._isBuffer === !0 && N !== p.prototype;
  }, p.compare = function(N, U) {
    if (Tt(N, o) && (N = p.from(N, N.offset, N.byteLength)), Tt(U, o) && (U = p.from(U, U.offset, U.byteLength)), !p.isBuffer(N) || !p.isBuffer(U))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (N === U) return 0;
    let le = N.length, Ce = U.length;
    for (let Te = 0, Ve = Math.min(le, Ce); Te < Ve; ++Te)
      if (N[Te] !== U[Te]) {
        le = N[Te], Ce = U[Te];
        break;
      }
    return le < Ce ? -1 : Ce < le ? 1 : 0;
  }, p.isEncoding = function(N) {
    switch (String(N).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, p.concat = function(N, U) {
    if (!Array.isArray(N))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (N.length === 0)
      return p.alloc(0);
    let le;
    if (U === void 0)
      for (U = 0, le = 0; le < N.length; ++le)
        U += N[le].length;
    const Ce = p.allocUnsafe(U);
    let Te = 0;
    for (le = 0; le < N.length; ++le) {
      let Ve = N[le];
      if (Tt(Ve, o))
        Te + Ve.length > Ce.length ? (p.isBuffer(Ve) || (Ve = p.from(Ve)), Ve.copy(Ce, Te)) : o.prototype.set.call(
          Ce,
          Ve,
          Te
        );
      else if (p.isBuffer(Ve))
        Ve.copy(Ce, Te);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      Te += Ve.length;
    }
    return Ce;
  };
  function j(ne, N) {
    if (p.isBuffer(ne))
      return ne.length;
    if (s.isView(ne) || Tt(ne, s))
      return ne.byteLength;
    if (typeof ne != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof ne
      );
    const U = ne.length, le = arguments.length > 2 && arguments[2] === !0;
    if (!le && U === 0) return 0;
    let Ce = !1;
    for (; ; )
      switch (N) {
        case "ascii":
        case "latin1":
        case "binary":
          return U;
        case "utf8":
        case "utf-8":
          return ar(ne).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return U * 2;
        case "hex":
          return U >>> 1;
        case "base64":
          return $n(ne).length;
        default:
          if (Ce)
            return le ? -1 : ar(ne).length;
          N = ("" + N).toLowerCase(), Ce = !0;
      }
  }
  p.byteLength = j;
  function F(ne, N, U) {
    let le = !1;
    if ((N === void 0 || N < 0) && (N = 0), N > this.length || ((U === void 0 || U > this.length) && (U = this.length), U <= 0) || (U >>>= 0, N >>>= 0, U <= N))
      return "";
    for (ne || (ne = "utf8"); ; )
      switch (ne) {
        case "hex":
          return pe(this, N, U);
        case "utf8":
        case "utf-8":
          return J(this, N, U);
        case "ascii":
          return be(this, N, U);
        case "latin1":
        case "binary":
          return ce(this, N, U);
        case "base64":
          return Z(this, N, U);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Ee(this, N, U);
        default:
          if (le) throw new TypeError("Unknown encoding: " + ne);
          ne = (ne + "").toLowerCase(), le = !0;
      }
  }
  p.prototype._isBuffer = !0;
  function O(ne, N, U) {
    const le = ne[N];
    ne[N] = ne[U], ne[U] = le;
  }
  p.prototype.swap16 = function() {
    const N = this.length;
    if (N % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let U = 0; U < N; U += 2)
      O(this, U, U + 1);
    return this;
  }, p.prototype.swap32 = function() {
    const N = this.length;
    if (N % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let U = 0; U < N; U += 4)
      O(this, U, U + 3), O(this, U + 1, U + 2);
    return this;
  }, p.prototype.swap64 = function() {
    const N = this.length;
    if (N % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let U = 0; U < N; U += 8)
      O(this, U, U + 7), O(this, U + 1, U + 6), O(this, U + 2, U + 5), O(this, U + 3, U + 4);
    return this;
  }, p.prototype.toString = function() {
    const N = this.length;
    return N === 0 ? "" : arguments.length === 0 ? J(this, 0, N) : F.apply(this, arguments);
  }, p.prototype.toLocaleString = p.prototype.toString, p.prototype.equals = function(N) {
    if (!p.isBuffer(N)) throw new TypeError("Argument must be a Buffer");
    return this === N ? !0 : p.compare(this, N) === 0;
  }, p.prototype.inspect = function() {
    let N = "";
    const U = e.INSPECT_MAX_BYTES;
    return N = this.toString("hex", 0, U).replace(/(.{2})/g, "$1 ").trim(), this.length > U && (N += " ... "), "<Buffer " + N + ">";
  }, r && (p.prototype[r] = p.prototype.inspect), p.prototype.compare = function(N, U, le, Ce, Te) {
    if (Tt(N, o) && (N = p.from(N, N.offset, N.byteLength)), !p.isBuffer(N))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof N
      );
    if (U === void 0 && (U = 0), le === void 0 && (le = N ? N.length : 0), Ce === void 0 && (Ce = 0), Te === void 0 && (Te = this.length), U < 0 || le > N.length || Ce < 0 || Te > this.length)
      throw new RangeError("out of range index");
    if (Ce >= Te && U >= le)
      return 0;
    if (Ce >= Te)
      return -1;
    if (U >= le)
      return 1;
    if (U >>>= 0, le >>>= 0, Ce >>>= 0, Te >>>= 0, this === N) return 0;
    let Ve = Te - Ce, kt = le - U;
    const bn = Math.min(Ve, kt), Wt = this.slice(Ce, Te), xn = N.slice(U, le);
    for (let St = 0; St < bn; ++St)
      if (Wt[St] !== xn[St]) {
        Ve = Wt[St], kt = xn[St];
        break;
      }
    return Ve < kt ? -1 : kt < Ve ? 1 : 0;
  };
  function z(ne, N, U, le, Ce) {
    if (ne.length === 0) return -1;
    if (typeof U == "string" ? (le = U, U = 0) : U > 2147483647 ? U = 2147483647 : U < -2147483648 && (U = -2147483648), U = +U, qt(U) && (U = Ce ? 0 : ne.length - 1), U < 0 && (U = ne.length + U), U >= ne.length) {
      if (Ce) return -1;
      U = ne.length - 1;
    } else if (U < 0)
      if (Ce) U = 0;
      else return -1;
    if (typeof N == "string" && (N = p.from(N, le)), p.isBuffer(N))
      return N.length === 0 ? -1 : H(ne, N, U, le, Ce);
    if (typeof N == "number")
      return N = N & 255, typeof o.prototype.indexOf == "function" ? Ce ? o.prototype.indexOf.call(ne, N, U) : o.prototype.lastIndexOf.call(ne, N, U) : H(ne, [N], U, le, Ce);
    throw new TypeError("val must be string, number or Buffer");
  }
  function H(ne, N, U, le, Ce) {
    let Te = 1, Ve = ne.length, kt = N.length;
    if (le !== void 0 && (le = String(le).toLowerCase(), le === "ucs2" || le === "ucs-2" || le === "utf16le" || le === "utf-16le")) {
      if (ne.length < 2 || N.length < 2)
        return -1;
      Te = 2, Ve /= 2, kt /= 2, U /= 2;
    }
    function bn(xn, St) {
      return Te === 1 ? xn[St] : xn.readUInt16BE(St * Te);
    }
    let Wt;
    if (Ce) {
      let xn = -1;
      for (Wt = U; Wt < Ve; Wt++)
        if (bn(ne, Wt) === bn(N, xn === -1 ? 0 : Wt - xn)) {
          if (xn === -1 && (xn = Wt), Wt - xn + 1 === kt) return xn * Te;
        } else
          xn !== -1 && (Wt -= Wt - xn), xn = -1;
    } else
      for (U + kt > Ve && (U = Ve - kt), Wt = U; Wt >= 0; Wt--) {
        let xn = !0;
        for (let St = 0; St < kt; St++)
          if (bn(ne, Wt + St) !== bn(N, St)) {
            xn = !1;
            break;
          }
        if (xn) return Wt;
      }
    return -1;
  }
  p.prototype.includes = function(N, U, le) {
    return this.indexOf(N, U, le) !== -1;
  }, p.prototype.indexOf = function(N, U, le) {
    return z(this, N, U, le, !0);
  }, p.prototype.lastIndexOf = function(N, U, le) {
    return z(this, N, U, le, !1);
  };
  function Q(ne, N, U, le) {
    U = Number(U) || 0;
    const Ce = ne.length - U;
    le ? (le = Number(le), le > Ce && (le = Ce)) : le = Ce;
    const Te = N.length;
    le > Te / 2 && (le = Te / 2);
    let Ve;
    for (Ve = 0; Ve < le; ++Ve) {
      const kt = parseInt(N.substr(Ve * 2, 2), 16);
      if (qt(kt)) return Ve;
      ne[U + Ve] = kt;
    }
    return Ve;
  }
  function Y(ne, N, U, le) {
    return gr(ar(N, ne.length - U), ne, U, le);
  }
  function ee(ne, N, U, le) {
    return gr(Cr(N), ne, U, le);
  }
  function ie(ne, N, U, le) {
    return gr($n(N), ne, U, le);
  }
  function X(ne, N, U, le) {
    return gr(Un(N, ne.length - U), ne, U, le);
  }
  p.prototype.write = function(N, U, le, Ce) {
    if (U === void 0)
      Ce = "utf8", le = this.length, U = 0;
    else if (le === void 0 && typeof U == "string")
      Ce = U, le = this.length, U = 0;
    else if (isFinite(U))
      U = U >>> 0, isFinite(le) ? (le = le >>> 0, Ce === void 0 && (Ce = "utf8")) : (Ce = le, le = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const Te = this.length - U;
    if ((le === void 0 || le > Te) && (le = Te), N.length > 0 && (le < 0 || U < 0) || U > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    Ce || (Ce = "utf8");
    let Ve = !1;
    for (; ; )
      switch (Ce) {
        case "hex":
          return Q(this, N, U, le);
        case "utf8":
        case "utf-8":
          return Y(this, N, U, le);
        case "ascii":
        case "latin1":
        case "binary":
          return ee(this, N, U, le);
        case "base64":
          return ie(this, N, U, le);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return X(this, N, U, le);
        default:
          if (Ve) throw new TypeError("Unknown encoding: " + Ce);
          Ce = ("" + Ce).toLowerCase(), Ve = !0;
      }
  }, p.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function Z(ne, N, U) {
    return N === 0 && U === ne.length ? t.fromByteArray(ne) : t.fromByteArray(ne.slice(N, U));
  }
  function J(ne, N, U) {
    U = Math.min(ne.length, U);
    const le = [];
    let Ce = N;
    for (; Ce < U; ) {
      const Te = ne[Ce];
      let Ve = null, kt = Te > 239 ? 4 : Te > 223 ? 3 : Te > 191 ? 2 : 1;
      if (Ce + kt <= U) {
        let bn, Wt, xn, St;
        switch (kt) {
          case 1:
            Te < 128 && (Ve = Te);
            break;
          case 2:
            bn = ne[Ce + 1], (bn & 192) === 128 && (St = (Te & 31) << 6 | bn & 63, St > 127 && (Ve = St));
            break;
          case 3:
            bn = ne[Ce + 1], Wt = ne[Ce + 2], (bn & 192) === 128 && (Wt & 192) === 128 && (St = (Te & 15) << 12 | (bn & 63) << 6 | Wt & 63, St > 2047 && (St < 55296 || St > 57343) && (Ve = St));
            break;
          case 4:
            bn = ne[Ce + 1], Wt = ne[Ce + 2], xn = ne[Ce + 3], (bn & 192) === 128 && (Wt & 192) === 128 && (xn & 192) === 128 && (St = (Te & 15) << 18 | (bn & 63) << 12 | (Wt & 63) << 6 | xn & 63, St > 65535 && St < 1114112 && (Ve = St));
        }
      }
      Ve === null ? (Ve = 65533, kt = 1) : Ve > 65535 && (Ve -= 65536, le.push(Ve >>> 10 & 1023 | 55296), Ve = 56320 | Ve & 1023), le.push(Ve), Ce += kt;
    }
    return oe(le);
  }
  const K = 4096;
  function oe(ne) {
    const N = ne.length;
    if (N <= K)
      return String.fromCharCode.apply(String, ne);
    let U = "", le = 0;
    for (; le < N; )
      U += String.fromCharCode.apply(
        String,
        ne.slice(le, le += K)
      );
    return U;
  }
  function be(ne, N, U) {
    let le = "";
    U = Math.min(ne.length, U);
    for (let Ce = N; Ce < U; ++Ce)
      le += String.fromCharCode(ne[Ce] & 127);
    return le;
  }
  function ce(ne, N, U) {
    let le = "";
    U = Math.min(ne.length, U);
    for (let Ce = N; Ce < U; ++Ce)
      le += String.fromCharCode(ne[Ce]);
    return le;
  }
  function pe(ne, N, U) {
    const le = ne.length;
    (!N || N < 0) && (N = 0), (!U || U < 0 || U > le) && (U = le);
    let Ce = "";
    for (let Te = N; Te < U; ++Te)
      Ce += gt[ne[Te]];
    return Ce;
  }
  function Ee(ne, N, U) {
    const le = ne.slice(N, U);
    let Ce = "";
    for (let Te = 0; Te < le.length - 1; Te += 2)
      Ce += String.fromCharCode(le[Te] + le[Te + 1] * 256);
    return Ce;
  }
  p.prototype.slice = function(N, U) {
    const le = this.length;
    N = ~~N, U = U === void 0 ? le : ~~U, N < 0 ? (N += le, N < 0 && (N = 0)) : N > le && (N = le), U < 0 ? (U += le, U < 0 && (U = 0)) : U > le && (U = le), U < N && (U = N);
    const Ce = this.subarray(N, U);
    return Object.setPrototypeOf(Ce, p.prototype), Ce;
  };
  function Se(ne, N, U) {
    if (ne % 1 !== 0 || ne < 0) throw new RangeError("offset is not uint");
    if (ne + N > U) throw new RangeError("Trying to access beyond buffer length");
  }
  p.prototype.readUintLE = p.prototype.readUIntLE = function(N, U, le) {
    N = N >>> 0, U = U >>> 0, le || Se(N, U, this.length);
    let Ce = this[N], Te = 1, Ve = 0;
    for (; ++Ve < U && (Te *= 256); )
      Ce += this[N + Ve] * Te;
    return Ce;
  }, p.prototype.readUintBE = p.prototype.readUIntBE = function(N, U, le) {
    N = N >>> 0, U = U >>> 0, le || Se(N, U, this.length);
    let Ce = this[N + --U], Te = 1;
    for (; U > 0 && (Te *= 256); )
      Ce += this[N + --U] * Te;
    return Ce;
  }, p.prototype.readUint8 = p.prototype.readUInt8 = function(N, U) {
    return N = N >>> 0, U || Se(N, 1, this.length), this[N];
  }, p.prototype.readUint16LE = p.prototype.readUInt16LE = function(N, U) {
    return N = N >>> 0, U || Se(N, 2, this.length), this[N] | this[N + 1] << 8;
  }, p.prototype.readUint16BE = p.prototype.readUInt16BE = function(N, U) {
    return N = N >>> 0, U || Se(N, 2, this.length), this[N] << 8 | this[N + 1];
  }, p.prototype.readUint32LE = p.prototype.readUInt32LE = function(N, U) {
    return N = N >>> 0, U || Se(N, 4, this.length), (this[N] | this[N + 1] << 8 | this[N + 2] << 16) + this[N + 3] * 16777216;
  }, p.prototype.readUint32BE = p.prototype.readUInt32BE = function(N, U) {
    return N = N >>> 0, U || Se(N, 4, this.length), this[N] * 16777216 + (this[N + 1] << 16 | this[N + 2] << 8 | this[N + 3]);
  }, p.prototype.readBigUInt64LE = Ht(function(N) {
    N = N >>> 0, Pn(N, "offset");
    const U = this[N], le = this[N + 7];
    (U === void 0 || le === void 0) && Fn(N, this.length - 8);
    const Ce = U + this[++N] * 2 ** 8 + this[++N] * 2 ** 16 + this[++N] * 2 ** 24, Te = this[++N] + this[++N] * 2 ** 8 + this[++N] * 2 ** 16 + le * 2 ** 24;
    return BigInt(Ce) + (BigInt(Te) << BigInt(32));
  }), p.prototype.readBigUInt64BE = Ht(function(N) {
    N = N >>> 0, Pn(N, "offset");
    const U = this[N], le = this[N + 7];
    (U === void 0 || le === void 0) && Fn(N, this.length - 8);
    const Ce = U * 2 ** 24 + this[++N] * 2 ** 16 + this[++N] * 2 ** 8 + this[++N], Te = this[++N] * 2 ** 24 + this[++N] * 2 ** 16 + this[++N] * 2 ** 8 + le;
    return (BigInt(Ce) << BigInt(32)) + BigInt(Te);
  }), p.prototype.readIntLE = function(N, U, le) {
    N = N >>> 0, U = U >>> 0, le || Se(N, U, this.length);
    let Ce = this[N], Te = 1, Ve = 0;
    for (; ++Ve < U && (Te *= 256); )
      Ce += this[N + Ve] * Te;
    return Te *= 128, Ce >= Te && (Ce -= Math.pow(2, 8 * U)), Ce;
  }, p.prototype.readIntBE = function(N, U, le) {
    N = N >>> 0, U = U >>> 0, le || Se(N, U, this.length);
    let Ce = U, Te = 1, Ve = this[N + --Ce];
    for (; Ce > 0 && (Te *= 256); )
      Ve += this[N + --Ce] * Te;
    return Te *= 128, Ve >= Te && (Ve -= Math.pow(2, 8 * U)), Ve;
  }, p.prototype.readInt8 = function(N, U) {
    return N = N >>> 0, U || Se(N, 1, this.length), this[N] & 128 ? (255 - this[N] + 1) * -1 : this[N];
  }, p.prototype.readInt16LE = function(N, U) {
    N = N >>> 0, U || Se(N, 2, this.length);
    const le = this[N] | this[N + 1] << 8;
    return le & 32768 ? le | 4294901760 : le;
  }, p.prototype.readInt16BE = function(N, U) {
    N = N >>> 0, U || Se(N, 2, this.length);
    const le = this[N + 1] | this[N] << 8;
    return le & 32768 ? le | 4294901760 : le;
  }, p.prototype.readInt32LE = function(N, U) {
    return N = N >>> 0, U || Se(N, 4, this.length), this[N] | this[N + 1] << 8 | this[N + 2] << 16 | this[N + 3] << 24;
  }, p.prototype.readInt32BE = function(N, U) {
    return N = N >>> 0, U || Se(N, 4, this.length), this[N] << 24 | this[N + 1] << 16 | this[N + 2] << 8 | this[N + 3];
  }, p.prototype.readBigInt64LE = Ht(function(N) {
    N = N >>> 0, Pn(N, "offset");
    const U = this[N], le = this[N + 7];
    (U === void 0 || le === void 0) && Fn(N, this.length - 8);
    const Ce = this[N + 4] + this[N + 5] * 2 ** 8 + this[N + 6] * 2 ** 16 + (le << 24);
    return (BigInt(Ce) << BigInt(32)) + BigInt(U + this[++N] * 2 ** 8 + this[++N] * 2 ** 16 + this[++N] * 2 ** 24);
  }), p.prototype.readBigInt64BE = Ht(function(N) {
    N = N >>> 0, Pn(N, "offset");
    const U = this[N], le = this[N + 7];
    (U === void 0 || le === void 0) && Fn(N, this.length - 8);
    const Ce = (U << 24) + // Overflow
    this[++N] * 2 ** 16 + this[++N] * 2 ** 8 + this[++N];
    return (BigInt(Ce) << BigInt(32)) + BigInt(this[++N] * 2 ** 24 + this[++N] * 2 ** 16 + this[++N] * 2 ** 8 + le);
  }), p.prototype.readFloatLE = function(N, U) {
    return N = N >>> 0, U || Se(N, 4, this.length), n.read(this, N, !0, 23, 4);
  }, p.prototype.readFloatBE = function(N, U) {
    return N = N >>> 0, U || Se(N, 4, this.length), n.read(this, N, !1, 23, 4);
  }, p.prototype.readDoubleLE = function(N, U) {
    return N = N >>> 0, U || Se(N, 8, this.length), n.read(this, N, !0, 52, 8);
  }, p.prototype.readDoubleBE = function(N, U) {
    return N = N >>> 0, U || Se(N, 8, this.length), n.read(this, N, !1, 52, 8);
  };
  function Me(ne, N, U, le, Ce, Te) {
    if (!p.isBuffer(ne)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (N > Ce || N < Te) throw new RangeError('"value" argument is out of bounds');
    if (U + le > ne.length) throw new RangeError("Index out of range");
  }
  p.prototype.writeUintLE = p.prototype.writeUIntLE = function(N, U, le, Ce) {
    if (N = +N, U = U >>> 0, le = le >>> 0, !Ce) {
      const kt = Math.pow(2, 8 * le) - 1;
      Me(this, N, U, le, kt, 0);
    }
    let Te = 1, Ve = 0;
    for (this[U] = N & 255; ++Ve < le && (Te *= 256); )
      this[U + Ve] = N / Te & 255;
    return U + le;
  }, p.prototype.writeUintBE = p.prototype.writeUIntBE = function(N, U, le, Ce) {
    if (N = +N, U = U >>> 0, le = le >>> 0, !Ce) {
      const kt = Math.pow(2, 8 * le) - 1;
      Me(this, N, U, le, kt, 0);
    }
    let Te = le - 1, Ve = 1;
    for (this[U + Te] = N & 255; --Te >= 0 && (Ve *= 256); )
      this[U + Te] = N / Ve & 255;
    return U + le;
  }, p.prototype.writeUint8 = p.prototype.writeUInt8 = function(N, U, le) {
    return N = +N, U = U >>> 0, le || Me(this, N, U, 1, 255, 0), this[U] = N & 255, U + 1;
  }, p.prototype.writeUint16LE = p.prototype.writeUInt16LE = function(N, U, le) {
    return N = +N, U = U >>> 0, le || Me(this, N, U, 2, 65535, 0), this[U] = N & 255, this[U + 1] = N >>> 8, U + 2;
  }, p.prototype.writeUint16BE = p.prototype.writeUInt16BE = function(N, U, le) {
    return N = +N, U = U >>> 0, le || Me(this, N, U, 2, 65535, 0), this[U] = N >>> 8, this[U + 1] = N & 255, U + 2;
  }, p.prototype.writeUint32LE = p.prototype.writeUInt32LE = function(N, U, le) {
    return N = +N, U = U >>> 0, le || Me(this, N, U, 4, 4294967295, 0), this[U + 3] = N >>> 24, this[U + 2] = N >>> 16, this[U + 1] = N >>> 8, this[U] = N & 255, U + 4;
  }, p.prototype.writeUint32BE = p.prototype.writeUInt32BE = function(N, U, le) {
    return N = +N, U = U >>> 0, le || Me(this, N, U, 4, 4294967295, 0), this[U] = N >>> 24, this[U + 1] = N >>> 16, this[U + 2] = N >>> 8, this[U + 3] = N & 255, U + 4;
  };
  function Fe(ne, N, U, le, Ce) {
    zt(N, le, Ce, ne, U, 7);
    let Te = Number(N & BigInt(4294967295));
    ne[U++] = Te, Te = Te >> 8, ne[U++] = Te, Te = Te >> 8, ne[U++] = Te, Te = Te >> 8, ne[U++] = Te;
    let Ve = Number(N >> BigInt(32) & BigInt(4294967295));
    return ne[U++] = Ve, Ve = Ve >> 8, ne[U++] = Ve, Ve = Ve >> 8, ne[U++] = Ve, Ve = Ve >> 8, ne[U++] = Ve, U;
  }
  function st(ne, N, U, le, Ce) {
    zt(N, le, Ce, ne, U, 7);
    let Te = Number(N & BigInt(4294967295));
    ne[U + 7] = Te, Te = Te >> 8, ne[U + 6] = Te, Te = Te >> 8, ne[U + 5] = Te, Te = Te >> 8, ne[U + 4] = Te;
    let Ve = Number(N >> BigInt(32) & BigInt(4294967295));
    return ne[U + 3] = Ve, Ve = Ve >> 8, ne[U + 2] = Ve, Ve = Ve >> 8, ne[U + 1] = Ve, Ve = Ve >> 8, ne[U] = Ve, U + 8;
  }
  p.prototype.writeBigUInt64LE = Ht(function(N, U = 0) {
    return Fe(this, N, U, BigInt(0), BigInt("0xffffffffffffffff"));
  }), p.prototype.writeBigUInt64BE = Ht(function(N, U = 0) {
    return st(this, N, U, BigInt(0), BigInt("0xffffffffffffffff"));
  }), p.prototype.writeIntLE = function(N, U, le, Ce) {
    if (N = +N, U = U >>> 0, !Ce) {
      const bn = Math.pow(2, 8 * le - 1);
      Me(this, N, U, le, bn - 1, -bn);
    }
    let Te = 0, Ve = 1, kt = 0;
    for (this[U] = N & 255; ++Te < le && (Ve *= 256); )
      N < 0 && kt === 0 && this[U + Te - 1] !== 0 && (kt = 1), this[U + Te] = (N / Ve >> 0) - kt & 255;
    return U + le;
  }, p.prototype.writeIntBE = function(N, U, le, Ce) {
    if (N = +N, U = U >>> 0, !Ce) {
      const bn = Math.pow(2, 8 * le - 1);
      Me(this, N, U, le, bn - 1, -bn);
    }
    let Te = le - 1, Ve = 1, kt = 0;
    for (this[U + Te] = N & 255; --Te >= 0 && (Ve *= 256); )
      N < 0 && kt === 0 && this[U + Te + 1] !== 0 && (kt = 1), this[U + Te] = (N / Ve >> 0) - kt & 255;
    return U + le;
  }, p.prototype.writeInt8 = function(N, U, le) {
    return N = +N, U = U >>> 0, le || Me(this, N, U, 1, 127, -128), N < 0 && (N = 255 + N + 1), this[U] = N & 255, U + 1;
  }, p.prototype.writeInt16LE = function(N, U, le) {
    return N = +N, U = U >>> 0, le || Me(this, N, U, 2, 32767, -32768), this[U] = N & 255, this[U + 1] = N >>> 8, U + 2;
  }, p.prototype.writeInt16BE = function(N, U, le) {
    return N = +N, U = U >>> 0, le || Me(this, N, U, 2, 32767, -32768), this[U] = N >>> 8, this[U + 1] = N & 255, U + 2;
  }, p.prototype.writeInt32LE = function(N, U, le) {
    return N = +N, U = U >>> 0, le || Me(this, N, U, 4, 2147483647, -2147483648), this[U] = N & 255, this[U + 1] = N >>> 8, this[U + 2] = N >>> 16, this[U + 3] = N >>> 24, U + 4;
  }, p.prototype.writeInt32BE = function(N, U, le) {
    return N = +N, U = U >>> 0, le || Me(this, N, U, 4, 2147483647, -2147483648), N < 0 && (N = 4294967295 + N + 1), this[U] = N >>> 24, this[U + 1] = N >>> 16, this[U + 2] = N >>> 8, this[U + 3] = N & 255, U + 4;
  }, p.prototype.writeBigInt64LE = Ht(function(N, U = 0) {
    return Fe(this, N, U, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), p.prototype.writeBigInt64BE = Ht(function(N, U = 0) {
    return st(this, N, U, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function mt(ne, N, U, le, Ce, Te) {
    if (U + le > ne.length) throw new RangeError("Index out of range");
    if (U < 0) throw new RangeError("Index out of range");
  }
  function yt(ne, N, U, le, Ce) {
    return N = +N, U = U >>> 0, Ce || mt(ne, N, U, 4), n.write(ne, N, U, le, 23, 4), U + 4;
  }
  p.prototype.writeFloatLE = function(N, U, le) {
    return yt(this, N, U, !0, le);
  }, p.prototype.writeFloatBE = function(N, U, le) {
    return yt(this, N, U, !1, le);
  };
  function Ut(ne, N, U, le, Ce) {
    return N = +N, U = U >>> 0, Ce || mt(ne, N, U, 8), n.write(ne, N, U, le, 52, 8), U + 8;
  }
  p.prototype.writeDoubleLE = function(N, U, le) {
    return Ut(this, N, U, !0, le);
  }, p.prototype.writeDoubleBE = function(N, U, le) {
    return Ut(this, N, U, !1, le);
  }, p.prototype.copy = function(N, U, le, Ce) {
    if (!p.isBuffer(N)) throw new TypeError("argument should be a Buffer");
    if (le || (le = 0), !Ce && Ce !== 0 && (Ce = this.length), U >= N.length && (U = N.length), U || (U = 0), Ce > 0 && Ce < le && (Ce = le), Ce === le || N.length === 0 || this.length === 0) return 0;
    if (U < 0)
      throw new RangeError("targetStart out of bounds");
    if (le < 0 || le >= this.length) throw new RangeError("Index out of range");
    if (Ce < 0) throw new RangeError("sourceEnd out of bounds");
    Ce > this.length && (Ce = this.length), N.length - U < Ce - le && (Ce = N.length - U + le);
    const Te = Ce - le;
    return this === N && typeof o.prototype.copyWithin == "function" ? this.copyWithin(U, le, Ce) : o.prototype.set.call(
      N,
      this.subarray(le, Ce),
      U
    ), Te;
  }, p.prototype.fill = function(N, U, le, Ce) {
    if (typeof N == "string") {
      if (typeof U == "string" ? (Ce = U, U = 0, le = this.length) : typeof le == "string" && (Ce = le, le = this.length), Ce !== void 0 && typeof Ce != "string")
        throw new TypeError("encoding must be a string");
      if (typeof Ce == "string" && !p.isEncoding(Ce))
        throw new TypeError("Unknown encoding: " + Ce);
      if (N.length === 1) {
        const Ve = N.charCodeAt(0);
        (Ce === "utf8" && Ve < 128 || Ce === "latin1") && (N = Ve);
      }
    } else typeof N == "number" ? N = N & 255 : typeof N == "boolean" && (N = Number(N));
    if (U < 0 || this.length < U || this.length < le)
      throw new RangeError("Out of range index");
    if (le <= U)
      return this;
    U = U >>> 0, le = le === void 0 ? this.length : le >>> 0, N || (N = 0);
    let Te;
    if (typeof N == "number")
      for (Te = U; Te < le; ++Te)
        this[Te] = N;
    else {
      const Ve = p.isBuffer(N) ? N : p.from(N, Ce), kt = Ve.length;
      if (kt === 0)
        throw new TypeError('The value "' + N + '" is invalid for argument "value"');
      for (Te = 0; Te < le - U; ++Te)
        this[Te + U] = Ve[Te % kt];
    }
    return this;
  };
  const hn = {};
  function wn(ne, N, U) {
    hn[ne] = class extends U {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: N.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${ne}]`, this.stack, delete this.name;
      }
      get code() {
        return ne;
      }
      set code(Ce) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: Ce,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${ne}]: ${this.message}`;
      }
    };
  }
  wn(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(ne) {
      return ne ? `${ne} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), wn(
    "ERR_INVALID_ARG_TYPE",
    function(ne, N) {
      return `The "${ne}" argument must be of type number. Received type ${typeof N}`;
    },
    TypeError
  ), wn(
    "ERR_OUT_OF_RANGE",
    function(ne, N, U) {
      let le = `The value of "${ne}" is out of range.`, Ce = U;
      return Number.isInteger(U) && Math.abs(U) > 2 ** 32 ? Ce = Ot(String(U)) : typeof U == "bigint" && (Ce = String(U), (U > BigInt(2) ** BigInt(32) || U < -(BigInt(2) ** BigInt(32))) && (Ce = Ot(Ce)), Ce += "n"), le += ` It must be ${N}. Received ${Ce}`, le;
    },
    RangeError
  );
  function Ot(ne) {
    let N = "", U = ne.length;
    const le = ne[0] === "-" ? 1 : 0;
    for (; U >= le + 4; U -= 3)
      N = `_${ne.slice(U - 3, U)}${N}`;
    return `${ne.slice(0, U)}${N}`;
  }
  function xt(ne, N, U) {
    Pn(N, "offset"), (ne[N] === void 0 || ne[N + U] === void 0) && Fn(N, ne.length - (U + 1));
  }
  function zt(ne, N, U, le, Ce, Te) {
    if (ne > U || ne < N) {
      const Ve = typeof N == "bigint" ? "n" : "";
      let kt;
      throw N === 0 || N === BigInt(0) ? kt = `>= 0${Ve} and < 2${Ve} ** ${(Te + 1) * 8}${Ve}` : kt = `>= -(2${Ve} ** ${(Te + 1) * 8 - 1}${Ve}) and < 2 ** ${(Te + 1) * 8 - 1}${Ve}`, new hn.ERR_OUT_OF_RANGE("value", kt, ne);
    }
    xt(le, Ce, Te);
  }
  function Pn(ne, N) {
    if (typeof ne != "number")
      throw new hn.ERR_INVALID_ARG_TYPE(N, "number", ne);
  }
  function Fn(ne, N, U) {
    throw Math.floor(ne) !== ne ? (Pn(ne, U), new hn.ERR_OUT_OF_RANGE("offset", "an integer", ne)) : N < 0 ? new hn.ERR_BUFFER_OUT_OF_BOUNDS() : new hn.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${N}`,
      ne
    );
  }
  const tr = /[^+/0-9A-Za-z-_]/g;
  function or(ne) {
    if (ne = ne.split("=")[0], ne = ne.trim().replace(tr, ""), ne.length < 2) return "";
    for (; ne.length % 4 !== 0; )
      ne = ne + "=";
    return ne;
  }
  function ar(ne, N) {
    N = N || 1 / 0;
    let U;
    const le = ne.length;
    let Ce = null;
    const Te = [];
    for (let Ve = 0; Ve < le; ++Ve) {
      if (U = ne.charCodeAt(Ve), U > 55295 && U < 57344) {
        if (!Ce) {
          if (U > 56319) {
            (N -= 3) > -1 && Te.push(239, 191, 189);
            continue;
          } else if (Ve + 1 === le) {
            (N -= 3) > -1 && Te.push(239, 191, 189);
            continue;
          }
          Ce = U;
          continue;
        }
        if (U < 56320) {
          (N -= 3) > -1 && Te.push(239, 191, 189), Ce = U;
          continue;
        }
        U = (Ce - 55296 << 10 | U - 56320) + 65536;
      } else Ce && (N -= 3) > -1 && Te.push(239, 191, 189);
      if (Ce = null, U < 128) {
        if ((N -= 1) < 0) break;
        Te.push(U);
      } else if (U < 2048) {
        if ((N -= 2) < 0) break;
        Te.push(
          U >> 6 | 192,
          U & 63 | 128
        );
      } else if (U < 65536) {
        if ((N -= 3) < 0) break;
        Te.push(
          U >> 12 | 224,
          U >> 6 & 63 | 128,
          U & 63 | 128
        );
      } else if (U < 1114112) {
        if ((N -= 4) < 0) break;
        Te.push(
          U >> 18 | 240,
          U >> 12 & 63 | 128,
          U >> 6 & 63 | 128,
          U & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return Te;
  }
  function Cr(ne) {
    const N = [];
    for (let U = 0; U < ne.length; ++U)
      N.push(ne.charCodeAt(U) & 255);
    return N;
  }
  function Un(ne, N) {
    let U, le, Ce;
    const Te = [];
    for (let Ve = 0; Ve < ne.length && !((N -= 2) < 0); ++Ve)
      U = ne.charCodeAt(Ve), le = U >> 8, Ce = U % 256, Te.push(Ce), Te.push(le);
    return Te;
  }
  function $n(ne) {
    return t.toByteArray(or(ne));
  }
  function gr(ne, N, U, le) {
    let Ce;
    for (Ce = 0; Ce < le && !(Ce + U >= N.length || Ce >= ne.length); ++Ce)
      N[Ce + U] = ne[Ce];
    return Ce;
  }
  function Tt(ne, N) {
    return ne instanceof N || ne != null && ne.constructor != null && ne.constructor.name != null && ne.constructor.name === N.name;
  }
  function qt(ne) {
    return ne !== ne;
  }
  const gt = function() {
    const ne = "0123456789abcdef", N = new Array(256);
    for (let U = 0; U < 16; ++U) {
      const le = U * 16;
      for (let Ce = 0; Ce < 16; ++Ce)
        N[le + Ce] = ne[U] + ne[Ce];
    }
    return N;
  }();
  function Ht(ne) {
    return typeof BigInt > "u" ? br : ne;
  }
  function br() {
    throw new Error("BigInt not supported");
  }
})(Io);
const DV = Io.Buffer, Jle = Io.Blob, Zle = Io.BlobOptions, ece = Io.Buffer, tce = Io.File, nce = Io.FileOptions, rce = Io.INSPECT_MAX_BYTES, ice = Io.SlowBuffer, oce = Io.TranscodeEncoding, ace = Io.atob, sce = Io.btoa, lce = Io.constants, cce = Io.isAscii, uce = Io.isUtf8, dce = Io.kMaxLength, fce = Io.kStringMaxLength, hce = Io.resolveObjectURL, pce = Io.transcode, uje = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Blob: Jle,
  BlobOptions: Zle,
  Buffer: ece,
  File: tce,
  FileOptions: nce,
  INSPECT_MAX_BYTES: rce,
  SlowBuffer: ice,
  TranscodeEncoding: oce,
  atob: ace,
  btoa: sce,
  constants: lce,
  default: DV,
  isAscii: cce,
  isUtf8: uce,
  kMaxLength: dce,
  kStringMaxLength: fce,
  resolveObjectURL: hce,
  transcode: pce
}, Symbol.toStringTag, { value: "Module" }));
function qn(e, t, n, r, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), i && (this.response = i, this.status = i.status ? i.status : null);
}
Xe.inherits(qn, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: Xe.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const MV = qn.prototype, PV = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  PV[e] = { value: e };
});
Object.defineProperties(qn, PV);
Object.defineProperty(MV, "isAxiosError", { value: !0 });
qn.from = (e, t, n, r, i, o) => {
  const s = Object.create(MV);
  return Xe.toFlatObject(e, s, function(u) {
    return u !== Error.prototype;
  }, (c) => c !== "isAxiosError"), qn.call(s, e.message, t, n, r, i), s.cause = e, s.name = e.name, o && Object.assign(s, o), s;
};
const mce = null;
function KI(e) {
  return Xe.isPlainObject(e) || Xe.isArray(e);
}
function NV(e) {
  return Xe.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function Sj(e, t, n) {
  return e ? e.concat(t).map(function(i, o) {
    return i = NV(i), !n && o ? "[" + i + "]" : i;
  }).join(n ? "." : "") : t;
}
function yce(e) {
  return Xe.isArray(e) && !e.some(KI);
}
const vce = Xe.toFlatObject(Xe, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function C8(e, t, n) {
  if (!Xe.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), n = Xe.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(x, A) {
    return !Xe.isUndefined(A[x]);
  });
  const r = n.metaTokens, i = n.visitor || p, o = n.dots, s = n.indexes, u = (n.Blob || typeof Blob < "u" && Blob) && Xe.isSpecCompliantForm(t);
  if (!Xe.isFunction(i))
    throw new TypeError("visitor must be a function");
  function f(C) {
    if (C === null) return "";
    if (Xe.isDate(C))
      return C.toISOString();
    if (!u && Xe.isBlob(C))
      throw new qn("Blob is not supported. Use a Buffer instead.");
    return Xe.isArrayBuffer(C) || Xe.isTypedArray(C) ? u && typeof Blob == "function" ? new Blob([C]) : DV.from(C) : C;
  }
  function p(C, x, A) {
    let R = C;
    if (C && !A && typeof C == "object") {
      if (Xe.endsWith(x, "{}"))
        x = r ? x : x.slice(0, -2), C = JSON.stringify(C);
      else if (Xe.isArray(C) && yce(C) || (Xe.isFileList(C) || Xe.endsWith(x, "[]")) && (R = Xe.toArray(C)))
        return x = NV(x), R.forEach(function(D, M) {
          !(Xe.isUndefined(D) || D === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            s === !0 ? Sj([x], M, o) : s === null ? x : x + "[]",
            f(D)
          );
        }), !1;
    }
    return KI(C) ? !0 : (t.append(Sj(A, x, o), f(C)), !1);
  }
  const y = [], v = Object.assign(vce, {
    defaultVisitor: p,
    convertValue: f,
    isVisitable: KI
  });
  function w(C, x) {
    if (!Xe.isUndefined(C)) {
      if (y.indexOf(C) !== -1)
        throw Error("Circular reference detected in " + x.join("."));
      y.push(C), Xe.forEach(C, function(R, I) {
        (!(Xe.isUndefined(R) || R === null) && i.call(
          t,
          R,
          Xe.isString(I) ? I.trim() : I,
          x,
          v
        )) === !0 && w(R, x ? x.concat(I) : [I]);
      }), y.pop();
    }
  }
  if (!Xe.isObject(e))
    throw new TypeError("data must be an object");
  return w(e), t;
}
function kj(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(r) {
    return t[r];
  });
}
function JD(e, t) {
  this._pairs = [], e && C8(e, this, t);
}
const BV = JD.prototype;
BV.append = function(t, n) {
  this._pairs.push([t, n]);
};
BV.toString = function(t) {
  const n = t ? function(r) {
    return t.call(this, r, kj);
  } : kj;
  return this._pairs.map(function(i) {
    return n(i[0]) + "=" + n(i[1]);
  }, "").join("&");
};
function gce(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function LV(e, t, n) {
  if (!t)
    return e;
  const r = n && n.encode || gce, i = n && n.serialize;
  let o;
  if (i ? o = i(t, n) : o = Xe.isURLSearchParams(t) ? t.toString() : new JD(t, n).toString(r), o) {
    const s = e.indexOf("#");
    s !== -1 && (e = e.slice(0, s)), e += (e.indexOf("?") === -1 ? "?" : "&") + o;
  }
  return e;
}
class Aj {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, n, r) {
    return this.handlers.push({
      fulfilled: t,
      rejected: n,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    Xe.forEach(this.handlers, function(r) {
      r !== null && t(r);
    });
  }
}
const jV = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, bce = typeof URLSearchParams < "u" ? URLSearchParams : JD, wce = typeof FormData < "u" ? FormData : null, Cce = typeof Blob < "u" ? Blob : null, xce = {
  isBrowser: !0,
  classes: {
    URLSearchParams: bce,
    FormData: wce,
    Blob: Cce
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, ZD = typeof window < "u" && typeof document < "u", YI = typeof navigator == "object" && navigator || void 0, Ece = ZD && (!YI || ["ReactNative", "NativeScript", "NS"].indexOf(YI.product) < 0), Sce = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", kce = ZD && window.location.href || "http://localhost", Ace = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: ZD,
  hasStandardBrowserEnv: Ece,
  hasStandardBrowserWebWorkerEnv: Sce,
  navigator: YI,
  origin: kce
}, Symbol.toStringTag, { value: "Module" })), Vs = {
  ...Ace,
  ...xce
};
function Tce(e, t) {
  return C8(e, new Vs.classes.URLSearchParams(), Object.assign({
    visitor: function(n, r, i, o) {
      return Vs.isNode && Xe.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : o.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function _ce(e) {
  return Xe.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function Rce(e) {
  const t = {}, n = Object.keys(e);
  let r;
  const i = n.length;
  let o;
  for (r = 0; r < i; r++)
    o = n[r], t[o] = e[o];
  return t;
}
function FV(e) {
  function t(n, r, i, o) {
    let s = n[o++];
    if (s === "__proto__") return !0;
    const c = Number.isFinite(+s), u = o >= n.length;
    return s = !s && Xe.isArray(i) ? i.length : s, u ? (Xe.hasOwnProp(i, s) ? i[s] = [i[s], r] : i[s] = r, !c) : ((!i[s] || !Xe.isObject(i[s])) && (i[s] = []), t(n, r, i[s], o) && Xe.isArray(i[s]) && (i[s] = Rce(i[s])), !c);
  }
  if (Xe.isFormData(e) && Xe.isFunction(e.entries)) {
    const n = {};
    return Xe.forEachEntry(e, (r, i) => {
      t(_ce(r), i, n, 0);
    }), n;
  }
  return null;
}
function Oce(e, t, n) {
  if (Xe.isString(e))
    try {
      return (t || JSON.parse)(e), Xe.trim(e);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (n || JSON.stringify)(e);
}
const PC = {
  transitional: jV,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(t, n) {
    const r = n.getContentType() || "", i = r.indexOf("application/json") > -1, o = Xe.isObject(t);
    if (o && Xe.isHTMLForm(t) && (t = new FormData(t)), Xe.isFormData(t))
      return i ? JSON.stringify(FV(t)) : t;
    if (Xe.isArrayBuffer(t) || Xe.isBuffer(t) || Xe.isStream(t) || Xe.isFile(t) || Xe.isBlob(t) || Xe.isReadableStream(t))
      return t;
    if (Xe.isArrayBufferView(t))
      return t.buffer;
    if (Xe.isURLSearchParams(t))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let c;
    if (o) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return Tce(t, this.formSerializer).toString();
      if ((c = Xe.isFileList(t)) || r.indexOf("multipart/form-data") > -1) {
        const u = this.env && this.env.FormData;
        return C8(
          c ? { "files[]": t } : t,
          u && new u(),
          this.formSerializer
        );
      }
    }
    return o || i ? (n.setContentType("application/json", !1), Oce(t)) : t;
  }],
  transformResponse: [function(t) {
    const n = this.transitional || PC.transitional, r = n && n.forcedJSONParsing, i = this.responseType === "json";
    if (Xe.isResponse(t) || Xe.isReadableStream(t))
      return t;
    if (t && Xe.isString(t) && (r && !this.responseType || i)) {
      const s = !(n && n.silentJSONParsing) && i;
      try {
        return JSON.parse(t);
      } catch (c) {
        if (s)
          throw c.name === "SyntaxError" ? qn.from(c, qn.ERR_BAD_RESPONSE, this, null, this.response) : c;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Vs.classes.FormData,
    Blob: Vs.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
Xe.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  PC.headers[e] = {};
});
const Ice = Xe.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), Dce = (e) => {
  const t = {};
  let n, r, i;
  return e && e.split(`
`).forEach(function(s) {
    i = s.indexOf(":"), n = s.substring(0, i).trim().toLowerCase(), r = s.substring(i + 1).trim(), !(!n || t[n] && Ice[n]) && (n === "set-cookie" ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r);
  }), t;
}, Tj = Symbol("internals");
function i1(e) {
  return e && String(e).trim().toLowerCase();
}
function n4(e) {
  return e === !1 || e == null ? e : Xe.isArray(e) ? e.map(n4) : String(e);
}
function Mce(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = n.exec(e); )
    t[r[1]] = r[2];
  return t;
}
const Pce = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function NR(e, t, n, r, i) {
  if (Xe.isFunction(r))
    return r.call(this, t, n);
  if (i && (t = n), !!Xe.isString(t)) {
    if (Xe.isString(r))
      return t.indexOf(r) !== -1;
    if (Xe.isRegExp(r))
      return r.test(t);
  }
}
function Nce(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r);
}
function Bce(e, t) {
  const n = Xe.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(e, r + n, {
      value: function(i, o, s) {
        return this[r].call(this, t, i, o, s);
      },
      configurable: !0
    });
  });
}
let $s = class {
  constructor(t) {
    t && this.set(t);
  }
  set(t, n, r) {
    const i = this;
    function o(c, u, f) {
      const p = i1(u);
      if (!p)
        throw new Error("header name must be a non-empty string");
      const y = Xe.findKey(i, p);
      (!y || i[y] === void 0 || f === !0 || f === void 0 && i[y] !== !1) && (i[y || u] = n4(c));
    }
    const s = (c, u) => Xe.forEach(c, (f, p) => o(f, p, u));
    if (Xe.isPlainObject(t) || t instanceof this.constructor)
      s(t, n);
    else if (Xe.isString(t) && (t = t.trim()) && !Pce(t))
      s(Dce(t), n);
    else if (Xe.isHeaders(t))
      for (const [c, u] of t.entries())
        o(u, c, r);
    else
      t != null && o(n, t, r);
    return this;
  }
  get(t, n) {
    if (t = i1(t), t) {
      const r = Xe.findKey(this, t);
      if (r) {
        const i = this[r];
        if (!n)
          return i;
        if (n === !0)
          return Mce(i);
        if (Xe.isFunction(n))
          return n.call(this, i, r);
        if (Xe.isRegExp(n))
          return n.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, n) {
    if (t = i1(t), t) {
      const r = Xe.findKey(this, t);
      return !!(r && this[r] !== void 0 && (!n || NR(this, this[r], r, n)));
    }
    return !1;
  }
  delete(t, n) {
    const r = this;
    let i = !1;
    function o(s) {
      if (s = i1(s), s) {
        const c = Xe.findKey(r, s);
        c && (!n || NR(r, r[c], c, n)) && (delete r[c], i = !0);
      }
    }
    return Xe.isArray(t) ? t.forEach(o) : o(t), i;
  }
  clear(t) {
    const n = Object.keys(this);
    let r = n.length, i = !1;
    for (; r--; ) {
      const o = n[r];
      (!t || NR(this, this[o], o, t, !0)) && (delete this[o], i = !0);
    }
    return i;
  }
  normalize(t) {
    const n = this, r = {};
    return Xe.forEach(this, (i, o) => {
      const s = Xe.findKey(r, o);
      if (s) {
        n[s] = n4(i), delete n[o];
        return;
      }
      const c = t ? Nce(o) : String(o).trim();
      c !== o && delete n[o], n[c] = n4(i), r[c] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const n = /* @__PURE__ */ Object.create(null);
    return Xe.forEach(this, (r, i) => {
      r != null && r !== !1 && (n[i] = t && Xe.isArray(r) ? r.join(", ") : r);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...n) {
    const r = new this(t);
    return n.forEach((i) => r.set(i)), r;
  }
  static accessor(t) {
    const r = (this[Tj] = this[Tj] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function o(s) {
      const c = i1(s);
      r[c] || (Bce(i, s), r[c] = !0);
    }
    return Xe.isArray(t) ? t.forEach(o) : o(t), this;
  }
};
$s.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
Xe.reduceDescriptors($s.prototype, ({ value: e }, t) => {
  let n = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(r) {
      this[n] = r;
    }
  };
});
Xe.freezeMethods($s);
function BR(e, t) {
  const n = this || PC, r = t || n, i = $s.from(r.headers);
  let o = r.data;
  return Xe.forEach(e, function(c) {
    o = c.call(n, o, i.normalize(), t ? t.status : void 0);
  }), i.normalize(), o;
}
function UV(e) {
  return !!(e && e.__CANCEL__);
}
function Mb(e, t, n) {
  qn.call(this, e ?? "canceled", qn.ERR_CANCELED, t, n), this.name = "CanceledError";
}
Xe.inherits(Mb, qn, {
  __CANCEL__: !0
});
function zV(e, t, n) {
  const r = n.config.validateStatus;
  !n.status || !r || r(n.status) ? e(n) : t(new qn(
    "Request failed with status code " + n.status,
    [qn.ERR_BAD_REQUEST, qn.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
function Lce(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function jce(e, t) {
  e = e || 10;
  const n = new Array(e), r = new Array(e);
  let i = 0, o = 0, s;
  return t = t !== void 0 ? t : 1e3, function(u) {
    const f = Date.now(), p = r[o];
    s || (s = f), n[i] = u, r[i] = f;
    let y = o, v = 0;
    for (; y !== i; )
      v += n[y++], y = y % e;
    if (i = (i + 1) % e, i === o && (o = (o + 1) % e), f - s < t)
      return;
    const w = p && f - p;
    return w ? Math.round(v * 1e3 / w) : void 0;
  };
}
function Fce(e, t) {
  let n = 0, r = 1e3 / t, i, o;
  const s = (f, p = Date.now()) => {
    n = p, i = null, o && (clearTimeout(o), o = null), e.apply(null, f);
  };
  return [(...f) => {
    const p = Date.now(), y = p - n;
    y >= r ? s(f, p) : (i = f, o || (o = setTimeout(() => {
      o = null, s(i);
    }, r - y)));
  }, () => i && s(i)];
}
const R4 = (e, t, n = 3) => {
  let r = 0;
  const i = jce(50, 250);
  return Fce((o) => {
    const s = o.loaded, c = o.lengthComputable ? o.total : void 0, u = s - r, f = i(u), p = s <= c;
    r = s;
    const y = {
      loaded: s,
      total: c,
      progress: c ? s / c : void 0,
      bytes: u,
      rate: f || void 0,
      estimated: f && c && p ? (c - s) / f : void 0,
      event: o,
      lengthComputable: c != null,
      [t ? "download" : "upload"]: !0
    };
    e(y);
  }, n);
}, _j = (e, t) => {
  const n = e != null;
  return [(r) => t[0]({
    lengthComputable: n,
    total: e,
    loaded: r
  }), t[1]];
}, Rj = (e) => (...t) => Xe.asap(() => e(...t)), Uce = Vs.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const t = Vs.navigator && /(msie|trident)/i.test(Vs.navigator.userAgent), n = document.createElement("a");
    let r;
    function i(o) {
      let s = o;
      return t && (n.setAttribute("href", s), s = n.href), n.setAttribute("href", s), {
        href: n.href,
        protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
        host: n.host,
        search: n.search ? n.search.replace(/^\?/, "") : "",
        hash: n.hash ? n.hash.replace(/^#/, "") : "",
        hostname: n.hostname,
        port: n.port,
        pathname: n.pathname.charAt(0) === "/" ? n.pathname : "/" + n.pathname
      };
    }
    return r = i(window.location.href), function(s) {
      const c = Xe.isString(s) ? i(s) : s;
      return c.protocol === r.protocol && c.host === r.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function() {
    return function() {
      return !0;
    };
  }()
), zce = Vs.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, n, r, i, o) {
      const s = [e + "=" + encodeURIComponent(t)];
      Xe.isNumber(n) && s.push("expires=" + new Date(n).toGMTString()), Xe.isString(r) && s.push("path=" + r), Xe.isString(i) && s.push("domain=" + i), o === !0 && s.push("secure"), document.cookie = s.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function Vce(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function $ce(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function VV(e, t) {
  return e && !Vce(t) ? $ce(e, t) : t;
}
const Oj = (e) => e instanceof $s ? { ...e } : e;
function Gm(e, t) {
  t = t || {};
  const n = {};
  function r(f, p, y) {
    return Xe.isPlainObject(f) && Xe.isPlainObject(p) ? Xe.merge.call({ caseless: y }, f, p) : Xe.isPlainObject(p) ? Xe.merge({}, p) : Xe.isArray(p) ? p.slice() : p;
  }
  function i(f, p, y) {
    if (Xe.isUndefined(p)) {
      if (!Xe.isUndefined(f))
        return r(void 0, f, y);
    } else return r(f, p, y);
  }
  function o(f, p) {
    if (!Xe.isUndefined(p))
      return r(void 0, p);
  }
  function s(f, p) {
    if (Xe.isUndefined(p)) {
      if (!Xe.isUndefined(f))
        return r(void 0, f);
    } else return r(void 0, p);
  }
  function c(f, p, y) {
    if (y in t)
      return r(f, p);
    if (y in e)
      return r(void 0, f);
  }
  const u = {
    url: o,
    method: o,
    data: o,
    baseURL: s,
    transformRequest: s,
    transformResponse: s,
    paramsSerializer: s,
    timeout: s,
    timeoutMessage: s,
    withCredentials: s,
    withXSRFToken: s,
    adapter: s,
    responseType: s,
    xsrfCookieName: s,
    xsrfHeaderName: s,
    onUploadProgress: s,
    onDownloadProgress: s,
    decompress: s,
    maxContentLength: s,
    maxBodyLength: s,
    beforeRedirect: s,
    transport: s,
    httpAgent: s,
    httpsAgent: s,
    cancelToken: s,
    socketPath: s,
    responseEncoding: s,
    validateStatus: c,
    headers: (f, p) => i(Oj(f), Oj(p), !0)
  };
  return Xe.forEach(Object.keys(Object.assign({}, e, t)), function(p) {
    const y = u[p] || i, v = y(e[p], t[p], p);
    Xe.isUndefined(v) && y !== c || (n[p] = v);
  }), n;
}
const $V = (e) => {
  const t = Gm({}, e);
  let { data: n, withXSRFToken: r, xsrfHeaderName: i, xsrfCookieName: o, headers: s, auth: c } = t;
  t.headers = s = $s.from(s), t.url = LV(VV(t.baseURL, t.url), e.params, e.paramsSerializer), c && s.set(
    "Authorization",
    "Basic " + btoa((c.username || "") + ":" + (c.password ? unescape(encodeURIComponent(c.password)) : ""))
  );
  let u;
  if (Xe.isFormData(n)) {
    if (Vs.hasStandardBrowserEnv || Vs.hasStandardBrowserWebWorkerEnv)
      s.setContentType(void 0);
    else if ((u = s.getContentType()) !== !1) {
      const [f, ...p] = u ? u.split(";").map((y) => y.trim()).filter(Boolean) : [];
      s.setContentType([f || "multipart/form-data", ...p].join("; "));
    }
  }
  if (Vs.hasStandardBrowserEnv && (r && Xe.isFunction(r) && (r = r(t)), r || r !== !1 && Uce(t.url))) {
    const f = i && o && zce.read(o);
    f && s.set(i, f);
  }
  return t;
}, Hce = typeof XMLHttpRequest < "u", qce = Hce && function(e) {
  return new Promise(function(n, r) {
    const i = $V(e);
    let o = i.data;
    const s = $s.from(i.headers).normalize();
    let { responseType: c, onUploadProgress: u, onDownloadProgress: f } = i, p, y, v, w, C;
    function x() {
      w && w(), C && C(), i.cancelToken && i.cancelToken.unsubscribe(p), i.signal && i.signal.removeEventListener("abort", p);
    }
    let A = new XMLHttpRequest();
    A.open(i.method.toUpperCase(), i.url, !0), A.timeout = i.timeout;
    function R() {
      if (!A)
        return;
      const D = $s.from(
        "getAllResponseHeaders" in A && A.getAllResponseHeaders()
      ), L = {
        data: !c || c === "text" || c === "json" ? A.responseText : A.response,
        status: A.status,
        statusText: A.statusText,
        headers: D,
        config: e,
        request: A
      };
      zV(function(F) {
        n(F), x();
      }, function(F) {
        r(F), x();
      }, L), A = null;
    }
    "onloadend" in A ? A.onloadend = R : A.onreadystatechange = function() {
      !A || A.readyState !== 4 || A.status === 0 && !(A.responseURL && A.responseURL.indexOf("file:") === 0) || setTimeout(R);
    }, A.onabort = function() {
      A && (r(new qn("Request aborted", qn.ECONNABORTED, e, A)), A = null);
    }, A.onerror = function() {
      r(new qn("Network Error", qn.ERR_NETWORK, e, A)), A = null;
    }, A.ontimeout = function() {
      let M = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
      const L = i.transitional || jV;
      i.timeoutErrorMessage && (M = i.timeoutErrorMessage), r(new qn(
        M,
        L.clarifyTimeoutError ? qn.ETIMEDOUT : qn.ECONNABORTED,
        e,
        A
      )), A = null;
    }, o === void 0 && s.setContentType(null), "setRequestHeader" in A && Xe.forEach(s.toJSON(), function(M, L) {
      A.setRequestHeader(L, M);
    }), Xe.isUndefined(i.withCredentials) || (A.withCredentials = !!i.withCredentials), c && c !== "json" && (A.responseType = i.responseType), f && ([v, C] = R4(f, !0), A.addEventListener("progress", v)), u && A.upload && ([y, w] = R4(u), A.upload.addEventListener("progress", y), A.upload.addEventListener("loadend", w)), (i.cancelToken || i.signal) && (p = (D) => {
      A && (r(!D || D.type ? new Mb(null, e, A) : D), A.abort(), A = null);
    }, i.cancelToken && i.cancelToken.subscribe(p), i.signal && (i.signal.aborted ? p() : i.signal.addEventListener("abort", p)));
    const I = Lce(i.url);
    if (I && Vs.protocols.indexOf(I) === -1) {
      r(new qn("Unsupported protocol " + I + ":", qn.ERR_BAD_REQUEST, e));
      return;
    }
    A.send(o || null);
  });
}, Wce = (e, t) => {
  const { length: n } = e = e ? e.filter(Boolean) : [];
  if (t || n) {
    let r = new AbortController(), i;
    const o = function(f) {
      if (!i) {
        i = !0, c();
        const p = f instanceof Error ? f : this.reason;
        r.abort(p instanceof qn ? p : new Mb(p instanceof Error ? p.message : p));
      }
    };
    let s = t && setTimeout(() => {
      s = null, o(new qn(`timeout ${t} of ms exceeded`, qn.ETIMEDOUT));
    }, t);
    const c = () => {
      e && (s && clearTimeout(s), s = null, e.forEach((f) => {
        f.unsubscribe ? f.unsubscribe(o) : f.removeEventListener("abort", o);
      }), e = null);
    };
    e.forEach((f) => f.addEventListener("abort", o));
    const { signal: u } = r;
    return u.unsubscribe = () => Xe.asap(c), u;
  }
}, Gce = function* (e, t) {
  let n = e.byteLength;
  if (!t || n < t) {
    yield e;
    return;
  }
  let r = 0, i;
  for (; r < n; )
    i = r + t, yield e.slice(r, i), r = i;
}, Kce = async function* (e, t) {
  for await (const n of Yce(e))
    yield* Gce(n, t);
}, Yce = async function* (e) {
  if (e[Symbol.asyncIterator]) {
    yield* e;
    return;
  }
  const t = e.getReader();
  try {
    for (; ; ) {
      const { done: n, value: r } = await t.read();
      if (n)
        break;
      yield r;
    }
  } finally {
    await t.cancel();
  }
}, Ij = (e, t, n, r) => {
  const i = Kce(e, t);
  let o = 0, s, c = (u) => {
    s || (s = !0, r && r(u));
  };
  return new ReadableStream({
    async pull(u) {
      try {
        const { done: f, value: p } = await i.next();
        if (f) {
          c(), u.close();
          return;
        }
        let y = p.byteLength;
        if (n) {
          let v = o += y;
          n(v);
        }
        u.enqueue(new Uint8Array(p));
      } catch (f) {
        throw c(f), f;
      }
    },
    cancel(u) {
      return c(u), i.return();
    }
  }, {
    highWaterMark: 2
  });
}, x8 = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", HV = x8 && typeof ReadableStream == "function", Qce = x8 && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer())), qV = (e, ...t) => {
  try {
    return !!e(...t);
  } catch {
    return !1;
  }
}, Xce = HV && qV(() => {
  let e = !1;
  const t = new Request(Vs.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return e = !0, "half";
    }
  }).headers.has("Content-Type");
  return e && !t;
}), Dj = 64 * 1024, QI = HV && qV(() => Xe.isReadableStream(new Response("").body)), O4 = {
  stream: QI && ((e) => e.body)
};
x8 && ((e) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
    !O4[t] && (O4[t] = Xe.isFunction(e[t]) ? (n) => n[t]() : (n, r) => {
      throw new qn(`Response type '${t}' is not supported`, qn.ERR_NOT_SUPPORT, r);
    });
  });
})(new Response());
const Jce = async (e) => {
  if (e == null)
    return 0;
  if (Xe.isBlob(e))
    return e.size;
  if (Xe.isSpecCompliantForm(e))
    return (await new Request(Vs.origin, {
      method: "POST",
      body: e
    }).arrayBuffer()).byteLength;
  if (Xe.isArrayBufferView(e) || Xe.isArrayBuffer(e))
    return e.byteLength;
  if (Xe.isURLSearchParams(e) && (e = e + ""), Xe.isString(e))
    return (await Qce(e)).byteLength;
}, Zce = async (e, t) => {
  const n = Xe.toFiniteNumber(e.getContentLength());
  return n ?? Jce(t);
}, eue = x8 && (async (e) => {
  let {
    url: t,
    method: n,
    data: r,
    signal: i,
    cancelToken: o,
    timeout: s,
    onDownloadProgress: c,
    onUploadProgress: u,
    responseType: f,
    headers: p,
    withCredentials: y = "same-origin",
    fetchOptions: v
  } = $V(e);
  f = f ? (f + "").toLowerCase() : "text";
  let w = Wce([i, o && o.toAbortSignal()], s), C;
  const x = w && w.unsubscribe && (() => {
    w.unsubscribe();
  });
  let A;
  try {
    if (u && Xce && n !== "get" && n !== "head" && (A = await Zce(p, r)) !== 0) {
      let L = new Request(t, {
        method: "POST",
        body: r,
        duplex: "half"
      }), j;
      if (Xe.isFormData(r) && (j = L.headers.get("content-type")) && p.setContentType(j), L.body) {
        const [F, O] = _j(
          A,
          R4(Rj(u))
        );
        r = Ij(L.body, Dj, F, O);
      }
    }
    Xe.isString(y) || (y = y ? "include" : "omit");
    const R = "credentials" in Request.prototype;
    C = new Request(t, {
      ...v,
      signal: w,
      method: n.toUpperCase(),
      headers: p.normalize().toJSON(),
      body: r,
      duplex: "half",
      credentials: R ? y : void 0
    });
    let I = await fetch(C);
    const D = QI && (f === "stream" || f === "response");
    if (QI && (c || D && x)) {
      const L = {};
      ["status", "statusText", "headers"].forEach((z) => {
        L[z] = I[z];
      });
      const j = Xe.toFiniteNumber(I.headers.get("content-length")), [F, O] = c && _j(
        j,
        R4(Rj(c), !0)
      ) || [];
      I = new Response(
        Ij(I.body, Dj, F, () => {
          O && O(), x && x();
        }),
        L
      );
    }
    f = f || "text";
    let M = await O4[Xe.findKey(O4, f) || "text"](I, e);
    return !D && x && x(), await new Promise((L, j) => {
      zV(L, j, {
        data: M,
        headers: $s.from(I.headers),
        status: I.status,
        statusText: I.statusText,
        config: e,
        request: C
      });
    });
  } catch (R) {
    throw x && x(), R && R.name === "TypeError" && /fetch/i.test(R.message) ? Object.assign(
      new qn("Network Error", qn.ERR_NETWORK, e, C),
      {
        cause: R.cause || R
      }
    ) : qn.from(R, R && R.code, e, C);
  }
}), XI = {
  http: mce,
  xhr: qce,
  fetch: eue
};
Xe.forEach(XI, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const Mj = (e) => `- ${e}`, tue = (e) => Xe.isFunction(e) || e === null || e === !1, WV = {
  getAdapter: (e) => {
    e = Xe.isArray(e) ? e : [e];
    const { length: t } = e;
    let n, r;
    const i = {};
    for (let o = 0; o < t; o++) {
      n = e[o];
      let s;
      if (r = n, !tue(n) && (r = XI[(s = String(n)).toLowerCase()], r === void 0))
        throw new qn(`Unknown adapter '${s}'`);
      if (r)
        break;
      i[s || "#" + o] = r;
    }
    if (!r) {
      const o = Object.entries(i).map(
        ([c, u]) => `adapter ${c} ` + (u === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let s = t ? o.length > 1 ? `since :
` + o.map(Mj).join(`
`) : " " + Mj(o[0]) : "as no adapter specified";
      throw new qn(
        "There is no suitable adapter to dispatch the request " + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return r;
  },
  adapters: XI
};
function LR(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new Mb(null, e);
}
function Pj(e) {
  return LR(e), e.headers = $s.from(e.headers), e.data = BR.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), WV.getAdapter(e.adapter || PC.adapter)(e).then(function(r) {
    return LR(e), r.data = BR.call(
      e,
      e.transformResponse,
      r
    ), r.headers = $s.from(r.headers), r;
  }, function(r) {
    return UV(r) || (LR(e), r && r.response && (r.response.data = BR.call(
      e,
      e.transformResponse,
      r.response
    ), r.response.headers = $s.from(r.response.headers))), Promise.reject(r);
  });
}
const GV = "1.7.7", eM = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  eM[e] = function(r) {
    return typeof r === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const Nj = {};
eM.transitional = function(t, n, r) {
  function i(o, s) {
    return "[Axios v" + GV + "] Transitional option '" + o + "'" + s + (r ? ". " + r : "");
  }
  return (o, s, c) => {
    if (t === !1)
      throw new qn(
        i(s, " has been removed" + (n ? " in " + n : "")),
        qn.ERR_DEPRECATED
      );
    return n && !Nj[s] && (Nj[s] = !0), t ? t(o, s, c) : !0;
  };
};
function nue(e, t, n) {
  if (typeof e != "object")
    throw new qn("options must be an object", qn.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(e);
  let i = r.length;
  for (; i-- > 0; ) {
    const o = r[i], s = t[o];
    if (s) {
      const c = e[o], u = c === void 0 || s(c, o, e);
      if (u !== !0)
        throw new qn("option " + o + " must be " + u, qn.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new qn("Unknown option " + o, qn.ERR_BAD_OPTION);
  }
}
const JI = {
  assertOptions: nue,
  validators: eM
}, vh = JI.validators;
let Um = class {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new Aj(),
      response: new Aj()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(t, n) {
    try {
      return await this._request(t, n);
    } catch (r) {
      if (r instanceof Error) {
        let i;
        Error.captureStackTrace ? Error.captureStackTrace(i = {}) : i = new Error();
        const o = i.stack ? i.stack.replace(/^.+\n/, "") : "";
        try {
          r.stack ? o && !String(r.stack).endsWith(o.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + o) : r.stack = o;
        } catch {
        }
      }
      throw r;
    }
  }
  _request(t, n) {
    typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = Gm(this.defaults, n);
    const { transitional: r, paramsSerializer: i, headers: o } = n;
    r !== void 0 && JI.assertOptions(r, {
      silentJSONParsing: vh.transitional(vh.boolean),
      forcedJSONParsing: vh.transitional(vh.boolean),
      clarifyTimeoutError: vh.transitional(vh.boolean)
    }, !1), i != null && (Xe.isFunction(i) ? n.paramsSerializer = {
      serialize: i
    } : JI.assertOptions(i, {
      encode: vh.function,
      serialize: vh.function
    }, !0)), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let s = o && Xe.merge(
      o.common,
      o[n.method]
    );
    o && Xe.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (C) => {
        delete o[C];
      }
    ), n.headers = $s.concat(s, o);
    const c = [];
    let u = !0;
    this.interceptors.request.forEach(function(x) {
      typeof x.runWhen == "function" && x.runWhen(n) === !1 || (u = u && x.synchronous, c.unshift(x.fulfilled, x.rejected));
    });
    const f = [];
    this.interceptors.response.forEach(function(x) {
      f.push(x.fulfilled, x.rejected);
    });
    let p, y = 0, v;
    if (!u) {
      const C = [Pj.bind(this), void 0];
      for (C.unshift.apply(C, c), C.push.apply(C, f), v = C.length, p = Promise.resolve(n); y < v; )
        p = p.then(C[y++], C[y++]);
      return p;
    }
    v = c.length;
    let w = n;
    for (y = 0; y < v; ) {
      const C = c[y++], x = c[y++];
      try {
        w = C(w);
      } catch (A) {
        x.call(this, A);
        break;
      }
    }
    try {
      p = Pj.call(this, w);
    } catch (C) {
      return Promise.reject(C);
    }
    for (y = 0, v = f.length; y < v; )
      p = p.then(f[y++], f[y++]);
    return p;
  }
  getUri(t) {
    t = Gm(this.defaults, t);
    const n = VV(t.baseURL, t.url);
    return LV(n, t.params, t.paramsSerializer);
  }
};
Xe.forEach(["delete", "get", "head", "options"], function(t) {
  Um.prototype[t] = function(n, r) {
    return this.request(Gm(r || {}, {
      method: t,
      url: n,
      data: (r || {}).data
    }));
  };
});
Xe.forEach(["post", "put", "patch"], function(t) {
  function n(r) {
    return function(o, s, c) {
      return this.request(Gm(c || {}, {
        method: t,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: o,
        data: s
      }));
    };
  }
  Um.prototype[t] = n(), Um.prototype[t + "Form"] = n(!0);
});
let rue = class KV {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(o) {
      n = o;
    });
    const r = this;
    this.promise.then((i) => {
      if (!r._listeners) return;
      let o = r._listeners.length;
      for (; o-- > 0; )
        r._listeners[o](i);
      r._listeners = null;
    }), this.promise.then = (i) => {
      let o;
      const s = new Promise((c) => {
        r.subscribe(c), o = c;
      }).then(i);
      return s.cancel = function() {
        r.unsubscribe(o);
      }, s;
    }, t(function(o, s, c) {
      r.reason || (r.reason = new Mb(o, s, c), n(r.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(t);
    n !== -1 && this._listeners.splice(n, 1);
  }
  toAbortSignal() {
    const t = new AbortController(), n = (r) => {
      t.abort(r);
    };
    return this.subscribe(n), t.signal.unsubscribe = () => this.unsubscribe(n), t.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new KV(function(i) {
        t = i;
      }),
      cancel: t
    };
  }
};
function iue(e) {
  return function(n) {
    return e.apply(null, n);
  };
}
function oue(e) {
  return Xe.isObject(e) && e.isAxiosError === !0;
}
const ZI = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(ZI).forEach(([e, t]) => {
  ZI[t] = e;
});
function YV(e) {
  const t = new Um(e), n = EV(Um.prototype.request, t);
  return Xe.extend(n, Um.prototype, t, { allOwnKeys: !0 }), Xe.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(i) {
    return YV(Gm(e, i));
  }, n;
}
const Yi = YV(PC);
Yi.Axios = Um;
Yi.CanceledError = Mb;
Yi.CancelToken = rue;
Yi.isCancel = UV;
Yi.VERSION = GV;
Yi.toFormData = C8;
Yi.AxiosError = qn;
Yi.Cancel = Yi.CanceledError;
Yi.all = function(t) {
  return Promise.all(t);
};
Yi.spread = iue;
Yi.isAxiosError = oue;
Yi.mergeConfig = Gm;
Yi.AxiosHeaders = $s;
Yi.formToJSON = (e) => FV(Xe.isHTMLForm(e) ? new FormData(e) : e);
Yi.getAdapter = WV.getAdapter;
Yi.HttpStatusCode = ZI;
Yi.default = Yi;
const {
  Axios: hje,
  AxiosError: pje,
  CanceledError: mje,
  isCancel: yje,
  CancelToken: vje,
  VERSION: gje,
  all: bje,
  Cancel: wje,
  isAxiosError: Qd,
  spread: Cje,
  toFormData: xje,
  AxiosHeaders: Eje,
  HttpStatusCode: Sje,
  formToJSON: kje,
  getAdapter: Aje,
  mergeConfig: Tje
} = Yi, he = {
  of(e) {
    return _n(e);
  },
  empty() {
    return Tr;
  },
  zero() {
    return Tr;
  },
  fromNullable(e) {
    return e == null ? Tr : _n(e);
  },
  fromFalsy(e) {
    return e ? _n(e) : Tr;
  },
  fromPredicate(e, t) {
    switch (arguments.length) {
      case 1:
        return (n) => he.fromPredicate(e, n);
      default:
        return e(t) ? _n(t) : Tr;
    }
  },
  mapMaybe(e, t) {
    switch (arguments.length) {
      case 1:
        return (n) => he.mapMaybe(e, n);
      default:
        return he.catMaybes(t.map(e));
    }
  },
  catMaybes(e) {
    let t = [];
    for (const n of e)
      n.isJust() && t.push(n.extract());
    return t;
  },
  encase(e) {
    try {
      return _n(e());
    } catch {
      return Tr;
    }
  },
  isMaybe(e) {
    return e instanceof tM || e instanceof nM;
  },
  sequence(e) {
    let t = [];
    for (const n of e)
      if (n.isJust())
        t.push(n.extract());
      else
        return Tr;
    return _n(t);
  },
  "fantasy-land/of"(e) {
    return this.of(e);
  },
  "fantasy-land/empty"() {
    return this.empty();
  },
  "fantasy-land/zero"() {
    return this.zero();
  }
};
class tM {
  constructor(t) {
    this.__value = t, this["fantasy-land/equals"] = this.equals, this["fantasy-land/map"] = this.map, this["fantasy-land/ap"] = this.ap, this["fantasy-land/alt"] = this.alt, this["fantasy-land/chain"] = this.chain, this["fantasy-land/reduce"] = this.reduce, this["fantasy-land/extend"] = this.extend, this["fantasy-land/filter"] = this.filter;
  }
  isJust() {
    return !0;
  }
  isNothing() {
    return !1;
  }
  inspect() {
    return `Just(${this.__value})`;
  }
  toString() {
    return this.inspect();
  }
  toJSON() {
    const t = this.__value;
    return t instanceof Date ? t.toJSON() : t;
  }
  equals(t) {
    return this.extract() === t.extract();
  }
  map(t) {
    return _n(t(this.__value));
  }
  ap(t) {
    return t.isJust() ? this.map(t.extract()) : Tr;
  }
  alt(t) {
    return this;
  }
  altLazy(t) {
    return this;
  }
  chain(t) {
    return t(this.__value);
  }
  chainNullable(t) {
    return he.fromNullable(t(this.__value));
  }
  join() {
    return this.__value;
  }
  reduce(t, n) {
    return t(n, this.__value);
  }
  extend(t) {
    return _n(t(this));
  }
  unsafeCoerce() {
    return this.__value;
  }
  caseOf(t) {
    return "_" in t ? t._() : t.Just(this.__value);
  }
  orDefault(t) {
    return this.__value;
  }
  orDefaultLazy(t) {
    return this.__value;
  }
  toList() {
    return [this.__value];
  }
  mapOrDefault(t, n) {
    return t(this.__value);
  }
  extract() {
    return this.__value;
  }
  extractNullable() {
    return this.__value;
  }
  toEither(t) {
    return Pt(this.__value);
  }
  ifJust(t) {
    return t(this.__value), this;
  }
  ifNothing(t) {
    return this;
  }
  filter(t) {
    return t(this.__value) ? _n(this.__value) : Tr;
  }
}
tM.prototype.constructor = he;
class nM {
  constructor() {
    this["fantasy-land/equals"] = this.equals, this["fantasy-land/map"] = this.map, this["fantasy-land/ap"] = this.ap, this["fantasy-land/alt"] = this.alt, this["fantasy-land/chain"] = this.chain, this["fantasy-land/reduce"] = this.reduce, this["fantasy-land/extend"] = this.extend, this["fantasy-land/filter"] = this.filter;
  }
  isJust() {
    return !1;
  }
  isNothing() {
    return !0;
  }
  inspect() {
    return "Nothing";
  }
  toString() {
    return this.inspect();
  }
  toJSON() {
    return this.__value;
  }
  equals(t) {
    return this.extract() === t.extract();
  }
  map(t) {
    return Tr;
  }
  ap(t) {
    return Tr;
  }
  alt(t) {
    return t;
  }
  altLazy(t) {
    return t();
  }
  chain(t) {
    return Tr;
  }
  chainNullable(t) {
    return Tr;
  }
  join() {
    return Tr;
  }
  reduce(t, n) {
    return n;
  }
  extend(t) {
    return Tr;
  }
  unsafeCoerce() {
    throw new Error("Maybe#unsafeCoerce was ran on a Nothing");
  }
  caseOf(t) {
    return "_" in t ? t._() : t.Nothing();
  }
  orDefault(t) {
    return t;
  }
  orDefaultLazy(t) {
    return t();
  }
  toList() {
    return [];
  }
  mapOrDefault(t, n) {
    return n;
  }
  extract() {
  }
  extractNullable() {
    return null;
  }
  toEither(t) {
    return Rn(t);
  }
  ifJust(t) {
    return this;
  }
  ifNothing(t) {
    return t(), this;
  }
  filter(t) {
    return Tr;
  }
}
nM.prototype.constructor = he;
const _n = (e) => new tM(e), Tr = new nM(), Oa = {
  of(e) {
    return Pt(e);
  },
  lefts(e) {
    let t = [];
    for (const n of e)
      n.isLeft() && t.push(n.extract());
    return t;
  },
  rights(e) {
    let t = [];
    for (const n of e)
      n.isRight() && t.push(n.extract());
    return t;
  },
  encase(e) {
    try {
      return Pt(e());
    } catch (t) {
      return Rn(t);
    }
  },
  sequence(e) {
    let t = [];
    for (const n of e) {
      if (n.isLeft())
        return n;
      t.push(n.extract());
    }
    return Pt(t);
  },
  isEither(e) {
    return e instanceof iM || e instanceof rM;
  },
  "fantasy-land/of"(e) {
    return Oa.of(e);
  }
};
class rM {
  constructor(t) {
    this.__value = t, this._ = "R", this["fantasy-land/bimap"] = this.bimap, this["fantasy-land/map"] = this.map, this["fantasy-land/ap"] = this.ap, this["fantasy-land/equals"] = this.equals, this["fantasy-land/chain"] = this.chain, this["fantasy-land/alt"] = this.alt, this["fantasy-land/reduce"] = this.reduce, this["fantasy-land/extend"] = this.extend;
  }
  isLeft() {
    return !1;
  }
  isRight() {
    return !0;
  }
  toJSON() {
    return this.__value;
  }
  inspect() {
    return `Right(${this.__value})`;
  }
  toString() {
    return this.inspect();
  }
  bimap(t, n) {
    return Pt(n(this.__value));
  }
  map(t) {
    return Pt(t(this.__value));
  }
  mapLeft(t) {
    return this;
  }
  ap(t) {
    return t.isRight() ? this.map(t.extract()) : t;
  }
  equals(t) {
    return t.isRight() ? this.__value === t.extract() : !1;
  }
  chain(t) {
    return t(this.__value);
  }
  chainLeft(t) {
    return this;
  }
  join() {
    return this.__value;
  }
  alt(t) {
    return this;
  }
  altLazy(t) {
    return this;
  }
  reduce(t, n) {
    return t(n, this.__value);
  }
  extend(t) {
    return Pt(t(this));
  }
  unsafeCoerce() {
    return this.__value;
  }
  caseOf(t) {
    return "_" in t ? t._() : t.Right(this.__value);
  }
  leftOrDefault(t) {
    return t;
  }
  orDefault(t) {
    return this.__value;
  }
  orDefaultLazy(t) {
    return this.__value;
  }
  leftOrDefaultLazy(t) {
    return t();
  }
  ifLeft(t) {
    return this;
  }
  ifRight(t) {
    return t(this.__value), this;
  }
  toMaybe() {
    return _n(this.__value);
  }
  leftToMaybe() {
    return Tr;
  }
  extract() {
    return this.__value;
  }
  swap() {
    return Rn(this.__value);
  }
}
rM.prototype.constructor = Oa;
class iM {
  constructor(t) {
    this.__value = t, this._ = "L", this["fantasy-land/bimap"] = this.bimap, this["fantasy-land/map"] = this.map, this["fantasy-land/ap"] = this.ap, this["fantasy-land/equals"] = this.equals, this["fantasy-land/chain"] = this.chain, this["fantasy-land/alt"] = this.alt, this["fantasy-land/reduce"] = this.reduce, this["fantasy-land/extend"] = this.extend;
  }
  isLeft() {
    return !0;
  }
  isRight() {
    return !1;
  }
  toJSON() {
    return this.__value;
  }
  inspect() {
    return `Left(${JSON.stringify(this.__value)})`;
  }
  toString() {
    return this.inspect();
  }
  bimap(t, n) {
    return Rn(t(this.__value));
  }
  map(t) {
    return this;
  }
  mapLeft(t) {
    return Rn(t(this.__value));
  }
  ap(t) {
    return t.isLeft() ? t : this;
  }
  equals(t) {
    return t.isLeft() ? t.extract() === this.__value : !1;
  }
  chain(t) {
    return this;
  }
  chainLeft(t) {
    return t(this.__value);
  }
  join() {
    return this;
  }
  alt(t) {
    return t;
  }
  altLazy(t) {
    return t();
  }
  reduce(t, n) {
    return n;
  }
  extend(t) {
    return this;
  }
  unsafeCoerce() {
    throw this.__value instanceof Error ? this.__value : new Error("Either#unsafeCoerce was ran on a Left");
  }
  caseOf(t) {
    return "_" in t ? t._() : t.Left(this.__value);
  }
  leftOrDefault(t) {
    return this.__value;
  }
  orDefault(t) {
    return t;
  }
  orDefaultLazy(t) {
    return t();
  }
  leftOrDefaultLazy(t) {
    return this.__value;
  }
  ifLeft(t) {
    return t(this.__value), this;
  }
  ifRight(t) {
    return this;
  }
  toMaybe() {
    return Tr;
  }
  leftToMaybe() {
    return _n(this.__value);
  }
  extract() {
    return this.__value;
  }
  swap() {
    return Pt(this.__value);
  }
}
iM.prototype.constructor = Oa;
const Rn = (e) => new iM(e), Pt = (e) => new rM(e), NC = (e) => e, Ig = {
  LT: "LT",
  EQ: "EQ",
  GT: "GT"
}, aue = (e, t) => e > t ? Ig.GT : e < t ? Ig.LT : Ig.EQ, sue = (e) => {
  switch (e) {
    case Ig.LT:
      return -1;
    case Ig.EQ:
      return 0;
    case Ig.GT:
      return 1;
  }
}, lue = (e) => e, jR = Object.assign(lue, {
  fromArray: (e) => jR.isNonEmpty(e) ? _n(e) : Tr,
  unsafeCoerce: (e) => {
    if (jR.isNonEmpty(e))
      return e;
    throw new Error("NonEmptyList#unsafeCoerce was ran on an empty array");
  },
  fromTuple: (e) => jR(e.toArray()),
  head: (e) => e[0],
  last: (e) => e[e.length - 1],
  isNonEmpty: (e) => e.length > 0,
  tail: (e) => e.slice(1)
}), r4 = (e, t) => typeof t == "bigint" ? t.toString() : t, QV = (e) => typeof e == "object" && e !== null && !Array.isArray(e), op = (e, t) => {
  let n = "";
  switch (typeof t) {
    case "undefined":
      n = "undefined";
      break;
    case "object":
      n = t === null ? "null" : Array.isArray(t) ? "an array with value " + JSON.stringify(t, r4) : "an object with value " + JSON.stringify(t, r4);
      break;
    case "boolean":
      n = "a boolean";
      break;
    case "symbol":
      n = "a symbol";
      break;
    case "function":
      n = "a function";
      break;
    case "bigint":
      n = `a bigint with value ${t.toString()}`;
  }
  return n = n || `a ${typeof t} with value ${JSON.stringify(t, r4)}`, `Expected ${e}, but received ${n}`;
}, cue = (e) => {
  var n;
  return Object.keys(e).length === 1 && ((n = e.oneOf) == null ? void 0 : n.length) === 1 && typeof e.oneOf[0] == "object" && (Object.assign(e, e.oneOf[0]), delete e.oneOf), e;
}, uue = (e) => {
  if (Array.isArray(e.oneOf))
    for (let t = 0; t < e.oneOf.length; t++) {
      const n = e.oneOf[t];
      if (typeof n == "object" && n.oneOf)
        return e.oneOf.splice(t, 1), e.oneOf.push(...n.oneOf), XV(e);
    }
  return e;
}, XV = (e) => (uue(e), cue(e), e), uo = {
  /** Creates a codec for any JSON object */
  interface(e) {
    const t = Object.keys(e), n = (i) => {
      if (!QV(i))
        return Rn(op("an object", i));
      const o = {};
      for (const s of t) {
        if (!i.hasOwnProperty(s) && !e[s]._isOptional)
          return Rn(`Problem with property "${s}": it does not exist in received object ${JSON.stringify(i, r4)}`);
        const c = e[s].decode(i[s]);
        if (c.isLeft())
          return Rn(`Problem with the value of property "${s}": ${c.extract()}`);
        const u = c.extract();
        u !== void 0 && (o[s] = u);
      }
      return Pt(o);
    };
    return {
      decode: n,
      encode: (i) => {
        const o = {};
        for (const s of t)
          o[s] = e[s].encode(i[s]);
        return o;
      },
      unsafeDecode: (i) => n(i).mapLeft(Error).unsafeCoerce(),
      schema: () => t.reduce((i, o) => (e[o]._isOptional || i.required.push(o), i.properties[o] = XV(e[o].schema()), i), {
        type: "object",
        properties: {},
        required: []
      })
    };
  },
  /** Creates a codec for any type, you can add your own deserialization/validation logic in the decode argument */
  custom({ decode: e, encode: t, schema: n }) {
    return {
      decode: e,
      encode: t,
      unsafeDecode: (r) => e(r).mapLeft(Error).unsafeCoerce(),
      schema: n ?? (() => ({}))
    };
  }
}, rs = uo.custom({
  decode: (e) => typeof e == "string" ? Pt(e) : Rn(op("a string", e)),
  encode: NC,
  schema: () => ({ type: "string" })
}), D1 = uo.custom({
  decode: (e) => typeof e == "number" ? Pt(e) : Rn(op("a number", e)),
  encode: NC,
  schema: () => ({ type: "number" })
}), due = uo.custom({
  decode: (e) => e === void 0 ? Pt(e) : Rn(op("an undefined", e)),
  encode: NC
}), FR = (e) => ({
  ...hue([e, due]),
  schema: e.schema,
  _isOptional: !0
}), fue = uo.custom({
  decode: (e) => typeof e == "boolean" ? Pt(e) : Rn(op("a boolean", e)),
  encode: NC,
  schema: () => ({ type: "boolean" })
}), hue = (e) => uo.custom({
  decode: (t) => {
    let n = [];
    for (const r of e) {
      const i = r.decode(t);
      if (i.isRight())
        return i;
      n.push(i.extract());
    }
    return Rn(`One of the following problems occured: ${n.map((r, i) => `(${i}) ${r}`).join(", ")}`);
  },
  encode: (t) => {
    for (const n of e)
      if (Oa.encase(() => n.encode(t)).mapLeft((i) => "").chain(n.decode).isRight())
        return n.encode(t);
    return t;
  },
  schema: () => ({ oneOf: e.map((t) => t.schema()) })
}), Bj = (e) => uo.custom({
  decode: (t) => {
    if (Array.isArray(t)) {
      const n = [];
      for (let r = 0; r < t.length; r++) {
        const i = e.decode(t[r]);
        if (i.isRight())
          n.push(i.extract());
        else
          return Rn(`Problem with the value at index ${r}: ${i.extract()}`);
      }
      return Pt(n);
    } else
      return Rn(op("an array", t));
  },
  encode: (t) => t.map(e.encode),
  schema: () => ({
    type: "array",
    items: e.schema()
  })
}), pue = uo.custom({
  decode: (e) => rs.decode(e).chain((t) => isFinite(+t) ? Pt(t) : Rn(op("a number", e))),
  encode: NC,
  schema: D1.schema
}), UR = (e, t) => uo.custom({
  decode: (n) => {
    const r = {}, i = e === D1 ? pue : e;
    if (!QV(n))
      return Rn(op("an object", n));
    for (const o of Object.keys(n))
      if (n.hasOwnProperty(o)) {
        const s = i.decode(o), c = t.decode(n[o]);
        if (s.isRight() && c.isRight())
          r[s.extract()] = c.extract();
        else {
          if (s.isLeft())
            return Rn(`Problem with key type of property "${o}": ${s.extract()}`);
          if (c.isLeft())
            return Rn(`Problem with the value of property "${o}": ${c.extract()}`);
        }
      }
    return Pt(r);
  },
  encode: (n) => {
    const r = {};
    for (const i in n)
      n.hasOwnProperty(i) && (r[e.encode(i)] = t.encode(n[i]));
    return r;
  },
  schema: () => ({
    type: "object",
    additionalProperties: t.schema()
  })
});
class JV {
  constructor(t, n) {
    this.first = t, this.second = n, this.length = 2, this["fantasy-land/equals"] = this.equals, this["fantasy-land/bimap"] = this.bimap, this["fantasy-land/map"] = this.map, this["fantasy-land/reduce"] = this.reduce, this["fantasy-land/ap"] = this.ap, this[0] = t, this[1] = n;
  }
  *[Symbol.iterator]() {
    yield this.first, yield this.second;
  }
  toJSON() {
    return this.toArray();
  }
  inspect() {
    return `Tuple(${JSON.stringify(this.first)}, ${JSON.stringify(this.second)})`;
  }
  toString() {
    return this.inspect();
  }
  fst() {
    return this.first;
  }
  snd() {
    return this.second;
  }
  equals(t) {
    return this.first === t.fst() && this.second === t.snd();
  }
  bimap(t, n) {
    return jc(t(this.first), n(this.second));
  }
  mapFirst(t) {
    return jc(t(this.first), this.second);
  }
  map(t) {
    return jc(this.first, t(this.second));
  }
  reduce(t, n) {
    return t(n, this.second);
  }
  toArray() {
    return [this.first, this.second];
  }
  swap() {
    return jc(this.second, this.first);
  }
  ap(t) {
    return jc(this.first, t.snd()(this.second));
  }
  every(t) {
    return t(this.first) && t(this.second);
  }
  some(t) {
    return t(this.first) || t(this.second);
  }
}
const jc = Object.assign((e, t) => new JV(e, t), {
  fromArray: ([e, t]) => jc(e, t),
  fanout: (...e) => {
    const [t, n, r] = e;
    switch (e.length) {
      case 3:
        return jc(t(r), n(r));
      case 2:
        return (i) => jc.fanout(t, n, i);
      default:
        return (i) => (o) => jc.fanout(t, i, o);
    }
  }
});
JV.prototype.constructor = jc;
const mue = (e) => e.length > 0 ? _n(e[0]) : Tr, yue = (e) => e.length > 0 ? _n(e[e.length - 1]) : Tr, vue = (e) => e.length > 0 ? _n(e.slice(1)) : Tr, gue = (e) => e.length > 0 ? _n(e.slice(0, -1)) : Tr, bue = (e) => e.length > 0 ? _n(jc(e[0], e.slice(1))) : Tr, wue = (e) => e.reduce((t, n) => t + n, 0);
function ZV(e, t) {
  switch (arguments.length) {
    case 1:
      return (n) => ZV(e, n);
    default:
      return he.fromNullable(t.find(e));
  }
}
function e$(e, t) {
  switch (arguments.length) {
    case 1:
      return (n) => e$(e, n);
    default:
      return he.fromPredicate((n) => n !== -1, t.findIndex(e));
  }
}
function t$(e, t) {
  switch (arguments.length) {
    case 1:
      return (n) => t$(e, n);
    default:
      return t[e] === void 0 ? Tr : _n(t[e]);
  }
}
function n$(e, t) {
  switch (arguments.length) {
    case 1:
      return (n) => n$(e, n);
    default:
      return [...t].sort((n, r) => sue(e(n, r)));
  }
}
const Wn = {
  init: gue,
  uncons: bue,
  at: t$,
  head: mue,
  last: yue,
  tail: vue,
  find: ZV,
  findIndex: e$,
  sum: wue,
  sort: n$
};
var r$;
const i$ = {
  liftEither(e) {
    if (e.isRight())
      return Promise.resolve(e.extract());
    throw e.extract();
  },
  fromPromise(e) {
    return e.then(i$.liftEither);
  },
  throwE(e) {
    throw e;
  }
};
class o$ {
  constructor(t) {
    this.runPromise = t, this[r$] = "EitherAsync", this["fantasy-land/chain"] = this.chain, this["fantasy-land/alt"] = this.alt, this.then = (n, r) => this.run().then(n, r);
  }
  leftOrDefault(t) {
    return this.run().then((n) => n.leftOrDefault(t));
  }
  orDefault(t) {
    return this.run().then((n) => n.orDefault(t));
  }
  join() {
    return Ye(async (t) => {
      const n = await this;
      if (n.isRight()) {
        const r = await n.extract();
        return t.liftEither(r);
      }
      return t.liftEither(n);
    });
  }
  ap(t) {
    return Ye(async (n) => {
      const r = await t;
      if (r.isRight()) {
        const i = await this.run();
        return i.isRight() ? r.extract()(i.extract()) : n.liftEither(i);
      }
      return n.liftEither(r);
    });
  }
  alt(t) {
    return Ye(async (n) => {
      const r = await this.run();
      if (r.isRight())
        return r.extract();
      {
        const i = await t;
        return n.liftEither(i);
      }
    });
  }
  extend(t) {
    return Ye(async (n) => {
      const r = await this.run();
      if (r.isRight()) {
        const i = Ye.liftEither(r);
        return n.liftEither(Pt(t(i)));
      }
      return n.liftEither(r);
    });
  }
  async run() {
    try {
      return Pt(await this.runPromise(i$));
    } catch (t) {
      return Rn(t);
    }
  }
  bimap(t, n) {
    return Ye(async (r) => {
      const i = await this.run();
      try {
        return await r.liftEither(i.bimap(t, n));
      } catch (o) {
        throw await o;
      }
    });
  }
  map(t) {
    return Ye((n) => this.runPromise(n).then(t));
  }
  mapLeft(t) {
    return Ye(async (n) => {
      try {
        return await this.runPromise(n);
      } catch (r) {
        throw await t(r);
      }
    });
  }
  chain(t) {
    return Ye(async (n) => {
      const r = await this.runPromise(n);
      return n.fromPromise(t(r));
    });
  }
  chainLeft(t) {
    return Ye(async (n) => {
      try {
        return await this.runPromise(n);
      } catch (r) {
        return n.fromPromise(t(r));
      }
    });
  }
  toMaybeAsync() {
    return ra(async ({ liftMaybe: t }) => {
      const n = await this.run();
      return t(n.toMaybe());
    });
  }
  swap() {
    return Ye(async (t) => {
      const n = await this.run();
      return n.isRight() && t.throwE(n.extract()), t.liftEither(Pt(n.extract()));
    });
  }
  ifLeft(t) {
    return Ye(async (n) => {
      const r = await this.run();
      return r.ifLeft(t), n.liftEither(r);
    });
  }
  ifRight(t) {
    return Ye(async (n) => {
      const r = await this.run();
      return r.ifRight(t), n.liftEither(r);
    });
  }
  void() {
    return this.map((t) => {
    });
  }
  caseOf(t) {
    return this.run().then((n) => n.caseOf(t));
  }
  finally(t) {
    return Ye(({ fromPromise: n }) => n(this.run().finally(t)));
  }
}
r$ = Symbol.toStringTag;
const Ye = Object.assign((e) => new o$(e), {
  fromPromise: (e) => Ye(({ fromPromise: t }) => t(e())),
  liftEither: (e) => Ye(({ liftEither: t }) => t(e)),
  lefts: (e) => Promise.all(e.map((t) => t.run())).then(Oa.lefts),
  rights: (e) => Promise.all(e.map((t) => t.run())).then(Oa.rights),
  sequence: (e) => Ye(async (t) => {
    let n = [];
    for await (const r of e) {
      if (r.isLeft())
        return t.liftEither(r);
      n.push(r.extract());
    }
    return t.liftEither(Pt(n));
  }),
  all: (e) => Ye.fromPromise(async () => Promise.all(e).then(Oa.sequence))
});
o$.prototype.constructor = Ye;
var a$;
const s$ = {
  liftMaybe(e) {
    if (e.isJust())
      return Promise.resolve(e.extract());
    throw Tr;
  },
  fromPromise(e) {
    return e.then(s$.liftMaybe);
  }
};
class l$ {
  constructor(t) {
    this.runPromise = t, this[a$] = "MaybeAsync", this["fantasy-land/chain"] = this.chain, this["fantasy-land/filter"] = this.filter, this["fantasy-land/alt"] = this.alt;
  }
  orDefault(t) {
    return this.run().then((n) => n.orDefault(t));
  }
  join() {
    return ra(async (t) => {
      const n = await this.run();
      if (n.isJust()) {
        const r = await n.extract();
        return t.liftMaybe(r);
      }
      return t.liftMaybe(Tr);
    });
  }
  ap(t) {
    return ra(async (n) => {
      const r = await t;
      if (r.isJust()) {
        const i = await this.run();
        return i.isJust() ? r.extract()(i.extract()) : n.liftMaybe(Tr);
      }
      return n.liftMaybe(Tr);
    });
  }
  alt(t) {
    return ra(async (n) => {
      const r = await this.run();
      if (r.isJust())
        return r.extract();
      {
        const i = await t;
        return n.liftMaybe(i);
      }
    });
  }
  extend(t) {
    return ra(async (n) => {
      const r = await this.run();
      if (r.isJust()) {
        const i = ra.liftMaybe(r);
        return n.liftMaybe(_n(t(i)));
      }
      return n.liftMaybe(Tr);
    });
  }
  filter(t) {
    return ra(async (n) => {
      const r = await this.run();
      return n.liftMaybe(r.filter(t));
    });
  }
  async run() {
    try {
      return _n(await this.runPromise(s$));
    } catch {
      return Tr;
    }
  }
  map(t) {
    return ra((n) => this.runPromise(n).then(t));
  }
  chain(t) {
    return ra(async (n) => {
      const r = await this.runPromise(n);
      return n.fromPromise(t(r));
    });
  }
  toEitherAsync(t) {
    return Ye(async ({ liftEither: n }) => {
      const r = await this.run();
      return n(r.toEither(t));
    });
  }
  ifJust(t) {
    return ra(async (n) => {
      const r = await this.run();
      return r.ifJust(t), n.liftMaybe(r);
    });
  }
  ifNothing(t) {
    return ra(async (n) => {
      const r = await this.run();
      return r.ifNothing(t), n.liftMaybe(r);
    });
  }
  void() {
    return this.map((t) => {
    });
  }
  caseOf(t) {
    return this.run().then((n) => n.caseOf(t));
  }
  finally(t) {
    return ra(({ fromPromise: n }) => n(this.run().finally(t)));
  }
  then(t, n) {
    return this.run().then(t, n);
  }
}
a$ = Symbol.toStringTag;
const ra = Object.assign((e) => new l$(e), {
  catMaybes: (e) => Promise.all(e).then(he.catMaybes),
  fromPromise: (e) => ra(({ fromPromise: t }) => t(e())),
  liftMaybe: (e) => ra(({ liftMaybe: t }) => t(e))
});
l$.prototype.constructor = ra;
var Cue = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, zR = Math.ceil, Nl = Math.floor, Bs = "[BigNumber Error] ", Lj = Bs + "Number primitive has more than 15 significant digits: ", Mc = 1e14, Vn = 14, VR = 9007199254740991, $R = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], gh = 1e7, Uo = 1e9;
function c$(e) {
  var t, n, r, i = I.prototype = { constructor: I, toString: null, valueOf: null }, o = new I(1), s = 20, c = 4, u = -7, f = 21, p = -1e7, y = 1e7, v = !1, w = 1, C = 0, x = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "",
    // non-breaking space
    suffix: ""
  }, A = "0123456789abcdefghijklmnopqrstuvwxyz", R = !0;
  function I(O, z) {
    var H, Q, Y, ee, ie, X, Z, J, K = this;
    if (!(K instanceof I)) return new I(O, z);
    if (z == null) {
      if (O && O._isBigNumber === !0) {
        K.s = O.s, !O.c || O.e > y ? K.c = K.e = null : O.e < p ? K.c = [K.e = 0] : (K.e = O.e, K.c = O.c.slice());
        return;
      }
      if ((X = typeof O == "number") && O * 0 == 0) {
        if (K.s = 1 / O < 0 ? (O = -O, -1) : 1, O === ~~O) {
          for (ee = 0, ie = O; ie >= 10; ie /= 10, ee++) ;
          ee > y ? K.c = K.e = null : (K.e = ee, K.c = [O]);
          return;
        }
        J = String(O);
      } else {
        if (!Cue.test(J = String(O))) return r(K, J, X);
        K.s = J.charCodeAt(0) == 45 ? (J = J.slice(1), -1) : 1;
      }
      (ee = J.indexOf(".")) > -1 && (J = J.replace(".", "")), (ie = J.search(/e/i)) > 0 ? (ee < 0 && (ee = ie), ee += +J.slice(ie + 1), J = J.substring(0, ie)) : ee < 0 && (ee = J.length);
    } else {
      if (Ti(z, 2, A.length, "Base"), z == 10 && R)
        return K = new I(O), j(K, s + K.e + 1, c);
      if (J = String(O), X = typeof O == "number") {
        if (O * 0 != 0) return r(K, J, X, z);
        if (K.s = 1 / O < 0 ? (J = J.slice(1), -1) : 1, I.DEBUG && J.replace(/^0\.0*|\./, "").length > 15)
          throw Error(Lj + O);
      } else
        K.s = J.charCodeAt(0) === 45 ? (J = J.slice(1), -1) : 1;
      for (H = A.slice(0, z), ee = ie = 0, Z = J.length; ie < Z; ie++)
        if (H.indexOf(Q = J.charAt(ie)) < 0) {
          if (Q == ".") {
            if (ie > ee) {
              ee = Z;
              continue;
            }
          } else if (!Y && (J == J.toUpperCase() && (J = J.toLowerCase()) || J == J.toLowerCase() && (J = J.toUpperCase()))) {
            Y = !0, ie = -1, ee = 0;
            continue;
          }
          return r(K, String(O), X, z);
        }
      X = !1, J = n(J, z, 10, K.s), (ee = J.indexOf(".")) > -1 ? J = J.replace(".", "") : ee = J.length;
    }
    for (ie = 0; J.charCodeAt(ie) === 48; ie++) ;
    for (Z = J.length; J.charCodeAt(--Z) === 48; ) ;
    if (J = J.slice(ie, ++Z)) {
      if (Z -= ie, X && I.DEBUG && Z > 15 && (O > VR || O !== Nl(O)))
        throw Error(Lj + K.s * O);
      if ((ee = ee - ie - 1) > y)
        K.c = K.e = null;
      else if (ee < p)
        K.c = [K.e = 0];
      else {
        if (K.e = ee, K.c = [], ie = (ee + 1) % Vn, ee < 0 && (ie += Vn), ie < Z) {
          for (ie && K.c.push(+J.slice(0, ie)), Z -= Vn; ie < Z; )
            K.c.push(+J.slice(ie, ie += Vn));
          ie = Vn - (J = J.slice(ie)).length;
        } else
          ie -= Z;
        for (; ie--; J += "0") ;
        K.c.push(+J);
      }
    } else
      K.c = [K.e = 0];
  }
  I.clone = c$, I.ROUND_UP = 0, I.ROUND_DOWN = 1, I.ROUND_CEIL = 2, I.ROUND_FLOOR = 3, I.ROUND_HALF_UP = 4, I.ROUND_HALF_DOWN = 5, I.ROUND_HALF_EVEN = 6, I.ROUND_HALF_CEIL = 7, I.ROUND_HALF_FLOOR = 8, I.EUCLID = 9, I.config = I.set = function(O) {
    var z, H;
    if (O != null)
      if (typeof O == "object") {
        if (O.hasOwnProperty(z = "DECIMAL_PLACES") && (H = O[z], Ti(H, 0, Uo, z), s = H), O.hasOwnProperty(z = "ROUNDING_MODE") && (H = O[z], Ti(H, 0, 8, z), c = H), O.hasOwnProperty(z = "EXPONENTIAL_AT") && (H = O[z], H && H.pop ? (Ti(H[0], -Uo, 0, z), Ti(H[1], 0, Uo, z), u = H[0], f = H[1]) : (Ti(H, -Uo, Uo, z), u = -(f = H < 0 ? -H : H))), O.hasOwnProperty(z = "RANGE"))
          if (H = O[z], H && H.pop)
            Ti(H[0], -Uo, -1, z), Ti(H[1], 1, Uo, z), p = H[0], y = H[1];
          else if (Ti(H, -Uo, Uo, z), H)
            p = -(y = H < 0 ? -H : H);
          else
            throw Error(Bs + z + " cannot be zero: " + H);
        if (O.hasOwnProperty(z = "CRYPTO"))
          if (H = O[z], H === !!H)
            if (H)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                v = H;
              else
                throw v = !H, Error(Bs + "crypto unavailable");
            else
              v = H;
          else
            throw Error(Bs + z + " not true or false: " + H);
        if (O.hasOwnProperty(z = "MODULO_MODE") && (H = O[z], Ti(H, 0, 9, z), w = H), O.hasOwnProperty(z = "POW_PRECISION") && (H = O[z], Ti(H, 0, Uo, z), C = H), O.hasOwnProperty(z = "FORMAT"))
          if (H = O[z], typeof H == "object") x = H;
          else throw Error(Bs + z + " not an object: " + H);
        if (O.hasOwnProperty(z = "ALPHABET"))
          if (H = O[z], typeof H == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(H))
            R = H.slice(0, 10) == "0123456789", A = H;
          else
            throw Error(Bs + z + " invalid: " + H);
      } else
        throw Error(Bs + "Object expected: " + O);
    return {
      DECIMAL_PLACES: s,
      ROUNDING_MODE: c,
      EXPONENTIAL_AT: [u, f],
      RANGE: [p, y],
      CRYPTO: v,
      MODULO_MODE: w,
      POW_PRECISION: C,
      FORMAT: x,
      ALPHABET: A
    };
  }, I.isBigNumber = function(O) {
    if (!O || O._isBigNumber !== !0) return !1;
    if (!I.DEBUG) return !0;
    var z, H, Q = O.c, Y = O.e, ee = O.s;
    e: if ({}.toString.call(Q) == "[object Array]") {
      if ((ee === 1 || ee === -1) && Y >= -Uo && Y <= Uo && Y === Nl(Y)) {
        if (Q[0] === 0) {
          if (Y === 0 && Q.length === 1) return !0;
          break e;
        }
        if (z = (Y + 1) % Vn, z < 1 && (z += Vn), String(Q[0]).length == z) {
          for (z = 0; z < Q.length; z++)
            if (H = Q[z], H < 0 || H >= Mc || H !== Nl(H)) break e;
          if (H !== 0) return !0;
        }
      }
    } else if (Q === null && Y === null && (ee === null || ee === 1 || ee === -1))
      return !0;
    throw Error(Bs + "Invalid BigNumber: " + O);
  }, I.maximum = I.max = function() {
    return M(arguments, -1);
  }, I.minimum = I.min = function() {
    return M(arguments, 1);
  }, I.random = function() {
    var O = 9007199254740992, z = Math.random() * O & 2097151 ? function() {
      return Nl(Math.random() * O);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(H) {
      var Q, Y, ee, ie, X, Z = 0, J = [], K = new I(o);
      if (H == null ? H = s : Ti(H, 0, Uo), ie = zR(H / Vn), v)
        if (crypto.getRandomValues) {
          for (Q = crypto.getRandomValues(new Uint32Array(ie *= 2)); Z < ie; )
            X = Q[Z] * 131072 + (Q[Z + 1] >>> 11), X >= 9e15 ? (Y = crypto.getRandomValues(new Uint32Array(2)), Q[Z] = Y[0], Q[Z + 1] = Y[1]) : (J.push(X % 1e14), Z += 2);
          Z = ie / 2;
        } else if (crypto.randomBytes) {
          for (Q = crypto.randomBytes(ie *= 7); Z < ie; )
            X = (Q[Z] & 31) * 281474976710656 + Q[Z + 1] * 1099511627776 + Q[Z + 2] * 4294967296 + Q[Z + 3] * 16777216 + (Q[Z + 4] << 16) + (Q[Z + 5] << 8) + Q[Z + 6], X >= 9e15 ? crypto.randomBytes(7).copy(Q, Z) : (J.push(X % 1e14), Z += 7);
          Z = ie / 7;
        } else
          throw v = !1, Error(Bs + "crypto unavailable");
      if (!v)
        for (; Z < ie; )
          X = z(), X < 9e15 && (J[Z++] = X % 1e14);
      for (ie = J[--Z], H %= Vn, ie && H && (X = $R[Vn - H], J[Z] = Nl(ie / X) * X); J[Z] === 0; J.pop(), Z--) ;
      if (Z < 0)
        J = [ee = 0];
      else {
        for (ee = -1; J[0] === 0; J.splice(0, 1), ee -= Vn) ;
        for (Z = 1, X = J[0]; X >= 10; X /= 10, Z++) ;
        Z < Vn && (ee -= Vn - Z);
      }
      return K.e = ee, K.c = J, K;
    };
  }(), I.sum = function() {
    for (var O = 1, z = arguments, H = new I(z[0]); O < z.length; ) H = H.plus(z[O++]);
    return H;
  }, n = /* @__PURE__ */ function() {
    var O = "0123456789";
    function z(H, Q, Y, ee) {
      for (var ie, X = [0], Z, J = 0, K = H.length; J < K; ) {
        for (Z = X.length; Z--; X[Z] *= Q) ;
        for (X[0] += ee.indexOf(H.charAt(J++)), ie = 0; ie < X.length; ie++)
          X[ie] > Y - 1 && (X[ie + 1] == null && (X[ie + 1] = 0), X[ie + 1] += X[ie] / Y | 0, X[ie] %= Y);
      }
      return X.reverse();
    }
    return function(H, Q, Y, ee, ie) {
      var X, Z, J, K, oe, be, ce, pe, Ee = H.indexOf("."), Se = s, Me = c;
      for (Ee >= 0 && (K = C, C = 0, H = H.replace(".", ""), pe = new I(Q), be = pe.pow(H.length - Ee), C = K, pe.c = z(
        Md(Dl(be.c), be.e, "0"),
        10,
        Y,
        O
      ), pe.e = pe.c.length), ce = z(H, Q, Y, ie ? (X = A, O) : (X = O, A)), J = K = ce.length; ce[--K] == 0; ce.pop()) ;
      if (!ce[0]) return X.charAt(0);
      if (Ee < 0 ? --J : (be.c = ce, be.e = J, be.s = ee, be = t(be, pe, Se, Me, Y), ce = be.c, oe = be.r, J = be.e), Z = J + Se + 1, Ee = ce[Z], K = Y / 2, oe = oe || Z < 0 || ce[Z + 1] != null, oe = Me < 4 ? (Ee != null || oe) && (Me == 0 || Me == (be.s < 0 ? 3 : 2)) : Ee > K || Ee == K && (Me == 4 || oe || Me == 6 && ce[Z - 1] & 1 || Me == (be.s < 0 ? 8 : 7)), Z < 1 || !ce[0])
        H = oe ? Md(X.charAt(1), -Se, X.charAt(0)) : X.charAt(0);
      else {
        if (ce.length = Z, oe)
          for (--Y; ++ce[--Z] > Y; )
            ce[Z] = 0, Z || (++J, ce = [1].concat(ce));
        for (K = ce.length; !ce[--K]; ) ;
        for (Ee = 0, H = ""; Ee <= K; H += X.charAt(ce[Ee++])) ;
        H = Md(H, J, X.charAt(0));
      }
      return H;
    };
  }(), t = /* @__PURE__ */ function() {
    function O(Q, Y, ee) {
      var ie, X, Z, J, K = 0, oe = Q.length, be = Y % gh, ce = Y / gh | 0;
      for (Q = Q.slice(); oe--; )
        Z = Q[oe] % gh, J = Q[oe] / gh | 0, ie = ce * Z + J * be, X = be * Z + ie % gh * gh + K, K = (X / ee | 0) + (ie / gh | 0) + ce * J, Q[oe] = X % ee;
      return K && (Q = [K].concat(Q)), Q;
    }
    function z(Q, Y, ee, ie) {
      var X, Z;
      if (ee != ie)
        Z = ee > ie ? 1 : -1;
      else
        for (X = Z = 0; X < ee; X++)
          if (Q[X] != Y[X]) {
            Z = Q[X] > Y[X] ? 1 : -1;
            break;
          }
      return Z;
    }
    function H(Q, Y, ee, ie) {
      for (var X = 0; ee--; )
        Q[ee] -= X, X = Q[ee] < Y[ee] ? 1 : 0, Q[ee] = X * ie + Q[ee] - Y[ee];
      for (; !Q[0] && Q.length > 1; Q.splice(0, 1)) ;
    }
    return function(Q, Y, ee, ie, X) {
      var Z, J, K, oe, be, ce, pe, Ee, Se, Me, Fe, st, mt, yt, Ut, hn, wn, Ot = Q.s == Y.s ? 1 : -1, xt = Q.c, zt = Y.c;
      if (!xt || !xt[0] || !zt || !zt[0])
        return new I(
          // Return NaN if either NaN, or both Infinity or 0.
          !Q.s || !Y.s || (xt ? zt && xt[0] == zt[0] : !zt) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            xt && xt[0] == 0 || !zt ? Ot * 0 : Ot / 0
          )
        );
      for (Ee = new I(Ot), Se = Ee.c = [], J = Q.e - Y.e, Ot = ee + J + 1, X || (X = Mc, J = Bl(Q.e / Vn) - Bl(Y.e / Vn), Ot = Ot / Vn | 0), K = 0; zt[K] == (xt[K] || 0); K++) ;
      if (zt[K] > (xt[K] || 0) && J--, Ot < 0)
        Se.push(1), oe = !0;
      else {
        for (yt = xt.length, hn = zt.length, K = 0, Ot += 2, be = Nl(X / (zt[0] + 1)), be > 1 && (zt = O(zt, be, X), xt = O(xt, be, X), hn = zt.length, yt = xt.length), mt = hn, Me = xt.slice(0, hn), Fe = Me.length; Fe < hn; Me[Fe++] = 0) ;
        wn = zt.slice(), wn = [0].concat(wn), Ut = zt[0], zt[1] >= X / 2 && Ut++;
        do {
          if (be = 0, Z = z(zt, Me, hn, Fe), Z < 0) {
            if (st = Me[0], hn != Fe && (st = st * X + (Me[1] || 0)), be = Nl(st / Ut), be > 1)
              for (be >= X && (be = X - 1), ce = O(zt, be, X), pe = ce.length, Fe = Me.length; z(ce, Me, pe, Fe) == 1; )
                be--, H(ce, hn < pe ? wn : zt, pe, X), pe = ce.length, Z = 1;
            else
              be == 0 && (Z = be = 1), ce = zt.slice(), pe = ce.length;
            if (pe < Fe && (ce = [0].concat(ce)), H(Me, ce, Fe, X), Fe = Me.length, Z == -1)
              for (; z(zt, Me, hn, Fe) < 1; )
                be++, H(Me, hn < Fe ? wn : zt, Fe, X), Fe = Me.length;
          } else Z === 0 && (be++, Me = [0]);
          Se[K++] = be, Me[0] ? Me[Fe++] = xt[mt] || 0 : (Me = [xt[mt]], Fe = 1);
        } while ((mt++ < yt || Me[0] != null) && Ot--);
        oe = Me[0] != null, Se[0] || Se.splice(0, 1);
      }
      if (X == Mc) {
        for (K = 1, Ot = Se[0]; Ot >= 10; Ot /= 10, K++) ;
        j(Ee, ee + (Ee.e = K + J * Vn - 1) + 1, ie, oe);
      } else
        Ee.e = J, Ee.r = +oe;
      return Ee;
    };
  }();
  function D(O, z, H, Q) {
    var Y, ee, ie, X, Z;
    if (H == null ? H = c : Ti(H, 0, 8), !O.c) return O.toString();
    if (Y = O.c[0], ie = O.e, z == null)
      Z = Dl(O.c), Z = Q == 1 || Q == 2 && (ie <= u || ie >= f) ? yk(Z, ie) : Md(Z, ie, "0");
    else if (O = j(new I(O), z, H), ee = O.e, Z = Dl(O.c), X = Z.length, Q == 1 || Q == 2 && (z <= ee || ee <= u)) {
      for (; X < z; Z += "0", X++) ;
      Z = yk(Z, ee);
    } else if (z -= ie, Z = Md(Z, ee, "0"), ee + 1 > X) {
      if (--z > 0) for (Z += "."; z--; Z += "0") ;
    } else if (z += ee - X, z > 0)
      for (ee + 1 == X && (Z += "."); z--; Z += "0") ;
    return O.s < 0 && Y ? "-" + Z : Z;
  }
  function M(O, z) {
    for (var H, Q, Y = 1, ee = new I(O[0]); Y < O.length; Y++)
      Q = new I(O[Y]), (!Q.s || (H = ym(ee, Q)) === z || H === 0 && ee.s === z) && (ee = Q);
    return ee;
  }
  function L(O, z, H) {
    for (var Q = 1, Y = z.length; !z[--Y]; z.pop()) ;
    for (Y = z[0]; Y >= 10; Y /= 10, Q++) ;
    return (H = Q + H * Vn - 1) > y ? O.c = O.e = null : H < p ? O.c = [O.e = 0] : (O.e = H, O.c = z), O;
  }
  r = /* @__PURE__ */ function() {
    var O = /^(-?)0([xbo])(?=\w[\w.]*$)/i, z = /^([^.]+)\.$/, H = /^\.([^.]+)$/, Q = /^-?(Infinity|NaN)$/, Y = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(ee, ie, X, Z) {
      var J, K = X ? ie : ie.replace(Y, "");
      if (Q.test(K))
        ee.s = isNaN(K) ? null : K < 0 ? -1 : 1;
      else {
        if (!X && (K = K.replace(O, function(oe, be, ce) {
          return J = (ce = ce.toLowerCase()) == "x" ? 16 : ce == "b" ? 2 : 8, !Z || Z == J ? be : oe;
        }), Z && (J = Z, K = K.replace(z, "$1").replace(H, "0.$1")), ie != K))
          return new I(K, J);
        if (I.DEBUG)
          throw Error(Bs + "Not a" + (Z ? " base " + Z : "") + " number: " + ie);
        ee.s = null;
      }
      ee.c = ee.e = null;
    };
  }();
  function j(O, z, H, Q) {
    var Y, ee, ie, X, Z, J, K, oe = O.c, be = $R;
    if (oe) {
      e: {
        for (Y = 1, X = oe[0]; X >= 10; X /= 10, Y++) ;
        if (ee = z - Y, ee < 0)
          ee += Vn, ie = z, Z = oe[J = 0], K = Nl(Z / be[Y - ie - 1] % 10);
        else if (J = zR((ee + 1) / Vn), J >= oe.length)
          if (Q) {
            for (; oe.length <= J; oe.push(0)) ;
            Z = K = 0, Y = 1, ee %= Vn, ie = ee - Vn + 1;
          } else
            break e;
        else {
          for (Z = X = oe[J], Y = 1; X >= 10; X /= 10, Y++) ;
          ee %= Vn, ie = ee - Vn + Y, K = ie < 0 ? 0 : Nl(Z / be[Y - ie - 1] % 10);
        }
        if (Q = Q || z < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        oe[J + 1] != null || (ie < 0 ? Z : Z % be[Y - ie - 1]), Q = H < 4 ? (K || Q) && (H == 0 || H == (O.s < 0 ? 3 : 2)) : K > 5 || K == 5 && (H == 4 || Q || H == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (ee > 0 ? ie > 0 ? Z / be[Y - ie] : 0 : oe[J - 1]) % 10 & 1 || H == (O.s < 0 ? 8 : 7)), z < 1 || !oe[0])
          return oe.length = 0, Q ? (z -= O.e + 1, oe[0] = be[(Vn - z % Vn) % Vn], O.e = -z || 0) : oe[0] = O.e = 0, O;
        if (ee == 0 ? (oe.length = J, X = 1, J--) : (oe.length = J + 1, X = be[Vn - ee], oe[J] = ie > 0 ? Nl(Z / be[Y - ie] % be[ie]) * X : 0), Q)
          for (; ; )
            if (J == 0) {
              for (ee = 1, ie = oe[0]; ie >= 10; ie /= 10, ee++) ;
              for (ie = oe[0] += X, X = 1; ie >= 10; ie /= 10, X++) ;
              ee != X && (O.e++, oe[0] == Mc && (oe[0] = 1));
              break;
            } else {
              if (oe[J] += X, oe[J] != Mc) break;
              oe[J--] = 0, X = 1;
            }
        for (ee = oe.length; oe[--ee] === 0; oe.pop()) ;
      }
      O.e > y ? O.c = O.e = null : O.e < p && (O.c = [O.e = 0]);
    }
    return O;
  }
  function F(O) {
    var z, H = O.e;
    return H === null ? O.toString() : (z = Dl(O.c), z = H <= u || H >= f ? yk(z, H) : Md(z, H, "0"), O.s < 0 ? "-" + z : z);
  }
  return i.absoluteValue = i.abs = function() {
    var O = new I(this);
    return O.s < 0 && (O.s = 1), O;
  }, i.comparedTo = function(O, z) {
    return ym(this, new I(O, z));
  }, i.decimalPlaces = i.dp = function(O, z) {
    var H, Q, Y, ee = this;
    if (O != null)
      return Ti(O, 0, Uo), z == null ? z = c : Ti(z, 0, 8), j(new I(ee), O + ee.e + 1, z);
    if (!(H = ee.c)) return null;
    if (Q = ((Y = H.length - 1) - Bl(this.e / Vn)) * Vn, Y = H[Y]) for (; Y % 10 == 0; Y /= 10, Q--) ;
    return Q < 0 && (Q = 0), Q;
  }, i.dividedBy = i.div = function(O, z) {
    return t(this, new I(O, z), s, c);
  }, i.dividedToIntegerBy = i.idiv = function(O, z) {
    return t(this, new I(O, z), 0, 1);
  }, i.exponentiatedBy = i.pow = function(O, z) {
    var H, Q, Y, ee, ie, X, Z, J, K, oe = this;
    if (O = new I(O), O.c && !O.isInteger())
      throw Error(Bs + "Exponent not an integer: " + F(O));
    if (z != null && (z = new I(z)), X = O.e > 14, !oe.c || !oe.c[0] || oe.c[0] == 1 && !oe.e && oe.c.length == 1 || !O.c || !O.c[0])
      return K = new I(Math.pow(+F(oe), X ? O.s * (2 - mk(O)) : +F(O))), z ? K.mod(z) : K;
    if (Z = O.s < 0, z) {
      if (z.c ? !z.c[0] : !z.s) return new I(NaN);
      Q = !Z && oe.isInteger() && z.isInteger(), Q && (oe = oe.mod(z));
    } else {
      if (O.e > 9 && (oe.e > 0 || oe.e < -1 || (oe.e == 0 ? oe.c[0] > 1 || X && oe.c[1] >= 24e7 : oe.c[0] < 8e13 || X && oe.c[0] <= 9999975e7)))
        return ee = oe.s < 0 && mk(O) ? -0 : 0, oe.e > -1 && (ee = 1 / ee), new I(Z ? 1 / ee : ee);
      C && (ee = zR(C / Vn + 2));
    }
    for (X ? (H = new I(0.5), Z && (O.s = 1), J = mk(O)) : (Y = Math.abs(+F(O)), J = Y % 2), K = new I(o); ; ) {
      if (J) {
        if (K = K.times(oe), !K.c) break;
        ee ? K.c.length > ee && (K.c.length = ee) : Q && (K = K.mod(z));
      }
      if (Y) {
        if (Y = Nl(Y / 2), Y === 0) break;
        J = Y % 2;
      } else if (O = O.times(H), j(O, O.e + 1, 1), O.e > 14)
        J = mk(O);
      else {
        if (Y = +F(O), Y === 0) break;
        J = Y % 2;
      }
      oe = oe.times(oe), ee ? oe.c && oe.c.length > ee && (oe.c.length = ee) : Q && (oe = oe.mod(z));
    }
    return Q ? K : (Z && (K = o.div(K)), z ? K.mod(z) : ee ? j(K, C, c, ie) : K);
  }, i.integerValue = function(O) {
    var z = new I(this);
    return O == null ? O = c : Ti(O, 0, 8), j(z, z.e + 1, O);
  }, i.isEqualTo = i.eq = function(O, z) {
    return ym(this, new I(O, z)) === 0;
  }, i.isFinite = function() {
    return !!this.c;
  }, i.isGreaterThan = i.gt = function(O, z) {
    return ym(this, new I(O, z)) > 0;
  }, i.isGreaterThanOrEqualTo = i.gte = function(O, z) {
    return (z = ym(this, new I(O, z))) === 1 || z === 0;
  }, i.isInteger = function() {
    return !!this.c && Bl(this.e / Vn) > this.c.length - 2;
  }, i.isLessThan = i.lt = function(O, z) {
    return ym(this, new I(O, z)) < 0;
  }, i.isLessThanOrEqualTo = i.lte = function(O, z) {
    return (z = ym(this, new I(O, z))) === -1 || z === 0;
  }, i.isNaN = function() {
    return !this.s;
  }, i.isNegative = function() {
    return this.s < 0;
  }, i.isPositive = function() {
    return this.s > 0;
  }, i.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, i.minus = function(O, z) {
    var H, Q, Y, ee, ie = this, X = ie.s;
    if (O = new I(O, z), z = O.s, !X || !z) return new I(NaN);
    if (X != z)
      return O.s = -z, ie.plus(O);
    var Z = ie.e / Vn, J = O.e / Vn, K = ie.c, oe = O.c;
    if (!Z || !J) {
      if (!K || !oe) return K ? (O.s = -z, O) : new I(oe ? ie : NaN);
      if (!K[0] || !oe[0])
        return oe[0] ? (O.s = -z, O) : new I(K[0] ? ie : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          c == 3 ? -0 : 0
        ));
    }
    if (Z = Bl(Z), J = Bl(J), K = K.slice(), X = Z - J) {
      for ((ee = X < 0) ? (X = -X, Y = K) : (J = Z, Y = oe), Y.reverse(), z = X; z--; Y.push(0)) ;
      Y.reverse();
    } else
      for (Q = (ee = (X = K.length) < (z = oe.length)) ? X : z, X = z = 0; z < Q; z++)
        if (K[z] != oe[z]) {
          ee = K[z] < oe[z];
          break;
        }
    if (ee && (Y = K, K = oe, oe = Y, O.s = -O.s), z = (Q = oe.length) - (H = K.length), z > 0) for (; z--; K[H++] = 0) ;
    for (z = Mc - 1; Q > X; ) {
      if (K[--Q] < oe[Q]) {
        for (H = Q; H && !K[--H]; K[H] = z) ;
        --K[H], K[Q] += Mc;
      }
      K[Q] -= oe[Q];
    }
    for (; K[0] == 0; K.splice(0, 1), --J) ;
    return K[0] ? L(O, K, J) : (O.s = c == 3 ? -1 : 1, O.c = [O.e = 0], O);
  }, i.modulo = i.mod = function(O, z) {
    var H, Q, Y = this;
    return O = new I(O, z), !Y.c || !O.s || O.c && !O.c[0] ? new I(NaN) : !O.c || Y.c && !Y.c[0] ? new I(Y) : (w == 9 ? (Q = O.s, O.s = 1, H = t(Y, O, 0, 3), O.s = Q, H.s *= Q) : H = t(Y, O, 0, w), O = Y.minus(H.times(O)), !O.c[0] && w == 1 && (O.s = Y.s), O);
  }, i.multipliedBy = i.times = function(O, z) {
    var H, Q, Y, ee, ie, X, Z, J, K, oe, be, ce, pe, Ee, Se, Me = this, Fe = Me.c, st = (O = new I(O, z)).c;
    if (!Fe || !st || !Fe[0] || !st[0])
      return !Me.s || !O.s || Fe && !Fe[0] && !st || st && !st[0] && !Fe ? O.c = O.e = O.s = null : (O.s *= Me.s, !Fe || !st ? O.c = O.e = null : (O.c = [0], O.e = 0)), O;
    for (Q = Bl(Me.e / Vn) + Bl(O.e / Vn), O.s *= Me.s, Z = Fe.length, oe = st.length, Z < oe && (pe = Fe, Fe = st, st = pe, Y = Z, Z = oe, oe = Y), Y = Z + oe, pe = []; Y--; pe.push(0)) ;
    for (Ee = Mc, Se = gh, Y = oe; --Y >= 0; ) {
      for (H = 0, be = st[Y] % Se, ce = st[Y] / Se | 0, ie = Z, ee = Y + ie; ee > Y; )
        J = Fe[--ie] % Se, K = Fe[ie] / Se | 0, X = ce * J + K * be, J = be * J + X % Se * Se + pe[ee] + H, H = (J / Ee | 0) + (X / Se | 0) + ce * K, pe[ee--] = J % Ee;
      pe[ee] = H;
    }
    return H ? ++Q : pe.splice(0, 1), L(O, pe, Q);
  }, i.negated = function() {
    var O = new I(this);
    return O.s = -O.s || null, O;
  }, i.plus = function(O, z) {
    var H, Q = this, Y = Q.s;
    if (O = new I(O, z), z = O.s, !Y || !z) return new I(NaN);
    if (Y != z)
      return O.s = -z, Q.minus(O);
    var ee = Q.e / Vn, ie = O.e / Vn, X = Q.c, Z = O.c;
    if (!ee || !ie) {
      if (!X || !Z) return new I(Y / 0);
      if (!X[0] || !Z[0]) return Z[0] ? O : new I(X[0] ? Q : Y * 0);
    }
    if (ee = Bl(ee), ie = Bl(ie), X = X.slice(), Y = ee - ie) {
      for (Y > 0 ? (ie = ee, H = Z) : (Y = -Y, H = X), H.reverse(); Y--; H.push(0)) ;
      H.reverse();
    }
    for (Y = X.length, z = Z.length, Y - z < 0 && (H = Z, Z = X, X = H, z = Y), Y = 0; z; )
      Y = (X[--z] = X[z] + Z[z] + Y) / Mc | 0, X[z] = Mc === X[z] ? 0 : X[z] % Mc;
    return Y && (X = [Y].concat(X), ++ie), L(O, X, ie);
  }, i.precision = i.sd = function(O, z) {
    var H, Q, Y, ee = this;
    if (O != null && O !== !!O)
      return Ti(O, 1, Uo), z == null ? z = c : Ti(z, 0, 8), j(new I(ee), O, z);
    if (!(H = ee.c)) return null;
    if (Y = H.length - 1, Q = Y * Vn + 1, Y = H[Y]) {
      for (; Y % 10 == 0; Y /= 10, Q--) ;
      for (Y = H[0]; Y >= 10; Y /= 10, Q++) ;
    }
    return O && ee.e + 1 > Q && (Q = ee.e + 1), Q;
  }, i.shiftedBy = function(O) {
    return Ti(O, -VR, VR), this.times("1e" + O);
  }, i.squareRoot = i.sqrt = function() {
    var O, z, H, Q, Y, ee = this, ie = ee.c, X = ee.s, Z = ee.e, J = s + 4, K = new I("0.5");
    if (X !== 1 || !ie || !ie[0])
      return new I(!X || X < 0 && (!ie || ie[0]) ? NaN : ie ? ee : 1 / 0);
    if (X = Math.sqrt(+F(ee)), X == 0 || X == 1 / 0 ? (z = Dl(ie), (z.length + Z) % 2 == 0 && (z += "0"), X = Math.sqrt(+z), Z = Bl((Z + 1) / 2) - (Z < 0 || Z % 2), X == 1 / 0 ? z = "5e" + Z : (z = X.toExponential(), z = z.slice(0, z.indexOf("e") + 1) + Z), H = new I(z)) : H = new I(X + ""), H.c[0]) {
      for (Z = H.e, X = Z + J, X < 3 && (X = 0); ; )
        if (Y = H, H = K.times(Y.plus(t(ee, Y, J, 1))), Dl(Y.c).slice(0, X) === (z = Dl(H.c)).slice(0, X))
          if (H.e < Z && --X, z = z.slice(X - 3, X + 1), z == "9999" || !Q && z == "4999") {
            if (!Q && (j(Y, Y.e + s + 2, 0), Y.times(Y).eq(ee))) {
              H = Y;
              break;
            }
            J += 4, X += 4, Q = 1;
          } else {
            (!+z || !+z.slice(1) && z.charAt(0) == "5") && (j(H, H.e + s + 2, 1), O = !H.times(H).eq(ee));
            break;
          }
    }
    return j(H, H.e + s + 1, c, O);
  }, i.toExponential = function(O, z) {
    return O != null && (Ti(O, 0, Uo), O++), D(this, O, z, 1);
  }, i.toFixed = function(O, z) {
    return O != null && (Ti(O, 0, Uo), O = O + this.e + 1), D(this, O, z);
  }, i.toFormat = function(O, z, H) {
    var Q, Y = this;
    if (H == null)
      O != null && z && typeof z == "object" ? (H = z, z = null) : O && typeof O == "object" ? (H = O, O = z = null) : H = x;
    else if (typeof H != "object")
      throw Error(Bs + "Argument not an object: " + H);
    if (Q = Y.toFixed(O, z), Y.c) {
      var ee, ie = Q.split("."), X = +H.groupSize, Z = +H.secondaryGroupSize, J = H.groupSeparator || "", K = ie[0], oe = ie[1], be = Y.s < 0, ce = be ? K.slice(1) : K, pe = ce.length;
      if (Z && (ee = X, X = Z, Z = ee, pe -= ee), X > 0 && pe > 0) {
        for (ee = pe % X || X, K = ce.substr(0, ee); ee < pe; ee += X) K += J + ce.substr(ee, X);
        Z > 0 && (K += J + ce.slice(ee)), be && (K = "-" + K);
      }
      Q = oe ? K + (H.decimalSeparator || "") + ((Z = +H.fractionGroupSize) ? oe.replace(
        new RegExp("\\d{" + Z + "}\\B", "g"),
        "$&" + (H.fractionGroupSeparator || "")
      ) : oe) : K;
    }
    return (H.prefix || "") + Q + (H.suffix || "");
  }, i.toFraction = function(O) {
    var z, H, Q, Y, ee, ie, X, Z, J, K, oe, be, ce = this, pe = ce.c;
    if (O != null && (X = new I(O), !X.isInteger() && (X.c || X.s !== 1) || X.lt(o)))
      throw Error(Bs + "Argument " + (X.isInteger() ? "out of range: " : "not an integer: ") + F(X));
    if (!pe) return new I(ce);
    for (z = new I(o), J = H = new I(o), Q = Z = new I(o), be = Dl(pe), ee = z.e = be.length - ce.e - 1, z.c[0] = $R[(ie = ee % Vn) < 0 ? Vn + ie : ie], O = !O || X.comparedTo(z) > 0 ? ee > 0 ? z : J : X, ie = y, y = 1 / 0, X = new I(be), Z.c[0] = 0; K = t(X, z, 0, 1), Y = H.plus(K.times(Q)), Y.comparedTo(O) != 1; )
      H = Q, Q = Y, J = Z.plus(K.times(Y = J)), Z = Y, z = X.minus(K.times(Y = z)), X = Y;
    return Y = t(O.minus(H), Q, 0, 1), Z = Z.plus(Y.times(J)), H = H.plus(Y.times(Q)), Z.s = J.s = ce.s, ee = ee * 2, oe = t(J, Q, ee, c).minus(ce).abs().comparedTo(
      t(Z, H, ee, c).minus(ce).abs()
    ) < 1 ? [J, Q] : [Z, H], y = ie, oe;
  }, i.toNumber = function() {
    return +F(this);
  }, i.toPrecision = function(O, z) {
    return O != null && Ti(O, 1, Uo), D(this, O, z, 2);
  }, i.toString = function(O) {
    var z, H = this, Q = H.s, Y = H.e;
    return Y === null ? Q ? (z = "Infinity", Q < 0 && (z = "-" + z)) : z = "NaN" : (O == null ? z = Y <= u || Y >= f ? yk(Dl(H.c), Y) : Md(Dl(H.c), Y, "0") : O === 10 && R ? (H = j(new I(H), s + Y + 1, c), z = Md(Dl(H.c), H.e, "0")) : (Ti(O, 2, A.length, "Base"), z = n(Md(Dl(H.c), Y, "0"), 10, O, Q, !0)), Q < 0 && H.c[0] && (z = "-" + z)), z;
  }, i.valueOf = i.toJSON = function() {
    return F(this);
  }, i._isBigNumber = !0, i[Symbol.toStringTag] = "BigNumber", i[Symbol.for("nodejs.util.inspect.custom")] = i.valueOf, e != null && I.set(e), I;
}
function Bl(e) {
  var t = e | 0;
  return e > 0 || e === t ? t : t - 1;
}
function Dl(e) {
  for (var t, n, r = 1, i = e.length, o = e[0] + ""; r < i; ) {
    for (t = e[r++] + "", n = Vn - t.length; n--; t = "0" + t) ;
    o += t;
  }
  for (i = o.length; o.charCodeAt(--i) === 48; ) ;
  return o.slice(0, i + 1 || 1);
}
function ym(e, t) {
  var n, r, i = e.c, o = t.c, s = e.s, c = t.s, u = e.e, f = t.e;
  if (!s || !c) return null;
  if (n = i && !i[0], r = o && !o[0], n || r) return n ? r ? 0 : -c : s;
  if (s != c) return s;
  if (n = s < 0, r = u == f, !i || !o) return r ? 0 : !i ^ n ? 1 : -1;
  if (!r) return u > f ^ n ? 1 : -1;
  for (c = (u = i.length) < (f = o.length) ? u : f, s = 0; s < c; s++) if (i[s] != o[s]) return i[s] > o[s] ^ n ? 1 : -1;
  return u == f ? 0 : u > f ^ n ? 1 : -1;
}
function Ti(e, t, n, r) {
  if (e < t || e > n || e !== Nl(e))
    throw Error(Bs + (r || "Argument") + (typeof e == "number" ? e < t || e > n ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(e));
}
function mk(e) {
  var t = e.c.length - 1;
  return Bl(e.e / Vn) == t && e.c[t] % 2 != 0;
}
function yk(e, t) {
  return (e.length > 1 ? e.charAt(0) + "." + e.slice(1) : e) + (t < 0 ? "e" : "e+") + t;
}
function Md(e, t, n) {
  var r, i;
  if (t < 0) {
    for (i = n + "."; ++t; i += n) ;
    e = i + e;
  } else if (r = e.length, ++t > r) {
    for (i = n, t -= r; --t; i += n) ;
    e += i;
  } else t < r && (e = e.slice(0, t) + "." + e.slice(t));
  return e;
}
var Nt = c$();
const _je = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BigNumber: Nt,
  default: Nt
}, Symbol.toStringTag, { value: "Module" })), jj = "https://assets.stakek.it", ni = {
  appName: "StakeKit",
  appIcon: `${jj}/stakekit/sk-icon_320x320.png`,
  appUrl: "https://stakek.it",
  currency: "USD",
  queryClient: {
    staleTime: 1e3 * 5,
    cacheTime: 1e3 * 60 * 5
  },
  walletConnectV2: {
    projectId: "10a5257c04d1d3097ff768a139c95f50"
  },
  appPrefix: "sk-widget",
  env: {
    apiUrl: "https://api.stakek.it/",
    isTestMode: !1,
    isDevMode: !1,
    forceAddress: void 0
  },
  assetsUrl: jj,
  zerion: {
    tracking: "2cbed59baa70c46f7cadef7b05eb1bc3",
    iconsByAddress: "https://token-icons.s3.amazonaws.com/",
    iconsByNetwork: "https://chain-icons.s3.amazonaws.com/"
  }
}, Ro = he.fromNullable(
  typeof window > "u" ? null : window
);
Nt.config({
  FORMAT: {
    prefix: "",
    decimalSeparator: ".",
    groupSeparator: ",",
    groupSize: 3,
    secondaryGroupSize: 0,
    fractionGroupSeparator: " ",
    fractionGroupSize: 0,
    suffix: ""
  }
});
const To = (e, t) => _n(Nt(e)).map(
  (n) => t ? n.decimalPlaces(t, Nt.ROUND_DOWN) : n
).map((n) => n.toFormat()).unsafeCoerce(), Na = (e) => To(e, 6), e5 = (e) => (e * 100).toFixed(2), HR = ["#6B69D6", "#F1C40F", "#1ABC9C", "#E74C3C"], xue = (e) => {
  const t = e.charCodeAt(0);
  return HR[t % HR.length] ?? HR[0];
}, Rje = () => Ro.map((e) => e.parent !== e).orDefault(!1), BC = /* @__PURE__ */ (() => {
  let e = null;
  return () => typeof e == "boolean" ? e : Ro.map((t) => {
    try {
      e = !!new URLSearchParams(t.self.location.search).get("embed");
    } catch {
      e = !1;
    }
    return !!e;
  }).orDefault(!1);
})(), Bh = (e) => `${ni.assetsUrl}/networks/${e}.svg`, ay = (e) => `${ni.assetsUrl}/tokens/${e}.svg`, u$ = (e) => new Promise((t) => setTimeout(t, e)), E8 = (e) => Object.fromEntries(e), S8 = (e) => Object.entries(e);
function I4(e, t) {
  const n = (t == null ? void 0 : t.leadingChars) ?? 4, r = (t == null ? void 0 : t.trailingChars) ?? 4;
  return e.length < n + r ? e : `${e.substring(0, n)}${e.substring(
    e.length - r
  )}`;
}
const Eue = () => {
  let e = !1;
  const t = () => {
    try {
      return typeof window > "u" ? !1 : (document.createEvent("TouchEvent"), !0);
    } catch {
      return !1;
    }
  };
  return e = typeof window > "u" ? !1 : !!(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(
    navigator.userAgent
  ) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(
    navigator.userAgent.substring(0, 4)
  ) || t()), e;
}, Sue = (e, t) => t.multipliedBy(e).dividedBy(1e4), kue = (e) => Nt(e).dividedBy(100).toNumber(), Aue = (e, t) => {
  const n = /* @__PURE__ */ new Date(), r = new Date(n);
  r.setDate(n.getDate() - 1);
  const i = (f) => f.toLocaleDateString(t.language, {
    year: "numeric",
    month: "long",
    day: "numeric"
  }), o = {}, s = {};
  e.forEach((f) => {
    const p = new Date(f);
    let y;
    p.toDateString() === n.toDateString() ? y = "today" : p.toDateString() === r.toDateString() ? y = "yesterday" : y = i(p), s[y] ? s[y]++ : (s[y] = 1, o[y] = y);
  });
  const c = Object.values(o), u = Object.values(s);
  return [c, u];
}, Tue = (e) => {
  var t, n;
  return !!(Qd(e) && e.response && ((t = e.response) == null ? void 0 : t.status) >= 400 && ((n = e.response) == null ? void 0 : n.status) < 500);
}, t5 = (e) => {
  var t;
  return !!((t = e.response) != null && t.status && e.response.status >= 500);
}, _ue = ({
  error: e,
  retryCount: t,
  retryTimes: n
}) => Qd(e) && t5(e) && t < n, Ia = ({
  fn: e,
  retryTimes: t = 2,
  shouldRetry: n,
  retryWaitForMs: r
}) => {
  let i = 0;
  return Ye(async () => {
    try {
      return await e();
    } catch (s) {
      let c = s;
      for (; (n == null ? void 0 : n(s, i)) ?? _ue({ error: c, retryCount: i, retryTimes: t }); )
        try {
          return await u$((r == null ? void 0 : r()) ?? 2 ** (i + 1) * 1e3), await e();
        } catch (u) {
          c = u, i++;
        }
      throw c;
    }
  });
};
var Pu = {
  CANCELED: "CANCELED",
  CREATED: "CREATED",
  WAITING_FOR_NEXT: "WAITING_FOR_NEXT",
  PROCESSING: "PROCESSING",
  FAILED: "FAILED",
  SUCCESS: "SUCCESS"
}, Tm = {
  STAKE: "STAKE",
  UNSTAKE: "UNSTAKE",
  CLAIM_REWARDS: "CLAIM_REWARDS",
  RESTAKE_REWARDS: "RESTAKE_REWARDS",
  WITHDRAW: "WITHDRAW",
  RESTAKE: "RESTAKE",
  CLAIM_UNSTAKED: "CLAIM_UNSTAKED",
  UNLOCK_LOCKED: "UNLOCK_LOCKED",
  STAKE_LOCKED: "STAKE_LOCKED",
  VOTE: "VOTE",
  REVOKE: "REVOKE",
  VOTE_LOCKED: "VOTE_LOCKED",
  REVOTE: "REVOTE",
  REBOND: "REBOND",
  MIGRATE: "MIGRATE"
}, Rue = {
  GEO_LOCATION: "GEO_LOCATION"
}, Fj = {
  NOT_FOUND: "NOT_FOUND",
  CREATED: "CREATED",
  BLOCKED: "BLOCKED",
  WAITING_FOR_SIGNATURE: "WAITING_FOR_SIGNATURE",
  SIGNED: "SIGNED",
  BROADCASTED: "BROADCASTED",
  PENDING: "PENDING",
  CONFIRMED: "CONFIRMED",
  FAILED: "FAILED",
  SKIPPED: "SKIPPED"
}, d$ = k.createContext(void 0), Oue = ({
  children: e,
  ...t
}) => /* @__PURE__ */ S.jsx(d$.Provider, { value: t, children: e }), Iue = () => {
  const e = k.useContext(d$);
  if (!e)
    throw new Error("ApiClient must be used within a ApiHooksProvider");
  return e;
}, Due = "https://api.stakek.it/", Mue = ({
  baseURL: e,
  path: t,
  params: n
}) => {
  const r = new URL(e);
  if (r.pathname = t, n) {
    const i = new URLSearchParams();
    Object.keys(n).forEach((o) => {
      const s = n[o];
      s == null || s === "" || i.append(o, n[o]);
    }), r.search = i.toString();
  }
  return r.toString();
}, ci = () => {
  const {
    fetchInstance: e,
    apiKey: t,
    baseURL: n = Due
  } = Iue();
  return ({
    url: r,
    data: i,
    method: o,
    params: s,
    headers: c,
    signal: u
  }) => e(Mue({ baseURL: n, path: r, params: s }), {
    method: o,
    data: i,
    headers: { ...c, "X-API-KEY": t },
    signal: u
  });
}, Pue = () => {
  const e = ci();
  return (t) => e({ url: "/v2/health", method: "GET", signal: t });
}, Nue = () => ["/v2/health"], Bue = (e) => {
  const { query: t } = e ?? {}, n = (t == null ? void 0 : t.queryKey) ?? Nue(), r = Pue();
  return { queryKey: n, queryFn: ({ signal: o }) => r(o), ...t };
}, Lue = (e) => {
  const t = Bue(e), n = Qr(t);
  return n.queryKey = t.queryKey, n;
}, jue = () => {
  const e = ci();
  return (t) => e({
    url: "/v1/actions/enter",
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: t
  });
}, Fue = () => {
  const e = ci();
  return (t) => e({
    url: "/v1/actions/exit",
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: t
  });
}, Uue = () => {
  const e = ci();
  return (t) => e({
    url: "/v1/actions/pending",
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: t
  });
}, zue = () => {
  const e = ci();
  return (t) => e({
    url: "/v1/actions/enter/estimate-gas",
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: t
  });
}, Vue = (e) => [
  "/v1/actions/enter/estimate-gas",
  e
], $ue = (e, t) => {
  const { query: n } = t ?? {}, r = (n == null ? void 0 : n.queryKey) ?? Vue(e), i = zue();
  return { queryKey: r, queryFn: () => i(e), ...n };
}, Hue = (e, t) => {
  const n = $ue(
    e,
    t
  ), r = Qr(n);
  return r.queryKey = n.queryKey, r;
}, que = () => {
  const e = ci();
  return (t) => e({
    url: "/v1/actions/exit/estimate-gas",
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: t
  });
}, Wue = (e) => [
  "/v1/actions/exit/estimate-gas",
  e
], Gue = (e, t) => {
  const { query: n } = t ?? {}, r = (n == null ? void 0 : n.queryKey) ?? Wue(e), i = que();
  return { queryKey: r, queryFn: () => i(e), ...n };
}, Kue = (e, t) => {
  const n = Gue(
    e,
    t
  ), r = Qr(n);
  return r.queryKey = n.queryKey, r;
}, Yue = () => {
  const e = ci();
  return (t, n) => e({ url: "/v1/actions", method: "GET", params: t, signal: n });
}, Que = (e) => ["/v1/actions", ...e ? [e] : []], Xue = () => {
  const e = ci();
  return (t) => e({
    url: "/v1/actions/pending/estimate-gas",
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: t
  });
}, Jue = (e) => [
  "/v1/actions/pending/estimate-gas",
  e
], Zue = (e, t) => {
  const { query: n } = t ?? {}, r = (n == null ? void 0 : n.queryKey) ?? Jue(e), i = Xue();
  return { queryKey: r, queryFn: () => i(e), ...n };
}, ede = (e, t) => {
  const n = Zue(
    e,
    t
  ), r = Qr(n);
  return r.queryKey = n.queryKey, r;
}, tde = () => {
  const e = ci();
  return (t, n) => e({
    url: `/v1/transactions/${t}`,
    method: "GET",
    signal: n
  });
}, nde = () => {
  const e = ci();
  return (t, n) => e({
    url: `/v1/transactions/${t}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: n
  });
}, rde = () => {
  const e = ci();
  return (t, n) => e({
    url: `/v1/transactions/${t}/submit`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: n
  });
}, ide = () => {
  const e = ci();
  return (t, n) => e({
    url: `/v1/transactions/${t}/submit_hash`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: n
  });
}, ode = () => {
  const e = ci();
  return (t, n) => e({
    url: `/v1/transactions/${t}/status`,
    method: "GET",
    signal: n
  });
}, ade = () => {
  const e = ci();
  return (t, n) => e({
    url: `/v1/transactions/gas/${t}`,
    method: "GET",
    signal: n
  });
}, sde = () => {
  const e = ci();
  return (t, n) => e({
    url: `/v1/transactions/verification/${t}`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: n
  });
}, oM = () => {
  const e = ci();
  return (t, n) => e({ url: "/v1/tokens", method: "GET", params: t, signal: n });
}, f$ = (e) => ["/v1/tokens", ...e ? [e] : []], lde = () => {
  const e = ci();
  return (t) => e({
    url: "/v1/tokens/prices",
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: t
  });
}, cde = (e) => ["/v1/tokens/prices", e], ude = (e, t) => {
  const { query: n } = t ?? {}, r = (n == null ? void 0 : n.queryKey) ?? cde(e), i = lde();
  return { queryKey: r, queryFn: () => i(e), ...n };
}, dde = (e, t) => {
  const n = ude(
    e,
    t
  ), r = Qr(n);
  return r.queryKey = n.queryKey, r;
}, fde = () => {
  const e = ci();
  return (t) => e({
    url: "/v1/tokens/balances",
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: t
  });
}, aM = () => {
  const e = ci();
  return (t) => e({
    url: "/v1/tokens/balances/scan",
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: t
  });
}, sM = (e) => ["/v1/tokens/balances/scan", e], hde = () => {
  const e = ci();
  return (t) => e({
    url: "/v1/yields/balances/scan",
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: t
  });
}, lM = (e) => ["/v1/yields/balances/scan", e], pde = (e, t) => {
  const { query: n } = t ?? {}, r = (n == null ? void 0 : n.queryKey) ?? lM(e), i = hde();
  return { queryKey: r, queryFn: () => i(e), ...n };
}, mde = (e, t) => {
  const n = pde(
    e,
    t
  ), r = Qr(n);
  return r.queryKey = n.queryKey, r;
}, yde = () => {
  const e = ci();
  return (t) => e({
    url: "/v1/yields/enabled/networks",
    method: "GET",
    signal: t
  });
}, vde = () => {
  const e = ci();
  return (t, n) => e({
    url: "/v1/yields/validators",
    method: "GET",
    params: t,
    signal: n
  });
}, gde = (e) => ["/v1/yields/validators", ...e ? [e] : []], bde = (e, t) => {
  const { query: n } = t ?? {}, r = (n == null ? void 0 : n.queryKey) ?? gde(e), i = vde();
  return { queryKey: r, queryFn: ({ signal: s }) => i(e, s), ...n };
}, wde = (e, t) => {
  const n = bde(e, t), r = Qr(n);
  return r.queryKey = n.queryKey, r;
}, ap = () => {
  const e = ci();
  return (t, n, r) => e({
    url: `/v1/yields/${t}`,
    method: "GET",
    params: n,
    signal: r
  });
}, Cde = () => {
  const e = ci();
  return (t, n, r) => e({
    url: `/v1/yields/${t}/balances`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: n,
    params: r
  });
}, xde = () => {
  const e = ci();
  return (t, n) => e({
    url: `/v1/yields/${t}/fee-configuration`,
    method: "GET",
    signal: n
  });
}, Ede = (e) => [`/v1/yields/${e}/fee-configuration`], Sde = (e, t) => {
  const { query: n } = {}, r = (n == null ? void 0 : n.queryKey) ?? Ede(e), i = xde();
  return {
    queryKey: r,
    queryFn: ({ signal: s }) => i(e, s),
    enabled: !!e,
    ...n
  };
}, cM = (e, t) => {
  const n = Sde(
    e
  ), r = Qr(n);
  return r.queryKey = n.queryKey, r;
};
const i4 = /* @__PURE__ */ new Map(), n5 = /* @__PURE__ */ new Map(), kde = (e) => (n5.set(e, e), () => {
  n5.delete(e);
}), Ade = () => {
  n5.forEach((e) => e());
}, Tde = () => {
  if (i4.size === 0) return Promise.resolve();
  let e;
  return new Promise((t) => {
    e = kde(() => t(null));
  }).then(() => e());
}, _de = (e) => e.interceptors.request.use(async (t) => (await Tde(), t)), Rde = () => {
  const e = {};
  return i4.set(e, e), () => {
    i4.delete(e), i4.size === 0 && Ade();
  };
};
let D4 = !1;
const r5 = /* @__PURE__ */ new Map(), Ode = () => r5.forEach((e) => e(D4)), Ide = (e) => (r5.set(e, e), () => r5.delete(e)), Dde = (e) => e.interceptors.response.use(void 0, (t) => {
  var n, r;
  if (((n = t == null ? void 0 : t.response) == null ? void 0 : n.status) === 403 && ((r = t.response.data) == null ? void 0 : r.type) === Rue.GEO_LOCATION) {
    const i = t.response.data, o = i.regionCode ?? "";
    D4 = {
      tags: new Set(i.tags ?? []),
      countryCode: i.countryCode ?? "",
      regionCode: o
    }, Ode();
  }
  return Promise.reject(t);
}), Mde = () => k.useSyncExternalStore(
  k.useCallback((e) => {
    const t = Ide(e);
    return () => {
      t();
    };
  }, []),
  k.useCallback(() => D4, []),
  k.useCallback(() => D4, [])
);
var i5 = function(e, t) {
  return i5 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i]);
  }, i5(e, t);
};
function sy(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  i5(e, t);
  function n() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n());
}
var $l = function() {
  return $l = Object.assign || function(t) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, $l.apply(this, arguments);
};
function k8(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
}
function h$(e, t, n, r) {
  var i = arguments.length, o = i < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, n) : r, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(e, t, n, r);
  else for (var c = e.length - 1; c >= 0; c--) (s = e[c]) && (o = (i < 3 ? s(o) : i > 3 ? s(t, n, o) : s(t, n)) || o);
  return i > 3 && o && Object.defineProperty(t, n, o), o;
}
function p$(e, t) {
  return function(n, r) {
    t(n, r, e);
  };
}
function Pde(e, t, n, r, i, o) {
  function s(R) {
    if (R !== void 0 && typeof R != "function") throw new TypeError("Function expected");
    return R;
  }
  for (var c = r.kind, u = c === "getter" ? "get" : c === "setter" ? "set" : "value", f = !t && e ? r.static ? e : e.prototype : null, p = t || (f ? Object.getOwnPropertyDescriptor(f, r.name) : {}), y, v = !1, w = n.length - 1; w >= 0; w--) {
    var C = {};
    for (var x in r) C[x] = x === "access" ? {} : r[x];
    for (var x in r.access) C.access[x] = r.access[x];
    C.addInitializer = function(R) {
      if (v) throw new TypeError("Cannot add initializers after decoration has completed");
      o.push(s(R || null));
    };
    var A = (0, n[w])(c === "accessor" ? { get: p.get, set: p.set } : p[u], C);
    if (c === "accessor") {
      if (A === void 0) continue;
      if (A === null || typeof A != "object") throw new TypeError("Object expected");
      (y = s(A.get)) && (p.get = y), (y = s(A.set)) && (p.set = y), (y = s(A.init)) && i.unshift(y);
    } else (y = s(A)) && (c === "field" ? i.unshift(y) : p[u] = y);
  }
  f && Object.defineProperty(f, r.name, p), v = !0;
}
function Nde(e, t, n) {
  for (var r = arguments.length > 2, i = 0; i < t.length; i++)
    n = r ? t[i].call(e, n) : t[i].call(e);
  return r ? n : void 0;
}
function Bde(e) {
  return typeof e == "symbol" ? e : "".concat(e);
}
function Lde(e, t, n) {
  return typeof t == "symbol" && (t = t.description ? "[".concat(t.description, "]") : ""), Object.defineProperty(e, "name", { configurable: !0, value: n ? "".concat(n, " ", t) : t });
}
function m$(e, t) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(e, t);
}
function y$(e, t, n, r) {
  function i(o) {
    return o instanceof n ? o : new n(function(s) {
      s(o);
    });
  }
  return new (n || (n = Promise))(function(o, s) {
    function c(p) {
      try {
        f(r.next(p));
      } catch (y) {
        s(y);
      }
    }
    function u(p) {
      try {
        f(r.throw(p));
      } catch (y) {
        s(y);
      }
    }
    function f(p) {
      p.done ? o(p.value) : i(p.value).then(c, u);
    }
    f((r = r.apply(e, t || [])).next());
  });
}
function v$(e, t) {
  var n = { label: 0, sent: function() {
    if (o[0] & 1) throw o[1];
    return o[1];
  }, trys: [], ops: [] }, r, i, o, s;
  return s = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function c(f) {
    return function(p) {
      return u([f, p]);
    };
  }
  function u(f) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; s && (s = 0, f[0] && (n = 0)), n; ) try {
      if (r = 1, i && (o = f[0] & 2 ? i.return : f[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) && !(o = o.call(i, f[1])).done) return o;
      switch (i = 0, o && (f = [f[0] & 2, o.value]), f[0]) {
        case 0:
        case 1:
          o = f;
          break;
        case 4:
          return n.label++, { value: f[1], done: !1 };
        case 5:
          n.label++, i = f[1], f = [0];
          continue;
        case 7:
          f = n.ops.pop(), n.trys.pop();
          continue;
        default:
          if (o = n.trys, !(o = o.length > 0 && o[o.length - 1]) && (f[0] === 6 || f[0] === 2)) {
            n = 0;
            continue;
          }
          if (f[0] === 3 && (!o || f[1] > o[0] && f[1] < o[3])) {
            n.label = f[1];
            break;
          }
          if (f[0] === 6 && n.label < o[1]) {
            n.label = o[1], o = f;
            break;
          }
          if (o && n.label < o[2]) {
            n.label = o[2], n.ops.push(f);
            break;
          }
          o[2] && n.ops.pop(), n.trys.pop();
          continue;
      }
      f = t.call(e, n);
    } catch (p) {
      f = [6, p], i = 0;
    } finally {
      r = o = 0;
    }
    if (f[0] & 5) throw f[1];
    return { value: f[0] ? f[1] : void 0, done: !0 };
  }
}
var A8 = Object.create ? function(e, t, n, r) {
  r === void 0 && (r = n);
  var i = Object.getOwnPropertyDescriptor(t, n);
  (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return t[n];
  } }), Object.defineProperty(e, r, i);
} : function(e, t, n, r) {
  r === void 0 && (r = n), e[r] = t[n];
};
function g$(e, t) {
  for (var n in e) n !== "default" && !Object.prototype.hasOwnProperty.call(t, n) && A8(t, e, n);
}
function Km(e) {
  var t = typeof Symbol == "function" && Symbol.iterator, n = t && e[t], r = 0;
  if (n) return n.call(e);
  if (e && typeof e.length == "number") return {
    next: function() {
      return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e };
    }
  };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Qg(e, t) {
  var n = typeof Symbol == "function" && e[Symbol.iterator];
  if (!n) return e;
  var r = n.call(e), i, o = [], s;
  try {
    for (; (t === void 0 || t-- > 0) && !(i = r.next()).done; ) o.push(i.value);
  } catch (c) {
    s = { error: c };
  } finally {
    try {
      i && !i.done && (n = r.return) && n.call(r);
    } finally {
      if (s) throw s.error;
    }
  }
  return o;
}
function b$() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e = e.concat(Qg(arguments[t]));
  return e;
}
function w$() {
  for (var e = 0, t = 0, n = arguments.length; t < n; t++) e += arguments[t].length;
  for (var r = Array(e), i = 0, t = 0; t < n; t++)
    for (var o = arguments[t], s = 0, c = o.length; s < c; s++, i++)
      r[i] = o[s];
  return r;
}
function Xg(e, t, n) {
  if (n || arguments.length === 2) for (var r = 0, i = t.length, o; r < i; r++)
    (o || !(r in t)) && (o || (o = Array.prototype.slice.call(t, 0, r)), o[r] = t[r]);
  return e.concat(o || Array.prototype.slice.call(t));
}
function Jg(e) {
  return this instanceof Jg ? (this.v = e, this) : new Jg(e);
}
function C$(e, t, n) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(e, t || []), i, o = [];
  return i = {}, s("next"), s("throw"), s("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function s(v) {
    r[v] && (i[v] = function(w) {
      return new Promise(function(C, x) {
        o.push([v, w, C, x]) > 1 || c(v, w);
      });
    });
  }
  function c(v, w) {
    try {
      u(r[v](w));
    } catch (C) {
      y(o[0][3], C);
    }
  }
  function u(v) {
    v.value instanceof Jg ? Promise.resolve(v.value.v).then(f, p) : y(o[0][2], v);
  }
  function f(v) {
    c("next", v);
  }
  function p(v) {
    c("throw", v);
  }
  function y(v, w) {
    v(w), o.shift(), o.length && c(o[0][0], o[0][1]);
  }
}
function x$(e) {
  var t, n;
  return t = {}, r("next"), r("throw", function(i) {
    throw i;
  }), r("return"), t[Symbol.iterator] = function() {
    return this;
  }, t;
  function r(i, o) {
    t[i] = e[i] ? function(s) {
      return (n = !n) ? { value: Jg(e[i](s)), done: !1 } : o ? o(s) : s;
    } : o;
  }
}
function E$(e) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var t = e[Symbol.asyncIterator], n;
  return t ? t.call(e) : (e = typeof Km == "function" ? Km(e) : e[Symbol.iterator](), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function() {
    return this;
  }, n);
  function r(o) {
    n[o] = e[o] && function(s) {
      return new Promise(function(c, u) {
        s = e[o](s), i(c, u, s.done, s.value);
      });
    };
  }
  function i(o, s, c, u) {
    Promise.resolve(u).then(function(f) {
      o({ value: f, done: c });
    }, s);
  }
}
function S$(e, t) {
  return Object.defineProperty ? Object.defineProperty(e, "raw", { value: t }) : e.raw = t, e;
}
var jde = Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
};
function k$(e) {
  if (e && e.__esModule) return e;
  var t = {};
  if (e != null) for (var n in e) n !== "default" && Object.prototype.hasOwnProperty.call(e, n) && A8(t, e, n);
  return jde(t, e), t;
}
function A$(e) {
  return e && e.__esModule ? e : { default: e };
}
function T$(e, t, n, r) {
  if (n === "a" && !r) throw new TypeError("Private accessor was defined without a getter");
  if (typeof t == "function" ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? r : n === "a" ? r.call(e) : r ? r.value : t.get(e);
}
function _$(e, t, n, r, i) {
  if (r === "m") throw new TypeError("Private method is not writable");
  if (r === "a" && !i) throw new TypeError("Private accessor was defined without a setter");
  if (typeof t == "function" ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return r === "a" ? i.call(e, n) : i ? i.value = n : t.set(e, n), n;
}
function R$(e, t) {
  if (t === null || typeof t != "object" && typeof t != "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof e == "function" ? t === e : e.has(t);
}
function O$(e, t, n) {
  if (t != null) {
    if (typeof t != "object" && typeof t != "function") throw new TypeError("Object expected.");
    var r;
    if (n) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      r = t[Symbol.asyncDispose];
    }
    if (r === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      r = t[Symbol.dispose];
    }
    if (typeof r != "function") throw new TypeError("Object not disposable.");
    e.stack.push({ value: t, dispose: r, async: n });
  } else n && e.stack.push({ async: !0 });
  return t;
}
var Fde = typeof SuppressedError == "function" ? SuppressedError : function(e, t, n) {
  var r = new Error(n);
  return r.name = "SuppressedError", r.error = e, r.suppressed = t, r;
};
function I$(e) {
  function t(r) {
    e.error = e.hasError ? new Fde(r, e.error, "An error was suppressed during disposal.") : r, e.hasError = !0;
  }
  function n() {
    for (; e.stack.length; ) {
      var r = e.stack.pop();
      try {
        var i = r.dispose && r.dispose.call(r.value);
        if (r.async) return Promise.resolve(i).then(n, function(o) {
          return t(o), n();
        });
      } catch (o) {
        t(o);
      }
    }
    if (e.hasError) throw e.error;
  }
  return n();
}
const Ude = {
  __extends: sy,
  __assign: $l,
  __rest: k8,
  __decorate: h$,
  __param: p$,
  __metadata: m$,
  __awaiter: y$,
  __generator: v$,
  __createBinding: A8,
  __exportStar: g$,
  __values: Km,
  __read: Qg,
  __spread: b$,
  __spreadArrays: w$,
  __spreadArray: Xg,
  __await: Jg,
  __asyncGenerator: C$,
  __asyncDelegator: x$,
  __asyncValues: E$,
  __makeTemplateObject: S$,
  __importStar: k$,
  __importDefault: A$,
  __classPrivateFieldGet: T$,
  __classPrivateFieldSet: _$,
  __classPrivateFieldIn: R$,
  __addDisposableResource: O$,
  __disposeResources: I$
}, Oje = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  __addDisposableResource: O$,
  get __assign() {
    return $l;
  },
  __asyncDelegator: x$,
  __asyncGenerator: C$,
  __asyncValues: E$,
  __await: Jg,
  __awaiter: y$,
  __classPrivateFieldGet: T$,
  __classPrivateFieldIn: R$,
  __classPrivateFieldSet: _$,
  __createBinding: A8,
  __decorate: h$,
  __disposeResources: I$,
  __esDecorate: Pde,
  __exportStar: g$,
  __extends: sy,
  __generator: v$,
  __importDefault: A$,
  __importStar: k$,
  __makeTemplateObject: S$,
  __metadata: m$,
  __param: p$,
  __propKey: Bde,
  __read: Qg,
  __rest: k8,
  __runInitializers: Nde,
  __setFunctionName: Lde,
  __spread: b$,
  __spreadArray: Xg,
  __spreadArrays: w$,
  __values: Km,
  default: Ude
}, Symbol.toStringTag, { value: "Module" }));
function $d(e) {
  return typeof e == "function";
}
function D$(e) {
  var t = function(r) {
    Error.call(r), r.stack = new Error().stack;
  }, n = e(t);
  return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n;
}
var qR = D$(function(e) {
  return function(n) {
    e(this), this.message = n ? n.length + ` errors occurred during unsubscription:
` + n.map(function(r, i) {
      return i + 1 + ") " + r.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = n;
  };
});
function o5(e, t) {
  if (e) {
    var n = e.indexOf(t);
    0 <= n && e.splice(n, 1);
  }
}
var T8 = function() {
  function e(t) {
    this.initialTeardown = t, this.closed = !1, this._parentage = null, this._finalizers = null;
  }
  return e.prototype.unsubscribe = function() {
    var t, n, r, i, o;
    if (!this.closed) {
      this.closed = !0;
      var s = this._parentage;
      if (s)
        if (this._parentage = null, Array.isArray(s))
          try {
            for (var c = Km(s), u = c.next(); !u.done; u = c.next()) {
              var f = u.value;
              f.remove(this);
            }
          } catch (x) {
            t = { error: x };
          } finally {
            try {
              u && !u.done && (n = c.return) && n.call(c);
            } finally {
              if (t) throw t.error;
            }
          }
        else
          s.remove(this);
      var p = this.initialTeardown;
      if ($d(p))
        try {
          p();
        } catch (x) {
          o = x instanceof qR ? x.errors : [x];
        }
      var y = this._finalizers;
      if (y) {
        this._finalizers = null;
        try {
          for (var v = Km(y), w = v.next(); !w.done; w = v.next()) {
            var C = w.value;
            try {
              Uj(C);
            } catch (x) {
              o = o ?? [], x instanceof qR ? o = Xg(Xg([], Qg(o)), Qg(x.errors)) : o.push(x);
            }
          }
        } catch (x) {
          r = { error: x };
        } finally {
          try {
            w && !w.done && (i = v.return) && i.call(v);
          } finally {
            if (r) throw r.error;
          }
        }
      }
      if (o)
        throw new qR(o);
    }
  }, e.prototype.add = function(t) {
    var n;
    if (t && t !== this)
      if (this.closed)
        Uj(t);
      else {
        if (t instanceof e) {
          if (t.closed || t._hasParent(this))
            return;
          t._addParent(this);
        }
        (this._finalizers = (n = this._finalizers) !== null && n !== void 0 ? n : []).push(t);
      }
  }, e.prototype._hasParent = function(t) {
    var n = this._parentage;
    return n === t || Array.isArray(n) && n.includes(t);
  }, e.prototype._addParent = function(t) {
    var n = this._parentage;
    this._parentage = Array.isArray(n) ? (n.push(t), n) : n ? [n, t] : t;
  }, e.prototype._removeParent = function(t) {
    var n = this._parentage;
    n === t ? this._parentage = null : Array.isArray(n) && o5(n, t);
  }, e.prototype.remove = function(t) {
    var n = this._finalizers;
    n && o5(n, t), t instanceof e && t._removeParent(this);
  }, e.EMPTY = function() {
    var t = new e();
    return t.closed = !0, t;
  }(), e;
}(), M$ = T8.EMPTY;
function P$(e) {
  return e instanceof T8 || e && "closed" in e && $d(e.remove) && $d(e.add) && $d(e.unsubscribe);
}
function Uj(e) {
  $d(e) ? e() : e.unsubscribe();
}
var N$ = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: !1,
  useDeprecatedNextContext: !1
}, B$ = {
  setTimeout: function(e, t) {
    for (var n = [], r = 2; r < arguments.length; r++)
      n[r - 2] = arguments[r];
    return setTimeout.apply(void 0, Xg([e, t], Qg(n)));
  },
  clearTimeout: function(e) {
    var t = B$.delegate;
    return ((t == null ? void 0 : t.clearTimeout) || clearTimeout)(e);
  },
  delegate: void 0
};
function zde(e) {
  B$.setTimeout(function() {
    throw e;
  });
}
function zj() {
}
function o4(e) {
  e();
}
var L$ = function(e) {
  sy(t, e);
  function t(n) {
    var r = e.call(this) || this;
    return r.isStopped = !1, n ? (r.destination = n, P$(n) && n.add(r)) : r.destination = qde, r;
  }
  return t.create = function(n, r, i) {
    return new a5(n, r, i);
  }, t.prototype.next = function(n) {
    this.isStopped || this._next(n);
  }, t.prototype.error = function(n) {
    this.isStopped || (this.isStopped = !0, this._error(n));
  }, t.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, t.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, e.prototype.unsubscribe.call(this), this.destination = null);
  }, t.prototype._next = function(n) {
    this.destination.next(n);
  }, t.prototype._error = function(n) {
    try {
      this.destination.error(n);
    } finally {
      this.unsubscribe();
    }
  }, t.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, t;
}(T8), Vde = Function.prototype.bind;
function WR(e, t) {
  return Vde.call(e, t);
}
var $de = function() {
  function e(t) {
    this.partialObserver = t;
  }
  return e.prototype.next = function(t) {
    var n = this.partialObserver;
    if (n.next)
      try {
        n.next(t);
      } catch (r) {
        vk(r);
      }
  }, e.prototype.error = function(t) {
    var n = this.partialObserver;
    if (n.error)
      try {
        n.error(t);
      } catch (r) {
        vk(r);
      }
    else
      vk(t);
  }, e.prototype.complete = function() {
    var t = this.partialObserver;
    if (t.complete)
      try {
        t.complete();
      } catch (n) {
        vk(n);
      }
  }, e;
}(), a5 = function(e) {
  sy(t, e);
  function t(n, r, i) {
    var o = e.call(this) || this, s;
    if ($d(n) || !n)
      s = {
        next: n ?? void 0,
        error: r ?? void 0,
        complete: i ?? void 0
      };
    else {
      var c;
      o && N$.useDeprecatedNextContext ? (c = Object.create(n), c.unsubscribe = function() {
        return o.unsubscribe();
      }, s = {
        next: n.next && WR(n.next, c),
        error: n.error && WR(n.error, c),
        complete: n.complete && WR(n.complete, c)
      }) : s = n;
    }
    return o.destination = new $de(s), o;
  }
  return t;
}(L$);
function vk(e) {
  zde(e);
}
function Hde(e) {
  throw e;
}
var qde = {
  closed: !0,
  next: zj,
  error: Hde,
  complete: zj
}, Wde = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function Gde(e) {
  return e;
}
function Kde(e) {
  return e.length === 0 ? Gde : e.length === 1 ? e[0] : function(n) {
    return e.reduce(function(r, i) {
      return i(r);
    }, n);
  };
}
var Vj = function() {
  function e(t) {
    t && (this._subscribe = t);
  }
  return e.prototype.lift = function(t) {
    var n = new e();
    return n.source = this, n.operator = t, n;
  }, e.prototype.subscribe = function(t, n, r) {
    var i = this, o = Qde(t) ? t : new a5(t, n, r);
    return o4(function() {
      var s = i, c = s.operator, u = s.source;
      o.add(c ? c.call(o, u) : u ? i._subscribe(o) : i._trySubscribe(o));
    }), o;
  }, e.prototype._trySubscribe = function(t) {
    try {
      return this._subscribe(t);
    } catch (n) {
      t.error(n);
    }
  }, e.prototype.forEach = function(t, n) {
    var r = this;
    return n = $j(n), new n(function(i, o) {
      var s = new a5({
        next: function(c) {
          try {
            t(c);
          } catch (u) {
            o(u), s.unsubscribe();
          }
        },
        error: o,
        complete: i
      });
      r.subscribe(s);
    });
  }, e.prototype._subscribe = function(t) {
    var n;
    return (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(t);
  }, e.prototype[Wde] = function() {
    return this;
  }, e.prototype.pipe = function() {
    for (var t = [], n = 0; n < arguments.length; n++)
      t[n] = arguments[n];
    return Kde(t)(this);
  }, e.prototype.toPromise = function(t) {
    var n = this;
    return t = $j(t), new t(function(r, i) {
      var o;
      n.subscribe(function(s) {
        return o = s;
      }, function(s) {
        return i(s);
      }, function() {
        return r(o);
      });
    });
  }, e.create = function(t) {
    return new e(t);
  }, e;
}();
function $j(e) {
  var t;
  return (t = e ?? N$.Promise) !== null && t !== void 0 ? t : Promise;
}
function Yde(e) {
  return e && $d(e.next) && $d(e.error) && $d(e.complete);
}
function Qde(e) {
  return e && e instanceof L$ || Yde(e) && P$(e);
}
var Xde = D$(function(e) {
  return function() {
    e(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
  };
}), j$ = function(e) {
  sy(t, e);
  function t() {
    var n = e.call(this) || this;
    return n.closed = !1, n.currentObservers = null, n.observers = [], n.isStopped = !1, n.hasError = !1, n.thrownError = null, n;
  }
  return t.prototype.lift = function(n) {
    var r = new Hj(this, this);
    return r.operator = n, r;
  }, t.prototype._throwIfClosed = function() {
    if (this.closed)
      throw new Xde();
  }, t.prototype.next = function(n) {
    var r = this;
    o4(function() {
      var i, o;
      if (r._throwIfClosed(), !r.isStopped) {
        r.currentObservers || (r.currentObservers = Array.from(r.observers));
        try {
          for (var s = Km(r.currentObservers), c = s.next(); !c.done; c = s.next()) {
            var u = c.value;
            u.next(n);
          }
        } catch (f) {
          i = { error: f };
        } finally {
          try {
            c && !c.done && (o = s.return) && o.call(s);
          } finally {
            if (i) throw i.error;
          }
        }
      }
    });
  }, t.prototype.error = function(n) {
    var r = this;
    o4(function() {
      if (r._throwIfClosed(), !r.isStopped) {
        r.hasError = r.isStopped = !0, r.thrownError = n;
        for (var i = r.observers; i.length; )
          i.shift().error(n);
      }
    });
  }, t.prototype.complete = function() {
    var n = this;
    o4(function() {
      if (n._throwIfClosed(), !n.isStopped) {
        n.isStopped = !0;
        for (var r = n.observers; r.length; )
          r.shift().complete();
      }
    });
  }, t.prototype.unsubscribe = function() {
    this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;
  }, Object.defineProperty(t.prototype, "observed", {
    get: function() {
      var n;
      return ((n = this.observers) === null || n === void 0 ? void 0 : n.length) > 0;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._trySubscribe = function(n) {
    return this._throwIfClosed(), e.prototype._trySubscribe.call(this, n);
  }, t.prototype._subscribe = function(n) {
    return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n);
  }, t.prototype._innerSubscribe = function(n) {
    var r = this, i = this, o = i.hasError, s = i.isStopped, c = i.observers;
    return o || s ? M$ : (this.currentObservers = null, c.push(n), new T8(function() {
      r.currentObservers = null, o5(c, n);
    }));
  }, t.prototype._checkFinalizedStatuses = function(n) {
    var r = this, i = r.hasError, o = r.thrownError, s = r.isStopped;
    i ? n.error(o) : s && n.complete();
  }, t.prototype.asObservable = function() {
    var n = new Vj();
    return n.source = this, n;
  }, t.create = function(n, r) {
    return new Hj(n, r);
  }, t;
}(Vj), Hj = function(e) {
  sy(t, e);
  function t(n, r) {
    var i = e.call(this) || this;
    return i.destination = n, i.source = r, i;
  }
  return t.prototype.next = function(n) {
    var r, i;
    (i = (r = this.destination) === null || r === void 0 ? void 0 : r.next) === null || i === void 0 || i.call(r, n);
  }, t.prototype.error = function(n) {
    var r, i;
    (i = (r = this.destination) === null || r === void 0 ? void 0 : r.error) === null || i === void 0 || i.call(r, n);
  }, t.prototype.complete = function() {
    var n, r;
    (r = (n = this.destination) === null || n === void 0 ? void 0 : n.complete) === null || r === void 0 || r.call(n);
  }, t.prototype._subscribe = function(n) {
    var r, i;
    return (i = (r = this.source) === null || r === void 0 ? void 0 : r.subscribe(n)) !== null && i !== void 0 ? i : M$;
  }, t;
}(j$), ly = function(e) {
  sy(t, e);
  function t(n) {
    var r = e.call(this) || this;
    return r._value = n, r;
  }
  return Object.defineProperty(t.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._subscribe = function(n) {
    var r = e.prototype._subscribe.call(this, n);
    return !r.closed && n.next(this._value), r;
  }, t.prototype.getValue = function() {
    var n = this, r = n.hasError, i = n.thrownError, o = n._value;
    if (r)
      throw i;
    return this._throwIfClosed(), o;
  }, t.prototype.next = function(n) {
    e.prototype.next.call(this, this._value = n);
  }, t;
}(j$);
const w1 = new ly(null), Jde = (e, t) => e.interceptors.response.use(void 0, (n) => {
  var r, i, o;
  return t.exists(`errors.${(i = (r = n == null ? void 0 : n.response) == null ? void 0 : r.data) == null ? void 0 : i.message}`) && !((o = n == null ? void 0 : n.config) != null && o.url.includes("gas-estimate")) && w1.next(n.response.data), Promise.reject(n);
}), Zde = () => ({ error: k.useSyncExternalStore(
  k.useCallback((n) => {
    const r = w1.subscribe(n);
    return () => {
      r.unsubscribe();
    };
  }, []),
  k.useCallback(() => w1.value, []),
  k.useCallback(() => w1.value, [])
), resetError: () => w1.next(null) }), F$ = k.createContext(
  void 0
), efe = ({
  children: e,
  ...t
}) => {
  var r;
  (r = t.wagmi) != null && r.__customConnectors__ && (t.wagmi.__customConnectors__ = void 0);
  const { i18n: n } = ln();
  return k.useLayoutEffect(() => {
    t.language && n.changeLanguage(t.language);
  }, [t.language, n]), /* @__PURE__ */ S.jsx(F$.Provider, { value: t, children: e });
}, dr = () => {
  const e = k.useContext(F$);
  if (!e)
    throw new Error(
      "useSettings must be used within a SettingsContextProvider"
    );
  return e;
}, U$ = k.createContext(void 0), tfe = ({ children: e }) => {
  const { apiKey: t } = dr(), { i18n: n } = ln(), [r] = k.useState(() => {
    const o = Yi.create({
      baseURL: ni.env.apiUrl,
      headers: { "X-API-KEY": t },
      adapter: "fetch"
    });
    return _de(o), Dde(o), Jde(o, n), o;
  }), i = k.useCallback(
    (o, s) => r(o, s).then((c) => c.data),
    [r]
  );
  return /* @__PURE__ */ S.jsx(U$.Provider, { value: r, children: /* @__PURE__ */ S.jsx(
    Oue,
    {
      apiKey: t,
      baseURL: ni.env.apiUrl,
      fetchInstance: i,
      children: e
    }
  ) });
}, _8 = () => {
  const e = k.useContext(U$);
  if (!e)
    throw new Error("ApiClient must be used within a ApiHooksProvider");
  return e;
}, nfe = {
  stake_kit: "StakeKit",
  max: "Max",
  min: "Min",
  available: "available",
  balance: "Balance",
  yearly: "Yearly",
  monthly: "Monthly",
  review: "Review",
  receive: "Receive",
  fees: "Fees",
  none: "None",
  confirm: "Confirm",
  cancel: "Cancel",
  ok: "Ok",
  something_went_wrong: "Something went wrong",
  not_enough_gas_token: "Not enough gas token",
  retry: "Try Again",
  unsupported_network: "Unsupported network",
  points: "Points",
  continue: "Continue",
  powered_by: "Powered by <span0>{{name}}</span0>"
}, rfe = {
  disabled_chain_info: "Add account"
}, ife = {
  get_started: "Connect your wallet to get started",
  connect_wallet: "Connect Wallet",
  ledger_add_account: "Add account"
}, ofe = {
  date_group_labels: {
    today: "Today",
    yesterday: "Yesterday"
  },
  review: {
    transactions: "Transactions",
    retry: "Retry",
    continue: "Continue",
    unknown_error: "Unknown error",
    terms_of_use: "By clicking {{action}} you agree to <underline0>Terms of Use</underline0> and understand the Risk Disclosures",
    in_progress: "In Progress"
  },
  no_previous_activity: "No previous activity in StakeKit"
}, afe = {
  earn: "Earn",
  estimated_reward: "Estimated rewards",
  earn_with: "Earn with",
  additional_info: "Additional info",
  referral_code: {
    title: "Your referral link:"
  },
  rewards: {
    receive: "You'll receive <symbols1></symbols1> via",
    yearly: "Estimated Yearly Earnings",
    monthly: "Estimated Monthly Earnings"
  },
  tron_resources: {
    label: "Resource",
    placeholder: "Select resource"
  },
  reward_rate_estimate_tooltip: "Reward rate can't be accurately estimated",
  unstake_before: "You already have delegated your balance to a validator. Unstake and try again",
  no_opportunities: "No yield opportunities for this token",
  selected_validators_one: "{{providerName}}",
  selected_validators_other: "{{providerName}} + {{count}} more",
  native_staking: {
    earn_after_warmup_one: "Youll start earning {{count}} day after you supply your assets",
    earn_after_warmup_other: "Youll start earning {{count}} days after you supply your assets",
    earn_rewards_auto: "Earned rewards are distributed each {{rewardSchedule}} and accrue to your position automatically",
    earn_rewards_manual: "Earned rewards are distributed each {{rewardSchedule}} and need to be claimed manually. Your earnings compound, if you claim and restake quickly",
    unstake_time_immediately: "When unstaking, your assets will be available immediately",
    unstake_time_days: "When unstaking it takes {{cooldownPeriodDays}} days for your tokens to be available"
  },
  vault: {
    description: "When you deposit {{stakeToken}} you'll receive {{depositToken}}. You can trade this liquid asset at any time",
    earn_after_warmup_one: "Youll start earning {{count}} day after you supply your assets",
    earn_after_warmup_other: "Youll start earning {{count}} days after you supply your assets",
    earn_yield_auto: "Earned yield is updated each {{rewardSchedule}} and accrues automatically",
    earn_yield_manual: "Earned yield is updated each {{rewardSchedule}} and needs to be claimed manually",
    withdrawn_time_immediately: "When withdrawing, your assets will be available immediately",
    withdrawn_time_days: "When withdrawing it takes {{cooldownPeriodDays}} days for your assets will be available"
  },
  lend: {
    description: "When you supply {{stakeToken}} you'll receive {{rewardTokens}}. You can borrow against the supplied assets on {{providerName}}",
    description_compound: "When you supply {{stakeToken}} you'll receive {{rewardTokens}}",
    earn_after_warmup_one: "Youll start earning {{count}} day after you supply your assets",
    earn_after_warmup_other: "Youll start earning {{count}} days after you supply your assets",
    earn_interest_auto: "Earned interest is distributed each {{rewardSchedule}} and accrues automatically",
    earn_interest_manual: "Earned interest is distributed each {{rewardSchedule}} and needs to be claimed manually",
    withdrawn_time_immediately: "Upon withdrawing, your assets will be available immediately",
    withdrawn_time_days: "After withdrawing, your assets will be available in {{cooldownPeriodDays}} days"
  },
  liquid_stake: {
    description: "When you liquid stake {{stakeToken}} you'll receive {{rewardTokens}}. You can trade this liquid asset at any time",
    earn_after_warmup_one: "Youll start earning {{count}} day after you stake",
    earn_after_warmup_other: "Youll start earning {{count}} days after you stake",
    earn_rewards_auto: "Earned rewards are distributed each {{rewardSchedule}} and accrue to your position automatically",
    earn_rewards_manual: "Earned rewards are distributed each {{rewardSchedule}} and need to be claimed manually",
    unstake_time_immediately: "When unstaking, your assets will be available immediately",
    unstake_time_days: "When unstaking it takes {{cooldownPeriodDays}} days for your tokens to be available",
    unstake_time_days_with_claim_days: "When unstaking it takes {{cooldownPeriodDays}} days for your tokens to be available. They need to be claimed within {{claimDays}} days, otherwise theyll need to be staked again.",
    withdrawn_not_available: "Withdrawals aren't available at the moment. To exit your position you can sell {{rewardTokens}} any time on DEXs"
  },
  restake: {
    description: "When you deposit {{stakeToken}} you'll receive {{rewardTokens}}. You can trade this liquid asset at any time",
    earn_after_warmup_one: "Youll start earning {{count}} day after you stake",
    earn_after_warmup_other: "Youll start earning {{count}} days after you stake",
    earn_rewards_auto: "Earned rewards are distributed each {{rewardSchedule}} and accrue to your position automatically",
    earn_rewards_manual: "Earned rewards are distributed each {{rewardSchedule}} and need to be claimed manually",
    unstake_time_immediately: "When unstaking, your assets will be available immediately",
    unstake_time_days: "When unstaking it takes {{cooldownPeriodDays}} days for your tokens to be available",
    withdrawn_not_available: "Withdrawals aren't available at the moment. To exit your position you can sell {{rewardTokens}} any time on DEXs"
  },
  extra_tezos: "You can use or send staked XTZ as normal",
  reward_type_varialbe: "{{symbol}} staking rewards rate varies based on the trading and transaction fees the protocol earns which cant be accurately estimated",
  opportunity_search_title: "Select a yield",
  validator_search_title_one: "Select validator",
  validator_search_title_other: "Select validators",
  reward_token: "You'll receive <symbols1></symbols1> <highlight2>via {{providerName}}</highlight2>",
  tabs: {
    earn: "Earn",
    positions: "Manage",
    activity: "Activity"
  },
  validators_preferred: "Preferred",
  validators_other: "All validators",
  validators_view_all: "View all",
  validators_inactive: "Inactive",
  validators_jailed: "Jailed",
  validators_staked_balance: "Validator stake",
  validators_voting_power: "Voting power",
  validators_address: "Address",
  validators_comission: "Commission",
  validators_website: "Website"
}, sfe = {
  estimated_reward: "Estimated rewards",
  estimated_gas_fee: "Estimated gas fee",
  wallet_fee: "{{wallet}} fee",
  claim: "Claim",
  terms_of_use: "By clicking confirm you agree to <underline0>Terms of Use</underline0> and understand the Risk Disclosures",
  amount_and_earn: "<highlight0>{{amount}}</highlight0> <highlight1>{{tokenSymbol}}</highlight1> & earn <highlight3>{{interestRate}}</highlight3>",
  additional_info: "Additional info",
  deposit_fee: "Deposit fee",
  management_fee: "Management fee",
  performance_fee: "Performance fee",
  deposit_fee_explanation: "A flat fee deducted at deposit, reducing the principal.",
  management_fee_explanation: "A flat annual fee deducted from vault deposits by minting new shares, diluting participants. Calculated based on time since the last harvest and applied during harvest.",
  performance_fee_explanation: "A fee deducted from earnings when a vault harvests a strategy. Its only applied after surpassing a variable threshold."
}, lfe = {
  title: "Follow Steps",
  sign_transaction: "Sign transaction",
  sign_transaction_desc: "Go back to connected wallet to approve transaction",
  transaction_status: "Transaction status",
  transaction_status_desc: "Checking transaction status",
  finalize_stake: "Finalize stake",
  send_to_finalize_stake: "Send transaction to finalize your stake",
  approve: "Approve",
  approve_desc: "Approve this transaction in your wallet",
  submitting: "Submitting transaction",
  submitted: "Submitted",
  pending: "Pending",
  completed: "Completed",
  failed: "Failed",
  tx_of_one: "Transaction - {{type}}",
  tx_of_other: "Transaction {{current}} / {{count}} - {{type}}",
  skipped: "Skipped",
  approve_error: "Something went wrong. Check if wallet is connected",
  tx_type: {
    SWAP: "SWAP",
    DEPOSIT: "DEPOSIT",
    APPROVAL: "APPROVAL",
    STAKE: "STAKE",
    CLAIM_UNSTAKED: "CLAIM UNSTAKED",
    CLAIM_REWARDS: "CLAIM REWARDS",
    RESTAKE_REWARDS: "RESTAKE REWARDS",
    UNSTAKE: "UNSTAKE",
    SPLIT: "SPLIT",
    MERGE: "MERGE",
    LOCK: "LOCK",
    UNLOCK: "UNLOCK",
    SUPPLY: "SUPPLY",
    BRIDGE: "BRIDGE",
    VOTE: "VOTE",
    REVOKE: "REVOKE",
    RESTAKE: "RESTAKE",
    REBOND: "REBOND",
    WITHDRAW: "WITHDRAW",
    CREATE_ACCOUNT: "CREATE ACCOUNT",
    REVEAL: "REVEAL",
    MIGRATE: "MIGRATE",
    UTXO_P_TO_C_IMPORT: "UTXO P TO C IMPORT",
    UTXO_C_TO_P_IMPORT: "UTXO C TO P IMPORT",
    UNFREEZE_LEGACY: "UNFREEZE LEGACY",
    UNFREEZE_LEGACY_BANDWIDTH: "UNFREEZE LEGACY BANDWIDTH",
    UNFREEZE_LEGACY_ENERGY: "UNFREEZE LEGACY ENERGY",
    UNFREEZE_BANDWIDTH: "UNFREEZE BANDWIDTH",
    UNFREEZE_ENERGY: "UNFREEZE ENERGY",
    FREEZE_BANDWIDTH: "FREEZE BANDWIDTH",
    FREEZE_ENERGY: "FREEZE ENERGY",
    UNDELEGATE_BANDWIDTH: "UNDELEGATE BANDWIDTH",
    UNDELEGATE_ENERGY: "UNDELEGATE ENERGY",
    P2P_NODE_REQUEST: "P2P NODE REQUEST",
    LUGANODES_PROVISION: "LUGANODES PROVISION",
    LUGANODES_EXIT_REQUEST: "LUGANODES EXIT REQUEST",
    INFSTONES_PROVISION: "INFSTONES PROVISION",
    INFSTONES_EXIT_REQUEST: "INFSTONES EXIT REQUEST",
    INFSTONES_CLAIM_REQUEST: "INFSTONES CLAIM REQUEST"
  }
}, cfe = {
  successfully_staked: "Successfully {{action}} {{amount}} {{tokenNetwork}}",
  successfully_unstaked: "Successfully {{action}} {{amount}} {{tokenNetwork}}",
  successfully_pending_action: "Successfully {{pendingAction}} {{amount}} {{tokenNetwork}}",
  view_transaction: "View {{type}} transaction",
  via: "via {{providerName}}",
  stake: {
    staking: "staked",
    "liquid-staking": "staked",
    vault: "deposited",
    lending: "supplied",
    restaking: "restaked",
    pooled_staking: "staked",
    native_staking: "staked"
  },
  unstake: {
    staking: "unstaked",
    "liquid-staking": "unstaked",
    vault: "withdrawn",
    lending: "withdrawn",
    restaking: "unstaked",
    pooled_staking: "unstaked",
    native_staking: "unstaked"
  },
  pending_action: {
    stake: "staked",
    unstake: "unstaked",
    claim_rewards: "claimed rewards",
    restake_rewards: "restaked rewards",
    withdraw: "withdrawn",
    restake: "restaked",
    claim_unstaked: "claimed unstaked",
    unlock_locked: "unlocked locked",
    unlock_locked_legacy: "unlocked locked",
    stake_locked: "staked locked",
    vote: "voted",
    revoke: "Revoke",
    vote_locked: "Vote locked",
    revote: "Revote",
    rebond: "Rebond",
    migrate: "Migrate"
  }
}, ufe = {
  geo_block: {
    title: "Geo Block",
    ofac: "This feature is not available in {{countryName}}. {{countryName}} is on the Office of Foreign Assets Control (OFAC) list of sanctioned countries. You can learn more about OFAC and its sanctions programs here <link0>https://ofac.treasury.gov/sanctions-programs-and-country-information</link0>.",
    ofsi: "This feature is not available in {{countryName}}. {{countryName}} is on the U.K.s Office of Financial Sanctions Implementation (OFSI) list of sanctioned countries. You can learn more about OFSI and its sanctions programs here <link0>https://www.gov.uk/government/collections/financial-sanctions-regime-specific-consolidated-lists-and-releases</link0>.",
    pending_litigation: "This feature is currently unavailable in {{nameOfRegion}} due to pending litigation on the subject of staking cryptocurrencies",
    crypto_ban: "This feature is not available in {{countryName}}. {{countryName}} has implemented firm regulations against the use of cryptocurrencies. Please refer to official {{countryName}} resources to learn more.",
    staking_ban: "This feature is not available in {{countryName}}. The Securities and Exchange Commission (SEC) of {{countryName}} has restricted digital asset business operators from offering staking services. You can learn more about the SEC regualtions here <link0>https://www.sec.or.th/TH/Pages/News_Detail.aspx?SECID=10018</link0>.",
    ofsi_crypto_ban: "This feature is not available in {{countryName}}. {{countryName}} is on the U.K.s Office of Financial Sanctions Implementation (OFSI) list of sanctioned countries. You can learn more about OFSI and its sanctions programs here <link0>https://www.gov.uk/government/collections/financial-sanctions-regime-specific-consolidated-lists-and-releases</link0>. {{countryName}} has further implemented firm regulations against the use of cryptocurrencies.",
    ofac_ofsi: "This feature is not available in {{countryName}}. {{countryName}} is on both the Office of Foreign Assets Control (OFAC) list of sanctioned countries, as well as the U.K.s Office of Financial Sanctions Implementation (OFSI) list of sanctioned countries. You can learn more about OFAC and its sanctions programs here <link0>https://ofac.treasury.gov/sanctions-programs-and-country-information</link0>, as well as OFSI and its sanctions programs here <link>https://www.gov.uk/government/collections/financial-sanctions-regime-specific-consolidated-lists-and-releases</link>.",
    default: "This feature is not available in {{countryName}}."
  },
  get_in_touch: {
    title: "Need help or have a questions?",
    button: "Get in touch"
  },
  what_is_stakekit: {
    title: "What is StakeKit?",
    description: "StakeKit is a platform that allows you to easily earn self-custodial yield across all major networks and tokens. From staking and liquid staking, to yield vaults and lending. StakeKit abstracts all complexity so that every yield is accessible in merely 3 clicks. And best of all, its fully self-custodial.<br0/><br0/>You can find more information about StakeKit on our <link0>website</link0> or in our <link1>FAQ section.</link1>"
  },
  under_maintenance: {
    title: "Under Maintenance",
    description: "StakeKit is currently undergoing routine maintenance. Our service is expected to be back up and running in approximately 5-10 minutes.",
    description2: "We appreciate your patience and encourage you to check back shortly!"
  }
}, dfe = {
  title: "My Positions",
  via_one: "via {{providerName}}",
  via_other: "via {{providerName}} + {{count}} more",
  connect_wallet: "Connect wallet",
  no_current_positions: "No current positions",
  claim_rewards: "Claim rewards",
  action_required: "Action required",
  dont_see_position: "Don't see a position?",
  import_validator: "Import a validator you have staked with to view your position",
  import_button: "Import",
  import_validator_modal_title: "Import validator",
  import_validator_already_imported: "Imported",
  search_for_validators: "Search for validators by address or name"
}, ffe = {
  native_staking: {
    title: "Native Staking",
    review: "Stake",
    cta: "Stake"
  },
  pooled_staking: {
    title: "Pooled Staking",
    review: "Stake",
    cta: "Stake"
  },
  staking: {
    title: "Stake",
    review: "Stake",
    cta: "Stake"
  },
  "liquid-staking": {
    title: "Liquid Staking",
    review: "Liquid Staking",
    cta: "Stake"
  },
  vault: {
    title: "Vault",
    review: "Deposit",
    cta: "Deposit"
  },
  lending: {
    title: "Lending",
    review: "Supply",
    cta: "Supply"
  },
  restaking: {
    title: "Restaking",
    review: "Deposit",
    cta: "Deposit"
  }
}, hfe = {
  labels: {
    hasFrozenV1: {
      label: "Frozen 1.0",
      details: "{{amount}} TRX are frozen with Legacy Stake 1.0. To migrate to 2.0: Simply unstake {{amount}} TRX in StakeKit and stake again (StakeKit automatically prioritizes unstaking of Stake 1.0 balance)"
    }
  },
  via: "{{stakeType}} via {{providerName}}",
  rewards: "Rewards",
  available_to: "<bold>{{amount}} {{symbol}}</bold> available to {{pendingAction, lowercase}}",
  claim: "Claim",
  unstake: "Unstake",
  withdraw: "Withdraw",
  available: "{{amount}} {{symbol}} available",
  select_validators: {
    submit: "Submit"
  },
  stake_type: {
    staking: "Staked",
    "liquid-staking": "Liquid staked",
    lending: "Deposited",
    vault: "Deposited",
    restaking: "Restaked"
  },
  unstake_label: {
    staking: "Unstake",
    "liquid-staking": "Unstake",
    lending: "Withdraw",
    vault: "Withdraw",
    restaking: "Unstake"
  },
  balance_type: {
    available: "Available",
    staked: "Staked",
    staked_yearn_or_deposit: "Deposited",
    unstaking: "Unstaking",
    unstaking_yearn_or_deposit: "Withdrawing",
    unstaked: "Unstaked",
    unstaked_yearn_or_deposit: "Withdrawn",
    preparing: "Preparing",
    rewards: "Rewards",
    locked: "Locked",
    unlocking: "Unlocking"
  },
  unstaking_days_one: "{{count}} day remaining",
  unstaking_days_other: "{{count}} days remaining",
  pending_action: {
    stake: "Stake",
    unstake: "Unstake",
    claim_rewards: "Claim rewards",
    restake_rewards: "Restake rewards",
    withdraw: "Withdraw",
    restake: "Restake",
    claim_unstaked: "Claim unstaked",
    unlock_locked: "Unlock",
    unlock_locked_legacy: "Unlock",
    stake_locked: "Stake",
    vote: "Vote",
    revoke: "Revoke",
    vote_locked: "Vote",
    revote: "Revote",
    rebond: "Rebond",
    migrate: "Migrate"
  },
  pending_action_button: {
    stake: "Stake",
    unstake: "Unstake",
    claim_rewards: "Claim",
    restake_rewards: "Restake",
    withdraw: "Withdraw",
    restake: "Restake",
    claim_unstaked: "Claim",
    unlock_locked: "Unlock",
    unlock_locked_legacy: "Unlock",
    stake_locked: "Stake",
    vote: "Vote",
    revoke: "Revoke",
    vote_locked: "Vote locked",
    revote: "Revote",
    rebond: "Rebond",
    migrate: "Migrate"
  },
  unstake_sign: {
    title: "Verify Ownership",
    description: "You need to verify ownership of this address to proceed with this action. You will be prompted to sign a message that will be used to verify that you own this address."
  }
}, pfe = {
  terms_of_use: "By clicking confirm your agree to <underline0>Terms of Use</underline0> and understand the Risk Disclosures",
  unstake_from: "Unstake from {{providerName}}"
}, mfe = {
  pending_action_type: {
    stake: "Stake with {{providerName}}",
    unstake: "Unstake from {{providerName}}",
    claim_rewards: "Claim rewards from {{providerName}}",
    restake_rewards: "Restake rewards with {{providerName}}",
    withdraw: "Withdraw from {{providerName}}",
    restake: "Restake with {{providerName}}",
    claim_unstaked: "Claim unstaked from {{providerName}}",
    unlock_locked: "Unlock locked from {{providerName}}",
    unlock_locked_legacy: "Unlock locked from {{providerName}}",
    stake_locked: "Stake locked with {{providerName}}",
    vote: "Vote with {{providerName}}",
    revoke: "Revoke with {{providerName}}",
    vote_locked: "Vote locked with {{providerName}}",
    revote: "Revote with {{providerName}}",
    rebond: "Rebond with {{providerName}}",
    migrate: "Migrate from {{providerName}}"
  }
}, yfe = {
  title: "Select token",
  n_available_opps: "{{count}} available opportunities"
}, vfe = {
  title: "Referral check",
  body: "Enter your referral code to continue",
  submit: "Submit"
}, gfe = {
  solution: "Potential solution:"
}, bfe = {
  shared: nfe,
  chain_modal: rfe,
  init: ife,
  activity: ofe,
  details: afe,
  review: sfe,
  steps: lfe,
  complete: cfe,
  help_modals: ufe,
  positions: dfe,
  yield_types: ffe,
  position_details: hfe,
  unstake_review: pfe,
  pending_action_review: mfe,
  select_token: yfe,
  referral_lock: vfe,
  error_modal: gfe
}, wfe = {
  stake_kit: "StakeKit",
  max: "Max",
  min: "Min",
  available: "disponible",
  balance: "Solde",
  yearly: "Annuel",
  monthly: "Mensuel",
  review: "Revoir",
  receive: "Recevoir",
  fees: "Frais",
  none: "Aucun",
  confirm: "Confirmer",
  cancel: "Annuler",
  ok: "Ok",
  something_went_wrong: "Une erreur s'est produite",
  not_enough_gas_token: "Gas insuffisant",
  retry: "Ressayer",
  unsupported_network: "Rseau non support",
  points: "Points",
  continue: "Continuer",
  powered_by: "Aliment par <span0>{{name}}</span0>"
}, Cfe = {
  disabled_chain_info: "Ajoutez un portefeuille"
}, xfe = {
  get_started: "Connectez votre portefeuille pour commencer",
  connect_wallet: "Connectez un portefeuille",
  ledger_add_account: "Ajoutez un portefeuille"
}, Efe = {
  date_group_labels: {
    today: "Aujourd'hui",
    yesterday: "Hier"
  },
  review: {
    transactions: "Transactions",
    retry: "Ressayer",
    continue: "Continuer",
    unknown_error: "Erreur inconnue",
    terms_of_use: "En cliquant sur {{action}} vous acceptez les <underline0>Conditions d'utilisation</underline0> et comprenez les Informations sur les Risques",
    in_progress: "En cours"
  },
  no_previous_activity: "Aucune activit prcdente dans StakeKit"
}, Sfe = {
  earn: "Earn",
  estimated_reward: "Rcompenses estimes",
  staked_via: "Earn avec",
  additional_info: "Infos supplmentaires",
  referral_code: {
    title: "Votre lien de parrainage :"
  },
  rewards: {
    receive: "Vous recevrez des <symbols1></symbols1> via",
    yearly: "Gains annuels estims",
    monthly: "Gains mensuels estims"
  },
  tron_resources: {
    label: "Ressource",
    placeholder: "Slectionnez une ressource"
  },
  reward_rate_estimate_tooltip: "Le taux de rcompense ne peut pas tre estim de faon prcise",
  unstake_before: "Vous avez dj dlgu vos fonds  un validateur. Dstakez et ressayez",
  no_opportunities: "Pas d'opportunit de yield pour ce token",
  selected_validators_one: "{{providerName}}",
  selected_validators_other: "{{providerName}} + {{count}} autres",
  native_staking: {
    earn_after_warmup_one: "Vous commencerez  tre rcompens {{count}} jour aprs avoir fourni vos actifs",
    earn_after_warmup_other: "Vous commencerez  tre rcompens {{count}} jours aprs avoir fourni vos actifs",
    earn_rewards_auto: "Les rcompenses gagnes sont distribues chaque {{rewardSchedule}} et cumules  votre position automatiquement",
    earn_rewards_manual: "Les rcompenses gagnes sont distribues chaque {{rewardSchedule}} et doivent tre rclames manuellement. Vos gains se cumulent, si vous les rclamez et restakez rapidement",
    unstake_time_immediately: "En les dstakant, vos actifs seront disponibles immdiatement",
    unstake_time_days: "En les dstakant, vos tokens seront disponibles sous {{cooldownPeriodDays}} jours"
  },
  vault: {
    description: "En dposant du {{stakeToken}} vous recevrez du {{depositToken}}. Vous pouvez trader cet actif liquide  tout moment",
    earn_after_warmup_one: "Vous commencerez  tre rcompens {{count}} jour aprs avoir fourni vos actifs",
    earn_after_warmup_other: "Vous commencerez  tre rcompens {{count}} jours aprs avoir fourni vos actifs",
    earn_yield_auto: "Le yield gagn est mis  jour chaque {{rewardSchedule}} et se cumule automatiquement",
    earn_yield_manual: "Le yield gagn est mis  jour chaque {{rewardSchedule}} et doit tre rclam manuellement",
    withdrawn_time_immediately: "En les retirant, vos actifs seront disponibles immdiatement",
    withdrawn_time_days: "En les retirant, vos actifs seront disponibles sous {{cooldownPeriodDays}} jours"
  },
  lend: {
    description: "En fournissant du {{stakeToken}} vous recevrez des {{rewardTokens}}. Vous pouvez emprunter contre les actifs fournis sur {{providerName}}",
    description_compound: "En fournissant du {{stakeToken}} vous recevrez du {{rewardTokens}}",
    earn_after_warmup_one: "Vous commencerez  tre rcompens {{count}} jour aprs avoir fourni vos actifs",
    earn_after_warmup_other: "Vous commencerez  tre rcompens {{count}} jours aprs avoir fourni vos actifs",
    earn_interest_auto: "Les intrts gagns sont distribus chaque {{rewardSchedule}} et se cumulent automatiquement",
    earn_interest_manual: "Les intrts gagns sont distribus chaque {{rewardSchedule}} et doivent tre rclams manuellement",
    withdrawn_time_immediately: "En les retirant, vos actifs seront disponibles immdiatement",
    withdrawn_time_days: "Aprs leur retrait, vos actifs seront disponibles sous {{cooldownPeriodDays}} jours"
  },
  liquid_stake: {
    description: "En stakant du {{stakeToken}} vous recevrez des {{rewardTokens}}. Vous pouvez trader cet actif liquide  tout moment",
    earn_after_warmup_one: "Vous commencerez  tre rcompens {{count}} jour aprs avoir stak",
    earn_after_warmup_other: "Vous commencerez  tre rcompens {{count}} jours aprs avoir stak",
    earn_rewards_auto: "Les rcompenses gagnes sont distribues chaque {{rewardSchedule}} et cumules  votre position automatiquement",
    earn_rewards_manual: "Les rcompenses gagnes sont distribues chaque {{rewardSchedule}} et doivent tre rclames manuellement",
    unstake_time_immediately: "En les dstakant, vos actifs seront disponibles immdiatement",
    unstake_time_days: "En les dstakant, vos tokens seront disponibles sous {{cooldownPeriodDays}} jours",
    unstake_time_days_with_claim_days: "En les dstakant, vos tokens seront disponibles sous {{cooldownPeriodDays}} jours. Vous devez les rclamer sous {{claimDays}} jours, sans quoi il faudra les staker  nouveau.",
    withdrawn_not_available: "Les retraits ne sont pas disponibles pour le moment. Pour liquider votre position, vous pouvez vendre {{rewardTokens}}  tout moment sur les DEXs"
  },
  restake: {
    description: "En dposant du {{stakeToken}} vous recevrez des {{rewardTokens}}. Vous pouvez trader cet actif liquide  tout moment",
    earn_after_warmup_one: "Vous commencerez  tre rcompens {{count}} jour aprs avoir stak",
    earn_after_warmup_other: "Vous commencerez  tre rcompens {{count}} jours aprs avoir stak",
    earn_rewards_auto: "Les rcompenses gagnes sont distribues chaque {{rewardSchedule}} et cumules  votre position automatiquement",
    earn_rewards_manual: "Les rcompenses gagnes sont distribues chaque {{rewardSchedule}} et doivent tre rclames manuellement",
    unstake_time_immediately: "En les dstakant, vos actifs seront disponibles immdiatement",
    unstake_time_days: "En les dstakant, vos tokens seront disponibles sous {{cooldownPeriodDays}} jours",
    withdrawn_not_available: "Les retraits ne sont pas disponibles pour le moment. Pour liquider votre position, vous pouvez vendre {{rewardTokens}}  tout moment sur les DEXs"
  },
  extra_tezos: "Vous pouvez utiliser ou envoyer des XTZ staks normalement",
  reward_type_varialbe: " Le taux de rcompense de staking de {{symbol}} varie selon les trades et les frais de transaction que le protocole gagne, ce qui ne peut tre estim prcisment",
  opportunity_search_title: "Slectionnez un rendement",
  validator_search_title_one: "Slectionnez un validateur",
  validator_search_title_other: "Slectionnez des validateurs",
  reward_token: "Vous recevrez des <symbols1></symbols1> <highlight2>via {{providerName}}</highlight2>",
  tabs: {
    earn: "Earn",
    positions: "Manage",
    activity: "Activity"
  },
  validators_preferred: "Prfrs",
  validators_other: "Tous les validateurs",
  validators_view_all: "Tout voir",
  validators_inactive: "Inactif",
  validators_jailed: "Banni",
  validators_staked_balance: "Solde validateur",
  validators_voting_power: "Droit de vote",
  validators_address: "Adresse",
  validators_comission: "Commission",
  validators_website: "Site web"
}, kfe = {
  estimated_reward: "Rcompenses estimes",
  estimated_gas_fee: "Frais de gas estims",
  wallet_fee: "Frais de {{wallet}}",
  claim: "Rclamer",
  terms_of_use: "En cliquant sur Confirmer vous acceptez les <underline0>Conditions d'utilisation</underline0> et comprenez les Informations sur les Risques",
  amount_and_earn: "<highlight0>{{amount}}</highlight0> <highlight1>{{tokenSymbol}}</highlight1> & earn <highlight3>{{interestRate}}</highlight3>",
  additional_info: "Infos supplmentaires",
  deposit_fee: "Frais de Dpt",
  management_fee: "Frais de Gestion",
  performance_fee: "Frais de Performance",
  deposit_fee_explanation: "Une commission fixe dduite lors du dpt, rduisant le capital investi.",
  management_fee_explanation: "Une commission annuelle fixe dduite des dpts du vault en mettant de nouvelles parts, ce qui dilue les participants. Calcule en fonction du temps coul depuis la dernire rcolte et applique lors de la rcolte.",
  performance_fee_explanation: "Une commission dduite des gains lorsquun vault rcolte une stratgie. Elle nest applique quaprs avoir dpass un seuil variable."
}, Afe = {
  title: "Suivi des tapes",
  sign_transaction: "Signez la transaction",
  sign_transaction_desc: "Retournez sur le portefeuille connect pour autoriser la transaction",
  transaction_status: "Statut de la transaction",
  transaction_status_desc: "Vrification du statut de la transaction",
  finalize_stake: "Finalisez le staking",
  send_to_finalize_stake: "Envoyez la transaction pour finaliser le staking",
  approve: "Autoriser",
  approve_desc: "Autorisez cette transaction dans votre portefeuille",
  submitting: "Envoi de la transaction",
  submitted: "Envoye",
  pending: "En cours",
  completed: "Complte",
  failed: "Echoue",
  tx_of_one: "Transaction - {{type}}",
  tx_of_other: "Transaction {{current}} / {{count}} - {{type}}",
  skipped: "Ignore",
  approve_error: "Une erreur s'est produite. Vrifiez si le portefeuille est bien connect",
  tx_type: {
    SWAP: "CHANGE",
    DEPOSIT: "DPT",
    APPROVAL: "APPROBATION",
    STAKE: "MISE",
    CLAIM_UNSTAKED: "RCLAMER NON MIS",
    CLAIM_REWARDS: "RCLAMER RCOMPENSES",
    RESTAKE_REWARDS: "REMISE DES RCOMPENSES",
    UNSTAKE: "RETIRER",
    SPLIT: "DIVISER",
    MERGE: "FUSIONNER",
    LOCK: "VERROUILLER",
    UNLOCK: "DVERROUILLER",
    SUPPLY: "FOURNIR",
    BRIDGE: "PONT",
    VOTE: "VOTER",
    REVOKE: "RVOQUER",
    RESTAKE: "REMISE",
    REBOND: "RELIER",
    WITHDRAW: "RETIRER",
    CREATE_ACCOUNT: "CRER UN COMPTE",
    REVEAL: "RVLER",
    MIGRATE: "MIGRER",
    UTXO_P_TO_C_IMPORT: "IMPORTER UTXO P VERS C",
    UTXO_C_TO_P_IMPORT: "IMPORTER UTXO C VERS P",
    UNFREEZE_LEGACY: "DGELER LGACY",
    UNFREEZE_LEGACY_BANDWIDTH: "DGELER BANDE PASSANTE LGACY",
    UNFREEZE_LEGACY_ENERGY: "DGELER NERGIE LGACY",
    UNFREEZE_BANDWIDTH: "DGELER BANDE PASSANTE",
    UNFREEZE_ENERGY: "DGELER NERGIE",
    FREEZE_BANDWIDTH: "GELER BANDE PASSANTE",
    FREEZE_ENERGY: "GELER NERGIE",
    UNDELEGATE_BANDWIDTH: "DLGUER BANDE PASSANTE",
    UNDELEGATE_ENERGY: "DLGUER NERGIE",
    P2P_NODE_REQUEST: "DEMANDE NUD P2P",
    LUGANODES_PROVISION: "FOURNITURE LUGANODES",
    LUGANODES_EXIT_REQUEST: "DEMANDE DE SORTIE LUGANODES",
    INFSTONES_PROVISION: "FOURNITURE INFSTONES",
    INFSTONES_EXIT_REQUEST: "DEMANDE DE SORTIE INFSTONES",
    INFSTONES_CLAIM_REQUEST: "DEMANDE DE RCLAMATION INFSTONES"
  }
}, Tfe = {
  successfully_staked: "{{amount}} {{tokenNetwork}} {{action}} avec succs",
  successfully_unstaked: "{{amount}} {{tokenNetwork}} {{action}} avec succs",
  successfully_pending_action: "{{amount}} {{tokenNetwork}} {{pendingAction}} avec succs",
  view_transaction: "Voir la transaction {{type}}",
  via: "via {{providerName}}",
  stake: {
    staking: "stak",
    "liquid-staking": "stak",
    vault: "dpos",
    lending: "fourni",
    restaking: "restak",
    pooled_staking: "stak",
    native_staking: "stak"
  },
  unstake: {
    staking: "dstak",
    "liquid-staking": "dstak",
    vault: "retir",
    lending: "retir",
    restaking: "dstak",
    pooled_staking: "dstak",
    native_staking: "dstak"
  },
  pending_action: {
    stake: "stak",
    unstake: "dstak",
    claim_rewards: "rcompenses rclames",
    restake_rewards: "rcompenses restakes",
    withdraw: "reitr",
    restake: "restak",
    claim_unstaked: "dstaks rclams",
    unlock_locked: "bloqus dbloqus",
    unlock_locked_legacy: "bloqus dbloqus",
    stake_locked: "bloqus staks",
    vote: "vot",
    revoke: "Rvoquer",
    vote_locked: "Voter bloqu",
    revote: "Revoter",
    rebond: "Re-staker",
    migrate: "Migrer"
  }
}, _fe = {
  geo_block: {
    title: "Bloquage Gographique",
    ofac: "Cette fonctionnalit n'est pas disponible en {{countryName}}. {{countryName}} figure sur la liste des pays sanctionns par l'Office of Foreign Assets Control (OFAC). Vous pouvez en apprendre plus sur l'OFAC et ses programmes de sanctions via ce lien : <link0>https://ofac.treasury.gov/sanctions-programs-and-country-information</link0>.",
    ofsi: "Cette fonctionnalit n'est pas disponible en {{countryName}}. {{countryName}} figure sur la liste des pays sanctionns par l'Office of Financial Sanctions Implementation (OFSI) britannique. Vous pouvez en apprendre plus sur l'OFSI et ses programmes de sanctions via ce lien : <link0>https://www.gov.uk/government/collections/financial-sanctions-regime-specific-consolidated-lists-and-releases</link0>.",
    pending_litigation: "Cette fonctionnalit n'est actuellement pas disponible en {{nameOfRegion}} du fait des litiges en cours au sujet du staking des cryptomonnaies",
    crypto_ban: "Cette fonctionnalit n'est pas disponible en {{countryName}}. {{countryName}} a mis en place une rgulation stricte  l'usage des cryptomonnaies. Merci de vous rfrer aux ressources officielles de {{countryName}} pour en savoir plus.",
    staking_ban: "Cette fonctionnalit n'est pas disponible en {{countryName}}. La Securities and Exchange Commission (SEC) de {{countryName}} a interdit aux oprateurs d'actifs numriques d'offrir des services de staking. Vous pouvez en apprendre plus sur les rgulations de la SEC via ce lien : <link0>https://www.sec.or.th/TH/Pages/News_Detail.aspx?SECID=10018</link0>.",
    ofsi_crypto_ban: "Cette fonctionnalit n'est pas disponible en {{countryName}}. {{countryName}} figure sur la liste des pays sanctionns par l'Office of Financial Sanctions Implementation (OFSI) britannique. Vous pouvez en apprendre plus sur l'OFSI et ses programmes de sanctions via ce lien : <link0>https://www.gov.uk/government/collections/financial-sanctions-regime-specific-consolidated-lists-and-releases</link0>. {{countryName}} a aussi mis en place une rgulatin stricte concernant l'usage des cryptomonnaies.",
    ofac_ofsi: "Cette fonctionnalit n'est pas disponible en {{countryName}}. {{countryName}} figure sur les listes des pays sanctionns par l'Office of Foreign Assets Control (OFAC) et de l'Office of Financial Sanctions Implementation (OFSI) britannique. Vous pouvez en apprendre plus sur l'OFAC et ses programmes de sanctions via ce lien : <link0>https://ofac.treasury.gov/sanctions-programs-and-country-information</link0>, ainsi que sur ceux de l'OFSI via ce lien : <link>https://www.gov.uk/government/collections/financial-sanctions-regime-specific-consolidated-lists-and-releases</link>.",
    default: "Cette fonctionnalit n'est pas disponible en {{countryName}}."
  },
  get_in_touch: {
    title: "Une question ? Besoin d'aide ?",
    button: "Contactez-nous"
  },
  what_is_stakekit: {
    title: "Qu'est-ce que StakeKit ?",
    description: "StakeKit est une plateforme qui vous permet d'engendrer facilement des rendements en propre  travers les rseaux et tokens les plus importants. Du staking au staking liquide, en passant par les vaults et le lending. StakeKit abstrait toute la complexit, rendant les gains accessibles en moins de 3 clics. Et cerise sur le gteau, vous restez propritaires de vos fonds.<br0/><br0/>Vous trouverez plus d'informations  propos de StakeKit sur notre <link0>site web</link0> ou dans notre <link1>FAQ.</link1>"
  },
  under_maintenance: {
    title: "En maintenance",
    description: "StakeKit est actuellement en maintenance de routine. Notre service devrait tre de retour en ligne dans environ 5  10 minutes.",
    description2: "Nous apprcions votre patience et vous encourageons  revenir bientt !"
  }
}, Rfe = {
  title: "Mes Positions",
  via_one: "via {{providerName}}",
  via_other: "via {{providerName}} + {{count}} autres",
  connect_wallet: "Connecter un portefeuille",
  no_current_positions: "Aucune position",
  claim_rewards: "Rclamer les rcompenses",
  action_required: "Action requise",
  dont_see_position: "Vous ne voyez pas une position?",
  import_validator: "Importez un validateur  qui vous avez dlgu des fonds pour voir votre position",
  import_button: "Importer",
  import_validator_modal_title: "Importer un validateur",
  import_validator_already_imported: "Import",
  search_for_validators: "Rechercher des validateurs par adresse ou nom"
}, Ofe = {
  native_staking: {
    title: "Staking Native",
    review: "Staker",
    cta: "Staker"
  },
  pooled_staking: {
    title: "Staking Pooled",
    review: "Staker",
    cta: "Staker"
  },
  staking: {
    title: "Staking",
    review: "Staker",
    cta: "Staker"
  },
  "liquid-staking": {
    title: "Staking Liquide",
    review: "Staker",
    cta: "Staker"
  },
  vault: {
    title: "Vault",
    review: "Dposer",
    cta: "Dposer"
  },
  lending: {
    title: "Lending",
    review: "Fournir",
    cta: "Fournir"
  },
  restaking: {
    title: "Restaking",
    review: "Dposer",
    cta: "Dposer"
  }
}, Ife = {
  labels: {
    hasFrozenV1: {
      label: "Gel 1.0",
      details: "{{amount}} TRX sont gels avec Legacy Stake 1.0. Pour migrer vers 2.0 : Il suffit de dstaker {{amount}} TRX dans StakeKit et de les staker  nouveau (StakeKit priorise automatiquement le dstaking du solde de Stake 1.0)"
    }
  },
  via: "{{stakeType}} via {{providerName}}",
  rewards: "Rcompenses",
  available_to: "<bold>{{amount}} {{symbol}}</bold> disponibles pour {{pendingAction, lowercase}}",
  claim: "Rclamer",
  unstake: "Dstaker",
  withdraw: "Retirer",
  available: "{{amount}} {{symbol}} disponibles",
  select_validators: {
    submit: "Envoyer"
  },
  stake_type: {
    staking: "Stak",
    "liquid-staking": "Stak",
    lending: "Dpos",
    vault: "Dpos",
    restaking: "Restak"
  },
  unstake_label: {
    staking: "Dstaker",
    "liquid-staking": "Dstaker",
    lending: "Retirer",
    vault: "Retirer",
    restaking: "Dstaker"
  },
  balance_type: {
    available: "Disponible",
    staked: "Stak",
    staked_yearn_or_deposit: "Dpos",
    unstaking: "En cours de dstaking",
    unstaking_yearn_or_deposit: "En cours de retrait",
    unstaked: "Dstak",
    unstaked_yearn_or_deposit: "Retir",
    preparing: "En cours de prparation",
    rewards: "Rcompenses",
    locked: "Bloqu",
    unlocking: "En cours de dblocage"
  },
  unstaking_days_one: "{{count}} jour restant",
  unstaking_days_other: "{{count}} jours restants",
  pending_action: {
    stake: "Staker",
    unstake: "Dstaker",
    claim_rewards: "Rclamer les rcompenses",
    restake_rewards: "Restaker les rcompenses",
    withdraw: "Retirer",
    restake: "Restaker",
    claim_unstaked: "Rclamer les dstaks",
    unlock_locked: "Dbloquer",
    unlock_locked_legacy: "Dbloquer",
    stake_locked: "Staker",
    vote: "Voter",
    revoke: "Rvoquer",
    vote_locked: "Voter",
    revote: "Revoter",
    rebond: "Re-staker",
    migrate: "Migrer"
  },
  pending_action_button: {
    stake: "Staker",
    unstake: "Dstaker",
    claim_rewards: "Rclamer",
    restake_rewards: "Restaker",
    withdraw: "Retirer",
    restake: "Restaker",
    claim_unstaked: "Rclamer",
    unlock_locked: "Dbloquer",
    unlock_locked_legacy: "Dbloquer",
    stake_locked: "Staker",
    vote: "Voter",
    revoke: "Rvoquer",
    vote_locked: "Voter bloqu",
    revote: "Revoter",
    rebond: "Re-staker",
    migrate: "Migrer"
  },
  unstake_sign: {
    title: "Vrifier la proprit",
    description: "Vous devez vrifier la proprit de cette adresse avant de procder. Vous serez invit(e)  signer un message qui sera utilis pour confirmer que vous possdez bien cette adresse."
  }
}, Dfe = {
  terms_of_use: "En cliquant sur Confirmer vous acceptez les <underline0>Conditions d'utilisation</underline0> et comprenez les Informations sur les Risques",
  unstake_from: "Dstaker de {{providerName}}"
}, Mfe = {
  pending_action_type: {
    stake: "Staker avec {{providerName}}",
    unstake: "Dstaker de {{providerName}}",
    claim_rewards: "Rclamer les rcompenses de {{providerName}}",
    restake_rewards: "Restaker les rcompenses avec {{providerName}}",
    withdraw: "Retirer de {{providerName}}",
    restake: "Restaker avec {{providerName}}",
    claim_unstaked: "Rclamer le dstak de {{providerName}}",
    unlock_locked: "Dbloquer le bloqu de {{providerName}}",
    unlock_locked_legacy: "Dbloquer le bloqu de {{providerName}}",
    stake_locked: "Staker le bloqu avec {{providerName}}",
    vote: "Voter avec {{providerName}}",
    revoke: "Rvoquer avec {{providerName}}",
    vote_locked: "Voter bloqu avec {{providerName}}",
    revote: "Revoter avec {{providerName}}",
    rebond: "Re-staker avec {{providerName}}",
    migrate: "Migrer de {{providerName}}"
  }
}, Pfe = {
  title: "Slectionner un token",
  n_available_opps: "{{count}} opportunits disponibles"
}, Nfe = {
  title: "Vrification du parrainage",
  body: "Saisissez votre code de parrainage pour continuer",
  submit: "Envoyer"
}, Bfe = {
  solution: "Solution potentielle :"
}, Lfe = {
  shared: wfe,
  chain_modal: Cfe,
  init: xfe,
  activity: Efe,
  details: Sfe,
  review: kfe,
  steps: Afe,
  complete: Tfe,
  help_modals: _fe,
  positions: Rfe,
  yield_types: Ofe,
  position_details: Ife,
  unstake_review: Dfe,
  pending_action_review: Mfe,
  select_token: Pfe,
  referral_lock: Nfe,
  error_modal: Bfe
}, uM = xse(), qj = {
  en: { translation: bfe },
  fr: { translation: Lfe }
};
uM.use(ele).use(yV).init({
  resources: qj,
  supportedLngs: Object.keys(qj),
  fallbackLng: "en",
  interpolation: { escapeValue: !1 },
  detection: { order: ["navigator", "localStorage"] }
});
var Hz;
(Hz = uM.services.formatter) == null || Hz.add(
  "lowercase",
  (e, t, n) => e.toLowerCase()
);
const jfe = () => {
  const e = _8(), { i18n: t } = ln(), [n] = t.language.split("-");
  return Qr({
    queryKey: ["error-translations", n],
    staleTime: Number.POSITIVE_INFINITY,
    gcTime: Number.POSITIVE_INFINITY,
    queryFn: () => Ia({
      fn: () => e.get(
        `https://i18n.stakek.it/locales/${n}/errors.json`
      )
    }).ifRight(
      (r) => t.addResourceBundle(t.language, "translation", {
        errors: r.data
      })
    )
  });
};
he.fromRecord = (e) => {
  const t = {};
  for (const n in e) {
    const r = e[n];
    if (r.isJust())
      t[n] = r.extract();
    else
      return Tr;
  }
  return _n(t);
};
var sn;
(function(e) {
  e.Ethereum = "ethereum", e.EthereumGoerli = "ethereum-goerli", e.EthereumHolesky = "ethereum-holesky", e.Arbitrum = "arbitrum", e.Base = "base", e.Gnosis = "gnosis", e.Optimism = "optimism", e.Polygon = "polygon", e.Starknet = "starknet", e.zkSync = "zksync", e.Linea = "linea", e.AvalancheC = "avalanche-c", e.AvalancheCAtomic = "avalanche-c-atomic", e.AvalancheP = "avalanche-p", e.Binance = "binance", e.Celo = "celo", e.Fantom = "fantom", e.Harmony = "harmony", e.Moonriver = "moonriver", e.OKC = "okc", e.Viction = "viction", e.Core = "core";
})(sn || (sn = {}));
var fn;
(function(e) {
  e.Agoric = "agoric", e.Akash = "akash", e.Axelar = "axelar", e.BandProtocol = "band-protocol", e.Bitsong = "bitsong", e.Canto = "canto", e.Chihuahua = "chihuahua", e.Comdex = "comdex", e.Coreum = "coreum", e.Cosmos = "cosmos", e.Crescent = "crescent", e.Cronos = "cronos", e.Cudos = "cudos", e.Desmos = "desmos", e.Dydx = "dydx", e.Evmos = "evmos", e.FetchAi = "fetch-ai", e.GravityBridge = "gravity-bridge", e.Injective = "injective", e.IRISnet = "irisnet", e.Juno = "juno", e.Kava = "kava", e.KiNetwork = "ki-network", e.MarsProtocol = "mars-protocol", e.NYM = "nym", e.OKExChain = "okex-chain", e.Onomy = "onomy", e.Osmosis = "osmosis", e.Persistence = "persistence", e.Quicksilver = "quicksilver", e.Regen = "regen", e.Secret = "secret", e.Sentinel = "sentinel", e.Sommelier = "sommelier", e.StaFi = "stafi", e.Stargaze = "stargaze", e.Stride = "stride", e.Teritori = "teritori", e.TGrade = "tgrade", e.Umee = "umee", e.Sei = "sei", e.Mantra = "mantra";
})(fn || (fn = {}));
var Ym;
(function(e) {
  e.Polkadot = "polkadot", e.Westend = "westend", e.Kusama = "kusama";
})(Ym || (Ym = {}));
var yi;
(function(e) {
  e.BinanceBeacon = "binancebeacon", e.Cardano = "cardano", e.Near = "near", e.Solana = "solana", e.Tezos = "tezos", e.Tron = "tron", e.Ton = "ton", e.TonTestnet = "ton-testnet";
})(yi || (yi = {}));
const de = {
  ...sn,
  ...fn,
  ...Ym,
  ...yi
};
var Wj;
(function(e) {
  e.slow = "slow", e.average = "average", e.fast = "fast", e.custom = "custom";
})(Wj || (Wj = {}));
var Gj;
(function(e) {
  e.wei = "wei", e.gwei = "gwei";
})(Gj || (Gj = {}));
var pt;
(function(e) {
  e.ATOM = "ATOM", e.uatom = "uatom", e.AKT = "AKT", e.uakt = "uakt", e.KAVA = "KAVA", e.ukava = "ukava", e.OSMO = "OSMO", e.uosmo = "uosmo", e.JUNO = "JUNO", e.ujuno = "ujuno", e.XPRT = "XPRT", e.uxprt = "uxprt", e.STARS = "STARS", e.ustars = "ustars", e.AXL = "AXL", e.uaxl = "uaxl", e.NOM = "NOM", e.anom = "anom", e.QCK = "QCK", e.uqck = "uqck", e.BLD = "BLD", e.ubld = "ubld", e.BAND = "BAND", e.uband = "uband", e.BTSG = "BTSG", e.ubtsg = "ubtsg", e.CANTO = "CANTO", e.acanto = "acanto", e.CMDX = "CMDX", e.ucmdx = "ucmdx", e.CRE = "CRE", e.ucre = "ucre", e.CRO = "CRO", e.basecro = "basecro", e.CUDOS = "CUDOS", e.acudos = "acudos", e.DVPN = "DVPN", e.udvpn = "udvpn", e.EVMOS = "EVMOS", e.aevmos = "aevmos", e.FET = "FET", e.afet = "afet", e.GRAVITON = "GRAVITON", e.ugraviton = "ugraviton", e.HUAHUA = "HUAHUA", e.uhuahua = "uhuahua", e.INJ = "INJ", e.inj = "inj", e.IRIS = "IRIS", e.uiris = "uiris", e.XKI = "XKI", e.uxki = "uxki", e.MARS = "MARS", e.umars = "umars", e.NYM = "NYM", e.unym = "unym", e.OKT = "OKT", e.aokt = "wei", e.REGEN = "REGEN", e.uregen = "uregen", e.SCRT = "SCRT", e.uscrt = "uscrt", e.SOMM = "SOMM", e.usomm = "usomm", e.FIS = "FIS", e.ufis = "ufis", e.STRD = "STRD", e.ustrd = "ustrd", e.TORI = "TORI", e.utori = "utori", e.TGD = "TGD", e.utgd = "utgd", e.UMEE = "UMEE", e.uumee = "uumee", e.CORE = "CORE", e.ucore = "ucore", e.DSM = "DSM", e.udsm = "udsm", e.DYDX = "DYDX", e.adydx = "adydx", e.SEI = "SEI", e.usei = "usei", e.OM = "OM", e.uom = "uom";
})(pt || (pt = {}));
const Ct = {
  [de.Akash]: {
    network: de.Akash,
    chainId: "akashnet-2",
    name: "Akash",
    denom: pt.AKT,
    minimalDenom: pt.uakt,
    decimals: 6,
    bech32Prefix: "akash",
    coinGeckoId: "akash-network"
  },
  [de.Cosmos]: {
    network: de.Cosmos,
    chainId: "cosmoshub-4",
    name: "Cosmos",
    denom: pt.ATOM,
    minimalDenom: pt.uatom,
    decimals: 6,
    bech32Prefix: "cosmos",
    coinGeckoId: "cosmos"
  },
  [de.Kava]: {
    network: de.Kava,
    chainId: "kava-9",
    name: "Kava",
    denom: pt.KAVA,
    minimalDenom: pt.ukava,
    decimals: 6,
    bech32Prefix: "kava",
    coinGeckoId: "kava"
  },
  [de.Osmosis]: {
    network: de.Osmosis,
    chainId: "osmosis-1",
    name: "Osmosis",
    denom: pt.OSMO,
    minimalDenom: pt.uosmo,
    decimals: 6,
    bech32Prefix: "osmo",
    coinGeckoId: "osmosis"
  },
  [de.Juno]: {
    network: de.Juno,
    chainId: "juno-1",
    name: "Juno",
    denom: pt.JUNO,
    minimalDenom: pt.ujuno,
    decimals: 6,
    bech32Prefix: "juno",
    coinGeckoId: "juno-network"
  },
  [de.Stargaze]: {
    network: de.Stargaze,
    chainId: "stargaze-1",
    name: "Stargaze",
    denom: pt.STARS,
    minimalDenom: pt.ustars,
    decimals: 6,
    bech32Prefix: "stars",
    coinGeckoId: "stargaze"
  },
  [de.Persistence]: {
    network: de.Persistence,
    chainId: "core-1",
    name: "Persistence",
    denom: pt.XPRT,
    minimalDenom: pt.uxprt,
    decimals: 6,
    bech32Prefix: "persistence",
    coinGeckoId: "persistence"
  },
  [de.Axelar]: {
    network: de.Axelar,
    chainId: "axelar-dojo-1",
    name: "Axelar",
    denom: pt.AXL,
    minimalDenom: pt.uaxl,
    decimals: 6,
    bech32Prefix: "axelar",
    coinGeckoId: "axelar"
  },
  [de.Onomy]: {
    network: de.Onomy,
    chainId: "onomy-mainnet-1",
    name: "Onomy",
    denom: pt.NOM,
    minimalDenom: pt.anom,
    decimals: 18,
    bech32Prefix: "onomy",
    coinGeckoId: "onomy-protocol"
  },
  [de.Quicksilver]: {
    network: de.Quicksilver,
    chainId: "quicksilver-2",
    name: "Quicksilver",
    denom: pt.QCK,
    minimalDenom: pt.uqck,
    decimals: 6,
    bech32Prefix: "quick",
    coinGeckoId: "quicksilver"
  },
  [de.Agoric]: {
    network: de.Agoric,
    chainId: "agoric-3",
    name: "Agoric",
    denom: pt.BLD,
    minimalDenom: pt.ubld,
    decimals: 6,
    bech32Prefix: "agoric",
    coinGeckoId: "agoric"
  },
  [de.BandProtocol]: {
    network: de.BandProtocol,
    chainId: "laozi-mainnet",
    name: "Band Protocol",
    denom: pt.BAND,
    minimalDenom: pt.uband,
    decimals: 6,
    bech32Prefix: "band",
    coinGeckoId: "band-protocol"
  },
  [de.Bitsong]: {
    network: de.Bitsong,
    chainId: "bitsong-2b",
    name: "BitSong",
    denom: pt.BTSG,
    minimalDenom: pt.ubtsg,
    decimals: 6,
    bech32Prefix: "bitsong",
    coinGeckoId: "bitsong"
  },
  [de.Canto]: {
    network: de.Canto,
    chainId: "canto_7700-1",
    name: "Canto",
    denom: pt.CANTO,
    minimalDenom: pt.acanto,
    decimals: 18,
    bech32Prefix: "canto",
    coinGeckoId: "canto"
  },
  [de.Chihuahua]: {
    network: de.Chihuahua,
    chainId: "chihuahua-1",
    name: "Chihuahua",
    denom: pt.HUAHUA,
    minimalDenom: pt.uhuahua,
    decimals: 6,
    bech32Prefix: "chihuahua",
    coinGeckoId: "chihuahua-token"
  },
  [de.Comdex]: {
    network: de.Comdex,
    chainId: "comdex-1",
    name: "Comdex",
    denom: pt.CMDX,
    minimalDenom: pt.ucmdx,
    decimals: 6,
    bech32Prefix: "comdex",
    coinGeckoId: "comdex"
  },
  [de.Crescent]: {
    network: de.Crescent,
    chainId: "crescent-1",
    name: "Crescent",
    denom: pt.CRE,
    minimalDenom: pt.ucre,
    decimals: 6,
    bech32Prefix: "cre",
    coinGeckoId: "crescent-network"
  },
  [de.Cronos]: {
    network: de.Cronos,
    chainId: "crypto-org-chain-mainnet-1",
    name: "Crypto.org Chain",
    denom: pt.CRO,
    minimalDenom: pt.basecro,
    decimals: 18,
    bech32Prefix: "cro",
    coinGeckoId: "crypto-com-chain"
  },
  [de.Cudos]: {
    network: de.Cudos,
    chainId: "cudos-1",
    name: "Cudos",
    denom: pt.CUDOS,
    minimalDenom: pt.acudos,
    decimals: 18,
    bech32Prefix: "cudos",
    coinGeckoId: "cudos"
  },
  [de.Evmos]: {
    network: de.Evmos,
    chainId: "evmos_9001-2",
    name: "Evmos",
    denom: pt.EVMOS,
    minimalDenom: pt.aevmos,
    decimals: 18,
    bech32Prefix: "evmos",
    coinGeckoId: "evmos"
  },
  [de.FetchAi]: {
    network: de.FetchAi,
    chainId: "fetchhub-4",
    name: "Fetch.ai",
    denom: pt.FET,
    minimalDenom: pt.afet,
    decimals: 18,
    bech32Prefix: "fetch",
    coinGeckoId: "fetch-ai"
  },
  [de.GravityBridge]: {
    network: de.GravityBridge,
    chainId: "gravity-bridge-3",
    name: "Gravity Bridge",
    denom: pt.GRAVITON,
    minimalDenom: pt.ugraviton,
    decimals: 6,
    bech32Prefix: "gravity",
    coinGeckoId: "graviton"
  },
  [de.Injective]: {
    network: de.Injective,
    chainId: "injective-1",
    name: "Injective",
    denom: pt.INJ,
    minimalDenom: pt.inj,
    decimals: 18,
    bech32Prefix: "inj",
    coinGeckoId: "injective-protocol"
  },
  [de.IRISnet]: {
    network: de.IRISnet,
    chainId: "irishub-1",
    name: "IRISnet",
    denom: pt.IRIS,
    minimalDenom: pt.uiris,
    decimals: 6,
    bech32Prefix: "iaa",
    coinGeckoId: "iris-network"
  },
  [de.KiNetwork]: {
    network: de.KiNetwork,
    chainId: "kichain-2",
    name: "Ki",
    denom: pt.XKI,
    minimalDenom: pt.uxki,
    decimals: 6,
    bech32Prefix: "ki",
    coinGeckoId: "ki"
  },
  [de.MarsProtocol]: {
    network: de.MarsProtocol,
    chainId: "mars-1",
    name: "Mars Hub",
    denom: pt.MARS,
    minimalDenom: pt.umars,
    decimals: 6,
    bech32Prefix: "mars",
    coinGeckoId: "mars-protocol"
  },
  [de.NYM]: {
    network: de.NYM,
    chainId: "nyx",
    name: "Nym",
    denom: pt.NYM,
    minimalDenom: pt.unym,
    decimals: 6,
    bech32Prefix: "n",
    coinGeckoId: "nym"
  },
  [de.OKExChain]: {
    network: de.OKExChain,
    chainId: "exchain-66",
    name: "OKExChain",
    denom: pt.OKT,
    minimalDenom: pt.aokt,
    decimals: 18,
    bech32Prefix: "ex",
    coinGeckoId: "oec-token"
  },
  [de.Regen]: {
    network: de.Regen,
    chainId: "regen-1",
    name: "Regen",
    denom: pt.REGEN,
    minimalDenom: pt.uregen,
    decimals: 6,
    bech32Prefix: "regen",
    coinGeckoId: "regen"
  },
  [de.Secret]: {
    network: de.Secret,
    chainId: "secret-4",
    name: "Secret Network",
    denom: pt.SCRT,
    minimalDenom: pt.uscrt,
    decimals: 6,
    bech32Prefix: "secret",
    coinGeckoId: "secret"
  },
  [de.Sentinel]: {
    network: de.Sentinel,
    chainId: "sentinelhub-2",
    name: "Sentinel",
    denom: pt.DVPN,
    minimalDenom: pt.udvpn,
    decimals: 6,
    bech32Prefix: "sent",
    coinGeckoId: "sentinel"
  },
  [de.Sommelier]: {
    network: de.Sommelier,
    chainId: "sommelier-3",
    name: "Sommelier",
    denom: pt.SOMM,
    minimalDenom: pt.usomm,
    decimals: 6,
    bech32Prefix: "somm",
    coinGeckoId: "sommelier"
  },
  [de.StaFi]: {
    network: de.StaFi,
    chainId: "stafihub-1",
    name: "StaFi Hub",
    denom: pt.FIS,
    minimalDenom: pt.ufis,
    decimals: 6,
    bech32Prefix: "stafi",
    coinGeckoId: "stafi"
  },
  [de.Stride]: {
    network: de.Stride,
    chainId: "stride-1",
    name: "Stride",
    denom: pt.STRD,
    minimalDenom: pt.ustrd,
    decimals: 6,
    bech32Prefix: "stride",
    coinGeckoId: "stride"
  },
  [de.Teritori]: {
    network: de.Teritori,
    chainId: "teritori-1",
    name: "Teritori",
    denom: pt.TORI,
    minimalDenom: pt.utori,
    decimals: 6,
    bech32Prefix: "tori",
    coinGeckoId: "teritori"
  },
  [de.TGrade]: {
    network: de.TGrade,
    chainId: "tgrade-mainnet-1",
    name: "Tgrade",
    denom: pt.TGD,
    minimalDenom: pt.utgd,
    decimals: 6,
    bech32Prefix: "tgrade",
    coinGeckoId: "tgrade"
  },
  [de.Umee]: {
    network: de.Umee,
    chainId: "umee-1",
    name: "Umee",
    denom: pt.UMEE,
    minimalDenom: pt.uumee,
    decimals: 6,
    bech32Prefix: "umee",
    coinGeckoId: "umee"
  },
  [de.Coreum]: {
    network: de.Coreum,
    chainId: "coreum-mainnet-1",
    name: "Coreum",
    denom: pt.CORE,
    minimalDenom: pt.ucore,
    decimals: 6,
    bech32Prefix: "core",
    coinGeckoId: "coreum"
  },
  [de.Desmos]: {
    network: de.Desmos,
    chainId: "desmos-mainnet",
    name: "Desmos",
    denom: pt.DSM,
    minimalDenom: pt.udsm,
    decimals: 6,
    bech32Prefix: "desmos",
    coinGeckoId: "desmos"
  },
  [de.Dydx]: {
    network: de.Dydx,
    chainId: "dydx-mainnet-1",
    name: "dydx",
    denom: pt.DYDX,
    minimalDenom: pt.adydx,
    decimals: 18,
    bech32Prefix: "dydx",
    coinGeckoId: "dydx-chain"
  },
  [de.Sei]: {
    network: de.Sei,
    chainId: "pacific-1",
    name: "sei",
    denom: pt.SEI,
    minimalDenom: pt.usei,
    decimals: 6,
    bech32Prefix: "sei",
    coinGeckoId: "sei-network"
  },
  [de.Mantra]: {
    network: de.Mantra,
    chainId: "mantra-1",
    name: "mantra",
    denom: pt.OM,
    minimalDenom: pt.uom,
    decimals: 6,
    bech32Prefix: "mantra",
    coinGeckoId: "mantra-dao"
  }
};
de.Ethereum + "", de.Solana + "", de.Celo + "", de.Optimism + "", de.AvalancheC + "", de.Fantom + "", de.Polygon + "", de.Binance + "", de.Harmony + "", de.Arbitrum + "", de.Tezos + "", de.Cardano + "", de.Starknet + "", de.Base + "", de.Linea + "", de.zkSync + "", de.Core + "", de.Cosmos + "", Ct[de.Cosmos].coinGeckoId, de.Kava + "", Ct[de.Kava].coinGeckoId, de.Osmosis + "", Ct[de.Osmosis].coinGeckoId, de.Stargaze + "", Ct[de.Stargaze].coinGeckoId, de.Juno + "", Ct[de.Juno].coinGeckoId, de.Persistence + "", Ct[de.Persistence].coinGeckoId, de.Axelar + "", Ct[de.Axelar].coinGeckoId, de.Onomy + "", Ct[de.Onomy].coinGeckoId, de.Agoric + "", Ct[de.Agoric].coinGeckoId, de.BandProtocol + "", Ct[de.BandProtocol].coinGeckoId, de.Bitsong + "", Ct[de.Bitsong].coinGeckoId, de.Canto + "", Ct[de.Canto].coinGeckoId, de.Chihuahua + "", Ct[de.Chihuahua].coinGeckoId, de.Comdex + "", Ct[de.Comdex].coinGeckoId, de.Crescent + "", Ct[de.Crescent].coinGeckoId, de.Cronos + "", Ct[de.Cronos].coinGeckoId, de.Cudos + "", Ct[de.Cudos].coinGeckoId, de.Evmos + "", Ct[de.Evmos].coinGeckoId, de.FetchAi + "", Ct[de.FetchAi].coinGeckoId, de.GravityBridge + "", Ct[de.GravityBridge].coinGeckoId, de.Injective + "", Ct[de.Injective].coinGeckoId, de.IRISnet + "", Ct[de.IRISnet].coinGeckoId, de.KiNetwork + "", Ct[de.KiNetwork].coinGeckoId, de.MarsProtocol + "", Ct[de.MarsProtocol].coinGeckoId, de.NYM + "", Ct[de.NYM].coinGeckoId, de.OKExChain + "", Ct[de.OKExChain].coinGeckoId, de.Regen + "", Ct[de.Regen].coinGeckoId, de.Secret + "", Ct[de.Secret].coinGeckoId, de.Sentinel + "", Ct[de.Sentinel].coinGeckoId, de.Sommelier + "", Ct[de.Sommelier].coinGeckoId, de.StaFi + "", Ct[de.StaFi].coinGeckoId, de.Stride + "", Ct[de.Stride].coinGeckoId, de.Teritori + "", Ct[de.Teritori].coinGeckoId, de.TGrade + "", Ct[de.TGrade].coinGeckoId, de.Umee + "", Ct[de.Umee].coinGeckoId, de.Coreum + "", Ct[de.Coreum].coinGeckoId, de.Desmos + "", Ct[de.Desmos].coinGeckoId, de.Dydx + "", Ct[de.Dydx].coinGeckoId, de.Sei + "", Ct[de.Sei].coinGeckoId, de.Mantra + "", Ct[de.Mantra].coinGeckoId;
de.Arbitrum + "", de.AvalancheC + "", de.Binance + "", de.Celo + "", de.Ethereum + "", de.EthereumGoerli + "", de.EthereumHolesky + "", de.Fantom + "", de.Near + "", de.Harmony + "", de.Optimism + "", de.Polygon + "", de.Akash + "", de.Solana + "", de.Tezos + "", de.Starknet + "", de.Viction + "", de.Base + "", de.Linea + "", de.zkSync + "", de.Core + "", de.Cosmos + "", Ct[de.Cosmos].chainId, de.Kava + "", Ct[de.Kava].chainId, de.Osmosis + "", Ct[de.Osmosis].chainId, de.Stargaze + "", Ct[de.Stargaze].chainId, de.Juno + "", Ct[de.Juno].chainId, de.Persistence + "", Ct[de.Persistence].chainId, de.Axelar + "", Ct[de.Axelar].chainId, de.Onomy + "", Ct[de.Onomy].chainId, de.Agoric + "", Ct[de.Agoric].chainId, de.BandProtocol + "", Ct[de.BandProtocol].chainId, de.Bitsong + "", Ct[de.Bitsong].chainId, de.Canto + "", Ct[de.Canto].chainId, de.Chihuahua + "", Ct[de.Chihuahua].chainId, de.Comdex + "", Ct[de.Comdex].chainId, de.Crescent + "", Ct[de.Crescent].chainId, de.Cronos + "", Ct[de.Cronos].chainId, de.Cudos + "", Ct[de.Cudos].chainId, de.Evmos + "", Ct[de.Evmos].chainId, de.FetchAi + "", Ct[de.FetchAi].chainId, de.GravityBridge + "", Ct[de.GravityBridge].chainId, de.Injective + "", Ct[de.Injective].chainId, de.IRISnet + "", Ct[de.IRISnet].chainId, de.KiNetwork + "", Ct[de.KiNetwork].chainId, de.MarsProtocol + "", Ct[de.MarsProtocol].chainId, de.NYM + "", Ct[de.NYM].chainId, de.OKExChain + "", Ct[de.OKExChain].chainId, de.Regen + "", Ct[de.Regen].chainId, de.Secret + "", Ct[de.Secret].chainId, de.Sentinel + "", Ct[de.Sentinel].chainId, de.Sommelier + "", Ct[de.Sommelier].chainId, de.StaFi + "", Ct[de.StaFi].chainId, de.Stride + "", Ct[de.Stride].chainId, de.Teritori + "", Ct[de.Teritori].chainId, de.TGrade + "", Ct[de.TGrade].chainId, de.Umee + "", Ct[de.Umee].chainId, de.Coreum + "", Ct[de.Coreum].chainId, de.Desmos + "", Ct[de.Desmos].chainId, de.Dydx + "", Ct[de.Dydx].chainId, de.Sei + "", Ct[de.Sei].chainId, de.Mantra + "", Ct[de.Mantra].chainId;
const z$ = [
  fn.Akash,
  fn.Cosmos,
  fn.Juno,
  fn.Kava,
  fn.Osmosis,
  fn.Stargaze,
  fn.Onomy,
  fn.Persistence,
  fn.Axelar,
  fn.Quicksilver,
  fn.Agoric,
  fn.BandProtocol,
  fn.Bitsong,
  fn.Chihuahua,
  fn.Comdex,
  fn.Crescent,
  fn.Cronos,
  fn.Cudos,
  fn.FetchAi,
  fn.GravityBridge,
  fn.IRISnet,
  fn.KiNetwork,
  fn.MarsProtocol,
  fn.Regen,
  fn.Secret,
  fn.Sentinel,
  fn.Sommelier,
  fn.Teritori,
  fn.Umee,
  fn.Coreum,
  fn.Desmos,
  fn.Dydx,
  fn.Injective,
  fn.Sei,
  fn.Mantra
], Ffe = new Set(z$), Ufe = [
  sn.AvalancheC,
  sn.Arbitrum,
  sn.Binance,
  sn.Celo,
  sn.Ethereum,
  sn.EthereumGoerli,
  sn.Harmony,
  sn.Optimism,
  sn.Polygon,
  sn.Viction,
  sn.EthereumHolesky,
  sn.Base,
  sn.Linea,
  sn.Core
], zfe = new Set(Ufe), Vfe = [
  yi.Near,
  yi.Tezos,
  yi.Solana,
  yi.Tron,
  yi.Ton
], $fe = new Set(Vfe), Hfe = [Ym.Polkadot], qfe = new Set(Hfe), V$ = (e) => Ffe.has(e) || zfe.has(e) || $fe.has(e) || qfe.has(e), Ije = {
  near: {
    "*": {
      currencyId: "near",
      family: "near",
      skChainName: yi.Near
    }
  },
  tezos: {
    "*": {
      currencyId: "tezos",
      family: "tezos",
      skChainName: yi.Tezos
    }
  },
  solana: {
    "*": {
      currencyId: "solana",
      family: "solana",
      skChainName: yi.Solana
    }
  },
  tron: {
    "*": {
      currencyId: "tron",
      family: "tron",
      skChainName: yi.Tron
    }
  },
  ton: {
    "*": {
      currencyId: "ton",
      family: "ton",
      skChainName: yi.Ton
    }
  },
  polkadot: {
    "*": {
      currencyId: "polkadot",
      family: "polkadot",
      skChainName: Ym.Polkadot
    }
  },
  celo: {
    "*": {
      currencyId: "celo",
      family: "celo",
      skChainName: sn.Celo
    }
  },
  crypto_org: {
    "*": {
      currencyId: "crypto_org",
      family: "crypto_org",
      skChainName: fn.Cronos
    }
  },
  ethereum: {
    ethereum: {
      currencyId: "ethereum",
      family: "ethereum",
      skChainName: sn.Ethereum
    },
    polygon: {
      currencyId: "polygon",
      family: "ethereum",
      skChainName: sn.Polygon
    },
    arbitrum: {
      currencyId: "arbitrum",
      family: "ethereum",
      skChainName: sn.Arbitrum
    },
    optimism: {
      currencyId: "optimism",
      family: "ethereum",
      skChainName: sn.Optimism
    },
    "avalanche-c": {
      currencyId: "avalanche_c_chain",
      family: "ethereum",
      skChainName: sn.AvalancheC
    },
    ethereum_holesky: {
      currencyId: "ethereum_holesky",
      family: "ethereum",
      skChainName: sn.EthereumHolesky
    }
  },
  cosmos: {
    cosmos: {
      currencyId: "cosmos",
      family: "cosmos",
      skChainName: fn.Cosmos
    },
    osmo: {
      currencyId: "osmo",
      family: "cosmos",
      skChainName: fn.Osmosis
    },
    coreum: {
      currencyId: "coreum",
      family: "cosmos",
      skChainName: fn.Coreum
    },
    axelar: {
      currencyId: "axelar",
      family: "cosmos",
      skChainName: fn.Axelar
    },
    stargaze: {
      currencyId: "stargaze",
      family: "cosmos",
      skChainName: fn.Stargaze
    },
    secret_network: {
      currencyId: "secret_network",
      family: "cosmos",
      skChainName: fn.Secret
    },
    umee: {
      currencyId: "umee",
      family: "cosmos",
      skChainName: fn.Umee
    },
    desmos: {
      currencyId: "desmos",
      family: "cosmos",
      skChainName: fn.Desmos
    },
    onomy: {
      currencyId: "onomy",
      family: "cosmos",
      skChainName: fn.Onomy
    },
    quicksilver: {
      currencyId: "quicksilver",
      family: "cosmos",
      skChainName: fn.Quicksilver
    },
    persistence: {
      currencyId: "persistence",
      family: "cosmos",
      skChainName: fn.Persistence
    },
    dydx: {
      currencyId: "dydx",
      family: "cosmos",
      skChainName: fn.Dydx
    },
    injective: {
      currencyId: "injective",
      family: "cosmos",
      skChainName: fn.Injective
    },
    sei: {
      currencyId: "sei",
      family: "cosmos",
      skChainName: fn.Sei
    },
    mantra: {
      currencyId: "mantra",
      family: "cosmos",
      skChainName: fn.Mantra
    }
  }
}, Wfe = () => {
  const { externalProviders: e } = dr();
  return k.useMemo(
    () => $$({
      externalProviderInitToken: e == null ? void 0 : e.initToken
    }),
    [e == null ? void 0 : e.initToken]
  );
}, Gfe = uo.custom({
  decode: (e) => rs.decode(e).chain(
    (t) => t in Tm ? Pt(t) : Rn("invalid pending action")
  ),
  encode: (e) => e
}), Kfe = uo.custom({
  decode: (e) => rs.decode(e).chain((t) => V$(t) ? Pt(t) : Rn("invalid chain")),
  encode: (e) => e
}), Yfe = /^(?!.*\.\.)[a-zA-Z0-9-_.]*$/, vm = uo.custom({
  decode: (e) => rs.decode(e).chain(
    (t) => Yfe.test(t) ? Pt(t) : Rn("invalid string value")
  ),
  encode: (e) => e
}), Qfe = uo.custom({
  decode: (e) => rs.decode(e).chain((t) => {
    const [n, r, ...i] = t.split("-");
    return !n || !r || !i.toString() ? Rn("invalid yieldId format") : Pt(t);
  }),
  encode: (e) => e
}), Xfe = uo.custom({
  decode: (e) => e === "earn" || e === "positions" ? Pt(e) : Rn("invalid chain"),
  encode: (e) => e
}), Jfe = uo.custom({
  decode: (e) => rs.decode(e).map((t) => decodeURIComponent(t)),
  encode: (e) => e
}), $$ = ({
  externalProviderInitToken: e
}) => Ro.map((t) => new URL(t.location.href)).map((t) => ({
  network: vm.decode(t.searchParams.get("network")).alt(
    vm.decode(t.searchParams.get("token")).chain(
      (n) => n.includes("-") ? Pt(n.split("-").slice(0, -1).join("-")) : Rn("invalid TokenString")
    )
  ).chain(Kfe.decode).toMaybe().extractNullable(),
  token: rs.decode(t.searchParams.get("token") ?? e).toMaybe().extractNullable(),
  yieldId: vm.decode(t.searchParams.get("yieldId")).chain(Qfe.decode).toMaybe().extractNullable(),
  balanceId: vm.decode(t.searchParams.get("balanceId")).toMaybe().extractNullable(),
  validator: rs.decode(t.searchParams.get("validator")).toMaybe().extractNullable(),
  pendingaction: vm.decode(t.searchParams.get("pendingaction")).chain(Gfe.decode).toMaybe().extractNullable(),
  referralCode: vm.decode(t.searchParams.get("ref")).toMaybe().extractNullable(),
  accountId: Jfe.decode(t.searchParams.get("accountId")).toMaybe().extractNullable(),
  tab: vm.decode(t.searchParams.get("tab")).chain(Xfe.decode).toMaybe().extractNullable()
})), Zfe = () => new Nae({
  defaultOptions: {
    queries: {
      gcTime: ni.queryClient.cacheTime,
      staleTime: ni.queryClient.staleTime,
      retry: (e, t) => Qd(t) ? !!(t5(t) && e < 2) : !1,
      refetchOnWindowFocus: !1
    },
    mutations: {
      retry: (e, t) => Qd(t) ? !!(t5(t) && e < 2) : !1
    }
  }
}), H$ = k.createContext(void 0), ehe = ({ children: e }) => {
  const [t] = k.useState(Zfe);
  return /* @__PURE__ */ S.jsx(H$.Provider, { value: t, children: /* @__PURE__ */ S.jsx(Uae, { client: t, children: e }) });
}, tc = () => {
  const e = k.useContext(H$);
  if (!e)
    throw new Error(
      "useSKQueryClient must be used within a QueryClientContextProvider"
    );
  return e;
}, the = () => {
  const e = k.useRef(!1);
  return k.useEffect(() => (e.current = !1, () => {
    e.current = !0;
  }), []), k.useCallback(() => e.current, []);
}, q$ = {
  id: "safe",
  name: "Safe",
  type: "safe"
}, dM = (e) => e.id === q$.id;
class nhe extends Error {
  constructor(n) {
    super("Safe tx failed");
    Ms(this, "_tag", "SafeFailedError");
    Ms(this, "type");
    this.type = n;
  }
}
var Kj = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"', rhe = {
  rounded: `SFRounded, ui-rounded, "SF Pro Rounded", ${Kj}`,
  system: Kj
}, o1 = {
  large: {
    actionButton: "9999px",
    connectButton: "12px",
    modal: "24px",
    modalMobile: "28px"
  },
  medium: {
    actionButton: "10px",
    connectButton: "8px",
    modal: "16px",
    modalMobile: "18px"
  },
  none: {
    actionButton: "0px",
    connectButton: "0px",
    modal: "0px",
    modalMobile: "0px"
  },
  small: {
    actionButton: "4px",
    connectButton: "4px",
    modal: "8px",
    modalMobile: "8px"
  }
}, ihe = {
  large: {
    modalOverlay: "blur(20px)"
  },
  none: {
    modalOverlay: "blur(0px)"
  },
  small: {
    modalOverlay: "blur(4px)"
  }
}, W$ = ({
  borderRadius: e = "large",
  fontStack: t = "rounded",
  overlayBlur: n = "none"
}) => ({
  blurs: {
    modalOverlay: ihe[n].modalOverlay
  },
  fonts: {
    body: rhe[t]
  },
  radii: {
    actionButton: o1[e].actionButton,
    connectButton: o1[e].connectButton,
    menuButton: o1[e].connectButton,
    modal: o1[e].modal,
    modalMobile: o1[e].modalMobile
  }
}), a4 = "#1A1B1F", G$ = {
  blue: { accentColor: "#3898FF", accentColorForeground: "#FFF" },
  green: { accentColor: "#4BD166", accentColorForeground: a4 },
  orange: { accentColor: "#FF983D", accentColorForeground: a4 },
  pink: { accentColor: "#FF7AB8", accentColorForeground: a4 },
  purple: { accentColor: "#7A70FF", accentColorForeground: "#FFF" },
  red: { accentColor: "#FF6257", accentColorForeground: "#FFF" }
}, Yj = G$.blue, K$ = ({
  accentColor: e = Yj.accentColor,
  accentColorForeground: t = Yj.accentColorForeground,
  ...n
} = {}) => ({
  ...W$(n),
  colors: {
    accentColor: e,
    accentColorForeground: t,
    actionButtonBorder: "rgba(255, 255, 255, 0.04)",
    actionButtonBorderMobile: "rgba(255, 255, 255, 0.08)",
    actionButtonSecondaryBackground: "rgba(255, 255, 255, 0.08)",
    closeButton: "rgba(224, 232, 255, 0.6)",
    closeButtonBackground: "rgba(255, 255, 255, 0.08)",
    connectButtonBackground: a4,
    connectButtonBackgroundError: "#FF494A",
    connectButtonInnerBackground: "linear-gradient(0deg, rgba(255, 255, 255, 0.075), rgba(255, 255, 255, 0.15))",
    connectButtonText: "#FFF",
    connectButtonTextError: "#FFF",
    connectionIndicator: "#30E000",
    downloadBottomCardBackground: "linear-gradient(126deg, rgba(0, 0, 0, 0) 9.49%, rgba(120, 120, 120, 0.2) 71.04%), #1A1B1F",
    downloadTopCardBackground: "linear-gradient(126deg, rgba(120, 120, 120, 0.2) 9.49%, rgba(0, 0, 0, 0) 71.04%), #1A1B1F",
    error: "#FF494A",
    generalBorder: "rgba(255, 255, 255, 0.08)",
    generalBorderDim: "rgba(255, 255, 255, 0.04)",
    menuItemBackground: "rgba(224, 232, 255, 0.1)",
    modalBackdrop: "rgba(0, 0, 0, 0.5)",
    modalBackground: "#1A1B1F",
    modalBorder: "rgba(255, 255, 255, 0.08)",
    modalText: "#FFF",
    modalTextDim: "rgba(224, 232, 255, 0.3)",
    modalTextSecondary: "rgba(255, 255, 255, 0.6)",
    profileAction: "rgba(224, 232, 255, 0.1)",
    profileActionHover: "rgba(224, 232, 255, 0.2)",
    profileForeground: "rgba(224, 232, 255, 0.05)",
    selectedOptionBorder: "rgba(224, 232, 255, 0.1)",
    standby: "#FFD641"
  },
  shadows: {
    connectButton: "0px 4px 12px rgba(0, 0, 0, 0.1)",
    dialog: "0px 8px 32px rgba(0, 0, 0, 0.32)",
    profileDetailsAction: "0px 2px 6px rgba(37, 41, 46, 0.04)",
    selectedOption: "0px 2px 6px rgba(0, 0, 0, 0.24)",
    selectedWallet: "0px 2px 6px rgba(0, 0, 0, 0.24)",
    walletLogo: "0px 2px 16px rgba(0, 0, 0, 0.16)"
  }
});
K$.accentColors = G$;
var Y$ = {
  blue: { accentColor: "#0E76FD", accentColorForeground: "#FFF" },
  green: { accentColor: "#1DB847", accentColorForeground: "#FFF" },
  orange: { accentColor: "#FF801F", accentColorForeground: "#FFF" },
  pink: { accentColor: "#FF5CA0", accentColorForeground: "#FFF" },
  purple: { accentColor: "#5F5AFA", accentColorForeground: "#FFF" },
  red: { accentColor: "#FA423C", accentColorForeground: "#FFF" }
}, Qj = Y$.blue, fM = ({
  accentColor: e = Qj.accentColor,
  accentColorForeground: t = Qj.accentColorForeground,
  ...n
} = {}) => ({
  ...W$(n),
  colors: {
    accentColor: e,
    accentColorForeground: t,
    actionButtonBorder: "rgba(0, 0, 0, 0.04)",
    actionButtonBorderMobile: "rgba(0, 0, 0, 0.06)",
    actionButtonSecondaryBackground: "rgba(0, 0, 0, 0.06)",
    closeButton: "rgba(60, 66, 66, 0.8)",
    closeButtonBackground: "rgba(0, 0, 0, 0.06)",
    connectButtonBackground: "#FFF",
    connectButtonBackgroundError: "#FF494A",
    connectButtonInnerBackground: "linear-gradient(0deg, rgba(0, 0, 0, 0.03), rgba(0, 0, 0, 0.06))",
    connectButtonText: "#25292E",
    connectButtonTextError: "#FFF",
    connectionIndicator: "#30E000",
    downloadBottomCardBackground: "linear-gradient(126deg, rgba(255, 255, 255, 0) 9.49%, rgba(171, 171, 171, 0.04) 71.04%), #FFFFFF",
    downloadTopCardBackground: "linear-gradient(126deg, rgba(171, 171, 171, 0.2) 9.49%, rgba(255, 255, 255, 0) 71.04%), #FFFFFF",
    error: "#FF494A",
    generalBorder: "rgba(0, 0, 0, 0.06)",
    generalBorderDim: "rgba(0, 0, 0, 0.03)",
    menuItemBackground: "rgba(60, 66, 66, 0.1)",
    modalBackdrop: "rgba(0, 0, 0, 0.3)",
    modalBackground: "#FFF",
    modalBorder: "transparent",
    modalText: "#25292E",
    modalTextDim: "rgba(60, 66, 66, 0.3)",
    modalTextSecondary: "rgba(60, 66, 66, 0.6)",
    profileAction: "#FFF",
    profileActionHover: "rgba(255, 255, 255, 0.5)",
    profileForeground: "rgba(60, 66, 66, 0.06)",
    selectedOptionBorder: "rgba(60, 66, 66, 0.1)",
    standby: "#FFD641"
  },
  shadows: {
    connectButton: "0px 4px 12px rgba(0, 0, 0, 0.1)",
    dialog: "0px 8px 32px rgba(0, 0, 0, 0.32)",
    profileDetailsAction: "0px 2px 6px rgba(37, 41, 46, 0.04)",
    selectedOption: "0px 2px 6px rgba(0, 0, 0, 0.24)",
    selectedWallet: "0px 2px 6px rgba(0, 0, 0, 0.12)",
    walletLogo: "0px 2px 16px rgba(0, 0, 0, 0.16)"
  }
});
fM.accentColors = Y$;
var s5 = `{
  "connect_wallet": {
    "label": "Connect Wallet",
    "wrong_network": {
      "label": "Wrong network"
    }
  },

  "intro": {
    "title": "What is a Wallet?",
    "description": "A wallet is used to send, receive, store, and display digital assets. It's also a new way to log in, without needing to create new accounts and passwords on every website.",
    "digital_asset": {
      "title": "A Home for your Digital Assets",
      "description": "Wallets are used to send, receive, store, and display digital assets like Ethereum and NFTs."
    },
    "login": {
      "title": "A New Way to Log In",
      "description": "Instead of creating new accounts and passwords on every website, just connect your wallet."
    },
    "get": {
      "label": "Get a Wallet"
    },
    "learn_more": {
      "label": "Learn More"
    }
  },

  "sign_in": {
    "label": "Verify your account",
    "description": "To finish connecting, you must sign a message in your wallet to verify that you are the owner of this account.",
    "message": {
      "send": "Sign message",
      "preparing": "Preparing message...",
      "cancel": "Cancel",
      "preparing_error": "Error preparing message, please retry!"
    },
    "signature": {
      "waiting": "Waiting for signature...",
      "verifying": "Verifying signature...",
      "signing_error": "Error signing message, please retry!",
      "verifying_error": "Error verifying signature, please retry!",
      "oops_error": "Oops, something went wrong!"
    }
  },

  "connect": {
    "label": "Connect",
    "title": "Connect a Wallet",
    "new_to_ethereum": {
      "description": "New to Ethereum wallets?",
      "learn_more": {
        "label": "Learn More"
      }
    },
    "learn_more": {
      "label": "Learn more"
    },
    "recent": "Recent",
    "status": {
      "opening": "Opening %{wallet}...",
      "connecting": "Connecting",
      "connect_mobile": "Continue in %{wallet}",
      "not_installed": "%{wallet} is not installed",
      "not_available": "%{wallet} is not available",
      "confirm": "Confirm connection in the extension",
      "confirm_mobile": "Accept connection request in the wallet"
    },
    "secondary_action": {
      "get": {
        "description": "Don't have %{wallet}?",
        "label": "GET"
      },
      "install": {
        "label": "INSTALL"
      },
      "retry": {
        "label": "RETRY"
      }
    },
    "walletconnect": {
      "description": {
        "full": "Need the official WalletConnect modal?",
        "compact": "Need the WalletConnect modal?"
      },
      "open": {
        "label": "OPEN"
      }
    }
  },

  "connect_scan": {
    "title": "Scan with %{wallet}",
    "fallback_title": "Scan with your phone"
  },

  "connector_group": {
    "installed": "Installed",
    "recommended": "Recommended",
    "other": "Other",
    "popular": "Popular",
    "more": "More",
    "others": "Others"
  },

  "get": {
    "title": "Get a Wallet",
    "action": {
      "label": "GET"
    },
    "mobile": {
      "description": "Mobile Wallet"
    },
    "extension": {
      "description": "Browser Extension"
    },
    "mobile_and_extension": {
      "description": "Mobile Wallet and Extension"
    },
    "mobile_and_desktop": {
      "description": "Mobile and Desktop Wallet"
    },
    "looking_for": {
      "title": "Not what you're looking for?",
      "mobile": {
        "description": "Select a wallet on the main screen to get started with a different wallet provider."
      },
      "desktop": {
        "compact_description": "Select a wallet on the main screen to get started with a different wallet provider.",
        "wide_description": "Select a wallet on the left to get started with a different wallet provider."
      }
    }
  },

  "get_options": {
    "title": "Get started with %{wallet}",
    "short_title": "Get %{wallet}",
    "mobile": {
      "title": "%{wallet} for Mobile",
      "description": "Use the mobile wallet to explore the world of Ethereum.",
      "download": {
        "label": "Get the app"
      }
    },
    "extension": {
      "title": "%{wallet} for %{browser}",
      "description": "Access your wallet right from your favorite web browser.",
      "download": {
        "label": "Add to %{browser}"
      }
    },
    "desktop": {
      "title": "%{wallet} for %{platform}",
      "description": "Access your wallet natively from your powerful desktop.",
      "download": {
        "label": "Add to %{platform}"
      }
    }
  },

  "get_mobile": {
    "title": "Install %{wallet}",
    "description": "Scan with your phone to download on iOS or Android",
    "continue": {
      "label": "Continue"
    }
  },

  "get_instructions": {
    "mobile": {
      "connect": {
        "label": "Connect"
      },
      "learn_more": {
        "label": "Learn More"
      }
    },
    "extension": {
      "refresh": {
        "label": "Refresh"
      },
      "learn_more": {
        "label": "Learn More"
      }
    },
    "desktop": {
      "connect": {
        "label": "Connect"
      },
      "learn_more": {
        "label": "Learn More"
      }
    }
  },

  "chains": {
    "title": "Switch Networks",
    "wrong_network": "Wrong network detected, switch or disconnect to continue.",
    "confirm": "Confirm in Wallet",
    "confirm_error": "Error switching chain",
    "switching_not_supported": "Your wallet does not support switching networks from %{appName}. Try switching networks from within your wallet instead.",
    "switching_not_supported_fallback": "Your wallet does not support switching networks from this app. Try switching networks from within your wallet instead.",
    "disconnect": "Disconnect",
    "connected": "Connected"
  },

  "profile": {
    "disconnect": {
      "label": "Disconnect"
    },
    "copy_address": {
      "label": "Copy Address",
      "copied": "Copied!"
    },
    "explorer": {
      "label": "View more on explorer"
    },
    "transactions": {
      "description": "%{appName} transactions will appear here...",
      "description_fallback": "Your transactions will appear here...",
      "recent": {
        "title": "Recent Transactions"
      },
      "clear": {
        "label": "Clear All"
      }
    }
  },

  "wallet_connectors": {
    "argent": {
      "qr_code": {
        "step1": {
          "description": "Put Argent on your home screen for faster access to your wallet.",
          "title": "Open the Argent app"
        },
        "step2": {
          "description": "Create a wallet and username, or import an existing wallet.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "After you scan, a connection prompt will appear for you to connect your wallet.",
          "title": "Tap the Scan QR button"
        }
      }
    },

    "bifrost": {
      "qr_code": {
        "step1": {
          "description": "We recommend putting Bifrost Wallet on your home screen for quicker access.",
          "title": "Open the Bifrost Wallet app"
        },
        "step2": {
          "description": "Create or import a wallet using your recovery phrase.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "After you scan, a connection prompt will appear for you to connect your wallet.",
          "title": "Tap the scan button"
        }
      }
    },

    "bitget": {
      "qr_code": {
        "step1": {
          "description": "We recommend putting Bitget Wallet on your home screen for quicker access.",
          "title": "Open the Bitget Wallet app"
        },
        "step2": {
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "After you scan, a connection prompt will appear for you to connect your wallet.",
          "title": "Tap the scan button"
        }
      },

      "extension": {
        "step1": {
          "description": "We recommend pinning Bitget Wallet to your taskbar for quicker access to your wallet.",
          "title": "Install the Bitget Wallet extension"
        },
        "step2": {
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension.",
          "title": "Refresh your browser"
        }
      }
    },

    "bitski": {
      "extension": {
        "step1": {
          "description": "We recommend pinning Bitski to your taskbar for quicker access to your wallet.",
          "title": "Install the Bitski extension"
        },
        "step2": {
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension.",
          "title": "Refresh your browser"
        }
      }
    },

    "bitverse": {
      "qr_code": {
        "step1": {
          "title": "Open the Bitverse Wallet app",
          "description": "Add Bitverse Wallet to your home screen for faster access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Create a new wallet or import an existing one."
        },
        "step3": {
          "title": "Tap the QR icon and scan",
          "description": "Tap the QR icon on your homescreen, scan the code and confirm the prompt to connect."
        }
      }
    },

    "bloom": {
      "desktop": {
        "step1": {
          "title": "Open the Bloom Wallet app",
          "description": "We recommend putting Bloom Wallet on your home screen for quicker access."
        },
        "step2": {
          "description": "Create or import a wallet using your recovery phrase.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "After you have a wallet, click on Connect to connect via Bloom. A connection prompt in the app will appear for you to confirm the connection.",
          "title": "Click on Connect"
        }
      },
      "qr_code": {
        "step1": {
          "title": "Open the Bloom Wallet app",
          "description": "We recommend putting Bloom Wallet on your home screen for quicker access."
        },
        "step2": {
          "description": "Create or import a wallet using your recovery phrase.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "After you have a wallet, click on Connect to connect via Bloom. A connection prompt in the app will appear for you to confirm the connection.",
          "title": "Click on Connect"
        }
      }
    },

    "bybit": {
      "qr_code": {
        "step1": {
          "description": "We recommend putting Bybit on your home screen for faster access to your wallet.",
          "title": "Open the Bybit app"
        },
        "step2": {
          "description": "You can easily backup your wallet using our backup feature on your phone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "After you scan, a connection prompt will appear for you to connect your wallet.",
          "title": "Tap the scan button"
        }
      },

      "extension": {
        "step1": {
          "description": "Click at the top right of your browser and pin Bybit Wallet for easy access.",
          "title": "Install the Bybit Wallet extension"
        },
        "step2": {
          "description": "Create a new wallet or import an existing one.",
          "title": "Create or Import a wallet"
        },
        "step3": {
          "description": "Once you set up Bybit Wallet, click below to refresh the browser and load up the extension.",
          "title": "Refresh your browser"
        }
      }
    },

    "coin98": {
      "qr_code": {
        "step1": {
          "description": "We recommend putting Coin98 Wallet on your home screen for faster access to your wallet.",
          "title": "Open the Coin98 Wallet app"
        },
        "step2": {
          "description": "You can easily backup your wallet using our backup feature on your phone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "After you scan, a connection prompt will appear for you to connect your wallet.",
          "title": "Tap the WalletConnect button"
        }
      },

      "extension": {
        "step1": {
          "description": "Click at the top right of your browser and pin Coin98 Wallet for easy access.",
          "title": "Install the Coin98 Wallet extension"
        },
        "step2": {
          "description": "Create a new wallet or import an existing one.",
          "title": "Create or Import a wallet"
        },
        "step3": {
          "description": "Once you set up Coin98 Wallet, click below to refresh the browser and load up the extension.",
          "title": "Refresh your browser"
        }
      }
    },

    "coinbase": {
      "qr_code": {
        "step1": {
          "description": "We recommend putting Coinbase Wallet on your home screen for quicker access.",
          "title": "Open the Coinbase Wallet app"
        },
        "step2": {
          "description": "You can easily backup your wallet using the cloud backup feature.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "After you scan, a connection prompt will appear for you to connect your wallet.",
          "title": "Tap the scan button"
        }
      },

      "extension": {
        "step1": {
          "description": "We recommend pinning Coinbase Wallet to your taskbar for quicker access to your wallet.",
          "title": "Install the Coinbase Wallet extension"
        },
        "step2": {
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension.",
          "title": "Refresh your browser"
        }
      }
    },

    "compass": {
      "extension": {
        "step1": {
          "description": "We recommend pinning Compass Wallet to your taskbar for quicker access to your wallet.",
          "title": "Install the Compass Wallet extension"
        },
        "step2": {
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension.",
          "title": "Refresh your browser"
        }
      }
    },

    "core": {
      "qr_code": {
        "step1": {
          "description": "We recommend putting Core on your home screen for faster access to your wallet.",
          "title": "Open the Core app"
        },
        "step2": {
          "description": "You can easily backup your wallet using our backup feature on your phone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "After you scan, a connection prompt will appear for you to connect your wallet.",
          "title": "Tap the WalletConnect button"
        }
      },

      "extension": {
        "step1": {
          "description": "We recommend pinning Core to your taskbar for quicker access to your wallet.",
          "title": "Install the Core extension"
        },
        "step2": {
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension.",
          "title": "Refresh your browser"
        }
      }
    },

    "fox": {
      "qr_code": {
        "step1": {
          "description": "We recommend putting FoxWallet on your home screen for quicker access.",
          "title": "Open the FoxWallet app"
        },
        "step2": {
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "After you scan, a connection prompt will appear for you to connect your wallet.",
          "title": "Tap the scan button"
        }
      }
    },

    "frontier": {
      "qr_code": {
        "step1": {
          "description": "We recommend putting Frontier Wallet on your home screen for quicker access.",
          "title": "Open the Frontier Wallet app"
        },
        "step2": {
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "After you scan, a connection prompt will appear for you to connect your wallet.",
          "title": "Tap the scan button"
        }
      },

      "extension": {
        "step1": {
          "description": "We recommend pinning Frontier Wallet to your taskbar for quicker access to your wallet.",
          "title": "Install the Frontier Wallet extension"
        },
        "step2": {
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension.",
          "title": "Refresh your browser"
        }
      }
    },

    "im_token": {
      "qr_code": {
        "step1": {
          "title": "Open the imToken app",
          "description": "Put imToken app on your home screen for faster access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Create a new wallet or import an existing one."
        },
        "step3": {
          "title": "Tap Scanner Icon in top right corner",
          "description": "Choose New Connection, then scan the QR code and confirm the prompt to connect."
        }
      }
    },

    "kaikas": {
      "extension": {
        "step1": {
          "description": "We recommend pinning Kaikas to your taskbar for quicker access to your wallet.",
          "title": "Install the Kaikas extension"
        },
        "step2": {
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension.",
          "title": "Refresh your browser"
        }
      },
      "qr_code": {
        "step1": {
          "title": "Open the Kaikas app",
          "description": "Put Kaikas app on your home screen for faster access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Create a new wallet or import an existing one."
        },
        "step3": {
          "title": "Tap Scanner Icon in top right corner",
          "description": "Choose New Connection, then scan the QR code and confirm the prompt to connect."
        }
      }
    },

    "kraken": {
      "qr_code": {
        "step1": {
          "title": "Open the Kraken Wallet app",
          "description": "Add Kraken Wallet to your home screen for faster access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Create a new wallet or import an existing one."
        },
        "step3": {
          "title": "Tap the QR icon and scan",
          "description": "Tap the QR icon on your homescreen, scan the code and confirm the prompt to connect."
        }
      }
    },

    "kresus": {
      "qr_code": {
        "step1": {
          "title": "Open the Kresus Wallet app",
          "description": "Add Kresus Wallet to your home screen for faster access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Create a new wallet or import an existing one."
        },
        "step3": {
          "title": "Tap the QR icon and scan",
          "description": "Tap the QR icon on your homescreen, scan the code and confirm the prompt to connect."
        }
      }
    },

    "magicEden": {
      "extension": {
        "step1": {
          "title": "Install the Magic Eden extension",
          "description": "We recommend pinning Magic Eden to your taskbar for easier access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret recovery phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "metamask": {
      "qr_code": {
        "step1": {
          "title": "Open the MetaMask app",
          "description": "We recommend putting MetaMask on your home screen for quicker access."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Tap the scan button",
          "description": "After you scan, a connection prompt will appear for you to connect your wallet."
        }
      },

      "extension": {
        "step1": {
          "title": "Install the MetaMask extension",
          "description": "We recommend pinning MetaMask to your taskbar for quicker access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "nestwallet": {
      "extension": {
        "step1": {
          "title": "Install the NestWallet extension",
          "description": "We recommend pinning NestWallet to your taskbar for quicker access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "okx": {
      "qr_code": {
        "step1": {
          "title": "Open the OKX Wallet app",
          "description": "We recommend putting OKX Wallet on your home screen for quicker access."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Tap the scan button",
          "description": "After you scan, a connection prompt will appear for you to connect your wallet."
        }
      },

      "extension": {
        "step1": {
          "title": "Install the OKX Wallet extension",
          "description": "We recommend pinning OKX Wallet to your taskbar for quicker access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "omni": {
      "qr_code": {
        "step1": {
          "title": "Open the Omni app",
          "description": "Add Omni to your home screen for faster access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Create a new wallet or import an existing one."
        },
        "step3": {
          "title": "Tap the QR icon and scan",
          "description": "Tap the QR icon on your home screen, scan the code and confirm the prompt to connect."
        }
      }
    },

    "1inch": {
      "qr_code": {
        "step1": {
          "description": "Put 1inch Wallet on your home screen for faster access to your wallet.",
          "title": "Open the 1inch Wallet app"
        },
        "step2": {
          "description": "Create a wallet and username, or import an existing wallet.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "After you scan, a connection prompt will appear for you to connect your wallet.",
          "title": "Tap the Scan QR button"
        }
      }
    },

    "token_pocket": {
      "qr_code": {
        "step1": {
          "title": "Open the TokenPocket app",
          "description": "We recommend putting TokenPocket on your home screen for quicker access."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Tap the scan button",
          "description": "After you scan, a connection prompt will appear for you to connect your wallet."
        }
      },

      "extension": {
        "step1": {
          "title": "Install the TokenPocket extension",
          "description": "We recommend pinning TokenPocket to your taskbar for quicker access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "trust": {
      "qr_code": {
        "step1": {
          "title": "Open the Trust Wallet app",
          "description": "Put Trust Wallet on your home screen for faster access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Create a new wallet or import an existing one."
        },
        "step3": {
          "title": "Tap WalletConnect in Settings",
          "description": "Choose New Connection, then scan the QR code and confirm the prompt to connect."
        }
      },

      "extension": {
        "step1": {
          "title": "Install the Trust Wallet extension",
          "description": "Click at the top right of your browser and pin Trust Wallet for easy access."
        },
        "step2": {
          "title": "Create or Import a wallet",
          "description": "Create a new wallet or import an existing one."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up Trust Wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "uniswap": {
      "qr_code": {
        "step1": {
          "title": "Open the Uniswap app",
          "description": "Add Uniswap Wallet to your home screen for faster access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Create a new wallet or import an existing one."
        },
        "step3": {
          "title": "Tap the QR icon and scan",
          "description": "Tap the QR icon on your homescreen, scan the code and confirm the prompt to connect."
        }
      }
    },

    "zerion": {
      "qr_code": {
        "step1": {
          "title": "Open the Zerion app",
          "description": "We recommend putting Zerion on your home screen for quicker access."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Tap the scan button",
          "description": "After you scan, a connection prompt will appear for you to connect your wallet."
        }
      },

      "extension": {
        "step1": {
          "title": "Install the Zerion extension",
          "description": "We recommend pinning Zerion to your taskbar for quicker access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "rainbow": {
      "qr_code": {
        "step1": {
          "title": "Open the Rainbow app",
          "description": "We recommend putting Rainbow on your home screen for faster access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "You can easily backup your wallet using our backup feature on your phone."
        },
        "step3": {
          "title": "Tap the scan button",
          "description": "After you scan, a connection prompt will appear for you to connect your wallet."
        }
      }
    },

    "enkrypt": {
      "extension": {
        "step1": {
          "description": "We recommend pinning Enkrypt Wallet to your taskbar for quicker access to your wallet.",
          "title": "Install the Enkrypt Wallet extension"
        },
        "step2": {
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension.",
          "title": "Refresh your browser"
        }
      }
    },

    "frame": {
      "extension": {
        "step1": {
          "description": "We recommend pinning Frame to your taskbar for quicker access to your wallet.",
          "title": "Install Frame & the companion extension"
        },
        "step2": {
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension.",
          "title": "Refresh your browser"
        }
      }
    },

    "one_key": {
      "extension": {
        "step1": {
          "title": "Install the OneKey Wallet extension",
          "description": "We recommend pinning OneKey Wallet to your taskbar for quicker access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "phantom": {
      "extension": {
        "step1": {
          "title": "Install the Phantom extension",
          "description": "We recommend pinning Phantom to your taskbar for easier access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret recovery phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "rabby": {
      "extension": {
        "step1": {
          "title": "Install the Rabby extension",
          "description": "We recommend pinning Rabby to your taskbar for quicker access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "ronin": {
      "qr_code": {
        "step1": {
          "description": "We recommend putting Ronin Wallet on your home screen for quicker access.",
          "title": "Open the Ronin Wallet app"
        },
        "step2": {
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "After you scan, a connection prompt will appear for you to connect your wallet.",
          "title": "Tap the scan button"
        }
      },

      "extension": {
        "step1": {
          "description": "We recommend pinning Ronin Wallet to your taskbar for quicker access to your wallet.",
          "title": "Install the Ronin Wallet extension"
        },
        "step2": {
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension.",
          "title": "Refresh your browser"
        }
      }
    },

    "ramper": {
      "extension": {
        "step1": {
          "title": "Install the Ramper extension",
          "description": "We recommend pinning Ramper to your taskbar for easier access to your wallet."
        },
        "step2": {
          "title": "Create a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "safeheron": {
      "extension": {
        "step1": {
          "title": "Install the Core extension",
          "description": "We recommend pinning Safeheron to your taskbar for quicker access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "taho": {
      "extension": {
        "step1": {
          "title": "Install the Taho extension",
          "description": "We recommend pinning Taho to your taskbar for quicker access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "talisman": {
      "extension": {
        "step1": {
          "title": "Install the Talisman extension",
          "description": "We recommend pinning Talisman to your taskbar for quicker access to your wallet."
        },
        "step2": {
          "title": "Create or Import an Ethereum Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your recovery phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "xdefi": {
      "extension": {
        "step1": {
          "title": "Install the XDEFI Wallet extension",
          "description": "We recommend pinning XDEFI Wallet to your taskbar for quicker access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "zeal": {
      "extension": {
        "step1": {
          "title": "Install the Zeal extension",
          "description": "We recommend pinning Zeal to your taskbar for quicker access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "safepal": {
      "extension": {
        "step1": {
          "title": "Install the SafePal Wallet extension",
          "description": "Click at the top right of your browser and pin SafePal Wallet for easy access."
        },
        "step2": {
          "title": "Create or Import a wallet",
          "description": "Create a new wallet or import an existing one."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up SafePal Wallet, click below to refresh the browser and load up the extension."
        }
      },
      "qr_code": {
        "step1": {
          "title": "Open the SafePal Wallet app",
          "description": "Put SafePal Wallet on your home screen for faster access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Create a new wallet or import an existing one."
        },
        "step3": {
          "title": "Tap WalletConnect in Settings",
          "description": "Choose New Connection, then scan the QR code and confirm the prompt to connect."
        }
      }
    },

    "desig": {
      "extension": {
        "step1": {
          "title": "Install the Desig extension",
          "description": "We recommend pinning Desig to your taskbar for easier access to your wallet."
        },
        "step2": {
          "title": "Create a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "subwallet": {
      "extension": {
        "step1": {
          "title": "Install the SubWallet extension",
          "description": "We recommend pinning SubWallet to your taskbar for quicker access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your recovery phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      },
      "qr_code": {
        "step1": {
          "title": "Open the SubWallet app",
          "description": "We recommend putting SubWallet on your home screen for quicker access."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Tap the scan button",
          "description": "After you scan, a connection prompt will appear for you to connect your wallet."
        }
      }
    },

    "clv": {
      "extension": {
        "step1": {
          "title": "Install the CLV Wallet extension",
          "description": "We recommend pinning CLV Wallet to your taskbar for quicker access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      },
      "qr_code": {
        "step1": {
          "title": "Open the CLV Wallet app",
          "description": "We recommend putting CLV Wallet on your home screen for quicker access."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Tap the scan button",
          "description": "After you scan, a connection prompt will appear for you to connect your wallet."
        }
      }
    },

    "okto": {
      "qr_code": {
        "step1": {
          "title": "Open the Okto app",
          "description": "Add Okto to your home screen for quick access"
        },
        "step2": {
          "title": "Create an MPC Wallet",
          "description": "Create an account and generate a wallet"
        },
        "step3": {
          "title": "Tap WalletConnect in Settings",
          "description": "Tap the Scan QR icon at the top right and confirm the prompt to connect."
        }
      }
    },

    "ledger": {
      "desktop": {
        "step1": {
          "title": "Open the Ledger Live app",
          "description": "We recommend putting Ledger Live on your home screen for quicker access."
        },
        "step2": {
          "title": "Set up your Ledger",
          "description": "Set up a new Ledger or connect to an existing one."
        },
        "step3": {
          "title": "Connect",
          "description": "A connection prompt will appear for you to connect your wallet."
        }
      },
      "qr_code": {
        "step1": {
          "title": "Open the Ledger Live app",
          "description": "We recommend putting Ledger Live on your home screen for quicker access."
        },
        "step2": {
          "title": "Set up your Ledger",
          "description": "You can either sync with the desktop app or connect your Ledger."
        },
        "step3": {
          "title": "Scan the code",
          "description": "Tap WalletConnect then Switch to Scanner. After you scan, a connection prompt will appear for you to connect your wallet."
        }
      }
    }
  }
}
`;
function ohe(e, t) {
  return Object.defineProperty(e, "__recipe__", {
    value: t,
    writable: !1
  }), e;
}
var Q$ = ohe;
function X$(e) {
  var {
    conditions: t
  } = e;
  if (!t)
    throw new Error("Styles have no conditions");
  function n(r) {
    if (typeof r == "string" || typeof r == "number" || typeof r == "boolean") {
      if (!t.defaultCondition)
        throw new Error("No default condition");
      return {
        [t.defaultCondition]: r
      };
    }
    if (Array.isArray(r)) {
      if (!("responsiveArray" in t))
        throw new Error("Responsive arrays are not supported");
      var i = {};
      for (var o in t.responsiveArray)
        r[o] != null && (i[t.responsiveArray[o]] = r[o]);
      return i;
    }
    return r;
  }
  return Q$(n, {
    importPath: "@vanilla-extract/sprinkles/createUtils",
    importName: "createNormalizeValueFn",
    args: [{
      conditions: e.conditions
    }]
  });
}
function ahe(e) {
  var {
    conditions: t
  } = e;
  if (!t)
    throw new Error("Styles have no conditions");
  var n = X$(e);
  function r(i, o) {
    if (typeof i == "string" || typeof i == "number" || typeof i == "boolean") {
      if (!t.defaultCondition)
        throw new Error("No default condition");
      return o(i, t.defaultCondition);
    }
    var s = Array.isArray(i) ? n(i) : i, c = {};
    for (var u in s)
      s[u] != null && (c[u] = o(s[u], u));
    return c;
  }
  return Q$(r, {
    importPath: "@vanilla-extract/sprinkles/createUtils",
    importName: "createMapValueFn",
    args: [{
      conditions: e.conditions
    }]
  });
}
function she(e, t) {
  if (typeof e != "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function lhe(e) {
  var t = she(e, "string");
  return typeof t == "symbol" ? t : String(t);
}
function che(e, t, n) {
  return t = lhe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Xj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function GR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Xj(Object(n), !0).forEach(function(r) {
      che(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Xj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var uhe = (e) => function() {
  for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
    n[r] = arguments[r];
  var i = Object.assign({}, ...n.map((u) => u.styles)), o = Object.keys(i), s = o.filter((u) => "mappings" in i[u]), c = (u) => {
    var f = [], p = {}, y = GR({}, u), v = !1;
    for (var w of s) {
      var C = u[w];
      if (C != null) {
        var x = i[w];
        v = !0;
        for (var A of x.mappings)
          p[A] = C, y[A] == null && delete y[A];
      }
    }
    var R = v ? GR(GR({}, p), y) : u, I = function() {
      var j = R[D], F = i[D];
      try {
        if (F.mappings)
          return "continue";
        if (typeof j == "string" || typeof j == "number") {
          if (ct.env.NODE_ENV !== "production" && !F.values[j].defaultClass)
            throw new Error();
          f.push(F.values[j].defaultClass);
        } else if (Array.isArray(j))
          for (var O = 0; O < j.length; O++) {
            var z = j[O];
            if (z != null) {
              var H = F.responsiveArray[O];
              if (ct.env.NODE_ENV !== "production" && !F.values[z].conditions[H])
                throw new Error();
              f.push(F.values[z].conditions[H]);
            }
          }
        else
          for (var Q in j) {
            var Y = j[Q];
            if (Y != null) {
              if (ct.env.NODE_ENV !== "production" && !F.values[Y].conditions[Q])
                throw new Error();
              f.push(F.values[Y].conditions[Q]);
            }
          }
      } catch (oe) {
        if (ct.env.NODE_ENV !== "production") {
          class be extends Error {
            constructor(pe) {
              super(pe), this.name = "SprinklesError";
            }
          }
          var ee = (ce) => typeof ce == "string" ? '"'.concat(ce, '"') : ce, ie = (ce, pe, Ee) => {
            throw new be('"'.concat(ce, '" has no value ').concat(ee(pe), ". Possible values are ").concat(Object.keys(Ee).map(ee).join(", ")));
          };
          if (!F)
            throw new be('"'.concat(D, '" is not a valid sprinkle'));
          if ((typeof j == "string" || typeof j == "number") && (j in F.values || ie(D, j, F.values), !F.values[j].defaultClass))
            throw new be('"'.concat(D, '" has no default condition. You must specify which conditions to target explicitly. Possible options are ').concat(Object.keys(F.values[j].conditions).map(ee).join(", ")));
          if (typeof j == "object") {
            if (!("conditions" in F.values[Object.keys(F.values)[0]]))
              throw new be('"'.concat(D, '" is not a conditional property'));
            if (Array.isArray(j)) {
              if (!("responsiveArray" in F))
                throw new be('"'.concat(D, '" does not support responsive arrays'));
              var X = F.responsiveArray.length;
              if (X < j.length)
                throw new be('"'.concat(D, '" only supports up to ').concat(X, " breakpoints. You passed ").concat(j.length));
              for (var Z of j)
                F.values[Z] || ie(D, Z, F.values);
            } else
              for (var J in j) {
                var K = j[J];
                if (K != null && (F.values[K] || ie(D, K, F.values), !F.values[K].conditions[J]))
                  throw new be('"'.concat(D, '" has no condition named ').concat(ee(J), ". Possible values are ").concat(Object.keys(F.values[K].conditions).map(ee).join(", ")));
              }
          }
        }
        throw oe;
      }
    };
    for (var D in R)
      var M = I();
    return e(f.join(" "));
  };
  return Object.assign(c, {
    properties: new Set(o)
  });
}, dhe = (e) => e, fhe = function() {
  return uhe(dhe)(...arguments);
};
const J$ = "2.21.8";
let gk = {
  getDocsUrl: ({ docsBaseUrl: e, docsPath: t = "", docsSlug: n }) => t ? `${e ?? "https://viem.sh"}${t}${n ? `#${n}` : ""}` : void 0,
  version: J$
}, it = class l5 extends Error {
  constructor(t, n = {}) {
    var c;
    const r = (() => {
      var u;
      return n.cause instanceof l5 ? n.cause.details : (u = n.cause) != null && u.message ? n.cause.message : n.details;
    })(), i = n.cause instanceof l5 && n.cause.docsPath || n.docsPath, o = (c = gk.getDocsUrl) == null ? void 0 : c.call(gk, { ...n, docsPath: i }), s = [
      t || "An error occurred.",
      "",
      ...n.metaMessages ? [...n.metaMessages, ""] : [],
      ...o ? [`Docs: ${o}`] : [],
      ...r ? [`Details: ${r}`] : [],
      `Version: ${gk.version}`
    ].join(`
`);
    super(s, n.cause ? { cause: n.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseError"
    }), this.details = r, this.docsPath = i, this.metaMessages = n.metaMessages, this.name = n.name ?? this.name, this.shortMessage = t, this.version = J$;
  }
  walk(t) {
    return Z$(this, t);
  }
};
function Z$(e, t) {
  return t != null && t(e) ? e : e && typeof e == "object" && "cause" in e ? Z$(e.cause, t) : t ? null : e;
}
class hhe extends it {
  constructor({ max: t, min: n, signed: r, size: i, value: o }) {
    super(`Number "${o}" is not in safe ${i ? `${i * 8}-bit ${r ? "signed" : "unsigned"} ` : ""}integer range ${t ? `(${n} to ${t})` : `(above ${n})`}`, { name: "IntegerOutOfRangeError" });
  }
}
class phe extends it {
  constructor(t) {
    super(`Bytes value "${t}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`, {
      name: "InvalidBytesBooleanError"
    });
  }
}
class mhe extends it {
  constructor({ givenSize: t, maxSize: n }) {
    super(`Size cannot exceed ${n} bytes. Given size: ${t} bytes.`, { name: "SizeOverflowError" });
  }
}
class eH extends it {
  constructor({ offset: t, position: n, size: r }) {
    super(`Slice ${n === "start" ? "starting" : "ending"} at offset "${t}" is out-of-bounds (size: ${r}).`, { name: "SliceOffsetOutOfBoundsError" });
  }
}
class tH extends it {
  constructor({ size: t, targetSize: n, type: r }) {
    super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (${t}) exceeds padding size (${n}).`, { name: "SizeExceedsPaddingSizeError" });
  }
}
class Jj extends it {
  constructor({ size: t, targetSize: n, type: r }) {
    super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} is expected to be ${n} ${r} long, but is ${t} ${r} long.`, { name: "InvalidBytesLengthError" });
  }
}
function Pb(e, { dir: t, size: n = 32 } = {}) {
  return typeof e == "string" ? Vh(e, { dir: t, size: n }) : yhe(e, { dir: t, size: n });
}
function Vh(e, { dir: t, size: n = 32 } = {}) {
  if (n === null)
    return e;
  const r = e.replace("0x", "");
  if (r.length > n * 2)
    throw new tH({
      size: Math.ceil(r.length / 2),
      targetSize: n,
      type: "hex"
    });
  return `0x${r[t === "right" ? "padEnd" : "padStart"](n * 2, "0")}`;
}
function yhe(e, { dir: t, size: n = 32 } = {}) {
  if (n === null)
    return e;
  if (e.length > n)
    throw new tH({
      size: e.length,
      targetSize: n,
      type: "bytes"
    });
  const r = new Uint8Array(n);
  for (let i = 0; i < n; i++) {
    const o = t === "right";
    r[o ? i : n - i - 1] = e[o ? i : e.length - i - 1];
  }
  return r;
}
function Ql(e, { strict: t = !0 } = {}) {
  return !e || typeof e != "string" ? !1 : t ? /^0x[0-9a-fA-F]*$/.test(e) : e.startsWith("0x");
}
function Ni(e) {
  return Ql(e, { strict: !1 }) ? Math.ceil((e.length - 2) / 2) : e.length;
}
function Fu(e, { dir: t = "left" } = {}) {
  let n = typeof e == "string" ? e.replace("0x", "") : e, r = 0;
  for (let i = 0; i < n.length - 1 && n[t === "left" ? i : n.length - i - 1].toString() === "0"; i++)
    r++;
  return n = t === "left" ? n.slice(r) : n.slice(0, n.length - r), typeof e == "string" ? (n.length === 1 && t === "right" && (n = `${n}0`), `0x${n.length % 2 === 1 ? `0${n}` : n}`) : n;
}
const vhe = /* @__PURE__ */ new TextEncoder();
function qh(e, t = {}) {
  return typeof e == "number" || typeof e == "bigint" ? bhe(e, t) : typeof e == "boolean" ? ghe(e, t) : Ql(e) ? zc(e, t) : zm(e, t);
}
function ghe(e, t = {}) {
  const n = new Uint8Array(1);
  return n[0] = Number(e), typeof t.size == "number" ? (qu(n, { size: t.size }), Pb(n, { size: t.size })) : n;
}
const Pd = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function Zj(e) {
  if (e >= Pd.zero && e <= Pd.nine)
    return e - Pd.zero;
  if (e >= Pd.A && e <= Pd.F)
    return e - (Pd.A - 10);
  if (e >= Pd.a && e <= Pd.f)
    return e - (Pd.a - 10);
}
function zc(e, t = {}) {
  let n = e;
  t.size && (qu(n, { size: t.size }), n = Pb(n, { dir: "right", size: t.size }));
  let r = n.slice(2);
  r.length % 2 && (r = `0${r}`);
  const i = r.length / 2, o = new Uint8Array(i);
  for (let s = 0, c = 0; s < i; s++) {
    const u = Zj(r.charCodeAt(c++)), f = Zj(r.charCodeAt(c++));
    if (u === void 0 || f === void 0)
      throw new it(`Invalid byte sequence ("${r[c - 2]}${r[c - 1]}" in "${r}").`);
    o[s] = u * 16 + f;
  }
  return o;
}
function bhe(e, t) {
  const n = en(e, t);
  return zc(n);
}
function zm(e, t = {}) {
  const n = vhe.encode(e);
  return typeof t.size == "number" ? (qu(n, { size: t.size }), Pb(n, { dir: "right", size: t.size })) : n;
}
function qu(e, { size: t }) {
  if (Ni(e) > t)
    throw new mhe({
      givenSize: Ni(e),
      maxSize: t
    });
}
function Da(e, t = {}) {
  const { signed: n } = t;
  t.size && qu(e, { size: t.size });
  const r = BigInt(e);
  if (!n)
    return r;
  const i = (e.length - 2) / 2, o = (1n << BigInt(i) * 8n - 1n) - 1n;
  return r <= o ? r : r - BigInt(`0x${"f".padStart(i * 2, "f")}`) - 1n;
}
function Uu(e, t = {}) {
  return Number(Da(e, t));
}
const whe = /* @__PURE__ */ Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function yn(e, t = {}) {
  return typeof e == "number" || typeof e == "bigint" ? en(e, t) : typeof e == "string" ? Zg(e, t) : typeof e == "boolean" ? nH(e, t) : lo(e, t);
}
function nH(e, t = {}) {
  const n = `0x${Number(e)}`;
  return typeof t.size == "number" ? (qu(n, { size: t.size }), Pb(n, { size: t.size })) : n;
}
function lo(e, t = {}) {
  let n = "";
  for (let i = 0; i < e.length; i++)
    n += whe[e[i]];
  const r = `0x${n}`;
  return typeof t.size == "number" ? (qu(r, { size: t.size }), Pb(r, { dir: "right", size: t.size })) : r;
}
function en(e, t = {}) {
  const { signed: n, size: r } = t, i = BigInt(e);
  let o;
  r ? n ? o = (1n << BigInt(r) * 8n - 1n) - 1n : o = 2n ** (BigInt(r) * 8n) - 1n : typeof e == "number" && (o = BigInt(Number.MAX_SAFE_INTEGER));
  const s = typeof o == "bigint" && n ? -o - 1n : 0;
  if (o && i > o || i < s) {
    const u = typeof e == "bigint" ? "n" : "";
    throw new hhe({
      max: o ? `${o}${u}` : void 0,
      min: `${s}${u}`,
      signed: n,
      size: r,
      value: `${e}${u}`
    });
  }
  const c = `0x${(n && i < 0 ? (1n << BigInt(r * 8)) + BigInt(i) : i).toString(16)}`;
  return r ? Pb(c, { size: r }) : c;
}
const Che = /* @__PURE__ */ new TextEncoder();
function Zg(e, t = {}) {
  const n = Che.encode(e);
  return lo(n, t);
}
function Xd(e, { includeName: t = !1 } = {}) {
  if (e.type !== "function" && e.type !== "event" && e.type !== "error")
    throw new Phe(e.type);
  return `${e.name}(${R8(e.inputs, { includeName: t })})`;
}
function R8(e, { includeName: t = !1 } = {}) {
  return e ? e.map((n) => xhe(n, { includeName: t })).join(t ? ", " : ",") : "";
}
function xhe(e, { includeName: t }) {
  return e.type.startsWith("tuple") ? `(${R8(e.components, { includeName: t })})${e.type.slice(5)}` : e.type + (t && e.name ? ` ${e.name}` : "");
}
class Ehe extends it {
  constructor({ docsPath: t }) {
    super([
      "A constructor was not found on the ABI.",
      "Make sure you are using the correct ABI and that the constructor exists on it."
    ].join(`
`), {
      docsPath: t,
      name: "AbiConstructorNotFoundError"
    });
  }
}
class eF extends it {
  constructor({ docsPath: t }) {
    super([
      "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
      "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
    ].join(`
`), {
      docsPath: t,
      name: "AbiConstructorParamsNotFoundError"
    });
  }
}
class rH extends it {
  constructor({ data: t, params: n, size: r }) {
    super([`Data size of ${r} bytes is too small for given parameters.`].join(`
`), {
      metaMessages: [
        `Params: (${R8(n, { includeName: !0 })})`,
        `Data:   ${t} (${r} bytes)`
      ],
      name: "AbiDecodingDataSizeTooSmallError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "params", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "size", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = t, this.params = n, this.size = r;
  }
}
class O8 extends it {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.', {
      name: "AbiDecodingZeroDataError"
    });
  }
}
class She extends it {
  constructor({ expectedLength: t, givenLength: n, type: r }) {
    super([
      `ABI encoding array length mismatch for type ${r}.`,
      `Expected length: ${t}`,
      `Given length: ${n}`
    ].join(`
`), { name: "AbiEncodingArrayLengthMismatchError" });
  }
}
class khe extends it {
  constructor({ expectedSize: t, value: n }) {
    super(`Size of bytes "${n}" (bytes${Ni(n)}) does not match expected size (bytes${t}).`, { name: "AbiEncodingBytesSizeMismatchError" });
  }
}
class Ahe extends it {
  constructor({ expectedLength: t, givenLength: n }) {
    super([
      "ABI encoding params/values length mismatch.",
      `Expected length (params): ${t}`,
      `Given length (values): ${n}`
    ].join(`
`), { name: "AbiEncodingLengthMismatchError" });
  }
}
class iH extends it {
  constructor(t, { docsPath: n }) {
    super([
      `Encoded error signature "${t}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${t}.`
    ].join(`
`), {
      docsPath: n,
      name: "AbiErrorSignatureNotFoundError"
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.signature = t;
  }
}
class The extends it {
  constructor({ docsPath: t }) {
    super("Cannot extract event signature from empty topics.", {
      docsPath: t,
      name: "AbiEventSignatureEmptyTopicsError"
    });
  }
}
class oH extends it {
  constructor(t, { docsPath: n }) {
    super([
      `Encoded event signature "${t}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the event exists on it.",
      `You can look up the signature here: https://openchain.xyz/signatures?query=${t}.`
    ].join(`
`), {
      docsPath: n,
      name: "AbiEventSignatureNotFoundError"
    });
  }
}
class tF extends it {
  constructor(t, { docsPath: n } = {}) {
    super([
      `Event ${t ? `"${t}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the event exists on it."
    ].join(`
`), {
      docsPath: n,
      name: "AbiEventNotFoundError"
    });
  }
}
class M4 extends it {
  constructor(t, { docsPath: n } = {}) {
    super([
      `Function ${t ? `"${t}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join(`
`), {
      docsPath: n,
      name: "AbiFunctionNotFoundError"
    });
  }
}
class _he extends it {
  constructor(t, { docsPath: n }) {
    super([
      `Function "${t}" does not contain any \`outputs\` on ABI.`,
      "Cannot decode function result without knowing what the parameter types are.",
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join(`
`), {
      docsPath: n,
      name: "AbiFunctionOutputsNotFoundError"
    });
  }
}
class Rhe extends it {
  constructor(t, n) {
    super("Found ambiguous types in overloaded ABI items.", {
      metaMessages: [
        `\`${t.type}\` in \`${Xd(t.abiItem)}\`, and`,
        `\`${n.type}\` in \`${Xd(n.abiItem)}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ],
      name: "AbiItemAmbiguityError"
    });
  }
}
class Ohe extends it {
  constructor({ expectedSize: t, givenSize: n }) {
    super(`Expected bytes${t}, got bytes${n}.`, {
      name: "BytesSizeMismatchError"
    });
  }
}
class $1 extends it {
  constructor({ abiItem: t, data: n, params: r, size: i }) {
    super([
      `Data size of ${i} bytes is too small for non-indexed event parameters.`
    ].join(`
`), {
      metaMessages: [
        `Params: (${R8(r, { includeName: !0 })})`,
        `Data:   ${n} (${i} bytes)`
      ],
      name: "DecodeLogDataMismatch"
    }), Object.defineProperty(this, "abiItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "params", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "size", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.abiItem = t, this.data = n, this.params = r, this.size = i;
  }
}
class I8 extends it {
  constructor({ abiItem: t, param: n }) {
    super([
      `Expected a topic for indexed event parameter${n.name ? ` "${n.name}"` : ""} on event "${Xd(t, { includeName: !0 })}".`
    ].join(`
`), { name: "DecodeLogTopicsMismatch" }), Object.defineProperty(this, "abiItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.abiItem = t;
  }
}
class Ihe extends it {
  constructor(t, { docsPath: n }) {
    super([
      `Type "${t}" is not a valid encoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: n, name: "InvalidAbiEncodingType" });
  }
}
class Dhe extends it {
  constructor(t, { docsPath: n }) {
    super([
      `Type "${t}" is not a valid decoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: n, name: "InvalidAbiDecodingType" });
  }
}
class Mhe extends it {
  constructor(t) {
    super([`Value "${t}" is not a valid array.`].join(`
`), {
      name: "InvalidArrayError"
    });
  }
}
class Phe extends it {
  constructor(t) {
    super([
      `"${t}" is not a valid definition type.`,
      'Valid types: "function", "event", "error"'
    ].join(`
`), { name: "InvalidDefinitionTypeError" });
  }
}
function Jd(e) {
  return typeof e[0] == "string" ? Wc(e) : Nhe(e);
}
function Nhe(e) {
  let t = 0;
  for (const i of e)
    t += i.length;
  const n = new Uint8Array(t);
  let r = 0;
  for (const i of e)
    n.set(i, r), r += i.length;
  return n;
}
function Wc(e) {
  return `0x${e.reduce((t, n) => t + n.replace("0x", ""), "")}`;
}
class Ba extends it {
  constructor({ address: t }) {
    super(`Address "${t}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart."
      ],
      name: "InvalidAddressError"
    });
  }
}
class hM extends Map {
  constructor(t) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSize = t;
  }
  get(t) {
    const n = super.get(t);
    return super.has(t) && n !== void 0 && (this.delete(t), super.set(t, n)), n;
  }
  set(t, n) {
    if (super.set(t, n), this.maxSize && this.size > this.maxSize) {
      const r = this.keys().next().value;
      r && this.delete(r);
    }
    return this;
  }
}
function P4(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`positive integer expected, not ${e}`);
}
function Bhe(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
function LC(e, ...t) {
  if (!Bhe(e))
    throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`);
}
function Lhe(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  P4(e.outputLen), P4(e.blockLen);
}
function eb(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function aH(e, t) {
  LC(e);
  const n = t.outputLen;
  if (e.length < n)
    throw new Error(`digestInto() expects output buffer of length at least ${n}`);
}
const bk = /* @__PURE__ */ BigInt(2 ** 32 - 1), nF = /* @__PURE__ */ BigInt(32);
function jhe(e, t = !1) {
  return t ? { h: Number(e & bk), l: Number(e >> nF & bk) } : { h: Number(e >> nF & bk) | 0, l: Number(e & bk) | 0 };
}
function Fhe(e, t = !1) {
  let n = new Uint32Array(e.length), r = new Uint32Array(e.length);
  for (let i = 0; i < e.length; i++) {
    const { h: o, l: s } = jhe(e[i], t);
    [n[i], r[i]] = [o, s];
  }
  return [n, r];
}
const Uhe = (e, t, n) => e << n | t >>> 32 - n, zhe = (e, t, n) => t << n | e >>> 32 - n, Vhe = (e, t, n) => t << n - 32 | e >>> 64 - n, $he = (e, t, n) => e << n - 32 | t >>> 64 - n, KR = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Hhe = (e) => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)), YR = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength), Au = (e, t) => e << 32 - t | e >>> t, rF = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, qhe = (e) => e << 24 & 4278190080 | e << 8 & 16711680 | e >>> 8 & 65280 | e >>> 24 & 255;
function iF(e) {
  for (let t = 0; t < e.length; t++)
    e[t] = qhe(e[t]);
}
function Whe(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function D8(e) {
  return typeof e == "string" && (e = Whe(e)), LC(e), e;
}
function Ghe(...e) {
  let t = 0;
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    LC(i), t += i.length;
  }
  const n = new Uint8Array(t);
  for (let r = 0, i = 0; r < e.length; r++) {
    const o = e[r];
    n.set(o, i), i += o.length;
  }
  return n;
}
class pM {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function sH(e) {
  const t = (r) => e().update(D8(r)).digest(), n = e();
  return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = () => e(), t;
}
function Khe(e = 32) {
  if (KR && typeof KR.getRandomValues == "function")
    return KR.getRandomValues(new Uint8Array(e));
  throw new Error("crypto.getRandomValues must be defined");
}
const lH = [], cH = [], uH = [], Yhe = /* @__PURE__ */ BigInt(0), a1 = /* @__PURE__ */ BigInt(1), Qhe = /* @__PURE__ */ BigInt(2), Xhe = /* @__PURE__ */ BigInt(7), Jhe = /* @__PURE__ */ BigInt(256), Zhe = /* @__PURE__ */ BigInt(113);
for (let e = 0, t = a1, n = 1, r = 0; e < 24; e++) {
  [n, r] = [r, (2 * n + 3 * r) % 5], lH.push(2 * (5 * r + n)), cH.push((e + 1) * (e + 2) / 2 % 64);
  let i = Yhe;
  for (let o = 0; o < 7; o++)
    t = (t << a1 ^ (t >> Xhe) * Zhe) % Jhe, t & Qhe && (i ^= a1 << (a1 << /* @__PURE__ */ BigInt(o)) - a1);
  uH.push(i);
}
const [epe, tpe] = /* @__PURE__ */ Fhe(uH, !0), oF = (e, t, n) => n > 32 ? Vhe(e, t, n) : Uhe(e, t, n), aF = (e, t, n) => n > 32 ? $he(e, t, n) : zhe(e, t, n);
function npe(e, t = 24) {
  const n = new Uint32Array(10);
  for (let r = 24 - t; r < 24; r++) {
    for (let s = 0; s < 10; s++)
      n[s] = e[s] ^ e[s + 10] ^ e[s + 20] ^ e[s + 30] ^ e[s + 40];
    for (let s = 0; s < 10; s += 2) {
      const c = (s + 8) % 10, u = (s + 2) % 10, f = n[u], p = n[u + 1], y = oF(f, p, 1) ^ n[c], v = aF(f, p, 1) ^ n[c + 1];
      for (let w = 0; w < 50; w += 10)
        e[s + w] ^= y, e[s + w + 1] ^= v;
    }
    let i = e[2], o = e[3];
    for (let s = 0; s < 24; s++) {
      const c = cH[s], u = oF(i, o, c), f = aF(i, o, c), p = lH[s];
      i = e[p], o = e[p + 1], e[p] = u, e[p + 1] = f;
    }
    for (let s = 0; s < 50; s += 10) {
      for (let c = 0; c < 10; c++)
        n[c] = e[s + c];
      for (let c = 0; c < 10; c++)
        e[s + c] ^= ~n[(c + 2) % 10] & n[(c + 4) % 10];
    }
    e[0] ^= epe[r], e[1] ^= tpe[r];
  }
  n.fill(0);
}
class mM extends pM {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(t, n, r, i = !1, o = 24) {
    if (super(), this.blockLen = t, this.suffix = n, this.outputLen = r, this.enableXOF = i, this.rounds = o, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, P4(r), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = Hhe(this.state);
  }
  keccak() {
    rF || iF(this.state32), npe(this.state32, this.rounds), rF || iF(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(t) {
    eb(this);
    const { blockLen: n, state: r } = this;
    t = D8(t);
    const i = t.length;
    for (let o = 0; o < i; ) {
      const s = Math.min(n - this.pos, i - o);
      for (let c = 0; c < s; c++)
        r[this.pos++] ^= t[o++];
      this.pos === n && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: t, suffix: n, pos: r, blockLen: i } = this;
    t[r] ^= n, n & 128 && r === i - 1 && this.keccak(), t[i - 1] ^= 128, this.keccak();
  }
  writeInto(t) {
    eb(this, !1), LC(t), this.finish();
    const n = this.state, { blockLen: r } = this;
    for (let i = 0, o = t.length; i < o; ) {
      this.posOut >= r && this.keccak();
      const s = Math.min(r - this.posOut, o - i);
      t.set(n.subarray(this.posOut, this.posOut + s), i), this.posOut += s, i += s;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return P4(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (aH(t, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: n, suffix: r, outputLen: i, rounds: o, enableXOF: s } = this;
    return t || (t = new mM(n, r, i, s, o)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = o, t.suffix = r, t.outputLen = i, t.enableXOF = s, t.destroyed = this.destroyed, t;
  }
}
const rpe = (e, t, n) => sH(() => new mM(t, e, n)), ipe = /* @__PURE__ */ rpe(1, 136, 256 / 8);
function zo(e, t) {
  const n = t || "hex", r = ipe(Ql(e, { strict: !1 }) ? qh(e) : e);
  return n === "bytes" ? r : yn(r);
}
const QR = /* @__PURE__ */ new hM(8192);
function M8(e, t) {
  if (QR.has(`${e}.${t}`))
    return QR.get(`${e}.${t}`);
  const n = t ? `${t}${e.toLowerCase()}` : e.substring(2).toLowerCase(), r = zo(zm(n), "bytes"), i = (t ? n.substring(`${t}0x`.length) : n).split("");
  for (let s = 0; s < 40; s += 2)
    r[s >> 1] >> 4 >= 8 && i[s] && (i[s] = i[s].toUpperCase()), (r[s >> 1] & 15) >= 8 && i[s + 1] && (i[s + 1] = i[s + 1].toUpperCase());
  const o = `0x${i.join("")}`;
  return QR.set(`${e}.${t}`, o), o;
}
function Ma(e, t) {
  if (!co(e, { strict: !1 }))
    throw new Ba({ address: e });
  return M8(e, t);
}
const ope = /^0x[a-fA-F0-9]{40}$/, XR = /* @__PURE__ */ new hM(8192);
function co(e, t) {
  const { strict: n = !0 } = t ?? {}, r = `${e}.${n}`;
  if (XR.has(r))
    return XR.get(r);
  const i = ope.test(e) ? e.toLowerCase() === e ? !0 : n ? M8(e) === e : !0 : !1;
  return XR.set(r, i), i;
}
function H1(e, t, n, { strict: r } = {}) {
  return Ql(e, { strict: !1 }) ? pH(e, t, n, {
    strict: r
  }) : hH(e, t, n, {
    strict: r
  });
}
function dH(e, t) {
  if (typeof t == "number" && t > 0 && t > Ni(e) - 1)
    throw new eH({
      offset: t,
      position: "start",
      size: Ni(e)
    });
}
function fH(e, t, n) {
  if (typeof t == "number" && typeof n == "number" && Ni(e) !== n - t)
    throw new eH({
      offset: n,
      position: "end",
      size: Ni(e)
    });
}
function hH(e, t, n, { strict: r } = {}) {
  dH(e, t);
  const i = e.slice(t, n);
  return r && fH(i, t, n), i;
}
function pH(e, t, n, { strict: r } = {}) {
  dH(e, t);
  const i = `0x${e.replace("0x", "").slice((t ?? 0) * 2, (n ?? e.length) * 2)}`;
  return r && fH(i, t, n), i;
}
function Nb(e, t) {
  if (e.length !== t.length)
    throw new Ahe({
      expectedLength: e.length,
      givenLength: t.length
    });
  const n = ape({
    params: e,
    values: t
  }), r = vM(n);
  return r.length === 0 ? "0x" : r;
}
function ape({ params: e, values: t }) {
  const n = [];
  for (let r = 0; r < e.length; r++)
    n.push(yM({ param: e[r], value: t[r] }));
  return n;
}
function yM({ param: e, value: t }) {
  const n = gM(e.type);
  if (n) {
    const [r, i] = n;
    return lpe(t, { length: r, param: { ...e, type: i } });
  }
  if (e.type === "tuple")
    return hpe(t, {
      param: e
    });
  if (e.type === "address")
    return spe(t);
  if (e.type === "bool")
    return upe(t);
  if (e.type.startsWith("uint") || e.type.startsWith("int")) {
    const r = e.type.startsWith("int");
    return dpe(t, { signed: r });
  }
  if (e.type.startsWith("bytes"))
    return cpe(t, { param: e });
  if (e.type === "string")
    return fpe(t);
  throw new Ihe(e.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  });
}
function vM(e) {
  let t = 0;
  for (let o = 0; o < e.length; o++) {
    const { dynamic: s, encoded: c } = e[o];
    s ? t += 32 : t += Ni(c);
  }
  const n = [], r = [];
  let i = 0;
  for (let o = 0; o < e.length; o++) {
    const { dynamic: s, encoded: c } = e[o];
    s ? (n.push(en(t + i, { size: 32 })), r.push(c), i += Ni(c)) : n.push(c);
  }
  return Jd([...n, ...r]);
}
function spe(e) {
  if (!co(e))
    throw new Ba({ address: e });
  return { dynamic: !1, encoded: Vh(e.toLowerCase()) };
}
function lpe(e, { length: t, param: n }) {
  const r = t === null;
  if (!Array.isArray(e))
    throw new Mhe(e);
  if (!r && e.length !== t)
    throw new She({
      expectedLength: t,
      givenLength: e.length,
      type: `${n.type}[${t}]`
    });
  let i = !1;
  const o = [];
  for (let s = 0; s < e.length; s++) {
    const c = yM({ param: n, value: e[s] });
    c.dynamic && (i = !0), o.push(c);
  }
  if (r || i) {
    const s = vM(o);
    if (r) {
      const c = en(o.length, { size: 32 });
      return {
        dynamic: !0,
        encoded: o.length > 0 ? Jd([c, s]) : c
      };
    }
    if (i)
      return { dynamic: !0, encoded: s };
  }
  return {
    dynamic: !1,
    encoded: Jd(o.map(({ encoded: s }) => s))
  };
}
function cpe(e, { param: t }) {
  const [, n] = t.type.split("bytes"), r = Ni(e);
  if (!n) {
    let i = e;
    return r % 32 !== 0 && (i = Vh(i, {
      dir: "right",
      size: Math.ceil((e.length - 2) / 2 / 32) * 32
    })), {
      dynamic: !0,
      encoded: Jd([Vh(en(r, { size: 32 })), i])
    };
  }
  if (r !== Number.parseInt(n))
    throw new khe({
      expectedSize: Number.parseInt(n),
      value: e
    });
  return { dynamic: !1, encoded: Vh(e, { dir: "right" }) };
}
function upe(e) {
  if (typeof e != "boolean")
    throw new it(`Invalid boolean value: "${e}" (type: ${typeof e}). Expected: \`true\` or \`false\`.`);
  return { dynamic: !1, encoded: Vh(nH(e)) };
}
function dpe(e, { signed: t }) {
  return {
    dynamic: !1,
    encoded: en(e, {
      size: 32,
      signed: t
    })
  };
}
function fpe(e) {
  const t = Zg(e), n = Math.ceil(Ni(t) / 32), r = [];
  for (let i = 0; i < n; i++)
    r.push(Vh(H1(t, i * 32, (i + 1) * 32), {
      dir: "right"
    }));
  return {
    dynamic: !0,
    encoded: Jd([
      Vh(en(Ni(t), { size: 32 })),
      ...r
    ])
  };
}
function hpe(e, { param: t }) {
  let n = !1;
  const r = [];
  for (let i = 0; i < t.components.length; i++) {
    const o = t.components[i], s = Array.isArray(e) ? i : o.name, c = yM({
      param: o,
      value: e[s]
    });
    r.push(c), c.dynamic && (n = !0);
  }
  return {
    dynamic: n,
    encoded: n ? vM(r) : Jd(r.map(({ encoded: i }) => i))
  };
}
function gM(e) {
  const t = e.match(/^(.*)\[(\d+)?\]$/);
  return t ? (
    // Return `null` if the array is dynamic.
    [t[2] ? Number(t[2]) : null, t[1]]
  ) : void 0;
}
const JR = "/docs/contract/encodeDeployData";
function bM(e) {
  const { abi: t, args: n, bytecode: r } = e;
  if (!n || n.length === 0)
    return r;
  const i = t.find((s) => "type" in s && s.type === "constructor");
  if (!i)
    throw new Ehe({ docsPath: JR });
  if (!("inputs" in i))
    throw new eF({ docsPath: JR });
  if (!i.inputs || i.inputs.length === 0)
    throw new eF({ docsPath: JR });
  const o = Nb(i.inputs, n);
  return Wc([r, o]);
}
function nc(e) {
  return typeof e == "string" ? { address: e, type: "json-rpc" } : e;
}
class wM extends it {
  constructor({ docsPath: t } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."
    ].join(`
`), {
      docsPath: t,
      docsSlug: "account",
      name: "AccountNotFoundError"
    });
  }
}
class ZR extends it {
  constructor({ docsPath: t, metaMessages: n, type: r }) {
    super(`Account type "${r}" is not supported.`, {
      docsPath: t,
      metaMessages: n,
      name: "AccountTypeNotSupportedError"
    });
  }
}
function ppe(e) {
  const t = zo(`0x${e.substring(4)}`).substring(26);
  return M8(`0x${t}`);
}
async function mpe({ hash: e, signature: t }) {
  const n = Ql(e) ? e : yn(e), { secp256k1: r } = await Promise.resolve().then(() => kge);
  return `0x${(() => {
    if (typeof t == "object" && "r" in t && "s" in t) {
      const { r: f, s: p, v: y, yParity: v } = t, w = Number(v ?? y), C = sF(w);
      return new r.Signature(Da(f), Da(p)).addRecoveryBit(C);
    }
    const s = Ql(t) ? t : yn(t), c = Uu(`0x${s.slice(130)}`), u = sF(c);
    return r.Signature.fromCompact(s.substring(2, 130)).addRecoveryBit(u);
  })().recoverPublicKey(n.substring(2)).toHex(!1)}`;
}
function sF(e) {
  if (e === 0 || e === 1)
    return e;
  if (e === 27)
    return 0;
  if (e === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}
async function mH({ hash: e, signature: t }) {
  return ppe(await mpe({ hash: e, signature: t }));
}
class lF extends it {
  constructor({ offset: t }) {
    super(`Offset \`${t}\` cannot be negative.`, {
      name: "NegativeOffsetError"
    });
  }
}
class yH extends it {
  constructor({ length: t, position: n }) {
    super(`Position \`${n}\` is out of bounds (\`0 < position < ${t}\`).`, { name: "PositionOutOfBoundsError" });
  }
}
class ype extends it {
  constructor({ count: t, limit: n }) {
    super(`Recursive read limit of \`${n}\` exceeded (recursive read count: \`${t}\`).`, { name: "RecursiveReadLimitExceededError" });
  }
}
const vpe = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new ype({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(e) {
    if (e < 0 || e > this.bytes.length - 1)
      throw new yH({
        length: this.bytes.length,
        position: e
      });
  },
  decrementPosition(e) {
    if (e < 0)
      throw new lF({ offset: e });
    const t = this.position - e;
    this.assertPosition(t), this.position = t;
  },
  getReadCount(e) {
    return this.positionReadCount.get(e || this.position) || 0;
  },
  incrementPosition(e) {
    if (e < 0)
      throw new lF({ offset: e });
    const t = this.position + e;
    this.assertPosition(t), this.position = t;
  },
  inspectByte(e) {
    const t = e ?? this.position;
    return this.assertPosition(t), this.bytes[t];
  },
  inspectBytes(e, t) {
    const n = t ?? this.position;
    return this.assertPosition(n + e - 1), this.bytes.subarray(n, n + e);
  },
  inspectUint8(e) {
    const t = e ?? this.position;
    return this.assertPosition(t), this.bytes[t];
  },
  inspectUint16(e) {
    const t = e ?? this.position;
    return this.assertPosition(t + 1), this.dataView.getUint16(t);
  },
  inspectUint24(e) {
    const t = e ?? this.position;
    return this.assertPosition(t + 2), (this.dataView.getUint16(t) << 8) + this.dataView.getUint8(t + 2);
  },
  inspectUint32(e) {
    const t = e ?? this.position;
    return this.assertPosition(t + 3), this.dataView.getUint32(t);
  },
  pushByte(e) {
    this.assertPosition(this.position), this.bytes[this.position] = e, this.position++;
  },
  pushBytes(e) {
    this.assertPosition(this.position + e.length - 1), this.bytes.set(e, this.position), this.position += e.length;
  },
  pushUint8(e) {
    this.assertPosition(this.position), this.bytes[this.position] = e, this.position++;
  },
  pushUint16(e) {
    this.assertPosition(this.position + 1), this.dataView.setUint16(this.position, e), this.position += 2;
  },
  pushUint24(e) {
    this.assertPosition(this.position + 2), this.dataView.setUint16(this.position, e >> 8), this.dataView.setUint8(this.position + 2, e & 255), this.position += 3;
  },
  pushUint32(e) {
    this.assertPosition(this.position + 3), this.dataView.setUint32(this.position, e), this.position += 4;
  },
  readByte() {
    this.assertReadLimit(), this._touch();
    const e = this.inspectByte();
    return this.position++, e;
  },
  readBytes(e, t) {
    this.assertReadLimit(), this._touch();
    const n = this.inspectBytes(e);
    return this.position += t ?? e, n;
  },
  readUint8() {
    this.assertReadLimit(), this._touch();
    const e = this.inspectUint8();
    return this.position += 1, e;
  },
  readUint16() {
    this.assertReadLimit(), this._touch();
    const e = this.inspectUint16();
    return this.position += 2, e;
  },
  readUint24() {
    this.assertReadLimit(), this._touch();
    const e = this.inspectUint24();
    return this.position += 3, e;
  },
  readUint32() {
    this.assertReadLimit(), this._touch();
    const e = this.inspectUint32();
    return this.position += 4, e;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(e) {
    const t = this.position;
    return this.assertPosition(e), this.position = e, () => this.position = t;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const e = this.getReadCount();
    this.positionReadCount.set(this.position, e + 1), e > 0 && this.recursiveReadCount++;
  }
};
function CM(e, { recursiveReadLimit: t = 8192 } = {}) {
  const n = Object.create(vpe);
  return n.bytes = e, n.dataView = new DataView(e.buffer, e.byteOffset, e.byteLength), n.positionReadCount = /* @__PURE__ */ new Map(), n.recursiveReadLimit = t, n;
}
function Zd(e, t = "hex") {
  const n = vH(e), r = CM(new Uint8Array(n.length));
  return n.encode(r), t === "hex" ? lo(r.bytes) : r.bytes;
}
function vH(e) {
  return Array.isArray(e) ? gpe(e.map((t) => vH(t))) : bpe(e);
}
function gpe(e) {
  const t = e.reduce((i, o) => i + o.length, 0), n = gH(t);
  return {
    length: t <= 55 ? 1 + t : 1 + n + t,
    encode(i) {
      t <= 55 ? i.pushByte(192 + t) : (i.pushByte(247 + n), n === 1 ? i.pushUint8(t) : n === 2 ? i.pushUint16(t) : n === 3 ? i.pushUint24(t) : i.pushUint32(t));
      for (const { encode: o } of e)
        o(i);
    }
  };
}
function bpe(e) {
  const t = typeof e == "string" ? zc(e) : e, n = gH(t.length);
  return {
    length: t.length === 1 && t[0] < 128 ? 1 : t.length <= 55 ? 1 + t.length : 1 + n + t.length,
    encode(i) {
      t.length === 1 && t[0] < 128 ? i.pushBytes(t) : t.length <= 55 ? (i.pushByte(128 + t.length), i.pushBytes(t)) : (i.pushByte(183 + n), n === 1 ? i.pushUint8(t.length) : n === 2 ? i.pushUint16(t.length) : n === 3 ? i.pushUint24(t.length) : i.pushUint32(t.length), i.pushBytes(t));
    }
  };
}
function gH(e) {
  if (e < 2 ** 8)
    return 1;
  if (e < 2 ** 16)
    return 2;
  if (e < 2 ** 24)
    return 3;
  if (e < 2 ** 32)
    return 4;
  throw new it("Length is too large.");
}
function wpe(e) {
  const { chainId: t, contractAddress: n, nonce: r, to: i } = e, o = zo(Wc([
    "0x05",
    Zd([
      en(t),
      n,
      r ? en(r) : "0x"
    ])
  ]));
  return i === "bytes" ? zc(o) : o;
}
async function bH(e) {
  const { authorization: t, signature: n } = e;
  return mH({
    hash: wpe(t),
    signature: n ?? t
  });
}
class c5 extends it {
  constructor({ blockNumber: t, chain: n, contract: r }) {
    super(`Chain "${n.name}" does not support contract "${r.name}".`, {
      metaMessages: [
        "This could be due to any of the following:",
        ...t && r.blockCreated && r.blockCreated > t ? [
          `- The contract "${r.name}" was not deployed until block ${r.blockCreated} (current block ${t}).`
        ] : [
          `- The chain does not have the contract "${r.name}" configured.`
        ]
      ],
      name: "ChainDoesNotSupportContract"
    });
  }
}
class Cpe extends it {
  constructor({ chain: t, currentChainId: n }) {
    super(`The current chain of the wallet (id: ${n}) does not match the target chain for the transaction (id: ${t.id}  ${t.name}).`, {
      metaMessages: [
        `Current Chain ID:  ${n}`,
        `Expected Chain ID: ${t.id}  ${t.name}`
      ],
      name: "ChainMismatchError"
    });
  }
}
class xpe extends it {
  constructor() {
    super([
      "No chain was provided to the request.",
      "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
    ].join(`
`), {
      name: "ChainNotFoundError"
    });
  }
}
class wH extends it {
  constructor() {
    super("No chain was provided to the Client.", {
      name: "ClientChainNotConfiguredError"
    });
  }
}
class jC extends it {
  constructor({ chainId: t }) {
    super(typeof t == "number" ? `Chain ID "${t}" is invalid.` : "Chain ID is invalid.", { name: "InvalidChainIdError" });
  }
}
function Epe({ chain: e, currentChainId: t }) {
  if (!e)
    throw new xpe();
  if (t !== e.id)
    throw new Cpe({ chain: e, currentChainId: t });
}
const Spe = {
  gwei: 9,
  wei: 18
}, kpe = {
  ether: -9,
  wei: 9
};
function CH(e, t) {
  let n = e.toString();
  const r = n.startsWith("-");
  r && (n = n.slice(1)), n = n.padStart(t, "0");
  let [i, o] = [
    n.slice(0, n.length - t),
    n.slice(n.length - t)
  ];
  return o = o.replace(/(0+)$/, ""), `${r ? "-" : ""}${i || "0"}${o ? `.${o}` : ""}`;
}
function Hs(e, t = "wei") {
  return CH(e, kpe[t]);
}
class bg extends it {
  constructor({ cause: t, message: n } = {}) {
    var i;
    const r = (i = n == null ? void 0 : n.replace("execution reverted: ", "")) == null ? void 0 : i.replace("execution reverted", "");
    super(`Execution reverted ${r ? `with reason: ${r}` : "for an unknown reason"}.`, {
      cause: t,
      name: "ExecutionRevertedError"
    });
  }
}
Object.defineProperty(bg, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 3
});
Object.defineProperty(bg, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /execution reverted/
});
class Wh extends it {
  constructor({ cause: t, maxFeePerGas: n } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${n ? ` = ${Hs(n)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause: t,
      name: "FeeCapTooHighError"
    });
  }
}
Object.defineProperty(Wh, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class u5 extends it {
  constructor({ cause: t, maxFeePerGas: n } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${n ? ` = ${Hs(n)}` : ""} gwei) cannot be lower than the block base fee.`, {
      cause: t,
      name: "FeeCapTooLowError"
    });
  }
}
Object.defineProperty(u5, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
class d5 extends it {
  constructor({ cause: t, nonce: n } = {}) {
    super(`Nonce provided for the transaction ${n ? `(${n}) ` : ""}is higher than the next one expected.`, { cause: t, name: "NonceTooHighError" });
  }
}
Object.defineProperty(d5, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too high/
});
class f5 extends it {
  constructor({ cause: t, nonce: n } = {}) {
    super([
      `Nonce provided for the transaction ${n ? `(${n}) ` : ""}is lower than the current nonce of the account.`,
      "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
    ].join(`
`), { cause: t, name: "NonceTooLowError" });
  }
}
Object.defineProperty(f5, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too low|transaction already imported|already known/
});
class h5 extends it {
  constructor({ cause: t, nonce: n } = {}) {
    super(`Nonce provided for the transaction ${n ? `(${n}) ` : ""}exceeds the maximum allowed nonce.`, { cause: t, name: "NonceMaxValueError" });
  }
}
Object.defineProperty(h5, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce has max value/
});
class p5 extends it {
  constructor({ cause: t } = {}) {
    super([
      "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
    ].join(`
`), {
      cause: t,
      metaMessages: [
        "This error could arise when the account does not have enough funds to:",
        " - pay for the total gas fee,",
        " - pay for the value to send.",
        " ",
        "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
        " - `gas` is the amount of gas needed for transaction to execute,",
        " - `gas fee` is the gas fee,",
        " - `value` is the amount of ether to send to the recipient."
      ],
      name: "InsufficientFundsError"
    });
  }
}
Object.defineProperty(p5, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /insufficient funds|exceeds transaction sender account balance/
});
class m5 extends it {
  constructor({ cause: t, gas: n } = {}) {
    super(`The amount of gas ${n ? `(${n}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
      cause: t,
      name: "IntrinsicGasTooHighError"
    });
  }
}
Object.defineProperty(m5, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too high|gas limit reached/
});
class y5 extends it {
  constructor({ cause: t, gas: n } = {}) {
    super(`The amount of gas ${n ? `(${n}) ` : ""}provided for the transaction is too low.`, {
      cause: t,
      name: "IntrinsicGasTooLowError"
    });
  }
}
Object.defineProperty(y5, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too low/
});
class v5 extends it {
  constructor({ cause: t }) {
    super("The transaction type is not supported for this chain.", {
      cause: t,
      name: "TransactionTypeNotSupportedError"
    });
  }
}
Object.defineProperty(v5, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /transaction type not valid/
});
class tb extends it {
  constructor({ cause: t, maxPriorityFeePerGas: n, maxFeePerGas: r } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${n ? ` = ${Hs(n)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${r ? ` = ${Hs(r)} gwei` : ""}).`
    ].join(`
`), {
      cause: t,
      name: "TipAboveFeeCapError"
    });
  }
}
Object.defineProperty(tb, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
class P8 extends it {
  constructor({ cause: t }) {
    super(`An error occurred while executing: ${t == null ? void 0 : t.shortMessage}`, {
      cause: t,
      name: "UnknownNodeError"
    });
  }
}
function xM(e, t = "wei") {
  return CH(e, Spe[t]);
}
function FC(e) {
  const t = Object.entries(e).map(([r, i]) => i === void 0 || i === !1 ? null : [r, i]).filter(Boolean), n = t.reduce((r, [i]) => Math.max(r, i.length), 0);
  return t.map(([r, i]) => `  ${`${r}:`.padEnd(n + 1)}  ${i}`).join(`
`);
}
class Ape extends it {
  constructor() {
    super([
      "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
      "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
    ].join(`
`), { name: "FeeConflictError" });
  }
}
class Tpe extends it {
  constructor({ v: t }) {
    super(`Invalid \`v\` value "${t}". Expected 27 or 28.`, {
      name: "InvalidLegacyVError"
    });
  }
}
class _pe extends it {
  constructor({ transaction: t }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        FC(t),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
        "- an EIP-7702 Transaction with `authorizationList`, or",
        "- a Legacy Transaction with `gasPrice`"
      ],
      name: "InvalidSerializableTransactionError"
    });
  }
}
class Rpe extends it {
  constructor({ storageKey: t }) {
    super(`Size for storage key "${t}" is invalid. Expected 32 bytes. Got ${Math.floor((t.length - 2) / 2)} bytes.`, { name: "InvalidStorageKeySizeError" });
  }
}
class Ope extends it {
  constructor(t, { account: n, docsPath: r, chain: i, data: o, gas: s, gasPrice: c, maxFeePerGas: u, maxPriorityFeePerGas: f, nonce: p, to: y, value: v }) {
    var C;
    const w = FC({
      chain: i && `${i == null ? void 0 : i.name} (id: ${i == null ? void 0 : i.id})`,
      from: n == null ? void 0 : n.address,
      to: y,
      value: typeof v < "u" && `${xM(v)} ${((C = i == null ? void 0 : i.nativeCurrency) == null ? void 0 : C.symbol) || "ETH"}`,
      data: o,
      gas: s,
      gasPrice: typeof c < "u" && `${Hs(c)} gwei`,
      maxFeePerGas: typeof u < "u" && `${Hs(u)} gwei`,
      maxPriorityFeePerGas: typeof f < "u" && `${Hs(f)} gwei`,
      nonce: p
    });
    super(t.shortMessage, {
      cause: t,
      docsPath: r,
      metaMessages: [
        ...t.metaMessages ? [...t.metaMessages, " "] : [],
        "Request Arguments:",
        w
      ].filter(Boolean),
      name: "TransactionExecutionError"
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cause = t;
  }
}
class xH extends it {
  constructor({ blockHash: t, blockNumber: n, blockTag: r, hash: i, index: o }) {
    let s = "Transaction";
    r && o !== void 0 && (s = `Transaction at block time "${r}" at index "${o}"`), t && o !== void 0 && (s = `Transaction at block hash "${t}" at index "${o}"`), n && o !== void 0 && (s = `Transaction at block number "${n}" at index "${o}"`), i && (s = `Transaction with hash "${i}"`), super(`${s} could not be found.`, {
      name: "TransactionNotFoundError"
    });
  }
}
class EH extends it {
  constructor({ hash: t }) {
    super(`Transaction receipt with hash "${t}" could not be found. The Transaction may not be processed on a block yet.`, {
      name: "TransactionReceiptNotFoundError"
    });
  }
}
class cF extends it {
  constructor({ hash: t }) {
    super(`Timed out while waiting for transaction with hash "${t}" to be confirmed.`, { name: "WaitForTransactionReceiptTimeoutError" });
  }
}
const Pa = (e, t, n) => JSON.stringify(e, (r, i) => typeof i == "bigint" ? i.toString() : i, n), Ipe = (e) => e, EM = (e) => e;
class M1 extends it {
  constructor({ body: t, cause: n, details: r, headers: i, status: o, url: s }) {
    super("HTTP request failed.", {
      cause: n,
      details: r,
      metaMessages: [
        o && `Status: ${o}`,
        `URL: ${EM(s)}`,
        t && `Request body: ${Pa(t)}`
      ].filter(Boolean),
      name: "HttpRequestError"
    }), Object.defineProperty(this, "body", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "status", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "url", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.body = t, this.headers = i, this.status = o, this.url = s;
  }
}
class SH extends it {
  constructor({ body: t, error: n, url: r }) {
    super("RPC Request failed.", {
      cause: n,
      details: n.message,
      metaMessages: [`URL: ${EM(r)}`, `Request body: ${Pa(t)}`],
      name: "RpcRequestError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.code = n.code;
  }
}
class uF extends it {
  constructor({ body: t, url: n }) {
    super("The request took too long to respond.", {
      details: "The request timed out.",
      metaMessages: [`URL: ${EM(n)}`, `Request body: ${Pa(t)}`],
      name: "TimeoutError"
    });
  }
}
const Dpe = -1;
class qs extends it {
  constructor(t, { code: n, docsPath: r, metaMessages: i, name: o, shortMessage: s }) {
    super(s, {
      cause: t,
      docsPath: r,
      metaMessages: i || (t == null ? void 0 : t.metaMessages),
      name: o || "RpcError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = o || t.name, this.code = t instanceof SH ? t.code : n ?? Dpe;
  }
}
class Bb extends qs {
  constructor(t, n) {
    super(t, n), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = n.data;
  }
}
class q1 extends qs {
  constructor(t) {
    super(t, {
      code: q1.code,
      name: "ParseRpcError",
      shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    });
  }
}
Object.defineProperty(q1, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32700
});
class W1 extends qs {
  constructor(t) {
    super(t, {
      code: W1.code,
      name: "InvalidRequestRpcError",
      shortMessage: "JSON is not a valid request object."
    });
  }
}
Object.defineProperty(W1, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32600
});
class G1 extends qs {
  constructor(t, { method: n } = {}) {
    super(t, {
      code: G1.code,
      name: "MethodNotFoundRpcError",
      shortMessage: `The method${n ? ` "${n}"` : ""} does not exist / is not available.`
    });
  }
}
Object.defineProperty(G1, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32601
});
class K1 extends qs {
  constructor(t) {
    super(t, {
      code: K1.code,
      name: "InvalidParamsRpcError",
      shortMessage: [
        "Invalid parameters were provided to the RPC method.",
        "Double check you have provided the correct parameters."
      ].join(`
`)
    });
  }
}
Object.defineProperty(K1, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32602
});
class Qm extends qs {
  constructor(t) {
    super(t, {
      code: Qm.code,
      name: "InternalRpcError",
      shortMessage: "An internal error was received."
    });
  }
}
Object.defineProperty(Qm, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32603
});
class Xm extends qs {
  constructor(t) {
    super(t, {
      code: Xm.code,
      name: "InvalidInputRpcError",
      shortMessage: [
        "Missing or invalid parameters.",
        "Double check you have provided the correct parameters."
      ].join(`
`)
    });
  }
}
Object.defineProperty(Xm, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32e3
});
class Y1 extends qs {
  constructor(t) {
    super(t, {
      code: Y1.code,
      name: "ResourceNotFoundRpcError",
      shortMessage: "Requested resource not found."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ResourceNotFoundRpcError"
    });
  }
}
Object.defineProperty(Y1, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32001
});
class $h extends qs {
  constructor(t) {
    super(t, {
      code: $h.code,
      name: "ResourceUnavailableRpcError",
      shortMessage: "Requested resource not available."
    });
  }
}
Object.defineProperty($h, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32002
});
class Q1 extends qs {
  constructor(t) {
    super(t, {
      code: Q1.code,
      name: "TransactionRejectedRpcError",
      shortMessage: "Transaction creation failed."
    });
  }
}
Object.defineProperty(Q1, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32003
});
class X1 extends qs {
  constructor(t, { method: n } = {}) {
    super(t, {
      code: X1.code,
      name: "MethodNotSupportedRpcError",
      shortMessage: `Method${n ? ` "${n}"` : ""} is not implemented.`
    });
  }
}
Object.defineProperty(X1, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32004
});
class nb extends qs {
  constructor(t) {
    super(t, {
      code: nb.code,
      name: "LimitExceededRpcError",
      shortMessage: "Request exceeds defined limit."
    });
  }
}
Object.defineProperty(nb, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32005
});
class J1 extends qs {
  constructor(t) {
    super(t, {
      code: J1.code,
      name: "JsonRpcVersionUnsupportedError",
      shortMessage: "Version of JSON-RPC protocol is not supported."
    });
  }
}
Object.defineProperty(J1, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32006
});
class li extends Bb {
  constructor(t) {
    super(t, {
      code: li.code,
      name: "UserRejectedRequestError",
      shortMessage: "User rejected the request."
    });
  }
}
Object.defineProperty(li, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4001
});
class Z1 extends Bb {
  constructor(t) {
    super(t, {
      code: Z1.code,
      name: "UnauthorizedProviderError",
      shortMessage: "The requested method and/or account has not been authorized by the user."
    });
  }
}
Object.defineProperty(Z1, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4100
});
class eC extends Bb {
  constructor(t, { method: n } = {}) {
    super(t, {
      code: eC.code,
      name: "UnsupportedProviderMethodError",
      shortMessage: `The Provider does not support the requested method${n ? ` " ${n}"` : ""}.`
    });
  }
}
Object.defineProperty(eC, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4200
});
class tC extends Bb {
  constructor(t) {
    super(t, {
      code: tC.code,
      name: "ProviderDisconnectedError",
      shortMessage: "The Provider is disconnected from all chains."
    });
  }
}
Object.defineProperty(tC, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4900
});
class nC extends Bb {
  constructor(t) {
    super(t, {
      code: nC.code,
      name: "ChainDisconnectedError",
      shortMessage: "The Provider is not connected to the requested chain."
    });
  }
}
Object.defineProperty(nC, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4901
});
class Xl extends Bb {
  constructor(t) {
    super(t, {
      code: Xl.code,
      name: "SwitchChainError",
      shortMessage: "An error occurred when attempting to switch chain."
    });
  }
}
Object.defineProperty(Xl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4902
});
class Mpe extends qs {
  constructor(t) {
    super(t, {
      name: "UnknownRpcError",
      shortMessage: "An unknown RPC error occurred."
    });
  }
}
function SM(e, t) {
  const n = (e.details || "").toLowerCase(), r = e instanceof it ? e.walk((i) => i.code === bg.code) : e;
  return r instanceof it ? new bg({
    cause: e,
    message: r.details
  }) : bg.nodeMessage.test(n) ? new bg({
    cause: e,
    message: e.details
  }) : Wh.nodeMessage.test(n) ? new Wh({
    cause: e,
    maxFeePerGas: t == null ? void 0 : t.maxFeePerGas
  }) : u5.nodeMessage.test(n) ? new u5({
    cause: e,
    maxFeePerGas: t == null ? void 0 : t.maxFeePerGas
  }) : d5.nodeMessage.test(n) ? new d5({ cause: e, nonce: t == null ? void 0 : t.nonce }) : f5.nodeMessage.test(n) ? new f5({ cause: e, nonce: t == null ? void 0 : t.nonce }) : h5.nodeMessage.test(n) ? new h5({ cause: e, nonce: t == null ? void 0 : t.nonce }) : p5.nodeMessage.test(n) ? new p5({ cause: e }) : m5.nodeMessage.test(n) ? new m5({ cause: e, gas: t == null ? void 0 : t.gas }) : y5.nodeMessage.test(n) ? new y5({ cause: e, gas: t == null ? void 0 : t.gas }) : v5.nodeMessage.test(n) ? new v5({ cause: e }) : tb.nodeMessage.test(n) ? new tb({
    cause: e,
    maxFeePerGas: t == null ? void 0 : t.maxFeePerGas,
    maxPriorityFeePerGas: t == null ? void 0 : t.maxPriorityFeePerGas
  }) : new P8({
    cause: e
  });
}
function Ppe(e, { docsPath: t, ...n }) {
  const r = (() => {
    const i = SM(e, n);
    return i instanceof P8 ? e : i;
  })();
  return new Ope(r, {
    docsPath: t,
    ...n
  });
}
function N8(e, { format: t }) {
  if (!t)
    return {};
  const n = {};
  function r(o) {
    const s = Object.keys(o);
    for (const c of s)
      c in e && (n[c] = e[c]), o[c] && typeof o[c] == "object" && !Array.isArray(o[c]) && r(o[c]);
  }
  const i = t(e || {});
  return r(i), n;
}
function B8(e, t) {
  return ({ exclude: n, format: r }) => ({
    exclude: n,
    format: (i) => {
      const o = t(i);
      if (n)
        for (const s of n)
          delete o[s];
      return {
        ...o,
        ...r(i)
      };
    },
    type: e
  });
}
const Npe = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3",
  eip7702: "0x4"
};
function UC(e) {
  const t = {};
  return typeof e.authorizationList < "u" && (t.authorizationList = Lpe(e.authorizationList)), typeof e.accessList < "u" && (t.accessList = e.accessList), typeof e.blobVersionedHashes < "u" && (t.blobVersionedHashes = e.blobVersionedHashes), typeof e.blobs < "u" && (typeof e.blobs[0] != "string" ? t.blobs = e.blobs.map((n) => lo(n)) : t.blobs = e.blobs), typeof e.data < "u" && (t.data = e.data), typeof e.from < "u" && (t.from = e.from), typeof e.gas < "u" && (t.gas = en(e.gas)), typeof e.gasPrice < "u" && (t.gasPrice = en(e.gasPrice)), typeof e.maxFeePerBlobGas < "u" && (t.maxFeePerBlobGas = en(e.maxFeePerBlobGas)), typeof e.maxFeePerGas < "u" && (t.maxFeePerGas = en(e.maxFeePerGas)), typeof e.maxPriorityFeePerGas < "u" && (t.maxPriorityFeePerGas = en(e.maxPriorityFeePerGas)), typeof e.nonce < "u" && (t.nonce = en(e.nonce)), typeof e.to < "u" && (t.to = e.to), typeof e.type < "u" && (t.type = Npe[e.type]), typeof e.value < "u" && (t.value = en(e.value)), t;
}
const Bpe = /* @__PURE__ */ B8("transactionRequest", UC);
function Lpe(e) {
  return e.map((t) => ({
    address: t.contractAddress,
    r: t.r,
    s: t.s,
    chainId: en(t.chainId),
    nonce: en(t.nonce),
    ...typeof t.yParity < "u" ? { yParity: en(t.yParity) } : {},
    ...typeof t.v < "u" && typeof t.yParity > "u" ? { v: en(t.v) } : {}
  }));
}
function Dn(e, t, n) {
  const r = e[t.name];
  if (typeof r == "function")
    return r;
  const i = e[n];
  return typeof i == "function" ? i : (o) => t(e, o);
}
const zC = 2n ** 256n - 1n;
function VC(e) {
  const { account: t, gasPrice: n, maxFeePerGas: r, maxPriorityFeePerGas: i, to: o } = e, s = t ? nc(t) : void 0;
  if (s && !co(s.address))
    throw new Ba({ address: s.address });
  if (o && !co(o))
    throw new Ba({ address: o });
  if (typeof n < "u" && (typeof r < "u" || typeof i < "u"))
    throw new Ape();
  if (r && r > zC)
    throw new Wh({ maxFeePerGas: r });
  if (i && r && i > r)
    throw new tb({ maxFeePerGas: r, maxPriorityFeePerGas: i });
}
async function kM(e) {
  const t = await e.request({
    method: "eth_chainId"
  }, { dedupe: !0 });
  return Uu(t);
}
class jpe extends it {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1.", {
      name: "BaseFeeScalarError"
    });
  }
}
class AM extends it {
  constructor() {
    super("Chain does not support EIP-1559 fees.", {
      name: "Eip1559FeesNotSupportedError"
    });
  }
}
class Fpe extends it {
  constructor({ maxPriorityFeePerGas: t }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${Hs(t)} gwei).`, { name: "MaxFeePerGasTooLowError" });
  }
}
class kH extends it {
  constructor({ blockHash: t, blockNumber: n }) {
    let r = "Block";
    t && (r = `Block at hash "${t}"`), n && (r = `Block at number "${n}"`), super(`${r} could not be found.`, { name: "BlockNotFoundError" });
  }
}
const AH = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function $C(e) {
  const t = {
    ...e,
    blockHash: e.blockHash ? e.blockHash : null,
    blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
    chainId: e.chainId ? Uu(e.chainId) : void 0,
    gas: e.gas ? BigInt(e.gas) : void 0,
    gasPrice: e.gasPrice ? BigInt(e.gasPrice) : void 0,
    maxFeePerBlobGas: e.maxFeePerBlobGas ? BigInt(e.maxFeePerBlobGas) : void 0,
    maxFeePerGas: e.maxFeePerGas ? BigInt(e.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: e.maxPriorityFeePerGas ? BigInt(e.maxPriorityFeePerGas) : void 0,
    nonce: e.nonce ? Uu(e.nonce) : void 0,
    to: e.to ? e.to : null,
    transactionIndex: e.transactionIndex ? Number(e.transactionIndex) : null,
    type: e.type ? AH[e.type] : void 0,
    typeHex: e.type ? e.type : void 0,
    value: e.value ? BigInt(e.value) : void 0,
    v: e.v ? BigInt(e.v) : void 0
  };
  return e.authorizationList && (t.authorizationList = Upe(e.authorizationList)), t.yParity = (() => {
    if (e.yParity)
      return Number(e.yParity);
    if (typeof t.v == "bigint") {
      if (t.v === 0n || t.v === 27n)
        return 0;
      if (t.v === 1n || t.v === 28n)
        return 1;
      if (t.v >= 35n)
        return t.v % 2n === 0n ? 1 : 0;
    }
  })(), t.type === "legacy" && (delete t.accessList, delete t.maxFeePerBlobGas, delete t.maxFeePerGas, delete t.maxPriorityFeePerGas, delete t.yParity), t.type === "eip2930" && (delete t.maxFeePerBlobGas, delete t.maxFeePerGas, delete t.maxPriorityFeePerGas), t.type === "eip1559" && delete t.maxFeePerBlobGas, t;
}
const TH = /* @__PURE__ */ B8("transaction", $C);
function Upe(e) {
  return e.map((t) => ({
    contractAddress: t.address,
    r: t.r,
    s: t.s,
    chainId: Number(t.chainId),
    nonce: Number(t.nonce),
    ...typeof t.yParity < "u" ? { yParity: Number(t.yParity) } : {},
    ...typeof t.v < "u" && typeof t.yParity > "u" ? { v: Number(t.v) } : {}
  }));
}
function TM(e) {
  var n;
  const t = (n = e.transactions) == null ? void 0 : n.map((r) => typeof r == "string" ? r : $C(r));
  return {
    ...e,
    baseFeePerGas: e.baseFeePerGas ? BigInt(e.baseFeePerGas) : null,
    blobGasUsed: e.blobGasUsed ? BigInt(e.blobGasUsed) : void 0,
    difficulty: e.difficulty ? BigInt(e.difficulty) : void 0,
    excessBlobGas: e.excessBlobGas ? BigInt(e.excessBlobGas) : void 0,
    gasLimit: e.gasLimit ? BigInt(e.gasLimit) : void 0,
    gasUsed: e.gasUsed ? BigInt(e.gasUsed) : void 0,
    hash: e.hash ? e.hash : null,
    logsBloom: e.logsBloom ? e.logsBloom : null,
    nonce: e.nonce ? e.nonce : null,
    number: e.number ? BigInt(e.number) : null,
    size: e.size ? BigInt(e.size) : void 0,
    timestamp: e.timestamp ? BigInt(e.timestamp) : void 0,
    transactions: t,
    totalDifficulty: e.totalDifficulty ? BigInt(e.totalDifficulty) : null
  };
}
const _H = /* @__PURE__ */ B8("block", TM);
async function Gh(e, { blockHash: t, blockNumber: n, blockTag: r, includeTransactions: i } = {}) {
  var p, y, v;
  const o = r ?? "latest", s = i ?? !1, c = n !== void 0 ? en(n) : void 0;
  let u = null;
  if (t ? u = await e.request({
    method: "eth_getBlockByHash",
    params: [t, s]
  }, { dedupe: !0 }) : u = await e.request({
    method: "eth_getBlockByNumber",
    params: [c || o, s]
  }, { dedupe: !!c }), !u)
    throw new kH({ blockHash: t, blockNumber: n });
  return (((v = (y = (p = e.chain) == null ? void 0 : p.formatters) == null ? void 0 : y.block) == null ? void 0 : v.format) || TM)(u);
}
async function _M(e) {
  const t = await e.request({
    method: "eth_gasPrice"
  });
  return BigInt(t);
}
async function zpe(e, t) {
  return RH(e, t);
}
async function RH(e, t) {
  var o, s;
  const { block: n, chain: r = e.chain, request: i } = t || {};
  try {
    const c = ((o = r == null ? void 0 : r.fees) == null ? void 0 : o.maxPriorityFeePerGas) ?? ((s = r == null ? void 0 : r.fees) == null ? void 0 : s.defaultPriorityFee);
    if (typeof c == "function") {
      const f = n || await Dn(e, Gh, "getBlock")({}), p = await c({
        block: f,
        client: e,
        request: i
      });
      if (p === null)
        throw new Error();
      return p;
    }
    if (typeof c < "u")
      return c;
    const u = await e.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return Da(u);
  } catch {
    const [c, u] = await Promise.all([
      n ? Promise.resolve(n) : Dn(e, Gh, "getBlock")({}),
      Dn(e, _M, "getGasPrice")({})
    ]);
    if (typeof c.baseFeePerGas != "bigint")
      throw new AM();
    const f = u - c.baseFeePerGas;
    return f < 0n ? 0n : f;
  }
}
async function Vpe(e, t) {
  return g5(e, t);
}
async function g5(e, t) {
  var v, w;
  const { block: n, chain: r = e.chain, request: i, type: o = "eip1559" } = t || {}, s = await (async () => {
    var C, x;
    return typeof ((C = r == null ? void 0 : r.fees) == null ? void 0 : C.baseFeeMultiplier) == "function" ? r.fees.baseFeeMultiplier({
      block: n,
      client: e,
      request: i
    }) : ((x = r == null ? void 0 : r.fees) == null ? void 0 : x.baseFeeMultiplier) ?? 1.2;
  })();
  if (s < 1)
    throw new jpe();
  const u = 10 ** (((v = s.toString().split(".")[1]) == null ? void 0 : v.length) ?? 0), f = (C) => C * BigInt(Math.ceil(s * u)) / BigInt(u), p = n || await Dn(e, Gh, "getBlock")({});
  if (typeof ((w = r == null ? void 0 : r.fees) == null ? void 0 : w.estimateFeesPerGas) == "function") {
    const C = await r.fees.estimateFeesPerGas({
      block: n,
      client: e,
      multiply: f,
      request: i,
      type: o
    });
    if (C !== null)
      return C;
  }
  if (o === "eip1559") {
    if (typeof p.baseFeePerGas != "bigint")
      throw new AM();
    const C = typeof (i == null ? void 0 : i.maxPriorityFeePerGas) == "bigint" ? i.maxPriorityFeePerGas : await RH(e, {
      block: p,
      chain: r,
      request: i
    }), x = f(p.baseFeePerGas);
    return {
      maxFeePerGas: (i == null ? void 0 : i.maxFeePerGas) ?? x + C,
      maxPriorityFeePerGas: C
    };
  }
  return {
    gasPrice: (i == null ? void 0 : i.gasPrice) ?? f(await Dn(e, _M, "getGasPrice")({}))
  };
}
class $pe extends it {
  constructor(t, { account: n, docsPath: r, chain: i, data: o, gas: s, gasPrice: c, maxFeePerGas: u, maxPriorityFeePerGas: f, nonce: p, to: y, value: v }) {
    var C;
    const w = FC({
      from: n == null ? void 0 : n.address,
      to: y,
      value: typeof v < "u" && `${xM(v)} ${((C = i == null ? void 0 : i.nativeCurrency) == null ? void 0 : C.symbol) || "ETH"}`,
      data: o,
      gas: s,
      gasPrice: typeof c < "u" && `${Hs(c)} gwei`,
      maxFeePerGas: typeof u < "u" && `${Hs(u)} gwei`,
      maxPriorityFeePerGas: typeof f < "u" && `${Hs(f)} gwei`,
      nonce: p
    });
    super(t.shortMessage, {
      cause: t,
      docsPath: r,
      metaMessages: [
        ...t.metaMessages ? [...t.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        w
      ].filter(Boolean),
      name: "EstimateGasExecutionError"
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cause = t;
  }
}
function Hpe(e, { docsPath: t, ...n }) {
  const r = (() => {
    const i = SM(e, n);
    return i instanceof P8 ? e : i;
  })();
  return new $pe(r, {
    docsPath: t,
    ...n
  });
}
class qpe extends it {
  constructor({ address: t }) {
    super(`State for account "${t}" is set multiple times.`, {
      name: "AccountStateConflictError"
    });
  }
}
class Wpe extends it {
  constructor() {
    super("state and stateDiff are set on the same account.", {
      name: "StateAssignmentConflictError"
    });
  }
}
function dF(e) {
  return e.reduce((t, { slot: n, value: r }) => `${t}        ${n}: ${r}
`, "");
}
function Gpe(e) {
  return e.reduce((t, { address: n, ...r }) => {
    let i = `${t}    ${n}:
`;
    return r.nonce && (i += `      nonce: ${r.nonce}
`), r.balance && (i += `      balance: ${r.balance}
`), r.code && (i += `      code: ${r.code}
`), r.state && (i += `      state:
`, i += dF(r.state)), r.stateDiff && (i += `      stateDiff:
`, i += dF(r.stateDiff)), i;
  }, `  State Override:
`).slice(0, -1);
}
function fF(e) {
  if (!(!e || e.length === 0))
    return e.reduce((t, { slot: n, value: r }) => {
      if (n.length !== 66)
        throw new Jj({
          size: n.length,
          targetSize: 66,
          type: "hex"
        });
      if (r.length !== 66)
        throw new Jj({
          size: r.length,
          targetSize: 66,
          type: "hex"
        });
      return t[n] = r, t;
    }, {});
}
function Kpe(e) {
  const { balance: t, nonce: n, state: r, stateDiff: i, code: o } = e, s = {};
  if (o !== void 0 && (s.code = o), t !== void 0 && (s.balance = en(t)), n !== void 0 && (s.nonce = en(n)), r !== void 0 && (s.state = fF(r)), i !== void 0) {
    if (s.state)
      throw new Wpe();
    s.stateDiff = fF(i);
  }
  return s;
}
function OH(e) {
  if (!e)
    return;
  const t = {};
  for (const { address: n, ...r } of e) {
    if (!co(n, { strict: !1 }))
      throw new Ba({ address: n });
    if (t[n])
      throw new qpe({ address: n });
    t[n] = Kpe(r);
  }
  return t;
}
async function IH(e, { address: t, blockNumber: n, blockTag: r = "latest" }) {
  const i = n ? en(n) : void 0, o = await e.request({
    method: "eth_getBalance",
    params: [t, i || r]
  });
  return BigInt(o);
}
async function L8(e, t) {
  var i, o, s;
  const n = t.account ?? e.account, r = n ? nc(n) : void 0;
  try {
    let ie = function(Z) {
      const { block: J, request: K, rpcStateOverride: oe } = Z;
      return e.request({
        method: "eth_estimateGas",
        params: oe ? [K, J ?? "latest", oe] : J ? [K, J] : [K]
      });
    };
    const { accessList: c, authorizationList: u, blobs: f, blobVersionedHashes: p, blockNumber: y, blockTag: v, data: w, gas: C, gasPrice: x, maxFeePerBlobGas: A, maxFeePerGas: R, maxPriorityFeePerGas: I, nonce: D, value: M, stateOverride: L, ...j } = await j8(e, {
      ...t,
      parameters: (
        // Some RPC Providers do not compute versioned hashes from blobs. We will need
        // to compute them.
        (r == null ? void 0 : r.type) === "local" ? void 0 : ["blobVersionedHashes"]
      )
    }), O = (y ? en(y) : void 0) || v, z = OH(L), H = await (async () => {
      if (j.to)
        return j.to;
      if (u && u.length > 0)
        return await bH({
          authorization: u[0]
        }).catch(() => {
          throw new it("`to` is required. Could not infer from `authorizationList`");
        });
    })();
    VC(t);
    const Q = (s = (o = (i = e.chain) == null ? void 0 : i.formatters) == null ? void 0 : o.transactionRequest) == null ? void 0 : s.format, ee = (Q || UC)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...N8(j, { format: Q }),
      from: r == null ? void 0 : r.address,
      accessList: c,
      authorizationList: u,
      blobs: f,
      blobVersionedHashes: p,
      data: w,
      gas: C,
      gasPrice: x,
      maxFeePerBlobGas: A,
      maxFeePerGas: R,
      maxPriorityFeePerGas: I,
      nonce: D,
      to: H,
      value: M
    });
    let X = BigInt(await ie({ block: O, request: ee, rpcStateOverride: z }));
    if (u) {
      const Z = await IH(e, { address: ee.from }), J = await Promise.all(u.map(async (K) => {
        const { contractAddress: oe } = K, be = await ie({
          block: O,
          request: {
            authorizationList: void 0,
            data: w,
            from: r == null ? void 0 : r.address,
            to: oe,
            value: en(Z)
          },
          rpcStateOverride: z
        }).catch(() => 100000n);
        return 2n * BigInt(be);
      }));
      X += J.reduce((K, oe) => K + oe, 0n);
    }
    return X;
  } catch (c) {
    throw Hpe(c, {
      ...t,
      account: r,
      chain: e.chain
    });
  }
}
async function DH(e, { address: t, blockTag: n = "latest", blockNumber: r }) {
  const i = await e.request({
    method: "eth_getTransactionCount",
    params: [t, r ? en(r) : n]
  }, { dedupe: !!r });
  return Uu(i);
}
function RM(e) {
  const { kzg: t } = e, n = e.to ?? (typeof e.blobs[0] == "string" ? "hex" : "bytes"), r = typeof e.blobs[0] == "string" ? e.blobs.map((o) => zc(o)) : e.blobs, i = [];
  for (const o of r)
    i.push(Uint8Array.from(t.blobToKzgCommitment(o)));
  return n === "bytes" ? i : i.map((o) => lo(o));
}
function OM(e) {
  const { kzg: t } = e, n = e.to ?? (typeof e.blobs[0] == "string" ? "hex" : "bytes"), r = typeof e.blobs[0] == "string" ? e.blobs.map((s) => zc(s)) : e.blobs, i = typeof e.commitments[0] == "string" ? e.commitments.map((s) => zc(s)) : e.commitments, o = [];
  for (let s = 0; s < r.length; s++) {
    const c = r[s], u = i[s];
    o.push(Uint8Array.from(t.computeBlobKzgProof(c, u)));
  }
  return n === "bytes" ? o : o.map((s) => lo(s));
}
function Ype(e, t, n, r) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, n, r);
  const i = BigInt(32), o = BigInt(4294967295), s = Number(n >> i & o), c = Number(n & o), u = r ? 4 : 0, f = r ? 0 : 4;
  e.setUint32(t + u, s, r), e.setUint32(t + f, c, r);
}
const Qpe = (e, t, n) => e & t ^ ~e & n, Xpe = (e, t, n) => e & t ^ e & n ^ t & n;
class Jpe extends pM {
  constructor(t, n, r, i) {
    super(), this.blockLen = t, this.outputLen = n, this.padOffset = r, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = YR(this.buffer);
  }
  update(t) {
    eb(this);
    const { view: n, buffer: r, blockLen: i } = this;
    t = D8(t);
    const o = t.length;
    for (let s = 0; s < o; ) {
      const c = Math.min(i - this.pos, o - s);
      if (c === i) {
        const u = YR(t);
        for (; i <= o - s; s += i)
          this.process(u, s);
        continue;
      }
      r.set(t.subarray(s, s + c), this.pos), this.pos += c, s += c, this.pos === i && (this.process(n, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    eb(this), aH(t, this), this.finished = !0;
    const { buffer: n, view: r, blockLen: i, isLE: o } = this;
    let { pos: s } = this;
    n[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > i - s && (this.process(r, 0), s = 0);
    for (let y = s; y < i; y++)
      n[y] = 0;
    Ype(r, i - 8, BigInt(this.length * 8), o), this.process(r, 0);
    const c = YR(t), u = this.outputLen;
    if (u % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const f = u / 4, p = this.get();
    if (f > p.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let y = 0; y < f; y++)
      c.setUint32(4 * y, p[y], o);
  }
  digest() {
    const { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    const r = t.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: n, buffer: r, length: i, finished: o, destroyed: s, pos: c } = this;
    return t.length = i, t.pos = c, t.finished = o, t.destroyed = s, i % n && t.buffer.set(r), t;
  }
}
const Zpe = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), bh = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), wh = /* @__PURE__ */ new Uint32Array(64);
class eme extends Jpe {
  constructor() {
    super(64, 32, 8, !1), this.A = bh[0] | 0, this.B = bh[1] | 0, this.C = bh[2] | 0, this.D = bh[3] | 0, this.E = bh[4] | 0, this.F = bh[5] | 0, this.G = bh[6] | 0, this.H = bh[7] | 0;
  }
  get() {
    const { A: t, B: n, C: r, D: i, E: o, F: s, G: c, H: u } = this;
    return [t, n, r, i, o, s, c, u];
  }
  // prettier-ignore
  set(t, n, r, i, o, s, c, u) {
    this.A = t | 0, this.B = n | 0, this.C = r | 0, this.D = i | 0, this.E = o | 0, this.F = s | 0, this.G = c | 0, this.H = u | 0;
  }
  process(t, n) {
    for (let y = 0; y < 16; y++, n += 4)
      wh[y] = t.getUint32(n, !1);
    for (let y = 16; y < 64; y++) {
      const v = wh[y - 15], w = wh[y - 2], C = Au(v, 7) ^ Au(v, 18) ^ v >>> 3, x = Au(w, 17) ^ Au(w, 19) ^ w >>> 10;
      wh[y] = x + wh[y - 7] + C + wh[y - 16] | 0;
    }
    let { A: r, B: i, C: o, D: s, E: c, F: u, G: f, H: p } = this;
    for (let y = 0; y < 64; y++) {
      const v = Au(c, 6) ^ Au(c, 11) ^ Au(c, 25), w = p + v + Qpe(c, u, f) + Zpe[y] + wh[y] | 0, x = (Au(r, 2) ^ Au(r, 13) ^ Au(r, 22)) + Xpe(r, i, o) | 0;
      p = f, f = u, u = c, c = s + w | 0, s = o, o = i, i = r, r = w + x | 0;
    }
    r = r + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, c = c + this.E | 0, u = u + this.F | 0, f = f + this.G | 0, p = p + this.H | 0, this.set(r, i, o, s, c, u, f, p);
  }
  roundClean() {
    wh.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const MH = /* @__PURE__ */ sH(() => new eme());
function tme(e, t) {
  return MH(Ql(e, { strict: !1 }) ? qh(e) : e);
}
function nme(e) {
  const { commitment: t, version: n = 1 } = e, r = e.to ?? (typeof t == "string" ? "hex" : "bytes"), i = tme(t);
  return i.set([n], 0), r === "bytes" ? i : lo(i);
}
function PH(e) {
  const { commitments: t, version: n } = e, r = e.to ?? (typeof t[0] == "string" ? "hex" : "bytes"), i = [];
  for (const o of t)
    i.push(nme({
      commitment: o,
      to: r,
      version: n
    }));
  return i;
}
const hF = 6, NH = 32, IM = 4096, BH = NH * IM, pF = BH * hF - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * IM * hF, LH = 1;
class rme extends it {
  constructor({ maxSize: t, size: n }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${t} bytes`, `Given: ${n} bytes`],
      name: "BlobSizeTooLargeError"
    });
  }
}
class jH extends it {
  constructor() {
    super("Blob data must not be empty.", { name: "EmptyBlobError" });
  }
}
class ime extends it {
  constructor({ hash: t, size: n }) {
    super(`Versioned hash "${t}" size is invalid.`, {
      metaMessages: ["Expected: 32", `Received: ${n}`],
      name: "InvalidVersionedHashSizeError"
    });
  }
}
class ome extends it {
  constructor({ hash: t, version: n }) {
    super(`Versioned hash "${t}" version is invalid.`, {
      metaMessages: [
        `Expected: ${LH}`,
        `Received: ${n}`
      ],
      name: "InvalidVersionedHashVersionError"
    });
  }
}
function ame(e) {
  const t = e.to ?? (typeof e.data == "string" ? "hex" : "bytes"), n = typeof e.data == "string" ? zc(e.data) : e.data, r = Ni(n);
  if (!r)
    throw new jH();
  if (r > pF)
    throw new rme({
      maxSize: pF,
      size: r
    });
  const i = [];
  let o = !0, s = 0;
  for (; o; ) {
    const c = CM(new Uint8Array(BH));
    let u = 0;
    for (; u < IM; ) {
      const f = n.slice(s, s + (NH - 1));
      if (c.pushByte(0), c.pushBytes(f), f.length < 31) {
        c.pushByte(128), o = !1;
        break;
      }
      u++, s += 31;
    }
    i.push(c);
  }
  return t === "bytes" ? i.map((c) => c.bytes) : i.map((c) => lo(c.bytes));
}
function FH(e) {
  const { data: t, kzg: n, to: r } = e, i = e.blobs ?? ame({ data: t, to: r }), o = e.commitments ?? RM({ blobs: i, kzg: n, to: r }), s = e.proofs ?? OM({ blobs: i, commitments: o, kzg: n, to: r }), c = [];
  for (let u = 0; u < i.length; u++)
    c.push({
      blob: i[u],
      commitment: o[u],
      proof: s[u]
    });
  return c;
}
function UH(e) {
  if (e.type)
    return e.type;
  if (typeof e.authorizationList < "u")
    return "eip7702";
  if (typeof e.blobs < "u" || typeof e.blobVersionedHashes < "u" || typeof e.maxFeePerBlobGas < "u" || typeof e.sidecars < "u")
    return "eip4844";
  if (typeof e.maxFeePerGas < "u" || typeof e.maxPriorityFeePerGas < "u")
    return "eip1559";
  if (typeof e.gasPrice < "u")
    return typeof e.accessList < "u" ? "eip2930" : "legacy";
  throw new _pe({ transaction: e });
}
const zH = [
  "blobVersionedHashes",
  "chainId",
  "fees",
  "gas",
  "nonce",
  "type"
];
async function j8(e, t) {
  const { account: n = e.account, blobs: r, chain: i, gas: o, kzg: s, nonce: c, nonceManager: u, parameters: f = zH, type: p } = t, y = n ? nc(n) : void 0, v = { ...t, ...y ? { from: y == null ? void 0 : y.address } : {} };
  let w;
  async function C() {
    return w || (w = await Dn(e, Gh, "getBlock")({ blockTag: "latest" }), w);
  }
  let x;
  async function A() {
    return x || (i ? i.id : typeof t.chainId < "u" ? t.chainId : (x = await Dn(e, kM, "getChainId")({}), x));
  }
  if ((f.includes("blobVersionedHashes") || f.includes("sidecars")) && r && s) {
    const R = RM({ blobs: r, kzg: s });
    if (f.includes("blobVersionedHashes")) {
      const I = PH({
        commitments: R,
        to: "hex"
      });
      v.blobVersionedHashes = I;
    }
    if (f.includes("sidecars")) {
      const I = OM({ blobs: r, commitments: R, kzg: s }), D = FH({
        blobs: r,
        commitments: R,
        proofs: I,
        to: "hex"
      });
      v.sidecars = D;
    }
  }
  if (f.includes("chainId") && (v.chainId = await A()), f.includes("nonce") && typeof c > "u" && y)
    if (u) {
      const R = await A();
      v.nonce = await u.consume({
        address: y.address,
        chainId: R,
        client: e
      });
    } else
      v.nonce = await Dn(e, DH, "getTransactionCount")({
        address: y.address,
        blockTag: "pending"
      });
  if ((f.includes("fees") || f.includes("type")) && typeof p > "u")
    try {
      v.type = UH(v);
    } catch {
      const R = await C();
      v.type = typeof (R == null ? void 0 : R.baseFeePerGas) == "bigint" ? "eip1559" : "legacy";
    }
  if (f.includes("fees"))
    if (v.type !== "legacy" && v.type !== "eip2930") {
      if (typeof v.maxFeePerGas > "u" || typeof v.maxPriorityFeePerGas > "u") {
        const R = await C(), { maxFeePerGas: I, maxPriorityFeePerGas: D } = await g5(e, {
          block: R,
          chain: i,
          request: v
        });
        if (typeof t.maxPriorityFeePerGas > "u" && t.maxFeePerGas && t.maxFeePerGas < D)
          throw new Fpe({
            maxPriorityFeePerGas: D
          });
        v.maxPriorityFeePerGas = D, v.maxFeePerGas = I;
      }
    } else {
      if (typeof t.maxFeePerGas < "u" || typeof t.maxPriorityFeePerGas < "u")
        throw new AM();
      const R = await C(), { gasPrice: I } = await g5(e, {
        block: R,
        chain: i,
        request: v,
        type: "legacy"
      });
      v.gasPrice = I;
    }
  return f.includes("gas") && typeof o > "u" && (v.gas = await Dn(e, L8, "estimateGas")({
    ...v,
    account: y ? { address: y.address, type: "json-rpc" } : void 0
  })), VC(v), delete v.parameters, v;
}
async function VH(e, { serializedTransaction: t }) {
  return e.request({
    method: "eth_sendRawTransaction",
    params: [t]
  }, { retryCount: 0 });
}
async function sme(e, t) {
  var R, I, D, M;
  const { account: n = e.account, chain: r = e.chain, accessList: i, authorizationList: o, blobs: s, data: c, gas: u, gasPrice: f, maxFeePerBlobGas: p, maxFeePerGas: y, maxPriorityFeePerGas: v, nonce: w, value: C, ...x } = t;
  if (!n)
    throw new wM({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  const A = nc(n);
  try {
    VC(t);
    const L = await (async () => {
      if (t.to)
        return t.to;
      if (o && o.length > 0)
        return await bH({
          authorization: o[0]
        }).catch(() => {
          throw new it("`to` is required. Could not infer from `authorizationList`.");
        });
    })();
    if (A.type === "json-rpc") {
      let j;
      r !== null && (j = await Dn(e, kM, "getChainId")({}), Epe({
        currentChainId: j,
        chain: r
      }));
      const F = (D = (I = (R = e.chain) == null ? void 0 : R.formatters) == null ? void 0 : I.transactionRequest) == null ? void 0 : D.format, z = (F || UC)({
        // Pick out extra data that might exist on the chain's transaction request type.
        ...N8(x, { format: F }),
        accessList: i,
        authorizationList: o,
        blobs: s,
        chainId: j,
        data: c,
        from: A.address,
        gas: u,
        gasPrice: f,
        maxFeePerBlobGas: p,
        maxFeePerGas: y,
        maxPriorityFeePerGas: v,
        nonce: w,
        to: L,
        value: C
      });
      return await e.request({
        method: "eth_sendTransaction",
        params: [z]
      }, { retryCount: 0 });
    }
    if (A.type === "local") {
      const j = await Dn(e, j8, "prepareTransactionRequest")({
        account: A,
        accessList: i,
        authorizationList: o,
        blobs: s,
        chain: r,
        data: c,
        gas: u,
        gasPrice: f,
        maxFeePerBlobGas: p,
        maxFeePerGas: y,
        maxPriorityFeePerGas: v,
        nonce: w,
        nonceManager: A.nonceManager,
        parameters: [...zH, "sidecars"],
        value: C,
        ...x,
        to: L
      }), F = (M = r == null ? void 0 : r.serializers) == null ? void 0 : M.transaction, O = await A.signTransaction(j, {
        serializer: F
      });
      return await Dn(e, VH, "sendRawTransaction")({
        serializedTransaction: O
      });
    }
    throw A.type === "smart" ? new ZR({
      metaMessages: [
        "Consider using the `sendUserOperation` Action instead."
      ],
      docsPath: "/docs/actions/bundler/sendUserOperation",
      type: "smart"
    }) : new ZR({
      docsPath: "/docs/actions/wallet/sendTransaction",
      type: A.type
    });
  } catch (L) {
    throw L instanceof ZR ? L : Ppe(L, {
      ...t,
      account: A,
      chain: t.chain || void 0
    });
  }
}
const b5 = [
  {
    inputs: [
      {
        components: [
          {
            name: "target",
            type: "address"
          },
          {
            name: "allowFailure",
            type: "bool"
          },
          {
            name: "callData",
            type: "bytes"
          }
        ],
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "aggregate3",
    outputs: [
      {
        components: [
          {
            name: "success",
            type: "bool"
          },
          {
            name: "returnData",
            type: "bytes"
          }
        ],
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
], $H = [
  {
    inputs: [],
    name: "ResolverNotFound",
    type: "error"
  },
  {
    inputs: [],
    name: "ResolverWildcardNotSupported",
    type: "error"
  },
  {
    inputs: [],
    name: "ResolverNotContract",
    type: "error"
  },
  {
    inputs: [
      {
        name: "returnData",
        type: "bytes"
      }
    ],
    name: "ResolverError",
    type: "error"
  },
  {
    inputs: [
      {
        components: [
          {
            name: "status",
            type: "uint16"
          },
          {
            name: "message",
            type: "string"
          }
        ],
        name: "errors",
        type: "tuple[]"
      }
    ],
    name: "HttpError",
    type: "error"
  }
], HH = [
  ...$H,
  {
    name: "resolve",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes" },
      { name: "data", type: "bytes" }
    ],
    outputs: [
      { name: "", type: "bytes" },
      { name: "address", type: "address" }
    ]
  },
  {
    name: "resolve",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes" },
      { name: "data", type: "bytes" },
      { name: "gateways", type: "string[]" }
    ],
    outputs: [
      { name: "", type: "bytes" },
      { name: "address", type: "address" }
    ]
  }
], lme = [
  ...$H,
  {
    name: "reverse",
    type: "function",
    stateMutability: "view",
    inputs: [{ type: "bytes", name: "reverseName" }],
    outputs: [
      { type: "string", name: "resolvedName" },
      { type: "address", name: "resolvedAddress" },
      { type: "address", name: "reverseResolver" },
      { type: "address", name: "resolver" }
    ]
  },
  {
    name: "reverse",
    type: "function",
    stateMutability: "view",
    inputs: [
      { type: "bytes", name: "reverseName" },
      { type: "string[]", name: "gateways" }
    ],
    outputs: [
      { type: "string", name: "resolvedName" },
      { type: "address", name: "resolvedAddress" },
      { type: "address", name: "reverseResolver" },
      { type: "address", name: "resolver" }
    ]
  }
], mF = [
  {
    name: "text",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes32" },
      { name: "key", type: "string" }
    ],
    outputs: [{ name: "", type: "string" }]
  }
], yF = [
  {
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [{ name: "name", type: "bytes32" }],
    outputs: [{ name: "", type: "address" }]
  },
  {
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes32" },
      { name: "coinType", type: "uint256" }
    ],
    outputs: [{ name: "", type: "bytes" }]
  }
], cme = [
  {
    inputs: [
      {
        name: "_signer",
        type: "address"
      },
      {
        name: "_hash",
        type: "bytes32"
      },
      {
        name: "_signature",
        type: "bytes"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  }
];
function ume(e, t = {}) {
  typeof t.size < "u" && qu(e, { size: t.size });
  const n = lo(e, t);
  return Da(n, t);
}
function dme(e, t = {}) {
  let n = e;
  if (typeof t.size < "u" && (qu(n, { size: t.size }), n = Fu(n)), n.length > 1 || n[0] > 1)
    throw new phe(n);
  return !!n[0];
}
function Hd(e, t = {}) {
  typeof t.size < "u" && qu(e, { size: t.size });
  const n = lo(e, t);
  return Uu(n, t);
}
function fme(e, t = {}) {
  let n = e;
  return typeof t.size < "u" && (qu(n, { size: t.size }), n = Fu(n, { dir: "right" })), new TextDecoder().decode(n);
}
function F8(e, t) {
  const n = typeof t == "string" ? zc(t) : t, r = CM(n);
  if (Ni(n) === 0 && e.length > 0)
    throw new O8();
  if (Ni(t) && Ni(t) < 32)
    throw new rH({
      data: typeof t == "string" ? t : lo(t),
      params: e,
      size: Ni(t)
    });
  let i = 0;
  const o = [];
  for (let s = 0; s < e.length; ++s) {
    const c = e[s];
    r.setPosition(i);
    const [u, f] = Dg(r, c, {
      staticPosition: 0
    });
    i += f, o.push(u);
  }
  return o;
}
function Dg(e, t, { staticPosition: n }) {
  const r = gM(t.type);
  if (r) {
    const [i, o] = r;
    return pme(e, { ...t, type: o }, { length: i, staticPosition: n });
  }
  if (t.type === "tuple")
    return gme(e, t, { staticPosition: n });
  if (t.type === "address")
    return hme(e);
  if (t.type === "bool")
    return mme(e);
  if (t.type.startsWith("bytes"))
    return yme(e, t, { staticPosition: n });
  if (t.type.startsWith("uint") || t.type.startsWith("int"))
    return vme(e, t);
  if (t.type === "string")
    return bme(e, { staticPosition: n });
  throw new Dhe(t.type, {
    docsPath: "/docs/contract/decodeAbiParameters"
  });
}
const vF = 32, w5 = 32;
function hme(e) {
  const t = e.readBytes(32);
  return [M8(lo(hH(t, -20))), 32];
}
function pme(e, t, { length: n, staticPosition: r }) {
  if (!n) {
    const s = Hd(e.readBytes(w5)), c = r + s, u = c + vF;
    e.setPosition(c);
    const f = Hd(e.readBytes(vF)), p = rC(t);
    let y = 0;
    const v = [];
    for (let w = 0; w < f; ++w) {
      e.setPosition(u + (p ? w * 32 : y));
      const [C, x] = Dg(e, t, {
        staticPosition: u
      });
      y += x, v.push(C);
    }
    return e.setPosition(r + 32), [v, 32];
  }
  if (rC(t)) {
    const s = Hd(e.readBytes(w5)), c = r + s, u = [];
    for (let f = 0; f < n; ++f) {
      e.setPosition(c + f * 32);
      const [p] = Dg(e, t, {
        staticPosition: c
      });
      u.push(p);
    }
    return e.setPosition(r + 32), [u, 32];
  }
  let i = 0;
  const o = [];
  for (let s = 0; s < n; ++s) {
    const [c, u] = Dg(e, t, {
      staticPosition: r + i
    });
    i += u, o.push(c);
  }
  return [o, i];
}
function mme(e) {
  return [dme(e.readBytes(32), { size: 32 }), 32];
}
function yme(e, t, { staticPosition: n }) {
  const [r, i] = t.type.split("bytes");
  if (!i) {
    const s = Hd(e.readBytes(32));
    e.setPosition(n + s);
    const c = Hd(e.readBytes(32));
    if (c === 0)
      return e.setPosition(n + 32), ["0x", 32];
    const u = e.readBytes(c);
    return e.setPosition(n + 32), [lo(u), 32];
  }
  return [lo(e.readBytes(Number.parseInt(i), 32)), 32];
}
function vme(e, t) {
  const n = t.type.startsWith("int"), r = Number.parseInt(t.type.split("int")[1] || "256"), i = e.readBytes(32);
  return [
    r > 48 ? ume(i, { signed: n }) : Hd(i, { signed: n }),
    32
  ];
}
function gme(e, t, { staticPosition: n }) {
  const r = t.components.length === 0 || t.components.some(({ name: s }) => !s), i = r ? [] : {};
  let o = 0;
  if (rC(t)) {
    const s = Hd(e.readBytes(w5)), c = n + s;
    for (let u = 0; u < t.components.length; ++u) {
      const f = t.components[u];
      e.setPosition(c + o);
      const [p, y] = Dg(e, f, {
        staticPosition: c
      });
      o += y, i[r ? u : f == null ? void 0 : f.name] = p;
    }
    return e.setPosition(n + 32), [i, 32];
  }
  for (let s = 0; s < t.components.length; ++s) {
    const c = t.components[s], [u, f] = Dg(e, c, {
      staticPosition: n
    });
    i[r ? s : c == null ? void 0 : c.name] = u, o += f;
  }
  return [i, o];
}
function bme(e, { staticPosition: t }) {
  const n = Hd(e.readBytes(32)), r = t + n;
  e.setPosition(r);
  const i = Hd(e.readBytes(32));
  if (i === 0)
    return e.setPosition(t + 32), ["", 32];
  const o = e.readBytes(i, 32), s = fme(Fu(o));
  return e.setPosition(t + 32), [s, 32];
}
function rC(e) {
  var r;
  const { type: t } = e;
  if (t === "string" || t === "bytes" || t.endsWith("[]"))
    return !0;
  if (t === "tuple")
    return (r = e.components) == null ? void 0 : r.some(rC);
  const n = gM(e.type);
  return !!(n && rC({ ...e, type: n[1] }));
}
const wme = (e) => zo(qh(e));
function Cme(e) {
  return wme(e);
}
const xme = "1.0.5";
let rc = class C5 extends Error {
  constructor(t, n = {}) {
    var s;
    const r = n.cause instanceof C5 ? n.cause.details : (s = n.cause) != null && s.message ? n.cause.message : n.details, i = n.cause instanceof C5 && n.cause.docsPath || n.docsPath, o = [
      t || "An error occurred.",
      "",
      ...n.metaMessages ? [...n.metaMessages, ""] : [],
      ...i ? [`Docs: https://abitype.dev${i}`] : [],
      ...r ? [`Details: ${r}`] : [],
      `Version: abitype@${xme}`
    ].join(`
`);
    super(o), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiTypeError"
    }), n.cause && (this.cause = n.cause), this.details = r, this.docsPath = i, this.metaMessages = n.metaMessages, this.shortMessage = t;
  }
};
function sp(e, t) {
  const n = e.exec(t);
  return n == null ? void 0 : n.groups;
}
const qH = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, WH = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/, GH = /^\(.+?\).*?$/, gF = /^tuple(?<array>(\[(\d*)\])*)$/;
function x5(e) {
  let t = e.type;
  if (gF.test(e.type) && "components" in e) {
    t = "(";
    const n = e.components.length;
    for (let i = 0; i < n; i++) {
      const o = e.components[i];
      t += x5(o), i < n - 1 && (t += ", ");
    }
    const r = sp(gF, e.type);
    return t += `)${(r == null ? void 0 : r.array) ?? ""}`, x5({
      ...e,
      type: t
    });
  }
  return "indexed" in e && e.indexed && (t = `${t} indexed`), e.name ? `${t} ${e.name}` : t;
}
function s1(e) {
  let t = "";
  const n = e.length;
  for (let r = 0; r < n; r++) {
    const i = e[r];
    t += x5(i), r !== n - 1 && (t += ", ");
  }
  return t;
}
function Eme(e) {
  return e.type === "function" ? `function ${e.name}(${s1(e.inputs)})${e.stateMutability && e.stateMutability !== "nonpayable" ? ` ${e.stateMutability}` : ""}${e.outputs.length ? ` returns (${s1(e.outputs)})` : ""}` : e.type === "event" ? `event ${e.name}(${s1(e.inputs)})` : e.type === "error" ? `error ${e.name}(${s1(e.inputs)})` : e.type === "constructor" ? `constructor(${s1(e.inputs)})${e.stateMutability === "payable" ? " payable" : ""}` : e.type === "fallback" ? "fallback()" : "receive() external payable";
}
const KH = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function Sme(e) {
  return KH.test(e);
}
function kme(e) {
  return sp(KH, e);
}
const YH = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function Ame(e) {
  return YH.test(e);
}
function Tme(e) {
  return sp(YH, e);
}
const QH = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
function _me(e) {
  return QH.test(e);
}
function Rme(e) {
  return sp(QH, e);
}
const XH = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
function JH(e) {
  return XH.test(e);
}
function Ome(e) {
  return sp(XH, e);
}
const ZH = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
function Ime(e) {
  return ZH.test(e);
}
function Dme(e) {
  return sp(ZH, e);
}
const Mme = /^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;
function Pme(e) {
  return Mme.test(e);
}
const Nme = /^receive\(\) external payable$/;
function Bme(e) {
  return Nme.test(e);
}
const Lme = /* @__PURE__ */ new Set(["indexed"]), E5 = /* @__PURE__ */ new Set([
  "calldata",
  "memory",
  "storage"
]);
class jme extends rc {
  constructor({ type: t }) {
    super("Unknown type.", {
      metaMessages: [
        `Type "${t}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownTypeError"
    });
  }
}
class Fme extends rc {
  constructor({ type: t }) {
    super("Unknown type.", {
      metaMessages: [`Type "${t}" is not a valid ABI type.`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownSolidityTypeError"
    });
  }
}
class Ume extends rc {
  constructor({ param: t }) {
    super("Invalid ABI parameter.", {
      details: t
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParameterError"
    });
  }
}
class zme extends rc {
  constructor({ param: t, name: n }) {
    super("Invalid ABI parameter.", {
      details: t,
      metaMessages: [
        `"${n}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SolidityProtectedKeywordError"
    });
  }
}
class Vme extends rc {
  constructor({ param: t, type: n, modifier: r }) {
    super("Invalid ABI parameter.", {
      details: t,
      metaMessages: [
        `Modifier "${r}" not allowed${n ? ` in "${n}" type` : ""}.`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidModifierError"
    });
  }
}
class $me extends rc {
  constructor({ param: t, type: n, modifier: r }) {
    super("Invalid ABI parameter.", {
      details: t,
      metaMessages: [
        `Modifier "${r}" not allowed${n ? ` in "${n}" type` : ""}.`,
        `Data location can only be specified for array, struct, or mapping types, but "${r}" was given.`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidFunctionModifierError"
    });
  }
}
class Hme extends rc {
  constructor({ abiParameter: t }) {
    super("Invalid ABI parameter.", {
      details: JSON.stringify(t, null, 2),
      metaMessages: ["ABI parameter type is invalid."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiTypeParameterError"
    });
  }
}
class C1 extends rc {
  constructor({ signature: t, type: n }) {
    super(`Invalid ${n} signature.`, {
      details: t
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidSignatureError"
    });
  }
}
class qme extends rc {
  constructor({ signature: t }) {
    super("Unknown signature.", {
      details: t
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownSignatureError"
    });
  }
}
class Wme extends rc {
  constructor({ signature: t }) {
    super("Invalid struct signature.", {
      details: t,
      metaMessages: ["No properties exist."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidStructSignatureError"
    });
  }
}
class Gme extends rc {
  constructor({ type: t }) {
    super("Circular reference detected.", {
      metaMessages: [`Struct "${t}" is a circular reference.`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "CircularReferenceError"
    });
  }
}
class Kme extends rc {
  constructor({ current: t, depth: n }) {
    super("Unbalanced parentheses.", {
      metaMessages: [
        `"${t.trim()}" has too many ${n > 0 ? "opening" : "closing"} parentheses.`
      ],
      details: `Depth "${n}"`
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParenthesisError"
    });
  }
}
function Yme(e, t) {
  return t ? `${t}:${e}` : e;
}
const eO = /* @__PURE__ */ new Map([
  // Unnamed
  ["address", { type: "address" }],
  ["bool", { type: "bool" }],
  ["bytes", { type: "bytes" }],
  ["bytes32", { type: "bytes32" }],
  ["int", { type: "int256" }],
  ["int256", { type: "int256" }],
  ["string", { type: "string" }],
  ["uint", { type: "uint256" }],
  ["uint8", { type: "uint8" }],
  ["uint16", { type: "uint16" }],
  ["uint24", { type: "uint24" }],
  ["uint32", { type: "uint32" }],
  ["uint64", { type: "uint64" }],
  ["uint96", { type: "uint96" }],
  ["uint112", { type: "uint112" }],
  ["uint160", { type: "uint160" }],
  ["uint192", { type: "uint192" }],
  ["uint256", { type: "uint256" }],
  // Named
  ["address owner", { type: "address", name: "owner" }],
  ["address to", { type: "address", name: "to" }],
  ["bool approved", { type: "bool", name: "approved" }],
  ["bytes _data", { type: "bytes", name: "_data" }],
  ["bytes data", { type: "bytes", name: "data" }],
  ["bytes signature", { type: "bytes", name: "signature" }],
  ["bytes32 hash", { type: "bytes32", name: "hash" }],
  ["bytes32 r", { type: "bytes32", name: "r" }],
  ["bytes32 root", { type: "bytes32", name: "root" }],
  ["bytes32 s", { type: "bytes32", name: "s" }],
  ["string name", { type: "string", name: "name" }],
  ["string symbol", { type: "string", name: "symbol" }],
  ["string tokenURI", { type: "string", name: "tokenURI" }],
  ["uint tokenId", { type: "uint256", name: "tokenId" }],
  ["uint8 v", { type: "uint8", name: "v" }],
  ["uint256 balance", { type: "uint256", name: "balance" }],
  ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
  ["uint256 value", { type: "uint256", name: "value" }],
  // Indexed
  [
    "event:address indexed from",
    { type: "address", name: "from", indexed: !0 }
  ],
  ["event:address indexed to", { type: "address", name: "to", indexed: !0 }],
  [
    "event:uint indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: !0 }
  ],
  [
    "event:uint256 indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: !0 }
  ]
]);
function Qme(e, t = {}) {
  if (_me(e)) {
    const n = Rme(e);
    if (!n)
      throw new C1({ signature: e, type: "function" });
    const r = Fc(n.parameters), i = [], o = r.length;
    for (let c = 0; c < o; c++)
      i.push(Cm(r[c], {
        modifiers: E5,
        structs: t,
        type: "function"
      }));
    const s = [];
    if (n.returns) {
      const c = Fc(n.returns), u = c.length;
      for (let f = 0; f < u; f++)
        s.push(Cm(c[f], {
          modifiers: E5,
          structs: t,
          type: "function"
        }));
    }
    return {
      name: n.name,
      type: "function",
      stateMutability: n.stateMutability ?? "nonpayable",
      inputs: i,
      outputs: s
    };
  }
  if (Ame(e)) {
    const n = Tme(e);
    if (!n)
      throw new C1({ signature: e, type: "event" });
    const r = Fc(n.parameters), i = [], o = r.length;
    for (let s = 0; s < o; s++)
      i.push(Cm(r[s], {
        modifiers: Lme,
        structs: t,
        type: "event"
      }));
    return { name: n.name, type: "event", inputs: i };
  }
  if (Sme(e)) {
    const n = kme(e);
    if (!n)
      throw new C1({ signature: e, type: "error" });
    const r = Fc(n.parameters), i = [], o = r.length;
    for (let s = 0; s < o; s++)
      i.push(Cm(r[s], { structs: t, type: "error" }));
    return { name: n.name, type: "error", inputs: i };
  }
  if (Ime(e)) {
    const n = Dme(e);
    if (!n)
      throw new C1({ signature: e, type: "constructor" });
    const r = Fc(n.parameters), i = [], o = r.length;
    for (let s = 0; s < o; s++)
      i.push(Cm(r[s], { structs: t, type: "constructor" }));
    return {
      type: "constructor",
      stateMutability: n.stateMutability ?? "nonpayable",
      inputs: i
    };
  }
  if (Pme(e))
    return { type: "fallback" };
  if (Bme(e))
    return {
      type: "receive",
      stateMutability: "payable"
    };
  throw new qme({ signature: e });
}
const Xme = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/, Jme = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/, Zme = /^u?int$/;
function Cm(e, t) {
  var y, v;
  const n = Yme(e, t == null ? void 0 : t.type);
  if (eO.has(n))
    return eO.get(n);
  const r = GH.test(e), i = sp(r ? Jme : Xme, e);
  if (!i)
    throw new Ume({ param: e });
  if (i.name && tye(i.name))
    throw new zme({ param: e, name: i.name });
  const o = i.name ? { name: i.name } : {}, s = i.modifier === "indexed" ? { indexed: !0 } : {}, c = (t == null ? void 0 : t.structs) ?? {};
  let u, f = {};
  if (r) {
    u = "tuple";
    const w = Fc(i.type), C = [], x = w.length;
    for (let A = 0; A < x; A++)
      C.push(Cm(w[A], { structs: c }));
    f = { components: C };
  } else if (i.type in c)
    u = "tuple", f = { components: c[i.type] };
  else if (Zme.test(i.type))
    u = `${i.type}256`;
  else if (u = i.type, (t == null ? void 0 : t.type) !== "struct" && !eq(u))
    throw new Fme({ type: u });
  if (i.modifier) {
    if (!((v = (y = t == null ? void 0 : t.modifiers) == null ? void 0 : y.has) != null && v.call(y, i.modifier)))
      throw new Vme({
        param: e,
        type: t == null ? void 0 : t.type,
        modifier: i.modifier
      });
    if (E5.has(i.modifier) && !nye(u, !!i.array))
      throw new $me({
        param: e,
        type: t == null ? void 0 : t.type,
        modifier: i.modifier
      });
  }
  const p = {
    type: `${u}${i.array ?? ""}`,
    ...o,
    ...s,
    ...f
  };
  return eO.set(n, p), p;
}
function Fc(e, t = [], n = "", r = 0) {
  const i = e.trim().length;
  for (let o = 0; o < i; o++) {
    const s = e[o], c = e.slice(o + 1);
    switch (s) {
      case ",":
        return r === 0 ? Fc(c, [...t, n.trim()]) : Fc(c, t, `${n}${s}`, r);
      case "(":
        return Fc(c, t, `${n}${s}`, r + 1);
      case ")":
        return Fc(c, t, `${n}${s}`, r - 1);
      default:
        return Fc(c, t, `${n}${s}`, r);
    }
  }
  if (n === "")
    return t;
  if (r !== 0)
    throw new Kme({ current: n, depth: r });
  return t.push(n.trim()), t;
}
function eq(e) {
  return e === "address" || e === "bool" || e === "function" || e === "string" || qH.test(e) || WH.test(e);
}
const eye = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
function tye(e) {
  return e === "address" || e === "bool" || e === "function" || e === "string" || e === "tuple" || qH.test(e) || WH.test(e) || eye.test(e);
}
function nye(e, t) {
  return t || e === "bytes" || e === "string" || e === "tuple";
}
function rye(e) {
  const t = {}, n = e.length;
  for (let s = 0; s < n; s++) {
    const c = e[s];
    if (!JH(c))
      continue;
    const u = Ome(c);
    if (!u)
      throw new C1({ signature: c, type: "struct" });
    const f = u.properties.split(";"), p = [], y = f.length;
    for (let v = 0; v < y; v++) {
      const C = f[v].trim();
      if (!C)
        continue;
      const x = Cm(C, {
        type: "struct"
      });
      p.push(x);
    }
    if (!p.length)
      throw new Wme({ signature: c });
    t[u.name] = p;
  }
  const r = {}, i = Object.entries(t), o = i.length;
  for (let s = 0; s < o; s++) {
    const [c, u] = i[s];
    r[c] = tq(u, t);
  }
  return r;
}
const iye = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
function tq(e, t, n = /* @__PURE__ */ new Set()) {
  const r = [], i = e.length;
  for (let o = 0; o < i; o++) {
    const s = e[o];
    if (GH.test(s.type))
      r.push(s);
    else {
      const u = sp(iye, s.type);
      if (!(u != null && u.type))
        throw new Hme({ abiParameter: s });
      const { array: f, type: p } = u;
      if (p in t) {
        if (n.has(p))
          throw new Gme({ type: p });
        r.push({
          ...s,
          type: `tuple${f ?? ""}`,
          components: tq(t[p] ?? [], t, /* @__PURE__ */ new Set([...n, p]))
        });
      } else if (eq(p))
        r.push(s);
      else
        throw new jme({ type: p });
    }
  }
  return r;
}
function nq(e) {
  const t = rye(e), n = [], r = e.length;
  for (let i = 0; i < r; i++) {
    const o = e[i];
    JH(o) || n.push(Qme(o, t));
  }
  return n;
}
function oye(e) {
  let t = !0, n = "", r = 0, i = "", o = !1;
  for (let s = 0; s < e.length; s++) {
    const c = e[s];
    if (["(", ")", ","].includes(c) && (t = !0), c === "(" && r++, c === ")" && r--, !!t) {
      if (r === 0) {
        if (c === " " && ["event", "function", ""].includes(i))
          i = "";
        else if (i += c, c === ")") {
          o = !0;
          break;
        }
        continue;
      }
      if (c === " ") {
        e[s - 1] !== "," && n !== "," && n !== ",(" && (n = "", t = !1);
        continue;
      }
      i += c, n += c;
    }
  }
  if (!o)
    throw new it("Unable to normalize signature.");
  return i;
}
const aye = (e) => {
  const t = typeof e == "string" ? e : Eme(e);
  return oye(t);
};
function rq(e) {
  return Cme(aye(e));
}
const U8 = rq, DM = (e) => H1(rq(e), 0, 4);
function HC(e) {
  const { abi: t, args: n = [], name: r } = e, i = Ql(r, { strict: !1 }), o = t.filter((c) => i ? c.type === "function" ? DM(c) === r : c.type === "event" ? U8(c) === r : !1 : "name" in c && c.name === r);
  if (o.length === 0)
    return;
  if (o.length === 1)
    return o[0];
  let s;
  for (const c of o) {
    if (!("inputs" in c))
      continue;
    if (!n || n.length === 0) {
      if (!c.inputs || c.inputs.length === 0)
        return c;
      continue;
    }
    if (!c.inputs || c.inputs.length === 0 || c.inputs.length !== n.length)
      continue;
    if (n.every((f, p) => {
      const y = "inputs" in c && c.inputs[p];
      return y ? S5(f, y) : !1;
    })) {
      if (s && "inputs" in s && s.inputs) {
        const f = iq(c.inputs, s.inputs, n);
        if (f)
          throw new Rhe({
            abiItem: c,
            type: f[0]
          }, {
            abiItem: s,
            type: f[1]
          });
      }
      s = c;
    }
  }
  return s || o[0];
}
function S5(e, t) {
  const n = typeof e, r = t.type;
  switch (r) {
    case "address":
      return co(e, { strict: !1 });
    case "bool":
      return n === "boolean";
    case "function":
      return n === "string";
    case "string":
      return n === "string";
    default:
      return r === "tuple" && "components" in t ? Object.values(t.components).every((i, o) => S5(Object.values(e)[o], i)) : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(r) ? n === "number" || n === "bigint" : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(r) ? n === "string" || e instanceof Uint8Array : /[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(r) ? Array.isArray(e) && e.every((i) => S5(i, {
        ...t,
        // Pop off `[]` or `[M]` from end of type
        type: r.replace(/(\[[0-9]{0,}\])$/, "")
      })) : !1;
  }
}
function iq(e, t, n) {
  for (const r in e) {
    const i = e[r], o = t[r];
    if (i.type === "tuple" && o.type === "tuple" && "components" in i && "components" in o)
      return iq(i.components, o.components, n[r]);
    const s = [i.type, o.type];
    if (s.includes("address") && s.includes("bytes20") ? !0 : s.includes("address") && s.includes("string") ? co(n[r], { strict: !1 }) : s.includes("address") && s.includes("bytes") ? co(n[r], { strict: !1 }) : !1)
      return s;
  }
}
const tO = "/docs/contract/decodeFunctionResult";
function Lb(e) {
  const { abi: t, args: n, functionName: r, data: i } = e;
  let o = t[0];
  if (r) {
    const c = HC({ abi: t, args: n, name: r });
    if (!c)
      throw new M4(r, { docsPath: tO });
    o = c;
  }
  if (o.type !== "function")
    throw new M4(void 0, { docsPath: tO });
  if (!o.outputs)
    throw new _he(o.name, { docsPath: tO });
  const s = F8(o.outputs, i);
  if (s && s.length > 1)
    return s;
  if (s && s.length === 1)
    return s[0];
}
const bF = "/docs/contract/encodeFunctionData";
function sye(e) {
  const { abi: t, args: n, functionName: r } = e;
  let i = t[0];
  if (r) {
    const o = HC({
      abi: t,
      args: n,
      name: r
    });
    if (!o)
      throw new M4(r, { docsPath: bF });
    i = o;
  }
  if (i.type !== "function")
    throw new M4(void 0, { docsPath: bF });
  return {
    abi: [i],
    functionName: DM(Xd(i))
  };
}
function cy(e) {
  const { args: t } = e, { abi: n, functionName: r } = (() => {
    var c;
    return e.abi.length === 1 && ((c = e.functionName) != null && c.startsWith("0x")) ? e : sye(e);
  })(), i = n[0], o = r, s = "inputs" in i && i.inputs ? Nb(i.inputs, t ?? []) : void 0;
  return Wc([o, s ?? "0x"]);
}
function jb({ blockNumber: e, chain: t, contract: n }) {
  var i;
  const r = (i = t == null ? void 0 : t.contracts) == null ? void 0 : i[n];
  if (!r)
    throw new c5({
      chain: t,
      contract: { name: n }
    });
  if (e && r.blockCreated && r.blockCreated > e)
    throw new c5({
      blockNumber: e,
      chain: t,
      contract: {
        name: n,
        blockCreated: r.blockCreated
      }
    });
  return r.address;
}
const oq = {
  1: "An `assert` condition failed.",
  17: "Arithmetic operation resulted in underflow or overflow.",
  18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
  33: "Attempted to convert to an invalid type.",
  34: "Attempted to access a storage byte array that is incorrectly encoded.",
  49: "Performed `.pop()` on an empty array",
  50: "Array index is out of bounds.",
  65: "Allocated too much memory or created an array which is too large.",
  81: "Attempted to call a zero-initialized variable of internal function type."
}, lye = {
  inputs: [
    {
      name: "message",
      type: "string"
    }
  ],
  name: "Error",
  type: "error"
}, cye = {
  inputs: [
    {
      name: "reason",
      type: "uint256"
    }
  ],
  name: "Panic",
  type: "error"
};
function uye(e) {
  const { abi: t, data: n } = e, r = H1(n, 0, 4);
  if (r === "0x")
    throw new O8();
  const o = [...t || [], lye, cye].find((s) => s.type === "error" && r === DM(Xd(s)));
  if (!o)
    throw new iH(r, {
      docsPath: "/docs/contract/decodeErrorResult"
    });
  return {
    abiItem: o,
    args: "inputs" in o && o.inputs && o.inputs.length > 0 ? F8(o.inputs, H1(n, 4)) : void 0,
    errorName: o.name
  };
}
function aq({ abiItem: e, args: t, includeFunctionName: n = !0, includeName: r = !1 }) {
  if ("name" in e && "inputs" in e && e.inputs)
    return `${n ? e.name : ""}(${e.inputs.map((i, o) => `${r && i.name ? `${i.name}: ` : ""}${typeof t[o] == "object" ? Pa(t[o]) : t[o]}`).join(", ")})`;
}
class sq extends it {
  constructor(t, { account: n, docsPath: r, chain: i, data: o, gas: s, gasPrice: c, maxFeePerGas: u, maxPriorityFeePerGas: f, nonce: p, to: y, value: v, stateOverride: w }) {
    var A;
    const C = n ? nc(n) : void 0;
    let x = FC({
      from: C == null ? void 0 : C.address,
      to: y,
      value: typeof v < "u" && `${xM(v)} ${((A = i == null ? void 0 : i.nativeCurrency) == null ? void 0 : A.symbol) || "ETH"}`,
      data: o,
      gas: s,
      gasPrice: typeof c < "u" && `${Hs(c)} gwei`,
      maxFeePerGas: typeof u < "u" && `${Hs(u)} gwei`,
      maxPriorityFeePerGas: typeof f < "u" && `${Hs(f)} gwei`,
      nonce: p
    });
    w && (x += `
${Gpe(w)}`), super(t.shortMessage, {
      cause: t,
      docsPath: r,
      metaMessages: [
        ...t.metaMessages ? [...t.metaMessages, " "] : [],
        "Raw Call Arguments:",
        x
      ].filter(Boolean),
      name: "CallExecutionError"
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cause = t;
  }
}
class dye extends it {
  constructor(t, { abi: n, args: r, contractAddress: i, docsPath: o, functionName: s, sender: c }) {
    const u = HC({ abi: n, args: r, name: s }), f = u ? aq({
      abiItem: u,
      args: r,
      includeFunctionName: !1,
      includeName: !1
    }) : void 0, p = u ? Xd(u, { includeName: !0 }) : void 0, y = FC({
      address: i && Ipe(i),
      function: p,
      args: f && f !== "()" && `${[...Array((s == null ? void 0 : s.length) ?? 0).keys()].map(() => " ").join("")}${f}`,
      sender: c
    });
    super(t.shortMessage || `An unknown error occurred while executing the contract function "${s}".`, {
      cause: t,
      docsPath: o,
      metaMessages: [
        ...t.metaMessages ? [...t.metaMessages, " "] : [],
        y && "Contract Call:",
        y
      ].filter(Boolean),
      name: "ContractFunctionExecutionError"
    }), Object.defineProperty(this, "abi", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "args", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "contractAddress", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "formattedArgs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "functionName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "sender", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.abi = n, this.args = r, this.cause = t, this.contractAddress = i, this.functionName = s, this.sender = c;
  }
}
class k5 extends it {
  constructor({ abi: t, data: n, functionName: r, message: i }) {
    let o, s, c, u;
    if (n && n !== "0x")
      try {
        s = uye({ abi: t, data: n });
        const { abiItem: p, errorName: y, args: v } = s;
        if (y === "Error")
          u = v[0];
        else if (y === "Panic") {
          const [w] = v;
          u = oq[w];
        } else {
          const w = p ? Xd(p, { includeName: !0 }) : void 0, C = p && v ? aq({
            abiItem: p,
            args: v,
            includeFunctionName: !1,
            includeName: !1
          }) : void 0;
          c = [
            w ? `Error: ${w}` : "",
            C && C !== "()" ? `       ${[...Array((y == null ? void 0 : y.length) ?? 0).keys()].map(() => " ").join("")}${C}` : ""
          ];
        }
      } catch (p) {
        o = p;
      }
    else i && (u = i);
    let f;
    o instanceof iH && (f = o.signature, c = [
      `Unable to decode signature "${f}" as it was not found on the provided ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${f}.`
    ]), super(u && u !== "execution reverted" || f ? [
      `The contract function "${r}" reverted with the following ${f ? "signature" : "reason"}:`,
      u || f
    ].join(`
`) : `The contract function "${r}" reverted.`, {
      cause: o,
      metaMessages: c,
      name: "ContractFunctionRevertedError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "reason", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = s, this.reason = u, this.signature = f;
  }
}
class fye extends it {
  constructor({ functionName: t }) {
    super(`The contract function "${t}" returned no data ("0x").`, {
      metaMessages: [
        "This could be due to any of the following:",
        `  - The contract does not have the function "${t}",`,
        "  - The parameters passed to the contract function may be invalid, or",
        "  - The address is not a contract."
      ],
      name: "ContractFunctionZeroDataError"
    });
  }
}
class hye extends it {
  constructor({ factory: t }) {
    super(`Deployment for counterfactual contract call failed${t ? ` for factory "${t}".` : ""}`, {
      metaMessages: [
        "Please ensure:",
        "- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).",
        "- The `factoryData` is a valid encoded function call for contract deployment function on the factory."
      ],
      name: "CounterfactualDeploymentFailedError"
    });
  }
}
class MM extends it {
  constructor({ data: t, message: n }) {
    super(n || "", { name: "RawContractError" }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 3
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = t;
  }
}
function PM(e, t) {
  var r, i, o, s, c, u;
  if (!(e instanceof it))
    return !1;
  const n = e.walk((f) => f instanceof k5);
  return n instanceof k5 ? !!(((r = n.data) == null ? void 0 : r.errorName) === "ResolverNotFound" || ((i = n.data) == null ? void 0 : i.errorName) === "ResolverWildcardNotSupported" || ((o = n.data) == null ? void 0 : o.errorName) === "ResolverNotContract" || ((s = n.data) == null ? void 0 : s.errorName) === "ResolverError" || ((c = n.data) == null ? void 0 : c.errorName) === "HttpError" || (u = n.reason) != null && u.includes("Wildcard on non-extended resolvers is not supported") || t === "reverse" && n.reason === oq[50]) : !1;
}
function lq(e) {
  if (e.length !== 66 || e.indexOf("[") !== 0 || e.indexOf("]") !== 65)
    return null;
  const t = `0x${e.slice(1, 65)}`;
  return Ql(t) ? t : null;
}
function s4(e) {
  let t = new Uint8Array(32).fill(0);
  if (!e)
    return lo(t);
  const n = e.split(".");
  for (let r = n.length - 1; r >= 0; r -= 1) {
    const i = lq(n[r]), o = i ? qh(i) : zo(zm(n[r]), "bytes");
    t = zo(Jd([t, o]), "bytes");
  }
  return lo(t);
}
function pye(e) {
  return `[${e.slice(2)}]`;
}
function mye(e) {
  const t = new Uint8Array(32).fill(0);
  return e ? lq(e) || zo(zm(e)) : lo(t);
}
function z8(e) {
  const t = e.replace(/^\.|\.$/gm, "");
  if (t.length === 0)
    return new Uint8Array(1);
  const n = new Uint8Array(zm(t).byteLength + 2);
  let r = 0;
  const i = t.split(".");
  for (let o = 0; o < i.length; o++) {
    let s = zm(i[o]);
    s.byteLength > 255 && (s = zm(pye(mye(i[o])))), n[r] = s.length, n.set(s, r + 1), r += s.length + 1;
  }
  return n.byteLength !== r + 1 ? n.slice(0, r + 1) : n;
}
const yye = 3;
function iC(e, { abi: t, address: n, args: r, docsPath: i, functionName: o, sender: s }) {
  const { code: c, data: u, message: f, shortMessage: p } = e instanceof MM ? e : e instanceof it ? e.walk((v) => "data" in v) || e.walk() : {}, y = e instanceof O8 ? new fye({ functionName: o }) : [yye, Qm.code].includes(c) && (u || f || p) ? new k5({
    abi: t,
    data: typeof u == "object" ? u.data : u,
    functionName: o,
    message: p ?? f
  }) : e;
  return new dye(y, {
    abi: t,
    args: r,
    contractAddress: n,
    docsPath: i,
    functionName: o,
    sender: s
  });
}
const vye = "0x82ad56cb", gye = "0x608060405234801561001057600080fd5b5060405161018e38038061018e83398101604081905261002f91610124565b6000808351602085016000f59050803b61004857600080fd5b6000808351602085016000855af16040513d6000823e81610067573d81fd5b3d81f35b634e487b7160e01b600052604160045260246000fd5b600082601f83011261009257600080fd5b81516001600160401b038111156100ab576100ab61006b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156100d9576100d961006b565b6040528181528382016020018510156100f157600080fd5b60005b82811015610110576020818601810151838301820152016100f4565b506000918101602001919091529392505050565b6000806040838503121561013757600080fd5b82516001600160401b0381111561014d57600080fd5b61015985828601610081565b602085015190935090506001600160401b0381111561017757600080fd5b61018385828601610081565b915050925092905056fe", bye = "0x608060405234801561001057600080fd5b506040516102c03803806102c083398101604081905261002f916101e6565b836001600160a01b03163b6000036100e457600080836001600160a01b03168360405161005c9190610270565b6000604051808303816000865af19150503d8060008114610099576040519150601f19603f3d011682016040523d82523d6000602084013e61009e565b606091505b50915091508115806100b857506001600160a01b0386163b155b156100e1578060405163101bb98d60e01b81526004016100d8919061028c565b60405180910390fd5b50505b6000808451602086016000885af16040513d6000823e81610103573d81fd5b3d81f35b80516001600160a01b038116811461011e57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561015457818101518382015260200161013c565b50506000910152565b600082601f83011261016e57600080fd5b81516001600160401b0381111561018757610187610123565b604051601f8201601f19908116603f011681016001600160401b03811182821017156101b5576101b5610123565b6040528181528382016020018510156101cd57600080fd5b6101de826020830160208701610139565b949350505050565b600080600080608085870312156101fc57600080fd5b61020585610107565b60208601519094506001600160401b0381111561022157600080fd5b61022d8782880161015d565b93505061023c60408601610107565b60608601519092506001600160401b0381111561025857600080fd5b6102648782880161015d565b91505092959194509250565b60008251610282818460208701610139565b9190910192915050565b60208152600082518060208401526102ab816040850160208701610139565b601f01601f1916919091016040019291505056fe", wye = "0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";
function cq(e, { docsPath: t, ...n }) {
  const r = (() => {
    const i = SM(e, n);
    return i instanceof P8 ? e : i;
  })();
  return new sq(r, {
    docsPath: t,
    ...n
  });
}
const nO = /* @__PURE__ */ new Map();
function uq({ fn: e, id: t, shouldSplitBatch: n, wait: r = 0, sort: i }) {
  const o = async () => {
    const p = u();
    s();
    const y = p.map(({ args: v }) => v);
    y.length !== 0 && e(y).then((v) => {
      var w;
      i && Array.isArray(v) && v.sort(i);
      for (let C = 0; C < p.length; C++) {
        const { pendingPromise: x } = p[C];
        (w = x.resolve) == null || w.call(x, [v[C], v]);
      }
    }).catch((v) => {
      var w;
      for (let C = 0; C < p.length; C++) {
        const { pendingPromise: x } = p[C];
        (w = x.reject) == null || w.call(x, v);
      }
    });
  }, s = () => nO.delete(t), c = () => u().map(({ args: p }) => p), u = () => nO.get(t) || [], f = (p) => nO.set(t, [...u(), p]);
  return {
    flush: s,
    async schedule(p) {
      const y = {}, v = new Promise((x, A) => {
        y.resolve = x, y.reject = A;
      });
      return (n == null ? void 0 : n([...c(), p])) && o(), u().length > 0 ? (f({ args: p, pendingPromise: y }), v) : (f({ args: p, pendingPromise: y }), setTimeout(o, r), v);
    }
  };
}
async function V8(e, t) {
  var Q, Y, ee, ie;
  const { account: n = e.account, batch: r = !!((Q = e.batch) != null && Q.multicall), blockNumber: i, blockTag: o = "latest", accessList: s, blobs: c, code: u, data: f, factory: p, factoryData: y, gas: v, gasPrice: w, maxFeePerBlobGas: C, maxFeePerGas: x, maxPriorityFeePerGas: A, nonce: R, to: I, value: D, stateOverride: M, ...L } = t, j = n ? nc(n) : void 0;
  if (u && (p || y))
    throw new it("Cannot provide both `code` & `factory`/`factoryData` as parameters.");
  if (u && I)
    throw new it("Cannot provide both `code` & `to` as parameters.");
  const F = u && f, O = p && y && I && f, z = F || O, H = F ? Eye({
    code: u,
    data: f
  }) : O ? Sye({
    data: f,
    factory: p,
    factoryData: y,
    to: I
  }) : f;
  try {
    VC(t);
    const Z = (i ? en(i) : void 0) || o, J = OH(M), K = (ie = (ee = (Y = e.chain) == null ? void 0 : Y.formatters) == null ? void 0 : ee.transactionRequest) == null ? void 0 : ie.format, be = (K || UC)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...N8(L, { format: K }),
      from: j == null ? void 0 : j.address,
      accessList: s,
      blobs: c,
      data: H,
      gas: v,
      gasPrice: w,
      maxFeePerBlobGas: C,
      maxFeePerGas: x,
      maxPriorityFeePerGas: A,
      nonce: R,
      to: z ? void 0 : I,
      value: D
    });
    if (r && Cye({ request: be }) && !J)
      try {
        return await xye(e, {
          ...be,
          blockNumber: i,
          blockTag: o
        });
      } catch (pe) {
        if (!(pe instanceof wH) && !(pe instanceof c5))
          throw pe;
      }
    const ce = await e.request({
      method: "eth_call",
      params: J ? [
        be,
        Z,
        J
      ] : [be, Z]
    });
    return ce === "0x" ? { data: void 0 } : { data: ce };
  } catch (X) {
    const Z = kye(X), { offchainLookup: J, offchainLookupSignature: K } = await import("./ccip-9AQ0BfHe.js");
    if (e.ccipRead !== !1 && (Z == null ? void 0 : Z.slice(0, 10)) === K && I)
      return { data: await J(e, { data: Z, to: I }) };
    throw z && (Z == null ? void 0 : Z.slice(0, 10)) === "0x101bb98d" ? new hye({ factory: p }) : cq(X, {
      ...t,
      account: j,
      chain: e.chain
    });
  }
}
function Cye({ request: e }) {
  const { data: t, to: n, ...r } = e;
  return !(!t || t.startsWith(vye) || !n || Object.values(r).filter((i) => typeof i < "u").length > 0);
}
async function xye(e, t) {
  var x;
  const { batchSize: n = 1024, wait: r = 0 } = typeof ((x = e.batch) == null ? void 0 : x.multicall) == "object" ? e.batch.multicall : {}, { blockNumber: i, blockTag: o = "latest", data: s, multicallAddress: c, to: u } = t;
  let f = c;
  if (!f) {
    if (!e.chain)
      throw new wH();
    f = jb({
      blockNumber: i,
      chain: e.chain,
      contract: "multicall3"
    });
  }
  const y = (i ? en(i) : void 0) || o, { schedule: v } = uq({
    id: `${e.uid}.${y}`,
    wait: r,
    shouldSplitBatch(A) {
      return A.reduce((I, { data: D }) => I + (D.length - 2), 0) > n * 2;
    },
    fn: async (A) => {
      const R = A.map((M) => ({
        allowFailure: !0,
        callData: M.data,
        target: M.to
      })), I = cy({
        abi: b5,
        args: [R],
        functionName: "aggregate3"
      }), D = await e.request({
        method: "eth_call",
        params: [
          {
            data: I,
            to: f
          },
          y
        ]
      });
      return Lb({
        abi: b5,
        args: [R],
        functionName: "aggregate3",
        data: D || "0x"
      });
    }
  }), [{ returnData: w, success: C }] = await v({ data: s, to: u });
  if (!C)
    throw new MM({ data: w });
  return w === "0x" ? { data: void 0 } : { data: w };
}
function Eye(e) {
  const { code: t, data: n } = e;
  return bM({
    abi: nq(["constructor(bytes, bytes)"]),
    bytecode: gye,
    args: [t, n]
  });
}
function Sye(e) {
  const { data: t, factory: n, factoryData: r, to: i } = e;
  return bM({
    abi: nq(["constructor(address, bytes, address, bytes)"]),
    bytecode: bye,
    args: [i, t, n, r]
  });
}
function kye(e) {
  var n;
  if (!(e instanceof it))
    return;
  const t = e.walk();
  return typeof (t == null ? void 0 : t.data) == "object" ? (n = t.data) == null ? void 0 : n.data : t.data;
}
async function ef(e, t) {
  const { abi: n, address: r, args: i, functionName: o, ...s } = t, c = cy({
    abi: n,
    args: i,
    functionName: o
  });
  try {
    const { data: u } = await Dn(e, V8, "call")({
      ...s,
      data: c,
      to: r
    });
    return Lb({
      abi: n,
      args: i,
      functionName: o,
      data: u || "0x"
    });
  } catch (u) {
    throw iC(u, {
      abi: n,
      address: r,
      args: i,
      docsPath: "/docs/contract/readContract",
      functionName: o
    });
  }
}
async function Aye(e, { blockNumber: t, blockTag: n, coinType: r, name: i, gatewayUrls: o, strict: s, universalResolverAddress: c }) {
  let u = c;
  if (!u) {
    if (!e.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    u = jb({
      blockNumber: t,
      chain: e.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const f = cy({
      abi: yF,
      functionName: "addr",
      ...r != null ? { args: [s4(i), BigInt(r)] } : { args: [s4(i)] }
    }), p = {
      address: u,
      abi: HH,
      functionName: "resolve",
      args: [yn(z8(i)), f],
      blockNumber: t,
      blockTag: n
    }, y = Dn(e, ef, "readContract"), v = o ? await y({
      ...p,
      args: [...p.args, o]
    }) : await y(p);
    if (v[0] === "0x")
      return null;
    const w = Lb({
      abi: yF,
      args: r != null ? [s4(i), BigInt(r)] : void 0,
      functionName: "addr",
      data: v[0]
    });
    return w === "0x" || Fu(w) === "0x00" ? null : w;
  } catch (f) {
    if (s)
      throw f;
    if (PM(f, "resolve"))
      return null;
    throw f;
  }
}
class Tye extends it {
  constructor({ data: t }) {
    super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
      metaMessages: [
        "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
        "",
        `Provided data: ${JSON.stringify(t)}`
      ],
      name: "EnsAvatarInvalidMetadataError"
    });
  }
}
class l1 extends it {
  constructor({ reason: t }) {
    super(`ENS NFT avatar URI is invalid. ${t}`, {
      name: "EnsAvatarInvalidNftUriError"
    });
  }
}
class NM extends it {
  constructor({ uri: t }) {
    super(`Unable to resolve ENS avatar URI "${t}". The URI may be malformed, invalid, or does not respond with a valid image.`, { name: "EnsAvatarUriResolutionError" });
  }
}
class _ye extends it {
  constructor({ namespace: t }) {
    super(`ENS NFT avatar namespace "${t}" is not supported. Must be "erc721" or "erc1155".`, { name: "EnsAvatarUnsupportedNamespaceError" });
  }
}
const Rye = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/, Oye = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/, Iye = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/, Dye = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function Mye(e) {
  try {
    const t = await fetch(e, { method: "HEAD" });
    if (t.status === 200) {
      const n = t.headers.get("content-type");
      return n == null ? void 0 : n.startsWith("image/");
    }
    return !1;
  } catch (t) {
    return typeof t == "object" && typeof t.response < "u" || !globalThis.hasOwnProperty("Image") ? !1 : new Promise((n) => {
      const r = new Image();
      r.onload = () => {
        n(!0);
      }, r.onerror = () => {
        n(!1);
      }, r.src = e;
    });
  }
}
function wF(e, t) {
  return e ? e.endsWith("/") ? e.slice(0, -1) : e : t;
}
function dq({ uri: e, gatewayUrls: t }) {
  const n = Iye.test(e);
  if (n)
    return { uri: e, isOnChain: !0, isEncoded: n };
  const r = wF(t == null ? void 0 : t.ipfs, "https://ipfs.io"), i = wF(t == null ? void 0 : t.arweave, "https://arweave.net"), o = e.match(Rye), { protocol: s, subpath: c, target: u, subtarget: f = "" } = (o == null ? void 0 : o.groups) || {}, p = s === "ipns:/" || c === "ipns/", y = s === "ipfs:/" || c === "ipfs/" || Oye.test(e);
  if (e.startsWith("http") && !p && !y) {
    let w = e;
    return t != null && t.arweave && (w = e.replace(/https:\/\/arweave.net/g, t == null ? void 0 : t.arweave)), { uri: w, isOnChain: !1, isEncoded: !1 };
  }
  if ((p || y) && u)
    return {
      uri: `${r}/${p ? "ipns" : "ipfs"}/${u}${f}`,
      isOnChain: !1,
      isEncoded: !1
    };
  if (s === "ar:/" && u)
    return {
      uri: `${i}/${u}${f || ""}`,
      isOnChain: !1,
      isEncoded: !1
    };
  let v = e.replace(Dye, "");
  if (v.startsWith("<svg") && (v = `data:image/svg+xml;base64,${btoa(v)}`), v.startsWith("data:") || v.startsWith("{"))
    return {
      uri: v,
      isOnChain: !0,
      isEncoded: !1
    };
  throw new NM({ uri: e });
}
function fq(e) {
  if (typeof e != "object" || !("image" in e) && !("image_url" in e) && !("image_data" in e))
    throw new Tye({ data: e });
  return e.image || e.image_url || e.image_data;
}
async function Pye({ gatewayUrls: e, uri: t }) {
  try {
    const n = await fetch(t).then((i) => i.json());
    return await BM({
      gatewayUrls: e,
      uri: fq(n)
    });
  } catch {
    throw new NM({ uri: t });
  }
}
async function BM({ gatewayUrls: e, uri: t }) {
  const { uri: n, isOnChain: r } = dq({ uri: t, gatewayUrls: e });
  if (r || await Mye(n))
    return n;
  throw new NM({ uri: t });
}
function Nye(e) {
  let t = e;
  t.startsWith("did:nft:") && (t = t.replace("did:nft:", "").replace(/_/g, "/"));
  const [n, r, i] = t.split("/"), [o, s] = n.split(":"), [c, u] = r.split(":");
  if (!o || o.toLowerCase() !== "eip155")
    throw new l1({ reason: "Only EIP-155 supported" });
  if (!s)
    throw new l1({ reason: "Chain ID not found" });
  if (!u)
    throw new l1({
      reason: "Contract address not found"
    });
  if (!i)
    throw new l1({ reason: "Token ID not found" });
  if (!c)
    throw new l1({ reason: "ERC namespace not found" });
  return {
    chainID: Number.parseInt(s),
    namespace: c.toLowerCase(),
    contractAddress: u,
    tokenID: i
  };
}
async function Bye(e, { nft: t }) {
  if (t.namespace === "erc721")
    return ef(e, {
      address: t.contractAddress,
      abi: [
        {
          name: "tokenURI",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "tokenId", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "tokenURI",
      args: [BigInt(t.tokenID)]
    });
  if (t.namespace === "erc1155")
    return ef(e, {
      address: t.contractAddress,
      abi: [
        {
          name: "uri",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "_id", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "uri",
      args: [BigInt(t.tokenID)]
    });
  throw new _ye({ namespace: t.namespace });
}
async function Lye(e, { gatewayUrls: t, record: n }) {
  return /eip155:/i.test(n) ? jye(e, { gatewayUrls: t, record: n }) : BM({ uri: n, gatewayUrls: t });
}
async function jye(e, { gatewayUrls: t, record: n }) {
  const r = Nye(n), i = await Bye(e, { nft: r }), { uri: o, isOnChain: s, isEncoded: c } = dq({ uri: i, gatewayUrls: t });
  if (s && (o.includes("data:application/json;base64,") || o.startsWith("{"))) {
    const f = c ? (
      // if it is encoded, decode it
      atob(o.replace("data:application/json;base64,", ""))
    ) : (
      // if it isn't encoded assume it is a JSON string, but it could be anything (it will error if it is)
      o
    ), p = JSON.parse(f);
    return BM({ uri: fq(p), gatewayUrls: t });
  }
  let u = r.tokenID;
  return r.namespace === "erc1155" && (u = u.replace("0x", "").padStart(64, "0")), Pye({
    gatewayUrls: t,
    uri: o.replace(/(?:0x)?{id}/, u)
  });
}
async function hq(e, { blockNumber: t, blockTag: n, name: r, key: i, gatewayUrls: o, strict: s, universalResolverAddress: c }) {
  let u = c;
  if (!u) {
    if (!e.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    u = jb({
      blockNumber: t,
      chain: e.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const f = {
      address: u,
      abi: HH,
      functionName: "resolve",
      args: [
        yn(z8(r)),
        cy({
          abi: mF,
          functionName: "text",
          args: [s4(r), i]
        })
      ],
      blockNumber: t,
      blockTag: n
    }, p = Dn(e, ef, "readContract"), y = o ? await p({
      ...f,
      args: [...f.args, o]
    }) : await p(f);
    if (y[0] === "0x")
      return null;
    const v = Lb({
      abi: mF,
      functionName: "text",
      data: y[0]
    });
    return v === "" ? null : v;
  } catch (f) {
    if (s)
      throw f;
    if (PM(f, "resolve"))
      return null;
    throw f;
  }
}
async function pq(e, { blockNumber: t, blockTag: n, assetGatewayUrls: r, name: i, gatewayUrls: o, strict: s, universalResolverAddress: c }) {
  const u = await Dn(e, hq, "getEnsText")({
    blockNumber: t,
    blockTag: n,
    key: "avatar",
    name: i,
    universalResolverAddress: c,
    gatewayUrls: o,
    strict: s
  });
  if (!u)
    return null;
  try {
    return await Lye(e, {
      record: u,
      gatewayUrls: r
    });
  } catch {
    return null;
  }
}
async function mq(e, { address: t, blockNumber: n, blockTag: r, gatewayUrls: i, strict: o, universalResolverAddress: s }) {
  let c = s;
  if (!c) {
    if (!e.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    c = jb({
      blockNumber: n,
      chain: e.chain,
      contract: "ensUniversalResolver"
    });
  }
  const u = `${t.toLowerCase().substring(2)}.addr.reverse`;
  try {
    const f = {
      address: c,
      abi: lme,
      functionName: "reverse",
      args: [yn(z8(u))],
      blockNumber: n,
      blockTag: r
    }, p = Dn(e, ef, "readContract"), [y, v] = i ? await p({
      ...f,
      args: [...f.args, i]
    }) : await p(f);
    return t.toLowerCase() !== v.toLowerCase() ? null : y;
  } catch (f) {
    if (o)
      throw f;
    if (PM(f, "reverse"))
      return null;
    throw f;
  }
}
async function Fye(e, { blockNumber: t, blockTag: n, name: r, universalResolverAddress: i }) {
  let o = i;
  if (!o) {
    if (!e.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    o = jb({
      blockNumber: t,
      chain: e.chain,
      contract: "ensUniversalResolver"
    });
  }
  const [s] = await Dn(e, ef, "readContract")({
    address: o,
    abi: [
      {
        inputs: [{ type: "bytes" }],
        name: "findResolver",
        outputs: [{ type: "address" }, { type: "bytes32" }],
        stateMutability: "view",
        type: "function"
      }
    ],
    functionName: "findResolver",
    args: [yn(z8(r))],
    blockNumber: t,
    blockTag: n
  });
  return s;
}
function $8(e, { method: t }) {
  var r, i;
  const n = {};
  return e.transport.type === "fallback" && ((i = (r = e.transport).onResponse) == null || i.call(r, ({ method: o, response: s, status: c, transport: u }) => {
    c === "success" && t === o && (n[s] = u.request);
  })), (o) => n[o] || e.request;
}
async function Uye(e) {
  const t = $8(e, {
    method: "eth_newBlockFilter"
  }), n = await e.request({
    method: "eth_newBlockFilter"
  });
  return { id: n, request: t(n), type: "block" };
}
class zye extends it {
  constructor(t) {
    super(`Filter type "${t}" is not supported.`, {
      name: "FilterTypeNotSupportedError"
    });
  }
}
const CF = "/docs/contract/encodeEventTopics";
function qC(e) {
  var u;
  const { abi: t, eventName: n, args: r } = e;
  let i = t[0];
  if (n) {
    const f = HC({ abi: t, name: n });
    if (!f)
      throw new tF(n, { docsPath: CF });
    i = f;
  }
  if (i.type !== "event")
    throw new tF(void 0, { docsPath: CF });
  const o = Xd(i), s = U8(o);
  let c = [];
  if (r && "inputs" in i) {
    const f = (u = i.inputs) == null ? void 0 : u.filter((y) => "indexed" in y && y.indexed), p = Array.isArray(r) ? r : Object.values(r).length > 0 ? (f == null ? void 0 : f.map((y) => r[y.name])) ?? [] : [];
    p.length > 0 && (c = (f == null ? void 0 : f.map((y, v) => Array.isArray(p[v]) ? p[v].map((w, C) => xF({ param: y, value: p[v][C] })) : p[v] ? xF({ param: y, value: p[v] }) : null)) ?? []);
  }
  return [s, ...c];
}
function xF({ param: e, value: t }) {
  if (e.type === "string" || e.type === "bytes")
    return zo(qh(t));
  if (e.type === "tuple" || e.type.match(/^(.*)\[(\d+)?\]$/))
    throw new zye(e.type);
  return Nb([e], [t]);
}
async function yq(e, t) {
  const { address: n, abi: r, args: i, eventName: o, fromBlock: s, strict: c, toBlock: u } = t, f = $8(e, {
    method: "eth_newFilter"
  }), p = o ? qC({
    abi: r,
    args: i,
    eventName: o
  }) : void 0, y = await e.request({
    method: "eth_newFilter",
    params: [
      {
        address: n,
        fromBlock: typeof s == "bigint" ? en(s) : s,
        toBlock: typeof u == "bigint" ? en(u) : u,
        topics: p
      }
    ]
  });
  return {
    abi: r,
    args: i,
    eventName: o,
    id: y,
    request: f(y),
    strict: !!c,
    type: "event"
  };
}
async function vq(e, { address: t, args: n, event: r, events: i, fromBlock: o, strict: s, toBlock: c } = {}) {
  const u = i ?? (r ? [r] : void 0), f = $8(e, {
    method: "eth_newFilter"
  });
  let p = [];
  u && (p = [u.flatMap((w) => qC({
    abi: [w],
    eventName: w.name,
    args: n
  }))], r && (p = p[0]));
  const y = await e.request({
    method: "eth_newFilter",
    params: [
      {
        address: t,
        fromBlock: typeof o == "bigint" ? en(o) : o,
        toBlock: typeof c == "bigint" ? en(c) : c,
        ...p.length ? { topics: p } : {}
      }
    ]
  });
  return {
    abi: u,
    args: n,
    eventName: r ? r.name : void 0,
    fromBlock: o,
    id: y,
    request: f(y),
    strict: !!s,
    toBlock: c,
    type: "event"
  };
}
async function gq(e) {
  const t = $8(e, {
    method: "eth_newPendingTransactionFilter"
  }), n = await e.request({
    method: "eth_newPendingTransactionFilter"
  });
  return { id: n, request: t(n), type: "transaction" };
}
async function Vye(e, t) {
  const { abi: n, address: r, args: i, functionName: o, ...s } = t, c = cy({
    abi: n,
    args: i,
    functionName: o
  });
  try {
    return await Dn(e, L8, "estimateGas")({
      data: c,
      to: r,
      ...s
    });
  } catch (u) {
    const f = s.account ? nc(s.account) : void 0;
    throw iC(u, {
      abi: n,
      address: r,
      args: i,
      docsPath: "/docs/contract/estimateContractGas",
      functionName: o,
      sender: f == null ? void 0 : f.address
    });
  }
}
async function $ye(e) {
  const t = await e.request({
    method: "eth_blobBaseFee"
  });
  return BigInt(t);
}
const Hye = /* @__PURE__ */ new Map(), qye = /* @__PURE__ */ new Map();
function Wye(e) {
  const t = (i, o) => ({
    clear: () => o.delete(i),
    get: () => o.get(i),
    set: (s) => o.set(i, s)
  }), n = t(e, Hye), r = t(e, qye);
  return {
    clear: () => {
      n.clear(), r.clear();
    },
    promise: n,
    response: r
  };
}
async function Gye(e, { cacheKey: t, cacheTime: n = Number.POSITIVE_INFINITY }) {
  const r = Wye(t), i = r.response.get();
  if (i && n > 0 && (/* @__PURE__ */ new Date()).getTime() - i.created.getTime() < n)
    return i.data;
  let o = r.promise.get();
  o || (o = e(), r.promise.set(o));
  try {
    const s = await o;
    return r.response.set({ created: /* @__PURE__ */ new Date(), data: s }), s;
  } finally {
    r.promise.clear();
  }
}
const Kye = (e) => `blockNumber.${e}`;
async function WC(e, { cacheTime: t = e.cacheTime } = {}) {
  const n = await Gye(() => e.request({
    method: "eth_blockNumber"
  }), { cacheKey: Kye(e.uid), cacheTime: t });
  return BigInt(n);
}
async function Yye(e, { blockHash: t, blockNumber: n, blockTag: r = "latest" } = {}) {
  const i = n !== void 0 ? en(n) : void 0;
  let o;
  return t ? o = await e.request({
    method: "eth_getBlockTransactionCountByHash",
    params: [t]
  }, { dedupe: !0 }) : o = await e.request({
    method: "eth_getBlockTransactionCountByNumber",
    params: [i || r]
  }, { dedupe: !!i }), Uu(o);
}
async function EF(e, { address: t, blockNumber: n, blockTag: r = "latest" }) {
  const i = n !== void 0 ? en(n) : void 0, o = await e.request({
    method: "eth_getCode",
    params: [t, i || r]
  }, { dedupe: !!i });
  if (o !== "0x")
    return o;
}
function LM(e, t) {
  if (!co(e, { strict: !1 }))
    throw new Ba({ address: e });
  if (!co(t, { strict: !1 }))
    throw new Ba({ address: t });
  return e.toLowerCase() === t.toLowerCase();
}
const SF = "/docs/contract/decodeEventLog";
function jM(e) {
  const { abi: t, data: n, strict: r, topics: i } = e, o = r ?? !0, [s, ...c] = i;
  if (!s)
    throw new The({ docsPath: SF });
  const u = t.length === 1 ? t[0] : t.find((x) => x.type === "event" && s === U8(Xd(x)));
  if (!(u && "name" in u) || u.type !== "event")
    throw new oH(s, { docsPath: SF });
  const { name: f, inputs: p } = u, y = p == null ? void 0 : p.some((x) => !("name" in x && x.name));
  let v = y ? [] : {};
  const w = p.filter((x) => "indexed" in x && x.indexed);
  for (let x = 0; x < w.length; x++) {
    const A = w[x], R = c[x];
    if (!R)
      throw new I8({
        abiItem: u,
        param: A
      });
    v[y ? x : A.name || x] = Qye({ param: A, value: R });
  }
  const C = p.filter((x) => !("indexed" in x && x.indexed));
  if (C.length > 0) {
    if (n && n !== "0x")
      try {
        const x = F8(C, n);
        if (x)
          if (y)
            v = [...v, ...x];
          else
            for (let A = 0; A < C.length; A++)
              v[C[A].name] = x[A];
      } catch (x) {
        if (o)
          throw x instanceof rH || x instanceof yH ? new $1({
            abiItem: u,
            data: n,
            params: C,
            size: Ni(n)
          }) : x;
      }
    else if (o)
      throw new $1({
        abiItem: u,
        data: "0x",
        params: C,
        size: 0
      });
  }
  return {
    eventName: f,
    args: Object.values(v).length > 0 ? v : void 0
  };
}
function Qye({ param: e, value: t }) {
  return e.type === "string" || e.type === "bytes" || e.type === "tuple" || e.type.match(/^(.*)\[(\d+)?\]$/) ? t : (F8([e], t) || [])[0];
}
function FM(e) {
  const { abi: t, args: n, logs: r, strict: i = !0 } = e, o = (() => {
    if (e.eventName)
      return Array.isArray(e.eventName) ? e.eventName : [e.eventName];
  })();
  return r.map((s) => {
    var c;
    try {
      const u = t.find((p) => p.type === "event" && s.topics[0] === U8(p));
      if (!u)
        return null;
      const f = jM({
        ...s,
        abi: [u],
        strict: i
      });
      return o && !o.includes(f.eventName) || !Xye({
        args: f.args,
        inputs: u.inputs,
        matchArgs: n
      }) ? null : { ...f, ...s };
    } catch (u) {
      let f, p;
      if (u instanceof oH)
        return null;
      if (u instanceof $1 || u instanceof I8) {
        if (i)
          return null;
        f = u.abiItem.name, p = (c = u.abiItem.inputs) == null ? void 0 : c.some((y) => !("name" in y && y.name));
      }
      return { ...s, args: p ? [] : {}, eventName: f };
    }
  }).filter(Boolean);
}
function Xye(e) {
  const { args: t, inputs: n, matchArgs: r } = e;
  if (!r)
    return !0;
  if (!t)
    return !1;
  function i(o, s, c) {
    try {
      return o.type === "address" ? LM(s, c) : o.type === "string" || o.type === "bytes" ? zo(qh(s)) === c : s === c;
    } catch {
      return !1;
    }
  }
  return Array.isArray(t) && Array.isArray(r) ? r.every((o, s) => {
    if (o === null)
      return !0;
    const c = n[s];
    return c ? (Array.isArray(o) ? o : [o]).some((f) => i(c, f, t[s])) : !1;
  }) : typeof t == "object" && !Array.isArray(t) && typeof r == "object" && !Array.isArray(r) ? Object.entries(r).every(([o, s]) => {
    if (s === null)
      return !0;
    const c = n.find((f) => f.name === o);
    return c ? (Array.isArray(s) ? s : [s]).some((f) => i(c, f, t[o])) : !1;
  }) : !1;
}
function Kh(e, { args: t, eventName: n } = {}) {
  return {
    ...e,
    blockHash: e.blockHash ? e.blockHash : null,
    blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
    logIndex: e.logIndex ? Number(e.logIndex) : null,
    transactionHash: e.transactionHash ? e.transactionHash : null,
    transactionIndex: e.transactionIndex ? Number(e.transactionIndex) : null,
    ...n ? { args: t, eventName: n } : {}
  };
}
async function UM(e, { address: t, blockHash: n, fromBlock: r, toBlock: i, event: o, events: s, args: c, strict: u } = {}) {
  const f = u ?? !1, p = s ?? (o ? [o] : void 0);
  let y = [];
  p && (y = [p.flatMap((x) => qC({
    abi: [x],
    eventName: x.name,
    args: s ? void 0 : c
  }))], o && (y = y[0]));
  let v;
  n ? v = await e.request({
    method: "eth_getLogs",
    params: [{ address: t, topics: y, blockHash: n }]
  }) : v = await e.request({
    method: "eth_getLogs",
    params: [
      {
        address: t,
        topics: y,
        fromBlock: typeof r == "bigint" ? en(r) : r,
        toBlock: typeof i == "bigint" ? en(i) : i
      }
    ]
  });
  const w = v.map((C) => Kh(C));
  return p ? FM({
    abi: p,
    args: c,
    logs: w,
    strict: f
  }) : w;
}
async function bq(e, t) {
  const { abi: n, address: r, args: i, blockHash: o, eventName: s, fromBlock: c, toBlock: u, strict: f } = t, p = s ? HC({ abi: n, name: s }) : void 0, y = p ? void 0 : n.filter((v) => v.type === "event");
  return Dn(e, UM, "getLogs")({
    address: r,
    args: i,
    blockHash: o,
    event: p,
    events: y,
    fromBlock: c,
    toBlock: u,
    strict: f
  });
}
class Jye extends it {
  constructor({ address: t }) {
    super(`No EIP-712 domain found on contract "${t}".`, {
      metaMessages: [
        "Ensure that:",
        `- The contract is deployed at the address "${t}".`,
        "- `eip712Domain()` function exists on the contract.",
        "- `eip712Domain()` function matches signature to ERC-5267 specification."
      ],
      name: "Eip712DomainNotFoundError"
    });
  }
}
async function Zye(e, t) {
  const { address: n, factory: r, factoryData: i } = t;
  try {
    const [o, s, c, u, f, p, y] = await Dn(e, ef, "readContract")({
      abi: eve,
      address: n,
      functionName: "eip712Domain",
      factory: r,
      factoryData: i
    });
    return {
      domain: {
        name: s,
        version: c,
        chainId: Number(u),
        verifyingContract: f,
        salt: p
      },
      extensions: y,
      fields: o
    };
  } catch (o) {
    const s = o;
    throw s.name === "ContractFunctionExecutionError" && s.cause.name === "ContractFunctionZeroDataError" ? new Jye({ address: n }) : s;
  }
}
const eve = [
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      { name: "fields", type: "bytes1" },
      { name: "name", type: "string" },
      { name: "version", type: "string" },
      { name: "chainId", type: "uint256" },
      { name: "verifyingContract", type: "address" },
      { name: "salt", type: "bytes32" },
      { name: "extensions", type: "uint256[]" }
    ],
    stateMutability: "view",
    type: "function"
  }
];
function tve(e) {
  var t;
  return {
    baseFeePerGas: e.baseFeePerGas.map((n) => BigInt(n)),
    gasUsedRatio: e.gasUsedRatio,
    oldestBlock: BigInt(e.oldestBlock),
    reward: (t = e.reward) == null ? void 0 : t.map((n) => n.map((r) => BigInt(r)))
  };
}
async function nve(e, { blockCount: t, blockNumber: n, blockTag: r = "latest", rewardPercentiles: i }) {
  const o = n ? en(n) : void 0, s = await e.request({
    method: "eth_feeHistory",
    params: [
      en(t),
      o || r,
      i
    ]
  }, { dedupe: !!o });
  return tve(s);
}
async function H8(e, { filter: t }) {
  const n = "strict" in t && t.strict, r = await t.request({
    method: "eth_getFilterChanges",
    params: [t.id]
  });
  if (typeof r[0] == "string")
    return r;
  const i = r.map((o) => Kh(o));
  return !("abi" in t) || !t.abi ? i : FM({
    abi: t.abi,
    logs: i,
    strict: n
  });
}
async function rve(e, { filter: t }) {
  const n = t.strict ?? !1, i = (await t.request({
    method: "eth_getFilterLogs",
    params: [t.id]
  })).map((o) => Kh(o));
  return t.abi ? FM({
    abi: t.abi,
    logs: i,
    strict: n
  }) : i;
}
async function ive(e, { address: t, blockNumber: n, blockTag: r = "latest", slot: i }) {
  const o = n !== void 0 ? en(n) : void 0;
  return await e.request({
    method: "eth_getStorageAt",
    params: [t, i, o || r]
  });
}
async function zM(e, { blockHash: t, blockNumber: n, blockTag: r, hash: i, index: o }) {
  var p, y, v;
  const s = r || "latest", c = n !== void 0 ? en(n) : void 0;
  let u = null;
  if (i ? u = await e.request({
    method: "eth_getTransactionByHash",
    params: [i]
  }, { dedupe: !0 }) : t ? u = await e.request({
    method: "eth_getTransactionByBlockHashAndIndex",
    params: [t, en(o)]
  }, { dedupe: !0 }) : (c || s) && (u = await e.request({
    method: "eth_getTransactionByBlockNumberAndIndex",
    params: [c || s, en(o)]
  }, { dedupe: !!c })), !u)
    throw new xH({
      blockHash: t,
      blockNumber: n,
      blockTag: s,
      hash: i,
      index: o
    });
  return (((v = (y = (p = e.chain) == null ? void 0 : p.formatters) == null ? void 0 : y.transaction) == null ? void 0 : v.format) || $C)(u);
}
async function ove(e, { hash: t, transactionReceipt: n }) {
  const [r, i] = await Promise.all([
    Dn(e, WC, "getBlockNumber")({}),
    t ? Dn(e, zM, "getTransaction")({ hash: t }) : void 0
  ]), o = (n == null ? void 0 : n.blockNumber) || (i == null ? void 0 : i.blockNumber);
  return o ? r - o + 1n : 0n;
}
const ave = {
  "0x0": "reverted",
  "0x1": "success"
};
function wq(e) {
  const t = {
    ...e,
    blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
    contractAddress: e.contractAddress ? e.contractAddress : null,
    cumulativeGasUsed: e.cumulativeGasUsed ? BigInt(e.cumulativeGasUsed) : null,
    effectiveGasPrice: e.effectiveGasPrice ? BigInt(e.effectiveGasPrice) : null,
    gasUsed: e.gasUsed ? BigInt(e.gasUsed) : null,
    logs: e.logs ? e.logs.map((n) => Kh(n)) : null,
    to: e.to ? e.to : null,
    transactionIndex: e.transactionIndex ? Uu(e.transactionIndex) : null,
    status: e.status ? ave[e.status] : null,
    type: e.type ? AH[e.type] || e.type : null
  };
  return e.blobGasPrice && (t.blobGasPrice = BigInt(e.blobGasPrice)), e.blobGasUsed && (t.blobGasUsed = BigInt(e.blobGasUsed)), t;
}
const sve = /* @__PURE__ */ B8("transactionReceipt", wq);
async function A5(e, { hash: t }) {
  var i, o, s;
  const n = await e.request({
    method: "eth_getTransactionReceipt",
    params: [t]
  }, { dedupe: !0 });
  if (!n)
    throw new EH({ hash: t });
  return (((s = (o = (i = e.chain) == null ? void 0 : i.formatters) == null ? void 0 : o.transactionReceipt) == null ? void 0 : s.format) || wq)(n);
}
async function lve(e, t) {
  var A;
  const { allowFailure: n = !0, batchSize: r, blockNumber: i, blockTag: o, multicallAddress: s, stateOverride: c } = t, u = t.contracts, f = r ?? (typeof ((A = e.batch) == null ? void 0 : A.multicall) == "object" && e.batch.multicall.batchSize || 1024);
  let p = s;
  if (!p) {
    if (!e.chain)
      throw new Error("client chain not configured. multicallAddress is required.");
    p = jb({
      blockNumber: i,
      chain: e.chain,
      contract: "multicall3"
    });
  }
  const y = [[]];
  let v = 0, w = 0;
  for (let R = 0; R < u.length; R++) {
    const { abi: I, address: D, args: M, functionName: L } = u[R];
    try {
      const j = cy({ abi: I, args: M, functionName: L });
      w += (j.length - 2) / 2, // Check if batching is enabled.
      f > 0 && // Check if the current size of the batch exceeds the size limit.
      w > f && // Check if the current chunk is not already empty.
      y[v].length > 0 && (v++, w = (j.length - 2) / 2, y[v] = []), y[v] = [
        ...y[v],
        {
          allowFailure: !0,
          callData: j,
          target: D
        }
      ];
    } catch (j) {
      const F = iC(j, {
        abi: I,
        address: D,
        args: M,
        docsPath: "/docs/contract/multicall",
        functionName: L
      });
      if (!n)
        throw F;
      y[v] = [
        ...y[v],
        {
          allowFailure: !0,
          callData: "0x",
          target: D
        }
      ];
    }
  }
  const C = await Promise.allSettled(y.map((R) => Dn(e, ef, "readContract")({
    abi: b5,
    address: p,
    args: [R],
    blockNumber: i,
    blockTag: o,
    functionName: "aggregate3",
    stateOverride: c
  }))), x = [];
  for (let R = 0; R < C.length; R++) {
    const I = C[R];
    if (I.status === "rejected") {
      if (!n)
        throw I.reason;
      for (let M = 0; M < y[R].length; M++)
        x.push({
          status: "failure",
          error: I.reason,
          result: void 0
        });
      continue;
    }
    const D = I.value;
    for (let M = 0; M < D.length; M++) {
      const { returnData: L, success: j } = D[M], { callData: F } = y[R][M], { abi: O, address: z, functionName: H, args: Q } = u[x.length];
      try {
        if (F === "0x")
          throw new O8();
        if (!j)
          throw new MM({ data: L });
        const Y = Lb({
          abi: O,
          args: Q,
          data: L,
          functionName: H
        });
        x.push(n ? { result: Y, status: "success" } : Y);
      } catch (Y) {
        const ee = iC(Y, {
          abi: O,
          address: z,
          args: Q,
          docsPath: "/docs/contract/multicall",
          functionName: H
        });
        if (!n)
          throw ee;
        x.push({ error: ee, result: void 0, status: "failure" });
      }
    }
  }
  if (x.length !== u.length)
    throw new it("multicall results mismatch");
  return x;
}
const rO = /* @__PURE__ */ new Map(), kF = /* @__PURE__ */ new Map();
let cve = 0;
function Yh(e, t, n) {
  const r = ++cve, i = () => rO.get(e) || [], o = () => {
    const p = i();
    rO.set(e, p.filter((y) => y.id !== r));
  }, s = () => {
    const p = kF.get(e);
    i().length === 1 && p && p(), o();
  }, c = i();
  if (rO.set(e, [
    ...c,
    { id: r, fns: t }
  ]), c && c.length > 0)
    return s;
  const u = {};
  for (const p in t)
    u[p] = (...y) => {
      var w, C;
      const v = i();
      if (v.length !== 0)
        for (const x of v)
          (C = (w = x.fns)[p]) == null || C.call(w, ...y);
    };
  const f = n(u);
  return typeof f == "function" && kF.set(e, f), s;
}
async function T5(e) {
  return new Promise((t) => setTimeout(t, e));
}
function GC(e, { emitOnBegin: t, initialWaitTime: n, interval: r }) {
  let i = !0;
  const o = () => i = !1;
  return (async () => {
    let c;
    t && (c = await e({ unpoll: o }));
    const u = await (n == null ? void 0 : n(c)) ?? r;
    await T5(u);
    const f = async () => {
      i && (await e({ unpoll: o }), await T5(r), f());
    };
    f();
  })(), o;
}
function uve(e, { blockTag: t = "latest", emitMissed: n = !1, emitOnBegin: r = !1, onBlock: i, onError: o, includeTransactions: s, poll: c, pollingInterval: u = e.pollingInterval }) {
  const f = typeof c < "u" ? c : !(e.transport.type === "webSocket" || e.transport.type === "fallback" && e.transport.transports[0].config.type === "webSocket"), p = s ?? !1;
  let y;
  return f ? (() => {
    const C = Pa([
      "watchBlocks",
      e.uid,
      t,
      n,
      r,
      p,
      u
    ]);
    return Yh(C, { onBlock: i, onError: o }, (x) => GC(async () => {
      var A;
      try {
        const R = await Dn(e, Gh, "getBlock")({
          blockTag: t,
          includeTransactions: p
        });
        if (R.number && (y != null && y.number)) {
          if (R.number === y.number)
            return;
          if (R.number - y.number > 1 && n)
            for (let I = (y == null ? void 0 : y.number) + 1n; I < R.number; I++) {
              const D = await Dn(e, Gh, "getBlock")({
                blockNumber: I,
                includeTransactions: p
              });
              x.onBlock(D, y), y = D;
            }
        }
        // If no previous block exists, emit.
        (!(y != null && y.number) || // If the block tag is "pending" with no block number, emit.
        t === "pending" && !(R != null && R.number) || // If the next block number is greater than the previous block number, emit.
        // We don't want to emit blocks in the past.
        R.number && R.number > y.number) && (x.onBlock(R, y), y = R);
      } catch (R) {
        (A = x.onError) == null || A.call(x, R);
      }
    }, {
      emitOnBegin: r,
      interval: u
    }));
  })() : (() => {
    let C = !0, x = () => C = !1;
    return (async () => {
      try {
        const A = (() => {
          if (e.transport.type === "fallback") {
            const I = e.transport.transports.find((D) => D.config.type === "webSocket");
            return I ? I.value : e.transport;
          }
          return e.transport;
        })(), { unsubscribe: R } = await A.subscribe({
          params: ["newHeads"],
          onData(I) {
            var L, j, F;
            if (!C)
              return;
            const M = (((F = (j = (L = e.chain) == null ? void 0 : L.formatters) == null ? void 0 : j.block) == null ? void 0 : F.format) || TM)(I.result);
            i(M, y), y = M;
          },
          onError(I) {
            o == null || o(I);
          }
        });
        x = R, C || x();
      } catch (A) {
        o == null || o(A);
      }
    })(), () => x();
  })();
}
function Cq(e, { emitOnBegin: t = !1, emitMissed: n = !1, onBlockNumber: r, onError: i, poll: o, pollingInterval: s = e.pollingInterval }) {
  const c = typeof o < "u" ? o : !(e.transport.type === "webSocket" || e.transport.type === "fallback" && e.transport.transports[0].config.type === "webSocket");
  let u;
  return c ? (() => {
    const y = Pa([
      "watchBlockNumber",
      e.uid,
      t,
      n,
      s
    ]);
    return Yh(y, { onBlockNumber: r, onError: i }, (v) => GC(async () => {
      var w;
      try {
        const C = await Dn(e, WC, "getBlockNumber")({ cacheTime: 0 });
        if (u) {
          if (C === u)
            return;
          if (C - u > 1 && n)
            for (let x = u + 1n; x < C; x++)
              v.onBlockNumber(x, u), u = x;
        }
        (!u || C > u) && (v.onBlockNumber(C, u), u = C);
      } catch (C) {
        (w = v.onError) == null || w.call(v, C);
      }
    }, {
      emitOnBegin: t,
      interval: s
    }));
  })() : (() => {
    const y = Pa([
      "watchBlockNumber",
      e.uid,
      t,
      n
    ]);
    return Yh(y, { onBlockNumber: r, onError: i }, (v) => {
      let w = !0, C = () => w = !1;
      return (async () => {
        try {
          const x = (() => {
            if (e.transport.type === "fallback") {
              const R = e.transport.transports.find((I) => I.config.type === "webSocket");
              return R ? R.value : e.transport;
            }
            return e.transport;
          })(), { unsubscribe: A } = await x.subscribe({
            params: ["newHeads"],
            onData(R) {
              var D;
              if (!w)
                return;
              const I = Da((D = R.result) == null ? void 0 : D.number);
              v.onBlockNumber(I, u), u = I;
            },
            onError(R) {
              var I;
              (I = v.onError) == null || I.call(v, R);
            }
          });
          C = A, w || C();
        } catch (x) {
          i == null || i(x);
        }
      })(), () => C();
    });
  })();
}
async function q8(e, { filter: t }) {
  return t.request({
    method: "eth_uninstallFilter",
    params: [t.id]
  });
}
function dve(e, { address: t, args: n, batch: r = !0, event: i, events: o, fromBlock: s, onError: c, onLogs: u, poll: f, pollingInterval: p = e.pollingInterval, strict: y }) {
  const v = typeof f < "u" ? f : typeof s == "bigint" ? !0 : !(e.transport.type === "webSocket" || e.transport.type === "fallback" && e.transport.transports[0].config.type === "webSocket"), w = y ?? !1;
  return v ? (() => {
    const A = Pa([
      "watchEvent",
      t,
      n,
      r,
      e.uid,
      i,
      p,
      s
    ]);
    return Yh(A, { onLogs: u, onError: c }, (R) => {
      let I;
      s !== void 0 && (I = s - 1n);
      let D, M = !1;
      const L = GC(async () => {
        var j;
        if (!M) {
          try {
            D = await Dn(e, vq, "createEventFilter")({
              address: t,
              args: n,
              event: i,
              events: o,
              strict: w,
              fromBlock: s
            });
          } catch {
          }
          M = !0;
          return;
        }
        try {
          let F;
          if (D)
            F = await Dn(e, H8, "getFilterChanges")({ filter: D });
          else {
            const O = await Dn(e, WC, "getBlockNumber")({});
            I && I !== O ? F = await Dn(e, UM, "getLogs")({
              address: t,
              args: n,
              event: i,
              events: o,
              fromBlock: I + 1n,
              toBlock: O
            }) : F = [], I = O;
          }
          if (F.length === 0)
            return;
          if (r)
            R.onLogs(F);
          else
            for (const O of F)
              R.onLogs([O]);
        } catch (F) {
          D && F instanceof Xm && (M = !1), (j = R.onError) == null || j.call(R, F);
        }
      }, {
        emitOnBegin: !0,
        interval: p
      });
      return async () => {
        D && await Dn(e, q8, "uninstallFilter")({ filter: D }), L();
      };
    });
  })() : (() => {
    let A = !0, R = () => A = !1;
    return (async () => {
      try {
        const I = (() => {
          if (e.transport.type === "fallback") {
            const j = e.transport.transports.find((F) => F.config.type === "webSocket");
            return j ? j.value : e.transport;
          }
          return e.transport;
        })(), D = o ?? (i ? [i] : void 0);
        let M = [];
        D && (M = [D.flatMap((F) => qC({
          abi: [F],
          eventName: F.name,
          args: n
        }))], i && (M = M[0]));
        const { unsubscribe: L } = await I.subscribe({
          params: ["logs", { address: t, topics: M }],
          onData(j) {
            var O;
            if (!A)
              return;
            const F = j.result;
            try {
              const { eventName: z, args: H } = jM({
                abi: D ?? [],
                data: F.data,
                topics: F.topics,
                strict: w
              }), Q = Kh(F, { args: H, eventName: z });
              u([Q]);
            } catch (z) {
              let H, Q;
              if (z instanceof $1 || z instanceof I8) {
                if (y)
                  return;
                H = z.abiItem.name, Q = (O = z.abiItem.inputs) == null ? void 0 : O.some((ee) => !("name" in ee && ee.name));
              }
              const Y = Kh(F, {
                args: Q ? [] : {},
                eventName: H
              });
              u([Y]);
            }
          },
          onError(j) {
            c == null || c(j);
          }
        });
        R = L, A || R();
      } catch (I) {
        c == null || c(I);
      }
    })(), () => R();
  })();
}
function fve(e, { batch: t = !0, onError: n, onTransactions: r, poll: i, pollingInterval: o = e.pollingInterval }) {
  return (typeof i < "u" ? i : e.transport.type !== "webSocket") ? (() => {
    const f = Pa([
      "watchPendingTransactions",
      e.uid,
      t,
      o
    ]);
    return Yh(f, { onTransactions: r, onError: n }, (p) => {
      let y;
      const v = GC(async () => {
        var w;
        try {
          if (!y)
            try {
              y = await Dn(e, gq, "createPendingTransactionFilter")({});
              return;
            } catch (x) {
              throw v(), x;
            }
          const C = await Dn(e, H8, "getFilterChanges")({ filter: y });
          if (C.length === 0)
            return;
          if (t)
            p.onTransactions(C);
          else
            for (const x of C)
              p.onTransactions([x]);
        } catch (C) {
          (w = p.onError) == null || w.call(p, C);
        }
      }, {
        emitOnBegin: !0,
        interval: o
      });
      return async () => {
        y && await Dn(e, q8, "uninstallFilter")({ filter: y }), v();
      };
    });
  })() : (() => {
    let f = !0, p = () => f = !1;
    return (async () => {
      try {
        const { unsubscribe: y } = await e.transport.subscribe({
          params: ["newPendingTransactions"],
          onData(v) {
            if (!f)
              return;
            const w = v.result;
            r([w]);
          },
          onError(v) {
            n == null || n(v);
          }
        });
        p = y, f || p();
      } catch (y) {
        n == null || n(y);
      }
    })(), () => p();
  })();
}
const wk = /* @__PURE__ */ new hM(8192);
function hve(e, { enabled: t = !0, id: n }) {
  if (!t || !n)
    return e();
  if (wk.get(n))
    return wk.get(n);
  const r = e().finally(() => wk.delete(n));
  return wk.set(n, r), r;
}
function N4(e, { delay: t = 100, retryCount: n = 2, shouldRetry: r = () => !0 } = {}) {
  return new Promise((i, o) => {
    const s = async ({ count: c = 0 } = {}) => {
      const u = async ({ error: f }) => {
        const p = typeof t == "function" ? t({ count: c, error: f }) : t;
        p && await T5(p), s({ count: c + 1 });
      };
      try {
        const f = await e();
        i(f);
      } catch (f) {
        if (c < n && await r({ count: c, error: f }))
          return u({ error: f });
        o(f);
      }
    };
    s();
  });
}
function pve(e, t = {}) {
  return async (n, r = {}) => {
    const { dedupe: i = !1, retryDelay: o = 150, retryCount: s = 3, uid: c } = {
      ...t,
      ...r
    }, u = i ? zo(Zg(`${c}.${Pa(n)}`)) : void 0;
    return hve(() => N4(async () => {
      try {
        return await e(n);
      } catch (f) {
        const p = f;
        switch (p.code) {
          case q1.code:
            throw new q1(p);
          case W1.code:
            throw new W1(p);
          case G1.code:
            throw new G1(p, { method: n.method });
          case K1.code:
            throw new K1(p);
          case Qm.code:
            throw new Qm(p);
          case Xm.code:
            throw new Xm(p);
          case Y1.code:
            throw new Y1(p);
          case $h.code:
            throw new $h(p);
          case Q1.code:
            throw new Q1(p);
          case X1.code:
            throw new X1(p, {
              method: n.method
            });
          case nb.code:
            throw new nb(p);
          case J1.code:
            throw new J1(p);
          case li.code:
            throw new li(p);
          case Z1.code:
            throw new Z1(p);
          case eC.code:
            throw new eC(p);
          case tC.code:
            throw new tC(p);
          case nC.code:
            throw new nC(p);
          case Xl.code:
            throw new Xl(p);
          case 5e3:
            throw new li(p);
          default:
            throw f instanceof it ? f : new Mpe(p);
        }
      }
    }, {
      delay: ({ count: f, error: p }) => {
        var y;
        if (p && p instanceof M1) {
          const v = (y = p == null ? void 0 : p.headers) == null ? void 0 : y.get("Retry-After");
          if (v != null && v.match(/\d/))
            return Number.parseInt(v) * 1e3;
        }
        return ~~(1 << f) * o;
      },
      retryCount: s,
      shouldRetry: ({ error: f }) => mve(f)
    }), { enabled: i, id: u });
  };
}
function mve(e) {
  return "code" in e && typeof e.code == "number" ? e.code === -1 || e.code === nb.code || e.code === Qm.code : e instanceof M1 && e.status ? e.status === 403 || e.status === 408 || e.status === 413 || e.status === 429 || e.status === 500 || e.status === 502 || e.status === 503 || e.status === 504 : !0;
}
function hl(e) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...e
  };
}
const yve = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, vve = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
function xq(e, { errorInstance: t = new Error("timed out"), timeout: n, signal: r }) {
  return new Promise((i, o) => {
    (async () => {
      let s;
      try {
        const c = new AbortController();
        n > 0 && (s = setTimeout(() => {
          r ? c.abort() : o(t);
        }, n)), i(await e({ signal: (c == null ? void 0 : c.signal) || null }));
      } catch (c) {
        (c == null ? void 0 : c.name) === "AbortError" && o(t), o(c);
      } finally {
        clearTimeout(s);
      }
    })();
  });
}
function gve() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
const AF = /* @__PURE__ */ gve();
function bve(e, t = {}) {
  return {
    async request(n) {
      var y;
      const { body: r, onRequest: i = t.onRequest, onResponse: o = t.onResponse, timeout: s = t.timeout ?? 1e4 } = n, c = {
        ...t.fetchOptions ?? {},
        ...n.fetchOptions ?? {}
      }, { headers: u, method: f, signal: p } = c;
      try {
        const v = await xq(async ({ signal: C }) => {
          const x = {
            ...c,
            body: Array.isArray(r) ? Pa(r.map((I) => ({
              jsonrpc: "2.0",
              id: I.id ?? AF.take(),
              ...I
            }))) : Pa({
              jsonrpc: "2.0",
              id: r.id ?? AF.take(),
              ...r
            }),
            headers: {
              "Content-Type": "application/json",
              ...u
            },
            method: f || "POST",
            signal: p || (s > 0 ? C : null)
          }, A = new Request(e, x);
          return i && await i(A), await fetch(e, x);
        }, {
          errorInstance: new uF({ body: r, url: e }),
          timeout: s,
          signal: !0
        });
        o && await o(v);
        let w;
        if ((y = v.headers.get("Content-Type")) != null && y.startsWith("application/json") ? w = await v.json() : (w = await v.text(), w = JSON.parse(w || "{}")), !v.ok)
          throw new M1({
            body: r,
            details: Pa(w.error) || v.statusText,
            headers: v.headers,
            status: v.status,
            url: e
          });
        return w;
      } catch (v) {
        throw v instanceof M1 || v instanceof uF ? v : new M1({
          body: r,
          cause: v,
          url: e
        });
      }
    }
  };
}
function wve(e) {
  const { domain: t = {}, message: n, primaryType: r } = e, i = {
    EIP712Domain: kve({ domain: t }),
    ...e.types
  };
  Sve({
    domain: t,
    message: n,
    primaryType: r,
    types: i
  });
  const o = ["0x1901"];
  return t && o.push(Cve({
    domain: t,
    types: i
  })), r !== "EIP712Domain" && o.push(Eq({
    data: n,
    primaryType: r,
    types: i
  })), zo(Jd(o));
}
function Cve({ domain: e, types: t }) {
  return Eq({
    data: e,
    primaryType: "EIP712Domain",
    types: t
  });
}
function Eq({ data: e, primaryType: t, types: n }) {
  const r = Sq({
    data: e,
    primaryType: t,
    types: n
  });
  return zo(r);
}
function Sq({ data: e, primaryType: t, types: n }) {
  const r = [{ type: "bytes32" }], i = [xve({ primaryType: t, types: n })];
  for (const o of n[t]) {
    const [s, c] = Aq({
      types: n,
      name: o.name,
      type: o.type,
      value: e[o.name]
    });
    r.push(s), i.push(c);
  }
  return Nb(r, i);
}
function xve({ primaryType: e, types: t }) {
  const n = yn(Eve({ primaryType: e, types: t }));
  return zo(n);
}
function Eve({ primaryType: e, types: t }) {
  let n = "";
  const r = kq({ primaryType: e, types: t });
  r.delete(e);
  const i = [e, ...Array.from(r).sort()];
  for (const o of i)
    n += `${o}(${t[o].map(({ name: s, type: c }) => `${c} ${s}`).join(",")})`;
  return n;
}
function kq({ primaryType: e, types: t }, n = /* @__PURE__ */ new Set()) {
  const r = e.match(/^\w*/u), i = r == null ? void 0 : r[0];
  if (n.has(i) || t[i] === void 0)
    return n;
  n.add(i);
  for (const o of t[i])
    kq({ primaryType: o.type, types: t }, n);
  return n;
}
function Aq({ types: e, name: t, type: n, value: r }) {
  if (e[n] !== void 0)
    return [
      { type: "bytes32" },
      zo(Sq({ data: r, primaryType: n, types: e }))
    ];
  if (n === "bytes")
    return r = `0x${(r.length % 2 ? "0" : "") + r.slice(2)}`, [{ type: "bytes32" }, zo(r)];
  if (n === "string")
    return [{ type: "bytes32" }, zo(yn(r))];
  if (n.lastIndexOf("]") === n.length - 1) {
    const i = n.slice(0, n.lastIndexOf("[")), o = r.map((s) => Aq({
      name: t,
      type: i,
      types: e,
      value: s
    }));
    return [
      { type: "bytes32" },
      zo(Nb(o.map(([s]) => s), o.map(([, s]) => s)))
    ];
  }
  return [{ type: n }, r];
}
function Sve(e) {
  const { domain: t, message: n, primaryType: r, types: i } = e, o = (s, c) => {
    for (const u of s) {
      const { name: f, type: p } = u, y = c[f], v = p.match(vve);
      if (v && (typeof y == "number" || typeof y == "bigint")) {
        const [x, A, R] = v;
        en(y, {
          signed: A === "int",
          size: Number.parseInt(R) / 8
        });
      }
      if (p === "address" && typeof y == "string" && !co(y))
        throw new Ba({ address: y });
      const w = p.match(yve);
      if (w) {
        const [x, A] = w;
        if (A && Ni(y) !== Number.parseInt(A))
          throw new Ohe({
            expectedSize: Number.parseInt(A),
            givenSize: Ni(y)
          });
      }
      const C = i[p];
      C && o(C, y);
    }
  };
  i.EIP712Domain && t && o(i.EIP712Domain, t), r !== "EIP712Domain" && o(i[r], n);
}
function kve({ domain: e }) {
  return [
    typeof (e == null ? void 0 : e.name) == "string" && { name: "name", type: "string" },
    (e == null ? void 0 : e.version) && { name: "version", type: "string" },
    typeof (e == null ? void 0 : e.chainId) == "number" && {
      name: "chainId",
      type: "uint256"
    },
    (e == null ? void 0 : e.verifyingContract) && {
      name: "verifyingContract",
      type: "address"
    },
    (e == null ? void 0 : e.salt) && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}
const Ave = `Ethereum Signed Message:
`;
function Tve(e) {
  const t = typeof e == "string" ? Zg(e) : typeof e.raw == "string" ? e.raw : lo(e.raw), n = Zg(`${Ave}${Ni(t)}`);
  return Jd([n, t]);
}
function Tq(e, t) {
  return zo(Tve(e), t);
}
const _q = "0x6492649264926492649264926492649264926492649264926492649264926492";
function _ve(e) {
  return pH(e, -32) === _q;
}
function Rve(e) {
  const { address: t, data: n, signature: r, to: i = "hex" } = e, o = Wc([
    Nb([{ type: "address" }, { type: "bytes" }, { type: "bytes" }], [t, n, r]),
    _q
  ]);
  return i === "hex" ? o : zc(o);
}
function Ove(e) {
  const { authorizationList: t } = e;
  if (t)
    for (const n of t) {
      const { contractAddress: r, chainId: i } = n;
      if (!co(r))
        throw new Ba({ address: r });
      if (i <= 0)
        throw new jC({ chainId: i });
    }
  VM(e);
}
function Ive(e) {
  const { blobVersionedHashes: t } = e;
  if (t) {
    if (t.length === 0)
      throw new jH();
    for (const n of t) {
      const r = Ni(n), i = Uu(H1(n, 0, 1));
      if (r !== 32)
        throw new ime({ hash: n, size: r });
      if (i !== LH)
        throw new ome({
          hash: n,
          version: i
        });
    }
  }
  VM(e);
}
function VM(e) {
  const { chainId: t, maxPriorityFeePerGas: n, maxFeePerGas: r, to: i } = e;
  if (t <= 0)
    throw new jC({ chainId: t });
  if (i && !co(i))
    throw new Ba({ address: i });
  if (r && r > zC)
    throw new Wh({ maxFeePerGas: r });
  if (n && r && n > r)
    throw new tb({ maxFeePerGas: r, maxPriorityFeePerGas: n });
}
function Dve(e) {
  const { chainId: t, maxPriorityFeePerGas: n, gasPrice: r, maxFeePerGas: i, to: o } = e;
  if (t <= 0)
    throw new jC({ chainId: t });
  if (o && !co(o))
    throw new Ba({ address: o });
  if (n || i)
    throw new it("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
  if (r && r > zC)
    throw new Wh({ maxFeePerGas: r });
}
function Mve(e) {
  const { chainId: t, maxPriorityFeePerGas: n, gasPrice: r, maxFeePerGas: i, to: o } = e;
  if (o && !co(o))
    throw new Ba({ address: o });
  if (typeof t < "u" && t <= 0)
    throw new jC({ chainId: t });
  if (n || i)
    throw new it("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
  if (r && r > zC)
    throw new Wh({ maxFeePerGas: r });
}
function Pve(e) {
  if (!e || e.length === 0)
    return [];
  const t = [];
  for (const n of e) {
    const { contractAddress: r, chainId: i, nonce: o, ...s } = n;
    t.push([
      yn(i),
      r,
      o ? yn(o) : "0x",
      ...Fb({}, s)
    ]);
  }
  return t;
}
function KC(e) {
  if (!e || e.length === 0)
    return [];
  const t = [];
  for (let n = 0; n < e.length; n++) {
    const { address: r, storageKeys: i } = e[n];
    for (let o = 0; o < i.length; o++)
      if (i[o].length - 2 !== 64)
        throw new Rpe({ storageKey: i[o] });
    if (!co(r, { strict: !1 }))
      throw new Ba({ address: r });
    t.push([r, i]);
  }
  return t;
}
function Nve(e, t) {
  const n = UH(e);
  return n === "eip1559" ? jve(e, t) : n === "eip2930" ? Fve(e, t) : n === "eip4844" ? Lve(e, t) : n === "eip7702" ? Bve(e, t) : Uve(e, t);
}
function Bve(e, t) {
  const { authorizationList: n, chainId: r, gas: i, nonce: o, to: s, value: c, maxFeePerGas: u, maxPriorityFeePerGas: f, accessList: p, data: y } = e;
  Ove(e);
  const v = KC(p), w = Pve(n);
  return Wc([
    "0x04",
    Zd([
      yn(r),
      o ? yn(o) : "0x",
      f ? yn(f) : "0x",
      u ? yn(u) : "0x",
      i ? yn(i) : "0x",
      s ?? "0x",
      c ? yn(c) : "0x",
      y ?? "0x",
      v,
      w,
      ...Fb(e, t)
    ])
  ]);
}
function Lve(e, t) {
  const { chainId: n, gas: r, nonce: i, to: o, value: s, maxFeePerBlobGas: c, maxFeePerGas: u, maxPriorityFeePerGas: f, accessList: p, data: y } = e;
  Ive(e);
  let v = e.blobVersionedHashes, w = e.sidecars;
  if (e.blobs && (typeof v > "u" || typeof w > "u")) {
    const D = typeof e.blobs[0] == "string" ? e.blobs : e.blobs.map((j) => lo(j)), M = e.kzg, L = RM({
      blobs: D,
      kzg: M
    });
    if (typeof v > "u" && (v = PH({
      commitments: L
    })), typeof w > "u") {
      const j = OM({ blobs: D, commitments: L, kzg: M });
      w = FH({ blobs: D, commitments: L, proofs: j });
    }
  }
  const C = KC(p), x = [
    yn(n),
    i ? yn(i) : "0x",
    f ? yn(f) : "0x",
    u ? yn(u) : "0x",
    r ? yn(r) : "0x",
    o ?? "0x",
    s ? yn(s) : "0x",
    y ?? "0x",
    C,
    c ? yn(c) : "0x",
    v ?? [],
    ...Fb(e, t)
  ], A = [], R = [], I = [];
  if (w)
    for (let D = 0; D < w.length; D++) {
      const { blob: M, commitment: L, proof: j } = w[D];
      A.push(M), R.push(L), I.push(j);
    }
  return Wc([
    "0x03",
    // If sidecars are enabled, envelope turns into a "wrapper":
    Zd(w ? [x, A, R, I] : x)
  ]);
}
function jve(e, t) {
  const { chainId: n, gas: r, nonce: i, to: o, value: s, maxFeePerGas: c, maxPriorityFeePerGas: u, accessList: f, data: p } = e;
  VM(e);
  const y = KC(f), v = [
    yn(n),
    i ? yn(i) : "0x",
    u ? yn(u) : "0x",
    c ? yn(c) : "0x",
    r ? yn(r) : "0x",
    o ?? "0x",
    s ? yn(s) : "0x",
    p ?? "0x",
    y,
    ...Fb(e, t)
  ];
  return Wc([
    "0x02",
    Zd(v)
  ]);
}
function Fve(e, t) {
  const { chainId: n, gas: r, data: i, nonce: o, to: s, value: c, accessList: u, gasPrice: f } = e;
  Dve(e);
  const p = KC(u), y = [
    yn(n),
    o ? yn(o) : "0x",
    f ? yn(f) : "0x",
    r ? yn(r) : "0x",
    s ?? "0x",
    c ? yn(c) : "0x",
    i ?? "0x",
    p,
    ...Fb(e, t)
  ];
  return Wc([
    "0x01",
    Zd(y)
  ]);
}
function Uve(e, t) {
  const { chainId: n = 0, gas: r, data: i, nonce: o, to: s, value: c, gasPrice: u } = e;
  Mve(e);
  let f = [
    o ? yn(o) : "0x",
    u ? yn(u) : "0x",
    r ? yn(r) : "0x",
    s ?? "0x",
    c ? yn(c) : "0x",
    i ?? "0x"
  ];
  if (t) {
    const p = (() => {
      if (t.v >= 35n)
        return (t.v - 35n) / 2n > 0 ? t.v : 27n + (t.v === 35n ? 0n : 1n);
      if (n > 0)
        return BigInt(n * 2) + BigInt(35n + t.v - 27n);
      const w = 27n + (t.v === 27n ? 0n : 1n);
      if (t.v !== w)
        throw new Tpe({ v: t.v });
      return w;
    })(), y = Fu(t.r), v = Fu(t.s);
    f = [
      ...f,
      yn(p),
      y === "0x00" ? "0x" : y,
      v === "0x00" ? "0x" : v
    ];
  } else n > 0 && (f = [
    ...f,
    yn(n),
    "0x",
    "0x"
  ]);
  return Zd(f);
}
function Fb(e, t) {
  const n = t ?? e, { v: r, yParity: i } = n;
  if (typeof n.r > "u")
    return [];
  if (typeof n.s > "u")
    return [];
  if (typeof r > "u" && typeof i > "u")
    return [];
  const o = Fu(n.r), s = Fu(n.s);
  return [typeof i == "number" ? i ? yn(1) : "0x" : r === 0n ? "0x" : r === 1n ? yn(1) : r === 27n ? "0x" : yn(1), o === "0x00" ? "0x" : o, s === "0x00" ? "0x" : s];
}
function zve(e) {
  return e.map((t) => ({
    ...t,
    value: BigInt(t.value)
  }));
}
function Vve(e) {
  return {
    ...e,
    balance: e.balance ? BigInt(e.balance) : void 0,
    nonce: e.nonce ? Uu(e.nonce) : void 0,
    storageProof: e.storageProof ? zve(e.storageProof) : void 0
  };
}
async function $ve(e, { address: t, blockNumber: n, blockTag: r, storageKeys: i }) {
  const o = r ?? "latest", s = n !== void 0 ? en(n) : void 0, c = await e.request({
    method: "eth_getProof",
    params: [t, i, s || o]
  });
  return Vve(c);
}
async function Hve(e, {
  confirmations: t = 1,
  hash: n,
  onReplaced: r,
  pollingInterval: i = e.pollingInterval,
  retryCount: o = 6,
  retryDelay: s = ({ count: u }) => ~~(1 << u) * 200,
  // exponential backoff
  timeout: c
}) {
  const u = Pa(["waitForTransactionReceipt", e.uid, n]);
  let f = 0, p, y, v, w = !1;
  return new Promise((C, x) => {
    c && setTimeout(() => x(new cF({ hash: n })), c);
    const A = Yh(u, { onReplaced: r, resolve: C, reject: x }, (R) => {
      const I = Dn(e, Cq, "watchBlockNumber")({
        emitMissed: !0,
        emitOnBegin: !0,
        poll: !0,
        pollingInterval: i,
        async onBlockNumber(D) {
          const M = (j) => {
            I(), j(), A();
          };
          let L = D;
          if (!w) {
            f > o && M(() => R.reject(new cF({ hash: n })));
            try {
              if (v) {
                if (t > 1 && (!v.blockNumber || L - v.blockNumber + 1n < t))
                  return;
                M(() => R.resolve(v));
                return;
              }
              if (p || (w = !0, await N4(async () => {
                p = await Dn(e, zM, "getTransaction")({ hash: n }), p.blockNumber && (L = p.blockNumber);
              }, {
                delay: s,
                retryCount: o
              }), w = !1), v = await Dn(e, A5, "getTransactionReceipt")({ hash: n }), t > 1 && (!v.blockNumber || L - v.blockNumber + 1n < t))
                return;
              M(() => R.resolve(v));
            } catch (j) {
              if (j instanceof xH || j instanceof EH) {
                if (!p) {
                  w = !1;
                  return;
                }
                try {
                  y = p, w = !0;
                  const F = await N4(() => Dn(e, Gh, "getBlock")({
                    blockNumber: L,
                    includeTransactions: !0
                  }), {
                    delay: s,
                    retryCount: o,
                    shouldRetry: ({ error: H }) => H instanceof kH
                  });
                  w = !1;
                  const O = F.transactions.find(({ from: H, nonce: Q }) => H === y.from && Q === y.nonce);
                  if (!O || (v = await Dn(e, A5, "getTransactionReceipt")({
                    hash: O.hash
                  }), t > 1 && (!v.blockNumber || L - v.blockNumber + 1n < t)))
                    return;
                  let z = "replaced";
                  O.to === y.to && O.value === y.value ? z = "repriced" : O.from === O.to && O.value === 0n && (z = "cancelled"), M(() => {
                    var H;
                    (H = R.onReplaced) == null || H.call(R, {
                      reason: z,
                      replacedTransaction: y,
                      transaction: O,
                      transactionReceipt: v
                    }), R.resolve(v);
                  });
                } catch (F) {
                  M(() => R.reject(F));
                }
              } else
                M(() => R.reject(j));
            } finally {
              f++;
            }
          }
        }
      });
    });
  });
}
async function qve(e, { account: t = e.account, message: n }) {
  if (!t)
    throw new wM({
      docsPath: "/docs/actions/wallet/signMessage"
    });
  const r = nc(t);
  if (r.signMessage)
    return r.signMessage({ message: n });
  const i = typeof n == "string" ? Zg(n) : n.raw instanceof Uint8Array ? yn(n.raw) : n.raw;
  return e.request({
    method: "personal_sign",
    params: [i, r.address]
  }, { retryCount: 0 });
}
async function Wve(e, t) {
  const { abi: n, address: r, args: i, dataSuffix: o, functionName: s, ...c } = t, u = c.account ? nc(c.account) : e.account, f = cy({ abi: n, args: i, functionName: s });
  try {
    const { data: p } = await Dn(e, V8, "call")({
      batch: !1,
      data: `${f}${o ? o.replace("0x", "") : ""}`,
      to: r,
      ...c,
      account: u
    }), y = Lb({
      abi: n,
      args: i,
      functionName: s,
      data: p || "0x"
    }), v = n.filter((w) => "name" in w && w.name === t.functionName);
    return {
      result: y,
      request: {
        abi: v,
        address: r,
        args: i,
        dataSuffix: o,
        functionName: s,
        ...c,
        account: u
      }
    };
  } catch (p) {
    throw iC(p, {
      abi: n,
      address: r,
      args: i,
      docsPath: "/docs/contract/simulateContract",
      functionName: s,
      sender: u == null ? void 0 : u.address
    });
  }
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Rq = BigInt(0), W8 = BigInt(1), Gve = BigInt(2);
function Jm(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
function YC(e) {
  if (!Jm(e))
    throw new Error("Uint8Array expected");
}
const Kve = /* @__PURE__ */ Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function rb(e) {
  YC(e);
  let t = "";
  for (let n = 0; n < e.length; n++)
    t += Kve[e[n]];
  return t;
}
function Oq(e) {
  const t = e.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function $M(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return BigInt(e === "" ? "0" : `0x${e}`);
}
const Nd = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function TF(e) {
  if (e >= Nd._0 && e <= Nd._9)
    return e - Nd._0;
  if (e >= Nd._A && e <= Nd._F)
    return e - (Nd._A - 10);
  if (e >= Nd._a && e <= Nd._f)
    return e - (Nd._a - 10);
}
function ib(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  const t = e.length, n = t / 2;
  if (t % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + t);
  const r = new Uint8Array(n);
  for (let i = 0, o = 0; i < n; i++, o += 2) {
    const s = TF(e.charCodeAt(o)), c = TF(e.charCodeAt(o + 1));
    if (s === void 0 || c === void 0) {
      const u = e[o] + e[o + 1];
      throw new Error('hex string expected, got non-hex character "' + u + '" at index ' + o);
    }
    r[i] = s * 16 + c;
  }
  return r;
}
function Vm(e) {
  return $M(rb(e));
}
function HM(e) {
  return YC(e), $M(rb(Uint8Array.from(e).reverse()));
}
function ob(e, t) {
  return ib(e.toString(16).padStart(t * 2, "0"));
}
function qM(e, t) {
  return ob(e, t).reverse();
}
function Yve(e) {
  return ib(Oq(e));
}
function Pc(e, t, n) {
  let r;
  if (typeof t == "string")
    try {
      r = ib(t);
    } catch (o) {
      throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${o}`);
    }
  else if (Jm(t))
    r = Uint8Array.from(t);
  else
    throw new Error(`${e} must be hex string or Uint8Array`);
  const i = r.length;
  if (typeof n == "number" && i !== n)
    throw new Error(`${e} expected ${n} bytes, got ${i}`);
  return r;
}
function oC(...e) {
  let t = 0;
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    YC(i), t += i.length;
  }
  const n = new Uint8Array(t);
  for (let r = 0, i = 0; r < e.length; r++) {
    const o = e[r];
    n.set(o, i), i += o.length;
  }
  return n;
}
function Iq(e, t) {
  if (e.length !== t.length)
    return !1;
  let n = 0;
  for (let r = 0; r < e.length; r++)
    n |= e[r] ^ t[r];
  return n === 0;
}
function Qve(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function Xve(e) {
  let t;
  for (t = 0; e > Rq; e >>= W8, t += 1)
    ;
  return t;
}
function Jve(e, t) {
  return e >> BigInt(t) & W8;
}
function Zve(e, t, n) {
  return e | (n ? W8 : Rq) << BigInt(t);
}
const WM = (e) => (Gve << BigInt(e - 1)) - W8, iO = (e) => new Uint8Array(e), _F = (e) => Uint8Array.from(e);
function Dq(e, t, n) {
  if (typeof e != "number" || e < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof n != "function")
    throw new Error("hmacFn must be a function");
  let r = iO(e), i = iO(e), o = 0;
  const s = () => {
    r.fill(1), i.fill(0), o = 0;
  }, c = (...y) => n(i, r, ...y), u = (y = iO()) => {
    i = c(_F([0]), y), r = c(), y.length !== 0 && (i = c(_F([1]), y), r = c());
  }, f = () => {
    if (o++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let y = 0;
    const v = [];
    for (; y < t; ) {
      r = c();
      const w = r.slice();
      v.push(w), y += r.length;
    }
    return oC(...v);
  };
  return (y, v) => {
    s(), u(y);
    let w;
    for (; !(w = v(f())); )
      u();
    return s(), w;
  };
}
const ege = {
  bigint: (e) => typeof e == "bigint",
  function: (e) => typeof e == "function",
  boolean: (e) => typeof e == "boolean",
  string: (e) => typeof e == "string",
  stringOrUint8Array: (e) => typeof e == "string" || Jm(e),
  isSafeInteger: (e) => Number.isSafeInteger(e),
  array: (e) => Array.isArray(e),
  field: (e, t) => t.Fp.isValid(e),
  hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen)
};
function QC(e, t, n = {}) {
  const r = (i, o, s) => {
    const c = ege[o];
    if (typeof c != "function")
      throw new Error(`Invalid validator "${o}", expected function`);
    const u = e[i];
    if (!(s && u === void 0) && !c(u, e))
      throw new Error(`Invalid param ${String(i)}=${u} (${typeof u}), expected ${o}`);
  };
  for (const [i, o] of Object.entries(t))
    r(i, o, !1);
  for (const [i, o] of Object.entries(n))
    r(i, o, !0);
  return e;
}
const tge = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  abytes: YC,
  bitGet: Jve,
  bitLen: Xve,
  bitMask: WM,
  bitSet: Zve,
  bytesToHex: rb,
  bytesToNumberBE: Vm,
  bytesToNumberLE: HM,
  concatBytes: oC,
  createHmacDrbg: Dq,
  ensureBytes: Pc,
  equalBytes: Iq,
  hexToBytes: ib,
  hexToNumber: $M,
  isBytes: Jm,
  numberToBytesBE: ob,
  numberToBytesLE: qM,
  numberToHexUnpadded: Oq,
  numberToVarBytesBE: Yve,
  utf8ToBytes: Qve,
  validateObject: QC
}, Symbol.toStringTag, { value: "Module" }));
function nge(e, t) {
  const n = Ql(e) ? qh(e) : e, r = Ql(t) ? qh(t) : t;
  return Iq(n, r);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Vo = BigInt(0), Ki = BigInt(1), xm = BigInt(2), rge = BigInt(3), _5 = BigInt(4), RF = BigInt(5), OF = BigInt(8);
BigInt(9);
BigInt(16);
function Us(e, t) {
  const n = e % t;
  return n >= Vo ? n : t + n;
}
function ige(e, t, n) {
  if (n <= Vo || t < Vo)
    throw new Error("Expected power/modulo > 0");
  if (n === Ki)
    return Vo;
  let r = Ki;
  for (; t > Vo; )
    t & Ki && (r = r * e % n), e = e * e % n, t >>= Ki;
  return r;
}
function Ml(e, t, n) {
  let r = e;
  for (; t-- > Vo; )
    r *= r, r %= n;
  return r;
}
function R5(e, t) {
  if (e === Vo || t <= Vo)
    throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
  let n = Us(e, t), r = t, i = Vo, o = Ki;
  for (; n !== Vo; ) {
    const c = r / n, u = r % n, f = i - o * c;
    r = n, n = u, i = o, o = f;
  }
  if (r !== Ki)
    throw new Error("invert: does not exist");
  return Us(i, t);
}
function oge(e) {
  const t = (e - Ki) / xm;
  let n, r, i;
  for (n = e - Ki, r = 0; n % xm === Vo; n /= xm, r++)
    ;
  for (i = xm; i < e && ige(i, t, e) !== e - Ki; i++)
    ;
  if (r === 1) {
    const s = (e + Ki) / _5;
    return function(u, f) {
      const p = u.pow(f, s);
      if (!u.eql(u.sqr(p), f))
        throw new Error("Cannot find square root");
      return p;
    };
  }
  const o = (n + Ki) / xm;
  return function(c, u) {
    if (c.pow(u, t) === c.neg(c.ONE))
      throw new Error("Cannot find square root");
    let f = r, p = c.pow(c.mul(c.ONE, i), n), y = c.pow(u, o), v = c.pow(u, n);
    for (; !c.eql(v, c.ONE); ) {
      if (c.eql(v, c.ZERO))
        return c.ZERO;
      let w = 1;
      for (let x = c.sqr(v); w < f && !c.eql(x, c.ONE); w++)
        x = c.sqr(x);
      const C = c.pow(p, Ki << BigInt(f - w - 1));
      p = c.sqr(C), y = c.mul(y, C), v = c.mul(v, p), f = w;
    }
    return y;
  };
}
function age(e) {
  if (e % _5 === rge) {
    const t = (e + Ki) / _5;
    return function(r, i) {
      const o = r.pow(i, t);
      if (!r.eql(r.sqr(o), i))
        throw new Error("Cannot find square root");
      return o;
    };
  }
  if (e % OF === RF) {
    const t = (e - RF) / OF;
    return function(r, i) {
      const o = r.mul(i, xm), s = r.pow(o, t), c = r.mul(i, s), u = r.mul(r.mul(c, xm), s), f = r.mul(c, r.sub(u, r.ONE));
      if (!r.eql(r.sqr(f), i))
        throw new Error("Cannot find square root");
      return f;
    };
  }
  return oge(e);
}
const sge = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function lge(e) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, n = sge.reduce((r, i) => (r[i] = "function", r), t);
  return QC(e, n);
}
function cge(e, t, n) {
  if (n < Vo)
    throw new Error("Expected power > 0");
  if (n === Vo)
    return e.ONE;
  if (n === Ki)
    return t;
  let r = e.ONE, i = t;
  for (; n > Vo; )
    n & Ki && (r = e.mul(r, i)), i = e.sqr(i), n >>= Ki;
  return r;
}
function uge(e, t) {
  const n = new Array(t.length), r = t.reduce((o, s, c) => e.is0(s) ? o : (n[c] = o, e.mul(o, s)), e.ONE), i = e.inv(r);
  return t.reduceRight((o, s, c) => e.is0(s) ? o : (n[c] = e.mul(o, n[c]), e.mul(o, s)), i), n;
}
function Mq(e, t) {
  const n = t !== void 0 ? t : e.toString(2).length, r = Math.ceil(n / 8);
  return { nBitLength: n, nByteLength: r };
}
function dge(e, t, n = !1, r = {}) {
  if (e <= Vo)
    throw new Error(`Expected Field ORDER > 0, got ${e}`);
  const { nBitLength: i, nByteLength: o } = Mq(e, t);
  if (o > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const s = age(e), c = Object.freeze({
    ORDER: e,
    BITS: i,
    BYTES: o,
    MASK: WM(i),
    ZERO: Vo,
    ONE: Ki,
    create: (u) => Us(u, e),
    isValid: (u) => {
      if (typeof u != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof u}`);
      return Vo <= u && u < e;
    },
    is0: (u) => u === Vo,
    isOdd: (u) => (u & Ki) === Ki,
    neg: (u) => Us(-u, e),
    eql: (u, f) => u === f,
    sqr: (u) => Us(u * u, e),
    add: (u, f) => Us(u + f, e),
    sub: (u, f) => Us(u - f, e),
    mul: (u, f) => Us(u * f, e),
    pow: (u, f) => cge(c, u, f),
    div: (u, f) => Us(u * R5(f, e), e),
    // Same as above, but doesn't normalize
    sqrN: (u) => u * u,
    addN: (u, f) => u + f,
    subN: (u, f) => u - f,
    mulN: (u, f) => u * f,
    inv: (u) => R5(u, e),
    sqrt: r.sqrt || ((u) => s(c, u)),
    invertBatch: (u) => uge(c, u),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (u, f, p) => p ? f : u,
    toBytes: (u) => n ? qM(u, o) : ob(u, o),
    fromBytes: (u) => {
      if (u.length !== o)
        throw new Error(`Fp.fromBytes: expected ${o}, got ${u.length}`);
      return n ? HM(u) : Vm(u);
    }
  });
  return Object.freeze(c);
}
function Pq(e) {
  if (typeof e != "bigint")
    throw new Error("field order must be bigint");
  const t = e.toString(2).length;
  return Math.ceil(t / 8);
}
function Nq(e) {
  const t = Pq(e);
  return t + Math.ceil(t / 2);
}
function fge(e, t, n = !1) {
  const r = e.length, i = Pq(t), o = Nq(t);
  if (r < 16 || r < o || r > 1024)
    throw new Error(`expected ${o}-1024 bytes of input, got ${r}`);
  const s = n ? Vm(e) : HM(e), c = Us(s, t - Ki) + Ki;
  return n ? qM(c, i) : ob(c, i);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const hge = BigInt(0), oO = BigInt(1);
function pge(e, t) {
  const n = (i, o) => {
    const s = o.negate();
    return i ? s : o;
  }, r = (i) => {
    const o = Math.ceil(t / i) + 1, s = 2 ** (i - 1);
    return { windows: o, windowSize: s };
  };
  return {
    constTimeNegate: n,
    // non-const time multiplication ladder
    unsafeLadder(i, o) {
      let s = e.ZERO, c = i;
      for (; o > hge; )
        o & oO && (s = s.add(c)), c = c.double(), o >>= oO;
      return s;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(i, o) {
      const { windows: s, windowSize: c } = r(o), u = [];
      let f = i, p = f;
      for (let y = 0; y < s; y++) {
        p = f, u.push(p);
        for (let v = 1; v < c; v++)
          p = p.add(f), u.push(p);
        f = p.double();
      }
      return u;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(i, o, s) {
      const { windows: c, windowSize: u } = r(i);
      let f = e.ZERO, p = e.BASE;
      const y = BigInt(2 ** i - 1), v = 2 ** i, w = BigInt(i);
      for (let C = 0; C < c; C++) {
        const x = C * u;
        let A = Number(s & y);
        s >>= w, A > u && (A -= v, s += oO);
        const R = x, I = x + Math.abs(A) - 1, D = C % 2 !== 0, M = A < 0;
        A === 0 ? p = p.add(n(D, o[R])) : f = f.add(n(M, o[I]));
      }
      return { p: f, f: p };
    },
    wNAFCached(i, o, s, c) {
      const u = i._WINDOW_SIZE || 1;
      let f = o.get(i);
      return f || (f = this.precomputeWindow(i, u), u !== 1 && o.set(i, c(f))), this.wNAF(u, f, s);
    }
  };
}
function Bq(e) {
  return lge(e.Fp), QC(e, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...Mq(e.n, e.nBitLength),
    ...e,
    p: e.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function mge(e) {
  const t = Bq(e);
  QC(t, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: n, Fp: r, a: i } = t;
  if (n) {
    if (!r.eql(i, r.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof n != "object" || typeof n.beta != "bigint" || typeof n.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...t });
}
const { bytesToNumberBE: yge, hexToBytes: vge } = tge, _m = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(t = "") {
      super(t);
    }
  },
  _parseInt(e) {
    const { Err: t } = _m;
    if (e.length < 2 || e[0] !== 2)
      throw new t("Invalid signature integer tag");
    const n = e[1], r = e.subarray(2, n + 2);
    if (!n || r.length !== n)
      throw new t("Invalid signature integer: wrong length");
    if (r[0] & 128)
      throw new t("Invalid signature integer: negative");
    if (r[0] === 0 && !(r[1] & 128))
      throw new t("Invalid signature integer: unnecessary leading zero");
    return { d: yge(r), l: e.subarray(n + 2) };
  },
  toSig(e) {
    const { Err: t } = _m, n = typeof e == "string" ? vge(e) : e;
    YC(n);
    let r = n.length;
    if (r < 2 || n[0] != 48)
      throw new t("Invalid signature tag");
    if (n[1] !== r - 2)
      throw new t("Invalid signature: incorrect length");
    const { d: i, l: o } = _m._parseInt(n.subarray(2)), { d: s, l: c } = _m._parseInt(o);
    if (c.length)
      throw new t("Invalid signature: left bytes after parsing");
    return { r: i, s };
  },
  hexFromSig(e) {
    const t = (f) => Number.parseInt(f[0], 16) & 8 ? "00" + f : f, n = (f) => {
      const p = f.toString(16);
      return p.length & 1 ? `0${p}` : p;
    }, r = t(n(e.s)), i = t(n(e.r)), o = r.length / 2, s = i.length / 2, c = n(o), u = n(s);
    return `30${n(s + o + 4)}02${u}${i}02${c}${r}`;
  }
}, Fd = BigInt(0), Vl = BigInt(1);
BigInt(2);
const IF = BigInt(3);
BigInt(4);
function gge(e) {
  const t = mge(e), { Fp: n } = t, r = t.toBytes || ((C, x, A) => {
    const R = x.toAffine();
    return oC(Uint8Array.from([4]), n.toBytes(R.x), n.toBytes(R.y));
  }), i = t.fromBytes || ((C) => {
    const x = C.subarray(1), A = n.fromBytes(x.subarray(0, n.BYTES)), R = n.fromBytes(x.subarray(n.BYTES, 2 * n.BYTES));
    return { x: A, y: R };
  });
  function o(C) {
    const { a: x, b: A } = t, R = n.sqr(C), I = n.mul(R, C);
    return n.add(n.add(I, n.mul(C, x)), A);
  }
  if (!n.eql(n.sqr(t.Gy), o(t.Gx)))
    throw new Error("bad generator point: equation left != right");
  function s(C) {
    return typeof C == "bigint" && Fd < C && C < t.n;
  }
  function c(C) {
    if (!s(C))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function u(C) {
    const { allowedPrivateKeyLengths: x, nByteLength: A, wrapPrivateKey: R, n: I } = t;
    if (x && typeof C != "bigint") {
      if (Jm(C) && (C = rb(C)), typeof C != "string" || !x.includes(C.length))
        throw new Error("Invalid key");
      C = C.padStart(A * 2, "0");
    }
    let D;
    try {
      D = typeof C == "bigint" ? C : Vm(Pc("private key", C, A));
    } catch {
      throw new Error(`private key must be ${A} bytes, hex or bigint, not ${typeof C}`);
    }
    return R && (D = Us(D, I)), c(D), D;
  }
  const f = /* @__PURE__ */ new Map();
  function p(C) {
    if (!(C instanceof y))
      throw new Error("ProjectivePoint expected");
  }
  class y {
    constructor(x, A, R) {
      if (this.px = x, this.py = A, this.pz = R, x == null || !n.isValid(x))
        throw new Error("x required");
      if (A == null || !n.isValid(A))
        throw new Error("y required");
      if (R == null || !n.isValid(R))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(x) {
      const { x: A, y: R } = x || {};
      if (!x || !n.isValid(A) || !n.isValid(R))
        throw new Error("invalid affine point");
      if (x instanceof y)
        throw new Error("projective point not allowed");
      const I = (D) => n.eql(D, n.ZERO);
      return I(A) && I(R) ? y.ZERO : new y(A, R, n.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(x) {
      const A = n.invertBatch(x.map((R) => R.pz));
      return x.map((R, I) => R.toAffine(A[I])).map(y.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(x) {
      const A = y.fromAffine(i(Pc("pointHex", x)));
      return A.assertValidity(), A;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(x) {
      return y.BASE.multiply(u(x));
    }
    // "Private method", don't use it directly
    _setWindowSize(x) {
      this._WINDOW_SIZE = x, f.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (t.allowInfinityPoint && !n.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y: A } = this.toAffine();
      if (!n.isValid(x) || !n.isValid(A))
        throw new Error("bad point: x or y not FE");
      const R = n.sqr(A), I = o(x);
      if (!n.eql(R, I))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: x } = this.toAffine();
      if (n.isOdd)
        return !n.isOdd(x);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(x) {
      p(x);
      const { px: A, py: R, pz: I } = this, { px: D, py: M, pz: L } = x, j = n.eql(n.mul(A, L), n.mul(D, I)), F = n.eql(n.mul(R, L), n.mul(M, I));
      return j && F;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new y(this.px, n.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: x, b: A } = t, R = n.mul(A, IF), { px: I, py: D, pz: M } = this;
      let L = n.ZERO, j = n.ZERO, F = n.ZERO, O = n.mul(I, I), z = n.mul(D, D), H = n.mul(M, M), Q = n.mul(I, D);
      return Q = n.add(Q, Q), F = n.mul(I, M), F = n.add(F, F), L = n.mul(x, F), j = n.mul(R, H), j = n.add(L, j), L = n.sub(z, j), j = n.add(z, j), j = n.mul(L, j), L = n.mul(Q, L), F = n.mul(R, F), H = n.mul(x, H), Q = n.sub(O, H), Q = n.mul(x, Q), Q = n.add(Q, F), F = n.add(O, O), O = n.add(F, O), O = n.add(O, H), O = n.mul(O, Q), j = n.add(j, O), H = n.mul(D, M), H = n.add(H, H), O = n.mul(H, Q), L = n.sub(L, O), F = n.mul(H, z), F = n.add(F, F), F = n.add(F, F), new y(L, j, F);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(x) {
      p(x);
      const { px: A, py: R, pz: I } = this, { px: D, py: M, pz: L } = x;
      let j = n.ZERO, F = n.ZERO, O = n.ZERO;
      const z = t.a, H = n.mul(t.b, IF);
      let Q = n.mul(A, D), Y = n.mul(R, M), ee = n.mul(I, L), ie = n.add(A, R), X = n.add(D, M);
      ie = n.mul(ie, X), X = n.add(Q, Y), ie = n.sub(ie, X), X = n.add(A, I);
      let Z = n.add(D, L);
      return X = n.mul(X, Z), Z = n.add(Q, ee), X = n.sub(X, Z), Z = n.add(R, I), j = n.add(M, L), Z = n.mul(Z, j), j = n.add(Y, ee), Z = n.sub(Z, j), O = n.mul(z, X), j = n.mul(H, ee), O = n.add(j, O), j = n.sub(Y, O), O = n.add(Y, O), F = n.mul(j, O), Y = n.add(Q, Q), Y = n.add(Y, Q), ee = n.mul(z, ee), X = n.mul(H, X), Y = n.add(Y, ee), ee = n.sub(Q, ee), ee = n.mul(z, ee), X = n.add(X, ee), Q = n.mul(Y, X), F = n.add(F, Q), Q = n.mul(Z, X), j = n.mul(ie, j), j = n.sub(j, Q), Q = n.mul(ie, Y), O = n.mul(Z, O), O = n.add(O, Q), new y(j, F, O);
    }
    subtract(x) {
      return this.add(x.negate());
    }
    is0() {
      return this.equals(y.ZERO);
    }
    wNAF(x) {
      return w.wNAFCached(this, f, x, (A) => {
        const R = n.invertBatch(A.map((I) => I.pz));
        return A.map((I, D) => I.toAffine(R[D])).map(y.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(x) {
      const A = y.ZERO;
      if (x === Fd)
        return A;
      if (c(x), x === Vl)
        return this;
      const { endo: R } = t;
      if (!R)
        return w.unsafeLadder(this, x);
      let { k1neg: I, k1: D, k2neg: M, k2: L } = R.splitScalar(x), j = A, F = A, O = this;
      for (; D > Fd || L > Fd; )
        D & Vl && (j = j.add(O)), L & Vl && (F = F.add(O)), O = O.double(), D >>= Vl, L >>= Vl;
      return I && (j = j.negate()), M && (F = F.negate()), F = new y(n.mul(F.px, R.beta), F.py, F.pz), j.add(F);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(x) {
      c(x);
      let A = x, R, I;
      const { endo: D } = t;
      if (D) {
        const { k1neg: M, k1: L, k2neg: j, k2: F } = D.splitScalar(A);
        let { p: O, f: z } = this.wNAF(L), { p: H, f: Q } = this.wNAF(F);
        O = w.constTimeNegate(M, O), H = w.constTimeNegate(j, H), H = new y(n.mul(H.px, D.beta), H.py, H.pz), R = O.add(H), I = z.add(Q);
      } else {
        const { p: M, f: L } = this.wNAF(A);
        R = M, I = L;
      }
      return y.normalizeZ([R, I])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(x, A, R) {
      const I = y.BASE, D = (L, j) => j === Fd || j === Vl || !L.equals(I) ? L.multiplyUnsafe(j) : L.multiply(j), M = D(this, A).add(D(x, R));
      return M.is0() ? void 0 : M;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(x) {
      const { px: A, py: R, pz: I } = this, D = this.is0();
      x == null && (x = D ? n.ONE : n.inv(I));
      const M = n.mul(A, x), L = n.mul(R, x), j = n.mul(I, x);
      if (D)
        return { x: n.ZERO, y: n.ZERO };
      if (!n.eql(j, n.ONE))
        throw new Error("invZ was invalid");
      return { x: M, y: L };
    }
    isTorsionFree() {
      const { h: x, isTorsionFree: A } = t;
      if (x === Vl)
        return !0;
      if (A)
        return A(y, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: x, clearCofactor: A } = t;
      return x === Vl ? this : A ? A(y, this) : this.multiplyUnsafe(t.h);
    }
    toRawBytes(x = !0) {
      return this.assertValidity(), r(y, this, x);
    }
    toHex(x = !0) {
      return rb(this.toRawBytes(x));
    }
  }
  y.BASE = new y(t.Gx, t.Gy, n.ONE), y.ZERO = new y(n.ZERO, n.ONE, n.ZERO);
  const v = t.nBitLength, w = pge(y, t.endo ? Math.ceil(v / 2) : v);
  return {
    CURVE: t,
    ProjectivePoint: y,
    normPrivateKeyToScalar: u,
    weierstrassEquation: o,
    isWithinCurveOrder: s
  };
}
function bge(e) {
  const t = Bq(e);
  return QC(t, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...t });
}
function wge(e) {
  const t = bge(e), { Fp: n, n: r } = t, i = n.BYTES + 1, o = 2 * n.BYTES + 1;
  function s(X) {
    return Fd < X && X < n.ORDER;
  }
  function c(X) {
    return Us(X, r);
  }
  function u(X) {
    return R5(X, r);
  }
  const { ProjectivePoint: f, normPrivateKeyToScalar: p, weierstrassEquation: y, isWithinCurveOrder: v } = gge({
    ...t,
    toBytes(X, Z, J) {
      const K = Z.toAffine(), oe = n.toBytes(K.x), be = oC;
      return J ? be(Uint8Array.from([Z.hasEvenY() ? 2 : 3]), oe) : be(Uint8Array.from([4]), oe, n.toBytes(K.y));
    },
    fromBytes(X) {
      const Z = X.length, J = X[0], K = X.subarray(1);
      if (Z === i && (J === 2 || J === 3)) {
        const oe = Vm(K);
        if (!s(oe))
          throw new Error("Point is not on curve");
        const be = y(oe);
        let ce;
        try {
          ce = n.sqrt(be);
        } catch (Se) {
          const Me = Se instanceof Error ? ": " + Se.message : "";
          throw new Error("Point is not on curve" + Me);
        }
        const pe = (ce & Vl) === Vl;
        return (J & 1) === 1 !== pe && (ce = n.neg(ce)), { x: oe, y: ce };
      } else if (Z === o && J === 4) {
        const oe = n.fromBytes(K.subarray(0, n.BYTES)), be = n.fromBytes(K.subarray(n.BYTES, 2 * n.BYTES));
        return { x: oe, y: be };
      } else
        throw new Error(`Point of length ${Z} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`);
    }
  }), w = (X) => rb(ob(X, t.nByteLength));
  function C(X) {
    const Z = r >> Vl;
    return X > Z;
  }
  function x(X) {
    return C(X) ? c(-X) : X;
  }
  const A = (X, Z, J) => Vm(X.slice(Z, J));
  class R {
    constructor(Z, J, K) {
      this.r = Z, this.s = J, this.recovery = K, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(Z) {
      const J = t.nByteLength;
      return Z = Pc("compactSignature", Z, J * 2), new R(A(Z, 0, J), A(Z, J, 2 * J));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(Z) {
      const { r: J, s: K } = _m.toSig(Pc("DER", Z));
      return new R(J, K);
    }
    assertValidity() {
      if (!v(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!v(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(Z) {
      return new R(this.r, this.s, Z);
    }
    recoverPublicKey(Z) {
      const { r: J, s: K, recovery: oe } = this, be = F(Pc("msgHash", Z));
      if (oe == null || ![0, 1, 2, 3].includes(oe))
        throw new Error("recovery id invalid");
      const ce = oe === 2 || oe === 3 ? J + t.n : J;
      if (ce >= n.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const pe = oe & 1 ? "03" : "02", Ee = f.fromHex(pe + w(ce)), Se = u(ce), Me = c(-be * Se), Fe = c(K * Se), st = f.BASE.multiplyAndAddUnsafe(Ee, Me, Fe);
      if (!st)
        throw new Error("point at infinify");
      return st.assertValidity(), st;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return C(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new R(this.r, c(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return ib(this.toDERHex());
    }
    toDERHex() {
      return _m.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return ib(this.toCompactHex());
    }
    toCompactHex() {
      return w(this.r) + w(this.s);
    }
  }
  const I = {
    isValidPrivateKey(X) {
      try {
        return p(X), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: p,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const X = Nq(t.n);
      return fge(t.randomBytes(X), t.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(X = 8, Z = f.BASE) {
      return Z._setWindowSize(X), Z.multiply(BigInt(3)), Z;
    }
  };
  function D(X, Z = !0) {
    return f.fromPrivateKey(X).toRawBytes(Z);
  }
  function M(X) {
    const Z = Jm(X), J = typeof X == "string", K = (Z || J) && X.length;
    return Z ? K === i || K === o : J ? K === 2 * i || K === 2 * o : X instanceof f;
  }
  function L(X, Z, J = !0) {
    if (M(X))
      throw new Error("first arg must be private key");
    if (!M(Z))
      throw new Error("second arg must be public key");
    return f.fromHex(Z).multiply(p(X)).toRawBytes(J);
  }
  const j = t.bits2int || function(X) {
    const Z = Vm(X), J = X.length * 8 - t.nBitLength;
    return J > 0 ? Z >> BigInt(J) : Z;
  }, F = t.bits2int_modN || function(X) {
    return c(j(X));
  }, O = WM(t.nBitLength);
  function z(X) {
    if (typeof X != "bigint")
      throw new Error("bigint expected");
    if (!(Fd <= X && X < O))
      throw new Error(`bigint expected < 2^${t.nBitLength}`);
    return ob(X, t.nByteLength);
  }
  function H(X, Z, J = Q) {
    if (["recovered", "canonical"].some((yt) => yt in J))
      throw new Error("sign() legacy options not supported");
    const { hash: K, randomBytes: oe } = t;
    let { lowS: be, prehash: ce, extraEntropy: pe } = J;
    be == null && (be = !0), X = Pc("msgHash", X), ce && (X = Pc("prehashed msgHash", K(X)));
    const Ee = F(X), Se = p(Z), Me = [z(Se), z(Ee)];
    if (pe != null && pe !== !1) {
      const yt = pe === !0 ? oe(n.BYTES) : pe;
      Me.push(Pc("extraEntropy", yt));
    }
    const Fe = oC(...Me), st = Ee;
    function mt(yt) {
      const Ut = j(yt);
      if (!v(Ut))
        return;
      const hn = u(Ut), wn = f.BASE.multiply(Ut).toAffine(), Ot = c(wn.x);
      if (Ot === Fd)
        return;
      const xt = c(hn * c(st + Ot * Se));
      if (xt === Fd)
        return;
      let zt = (wn.x === Ot ? 0 : 2) | Number(wn.y & Vl), Pn = xt;
      return be && C(xt) && (Pn = x(xt), zt ^= 1), new R(Ot, Pn, zt);
    }
    return { seed: Fe, k2sig: mt };
  }
  const Q = { lowS: t.lowS, prehash: !1 }, Y = { lowS: t.lowS, prehash: !1 };
  function ee(X, Z, J = Q) {
    const { seed: K, k2sig: oe } = H(X, Z, J), be = t;
    return Dq(be.hash.outputLen, be.nByteLength, be.hmac)(K, oe);
  }
  f.BASE._setWindowSize(8);
  function ie(X, Z, J, K = Y) {
    var wn;
    const oe = X;
    if (Z = Pc("msgHash", Z), J = Pc("publicKey", J), "strict" in K)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: be, prehash: ce } = K;
    let pe, Ee;
    try {
      if (typeof oe == "string" || Jm(oe))
        try {
          pe = R.fromDER(oe);
        } catch (Ot) {
          if (!(Ot instanceof _m.Err))
            throw Ot;
          pe = R.fromCompact(oe);
        }
      else if (typeof oe == "object" && typeof oe.r == "bigint" && typeof oe.s == "bigint") {
        const { r: Ot, s: xt } = oe;
        pe = new R(Ot, xt);
      } else
        throw new Error("PARSE");
      Ee = f.fromHex(J);
    } catch (Ot) {
      if (Ot.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (be && pe.hasHighS())
      return !1;
    ce && (Z = t.hash(Z));
    const { r: Se, s: Me } = pe, Fe = F(Z), st = u(Me), mt = c(Fe * st), yt = c(Se * st), Ut = (wn = f.BASE.multiplyAndAddUnsafe(Ee, mt, yt)) == null ? void 0 : wn.toAffine();
    return Ut ? c(Ut.x) === Se : !1;
  }
  return {
    CURVE: t,
    getPublicKey: D,
    getSharedSecret: L,
    sign: ee,
    verify: ie,
    ProjectivePoint: f,
    Signature: R,
    utils: I
  };
}
class Lq extends pM {
  constructor(t, n) {
    super(), this.finished = !1, this.destroyed = !1, Lhe(t);
    const r = D8(n);
    if (this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const i = this.blockLen, o = new Uint8Array(i);
    o.set(r.length > i ? t.create().update(r).digest() : r);
    for (let s = 0; s < o.length; s++)
      o[s] ^= 54;
    this.iHash.update(o), this.oHash = t.create();
    for (let s = 0; s < o.length; s++)
      o[s] ^= 106;
    this.oHash.update(o), o.fill(0);
  }
  update(t) {
    return eb(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    eb(this), LC(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n, iHash: r, finished: i, destroyed: o, blockLen: s, outputLen: c } = this;
    return t = t, t.finished = i, t.destroyed = o, t.blockLen = s, t.outputLen = c, t.oHash = n._cloneInto(t.oHash), t.iHash = r._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const jq = (e, t, n) => new Lq(e, t).update(n).digest();
jq.create = (e, t) => new Lq(e, t);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function Cge(e) {
  return {
    hash: e,
    hmac: (t, ...n) => jq(e, t, Ghe(...n)),
    randomBytes: Khe
  };
}
function xge(e, t) {
  const n = (r) => wge({ ...e, ...Cge(r) });
  return Object.freeze({ ...n(t), create: n });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Fq = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), DF = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), Ege = BigInt(1), O5 = BigInt(2), MF = (e, t) => (e + t / O5) / t;
function Sge(e) {
  const t = Fq, n = BigInt(3), r = BigInt(6), i = BigInt(11), o = BigInt(22), s = BigInt(23), c = BigInt(44), u = BigInt(88), f = e * e * e % t, p = f * f * e % t, y = Ml(p, n, t) * p % t, v = Ml(y, n, t) * p % t, w = Ml(v, O5, t) * f % t, C = Ml(w, i, t) * w % t, x = Ml(C, o, t) * C % t, A = Ml(x, c, t) * x % t, R = Ml(A, u, t) * A % t, I = Ml(R, c, t) * x % t, D = Ml(I, n, t) * p % t, M = Ml(D, s, t) * C % t, L = Ml(M, r, t) * f % t, j = Ml(L, O5, t);
  if (!I5.eql(I5.sqr(j), e))
    throw new Error("Cannot find square root");
  return j;
}
const I5 = dge(Fq, void 0, void 0, { sqrt: Sge }), GM = xge({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp: I5,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: DF,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: !0,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (e) => {
      const t = DF, n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), r = -Ege * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), o = n, s = BigInt("0x100000000000000000000000000000000"), c = MF(o * e, t), u = MF(-r * e, t);
      let f = Us(e - c * n - u * i, t), p = Us(-c * r - u * o, t);
      const y = f > s, v = p > s;
      if (y && (f = t - f), v && (p = t - p), f > s || p > s)
        throw new Error("splitScalar: Endomorphism failed, k=" + e);
      return { k1neg: y, k1: f, k2neg: v, k2: p };
    }
  }
}, MH);
BigInt(0);
GM.ProjectivePoint;
const kge = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  secp256k1: GM
}, Symbol.toStringTag, { value: "Module" }));
function Age({ r: e, s: t, to: n = "hex", v: r, yParity: i }) {
  const o = (() => {
    if (i === 0 || i === 1)
      return i;
    if (r && (r === 27n || r === 28n || r >= 35n))
      return r % 2n === 0n ? 1 : 0;
    throw new Error("Invalid `v` or `yParity` value");
  })(), s = `0x${new GM.Signature(Da(e), Da(t)).toCompactHex()}${o === 0 ? "1b" : "1c"}`;
  return n === "hex" ? s : zc(s);
}
async function KM(e, t) {
  const { address: n, factory: r, factoryData: i, hash: o, signature: s, ...c } = t, u = Ql(s) ? s : typeof s == "object" && "r" in s && "s" in s ? Age(s) : lo(s), f = await (async () => !r && !i || _ve(u) ? u : Rve({
    address: r,
    data: i,
    signature: u
  }))();
  try {
    const { data: p } = await Dn(e, V8, "call")({
      data: bM({
        abi: cme,
        args: [n, o, f],
        bytecode: wye
      }),
      ...c
    });
    return nge(p ?? "0x0", "0x1");
  } catch (p) {
    try {
      if (LM(Ma(n), await mH({ hash: o, signature: s })))
        return !0;
    } catch {
    }
    if (p instanceof sq)
      return !1;
    throw p;
  }
}
async function Tge(e, { address: t, message: n, factory: r, factoryData: i, signature: o, ...s }) {
  const c = Tq(n);
  return KM(e, {
    address: t,
    factory: r,
    factoryData: i,
    hash: c,
    signature: o,
    ...s
  });
}
async function _ge(e, t) {
  const { address: n, factory: r, factoryData: i, signature: o, message: s, primaryType: c, types: u, domain: f, ...p } = t, y = wve({ message: s, primaryType: c, types: u, domain: f });
  return KM(e, {
    address: n,
    factory: r,
    factoryData: i,
    hash: y,
    signature: o,
    ...p
  });
}
function Rge(e, t) {
  const { abi: n, address: r, args: i, batch: o = !0, eventName: s, fromBlock: c, onError: u, onLogs: f, poll: p, pollingInterval: y = e.pollingInterval, strict: v } = t;
  return (typeof p < "u" ? p : typeof c == "bigint" ? !0 : !(e.transport.type === "webSocket" || e.transport.type === "fallback" && e.transport.transports[0].config.type === "webSocket")) ? (() => {
    const A = v ?? !1, R = Pa([
      "watchContractEvent",
      r,
      i,
      o,
      e.uid,
      s,
      y,
      A,
      c
    ]);
    return Yh(R, { onLogs: f, onError: u }, (I) => {
      let D;
      c !== void 0 && (D = c - 1n);
      let M, L = !1;
      const j = GC(async () => {
        var F;
        if (!L) {
          try {
            M = await Dn(e, yq, "createContractEventFilter")({
              abi: n,
              address: r,
              args: i,
              eventName: s,
              strict: A,
              fromBlock: c
            });
          } catch {
          }
          L = !0;
          return;
        }
        try {
          let O;
          if (M)
            O = await Dn(e, H8, "getFilterChanges")({ filter: M });
          else {
            const z = await Dn(e, WC, "getBlockNumber")({});
            D && D < z ? O = await Dn(e, bq, "getContractEvents")({
              abi: n,
              address: r,
              args: i,
              eventName: s,
              fromBlock: D + 1n,
              toBlock: z,
              strict: A
            }) : O = [], D = z;
          }
          if (O.length === 0)
            return;
          if (o)
            I.onLogs(O);
          else
            for (const z of O)
              I.onLogs([z]);
        } catch (O) {
          M && O instanceof Xm && (L = !1), (F = I.onError) == null || F.call(I, O);
        }
      }, {
        emitOnBegin: !0,
        interval: y
      });
      return async () => {
        M && await Dn(e, q8, "uninstallFilter")({ filter: M }), j();
      };
    });
  })() : (() => {
    const A = v ?? !1, R = Pa([
      "watchContractEvent",
      r,
      i,
      o,
      e.uid,
      s,
      y,
      A
    ]);
    let I = !0, D = () => I = !1;
    return Yh(R, { onLogs: f, onError: u }, (M) => ((async () => {
      try {
        const L = (() => {
          if (e.transport.type === "fallback") {
            const O = e.transport.transports.find((z) => z.config.type === "webSocket");
            return O ? O.value : e.transport;
          }
          return e.transport;
        })(), j = s ? qC({
          abi: n,
          eventName: s,
          args: i
        }) : [], { unsubscribe: F } = await L.subscribe({
          params: ["logs", { address: r, topics: j }],
          onData(O) {
            var H;
            if (!I)
              return;
            const z = O.result;
            try {
              const { eventName: Q, args: Y } = jM({
                abi: n,
                data: z.data,
                topics: z.topics,
                strict: v
              }), ee = Kh(z, {
                args: Y,
                eventName: Q
              });
              M.onLogs([ee]);
            } catch (Q) {
              let Y, ee;
              if (Q instanceof $1 || Q instanceof I8) {
                if (v)
                  return;
                Y = Q.abiItem.name, ee = (H = Q.abiItem.inputs) == null ? void 0 : H.some((X) => !("name" in X && X.name));
              }
              const ie = Kh(z, {
                args: ee ? [] : {},
                eventName: Y
              });
              M.onLogs([ie]);
            }
          },
          onError(O) {
            var z;
            (z = M.onError) == null || z.call(M, O);
          }
        });
        D = F, I || D();
      } catch (L) {
        u == null || u(L);
      }
    })(), () => D()));
  })();
}
function aC(e, t, n) {
  const r = e[t.name];
  if (typeof r == "function")
    return r;
  const i = e[n];
  return typeof i == "function" ? i : (o) => t(e, o);
}
const l4 = "2.14.1", Oge = () => `@wagmi/core@${l4}`;
var Uq = function(e, t, n, r) {
  if (n === "a" && !r) throw new TypeError("Private accessor was defined without a getter");
  if (typeof t == "function" ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? r : n === "a" ? r.call(e) : r ? r.value : t.get(e);
}, B4, zq;
let lf = class D5 extends Error {
  get docsBaseUrl() {
    return "https://wagmi.sh/core";
  }
  get version() {
    return Oge();
  }
  constructor(t, n = {}) {
    var o;
    super(), B4.add(this), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "WagmiCoreError"
    });
    const r = n.cause instanceof D5 ? n.cause.details : (o = n.cause) != null && o.message ? n.cause.message : n.details, i = n.cause instanceof D5 && n.cause.docsPath || n.docsPath;
    this.message = [
      t || "An error occurred.",
      "",
      ...n.metaMessages ? [...n.metaMessages, ""] : [],
      ...i ? [
        `Docs: ${this.docsBaseUrl}${i}.html${n.docsSlug ? `#${n.docsSlug}` : ""}`
      ] : [],
      ...r ? [`Details: ${r}`] : [],
      `Version: ${this.version}`
    ].join(`
`), n.cause && (this.cause = n.cause), this.details = r, this.docsPath = i, this.metaMessages = n.metaMessages, this.shortMessage = t;
  }
  walk(t) {
    return Uq(this, B4, "m", zq).call(this, this, t);
  }
};
B4 = /* @__PURE__ */ new WeakSet(), zq = function e(t, n) {
  return n != null && n(t) ? t : t.cause ? Uq(this, B4, "m", e).call(this, t.cause, n) : t;
};
class Zm extends lf {
  constructor() {
    super("Chain not configured."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ChainNotConfiguredError"
    });
  }
}
class Ige extends lf {
  constructor() {
    super("Connector already connected."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ConnectorAlreadyConnectedError"
    });
  }
}
class Dge extends lf {
  constructor() {
    super("Connector not connected."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ConnectorNotConnectedError"
    });
  }
}
class Mge extends lf {
  constructor({ address: t, connector: n }) {
    super(`Account "${t}" not found for connector "${n.name}".`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ConnectorAccountNotFoundError"
    });
  }
}
class Pge extends lf {
  constructor({ connectionChainId: t, connectorChainId: n }) {
    super(`The current chain of the connector (id: ${n}) does not match the connection's chain (id: ${t}).`, {
      metaMessages: [
        `Current Chain ID:  ${n}`,
        `Expected Chain ID: ${t}`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ConnectorChainMismatchError"
    });
  }
}
class Nge extends lf {
  constructor({ connector: t }) {
    super(`Connector "${t.name}" unavailable while reconnecting.`, {
      details: [
        "During the reconnection step, the only connector methods guaranteed to be available are: `id`, `name`, `type`, `uuid`.",
        "All other methods are not guaranteed to be available until reconnection completes and connectors are fully restored.",
        "This error commonly occurs for connectors that asynchronously inject after reconnection has already started."
      ].join(" ")
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ConnectorUnavailableReconnectingError"
    });
  }
}
async function Vq(e, t) {
  var r;
  let n;
  if (typeof t.connector == "function" ? n = e._internal.connectors.setup(t.connector) : n = t.connector, n.uid === e.state.current)
    throw new Ige();
  try {
    e.setState((s) => ({ ...s, status: "connecting" })), n.emitter.emit("message", { type: "connecting" });
    const i = await n.connect({ chainId: t.chainId }), o = i.accounts;
    return n.emitter.off("connect", e._internal.events.connect), n.emitter.on("change", e._internal.events.change), n.emitter.on("disconnect", e._internal.events.disconnect), await ((r = e.storage) == null ? void 0 : r.setItem("recentConnectorId", n.id)), e.setState((s) => ({
      ...s,
      connections: new Map(s.connections).set(n.uid, {
        accounts: o,
        chainId: i.chainId,
        connector: n
      }),
      current: n.uid,
      status: "connected"
    })), { accounts: o, chainId: i.chainId };
  } catch (i) {
    throw e.setState((o) => ({
      ...o,
      // Keep existing connector connected in case of error
      status: o.current ? "connected" : "disconnected"
    })), i;
  }
}
const M5 = 256;
let Ck = M5, xk;
function $q(e = 11) {
  if (!xk || Ck + e > M5 * 2) {
    xk = "", Ck = 0;
    for (let t = 0; t < M5; t++)
      xk += (256 + Math.random() * 256 | 0).toString(16).substring(1);
  }
  return xk.substring(Ck, Ck++ + e);
}
function G8(e) {
  const { batch: t, cacheTime: n = e.pollingInterval ?? 4e3, ccipRead: r, key: i = "base", name: o = "Base Client", pollingInterval: s = 4e3, type: c = "base" } = e, u = e.chain, f = e.account ? nc(e.account) : void 0, { config: p, request: y, value: v } = e.transport({
    chain: u,
    pollingInterval: s
  }), w = { ...p, ...v }, C = {
    account: f,
    batch: t,
    cacheTime: n,
    ccipRead: r,
    chain: u,
    key: i,
    name: o,
    pollingInterval: s,
    request: y,
    transport: w,
    type: c,
    uid: $q()
  };
  function x(A) {
    return (R) => {
      const I = R(A);
      for (const M in C)
        delete I[M];
      const D = { ...A, ...I };
      return Object.assign(D, { extend: x(D) });
    };
  }
  return Object.assign(C, { extend: x(C) });
}
function Hq({ key: e, name: t, request: n, retryCount: r = 3, retryDelay: i = 150, timeout: o, type: s }, c) {
  const u = $q();
  return {
    config: {
      key: e,
      name: t,
      request: n,
      retryCount: r,
      retryDelay: i,
      timeout: o,
      type: s
    },
    request: pve(n, { retryCount: r, retryDelay: i, uid: u }),
    value: c
  };
}
function Bge(e, t = {}) {
  const { key: n = "custom", name: r = "Custom Provider", retryDelay: i } = t;
  return ({ retryCount: o }) => Hq({
    key: n,
    name: r,
    request: e.request.bind(e),
    retryCount: t.retryCount ?? o,
    retryDelay: i,
    type: "custom"
  });
}
class Lge extends it {
  constructor() {
    super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
      docsPath: "/docs/clients/intro",
      name: "UrlRequiredError"
    });
  }
}
function qq(e, t = {}) {
  const { batch: n, fetchOptions: r, key: i = "http", name: o = "HTTP JSON-RPC", onFetchRequest: s, onFetchResponse: c, retryDelay: u } = t;
  return ({ chain: f, retryCount: p, timeout: y }) => {
    const { batchSize: v = 1e3, wait: w = 0 } = typeof n == "object" ? n : {}, C = t.retryCount ?? p, x = y ?? t.timeout ?? 1e4, A = e || (f == null ? void 0 : f.rpcUrls.default.http[0]);
    if (!A)
      throw new Lge();
    const R = bve(A, {
      fetchOptions: r,
      onRequest: s,
      onResponse: c,
      timeout: x
    });
    return Hq({
      key: i,
      name: o,
      async request({ method: I, params: D }) {
        const M = { method: I, params: D }, { schedule: L } = uq({
          id: A,
          wait: w,
          shouldSplitBatch(z) {
            return z.length > v;
          },
          fn: (z) => R.request({
            body: z
          }),
          sort: (z, H) => z.id - H.id
        }), j = async (z) => n ? L(z) : [
          await R.request({
            body: z
          })
        ], [{ error: F, result: O }] = await j(M);
        if (F)
          throw new SH({
            body: M,
            error: F,
            url: A
          });
        return O;
      },
      retryCount: C,
      retryDelay: u,
      timeout: x,
      type: "http"
    }, {
      fetchOptions: r,
      url: A
    });
  };
}
function jge(e) {
  var y, v, w;
  const { scheme: t, statement: n, ...r } = ((y = e.match(Fge)) == null ? void 0 : y.groups) ?? {}, { chainId: i, expirationTime: o, issuedAt: s, notBefore: c, requestId: u, ...f } = ((v = e.match(Uge)) == null ? void 0 : v.groups) ?? {}, p = (w = e.split("Resources:")[1]) == null ? void 0 : w.split(`
- `).slice(1);
  return {
    ...r,
    ...f,
    ...i ? { chainId: Number(i) } : {},
    ...o ? { expirationTime: new Date(o) } : {},
    ...s ? { issuedAt: new Date(s) } : {},
    ...c ? { notBefore: new Date(c) } : {},
    ...u ? { requestId: u } : {},
    ...p ? { resources: p } : {},
    ...t ? { scheme: t } : {},
    ...n ? { statement: n } : {}
  };
}
const Fge = /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\/\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\n)(?<address>0x[a-fA-F0-9]{40})\n\n(?:(?<statement>.*)\n\n)?/, Uge = /(?:URI: (?<uri>.+))\n(?:Version: (?<version>.+))\n(?:Chain ID: (?<chainId>\d+))\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\n(?:Issued At: (?<issuedAt>.+))(?:\nExpiration Time: (?<expirationTime>.+))?(?:\nNot Before: (?<notBefore>.+))?(?:\nRequest ID: (?<requestId>.+))?/;
function zge(e) {
  const { address: t, domain: n, message: r, nonce: i, scheme: o, time: s = /* @__PURE__ */ new Date() } = e;
  if (n && r.domain !== n || i && r.nonce !== i || o && r.scheme !== o || r.expirationTime && s >= r.expirationTime || r.notBefore && s < r.notBefore)
    return !1;
  try {
    if (!r.address || t && !LM(r.address, t))
      return !1;
  } catch {
    return !1;
  }
  return !0;
}
async function Vge(e, t) {
  const { address: n, domain: r, message: i, nonce: o, scheme: s, signature: c, time: u = /* @__PURE__ */ new Date(), ...f } = t, p = jge(i);
  if (!p.address || !zge({
    address: n,
    domain: r,
    message: p,
    nonce: o,
    scheme: s,
    time: u
  }))
    return !1;
  const v = Tq(i);
  return KM(e, {
    address: p.address,
    hash: v,
    signature: c,
    ...f
  });
}
function $ge(e) {
  return {
    call: (t) => V8(e, t),
    createBlockFilter: () => Uye(e),
    createContractEventFilter: (t) => yq(e, t),
    createEventFilter: (t) => vq(e, t),
    createPendingTransactionFilter: () => gq(e),
    estimateContractGas: (t) => Vye(e, t),
    estimateGas: (t) => L8(e, t),
    getBalance: (t) => IH(e, t),
    getBlobBaseFee: () => $ye(e),
    getBlock: (t) => Gh(e, t),
    getBlockNumber: (t) => WC(e, t),
    getBlockTransactionCount: (t) => Yye(e, t),
    getBytecode: (t) => EF(e, t),
    getChainId: () => kM(e),
    getCode: (t) => EF(e, t),
    getContractEvents: (t) => bq(e, t),
    getEip712Domain: (t) => Zye(e, t),
    getEnsAddress: (t) => Aye(e, t),
    getEnsAvatar: (t) => pq(e, t),
    getEnsName: (t) => mq(e, t),
    getEnsResolver: (t) => Fye(e, t),
    getEnsText: (t) => hq(e, t),
    getFeeHistory: (t) => nve(e, t),
    estimateFeesPerGas: (t) => Vpe(e, t),
    getFilterChanges: (t) => H8(e, t),
    getFilterLogs: (t) => rve(e, t),
    getGasPrice: () => _M(e),
    getLogs: (t) => UM(e, t),
    getProof: (t) => $ve(e, t),
    estimateMaxPriorityFeePerGas: (t) => zpe(e, t),
    getStorageAt: (t) => ive(e, t),
    getTransaction: (t) => zM(e, t),
    getTransactionConfirmations: (t) => ove(e, t),
    getTransactionCount: (t) => DH(e, t),
    getTransactionReceipt: (t) => A5(e, t),
    multicall: (t) => lve(e, t),
    prepareTransactionRequest: (t) => j8(e, t),
    readContract: (t) => ef(e, t),
    sendRawTransaction: (t) => VH(e, t),
    simulateContract: (t) => Wve(e, t),
    verifyMessage: (t) => Tge(e, t),
    verifySiweMessage: (t) => Vge(e, t),
    verifyTypedData: (t) => _ge(e, t),
    uninstallFilter: (t) => q8(e, t),
    waitForTransactionReceipt: (t) => Hve(e, t),
    watchBlocks: (t) => uve(e, t),
    watchBlockNumber: (t) => Cq(e, t),
    watchContractEvent: (t) => Rge(e, t),
    watchEvent: (t) => dve(e, t),
    watchPendingTransactions: (t) => fve(e, t)
  };
}
async function Wq(e, t = {}) {
  let n;
  if (t.connector) {
    const { connector: f } = t;
    if (e.state.status === "reconnecting" && !f.getAccounts && !f.getChainId)
      throw new Nge({ connector: f });
    const [p, y] = await Promise.all([
      f.getAccounts(),
      f.getChainId()
    ]);
    n = {
      accounts: p,
      chainId: y,
      connector: f
    };
  } else
    n = e.state.connections.get(e.state.current);
  if (!n)
    throw new Dge();
  const r = t.chainId ?? n.chainId, i = await n.connector.getChainId();
  if (i !== n.chainId)
    throw new Pge({
      connectionChainId: n.chainId,
      connectorChainId: i
    });
  const o = n.connector;
  if (o.getClient)
    return o.getClient({ chainId: r });
  const s = nc(t.account ?? n.accounts[0]);
  if (s.address = Ma(s.address), t.account && !n.accounts.some((f) => f.toLowerCase() === s.address.toLowerCase()))
    throw new Mge({
      address: s.address,
      connector: o
    });
  const c = e.chains.find((f) => f.id === r), u = await n.connector.getProvider({ chainId: r });
  return G8({
    account: s,
    chain: c,
    name: "Connector Client",
    transport: (f) => Bge(u)({ ...f, retryCount: 0 })
  });
}
async function Hge(e, t = {}) {
  var i, o;
  let n;
  if (t.connector)
    n = t.connector;
  else {
    const { connections: s, current: c } = e.state, u = s.get(c);
    n = u == null ? void 0 : u.connector;
  }
  const r = e.state.connections;
  n && (await n.disconnect(), n.emitter.off("change", e._internal.events.change), n.emitter.off("disconnect", e._internal.events.disconnect), n.emitter.on("connect", e._internal.events.connect), r.delete(n.uid)), e.setState((s) => {
    if (r.size === 0)
      return {
        ...s,
        connections: /* @__PURE__ */ new Map(),
        current: null,
        status: "disconnected"
      };
    const c = r.values().next().value;
    return {
      ...s,
      connections: new Map(r),
      current: c.connector.uid
    };
  });
  {
    const s = e.state.current;
    if (!s)
      return;
    const c = (i = e.state.connections.get(s)) == null ? void 0 : i.connector;
    if (!c)
      return;
    await ((o = e.storage) == null ? void 0 : o.setItem("recentConnectorId", c.id));
  }
}
function YM(e) {
  const t = e.state.current, n = e.state.connections.get(t), r = n == null ? void 0 : n.accounts, i = r == null ? void 0 : r[0], o = e.chains.find((c) => c.id === (n == null ? void 0 : n.chainId)), s = e.state.status;
  switch (s) {
    case "connected":
      return {
        address: i,
        addresses: r,
        chain: o,
        chainId: n == null ? void 0 : n.chainId,
        connector: n == null ? void 0 : n.connector,
        isConnected: !0,
        isConnecting: !1,
        isDisconnected: !1,
        isReconnecting: !1,
        status: s
      };
    case "reconnecting":
      return {
        address: i,
        addresses: r,
        chain: o,
        chainId: n == null ? void 0 : n.chainId,
        connector: n == null ? void 0 : n.connector,
        isConnected: !!i,
        isConnecting: !1,
        isDisconnected: !1,
        isReconnecting: !0,
        status: s
      };
    case "connecting":
      return {
        address: i,
        addresses: r,
        chain: o,
        chainId: n == null ? void 0 : n.chainId,
        connector: n == null ? void 0 : n.connector,
        isConnected: !1,
        isConnecting: !0,
        isDisconnected: !1,
        isReconnecting: !1,
        status: s
      };
    case "disconnected":
      return {
        address: void 0,
        addresses: void 0,
        chain: void 0,
        chainId: void 0,
        connector: void 0,
        isConnected: !1,
        isConnecting: !1,
        isDisconnected: !0,
        isReconnecting: !1,
        status: s
      };
  }
}
function PF(e) {
  return e.state.chainId;
}
function Qh(e, t) {
  if (e === t)
    return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    if (e.constructor !== t.constructor)
      return !1;
    let n, r;
    if (Array.isArray(e) && Array.isArray(t)) {
      if (n = e.length, n !== t.length)
        return !1;
      for (r = n; r-- !== 0; )
        if (!Qh(e[r], t[r]))
          return !1;
      return !0;
    }
    if (e.valueOf !== Object.prototype.valueOf)
      return e.valueOf() === t.valueOf();
    if (e.toString !== Object.prototype.toString)
      return e.toString() === t.toString();
    const i = Object.keys(e);
    if (n = i.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(t, i[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const o = i[r];
      if (o && !Qh(e[o], t[o]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
let aO = [];
function NF(e) {
  const t = e.chains;
  return Qh(aO, t) ? aO : (aO = t, t);
}
function qge(e, t = {}) {
  let n;
  try {
    n = e.getClient(t);
  } catch {
  }
  return n;
}
let Ek = [];
function P5(e) {
  const t = [...e.state.connections.values()];
  return e.state.status === "reconnecting" || Qh(Ek, t) ? Ek : (Ek = t, t);
}
let sO = [];
function BF(e) {
  const t = e.connectors;
  return Qh(sO, t) ? sO : (sO = t, t);
}
function Wge(e, t) {
  const { chainId: n, ...r } = t, i = e.getClient({ chainId: n });
  return aC(i, pq, "getEnsAvatar")(r);
}
function Gge(e, t) {
  const { chainId: n, ...r } = t, i = e.getClient({ chainId: n });
  return aC(i, mq, "getEnsName")(r);
}
function N5(e, t = {}) {
  const n = qge(e, t);
  return n == null ? void 0 : n.extend($ge);
}
let lO = !1;
async function Kge(e, t = {}) {
  var f, p;
  if (lO)
    return [];
  lO = !0, e.setState((y) => ({
    ...y,
    status: y.current ? "reconnecting" : "connecting"
  }));
  const n = [];
  if ((f = t.connectors) != null && f.length)
    for (const y of t.connectors) {
      let v;
      typeof y == "function" ? v = e._internal.connectors.setup(y) : v = y, n.push(v);
    }
  else
    n.push(...e.connectors);
  let r;
  try {
    r = await ((p = e.storage) == null ? void 0 : p.getItem("recentConnectorId"));
  } catch {
  }
  const i = {};
  for (const [, y] of e.state.connections)
    i[y.connector.id] = 1;
  r && (i[r] = 0);
  const o = Object.keys(i).length > 0 ? (
    // .toSorted()
    [...n].sort((y, v) => (i[y.id] ?? 10) - (i[v.id] ?? 10))
  ) : n;
  let s = !1;
  const c = [], u = [];
  for (const y of o) {
    const v = await y.getProvider().catch(() => {
    });
    if (!v || u.some((x) => x === v) || !await y.isAuthorized())
      continue;
    const C = await y.connect({ isReconnecting: !0 }).catch(() => null);
    C && (y.emitter.off("connect", e._internal.events.connect), y.emitter.on("change", e._internal.events.change), y.emitter.on("disconnect", e._internal.events.disconnect), e.setState((x) => {
      const A = new Map(s ? x.connections : /* @__PURE__ */ new Map()).set(y.uid, { accounts: C.accounts, chainId: C.chainId, connector: y });
      return {
        ...x,
        current: s ? x.current : y.uid,
        connections: A
      };
    }), c.push({
      accounts: C.accounts,
      chainId: C.chainId,
      connector: y
    }), u.push(v), s = !0);
  }
  return (e.state.status === "reconnecting" || e.state.status === "connecting") && (s ? e.setState((y) => ({ ...y, status: "connected" })) : e.setState((y) => ({
    ...y,
    connections: /* @__PURE__ */ new Map(),
    current: null,
    status: "disconnected"
  }))), lO = !1, c;
}
async function Yge(e, t) {
  const { account: n, chainId: r, connector: i, gas: o, ...s } = t;
  let c;
  typeof n == "object" && (n == null ? void 0 : n.type) === "local" ? c = e.getClient({ chainId: r }) : c = await Wq(e, {
    account: n ?? void 0,
    chainId: r,
    connector: i
  });
  const { connector: u } = YM(e), f = await (async () => {
    var v;
    if (!(!("data" in t) || !t.data) && !((v = i ?? u) != null && v.supportsSimulation) && o !== null)
      return o === void 0 ? aC(c, L8, "estimateGas")({
        ...s,
        account: n,
        chain: r ? { id: r } : null
      }) : o;
  })();
  return await aC(c, sme, "sendTransaction")({
    ...s,
    ...n ? { account: n } : {},
    gas: f,
    chain: r ? { id: r } : null
  });
}
async function Qge(e, t) {
  const { account: n, connector: r, ...i } = t;
  let o;
  return typeof n == "object" && n.type === "local" ? o = e.getClient() : o = await Wq(e, { account: n, connector: r }), aC(o, qve, "signMessage")({
    ...i,
    ...n ? { account: n } : {}
  });
}
class Th extends lf {
  constructor() {
    super("Provider not found."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ProviderNotFoundError"
    });
  }
}
class Xge extends lf {
  constructor({ connector: t }) {
    super(`"${t.name}" does not support programmatic chain switching.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SwitchChainNotSupportedError"
    });
  }
}
async function Gq(e, t) {
  var s;
  const { addEthereumChainParameter: n, chainId: r } = t, i = e.state.connections.get(((s = t.connector) == null ? void 0 : s.uid) ?? e.state.current);
  if (i) {
    const c = i.connector;
    if (!c.switchChain)
      throw new Xge({ connector: c });
    return await c.switchChain({
      addEthereumChainParameter: n,
      chainId: r
    });
  }
  const o = e.chains.find((c) => c.id === r);
  if (!o)
    throw new Zm();
  return e.setState((c) => ({ ...c, chainId: r })), o;
}
function Kq(e, t) {
  const { onChange: n } = t;
  return e.subscribe(() => YM(e), n, {
    equalityFn(r, i) {
      const { connector: o, ...s } = r, { connector: c, ...u } = i;
      return Qh(s, u) && // check connector separately
      (o == null ? void 0 : o.id) === (c == null ? void 0 : c.id) && (o == null ? void 0 : o.uid) === (c == null ? void 0 : c.uid);
    }
  });
}
function Jge(e, t) {
  const { onChange: n } = t;
  return e.subscribe((r) => r.chainId, n);
}
function Zge(e, t) {
  const { onChange: n } = t;
  return e.subscribe(() => P5(e), n, {
    equalityFn: Qh
  });
}
function ebe(e, t) {
  const { onChange: n } = t;
  return e._internal.connectors.subscribe((r, i) => {
    n(Object.values(r), i);
  });
}
function tbe(e, t) {
  const { onChange: n } = t;
  return e.subscribe(() => N5(e), n, {
    equalityFn(r, i) {
      return (r == null ? void 0 : r.uid) === (i == null ? void 0 : i.uid);
    }
  });
}
function Mje(e) {
  return e;
}
const nbe = /(rabby|trustwallet)/;
K8.type = "injected";
function K8(e = {}) {
  const { shimDisconnect: t = !0, unstable_shimAsyncInject: n } = e;
  function r() {
    const u = e.target;
    if (typeof u == "function") {
      const f = u();
      if (f)
        return f;
    }
    return typeof u == "object" ? u : typeof u == "string" ? {
      ...rbe[u] ?? {
        id: u,
        name: `${u[0].toUpperCase()}${u.slice(1)}`,
        provider: `is${u[0].toUpperCase()}${u.slice(1)}`
      }
    } : {
      id: "injected",
      name: "Injected",
      provider(f) {
        return f == null ? void 0 : f.ethereum;
      }
    };
  }
  let i, o, s, c;
  return (u) => ({
    get icon() {
      return r().icon;
    },
    get id() {
      return r().id;
    },
    get name() {
      return r().name;
    },
    get supportsSimulation() {
      return nbe.test(this.id.toLowerCase());
    },
    type: K8.type,
    async setup() {
      const f = await this.getProvider();
      f != null && f.on && e.target && (s || (s = this.onConnect.bind(this), f.on("connect", s)), i || (i = this.onAccountsChanged.bind(this), f.on("accountsChanged", i)));
    },
    async connect({ chainId: f, isReconnecting: p } = {}) {
      var w, C, x, A, R, I;
      const y = await this.getProvider();
      if (!y)
        throw new Th();
      let v = [];
      if (p)
        v = await this.getAccounts().catch(() => []);
      else if (t)
        try {
          v = (A = (x = (C = (w = (await y.request({
            method: "wallet_requestPermissions",
            params: [{ eth_accounts: {} }]
          }))[0]) == null ? void 0 : w.caveats) == null ? void 0 : C[0]) == null ? void 0 : x.value) == null ? void 0 : A.map((M) => Ma(M)), v.length > 0 && (v = await this.getAccounts());
        } catch (D) {
          const M = D;
          if (M.code === li.code)
            throw new li(M);
          if (M.code === $h.code)
            throw M;
        }
      try {
        !(v != null && v.length) && !p && (v = (await y.request({
          method: "eth_requestAccounts"
        })).map((L) => Ma(L))), s && (y.removeListener("connect", s), s = void 0), i || (i = this.onAccountsChanged.bind(this), y.on("accountsChanged", i)), o || (o = this.onChainChanged.bind(this), y.on("chainChanged", o)), c || (c = this.onDisconnect.bind(this), y.on("disconnect", c));
        let D = await this.getChainId();
        if (f && D !== f) {
          const M = await this.switchChain({ chainId: f }).catch((L) => {
            if (L.code === li.code)
              throw L;
            return { id: D };
          });
          D = (M == null ? void 0 : M.id) ?? D;
        }
        return t && await ((R = u.storage) == null ? void 0 : R.removeItem(`${this.id}.disconnected`)), e.target || await ((I = u.storage) == null ? void 0 : I.setItem("injected.connected", !0)), { accounts: v, chainId: D };
      } catch (D) {
        const M = D;
        throw M.code === li.code ? new li(M) : M.code === $h.code ? new $h(M) : M;
      }
    },
    async disconnect() {
      var p, y;
      const f = await this.getProvider();
      if (!f)
        throw new Th();
      o && (f.removeListener("chainChanged", o), o = void 0), c && (f.removeListener("disconnect", c), c = void 0), s || (s = this.onConnect.bind(this), f.on("connect", s));
      try {
        await xq(() => (
          // TODO: Remove explicit type for viem@3
          f.request({
            // `'wallet_revokePermissions'` added in `viem@2.10.3`
            method: "wallet_revokePermissions",
            params: [{ eth_accounts: {} }]
          })
        ), { timeout: 100 });
      } catch {
      }
      t && await ((p = u.storage) == null ? void 0 : p.setItem(`${this.id}.disconnected`, !0)), e.target || await ((y = u.storage) == null ? void 0 : y.removeItem("injected.connected"));
    },
    async getAccounts() {
      const f = await this.getProvider();
      if (!f)
        throw new Th();
      return (await f.request({ method: "eth_accounts" })).map((y) => Ma(y));
    },
    async getChainId() {
      const f = await this.getProvider();
      if (!f)
        throw new Th();
      const p = await f.request({ method: "eth_chainId" });
      return Number(p);
    },
    async getProvider() {
      if (typeof window > "u")
        return;
      let f;
      const p = r();
      return typeof p.provider == "function" ? f = p.provider(window) : typeof p.provider == "string" ? f = c4(window, p.provider) : f = p.provider, f && !f.removeListener && ("off" in f && typeof f.off == "function" ? f.removeListener = f.off : f.removeListener = () => {
      }), f;
    },
    async isAuthorized() {
      var f, p;
      try {
        if (t && // If shim exists in storage, connector is disconnected
        await ((f = u.storage) == null ? void 0 : f.getItem(`${this.id}.disconnected`)) || !e.target && !await ((p = u.storage) == null ? void 0 : p.getItem("injected.connected")))
          return !1;
        if (!await this.getProvider()) {
          if (n !== void 0 && n !== !1) {
            const C = async () => (typeof window < "u" && window.removeEventListener("ethereum#initialized", C), !!await this.getProvider()), x = typeof n == "number" ? n : 1e3;
            if (await Promise.race([
              ...typeof window < "u" ? [
                new Promise((R) => window.addEventListener("ethereum#initialized", () => R(C()), { once: !0 }))
              ] : [],
              new Promise((R) => setTimeout(() => R(C()), x))
            ]))
              return !0;
          }
          throw new Th();
        }
        return !!(await N4(() => this.getAccounts())).length;
      } catch {
        return !1;
      }
    },
    async switchChain({ addEthereumChainParameter: f, chainId: p }) {
      var w, C, x, A;
      const y = await this.getProvider();
      if (!y)
        throw new Th();
      const v = u.chains.find((R) => R.id === p);
      if (!v)
        throw new Xl(new Zm());
      try {
        return await Promise.all([
          y.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: en(p) }]
          }).then(async () => {
            await this.getChainId() === p && u.emitter.emit("change", { chainId: p });
          }),
          new Promise((R) => {
            const I = (D) => {
              "chainId" in D && D.chainId === p && (u.emitter.off("change", I), R());
            };
            u.emitter.on("change", I);
          })
        ]), v;
      } catch (R) {
        const I = R;
        if (I.code === 4902 || // Unwrapping for MetaMask Mobile
        // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719
        ((C = (w = I == null ? void 0 : I.data) == null ? void 0 : w.originalError) == null ? void 0 : C.code) === 4902)
          try {
            const { default: D, ...M } = v.blockExplorers ?? {};
            let L;
            f != null && f.blockExplorerUrls ? L = f.blockExplorerUrls : D && (L = [
              D.url,
              ...Object.values(M).map((z) => z.url)
            ]);
            let j;
            (x = f == null ? void 0 : f.rpcUrls) != null && x.length ? j = f.rpcUrls : j = [((A = v.rpcUrls.default) == null ? void 0 : A.http[0]) ?? ""];
            const F = {
              blockExplorerUrls: L,
              chainId: en(p),
              chainName: (f == null ? void 0 : f.chainName) ?? v.name,
              iconUrls: f == null ? void 0 : f.iconUrls,
              nativeCurrency: (f == null ? void 0 : f.nativeCurrency) ?? v.nativeCurrency,
              rpcUrls: j
            };
            if (await y.request({
              method: "wallet_addEthereumChain",
              params: [F]
            }), await this.getChainId() !== p)
              throw new li(new Error("User rejected switch after adding network."));
            return v;
          } catch (D) {
            throw new li(D);
          }
        throw I.code === li.code ? new li(I) : new Xl(I);
      }
    },
    async onAccountsChanged(f) {
      var p;
      if (f.length === 0)
        this.onDisconnect();
      else if (u.emitter.listenerCount("connect")) {
        const y = (await this.getChainId()).toString();
        this.onConnect({ chainId: y }), t && await ((p = u.storage) == null ? void 0 : p.removeItem(`${this.id}.disconnected`));
      } else
        u.emitter.emit("change", {
          accounts: f.map((y) => Ma(y))
        });
    },
    onChainChanged(f) {
      const p = Number(f);
      u.emitter.emit("change", { chainId: p });
    },
    async onConnect(f) {
      const p = await this.getAccounts();
      if (p.length === 0)
        return;
      const y = Number(f.chainId);
      u.emitter.emit("connect", { accounts: p, chainId: y });
      const v = await this.getProvider();
      v && (s && (v.removeListener("connect", s), s = void 0), i || (i = this.onAccountsChanged.bind(this), v.on("accountsChanged", i)), o || (o = this.onChainChanged.bind(this), v.on("chainChanged", o)), c || (c = this.onDisconnect.bind(this), v.on("disconnect", c)));
    },
    async onDisconnect(f) {
      const p = await this.getProvider();
      f && f.code === 1013 && p && (await this.getAccounts()).length || (u.emitter.emit("disconnect"), p && (o && (p.removeListener("chainChanged", o), o = void 0), c && (p.removeListener("disconnect", c), c = void 0), s || (s = this.onConnect.bind(this), p.on("connect", s))));
    }
  });
}
const rbe = {
  coinbaseWallet: {
    id: "coinbaseWallet",
    name: "Coinbase Wallet",
    provider(e) {
      return e != null && e.coinbaseWalletExtension ? e.coinbaseWalletExtension : c4(e, "isCoinbaseWallet");
    }
  },
  metaMask: {
    id: "metaMask",
    name: "MetaMask",
    provider(e) {
      return c4(e, (t) => {
        if (!t.isMetaMask || t.isBraveWallet && !t._events && !t._state)
          return !1;
        const n = [
          "isApexWallet",
          "isAvalanche",
          "isBitKeep",
          "isBlockWallet",
          "isKuCoinWallet",
          "isMathWallet",
          "isOkxWallet",
          "isOKExWallet",
          "isOneInchIOSWallet",
          "isOneInchAndroidWallet",
          "isOpera",
          "isPortal",
          "isRabby",
          "isTokenPocket",
          "isTokenary",
          "isUniswapWallet",
          "isZerion"
        ];
        for (const r of n)
          if (t[r])
            return !1;
        return !0;
      });
    }
  },
  phantom: {
    id: "phantom",
    name: "Phantom",
    provider(e) {
      var t, n;
      return (t = e == null ? void 0 : e.phantom) != null && t.ethereum ? (n = e.phantom) == null ? void 0 : n.ethereum : c4(e, "isPhantom");
    }
  }
};
function c4(e, t) {
  function n(i) {
    return typeof t == "function" ? t(i) : typeof t == "string" ? i[t] : !0;
  }
  const r = e.ethereum;
  if (r != null && r.providers)
    return r.providers.find((i) => n(i));
  if (r && n(r))
    return r;
}
function ibe(e) {
  if (typeof window > "u")
    return;
  const t = (n) => e(n.detail);
  return window.addEventListener("eip6963:announceProvider", t), window.dispatchEvent(new CustomEvent("eip6963:requestProvider")), () => window.removeEventListener("eip6963:announceProvider", t);
}
function obe() {
  const e = /* @__PURE__ */ new Set();
  let t = [];
  const n = () => ibe((i) => {
    t.some(({ info: o }) => o.uuid === i.info.uuid) || (t = [...t, i], e.forEach((o) => o(t, { added: [i] })));
  });
  let r = n();
  return {
    _listeners() {
      return e;
    },
    clear() {
      e.forEach((i) => i([], { removed: [...t] })), t = [];
    },
    destroy() {
      this.clear(), e.clear(), r == null || r();
    },
    findProvider({ rdns: i }) {
      return t.find((o) => o.info.rdns === i);
    },
    getProviders() {
      return t;
    },
    reset() {
      this.clear(), r == null || r(), r = n();
    },
    subscribe(i, { emitImmediately: o } = {}) {
      return e.add(i), o && i(t, { added: t }), () => e.delete(i);
    }
  };
}
const abe = (e) => (t, n, r) => {
  const i = r.subscribe;
  return r.subscribe = (s, c, u) => {
    let f = s;
    if (c) {
      const p = (u == null ? void 0 : u.equalityFn) || Object.is;
      let y = s(r.getState());
      f = (v) => {
        const w = s(v);
        if (!p(y, w)) {
          const C = y;
          c(y = w, C);
        }
      }, u != null && u.fireImmediately && c(y, y);
    }
    return i(f);
  }, e(t, n, r);
}, sbe = abe;
function lbe(e, t) {
  let n;
  try {
    n = e();
  } catch {
    return;
  }
  return {
    getItem: (i) => {
      var o;
      const s = (u) => u === null ? null : JSON.parse(u, void 0), c = (o = n.getItem(i)) != null ? o : null;
      return c instanceof Promise ? c.then(s) : s(c);
    },
    setItem: (i, o) => n.setItem(
      i,
      JSON.stringify(o, void 0)
    ),
    removeItem: (i) => n.removeItem(i)
  };
}
const B5 = (e) => (t) => {
  try {
    const n = e(t);
    return n instanceof Promise ? n : {
      then(r) {
        return B5(r)(n);
      },
      catch(r) {
        return this;
      }
    };
  } catch (n) {
    return {
      then(r) {
        return this;
      },
      catch(r) {
        return B5(r)(n);
      }
    };
  }
}, cbe = (e, t) => (n, r, i) => {
  let o = {
    storage: lbe(() => localStorage),
    partialize: (x) => x,
    version: 0,
    merge: (x, A) => ({
      ...A,
      ...x
    }),
    ...t
  }, s = !1;
  const c = /* @__PURE__ */ new Set(), u = /* @__PURE__ */ new Set();
  let f = o.storage;
  if (!f)
    return e(
      (...x) => {
        n(...x);
      },
      r,
      i
    );
  const p = () => {
    const x = o.partialize({ ...r() });
    return f.setItem(o.name, {
      state: x,
      version: o.version
    });
  }, y = i.setState;
  i.setState = (x, A) => {
    y(x, A), p();
  };
  const v = e(
    (...x) => {
      n(...x), p();
    },
    r,
    i
  );
  i.getInitialState = () => v;
  let w;
  const C = () => {
    var x, A;
    if (!f) return;
    s = !1, c.forEach((I) => {
      var D;
      return I((D = r()) != null ? D : v);
    });
    const R = ((A = o.onRehydrateStorage) == null ? void 0 : A.call(o, (x = r()) != null ? x : v)) || void 0;
    return B5(f.getItem.bind(f))(o.name).then((I) => {
      if (I)
        if (typeof I.version == "number" && I.version !== o.version) {
          if (o.migrate)
            return [
              !0,
              o.migrate(
                I.state,
                I.version
              )
            ];
        } else
          return [!1, I.state];
      return [!1, void 0];
    }).then((I) => {
      var D;
      const [M, L] = I;
      if (w = o.merge(
        L,
        (D = r()) != null ? D : v
      ), n(w, !0), M)
        return p();
    }).then(() => {
      R == null || R(w, void 0), w = r(), s = !0, u.forEach((I) => I(w));
    }).catch((I) => {
      R == null || R(void 0, I);
    });
  };
  return i.persist = {
    setOptions: (x) => {
      o = {
        ...o,
        ...x
      }, x.storage && (f = x.storage);
    },
    clearStorage: () => {
      f == null || f.removeItem(o.name);
    },
    getOptions: () => o,
    rehydrate: () => C(),
    hasHydrated: () => s,
    onHydrate: (x) => (c.add(x), () => {
      c.delete(x);
    }),
    onFinishHydration: (x) => (u.add(x), () => {
      u.delete(x);
    })
  }, o.skipHydration || C(), w || v;
}, ube = cbe, LF = (e) => {
  let t;
  const n = /* @__PURE__ */ new Set(), r = (f, p) => {
    const y = typeof f == "function" ? f(t) : f;
    if (!Object.is(y, t)) {
      const v = t;
      t = p ?? (typeof y != "object" || y === null) ? y : Object.assign({}, t, y), n.forEach((w) => w(t, v));
    }
  }, i = () => t, c = { setState: r, getState: i, getInitialState: () => u, subscribe: (f) => (n.add(f), () => n.delete(f)) }, u = t = e(r, i, c);
  return c;
}, cO = (e) => e ? LF(e) : LF;
var Yq = { exports: {} };
(function(e) {
  var t = Object.prototype.hasOwnProperty, n = "~";
  function r() {
  }
  Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (n = !1));
  function i(u, f, p) {
    this.fn = u, this.context = f, this.once = p || !1;
  }
  function o(u, f, p, y, v) {
    if (typeof p != "function")
      throw new TypeError("The listener must be a function");
    var w = new i(p, y || u, v), C = n ? n + f : f;
    return u._events[C] ? u._events[C].fn ? u._events[C] = [u._events[C], w] : u._events[C].push(w) : (u._events[C] = w, u._eventsCount++), u;
  }
  function s(u, f) {
    --u._eventsCount === 0 ? u._events = new r() : delete u._events[f];
  }
  function c() {
    this._events = new r(), this._eventsCount = 0;
  }
  c.prototype.eventNames = function() {
    var f = [], p, y;
    if (this._eventsCount === 0) return f;
    for (y in p = this._events)
      t.call(p, y) && f.push(n ? y.slice(1) : y);
    return Object.getOwnPropertySymbols ? f.concat(Object.getOwnPropertySymbols(p)) : f;
  }, c.prototype.listeners = function(f) {
    var p = n ? n + f : f, y = this._events[p];
    if (!y) return [];
    if (y.fn) return [y.fn];
    for (var v = 0, w = y.length, C = new Array(w); v < w; v++)
      C[v] = y[v].fn;
    return C;
  }, c.prototype.listenerCount = function(f) {
    var p = n ? n + f : f, y = this._events[p];
    return y ? y.fn ? 1 : y.length : 0;
  }, c.prototype.emit = function(f, p, y, v, w, C) {
    var x = n ? n + f : f;
    if (!this._events[x]) return !1;
    var A = this._events[x], R = arguments.length, I, D;
    if (A.fn) {
      switch (A.once && this.removeListener(f, A.fn, void 0, !0), R) {
        case 1:
          return A.fn.call(A.context), !0;
        case 2:
          return A.fn.call(A.context, p), !0;
        case 3:
          return A.fn.call(A.context, p, y), !0;
        case 4:
          return A.fn.call(A.context, p, y, v), !0;
        case 5:
          return A.fn.call(A.context, p, y, v, w), !0;
        case 6:
          return A.fn.call(A.context, p, y, v, w, C), !0;
      }
      for (D = 1, I = new Array(R - 1); D < R; D++)
        I[D - 1] = arguments[D];
      A.fn.apply(A.context, I);
    } else {
      var M = A.length, L;
      for (D = 0; D < M; D++)
        switch (A[D].once && this.removeListener(f, A[D].fn, void 0, !0), R) {
          case 1:
            A[D].fn.call(A[D].context);
            break;
          case 2:
            A[D].fn.call(A[D].context, p);
            break;
          case 3:
            A[D].fn.call(A[D].context, p, y);
            break;
          case 4:
            A[D].fn.call(A[D].context, p, y, v);
            break;
          default:
            if (!I) for (L = 1, I = new Array(R - 1); L < R; L++)
              I[L - 1] = arguments[L];
            A[D].fn.apply(A[D].context, I);
        }
    }
    return !0;
  }, c.prototype.on = function(f, p, y) {
    return o(this, f, p, y, !1);
  }, c.prototype.once = function(f, p, y) {
    return o(this, f, p, y, !0);
  }, c.prototype.removeListener = function(f, p, y, v) {
    var w = n ? n + f : f;
    if (!this._events[w]) return this;
    if (!p)
      return s(this, w), this;
    var C = this._events[w];
    if (C.fn)
      C.fn === p && (!v || C.once) && (!y || C.context === y) && s(this, w);
    else {
      for (var x = 0, A = [], R = C.length; x < R; x++)
        (C[x].fn !== p || v && !C[x].once || y && C[x].context !== y) && A.push(C[x]);
      A.length ? this._events[w] = A.length === 1 ? A[0] : A : s(this, w);
    }
    return this;
  }, c.prototype.removeAllListeners = function(f) {
    var p;
    return f ? (p = n ? n + f : f, this._events[p] && s(this, p)) : (this._events = new r(), this._eventsCount = 0), this;
  }, c.prototype.off = c.prototype.removeListener, c.prototype.addListener = c.prototype.on, c.prefixed = n, c.EventEmitter = c, e.exports = c;
})(Yq);
var dbe = Yq.exports;
const fbe = /* @__PURE__ */ DC(dbe);
class hbe {
  constructor(t) {
    Object.defineProperty(this, "uid", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "_emitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new fbe()
    });
  }
  on(t, n) {
    this._emitter.on(t, n);
  }
  once(t, n) {
    this._emitter.once(t, n);
  }
  off(t, n) {
    this._emitter.off(t, n);
  }
  emit(t, ...n) {
    const r = n[0];
    this._emitter.emit(t, { uid: this.uid, ...r });
  }
  listenerCount(t) {
    return this._emitter.listenerCount(t);
  }
}
function pbe(e) {
  return new hbe(e);
}
function mbe(e, t) {
  return JSON.parse(e, (n, r) => {
    let i = r;
    return (i == null ? void 0 : i.__type) === "bigint" && (i = BigInt(i.value)), (i == null ? void 0 : i.__type) === "Map" && (i = new Map(i.value)), (t == null ? void 0 : t(n, i)) ?? i;
  });
}
function jF(e, t) {
  return e.slice(0, t).join(".") || ".";
}
function FF(e, t) {
  const { length: n } = e;
  for (let r = 0; r < n; ++r)
    if (e[r] === t)
      return r + 1;
  return 0;
}
function ybe(e, t) {
  const n = typeof e == "function", r = typeof t == "function", i = [], o = [];
  return function(c, u) {
    if (typeof u == "object")
      if (i.length) {
        const f = FF(i, this);
        f === 0 ? i[i.length] = this : (i.splice(f), o.splice(f)), o[o.length] = c;
        const p = FF(i, u);
        if (p !== 0)
          return r ? t.call(this, c, u, jF(o, p)) : `[ref=${jF(o, p)}]`;
      } else
        i[0] = u, o[0] = c;
    return n ? e.call(this, c, u) : u;
  };
}
function vbe(e, t, n, r) {
  return JSON.stringify(e, ybe((i, o) => {
    let s = o;
    return typeof s == "bigint" && (s = { __type: "bigint", value: o.toString() }), s instanceof Map && (s = { __type: "Map", value: Array.from(o.entries()) }), (t == null ? void 0 : t(i, s)) ?? s;
  }, r), n ?? void 0);
}
function gbe(e) {
  const { deserialize: t = mbe, key: n = "wagmi", serialize: r = vbe, storage: i = Qq } = e;
  function o(s) {
    return s instanceof Promise ? s.then((c) => c).catch(() => null) : s;
  }
  return {
    ...i,
    key: n,
    async getItem(s, c) {
      const u = i.getItem(`${n}.${s}`), f = await o(u);
      return f ? t(f) ?? null : c ?? null;
    },
    async setItem(s, c) {
      const u = `${n}.${s}`;
      c === null ? await o(i.removeItem(u)) : await o(i.setItem(u, r(c)));
    },
    async removeItem(s) {
      await o(i.removeItem(`${n}.${s}`));
    }
  };
}
const Qq = {
  getItem: () => null,
  setItem: () => {
  },
  removeItem: () => {
  }
}, L5 = 256;
let Sk = L5, kk;
function bbe(e = 11) {
  if (!kk || Sk + e > L5 * 2) {
    kk = "", Sk = 0;
    for (let t = 0; t < L5; t++)
      kk += (256 + Math.random() * 256 | 0).toString(16).substring(1);
  }
  return kk.substring(Sk, Sk++ + e);
}
function Xq(e) {
  const { multiInjectedProviderDiscovery: t = !0, storage: n = gbe({
    storage: typeof window < "u" && window.localStorage ? window.localStorage : Qq
  }), syncConnectedChain: r = !0, ssr: i = !1, ...o } = e, s = typeof window < "u" && t ? obe() : void 0, c = cO(() => o.chains), u = cO(() => {
    const L = [], j = /* @__PURE__ */ new Set();
    for (const F of o.connectors ?? []) {
      const O = f(F);
      L.push(O), !i && O.rdns && j.add(O.rdns);
    }
    if (!i && s) {
      const F = s.getProviders();
      for (const O of F)
        j.has(O.info.rdns) || L.push(f(p(O)));
    }
    return L;
  });
  function f(L) {
    var O;
    const j = pbe(bbe()), F = {
      ...L({
        emitter: j,
        chains: c.getState(),
        storage: n,
        transports: o.transports
      }),
      emitter: j,
      uid: j.uid
    };
    return j.on("connect", D), (O = F.setup) == null || O.call(F), F;
  }
  function p(L) {
    const { info: j } = L, F = L.provider;
    return K8({ target: { ...j, id: j.rdns, provider: F } });
  }
  const y = /* @__PURE__ */ new Map();
  function v(L = {}) {
    const j = L.chainId ?? A.getState().chainId, F = c.getState().find((z) => z.id === j);
    if (L.chainId && !F)
      throw new Zm();
    {
      const z = y.get(A.getState().chainId);
      if (z && !F)
        return z;
      if (!F)
        throw new Zm();
    }
    {
      const z = y.get(j);
      if (z)
        return z;
    }
    let O;
    if (o.client)
      O = o.client({ chain: F });
    else {
      const z = F.id, H = c.getState().map((ee) => ee.id), Q = {}, Y = Object.entries(o);
      for (const [ee, ie] of Y)
        if (!(ee === "chains" || ee === "client" || ee === "connectors" || ee === "transports"))
          if (typeof ie == "object")
            if (z in ie)
              Q[ee] = ie[z];
            else {
              if (H.some((Z) => Z in ie))
                continue;
              Q[ee] = ie;
            }
          else
            Q[ee] = ie;
      O = G8({
        ...Q,
        chain: F,
        batch: Q.batch ?? { multicall: !0 },
        transport: (ee) => o.transports[z]({ ...ee, connectors: u })
      });
    }
    return y.set(j, O), O;
  }
  function w() {
    return {
      chainId: c.getState()[0].id,
      connections: /* @__PURE__ */ new Map(),
      current: null,
      status: "disconnected"
    };
  }
  let C;
  const x = "0.0.0-canary-";
  l4.startsWith(x) ? C = Number.parseInt(l4.replace(x, "")) : C = Number.parseInt(l4.split(".")[0] ?? "0");
  const A = cO(sbe(
    // only use persist middleware if storage exists
    n ? ube(w, {
      migrate(L, j) {
        if (j === C)
          return L;
        const F = w(), O = R(L, F.chainId);
        return { ...F, chainId: O };
      },
      name: "store",
      partialize(L) {
        return {
          connections: {
            __type: "Map",
            value: Array.from(L.connections.entries()).map(([j, F]) => {
              const { id: O, name: z, type: H, uid: Q } = F.connector;
              return [j, { ...F, connector: { id: O, name: z, type: H, uid: Q } }];
            })
          },
          chainId: L.chainId,
          current: L.current
        };
      },
      merge(L, j) {
        typeof L == "object" && L && "status" in L && delete L.status;
        const F = R(L, j.chainId);
        return {
          ...j,
          ...L,
          chainId: F
        };
      },
      skipHydration: i,
      storage: n,
      version: C
    }) : w
  ));
  A.setState(w());
  function R(L, j) {
    return L && typeof L == "object" && "chainId" in L && typeof L.chainId == "number" && c.getState().some((F) => F.id === L.chainId) ? L.chainId : j;
  }
  r && A.subscribe(({ connections: L, current: j }) => {
    var F;
    return j ? (F = L.get(j)) == null ? void 0 : F.chainId : void 0;
  }, (L) => {
    if (c.getState().some((F) => F.id === L))
      return A.setState((F) => ({
        ...F,
        chainId: L ?? F.chainId
      }));
  }), s == null || s.subscribe((L) => {
    const j = /* @__PURE__ */ new Set(), F = /* @__PURE__ */ new Set();
    for (const z of u.getState())
      j.add(z.id), z.rdns && F.add(z.rdns);
    const O = [];
    for (const z of L) {
      if (F.has(z.info.rdns))
        continue;
      const H = f(p(z));
      j.has(H.id) || O.push(H);
    }
    n && !A.persist.hasHydrated() || u.setState((z) => [...z, ...O], !0);
  });
  function I(L) {
    A.setState((j) => {
      const F = j.connections.get(L.uid);
      return F ? {
        ...j,
        connections: new Map(j.connections).set(L.uid, {
          accounts: L.accounts ?? F.accounts,
          chainId: L.chainId ?? F.chainId,
          connector: F.connector
        })
      } : j;
    });
  }
  function D(L) {
    A.getState().status === "connecting" || A.getState().status === "reconnecting" || A.setState((j) => {
      const F = u.getState().find((O) => O.uid === L.uid);
      return F ? (F.emitter.listenerCount("connect") && F.emitter.off("connect", I), F.emitter.listenerCount("change") || F.emitter.on("change", I), F.emitter.listenerCount("disconnect") || F.emitter.on("disconnect", M), {
        ...j,
        connections: new Map(j.connections).set(L.uid, {
          accounts: L.accounts,
          chainId: L.chainId,
          connector: F
        }),
        current: L.uid,
        status: "connected"
      }) : j;
    });
  }
  function M(L) {
    A.setState((j) => {
      const F = j.connections.get(L.uid);
      if (F) {
        const z = F.connector;
        z.emitter.listenerCount("change") && F.connector.emitter.off("change", I), z.emitter.listenerCount("disconnect") && F.connector.emitter.off("disconnect", M), z.emitter.listenerCount("connect") || F.connector.emitter.on("connect", D);
      }
      if (j.connections.delete(L.uid), j.connections.size === 0)
        return {
          ...j,
          connections: /* @__PURE__ */ new Map(),
          current: null,
          status: "disconnected"
        };
      const O = j.connections.values().next().value;
      return {
        ...j,
        connections: new Map(j.connections),
        current: O.connector.uid
      };
    });
  }
  return {
    get chains() {
      return c.getState();
    },
    get connectors() {
      return u.getState();
    },
    storage: n,
    getClient: v,
    get state() {
      return A.getState();
    },
    setState(L) {
      let j;
      typeof L == "function" ? j = L(A.getState()) : j = L;
      const F = w();
      typeof j != "object" && (j = F), Object.keys(F).some((z) => !(z in j)) && (j = F), A.setState(j, !0);
    },
    subscribe(L, j, F) {
      return A.subscribe(L, j, F ? {
        ...F,
        fireImmediately: F.emitImmediately
        // Workaround cast since Zustand does not support `'exactOptionalPropertyTypes'`
      } : void 0);
    },
    _internal: {
      mipd: s,
      store: A,
      ssr: !!i,
      syncConnectedChain: r,
      transports: o.transports,
      chains: {
        setState(L) {
          const j = typeof L == "function" ? L(c.getState()) : L;
          if (j.length !== 0)
            return c.setState(j, !0);
        },
        subscribe(L) {
          return c.subscribe(L);
        }
      },
      connectors: {
        providerDetailToConnector: p,
        setup: f,
        setState(L) {
          return u.setState(typeof L == "function" ? L(u.getState()) : L, !0);
        },
        subscribe(L) {
          return u.subscribe(L);
        }
      },
      events: { change: I, connect: D, disconnect: M }
    }
  };
}
function wbe(e) {
  var o, s, c;
  const { chain: t } = e, n = t.rpcUrls.default.http[0];
  if (!e.transports)
    return [n];
  const r = (s = (o = e.transports) == null ? void 0 : o[t.id]) == null ? void 0 : s.call(o, { chain: t });
  return (((c = r == null ? void 0 : r.value) == null ? void 0 : c.transports) || [r]).map(({ value: u }) => (u == null ? void 0 : u.url) || n);
}
function Cbe(e) {
  if (typeof e == "string")
    return Number.parseInt(e, e.trim().substring(0, 2) === "0x" ? 16 : 10);
  if (typeof e == "bigint")
    return Number(e);
  if (typeof e == "number")
    return e;
  throw new Error(`Cannot normalize chainId "${e}" of type "${typeof e}"`);
}
const Jq = k.createContext(void 0), xbe = "2.12.25", Ebe = () => `wagmi@${xbe}`;
class Sbe extends lf {
  constructor() {
    super(...arguments), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "WagmiError"
    });
  }
  get docsBaseUrl() {
    return "https://wagmi.sh/react";
  }
  get version() {
    return Ebe();
  }
}
class kbe extends Sbe {
  constructor() {
    super("`useConfig` must be used within `WagmiProvider`.", {
      docsPath: "/api/WagmiProvider"
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "WagmiProviderNotFoundError"
    });
  }
}
function Ho(e = {}) {
  const t = e.config ?? k.useContext(Jq);
  if (!t)
    throw new kbe();
  return t;
}
function Abe(e, t) {
  const { onChange: n } = t;
  return e._internal.chains.subscribe((r, i) => {
    n(r, i);
  });
}
var j5 = { exports: {} }, uO = {}, Ak = { exports: {} }, dO = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var UF;
function Tbe() {
  if (UF) return dO;
  UF = 1;
  var e = k;
  function t(y, v) {
    return y === v && (y !== 0 || 1 / y === 1 / v) || y !== y && v !== v;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, i = e.useEffect, o = e.useLayoutEffect, s = e.useDebugValue;
  function c(y, v) {
    var w = v(), C = r({ inst: { value: w, getSnapshot: v } }), x = C[0].inst, A = C[1];
    return o(function() {
      x.value = w, x.getSnapshot = v, u(x) && A({ inst: x });
    }, [y, w, v]), i(function() {
      return u(x) && A({ inst: x }), y(function() {
        u(x) && A({ inst: x });
      });
    }, [y]), s(w), w;
  }
  function u(y) {
    var v = y.getSnapshot;
    y = y.value;
    try {
      var w = v();
      return !n(y, w);
    } catch {
      return !0;
    }
  }
  function f(y, v) {
    return v();
  }
  var p = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? f : c;
  return dO.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : p, dO;
}
var fO = {}, zF;
function _be() {
  return zF || (zF = 1, ct.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = k, t = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function n(D) {
      {
        for (var M = arguments.length, L = new Array(M > 1 ? M - 1 : 0), j = 1; j < M; j++)
          L[j - 1] = arguments[j];
        r("error", D, L);
      }
    }
    function r(D, M, L) {
      {
        var j = t.ReactDebugCurrentFrame, F = j.getStackAddendum();
        F !== "" && (M += "%s", L = L.concat([F]));
        var O = L.map(function(z) {
          return String(z);
        });
        O.unshift("Warning: " + M), Function.prototype.apply.call(console[D], console, O);
      }
    }
    function i(D, M) {
      return D === M && (D !== 0 || 1 / D === 1 / M) || D !== D && M !== M;
    }
    var o = typeof Object.is == "function" ? Object.is : i, s = e.useState, c = e.useEffect, u = e.useLayoutEffect, f = e.useDebugValue, p = !1, y = !1;
    function v(D, M, L) {
      p || e.startTransition !== void 0 && (p = !0, n("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var j = M();
      if (!y) {
        var F = M();
        o(j, F) || (n("The result of getSnapshot should be cached to avoid an infinite loop"), y = !0);
      }
      var O = s({
        inst: {
          value: j,
          getSnapshot: M
        }
      }), z = O[0].inst, H = O[1];
      return u(function() {
        z.value = j, z.getSnapshot = M, w(z) && H({
          inst: z
        });
      }, [D, j, M]), c(function() {
        w(z) && H({
          inst: z
        });
        var Q = function() {
          w(z) && H({
            inst: z
          });
        };
        return D(Q);
      }, [D]), f(j), j;
    }
    function w(D) {
      var M = D.getSnapshot, L = D.value;
      try {
        var j = M();
        return !o(L, j);
      } catch {
        return !0;
      }
    }
    function C(D, M, L) {
      return M();
    }
    var x = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", A = !x, R = A ? C : v, I = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : R;
    fO.useSyncExternalStore = I, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), fO;
}
var VF;
function Zq() {
  return VF || (VF = 1, ct.env.NODE_ENV === "production" ? Ak.exports = Tbe() : Ak.exports = _be()), Ak.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var $F;
function Rbe() {
  if ($F) return uO;
  $F = 1;
  var e = k, t = Zq();
  function n(f, p) {
    return f === p && (f !== 0 || 1 / f === 1 / p) || f !== f && p !== p;
  }
  var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, o = e.useRef, s = e.useEffect, c = e.useMemo, u = e.useDebugValue;
  return uO.useSyncExternalStoreWithSelector = function(f, p, y, v, w) {
    var C = o(null);
    if (C.current === null) {
      var x = { hasValue: !1, value: null };
      C.current = x;
    } else x = C.current;
    C = c(function() {
      function R(j) {
        if (!I) {
          if (I = !0, D = j, j = v(j), w !== void 0 && x.hasValue) {
            var F = x.value;
            if (w(F, j)) return M = F;
          }
          return M = j;
        }
        if (F = M, r(D, j)) return F;
        var O = v(j);
        return w !== void 0 && w(F, O) ? F : (D = j, M = O);
      }
      var I = !1, D, M, L = y === void 0 ? null : y;
      return [function() {
        return R(p());
      }, L === null ? void 0 : function() {
        return R(L());
      }];
    }, [p, y, v, w]);
    var A = i(f, C[0], C[1]);
    return s(function() {
      x.hasValue = !0, x.value = A;
    }, [A]), u(A), A;
  }, uO;
}
var hO = {}, HF;
function Obe() {
  return HF || (HF = 1, ct.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = k, t = Zq();
    function n(p, y) {
      return p === y && (p !== 0 || 1 / p === 1 / y) || p !== p && y !== y;
    }
    var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, o = e.useRef, s = e.useEffect, c = e.useMemo, u = e.useDebugValue;
    function f(p, y, v, w, C) {
      var x = o(null), A;
      x.current === null ? (A = {
        hasValue: !1,
        value: null
      }, x.current = A) : A = x.current;
      var R = c(function() {
        var L = !1, j, F, O = function(Y) {
          if (!L) {
            L = !0, j = Y;
            var ee = w(Y);
            if (C !== void 0 && A.hasValue) {
              var ie = A.value;
              if (C(ie, ee))
                return F = ie, ie;
            }
            return F = ee, ee;
          }
          var X = j, Z = F;
          if (r(X, Y))
            return Z;
          var J = w(Y);
          return C !== void 0 && C(Z, J) ? Z : (j = Y, F = J, J);
        }, z = v === void 0 ? null : v, H = function() {
          return O(y());
        }, Q = z === null ? void 0 : function() {
          return O(z());
        };
        return [H, Q];
      }, [y, v, w, C]), I = R[0], D = R[1], M = i(p, I, D);
      return s(function() {
        A.hasValue = !0, A.value = M;
      }, [M]), u(M), M;
    }
    hO.useSyncExternalStoreWithSelector = f, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), hO;
}
ct.env.NODE_ENV === "production" ? j5.exports = Rbe() : j5.exports = Obe();
var eW = j5.exports;
const pO = (e) => typeof e == "object" && !Array.isArray(e);
function Ibe(e, t, n = t, r = Qh) {
  const i = k.useRef([]), o = eW.useSyncExternalStoreWithSelector(e, t, n, (s) => s, (s, c) => {
    if (pO(s) && pO(c) && i.current.length) {
      for (const u of i.current)
        if (!r(s[u], c[u]))
          return !1;
      return !0;
    }
    return r(s, c);
  });
  return k.useMemo(() => {
    if (pO(o)) {
      const s = { ...o };
      let c = {};
      for (const [u, f] of Object.entries(s))
        c = {
          ...c,
          [u]: {
            configurable: !1,
            enumerable: !0,
            get: () => (i.current.includes(u) || i.current.push(u), f)
          }
        };
      return Object.defineProperties(s, c), s;
    }
    return o;
  }, [o]);
}
function os(e = {}) {
  const t = Ho(e);
  return Ibe((n) => Kq(t, { onChange: n }), () => YM(t));
}
function tW(e = {}) {
  const { onConnect: t, onDisconnect: n } = e, r = Ho(e);
  k.useEffect(() => Kq(r, {
    onChange(i, o) {
      if ((o.status === "reconnecting" || o.status === "connecting" && o.address === void 0) && i.status === "connected") {
        const { address: s, addresses: c, chain: u, chainId: f, connector: p } = i, y = o.status === "reconnecting" || // if `previousAccount.status` is `undefined`, the connector connected immediately.
        o.status === void 0;
        t == null || t({
          address: s,
          addresses: c,
          chain: u,
          chainId: f,
          connector: p,
          isReconnected: y
        });
      } else o.status === "connected" && i.status === "disconnected" && (n == null || n());
    }
  }), [r, t, n]);
}
function Dbe(e) {
  return JSON.stringify(e, (t, n) => Mbe(n) ? Object.keys(n).sort().reduce((r, i) => (r[i] = n[i], r), {}) : typeof n == "bigint" ? n.toString() : n);
}
function Mbe(e) {
  if (!qF(e))
    return !1;
  const t = e.constructor;
  if (typeof t > "u")
    return !0;
  const n = t.prototype;
  return !(!qF(n) || !n.hasOwnProperty("isPrototypeOf"));
}
function qF(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function nW(e) {
  const {
    // import('@tanstack/query-core').QueryOptions
    _defaulted: t,
    behavior: n,
    gcTime: r,
    initialData: i,
    initialDataUpdatedAt: o,
    maxPages: s,
    meta: c,
    networkMode: u,
    queryFn: f,
    queryHash: p,
    queryKey: y,
    queryKeyHashFn: v,
    retry: w,
    retryDelay: C,
    structuralSharing: x,
    // import('@tanstack/query-core').InfiniteQueryObserverOptions
    getPreviousPageParam: A,
    getNextPageParam: R,
    initialPageParam: I,
    // import('@tanstack/react-query').UseQueryOptions
    _optimisticResults: D,
    enabled: M,
    notifyOnChangeProps: L,
    placeholderData: j,
    refetchInterval: F,
    refetchIntervalInBackground: O,
    refetchOnMount: z,
    refetchOnReconnect: H,
    refetchOnWindowFocus: Q,
    retryOnMount: Y,
    select: ee,
    staleTime: ie,
    suspense: X,
    throwOnError: Z,
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // wagmi
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    config: J,
    connector: K,
    query: oe,
    ...be
  } = e;
  return be;
}
function Pbe(e) {
  return {
    mutationFn(t) {
      return Vq(e, t);
    },
    mutationKey: ["connect"]
  };
}
function Nbe(e) {
  return {
    mutationFn(t) {
      return Hge(e, t);
    },
    mutationKey: ["disconnect"]
  };
}
function Bbe(e, t = {}) {
  return {
    async queryFn({ queryKey: n }) {
      const { name: r, scopeKey: i, ...o } = n[1];
      if (!r)
        throw new Error("name is required");
      return Wge(e, { ...o, name: r });
    },
    queryKey: Lbe(t)
  };
}
function Lbe(e = {}) {
  return ["ensAvatar", nW(e)];
}
function jbe(e, t = {}) {
  return {
    async queryFn({ queryKey: n }) {
      const { address: r, scopeKey: i, ...o } = n[1];
      if (!r)
        throw new Error("address is required");
      return Gge(e, { ...o, address: r });
    },
    queryKey: Fbe(t)
  };
}
function Fbe(e = {}) {
  return ["ensName", nW(e)];
}
function Ube(e) {
  return {
    mutationFn(t) {
      return Yge(e, t);
    },
    mutationKey: ["sendTransaction"]
  };
}
function zbe(e) {
  return {
    mutationFn(t) {
      return Qge(e, t);
    },
    mutationKey: ["signMessage"]
  };
}
function Vbe(e) {
  return {
    mutationFn(t) {
      return Gq(e, t);
    },
    mutationKey: ["switchChain"]
  };
}
function rW(e) {
  const t = Qr({
    ...e,
    queryKeyHashFn: Dbe
    // for bigint support
  });
  return t.queryKey = e.queryKey, t;
}
function iW(e = {}) {
  const t = Ho(e);
  return k.useSyncExternalStore((n) => Jge(t, { onChange: n }), () => PF(t), () => PF(t));
}
function $be(e = {}) {
  const t = Ho(e);
  return k.useSyncExternalStore((n) => Abe(t, { onChange: n }), () => NF(t), () => NF(t));
}
function oW(e = {}) {
  const t = Ho(e);
  return k.useSyncExternalStore((n) => ebe(t, { onChange: n }), () => BF(t), () => BF(t));
}
function aW(e = {}) {
  const { mutation: t } = e, n = Ho(e), r = Pbe(n), { mutate: i, mutateAsync: o, ...s } = ec({
    ...t,
    ...r
  });
  return k.useEffect(() => n.subscribe(({ status: c }) => c, (c, u) => {
    u === "connected" && c === "disconnected" && s.reset();
  }), [n, s.reset]), {
    ...s,
    connect: i,
    connectAsync: o,
    connectors: oW({ config: n })
  };
}
function Hbe(e = {}) {
  const t = Ho(e);
  return k.useSyncExternalStore((n) => Zge(t, { onChange: n }), () => P5(t), () => P5(t));
}
function Y8(e = {}) {
  const { mutation: t } = e, n = Ho(e), r = Nbe(n), { mutate: i, mutateAsync: o, ...s } = ec({
    ...t,
    ...r
  });
  return {
    ...s,
    connectors: Hbe({ config: n }).map((c) => c.connector),
    disconnect: i,
    disconnectAsync: o
  };
}
function qbe(e = {}) {
  const { name: t, query: n = {} } = e, r = Ho(e), i = iW({ config: r }), o = Bbe(r, {
    ...e,
    chainId: e.chainId ?? i
  }), s = !!(t && (n.enabled ?? !0));
  return rW({ ...n, ...o, enabled: s });
}
function Wbe(e = {}) {
  const { address: t, query: n = {} } = e, r = Ho(e), i = iW({ config: r }), o = jbe(r, {
    ...e,
    chainId: e.chainId ?? i
  }), s = !!(t && (n.enabled ?? !0));
  return rW({ ...n, ...o, enabled: s });
}
function Gbe(e = {}) {
  const t = Ho(e);
  return eW.useSyncExternalStoreWithSelector((n) => tbe(t, { onChange: n }), () => N5(t, e), () => N5(t, e), (n) => n, (n, r) => (n == null ? void 0 : n.uid) === (r == null ? void 0 : r.uid));
}
function Kbe(e = {}) {
  const { mutation: t } = e, n = Ho(e), r = Ube(n), { mutate: i, mutateAsync: o, ...s } = ec({
    ...t,
    ...r
  });
  return {
    ...s,
    sendTransaction: i,
    sendTransactionAsync: o
  };
}
function sW(e = {}) {
  const { mutation: t } = e, n = Ho(e), r = zbe(n), { mutate: i, mutateAsync: o, ...s } = ec({
    ...t,
    ...r
  });
  return {
    ...s,
    signMessage: i,
    signMessageAsync: o
  };
}
function Ybe(e = {}) {
  const { mutation: t } = e, n = Ho(e), r = Vbe(n), { mutate: i, mutateAsync: o, ...s } = ec({
    ...t,
    ...r
  });
  return {
    ...s,
    chains: $be({ config: n }),
    switchChain: i,
    switchChainAsync: o
  };
}
function lW(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var i = e.length;
    for (t = 0; t < i; t++) e[t] && (n = lW(e[t])) && (r && (r += " "), r += n);
  } else for (n in e) e[n] && (r && (r += " "), r += n);
  return r;
}
function cW() {
  for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++) (e = arguments[n]) && (t = lW(e)) && (r && (r += " "), r += t);
  return r;
}
var Qbe = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
const WF = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]), GF = 4;
function Xbe(e) {
  let t = 0;
  function n() {
    return e[t++] << 8 | e[t++];
  }
  let r = n(), i = 1, o = [0, 1];
  for (let L = 1; L < r; L++)
    o.push(i += n());
  let s = n(), c = t;
  t += s;
  let u = 0, f = 0;
  function p() {
    return u == 0 && (f = f << 8 | e[t++], u = 8), f >> --u & 1;
  }
  const y = 31, v = 2 ** y, w = v >>> 1, C = w >> 1, x = v - 1;
  let A = 0;
  for (let L = 0; L < y; L++) A = A << 1 | p();
  let R = [], I = 0, D = v;
  for (; ; ) {
    let L = Math.floor(((A - I + 1) * i - 1) / D), j = 0, F = r;
    for (; F - j > 1; ) {
      let H = j + F >>> 1;
      L < o[H] ? F = H : j = H;
    }
    if (j == 0) break;
    R.push(j);
    let O = I + Math.floor(D * o[j] / i), z = I + Math.floor(D * o[j + 1] / i) - 1;
    for (; !((O ^ z) & w); )
      A = A << 1 & x | p(), O = O << 1 & x, z = z << 1 & x | 1;
    for (; O & ~z & C; )
      A = A & w | A << 1 & x >>> 1 | p(), O = O << 1 ^ w, z = (z ^ w) << 1 | w | 1;
    I = O, D = 1 + z - O;
  }
  let M = r - 4;
  return R.map((L) => {
    switch (L - M) {
      case 3:
        return M + 65792 + (e[c++] << 16 | e[c++] << 8 | e[c++]);
      case 2:
        return M + 256 + (e[c++] << 8 | e[c++]);
      case 1:
        return M + e[c++];
      default:
        return L - 1;
    }
  });
}
function Jbe(e) {
  let t = 0;
  return () => e[t++];
}
function uW(e) {
  return Jbe(Xbe(Zbe(e)));
}
function Zbe(e) {
  let t = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((i, o) => t[i.charCodeAt(0)] = o);
  let n = e.length, r = new Uint8Array(6 * n >> 3);
  for (let i = 0, o = 0, s = 0, c = 0; i < n; i++)
    c = c << 6 | t[e.charCodeAt(i)], s += 6, s >= 8 && (r[o++] = c >> (s -= 8));
  return r;
}
function e0e(e) {
  return e & 1 ? ~e >> 1 : e >> 1;
}
function t0e(e, t) {
  let n = Array(e);
  for (let r = 0, i = 0; r < e; r++) n[r] = i += e0e(t());
  return n;
}
function sC(e, t = 0) {
  let n = [];
  for (; ; ) {
    let r = e(), i = e();
    if (!i) break;
    t += r;
    for (let o = 0; o < i; o++)
      n.push(t + o);
    t += i + 1;
  }
  return n;
}
function dW(e) {
  return lC(() => {
    let t = sC(e);
    if (t.length) return t;
  });
}
function fW(e) {
  let t = [];
  for (; ; ) {
    let n = e();
    if (n == 0) break;
    t.push(n0e(n, e));
  }
  for (; ; ) {
    let n = e() - 1;
    if (n < 0) break;
    t.push(r0e(n, e));
  }
  return t.flat();
}
function lC(e) {
  let t = [];
  for (; ; ) {
    let n = e(t.length);
    if (!n) break;
    t.push(n);
  }
  return t;
}
function hW(e, t, n) {
  let r = Array(e).fill().map(() => []);
  for (let i = 0; i < t; i++)
    t0e(e, n).forEach((o, s) => r[s].push(o));
  return r;
}
function n0e(e, t) {
  let n = 1 + t(), r = t(), i = lC(t);
  return hW(i.length, 1 + e, t).flatMap((s, c) => {
    let [u, ...f] = s;
    return Array(i[c]).fill().map((p, y) => {
      let v = y * r;
      return [u + y * n, f.map((w) => w + v)];
    });
  });
}
function r0e(e, t) {
  let n = 1 + t();
  return hW(n, 1 + e, t).map((i) => [i[0], i.slice(1)]);
}
function i0e(e) {
  let t = [], n = sC(e);
  return i(r([]), []), t;
  function r(o) {
    let s = e(), c = lC(() => {
      let u = sC(e).map((f) => n[f]);
      if (u.length) return r(u);
    });
    return { S: s, B: c, Q: o };
  }
  function i({ S: o, B: s }, c, u) {
    if (!(o & 4 && u === c[c.length - 1])) {
      o & 2 && (u = c[c.length - 1]), o & 1 && t.push(c);
      for (let f of s)
        for (let p of f.Q)
          i(f, [...c, p], u);
    }
  }
}
function o0e(e) {
  return e.toString(16).toUpperCase().padStart(2, "0");
}
function pW(e) {
  return `{${o0e(e)}}`;
}
function a0e(e) {
  let t = [];
  for (let n = 0, r = e.length; n < r; ) {
    let i = e.codePointAt(n);
    n += i < 65536 ? 1 : 2, t.push(i);
  }
  return t;
}
function ab(e) {
  let n = e.length;
  if (n < 4096) return String.fromCodePoint(...e);
  let r = [];
  for (let i = 0; i < n; )
    r.push(String.fromCodePoint(...e.slice(i, i += 4096)));
  return r.join("");
}
function s0e(e, t) {
  let n = e.length, r = n - t.length;
  for (let i = 0; r == 0 && i < n; i++) r = e[i] - t[i];
  return r;
}
var l0e = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
const cC = 44032, L4 = 4352, j4 = 4449, F4 = 4519, mW = 19, yW = 21, sb = 28, U4 = yW * sb, c0e = mW * U4, u0e = cC + c0e, d0e = L4 + mW, f0e = j4 + yW, h0e = F4 + sb;
function x1(e) {
  return e >> 24 & 255;
}
function vW(e) {
  return e & 16777215;
}
let F5, KF, U5, u4;
function p0e() {
  let e = uW(l0e);
  F5 = new Map(dW(e).flatMap((t, n) => t.map((r) => [r, n + 1 << 24]))), KF = new Set(sC(e)), U5 = /* @__PURE__ */ new Map(), u4 = /* @__PURE__ */ new Map();
  for (let [t, n] of fW(e)) {
    if (!KF.has(t) && n.length == 2) {
      let [r, i] = n, o = u4.get(r);
      o || (o = /* @__PURE__ */ new Map(), u4.set(r, o)), o.set(i, t);
    }
    U5.set(t, n.reverse());
  }
}
function gW(e) {
  return e >= cC && e < u0e;
}
function m0e(e, t) {
  if (e >= L4 && e < d0e && t >= j4 && t < f0e)
    return cC + (e - L4) * U4 + (t - j4) * sb;
  if (gW(e) && t > F4 && t < h0e && (e - cC) % sb == 0)
    return e + (t - F4);
  {
    let n = u4.get(e);
    return n && (n = n.get(t), n) ? n : -1;
  }
}
function bW(e) {
  F5 || p0e();
  let t = [], n = [], r = !1;
  function i(o) {
    let s = F5.get(o);
    s && (r = !0, o |= s), t.push(o);
  }
  for (let o of e)
    for (; ; ) {
      if (o < 128)
        t.push(o);
      else if (gW(o)) {
        let s = o - cC, c = s / U4 | 0, u = s % U4 / sb | 0, f = s % sb;
        i(L4 + c), i(j4 + u), f > 0 && i(F4 + f);
      } else {
        let s = U5.get(o);
        s ? n.push(...s) : i(o);
      }
      if (!n.length) break;
      o = n.pop();
    }
  if (r && t.length > 1) {
    let o = x1(t[0]);
    for (let s = 1; s < t.length; s++) {
      let c = x1(t[s]);
      if (c == 0 || o <= c) {
        o = c;
        continue;
      }
      let u = s - 1;
      for (; ; ) {
        let f = t[u + 1];
        if (t[u + 1] = t[u], t[u] = f, !u || (o = x1(t[--u]), o <= c)) break;
      }
      o = x1(t[s]);
    }
  }
  return t;
}
function y0e(e) {
  let t = [], n = [], r = -1, i = 0;
  for (let o of e) {
    let s = x1(o), c = vW(o);
    if (r == -1)
      s == 0 ? r = c : t.push(c);
    else if (i > 0 && i >= s)
      s == 0 ? (t.push(r, ...n), n.length = 0, r = c) : n.push(c), i = s;
    else {
      let u = m0e(r, c);
      u >= 0 ? r = u : i == 0 && s == 0 ? (t.push(r), r = c) : (n.push(c), i = s);
    }
  }
  return r >= 0 && t.push(r, ...n), t;
}
function wW(e) {
  return bW(e).map(vW);
}
function v0e(e) {
  return y0e(bW(e));
}
const YF = 45, CW = ".", xW = 65039, EW = 1, wg = (e) => Array.from(e);
function uC(e, t) {
  return e.P.has(t) || e.Q.has(t);
}
class g0e extends Array {
  get is_emoji() {
    return !0;
  }
  // free tagging system
}
let z5, SW, Rm, V5, kW, Mg, mO, pg, AW, QF, $5;
function QM() {
  if (z5) return;
  let e = uW(Qbe);
  const t = () => sC(e), n = () => new Set(t());
  z5 = new Map(fW(e)), SW = n(), Rm = t(), V5 = new Set(t().map((p) => Rm[p])), Rm = new Set(Rm), kW = n(), n();
  let r = dW(e), i = e();
  const o = () => new Set(t().flatMap((p) => r[p]).concat(t()));
  Mg = lC((p) => {
    let y = lC(e).map((v) => v + 96);
    if (y.length) {
      let v = p >= i;
      y[0] -= 32, y = ab(y), v && (y = `Restricted[${y}]`);
      let w = o(), C = o(), x = !e();
      return { N: y, P: w, Q: C, M: x, R: v };
    }
  }), mO = n(), pg = /* @__PURE__ */ new Map();
  let s = t().concat(wg(mO)).sort((p, y) => p - y);
  s.forEach((p, y) => {
    let v = e(), w = s[y] = v ? s[y - v] : { V: [], M: /* @__PURE__ */ new Map() };
    w.V.push(p), mO.has(p) || pg.set(p, w);
  });
  for (let { V: p, M: y } of new Set(pg.values())) {
    let v = [];
    for (let C of p) {
      let x = Mg.filter((R) => uC(R, C)), A = v.find(({ G: R }) => x.some((I) => R.has(I)));
      A || (A = { G: /* @__PURE__ */ new Set(), V: [] }, v.push(A)), A.V.push(C), x.forEach((R) => A.G.add(R));
    }
    let w = v.flatMap((C) => wg(C.G));
    for (let { G: C, V: x } of v) {
      let A = new Set(w.filter((R) => !C.has(R)));
      for (let R of x)
        y.set(R, A);
    }
  }
  let c = /* @__PURE__ */ new Set(), u = /* @__PURE__ */ new Set();
  const f = (p) => c.has(p) ? u.add(p) : c.add(p);
  for (let p of Mg) {
    for (let y of p.P) f(y);
    for (let y of p.Q) f(y);
  }
  for (let p of c)
    !pg.has(p) && !u.has(p) && pg.set(p, EW);
  AW = new Set(wg(c).concat(wg(wW(c)))), QF = i0e(e).map((p) => g0e.from(p)).sort(s0e), $5 = /* @__PURE__ */ new Map();
  for (let p of QF) {
    let y = [$5];
    for (let v of p) {
      let w = y.map((C) => {
        let x = C.get(v);
        return x || (x = /* @__PURE__ */ new Map(), C.set(v, x)), x;
      });
      v === xW ? y.push(...w) : y = w;
    }
    for (let v of y)
      v.V = p;
  }
}
function XM(e) {
  return (TW(e) ? "" : `${JM(Q8([e]))} `) + pW(e);
}
function JM(e) {
  return `"${e}"`;
}
function b0e(e) {
  if (e.length >= 4 && e[2] == YF && e[3] == YF)
    throw new Error(`invalid label extension: "${ab(e.slice(0, 4))}"`);
}
function w0e(e) {
  for (let n = e.lastIndexOf(95); n > 0; )
    if (e[--n] !== 95)
      throw new Error("underscore allowed only at start");
}
function C0e(e) {
  let t = e[0], n = WF.get(t);
  if (n) throw P1(`leading ${n}`);
  let r = e.length, i = -1;
  for (let o = 1; o < r; o++) {
    t = e[o];
    let s = WF.get(t);
    if (s) {
      if (i == o) throw P1(`${n} + ${s}`);
      i = o + 1, n = s;
    }
  }
  if (i == r) throw P1(`trailing ${n}`);
}
function Q8(e, t = pW) {
  let n = [];
  x0e(e[0]) && n.push("");
  let r = 0, i = e.length;
  for (let o = 0; o < i; o++) {
    let s = e[o];
    TW(s) && (n.push(ab(e.slice(r, o))), n.push(t(s)), r = o + 1);
  }
  return n.push(ab(e.slice(r, i))), n.join("");
}
function x0e(e) {
  return QM(), Rm.has(e);
}
function TW(e) {
  return QM(), kW.has(e);
}
function E0e(e) {
  return T0e(S0e(e, v0e, O0e));
}
function S0e(e, t, n) {
  if (!e) return [];
  QM();
  let r = 0;
  return e.split(CW).map((i) => {
    let o = a0e(i), s = {
      input: o,
      offset: r
      // codepoint, not substring!
    };
    r += o.length + 1;
    try {
      let c = s.tokens = R0e(o, t, n), u = c.length, f;
      if (!u)
        throw new Error("empty label");
      let p = s.output = c.flat();
      if (w0e(p), !(s.emoji = u > 1 || c[0].is_emoji) && p.every((v) => v < 128))
        b0e(p), f = "ASCII";
      else {
        let v = c.flatMap((w) => w.is_emoji ? [] : w);
        if (!v.length)
          f = "Emoji";
        else {
          if (Rm.has(p[0])) throw P1("leading combining mark");
          for (let x = 1; x < u; x++) {
            let A = c[x];
            if (!A.is_emoji && Rm.has(A[0]))
              throw P1(`emoji + combining mark: "${ab(c[x - 1])} + ${Q8([A[0]])}"`);
          }
          C0e(p);
          let w = wg(new Set(v)), [C] = A0e(w);
          _0e(C, v), k0e(C, w), f = C.N;
        }
      }
      s.type = f;
    } catch (c) {
      s.error = c;
    }
    return s;
  });
}
function k0e(e, t) {
  let n, r = [];
  for (let i of t) {
    let o = pg.get(i);
    if (o === EW) return;
    if (o) {
      let s = o.M.get(i);
      if (n = n ? n.filter((c) => s.has(c)) : wg(s), !n.length) return;
    } else
      r.push(i);
  }
  if (n) {
    for (let i of n)
      if (r.every((o) => uC(i, o)))
        throw new Error(`whole-script confusable: ${e.N}/${i.N}`);
  }
}
function A0e(e) {
  let t = Mg;
  for (let n of e) {
    let r = t.filter((i) => uC(i, n));
    if (!r.length)
      throw Mg.some((i) => uC(i, n)) ? RW(t[0], n) : _W(n);
    if (t = r, r.length == 1) break;
  }
  return t;
}
function T0e(e) {
  return e.map(({ input: t, error: n, output: r }) => {
    if (n) {
      let i = n.message;
      throw new Error(e.length == 1 ? i : `Invalid label ${JM(Q8(t))}: ${i}`);
    }
    return ab(r);
  }).join(CW);
}
function _W(e) {
  return new Error(`disallowed character: ${XM(e)}`);
}
function RW(e, t) {
  let n = XM(t), r = Mg.find((i) => i.P.has(t));
  return r && (n = `${r.N} ${n}`), new Error(`illegal mixture: ${e.N} + ${n}`);
}
function P1(e) {
  return new Error(`illegal placement: ${e}`);
}
function _0e(e, t) {
  for (let n of t)
    if (!uC(e, n))
      throw RW(e, n);
  if (e.M) {
    let n = wW(t);
    for (let r = 1, i = n.length; r < i; r++)
      if (V5.has(n[r])) {
        let o = r + 1;
        for (let s; o < i && V5.has(s = n[o]); o++)
          for (let c = r; c < o; c++)
            if (n[c] == s)
              throw new Error(`duplicate non-spacing marks: ${XM(s)}`);
        if (o - r > GF)
          throw new Error(`excessive non-spacing marks: ${JM(Q8(n.slice(r - 1, o)))} (${o - r}/${GF})`);
        r = o;
      }
  }
}
function R0e(e, t, n) {
  let r = [], i = [];
  for (e = e.slice().reverse(); e.length; ) {
    let o = I0e(e);
    if (o)
      i.length && (r.push(t(i)), i = []), r.push(n(o));
    else {
      let s = e.pop();
      if (AW.has(s))
        i.push(s);
      else {
        let c = z5.get(s);
        if (c)
          i.push(...c);
        else if (!SW.has(s))
          throw _W(s);
      }
    }
  }
  return i.length && r.push(t(i)), r;
}
function O0e(e) {
  return e.filter((t) => t != xW);
}
function I0e(e, t) {
  let n = $5, r, i = e.length;
  for (; i && (n = n.get(e[--i]), !!n); ) {
    let { V: o } = n;
    o && (r = o, e.length = i);
  }
  return r;
}
function D0e(e) {
  return E0e(e);
}
const M0e = {
  gasPriceOracle: { address: "0x420000000000000000000000000000000000000F" },
  l1Block: { address: "0x4200000000000000000000000000000000000015" },
  l2CrossDomainMessenger: {
    address: "0x4200000000000000000000000000000000000007"
  },
  l2Erc721Bridge: { address: "0x4200000000000000000000000000000000000014" },
  l2StandardBridge: { address: "0x4200000000000000000000000000000000000010" },
  l2ToL1MessagePasser: {
    address: "0x4200000000000000000000000000000000000016"
  }
}, P0e = {
  block: /* @__PURE__ */ _H({
    format(e) {
      var n;
      return {
        transactions: (n = e.transactions) == null ? void 0 : n.map((r) => {
          if (typeof r == "string")
            return r;
          const i = $C(r);
          return i.typeHex === "0x7e" && (i.isSystemTx = r.isSystemTx, i.mint = r.mint ? Da(r.mint) : void 0, i.sourceHash = r.sourceHash, i.type = "deposit"), i;
        }),
        stateRoot: e.stateRoot
      };
    }
  }),
  transaction: /* @__PURE__ */ TH({
    format(e) {
      const t = {};
      return e.type === "0x7e" && (t.isSystemTx = e.isSystemTx, t.mint = e.mint ? Da(e.mint) : void 0, t.sourceHash = e.sourceHash, t.type = "deposit"), t;
    }
  }),
  transactionReceipt: /* @__PURE__ */ sve({
    format(e) {
      return {
        l1GasPrice: e.l1GasPrice ? Da(e.l1GasPrice) : null,
        l1GasUsed: e.l1GasUsed ? Da(e.l1GasUsed) : null,
        l1Fee: e.l1Fee ? Da(e.l1Fee) : null,
        l1FeeScalar: e.l1FeeScalar ? Number(e.l1FeeScalar) : null
      };
    }
  })
};
function OW(e, t) {
  return L0e(e) ? B0e(e) : Nve(e, t);
}
const N0e = {
  transaction: OW
};
function B0e(e) {
  j0e(e);
  const { sourceHash: t, data: n, from: r, gas: i, isSystemTx: o, mint: s, to: c, value: u } = e, f = [
    t,
    r,
    c ?? "0x",
    s ? yn(s) : "0x",
    u ? yn(u) : "0x",
    i ? yn(i) : "0x",
    o ? "0x1" : "0x",
    n ?? "0x"
  ];
  return Wc([
    "0x7e",
    Zd(f)
  ]);
}
function L0e(e) {
  return e.type === "deposit" || typeof e.sourceHash < "u";
}
function j0e(e) {
  const { from: t, to: n } = e;
  if (t && !co(t))
    throw new Ba({ address: t });
  if (n && !co(n))
    throw new Ba({ address: n });
}
const z4 = {
  contracts: M0e,
  formatters: P0e,
  serializers: N0e
}, F0e = /* @__PURE__ */ hl({
  id: 42161,
  name: "Arbitrum One",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://arb1.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://arbiscan.io",
      apiUrl: "https://api.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7654707
    }
  }
}), U0e = /* @__PURE__ */ hl({
  id: 43114,
  name: "Avalanche",
  nativeCurrency: {
    decimals: 18,
    name: "Avalanche",
    symbol: "AVAX"
  },
  rpcUrls: {
    default: { http: ["https://api.avax.network/ext/bc/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "SnowTrace",
      url: "https://snowtrace.io",
      apiUrl: "https://api.snowtrace.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11907934
    }
  }
}), Tk = 1, z0e = /* @__PURE__ */ hl({
  ...z4,
  id: 8453,
  name: "Base",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.base.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://basescan.org",
      apiUrl: "https://api.basescan.org/api"
    }
  },
  contracts: {
    ...z4.contracts,
    l2OutputOracle: {
      [Tk]: {
        address: "0x56315b90c40730925ec5485cf004d835058518A0"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 5022
    },
    portal: {
      [Tk]: {
        address: "0x49048044D57e1C92A77f79988d21Fa8fAF74E97e",
        blockCreated: 17482143
      }
    },
    l1StandardBridge: {
      [Tk]: {
        address: "0x3154Cf16ccdb4C6d922629664174b904d80F2C35",
        blockCreated: 17482143
      }
    }
  },
  sourceId: Tk
}), V0e = /* @__PURE__ */ hl({
  id: 56,
  name: "BNB Smart Chain",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "BNB"
  },
  rpcUrls: {
    default: { http: ["https://rpc.ankr.com/bsc"] }
  },
  blockExplorers: {
    default: {
      name: "BscScan",
      url: "https://bscscan.com",
      apiUrl: "https://api.bscscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15921452
    }
  }
}), $0e = {
  /*
     * Estimates the fees per gas for a transaction.
  
     * If the transaction is to be paid in a token (feeCurrency is present) then the fees
     * are estimated in the value of the token. Otherwise falls back to the default
     * estimation by returning null.
     *
     * @param params fee estimation function parameters
     */
  estimateFeesPerGas: async (e) => {
    var r;
    if (!((r = e.request) != null && r.feeCurrency))
      return null;
    const [t, n] = await Promise.all([
      H0e(e.client, e.request.feeCurrency),
      q0e(e.client, e.request.feeCurrency)
    ]);
    return {
      maxFeePerGas: t,
      maxPriorityFeePerGas: n
    };
  }
};
async function H0e(e, t) {
  const n = await e.request({
    method: "eth_gasPrice",
    params: [t]
  });
  return BigInt(n);
}
async function q0e(e, t) {
  const n = await e.request({
    method: "eth_maxPriorityFeePerGas",
    params: [t]
  });
  return BigInt(n);
}
function IW(e) {
  return e === 0 || e === 0n || e === void 0 || e === null || e === "0" || e === "" || typeof e == "string" && (Fu(e).toLowerCase() === "0x" || Fu(e).toLowerCase() === "0x00");
}
function E1(e) {
  return !IW(e);
}
function W0e(e) {
  return typeof e.maxFeePerGas < "u" && typeof e.maxPriorityFeePerGas < "u";
}
function DW(e) {
  return e.type === "cip64" ? !0 : W0e(e) && E1(e.feeCurrency);
}
const G0e = {
  block: /* @__PURE__ */ _H({
    format(e) {
      var n;
      return {
        transactions: (n = e.transactions) == null ? void 0 : n.map((r) => typeof r == "string" ? r : {
          ...$C(r),
          ...r.gatewayFee ? {
            gatewayFee: Da(r.gatewayFee),
            gatewayFeeRecipient: r.gatewayFeeRecipient
          } : {},
          feeCurrency: r.feeCurrency
        }),
        ...e.randomness ? { randomness: e.randomness } : {}
      };
    }
  }),
  transaction: /* @__PURE__ */ TH({
    format(e) {
      if (e.type === "0x7e")
        return {
          isSystemTx: e.isSystemTx,
          mint: e.mint ? Da(e.mint) : void 0,
          sourceHash: e.sourceHash,
          type: "deposit"
        };
      const t = { feeCurrency: e.feeCurrency };
      return e.type === "0x7b" ? t.type = "cip64" : (e.type === "0x7c" && (t.type = "cip42"), t.gatewayFee = e.gatewayFee ? Da(e.gatewayFee) : null, t.gatewayFeeRecipient = e.gatewayFeeRecipient), t;
    }
  }),
  transactionRequest: /* @__PURE__ */ Bpe({
    format(e) {
      const t = {};
      return e.feeCurrency && (t.feeCurrency = e.feeCurrency), DW(e) && (t.type = "0x7b"), t;
    }
  })
};
function K0e(e, t) {
  return DW(e) ? Q0e(e, t) : OW(e, t);
}
const Y0e = {
  transaction: K0e
};
function Q0e(e, t) {
  J0e(e);
  const { chainId: n, gas: r, nonce: i, to: o, value: s, maxFeePerGas: c, maxPriorityFeePerGas: u, accessList: f, feeCurrency: p, data: y } = e, v = [
    yn(n),
    i ? yn(i) : "0x",
    u ? yn(u) : "0x",
    c ? yn(c) : "0x",
    r ? yn(r) : "0x",
    o ?? "0x",
    s ? yn(s) : "0x",
    y ?? "0x",
    KC(f),
    p,
    ...Fb(e, t)
  ];
  return Wc([
    "0x7b",
    Zd(v)
  ]);
}
const X0e = zC;
function J0e(e) {
  const { chainId: t, maxPriorityFeePerGas: n, gasPrice: r, maxFeePerGas: i, to: o, feeCurrency: s } = e;
  if (t <= 0)
    throw new jC({ chainId: t });
  if (o && !co(o))
    throw new Ba({ address: o });
  if (r)
    throw new it("`gasPrice` is not a valid CIP-64 Transaction attribute.");
  if (E1(i) && i > X0e)
    throw new Wh({ maxFeePerGas: i });
  if (E1(n) && E1(i) && n > i)
    throw new tb({ maxFeePerGas: i, maxPriorityFeePerGas: n });
  if (E1(s) && !co(s))
    throw new it("`feeCurrency` MUST be a token address for CIP-64 transactions.");
  if (IW(s))
    throw new it("`feeCurrency` must be provided for CIP-64 transactions.");
}
const Z0e = {
  formatters: G0e,
  serializers: Y0e,
  fees: $0e
}, ewe = /* @__PURE__ */ hl({
  ...Z0e,
  id: 42220,
  name: "Celo",
  nativeCurrency: {
    decimals: 18,
    name: "CELO",
    symbol: "CELO"
  },
  rpcUrls: {
    default: { http: ["https://forno.celo.org"] }
  },
  blockExplorers: {
    default: {
      name: "Celo Explorer",
      url: "https://celoscan.io",
      apiUrl: "https://api.celoscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 13112599
    }
  },
  testnet: !1
}), twe = /* @__PURE__ */ hl({
  id: 1116,
  name: "Core Dao",
  nativeCurrency: {
    decimals: 18,
    name: "Core",
    symbol: "CORE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.coredao.org"] }
  },
  blockExplorers: {
    default: {
      name: "CoreDao",
      url: "https://scan.coredao.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 11907934
    }
  },
  testnet: !1
}), nwe = /* @__PURE__ */ hl({
  id: 5,
  name: "Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.ankr.com/eth_goerli"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli.etherscan.io",
      apiUrl: "https://api-goerli.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xfc4AC75C46C914aF5892d6d3eFFcebD7917293F1",
      blockCreated: 10339206
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6507670
    }
  },
  testnet: !0
}), rwe = /* @__PURE__ */ hl({
  id: 16666e5,
  name: "Harmony One",
  nativeCurrency: {
    name: "Harmony",
    symbol: "ONE",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.ankr.com/harmony"] }
  },
  blockExplorers: {
    default: {
      name: "Harmony Explorer",
      url: "https://explorer.harmony.one"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 24185753
    }
  }
}), iwe = /* @__PURE__ */ hl({
  id: 17e3,
  name: "Holesky",
  nativeCurrency: { name: "Holesky Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://ethereum-holesky-rpc.publicnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://holesky.etherscan.io",
      apiUrl: "https://api-holesky.etherscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 77
    },
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      blockCreated: 801613
    },
    ensUniversalResolver: {
      address: "0xa6AC935D4971E3CD133b950aE053bECD16fE7f3b",
      blockCreated: 973484
    }
  },
  testnet: !0
});
async function owe(e, t) {
  var i, o, s;
  const { account: n = e.account } = t;
  if (!n)
    throw new wM();
  const r = nc(n);
  try {
    const { accessList: c, blockNumber: u, blockTag: f, data: p, gas: y, gasPrice: v, maxFeePerGas: w, maxPriorityFeePerGas: C, nonce: x, to: A, value: R, ...I } = (r == null ? void 0 : r.type) === "local" ? await j8(e, t) : t, M = (u ? en(u) : void 0) || f;
    VC(t);
    const L = (s = (o = (i = e.chain) == null ? void 0 : i.formatters) == null ? void 0 : o.transactionRequest) == null ? void 0 : s.format, F = (L || UC)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...N8(I, { format: L }),
      from: r == null ? void 0 : r.address,
      accessList: c,
      data: p,
      gas: y,
      gasPrice: v,
      maxFeePerGas: w,
      maxPriorityFeePerGas: C,
      nonce: x,
      to: A,
      value: R
    }), { baseFeePerGas: O, gasLimit: z, priorityFeePerGas: H } = await e.request({
      method: "linea_estimateGas",
      params: M ? [F, M] : [F]
    });
    return {
      baseFeePerGas: BigInt(O),
      gasLimit: BigInt(z),
      priorityFeePerGas: BigInt(H)
    };
  } catch (c) {
    throw cq(c, {
      ...t,
      account: r,
      chain: e.chain
    });
  }
}
const awe = {
  fees: {
    estimateFeesPerGas: XF,
    async maxPriorityFeePerGas({ block: e, client: t, request: n }) {
      const r = await XF({
        block: e,
        client: t,
        multiply: (i) => i,
        request: n,
        type: "eip1559"
      });
      return r != null && r.maxPriorityFeePerGas ? r.maxPriorityFeePerGas : null;
    }
  }
};
async function XF({ client: e, multiply: t, request: n, type: r }) {
  try {
    const i = await owe(e, {
      ...n,
      account: n == null ? void 0 : n.account
    }), { priorityFeePerGas: o } = i, c = t(BigInt(i.baseFeePerGas)) + o;
    return r === "legacy" ? { gasPrice: c } : {
      maxFeePerGas: c,
      maxPriorityFeePerGas: o
    };
  } catch {
    return null;
  }
}
const swe = /* @__PURE__ */ hl({
  ...awe,
  id: 59144,
  name: "Linea Mainnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.linea.build"],
      webSocket: ["wss://rpc.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://lineascan.build",
      apiUrl: "https://api.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 42
    }
  },
  testnet: !1
}), Ub = /* @__PURE__ */ hl({
  id: 1,
  name: "Ethereum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://cloudflare-eth.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://etherscan.io",
      apiUrl: "https://api.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xce01f8eee7E479C928F8919abD53E553a36CeF67",
      blockCreated: 19258213
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
}), c1 = 1, lwe = /* @__PURE__ */ hl({
  ...z4,
  id: 10,
  name: "OP Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Optimism Explorer",
      url: "https://optimistic.etherscan.io",
      apiUrl: "https://api-optimistic.etherscan.io/api"
    }
  },
  contracts: {
    ...z4.contracts,
    disputeGameFactory: {
      [c1]: {
        address: "0xe5965Ab5962eDc7477C8520243A95517CD252fA9"
      }
    },
    l2OutputOracle: {
      [c1]: {
        address: "0xdfe97868233d1aa22e815a266982f2cf17685a27"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4286263
    },
    portal: {
      [c1]: {
        address: "0xbEb5Fc579115071764c7423A4f12eDde41f106Ed"
      }
    },
    l1StandardBridge: {
      [c1]: {
        address: "0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1"
      }
    }
  },
  sourceId: c1
}), cwe = /* @__PURE__ */ hl({
  id: 137,
  name: "Polygon",
  nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://polygon-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://polygonscan.com",
      apiUrl: "https://api.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  }
});
var H5 = { exports: {} }, Ps = {}, _k = { exports: {} }, yO = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var JF;
function uwe() {
  return JF || (JF = 1, function(e) {
    function t(K, oe) {
      var be = K.length;
      K.push(oe);
      e: for (; 0 < be; ) {
        var ce = be - 1 >>> 1, pe = K[ce];
        if (0 < i(pe, oe)) K[ce] = oe, K[be] = pe, be = ce;
        else break e;
      }
    }
    function n(K) {
      return K.length === 0 ? null : K[0];
    }
    function r(K) {
      if (K.length === 0) return null;
      var oe = K[0], be = K.pop();
      if (be !== oe) {
        K[0] = be;
        e: for (var ce = 0, pe = K.length, Ee = pe >>> 1; ce < Ee; ) {
          var Se = 2 * (ce + 1) - 1, Me = K[Se], Fe = Se + 1, st = K[Fe];
          if (0 > i(Me, be)) Fe < pe && 0 > i(st, Me) ? (K[ce] = st, K[Fe] = be, ce = Fe) : (K[ce] = Me, K[Se] = be, ce = Se);
          else if (Fe < pe && 0 > i(st, be)) K[ce] = st, K[Fe] = be, ce = Fe;
          else break e;
        }
      }
      return oe;
    }
    function i(K, oe) {
      var be = K.sortIndex - oe.sortIndex;
      return be !== 0 ? be : K.id - oe.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var o = performance;
      e.unstable_now = function() {
        return o.now();
      };
    } else {
      var s = Date, c = s.now();
      e.unstable_now = function() {
        return s.now() - c;
      };
    }
    var u = [], f = [], p = 1, y = null, v = 3, w = !1, C = !1, x = !1, A = typeof setTimeout == "function" ? setTimeout : null, R = typeof clearTimeout == "function" ? clearTimeout : null, I = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function D(K) {
      for (var oe = n(f); oe !== null; ) {
        if (oe.callback === null) r(f);
        else if (oe.startTime <= K) r(f), oe.sortIndex = oe.expirationTime, t(u, oe);
        else break;
        oe = n(f);
      }
    }
    function M(K) {
      if (x = !1, D(K), !C) if (n(u) !== null) C = !0, Z(L);
      else {
        var oe = n(f);
        oe !== null && J(M, oe.startTime - K);
      }
    }
    function L(K, oe) {
      C = !1, x && (x = !1, R(O), O = -1), w = !0;
      var be = v;
      try {
        for (D(oe), y = n(u); y !== null && (!(y.expirationTime > oe) || K && !Q()); ) {
          var ce = y.callback;
          if (typeof ce == "function") {
            y.callback = null, v = y.priorityLevel;
            var pe = ce(y.expirationTime <= oe);
            oe = e.unstable_now(), typeof pe == "function" ? y.callback = pe : y === n(u) && r(u), D(oe);
          } else r(u);
          y = n(u);
        }
        if (y !== null) var Ee = !0;
        else {
          var Se = n(f);
          Se !== null && J(M, Se.startTime - oe), Ee = !1;
        }
        return Ee;
      } finally {
        y = null, v = be, w = !1;
      }
    }
    var j = !1, F = null, O = -1, z = 5, H = -1;
    function Q() {
      return !(e.unstable_now() - H < z);
    }
    function Y() {
      if (F !== null) {
        var K = e.unstable_now();
        H = K;
        var oe = !0;
        try {
          oe = F(!0, K);
        } finally {
          oe ? ee() : (j = !1, F = null);
        }
      } else j = !1;
    }
    var ee;
    if (typeof I == "function") ee = function() {
      I(Y);
    };
    else if (typeof MessageChannel < "u") {
      var ie = new MessageChannel(), X = ie.port2;
      ie.port1.onmessage = Y, ee = function() {
        X.postMessage(null);
      };
    } else ee = function() {
      A(Y, 0);
    };
    function Z(K) {
      F = K, j || (j = !0, ee());
    }
    function J(K, oe) {
      O = A(function() {
        K(e.unstable_now());
      }, oe);
    }
    e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(K) {
      K.callback = null;
    }, e.unstable_continueExecution = function() {
      C || w || (C = !0, Z(L));
    }, e.unstable_forceFrameRate = function(K) {
      0 > K || 125 < K || (z = 0 < K ? Math.floor(1e3 / K) : 5);
    }, e.unstable_getCurrentPriorityLevel = function() {
      return v;
    }, e.unstable_getFirstCallbackNode = function() {
      return n(u);
    }, e.unstable_next = function(K) {
      switch (v) {
        case 1:
        case 2:
        case 3:
          var oe = 3;
          break;
        default:
          oe = v;
      }
      var be = v;
      v = oe;
      try {
        return K();
      } finally {
        v = be;
      }
    }, e.unstable_pauseExecution = function() {
    }, e.unstable_requestPaint = function() {
    }, e.unstable_runWithPriority = function(K, oe) {
      switch (K) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          K = 3;
      }
      var be = v;
      v = K;
      try {
        return oe();
      } finally {
        v = be;
      }
    }, e.unstable_scheduleCallback = function(K, oe, be) {
      var ce = e.unstable_now();
      switch (typeof be == "object" && be !== null ? (be = be.delay, be = typeof be == "number" && 0 < be ? ce + be : ce) : be = ce, K) {
        case 1:
          var pe = -1;
          break;
        case 2:
          pe = 250;
          break;
        case 5:
          pe = 1073741823;
          break;
        case 4:
          pe = 1e4;
          break;
        default:
          pe = 5e3;
      }
      return pe = be + pe, K = { id: p++, callback: oe, priorityLevel: K, startTime: be, expirationTime: pe, sortIndex: -1 }, be > ce ? (K.sortIndex = be, t(f, K), n(u) === null && K === n(f) && (x ? (R(O), O = -1) : x = !0, J(M, be - ce))) : (K.sortIndex = pe, t(u, K), C || w || (C = !0, Z(L))), K;
    }, e.unstable_shouldYield = Q, e.unstable_wrapCallback = function(K) {
      var oe = v;
      return function() {
        var be = v;
        v = oe;
        try {
          return K.apply(this, arguments);
        } finally {
          v = be;
        }
      };
    };
  }(yO)), yO;
}
var vO = {}, ZF;
function dwe() {
  return ZF || (ZF = 1, function(e) {
    ct.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var t = !1, n = !1, r = 5;
      function i(N, U) {
        var le = N.length;
        N.push(U), c(N, U, le);
      }
      function o(N) {
        return N.length === 0 ? null : N[0];
      }
      function s(N) {
        if (N.length === 0)
          return null;
        var U = N[0], le = N.pop();
        return le !== U && (N[0] = le, u(N, le, 0)), U;
      }
      function c(N, U, le) {
        for (var Ce = le; Ce > 0; ) {
          var Te = Ce - 1 >>> 1, Ve = N[Te];
          if (f(Ve, U) > 0)
            N[Te] = U, N[Ce] = Ve, Ce = Te;
          else
            return;
        }
      }
      function u(N, U, le) {
        for (var Ce = le, Te = N.length, Ve = Te >>> 1; Ce < Ve; ) {
          var kt = (Ce + 1) * 2 - 1, bn = N[kt], Wt = kt + 1, xn = N[Wt];
          if (f(bn, U) < 0)
            Wt < Te && f(xn, bn) < 0 ? (N[Ce] = xn, N[Wt] = U, Ce = Wt) : (N[Ce] = bn, N[kt] = U, Ce = kt);
          else if (Wt < Te && f(xn, U) < 0)
            N[Ce] = xn, N[Wt] = U, Ce = Wt;
          else
            return;
        }
      }
      function f(N, U) {
        var le = N.sortIndex - U.sortIndex;
        return le !== 0 ? le : N.id - U.id;
      }
      var p = 1, y = 2, v = 3, w = 4, C = 5;
      function x(N, U) {
      }
      var A = typeof performance == "object" && typeof performance.now == "function";
      if (A) {
        var R = performance;
        e.unstable_now = function() {
          return R.now();
        };
      } else {
        var I = Date, D = I.now();
        e.unstable_now = function() {
          return I.now() - D;
        };
      }
      var M = 1073741823, L = -1, j = 250, F = 5e3, O = 1e4, z = M, H = [], Q = [], Y = 1, ee = null, ie = v, X = !1, Z = !1, J = !1, K = typeof setTimeout == "function" ? setTimeout : null, oe = typeof clearTimeout == "function" ? clearTimeout : null, be = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function ce(N) {
        for (var U = o(Q); U !== null; ) {
          if (U.callback === null)
            s(Q);
          else if (U.startTime <= N)
            s(Q), U.sortIndex = U.expirationTime, i(H, U);
          else
            return;
          U = o(Q);
        }
      }
      function pe(N) {
        if (J = !1, ce(N), !Z)
          if (o(H) !== null)
            Z = !0, qt(Ee);
          else {
            var U = o(Q);
            U !== null && gt(pe, U.startTime - N);
          }
      }
      function Ee(N, U) {
        Z = !1, J && (J = !1, Ht()), X = !0;
        var le = ie;
        try {
          var Ce;
          if (!n) return Se(N, U);
        } finally {
          ee = null, ie = le, X = !1;
        }
      }
      function Se(N, U) {
        var le = U;
        for (ce(le), ee = o(H); ee !== null && !t && !(ee.expirationTime > le && (!N || or())); ) {
          var Ce = ee.callback;
          if (typeof Ce == "function") {
            ee.callback = null, ie = ee.priorityLevel;
            var Te = ee.expirationTime <= le, Ve = Ce(Te);
            le = e.unstable_now(), typeof Ve == "function" ? ee.callback = Ve : ee === o(H) && s(H), ce(le);
          } else
            s(H);
          ee = o(H);
        }
        if (ee !== null)
          return !0;
        var kt = o(Q);
        return kt !== null && gt(pe, kt.startTime - le), !1;
      }
      function Me(N, U) {
        switch (N) {
          case p:
          case y:
          case v:
          case w:
          case C:
            break;
          default:
            N = v;
        }
        var le = ie;
        ie = N;
        try {
          return U();
        } finally {
          ie = le;
        }
      }
      function Fe(N) {
        var U;
        switch (ie) {
          case p:
          case y:
          case v:
            U = v;
            break;
          default:
            U = ie;
            break;
        }
        var le = ie;
        ie = U;
        try {
          return N();
        } finally {
          ie = le;
        }
      }
      function st(N) {
        var U = ie;
        return function() {
          var le = ie;
          ie = U;
          try {
            return N.apply(this, arguments);
          } finally {
            ie = le;
          }
        };
      }
      function mt(N, U, le) {
        var Ce = e.unstable_now(), Te;
        if (typeof le == "object" && le !== null) {
          var Ve = le.delay;
          typeof Ve == "number" && Ve > 0 ? Te = Ce + Ve : Te = Ce;
        } else
          Te = Ce;
        var kt;
        switch (N) {
          case p:
            kt = L;
            break;
          case y:
            kt = j;
            break;
          case C:
            kt = z;
            break;
          case w:
            kt = O;
            break;
          case v:
          default:
            kt = F;
            break;
        }
        var bn = Te + kt, Wt = {
          id: Y++,
          callback: U,
          priorityLevel: N,
          startTime: Te,
          expirationTime: bn,
          sortIndex: -1
        };
        return Te > Ce ? (Wt.sortIndex = Te, i(Q, Wt), o(H) === null && Wt === o(Q) && (J ? Ht() : J = !0, gt(pe, Te - Ce))) : (Wt.sortIndex = bn, i(H, Wt), !Z && !X && (Z = !0, qt(Ee))), Wt;
      }
      function yt() {
      }
      function Ut() {
        !Z && !X && (Z = !0, qt(Ee));
      }
      function hn() {
        return o(H);
      }
      function wn(N) {
        N.callback = null;
      }
      function Ot() {
        return ie;
      }
      var xt = !1, zt = null, Pn = -1, Fn = r, tr = -1;
      function or() {
        var N = e.unstable_now() - tr;
        return !(N < Fn);
      }
      function ar() {
      }
      function Cr(N) {
        N < 0 || N > 125 || (N > 0 ? Fn = Math.floor(1e3 / N) : Fn = r);
      }
      var Un = function() {
        if (zt !== null) {
          var N = e.unstable_now();
          tr = N;
          var U = !0, le = !0;
          try {
            le = zt(U, N);
          } finally {
            le ? $n() : (xt = !1, zt = null);
          }
        } else
          xt = !1;
      }, $n;
      if (typeof be == "function")
        $n = function() {
          be(Un);
        };
      else if (typeof MessageChannel < "u") {
        var gr = new MessageChannel(), Tt = gr.port2;
        gr.port1.onmessage = Un, $n = function() {
          Tt.postMessage(null);
        };
      } else
        $n = function() {
          K(Un, 0);
        };
      function qt(N) {
        zt = N, xt || (xt = !0, $n());
      }
      function gt(N, U) {
        Pn = K(function() {
          N(e.unstable_now());
        }, U);
      }
      function Ht() {
        oe(Pn), Pn = -1;
      }
      var br = ar, ne = null;
      e.unstable_IdlePriority = C, e.unstable_ImmediatePriority = p, e.unstable_LowPriority = w, e.unstable_NormalPriority = v, e.unstable_Profiling = ne, e.unstable_UserBlockingPriority = y, e.unstable_cancelCallback = wn, e.unstable_continueExecution = Ut, e.unstable_forceFrameRate = Cr, e.unstable_getCurrentPriorityLevel = Ot, e.unstable_getFirstCallbackNode = hn, e.unstable_next = Fe, e.unstable_pauseExecution = yt, e.unstable_requestPaint = br, e.unstable_runWithPriority = Me, e.unstable_scheduleCallback = mt, e.unstable_shouldYield = or, e.unstable_wrapCallback = st, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(vO)), vO;
}
var eU;
function MW() {
  return eU || (eU = 1, ct.env.NODE_ENV === "production" ? _k.exports = uwe() : _k.exports = dwe()), _k.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tU;
function fwe() {
  if (tU) return Ps;
  tU = 1;
  var e = k, t = MW();
  function n(d) {
    for (var h = "https://reactjs.org/docs/error-decoder.html?invariant=" + d, b = 1; b < arguments.length; b++) h += "&args[]=" + encodeURIComponent(arguments[b]);
    return "Minified React error #" + d + "; visit " + h + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var r = /* @__PURE__ */ new Set(), i = {};
  function o(d, h) {
    s(d, h), s(d + "Capture", h);
  }
  function s(d, h) {
    for (i[d] = h, d = 0; d < h.length; d++) r.add(h[d]);
  }
  var c = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), u = Object.prototype.hasOwnProperty, f = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, p = {}, y = {};
  function v(d) {
    return u.call(y, d) ? !0 : u.call(p, d) ? !1 : f.test(d) ? y[d] = !0 : (p[d] = !0, !1);
  }
  function w(d, h, b, T) {
    if (b !== null && b.type === 0) return !1;
    switch (typeof h) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return T ? !1 : b !== null ? !b.acceptsBooleans : (d = d.toLowerCase().slice(0, 5), d !== "data-" && d !== "aria-");
      default:
        return !1;
    }
  }
  function C(d, h, b, T) {
    if (h === null || typeof h > "u" || w(d, h, b, T)) return !0;
    if (T) return !1;
    if (b !== null) switch (b.type) {
      case 3:
        return !h;
      case 4:
        return h === !1;
      case 5:
        return isNaN(h);
      case 6:
        return isNaN(h) || 1 > h;
    }
    return !1;
  }
  function x(d, h, b, T, P, V, te) {
    this.acceptsBooleans = h === 2 || h === 3 || h === 4, this.attributeName = T, this.attributeNamespace = P, this.mustUseProperty = b, this.propertyName = d, this.type = h, this.sanitizeURL = V, this.removeEmptyString = te;
  }
  var A = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(d) {
    A[d] = new x(d, 0, !1, d, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(d) {
    var h = d[0];
    A[h] = new x(h, 1, !1, d[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(d) {
    A[d] = new x(d, 2, !1, d.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(d) {
    A[d] = new x(d, 2, !1, d, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(d) {
    A[d] = new x(d, 3, !1, d.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(d) {
    A[d] = new x(d, 3, !0, d, null, !1, !1);
  }), ["capture", "download"].forEach(function(d) {
    A[d] = new x(d, 4, !1, d, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(d) {
    A[d] = new x(d, 6, !1, d, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(d) {
    A[d] = new x(d, 5, !1, d.toLowerCase(), null, !1, !1);
  });
  var R = /[\-:]([a-z])/g;
  function I(d) {
    return d[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(d) {
    var h = d.replace(
      R,
      I
    );
    A[h] = new x(h, 1, !1, d, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(d) {
    var h = d.replace(R, I);
    A[h] = new x(h, 1, !1, d, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(d) {
    var h = d.replace(R, I);
    A[h] = new x(h, 1, !1, d, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(d) {
    A[d] = new x(d, 1, !1, d.toLowerCase(), null, !1, !1);
  }), A.xlinkHref = new x("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(d) {
    A[d] = new x(d, 1, !1, d.toLowerCase(), null, !0, !0);
  });
  function D(d, h, b, T) {
    var P = A.hasOwnProperty(h) ? A[h] : null;
    (P !== null ? P.type !== 0 : T || !(2 < h.length) || h[0] !== "o" && h[0] !== "O" || h[1] !== "n" && h[1] !== "N") && (C(h, b, P, T) && (b = null), T || P === null ? v(h) && (b === null ? d.removeAttribute(h) : d.setAttribute(h, "" + b)) : P.mustUseProperty ? d[P.propertyName] = b === null ? P.type === 3 ? !1 : "" : b : (h = P.attributeName, T = P.attributeNamespace, b === null ? d.removeAttribute(h) : (P = P.type, b = P === 3 || P === 4 && b === !0 ? "" : "" + b, T ? d.setAttributeNS(T, h, b) : d.setAttribute(h, b))));
  }
  var M = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, L = Symbol.for("react.element"), j = Symbol.for("react.portal"), F = Symbol.for("react.fragment"), O = Symbol.for("react.strict_mode"), z = Symbol.for("react.profiler"), H = Symbol.for("react.provider"), Q = Symbol.for("react.context"), Y = Symbol.for("react.forward_ref"), ee = Symbol.for("react.suspense"), ie = Symbol.for("react.suspense_list"), X = Symbol.for("react.memo"), Z = Symbol.for("react.lazy"), J = Symbol.for("react.offscreen"), K = Symbol.iterator;
  function oe(d) {
    return d === null || typeof d != "object" ? null : (d = K && d[K] || d["@@iterator"], typeof d == "function" ? d : null);
  }
  var be = Object.assign, ce;
  function pe(d) {
    if (ce === void 0) try {
      throw Error();
    } catch (b) {
      var h = b.stack.trim().match(/\n( *(at )?)/);
      ce = h && h[1] || "";
    }
    return `
` + ce + d;
  }
  var Ee = !1;
  function Se(d, h) {
    if (!d || Ee) return "";
    Ee = !0;
    var b = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (h) if (h = function() {
        throw Error();
      }, Object.defineProperty(h.prototype, "props", { set: function() {
        throw Error();
      } }), typeof Reflect == "object" && Reflect.construct) {
        try {
          Reflect.construct(h, []);
        } catch (He) {
          var T = He;
        }
        Reflect.construct(d, [], h);
      } else {
        try {
          h.call();
        } catch (He) {
          T = He;
        }
        d.call(h.prototype);
      }
      else {
        try {
          throw Error();
        } catch (He) {
          T = He;
        }
        d();
      }
    } catch (He) {
      if (He && T && typeof He.stack == "string") {
        for (var P = He.stack.split(`
`), V = T.stack.split(`
`), te = P.length - 1, me = V.length - 1; 1 <= te && 0 <= me && P[te] !== V[me]; ) me--;
        for (; 1 <= te && 0 <= me; te--, me--) if (P[te] !== V[me]) {
          if (te !== 1 || me !== 1)
            do
              if (te--, me--, 0 > me || P[te] !== V[me]) {
                var xe = `
` + P[te].replace(" at new ", " at ");
                return d.displayName && xe.includes("<anonymous>") && (xe = xe.replace("<anonymous>", d.displayName)), xe;
              }
            while (1 <= te && 0 <= me);
          break;
        }
      }
    } finally {
      Ee = !1, Error.prepareStackTrace = b;
    }
    return (d = d ? d.displayName || d.name : "") ? pe(d) : "";
  }
  function Me(d) {
    switch (d.tag) {
      case 5:
        return pe(d.type);
      case 16:
        return pe("Lazy");
      case 13:
        return pe("Suspense");
      case 19:
        return pe("SuspenseList");
      case 0:
      case 2:
      case 15:
        return d = Se(d.type, !1), d;
      case 11:
        return d = Se(d.type.render, !1), d;
      case 1:
        return d = Se(d.type, !0), d;
      default:
        return "";
    }
  }
  function Fe(d) {
    if (d == null) return null;
    if (typeof d == "function") return d.displayName || d.name || null;
    if (typeof d == "string") return d;
    switch (d) {
      case F:
        return "Fragment";
      case j:
        return "Portal";
      case z:
        return "Profiler";
      case O:
        return "StrictMode";
      case ee:
        return "Suspense";
      case ie:
        return "SuspenseList";
    }
    if (typeof d == "object") switch (d.$$typeof) {
      case Q:
        return (d.displayName || "Context") + ".Consumer";
      case H:
        return (d._context.displayName || "Context") + ".Provider";
      case Y:
        var h = d.render;
        return d = d.displayName, d || (d = h.displayName || h.name || "", d = d !== "" ? "ForwardRef(" + d + ")" : "ForwardRef"), d;
      case X:
        return h = d.displayName || null, h !== null ? h : Fe(d.type) || "Memo";
      case Z:
        h = d._payload, d = d._init;
        try {
          return Fe(d(h));
        } catch {
        }
    }
    return null;
  }
  function st(d) {
    var h = d.type;
    switch (d.tag) {
      case 24:
        return "Cache";
      case 9:
        return (h.displayName || "Context") + ".Consumer";
      case 10:
        return (h._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return d = h.render, d = d.displayName || d.name || "", h.displayName || (d !== "" ? "ForwardRef(" + d + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return h;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Fe(h);
      case 8:
        return h === O ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof h == "function") return h.displayName || h.name || null;
        if (typeof h == "string") return h;
    }
    return null;
  }
  function mt(d) {
    switch (typeof d) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return d;
      case "object":
        return d;
      default:
        return "";
    }
  }
  function yt(d) {
    var h = d.type;
    return (d = d.nodeName) && d.toLowerCase() === "input" && (h === "checkbox" || h === "radio");
  }
  function Ut(d) {
    var h = yt(d) ? "checked" : "value", b = Object.getOwnPropertyDescriptor(d.constructor.prototype, h), T = "" + d[h];
    if (!d.hasOwnProperty(h) && typeof b < "u" && typeof b.get == "function" && typeof b.set == "function") {
      var P = b.get, V = b.set;
      return Object.defineProperty(d, h, { configurable: !0, get: function() {
        return P.call(this);
      }, set: function(te) {
        T = "" + te, V.call(this, te);
      } }), Object.defineProperty(d, h, { enumerable: b.enumerable }), { getValue: function() {
        return T;
      }, setValue: function(te) {
        T = "" + te;
      }, stopTracking: function() {
        d._valueTracker = null, delete d[h];
      } };
    }
  }
  function hn(d) {
    d._valueTracker || (d._valueTracker = Ut(d));
  }
  function wn(d) {
    if (!d) return !1;
    var h = d._valueTracker;
    if (!h) return !0;
    var b = h.getValue(), T = "";
    return d && (T = yt(d) ? d.checked ? "true" : "false" : d.value), d = T, d !== b ? (h.setValue(d), !0) : !1;
  }
  function Ot(d) {
    if (d = d || (typeof document < "u" ? document : void 0), typeof d > "u") return null;
    try {
      return d.activeElement || d.body;
    } catch {
      return d.body;
    }
  }
  function xt(d, h) {
    var b = h.checked;
    return be({}, h, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: b ?? d._wrapperState.initialChecked });
  }
  function zt(d, h) {
    var b = h.defaultValue == null ? "" : h.defaultValue, T = h.checked != null ? h.checked : h.defaultChecked;
    b = mt(h.value != null ? h.value : b), d._wrapperState = { initialChecked: T, initialValue: b, controlled: h.type === "checkbox" || h.type === "radio" ? h.checked != null : h.value != null };
  }
  function Pn(d, h) {
    h = h.checked, h != null && D(d, "checked", h, !1);
  }
  function Fn(d, h) {
    Pn(d, h);
    var b = mt(h.value), T = h.type;
    if (b != null) T === "number" ? (b === 0 && d.value === "" || d.value != b) && (d.value = "" + b) : d.value !== "" + b && (d.value = "" + b);
    else if (T === "submit" || T === "reset") {
      d.removeAttribute("value");
      return;
    }
    h.hasOwnProperty("value") ? or(d, h.type, b) : h.hasOwnProperty("defaultValue") && or(d, h.type, mt(h.defaultValue)), h.checked == null && h.defaultChecked != null && (d.defaultChecked = !!h.defaultChecked);
  }
  function tr(d, h, b) {
    if (h.hasOwnProperty("value") || h.hasOwnProperty("defaultValue")) {
      var T = h.type;
      if (!(T !== "submit" && T !== "reset" || h.value !== void 0 && h.value !== null)) return;
      h = "" + d._wrapperState.initialValue, b || h === d.value || (d.value = h), d.defaultValue = h;
    }
    b = d.name, b !== "" && (d.name = ""), d.defaultChecked = !!d._wrapperState.initialChecked, b !== "" && (d.name = b);
  }
  function or(d, h, b) {
    (h !== "number" || Ot(d.ownerDocument) !== d) && (b == null ? d.defaultValue = "" + d._wrapperState.initialValue : d.defaultValue !== "" + b && (d.defaultValue = "" + b));
  }
  var ar = Array.isArray;
  function Cr(d, h, b, T) {
    if (d = d.options, h) {
      h = {};
      for (var P = 0; P < b.length; P++) h["$" + b[P]] = !0;
      for (b = 0; b < d.length; b++) P = h.hasOwnProperty("$" + d[b].value), d[b].selected !== P && (d[b].selected = P), P && T && (d[b].defaultSelected = !0);
    } else {
      for (b = "" + mt(b), h = null, P = 0; P < d.length; P++) {
        if (d[P].value === b) {
          d[P].selected = !0, T && (d[P].defaultSelected = !0);
          return;
        }
        h !== null || d[P].disabled || (h = d[P]);
      }
      h !== null && (h.selected = !0);
    }
  }
  function Un(d, h) {
    if (h.dangerouslySetInnerHTML != null) throw Error(n(91));
    return be({}, h, { value: void 0, defaultValue: void 0, children: "" + d._wrapperState.initialValue });
  }
  function $n(d, h) {
    var b = h.value;
    if (b == null) {
      if (b = h.children, h = h.defaultValue, b != null) {
        if (h != null) throw Error(n(92));
        if (ar(b)) {
          if (1 < b.length) throw Error(n(93));
          b = b[0];
        }
        h = b;
      }
      h == null && (h = ""), b = h;
    }
    d._wrapperState = { initialValue: mt(b) };
  }
  function gr(d, h) {
    var b = mt(h.value), T = mt(h.defaultValue);
    b != null && (b = "" + b, b !== d.value && (d.value = b), h.defaultValue == null && d.defaultValue !== b && (d.defaultValue = b)), T != null && (d.defaultValue = "" + T);
  }
  function Tt(d) {
    var h = d.textContent;
    h === d._wrapperState.initialValue && h !== "" && h !== null && (d.value = h);
  }
  function qt(d) {
    switch (d) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function gt(d, h) {
    return d == null || d === "http://www.w3.org/1999/xhtml" ? qt(h) : d === "http://www.w3.org/2000/svg" && h === "foreignObject" ? "http://www.w3.org/1999/xhtml" : d;
  }
  var Ht, br = function(d) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(h, b, T, P) {
      MSApp.execUnsafeLocalFunction(function() {
        return d(h, b, T, P);
      });
    } : d;
  }(function(d, h) {
    if (d.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in d) d.innerHTML = h;
    else {
      for (Ht = Ht || document.createElement("div"), Ht.innerHTML = "<svg>" + h.valueOf().toString() + "</svg>", h = Ht.firstChild; d.firstChild; ) d.removeChild(d.firstChild);
      for (; h.firstChild; ) d.appendChild(h.firstChild);
    }
  });
  function ne(d, h) {
    if (h) {
      var b = d.firstChild;
      if (b && b === d.lastChild && b.nodeType === 3) {
        b.nodeValue = h;
        return;
      }
    }
    d.textContent = h;
  }
  var N = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, U = ["Webkit", "ms", "Moz", "O"];
  Object.keys(N).forEach(function(d) {
    U.forEach(function(h) {
      h = h + d.charAt(0).toUpperCase() + d.substring(1), N[h] = N[d];
    });
  });
  function le(d, h, b) {
    return h == null || typeof h == "boolean" || h === "" ? "" : b || typeof h != "number" || h === 0 || N.hasOwnProperty(d) && N[d] ? ("" + h).trim() : h + "px";
  }
  function Ce(d, h) {
    d = d.style;
    for (var b in h) if (h.hasOwnProperty(b)) {
      var T = b.indexOf("--") === 0, P = le(b, h[b], T);
      b === "float" && (b = "cssFloat"), T ? d.setProperty(b, P) : d[b] = P;
    }
  }
  var Te = be({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function Ve(d, h) {
    if (h) {
      if (Te[d] && (h.children != null || h.dangerouslySetInnerHTML != null)) throw Error(n(137, d));
      if (h.dangerouslySetInnerHTML != null) {
        if (h.children != null) throw Error(n(60));
        if (typeof h.dangerouslySetInnerHTML != "object" || !("__html" in h.dangerouslySetInnerHTML)) throw Error(n(61));
      }
      if (h.style != null && typeof h.style != "object") throw Error(n(62));
    }
  }
  function kt(d, h) {
    if (d.indexOf("-") === -1) return typeof h.is == "string";
    switch (d) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var bn = null;
  function Wt(d) {
    return d = d.target || d.srcElement || window, d.correspondingUseElement && (d = d.correspondingUseElement), d.nodeType === 3 ? d.parentNode : d;
  }
  var xn = null, St = null, Qn = null;
  function Nr(d) {
    if (d = Tp(d)) {
      if (typeof xn != "function") throw Error(n(280));
      var h = d.stateNode;
      h && (h = an(h), xn(d.stateNode, d.type, h));
    }
  }
  function bi(d) {
    St ? Qn ? Qn.push(d) : Qn = [d] : St = d;
  }
  function Do() {
    if (St) {
      var d = St, h = Qn;
      if (Qn = St = null, Nr(d), h) for (d = 0; d < h.length; d++) Nr(h[d]);
    }
  }
  function la(d, h) {
    return d(h);
  }
  function ja() {
  }
  var Mo = !1;
  function ri(d, h, b) {
    if (Mo) return d(h, b);
    Mo = !0;
    try {
      return la(d, h, b);
    } finally {
      Mo = !1, (St !== null || Qn !== null) && (ja(), Do());
    }
  }
  function ui(d, h) {
    var b = d.stateNode;
    if (b === null) return null;
    var T = an(b);
    if (T === null) return null;
    b = T[h];
    e: switch (h) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (T = !T.disabled) || (d = d.type, T = !(d === "button" || d === "input" || d === "select" || d === "textarea")), d = !T;
        break e;
      default:
        d = !1;
    }
    if (d) return null;
    if (b && typeof b != "function") throw Error(n(231, h, typeof b));
    return b;
  }
  var ji = !1;
  if (c) try {
    var _i = {};
    Object.defineProperty(_i, "passive", { get: function() {
      ji = !0;
    } }), window.addEventListener("test", _i, _i), window.removeEventListener("test", _i, _i);
  } catch {
    ji = !1;
  }
  function ho(d, h, b, T, P, V, te, me, xe) {
    var He = Array.prototype.slice.call(arguments, 3);
    try {
      h.apply(b, He);
    } catch (at) {
      this.onError(at);
    }
  }
  var wi = !1, we = null, Ae = !1, ye = null, re = { onError: function(d) {
    wi = !0, we = d;
  } };
  function _e(d, h, b, T, P, V, te, me, xe) {
    wi = !1, we = null, ho.apply(re, arguments);
  }
  function Pe(d, h, b, T, P, V, te, me, xe) {
    if (_e.apply(this, arguments), wi) {
      if (wi) {
        var He = we;
        wi = !1, we = null;
      } else throw Error(n(198));
      Ae || (Ae = !0, ye = He);
    }
  }
  function Qe(d) {
    var h = d, b = d;
    if (d.alternate) for (; h.return; ) h = h.return;
    else {
      d = h;
      do
        h = d, h.flags & 4098 && (b = h.return), d = h.return;
      while (d);
    }
    return h.tag === 3 ? b : null;
  }
  function Ke(d) {
    if (d.tag === 13) {
      var h = d.memoizedState;
      if (h === null && (d = d.alternate, d !== null && (h = d.memoizedState)), h !== null) return h.dehydrated;
    }
    return null;
  }
  function lt(d) {
    if (Qe(d) !== d) throw Error(n(188));
  }
  function tt(d) {
    var h = d.alternate;
    if (!h) {
      if (h = Qe(d), h === null) throw Error(n(188));
      return h !== d ? null : d;
    }
    for (var b = d, T = h; ; ) {
      var P = b.return;
      if (P === null) break;
      var V = P.alternate;
      if (V === null) {
        if (T = P.return, T !== null) {
          b = T;
          continue;
        }
        break;
      }
      if (P.child === V.child) {
        for (V = P.child; V; ) {
          if (V === b) return lt(P), d;
          if (V === T) return lt(P), h;
          V = V.sibling;
        }
        throw Error(n(188));
      }
      if (b.return !== T.return) b = P, T = V;
      else {
        for (var te = !1, me = P.child; me; ) {
          if (me === b) {
            te = !0, b = P, T = V;
            break;
          }
          if (me === T) {
            te = !0, T = P, b = V;
            break;
          }
          me = me.sibling;
        }
        if (!te) {
          for (me = V.child; me; ) {
            if (me === b) {
              te = !0, b = V, T = P;
              break;
            }
            if (me === T) {
              te = !0, T = V, b = P;
              break;
            }
            me = me.sibling;
          }
          if (!te) throw Error(n(189));
        }
      }
      if (b.alternate !== T) throw Error(n(190));
    }
    if (b.tag !== 3) throw Error(n(188));
    return b.stateNode.current === b ? d : h;
  }
  function ot(d) {
    return d = tt(d), d !== null ? cn(d) : null;
  }
  function cn(d) {
    if (d.tag === 5 || d.tag === 6) return d;
    for (d = d.child; d !== null; ) {
      var h = cn(d);
      if (h !== null) return h;
      d = d.sibling;
    }
    return null;
  }
  var Qt = t.unstable_scheduleCallback, on = t.unstable_cancelCallback, pn = t.unstable_shouldYield, sr = t.unstable_requestPaint, tn = t.unstable_now, Ur = t.unstable_getCurrentPriorityLevel, xr = t.unstable_ImmediatePriority, vn = t.unstable_UserBlockingPriority, ii = t.unstable_NormalPriority, qo = t.unstable_LowPriority, Xi = t.unstable_IdlePriority, Po = null, Ci = null;
  function cs(d) {
    if (Ci && typeof Ci.onCommitFiberRoot == "function") try {
      Ci.onCommitFiberRoot(Po, d, void 0, (d.current.flags & 128) === 128);
    } catch {
    }
  }
  var Zt = Math.clz32 ? Math.clz32 : _r, Er = Math.log, xi = Math.LN2;
  function _r(d) {
    return d >>>= 0, d === 0 ? 32 : 31 - (Er(d) / xi | 0) | 0;
  }
  var Ji = 64, Fa = 4194304;
  function Wo(d) {
    switch (d & -d) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return d & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return d & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return d;
    }
  }
  function po(d, h) {
    var b = d.pendingLanes;
    if (b === 0) return 0;
    var T = 0, P = d.suspendedLanes, V = d.pingedLanes, te = b & 268435455;
    if (te !== 0) {
      var me = te & ~P;
      me !== 0 ? T = Wo(me) : (V &= te, V !== 0 && (T = Wo(V)));
    } else te = b & ~P, te !== 0 ? T = Wo(te) : V !== 0 && (T = Wo(V));
    if (T === 0) return 0;
    if (h !== 0 && h !== T && !(h & P) && (P = T & -T, V = h & -h, P >= V || P === 16 && (V & 4194240) !== 0)) return h;
    if (T & 4 && (T |= b & 16), h = d.entangledLanes, h !== 0) for (d = d.entanglements, h &= T; 0 < h; ) b = 31 - Zt(h), P = 1 << b, T |= d[b], h &= ~P;
    return T;
  }
  function Ua(d, h) {
    switch (d) {
      case 1:
      case 2:
      case 4:
        return h + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return h + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function us(d, h) {
    for (var b = d.suspendedLanes, T = d.pingedLanes, P = d.expirationTimes, V = d.pendingLanes; 0 < V; ) {
      var te = 31 - Zt(V), me = 1 << te, xe = P[te];
      xe === -1 ? (!(me & b) || me & T) && (P[te] = Ua(me, h)) : xe <= h && (d.expiredLanes |= me), V &= ~me;
    }
  }
  function yl(d) {
    return d = d.pendingLanes & -1073741825, d !== 0 ? d : d & 1073741824 ? 1073741824 : 0;
  }
  function Qc() {
    var d = Ji;
    return Ji <<= 1, !(Ji & 4194240) && (Ji = 64), d;
  }
  function oc(d) {
    for (var h = [], b = 0; 31 > b; b++) h.push(d);
    return h;
  }
  function Gs(d, h, b) {
    d.pendingLanes |= h, h !== 536870912 && (d.suspendedLanes = 0, d.pingedLanes = 0), d = d.eventTimes, h = 31 - Zt(h), d[h] = b;
  }
  function hp(d, h) {
    var b = d.pendingLanes & ~h;
    d.pendingLanes = h, d.suspendedLanes = 0, d.pingedLanes = 0, d.expiredLanes &= h, d.mutableReadLanes &= h, d.entangledLanes &= h, h = d.entanglements;
    var T = d.eventTimes;
    for (d = d.expirationTimes; 0 < b; ) {
      var P = 31 - Zt(b), V = 1 << P;
      h[P] = 0, T[P] = -1, d[P] = -1, b &= ~V;
    }
  }
  function ds(d, h) {
    var b = d.entangledLanes |= h;
    for (d = d.entanglements; b; ) {
      var T = 31 - Zt(b), P = 1 << T;
      P & h | d[T] & h && (d[T] |= h), b &= ~P;
    }
  }
  var nr = 0;
  function Xc(d) {
    return d &= -d, 1 < d ? 4 < d ? d & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var ac, Jc, Hn, Zc, eu, En = !1, fs = [], Br = null, Zi = null, Fi = null, vl = /* @__PURE__ */ new Map(), Hr = /* @__PURE__ */ new Map(), lr = [], Yu = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function di(d, h) {
    switch (d) {
      case "focusin":
      case "focusout":
        Br = null;
        break;
      case "dragenter":
      case "dragleave":
        Zi = null;
        break;
      case "mouseover":
      case "mouseout":
        Fi = null;
        break;
      case "pointerover":
      case "pointerout":
        vl.delete(h.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Hr.delete(h.pointerId);
    }
  }
  function Xr(d, h, b, T, P, V) {
    return d === null || d.nativeEvent !== V ? (d = { blockedOn: h, domEventName: b, eventSystemFlags: T, nativeEvent: V, targetContainers: [P] }, h !== null && (h = Tp(h), h !== null && Jc(h)), d) : (d.eventSystemFlags |= T, h = d.targetContainers, P !== null && h.indexOf(P) === -1 && h.push(P), d);
  }
  function hs(d, h, b, T, P) {
    switch (h) {
      case "focusin":
        return Br = Xr(Br, d, h, b, T, P), !0;
      case "dragenter":
        return Zi = Xr(Zi, d, h, b, T, P), !0;
      case "mouseover":
        return Fi = Xr(Fi, d, h, b, T, P), !0;
      case "pointerover":
        var V = P.pointerId;
        return vl.set(V, Xr(vl.get(V) || null, d, h, b, T, P)), !0;
      case "gotpointercapture":
        return V = P.pointerId, Hr.set(V, Xr(Hr.get(V) || null, d, h, b, T, P)), !0;
    }
    return !1;
  }
  function Qu(d) {
    var h = ms(d.target);
    if (h !== null) {
      var b = Qe(h);
      if (b !== null) {
        if (h = b.tag, h === 13) {
          if (h = Ke(b), h !== null) {
            d.blockedOn = h, eu(d.priority, function() {
              Hn(b);
            });
            return;
          }
        } else if (h === 3 && b.stateNode.current.memoizedState.isDehydrated) {
          d.blockedOn = b.tag === 3 ? b.stateNode.containerInfo : null;
          return;
        }
      }
    }
    d.blockedOn = null;
  }
  function Ks(d) {
    if (d.blockedOn !== null) return !1;
    for (var h = d.targetContainers; 0 < h.length; ) {
      var b = cr(d.domEventName, d.eventSystemFlags, h[0], d.nativeEvent);
      if (b === null) {
        b = d.nativeEvent;
        var T = new b.constructor(b.type, b);
        bn = T, b.target.dispatchEvent(T), bn = null;
      } else return h = Tp(b), h !== null && Jc(h), d.blockedOn = b, !1;
      h.shift();
    }
    return !0;
  }
  function Ys(d, h, b) {
    Ks(d) && b.delete(h);
  }
  function mf() {
    En = !1, Br !== null && Ks(Br) && (Br = null), Zi !== null && Ks(Zi) && (Zi = null), Fi !== null && Ks(Fi) && (Fi = null), vl.forEach(Ys), Hr.forEach(Ys);
  }
  function ca(d, h) {
    d.blockedOn === h && (d.blockedOn = null, En || (En = !0, t.unstable_scheduleCallback(t.unstable_NormalPriority, mf)));
  }
  function Qs(d) {
    function h(P) {
      return ca(P, d);
    }
    if (0 < fs.length) {
      ca(fs[0], d);
      for (var b = 1; b < fs.length; b++) {
        var T = fs[b];
        T.blockedOn === d && (T.blockedOn = null);
      }
    }
    for (Br !== null && ca(Br, d), Zi !== null && ca(Zi, d), Fi !== null && ca(Fi, d), vl.forEach(h), Hr.forEach(h), b = 0; b < lr.length; b++) T = lr[b], T.blockedOn === d && (T.blockedOn = null);
    for (; 0 < lr.length && (b = lr[0], b.blockedOn === null); ) Qu(b), b.blockedOn === null && lr.shift();
  }
  var Xs = M.ReactCurrentBatchConfig, fe = !0;
  function Ie(d, h, b, T) {
    var P = nr, V = Xs.transition;
    Xs.transition = null;
    try {
      nr = 1, It(d, h, b, T);
    } finally {
      nr = P, Xs.transition = V;
    }
  }
  function $e(d, h, b, T) {
    var P = nr, V = Xs.transition;
    Xs.transition = null;
    try {
      nr = 4, It(d, h, b, T);
    } finally {
      nr = P, Xs.transition = V;
    }
  }
  function It(d, h, b, T) {
    if (fe) {
      var P = cr(d, h, b, T);
      if (P === null) Sy(d, h, T, jn, b), di(d, T);
      else if (hs(P, d, h, b, T)) T.stopPropagation();
      else if (di(d, T), h & 4 && -1 < Yu.indexOf(d)) {
        for (; P !== null; ) {
          var V = Tp(P);
          if (V !== null && ac(V), V = cr(d, h, b, T), V === null && Sy(d, h, T, jn, b), V === P) break;
          P = V;
        }
        P !== null && T.stopPropagation();
      } else Sy(d, h, T, null, b);
    }
  }
  var jn = null;
  function cr(d, h, b, T) {
    if (jn = null, d = Wt(T), d = ms(d), d !== null) if (h = Qe(d), h === null) d = null;
    else if (b = h.tag, b === 13) {
      if (d = Ke(h), d !== null) return d;
      d = null;
    } else if (b === 3) {
      if (h.stateNode.current.memoizedState.isDehydrated) return h.tag === 3 ? h.stateNode.containerInfo : null;
      d = null;
    } else h !== d && (d = null);
    return jn = d, null;
  }
  function Sr(d) {
    switch (d) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (Ur()) {
          case xr:
            return 1;
          case vn:
            return 4;
          case ii:
          case qo:
            return 16;
          case Xi:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var Nn = null, W = null, ve = null;
  function Be() {
    if (ve) return ve;
    var d, h = W, b = h.length, T, P = "value" in Nn ? Nn.value : Nn.textContent, V = P.length;
    for (d = 0; d < b && h[d] === P[d]; d++) ;
    var te = b - d;
    for (T = 1; T <= te && h[b - T] === P[V - T]; T++) ;
    return ve = P.slice(d, 1 < T ? 1 - T : void 0);
  }
  function We(d) {
    var h = d.keyCode;
    return "charCode" in d ? (d = d.charCode, d === 0 && h === 13 && (d = 13)) : d = h, d === 10 && (d = 13), 32 <= d || d === 13 ? d : 0;
  }
  function ft() {
    return !0;
  }
  function rn() {
    return !1;
  }
  function vt(d) {
    function h(b, T, P, V, te) {
      this._reactName = b, this._targetInst = P, this.type = T, this.nativeEvent = V, this.target = te, this.currentTarget = null;
      for (var me in d) d.hasOwnProperty(me) && (b = d[me], this[me] = b ? b(V) : V[me]);
      return this.isDefaultPrevented = (V.defaultPrevented != null ? V.defaultPrevented : V.returnValue === !1) ? ft : rn, this.isPropagationStopped = rn, this;
    }
    return be(h.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var b = this.nativeEvent;
      b && (b.preventDefault ? b.preventDefault() : typeof b.returnValue != "unknown" && (b.returnValue = !1), this.isDefaultPrevented = ft);
    }, stopPropagation: function() {
      var b = this.nativeEvent;
      b && (b.stopPropagation ? b.stopPropagation() : typeof b.cancelBubble != "unknown" && (b.cancelBubble = !0), this.isPropagationStopped = ft);
    }, persist: function() {
    }, isPersistent: ft }), h;
  }
  var dn = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(d) {
    return d.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, Gn = vt(dn), ur = be({}, dn, { view: 0, detail: 0 }), Lr = vt(ur), Rr, jr, zr, Zn = be({}, ur, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: t0, button: 0, buttons: 0, relatedTarget: function(d) {
    return d.relatedTarget === void 0 ? d.fromElement === d.srcElement ? d.toElement : d.fromElement : d.relatedTarget;
  }, movementX: function(d) {
    return "movementX" in d ? d.movementX : (d !== zr && (zr && d.type === "mousemove" ? (Rr = d.screenX - zr.screenX, jr = d.screenY - zr.screenY) : jr = Rr = 0, zr = d), Rr);
  }, movementY: function(d) {
    return "movementY" in d ? d.movementY : jr;
  } }), sc = vt(Zn), yf = be({}, Zn, { dataTransfer: 0 }), pp = vt(yf), Xb = be({}, ur, { relatedTarget: 0 }), Js = vt(Xb), mp = be({}, dn, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), yp = vt(mp), Jb = be({}, dn, { clipboardData: function(d) {
    return "clipboardData" in d ? d.clipboardData : window.clipboardData;
  } }), iT = vt(Jb), oT = be({}, dn, { data: 0 }), Zb = vt(oT), e0 = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Ex = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Sx = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function kx(d) {
    var h = this.nativeEvent;
    return h.getModifierState ? h.getModifierState(d) : (d = Sx[d]) ? !!h[d] : !1;
  }
  function t0() {
    return kx;
  }
  var lc = be({}, ur, { key: function(d) {
    if (d.key) {
      var h = e0[d.key] || d.key;
      if (h !== "Unidentified") return h;
    }
    return d.type === "keypress" ? (d = We(d), d === 13 ? "Enter" : String.fromCharCode(d)) : d.type === "keydown" || d.type === "keyup" ? Ex[d.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: t0, charCode: function(d) {
    return d.type === "keypress" ? We(d) : 0;
  }, keyCode: function(d) {
    return d.type === "keydown" || d.type === "keyup" ? d.keyCode : 0;
  }, which: function(d) {
    return d.type === "keypress" ? We(d) : d.type === "keydown" || d.type === "keyup" ? d.keyCode : 0;
  } }), aT = vt(lc), n0 = be({}, Zn, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), yy = vt(n0), r0 = be({}, ur, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: t0 }), sT = vt(r0), vy = be({}, dn, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Ax = vt(vy), ua = be({}, Zn, {
    deltaX: function(d) {
      return "deltaX" in d ? d.deltaX : "wheelDeltaX" in d ? -d.wheelDeltaX : 0;
    },
    deltaY: function(d) {
      return "deltaY" in d ? d.deltaY : "wheelDeltaY" in d ? -d.wheelDeltaY : "wheelDelta" in d ? -d.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), cc = vt(ua), Ri = [9, 13, 27, 32], Zs = c && "CompositionEvent" in window, Xu = null;
  c && "documentMode" in document && (Xu = document.documentMode);
  var gy = c && "TextEvent" in window && !Xu, Tx = c && (!Zs || Xu && 8 < Xu && 11 >= Xu), vf = " ", _x = !1;
  function Rx(d, h) {
    switch (d) {
      case "keyup":
        return Ri.indexOf(h.keyCode) !== -1;
      case "keydown":
        return h.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function by(d) {
    return d = d.detail, typeof d == "object" && "data" in d ? d.data : null;
  }
  var gf = !1;
  function lT(d, h) {
    switch (d) {
      case "compositionend":
        return by(h);
      case "keypress":
        return h.which !== 32 ? null : (_x = !0, vf);
      case "textInput":
        return d = h.data, d === vf && _x ? null : d;
      default:
        return null;
    }
  }
  function cT(d, h) {
    if (gf) return d === "compositionend" || !Zs && Rx(d, h) ? (d = Be(), ve = W = Nn = null, gf = !1, d) : null;
    switch (d) {
      case "paste":
        return null;
      case "keypress":
        if (!(h.ctrlKey || h.altKey || h.metaKey) || h.ctrlKey && h.altKey) {
          if (h.char && 1 < h.char.length) return h.char;
          if (h.which) return String.fromCharCode(h.which);
        }
        return null;
      case "compositionend":
        return Tx && h.locale !== "ko" ? null : h.data;
      default:
        return null;
    }
  }
  var Ox = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function Ix(d) {
    var h = d && d.nodeName && d.nodeName.toLowerCase();
    return h === "input" ? !!Ox[d.type] : h === "textarea";
  }
  function Dx(d, h, b, T) {
    bi(T), h = Sp(h, "onChange"), 0 < h.length && (b = new Gn("onChange", "change", null, b, T), d.push({ event: b, listeners: h }));
  }
  var vp = null, bf = null;
  function wf(d) {
    Ey(d, 0);
  }
  function Cf(d) {
    var h = Ef(d);
    if (wn(h)) return d;
  }
  function Mx(d, h) {
    if (d === "change") return h;
  }
  var i0 = !1;
  if (c) {
    var o0;
    if (c) {
      var a0 = "oninput" in document;
      if (!a0) {
        var Px = document.createElement("div");
        Px.setAttribute("oninput", "return;"), a0 = typeof Px.oninput == "function";
      }
      o0 = a0;
    } else o0 = !1;
    i0 = o0 && (!document.documentMode || 9 < document.documentMode);
  }
  function Nx() {
    vp && (vp.detachEvent("onpropertychange", Bx), bf = vp = null);
  }
  function Bx(d) {
    if (d.propertyName === "value" && Cf(bf)) {
      var h = [];
      Dx(h, bf, d, Wt(d)), ri(wf, h);
    }
  }
  function uT(d, h, b) {
    d === "focusin" ? (Nx(), vp = h, bf = b, vp.attachEvent("onpropertychange", Bx)) : d === "focusout" && Nx();
  }
  function dT(d) {
    if (d === "selectionchange" || d === "keyup" || d === "keydown") return Cf(bf);
  }
  function fT(d, h) {
    if (d === "click") return Cf(h);
  }
  function Lx(d, h) {
    if (d === "input" || d === "change") return Cf(h);
  }
  function hT(d, h) {
    return d === h && (d !== 0 || 1 / d === 1 / h) || d !== d && h !== h;
  }
  var ps = typeof Object.is == "function" ? Object.is : hT;
  function gp(d, h) {
    if (ps(d, h)) return !0;
    if (typeof d != "object" || d === null || typeof h != "object" || h === null) return !1;
    var b = Object.keys(d), T = Object.keys(h);
    if (b.length !== T.length) return !1;
    for (T = 0; T < b.length; T++) {
      var P = b[T];
      if (!u.call(h, P) || !ps(d[P], h[P])) return !1;
    }
    return !0;
  }
  function jx(d) {
    for (; d && d.firstChild; ) d = d.firstChild;
    return d;
  }
  function Fx(d, h) {
    var b = jx(d);
    d = 0;
    for (var T; b; ) {
      if (b.nodeType === 3) {
        if (T = d + b.textContent.length, d <= h && T >= h) return { node: b, offset: h - d };
        d = T;
      }
      e: {
        for (; b; ) {
          if (b.nextSibling) {
            b = b.nextSibling;
            break e;
          }
          b = b.parentNode;
        }
        b = void 0;
      }
      b = jx(b);
    }
  }
  function Ux(d, h) {
    return d && h ? d === h ? !0 : d && d.nodeType === 3 ? !1 : h && h.nodeType === 3 ? Ux(d, h.parentNode) : "contains" in d ? d.contains(h) : d.compareDocumentPosition ? !!(d.compareDocumentPosition(h) & 16) : !1 : !1;
  }
  function wy() {
    for (var d = window, h = Ot(); h instanceof d.HTMLIFrameElement; ) {
      try {
        var b = typeof h.contentWindow.location.href == "string";
      } catch {
        b = !1;
      }
      if (b) d = h.contentWindow;
      else break;
      h = Ot(d.document);
    }
    return h;
  }
  function uc(d) {
    var h = d && d.nodeName && d.nodeName.toLowerCase();
    return h && (h === "input" && (d.type === "text" || d.type === "search" || d.type === "tel" || d.type === "url" || d.type === "password") || h === "textarea" || d.contentEditable === "true");
  }
  function Cy(d) {
    var h = wy(), b = d.focusedElem, T = d.selectionRange;
    if (h !== b && b && b.ownerDocument && Ux(b.ownerDocument.documentElement, b)) {
      if (T !== null && uc(b)) {
        if (h = T.start, d = T.end, d === void 0 && (d = h), "selectionStart" in b) b.selectionStart = h, b.selectionEnd = Math.min(d, b.value.length);
        else if (d = (h = b.ownerDocument || document) && h.defaultView || window, d.getSelection) {
          d = d.getSelection();
          var P = b.textContent.length, V = Math.min(T.start, P);
          T = T.end === void 0 ? V : Math.min(T.end, P), !d.extend && V > T && (P = T, T = V, V = P), P = Fx(b, V);
          var te = Fx(
            b,
            T
          );
          P && te && (d.rangeCount !== 1 || d.anchorNode !== P.node || d.anchorOffset !== P.offset || d.focusNode !== te.node || d.focusOffset !== te.offset) && (h = h.createRange(), h.setStart(P.node, P.offset), d.removeAllRanges(), V > T ? (d.addRange(h), d.extend(te.node, te.offset)) : (h.setEnd(te.node, te.offset), d.addRange(h)));
        }
      }
      for (h = [], d = b; d = d.parentNode; ) d.nodeType === 1 && h.push({ element: d, left: d.scrollLeft, top: d.scrollTop });
      for (typeof b.focus == "function" && b.focus(), b = 0; b < h.length; b++) d = h[b], d.element.scrollLeft = d.left, d.element.scrollTop = d.top;
    }
  }
  var zx = c && "documentMode" in document && 11 >= document.documentMode, el = null, s0 = null, bp = null, l0 = !1;
  function Vx(d, h, b) {
    var T = b.window === b ? b.document : b.nodeType === 9 ? b : b.ownerDocument;
    l0 || el == null || el !== Ot(T) || (T = el, "selectionStart" in T && uc(T) ? T = { start: T.selectionStart, end: T.selectionEnd } : (T = (T.ownerDocument && T.ownerDocument.defaultView || window).getSelection(), T = { anchorNode: T.anchorNode, anchorOffset: T.anchorOffset, focusNode: T.focusNode, focusOffset: T.focusOffset }), bp && gp(bp, T) || (bp = T, T = Sp(s0, "onSelect"), 0 < T.length && (h = new Gn("onSelect", "select", null, h, b), d.push({ event: h, listeners: T }), h.target = el)));
  }
  function xy(d, h) {
    var b = {};
    return b[d.toLowerCase()] = h.toLowerCase(), b["Webkit" + d] = "webkit" + h, b["Moz" + d] = "moz" + h, b;
  }
  var Ju = { animationend: xy("Animation", "AnimationEnd"), animationiteration: xy("Animation", "AnimationIteration"), animationstart: xy("Animation", "AnimationStart"), transitionend: xy("Transition", "TransitionEnd") }, c0 = {}, u0 = {};
  c && (u0 = document.createElement("div").style, "AnimationEvent" in window || (delete Ju.animationend.animation, delete Ju.animationiteration.animation, delete Ju.animationstart.animation), "TransitionEvent" in window || delete Ju.transitionend.transition);
  function eo(d) {
    if (c0[d]) return c0[d];
    if (!Ju[d]) return d;
    var h = Ju[d], b;
    for (b in h) if (h.hasOwnProperty(b) && b in u0) return c0[d] = h[b];
    return d;
  }
  var d0 = eo("animationend"), $x = eo("animationiteration"), Hx = eo("animationstart"), qx = eo("transitionend"), Wx = /* @__PURE__ */ new Map(), Gx = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function dc(d, h) {
    Wx.set(d, h), o(h, [d]);
  }
  for (var wp = 0; wp < Gx.length; wp++) {
    var Zu = Gx[wp], pT = Zu.toLowerCase(), Cp = Zu[0].toUpperCase() + Zu.slice(1);
    dc(pT, "on" + Cp);
  }
  dc(d0, "onAnimationEnd"), dc($x, "onAnimationIteration"), dc(Hx, "onAnimationStart"), dc("dblclick", "onDoubleClick"), dc("focusin", "onFocus"), dc("focusout", "onBlur"), dc(qx, "onTransitionEnd"), s("onMouseEnter", ["mouseout", "mouseover"]), s("onMouseLeave", ["mouseout", "mouseover"]), s("onPointerEnter", ["pointerout", "pointerover"]), s("onPointerLeave", ["pointerout", "pointerover"]), o("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), o("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), o("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), o("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), o("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), o("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var xp = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mT = new Set("cancel close invalid load scroll toggle".split(" ").concat(xp));
  function Kx(d, h, b) {
    var T = d.type || "unknown-event";
    d.currentTarget = b, Pe(T, h, void 0, d), d.currentTarget = null;
  }
  function Ey(d, h) {
    h = (h & 4) !== 0;
    for (var b = 0; b < d.length; b++) {
      var T = d[b], P = T.event;
      T = T.listeners;
      e: {
        var V = void 0;
        if (h) for (var te = T.length - 1; 0 <= te; te--) {
          var me = T[te], xe = me.instance, He = me.currentTarget;
          if (me = me.listener, xe !== V && P.isPropagationStopped()) break e;
          Kx(P, me, He), V = xe;
        }
        else for (te = 0; te < T.length; te++) {
          if (me = T[te], xe = me.instance, He = me.currentTarget, me = me.listener, xe !== V && P.isPropagationStopped()) break e;
          Kx(P, me, He), V = xe;
        }
      }
    }
    if (Ae) throw d = ye, Ae = !1, ye = null, d;
  }
  function Fr(d, h) {
    var b = h[g0];
    b === void 0 && (b = h[g0] = /* @__PURE__ */ new Set());
    var T = d + "__bubble";
    b.has(T) || (Yx(h, d, 2, !1), b.add(T));
  }
  function tu(d, h, b) {
    var T = 0;
    h && (T |= 4), Yx(b, d, T, h);
  }
  var fc = "_reactListening" + Math.random().toString(36).slice(2);
  function xf(d) {
    if (!d[fc]) {
      d[fc] = !0, r.forEach(function(b) {
        b !== "selectionchange" && (mT.has(b) || tu(b, !1, d), tu(b, !0, d));
      });
      var h = d.nodeType === 9 ? d : d.ownerDocument;
      h === null || h[fc] || (h[fc] = !0, tu("selectionchange", !1, h));
    }
  }
  function Yx(d, h, b, T) {
    switch (Sr(h)) {
      case 1:
        var P = Ie;
        break;
      case 4:
        P = $e;
        break;
      default:
        P = It;
    }
    b = P.bind(null, h, b, d), P = void 0, !ji || h !== "touchstart" && h !== "touchmove" && h !== "wheel" || (P = !0), T ? P !== void 0 ? d.addEventListener(h, b, { capture: !0, passive: P }) : d.addEventListener(h, b, !0) : P !== void 0 ? d.addEventListener(h, b, { passive: P }) : d.addEventListener(h, b, !1);
  }
  function Sy(d, h, b, T, P) {
    var V = T;
    if (!(h & 1) && !(h & 2) && T !== null) e: for (; ; ) {
      if (T === null) return;
      var te = T.tag;
      if (te === 3 || te === 4) {
        var me = T.stateNode.containerInfo;
        if (me === P || me.nodeType === 8 && me.parentNode === P) break;
        if (te === 4) for (te = T.return; te !== null; ) {
          var xe = te.tag;
          if ((xe === 3 || xe === 4) && (xe = te.stateNode.containerInfo, xe === P || xe.nodeType === 8 && xe.parentNode === P)) return;
          te = te.return;
        }
        for (; me !== null; ) {
          if (te = ms(me), te === null) return;
          if (xe = te.tag, xe === 5 || xe === 6) {
            T = V = te;
            continue e;
          }
          me = me.parentNode;
        }
      }
      T = T.return;
    }
    ri(function() {
      var He = V, at = Wt(b), ut = [];
      e: {
        var rt = Wx.get(d);
        if (rt !== void 0) {
          var _t = Gn, Lt = d;
          switch (d) {
            case "keypress":
              if (We(b) === 0) break e;
            case "keydown":
            case "keyup":
              _t = aT;
              break;
            case "focusin":
              Lt = "focus", _t = Js;
              break;
            case "focusout":
              Lt = "blur", _t = Js;
              break;
            case "beforeblur":
            case "afterblur":
              _t = Js;
              break;
            case "click":
              if (b.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              _t = sc;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              _t = pp;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              _t = sT;
              break;
            case d0:
            case $x:
            case Hx:
              _t = yp;
              break;
            case qx:
              _t = Ax;
              break;
            case "scroll":
              _t = Lr;
              break;
            case "wheel":
              _t = cc;
              break;
            case "copy":
            case "cut":
            case "paste":
              _t = iT;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              _t = yy;
          }
          var Vt = (h & 4) !== 0, ki = !Vt && d === "scroll", Ne = Vt ? rt !== null ? rt + "Capture" : null : rt;
          Vt = [];
          for (var Oe = He, Ue; Oe !== null; ) {
            Ue = Oe;
            var ht = Ue.stateNode;
            if (Ue.tag === 5 && ht !== null && (Ue = ht, Ne !== null && (ht = ui(Oe, Ne), ht != null && Vt.push(Ep(Oe, ht, Ue)))), ki) break;
            Oe = Oe.return;
          }
          0 < Vt.length && (rt = new _t(rt, Lt, null, b, at), ut.push({ event: rt, listeners: Vt }));
        }
      }
      if (!(h & 7)) {
        e: {
          if (rt = d === "mouseover" || d === "pointerover", _t = d === "mouseout" || d === "pointerout", rt && b !== bn && (Lt = b.relatedTarget || b.fromElement) && (ms(Lt) || Lt[hc])) break e;
          if ((_t || rt) && (rt = at.window === at ? at : (rt = at.ownerDocument) ? rt.defaultView || rt.parentWindow : window, _t ? (Lt = b.relatedTarget || b.toElement, _t = He, Lt = Lt ? ms(Lt) : null, Lt !== null && (ki = Qe(Lt), Lt !== ki || Lt.tag !== 5 && Lt.tag !== 6) && (Lt = null)) : (_t = null, Lt = He), _t !== Lt)) {
            if (Vt = sc, ht = "onMouseLeave", Ne = "onMouseEnter", Oe = "mouse", (d === "pointerout" || d === "pointerover") && (Vt = yy, ht = "onPointerLeave", Ne = "onPointerEnter", Oe = "pointer"), ki = _t == null ? rt : Ef(_t), Ue = Lt == null ? rt : Ef(Lt), rt = new Vt(ht, Oe + "leave", _t, b, at), rt.target = ki, rt.relatedTarget = Ue, ht = null, ms(at) === He && (Vt = new Vt(Ne, Oe + "enter", Lt, b, at), Vt.target = Ue, Vt.relatedTarget = ki, ht = Vt), ki = ht, _t && Lt) t: {
              for (Vt = _t, Ne = Lt, Oe = 0, Ue = Vt; Ue; Ue = ed(Ue)) Oe++;
              for (Ue = 0, ht = Ne; ht; ht = ed(ht)) Ue++;
              for (; 0 < Oe - Ue; ) Vt = ed(Vt), Oe--;
              for (; 0 < Ue - Oe; ) Ne = ed(Ne), Ue--;
              for (; Oe--; ) {
                if (Vt === Ne || Ne !== null && Vt === Ne.alternate) break t;
                Vt = ed(Vt), Ne = ed(Ne);
              }
              Vt = null;
            }
            else Vt = null;
            _t !== null && f0(ut, rt, _t, Vt, !1), Lt !== null && ki !== null && f0(ut, ki, Lt, Vt, !0);
          }
        }
        e: {
          if (rt = He ? Ef(He) : window, _t = rt.nodeName && rt.nodeName.toLowerCase(), _t === "select" || _t === "input" && rt.type === "file") var Kt = Mx;
          else if (Ix(rt)) if (i0) Kt = Lx;
          else {
            Kt = dT;
            var mn = uT;
          }
          else (_t = rt.nodeName) && _t.toLowerCase() === "input" && (rt.type === "checkbox" || rt.type === "radio") && (Kt = fT);
          if (Kt && (Kt = Kt(d, He))) {
            Dx(ut, Kt, b, at);
            break e;
          }
          mn && mn(d, rt, He), d === "focusout" && (mn = rt._wrapperState) && mn.controlled && rt.type === "number" && or(rt, "number", rt.value);
        }
        switch (mn = He ? Ef(He) : window, d) {
          case "focusin":
            (Ix(mn) || mn.contentEditable === "true") && (el = mn, s0 = He, bp = null);
            break;
          case "focusout":
            bp = s0 = el = null;
            break;
          case "mousedown":
            l0 = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            l0 = !1, Vx(ut, b, at);
            break;
          case "selectionchange":
            if (zx) break;
          case "keydown":
          case "keyup":
            Vx(ut, b, at);
        }
        var jt;
        if (Zs) e: {
          switch (d) {
            case "compositionstart":
              var gn = "onCompositionStart";
              break e;
            case "compositionend":
              gn = "onCompositionEnd";
              break e;
            case "compositionupdate":
              gn = "onCompositionUpdate";
              break e;
          }
          gn = void 0;
        }
        else gf ? Rx(d, b) && (gn = "onCompositionEnd") : d === "keydown" && b.keyCode === 229 && (gn = "onCompositionStart");
        gn && (Tx && b.locale !== "ko" && (gf || gn !== "onCompositionStart" ? gn === "onCompositionEnd" && gf && (jt = Be()) : (Nn = at, W = "value" in Nn ? Nn.value : Nn.textContent, gf = !0)), mn = Sp(He, gn), 0 < mn.length && (gn = new Zb(gn, d, null, b, at), ut.push({ event: gn, listeners: mn }), jt ? gn.data = jt : (jt = by(b), jt !== null && (gn.data = jt)))), (jt = gy ? lT(d, b) : cT(d, b)) && (He = Sp(He, "onBeforeInput"), 0 < He.length && (at = new Zb("onBeforeInput", "beforeinput", null, b, at), ut.push({ event: at, listeners: He }), at.data = jt));
      }
      Ey(ut, h);
    });
  }
  function Ep(d, h, b) {
    return { instance: d, listener: h, currentTarget: b };
  }
  function Sp(d, h) {
    for (var b = h + "Capture", T = []; d !== null; ) {
      var P = d, V = P.stateNode;
      P.tag === 5 && V !== null && (P = V, V = ui(d, b), V != null && T.unshift(Ep(d, V, P)), V = ui(d, h), V != null && T.push(Ep(d, V, P))), d = d.return;
    }
    return T;
  }
  function ed(d) {
    if (d === null) return null;
    do
      d = d.return;
    while (d && d.tag !== 5);
    return d || null;
  }
  function f0(d, h, b, T, P) {
    for (var V = h._reactName, te = []; b !== null && b !== T; ) {
      var me = b, xe = me.alternate, He = me.stateNode;
      if (xe !== null && xe === T) break;
      me.tag === 5 && He !== null && (me = He, P ? (xe = ui(b, V), xe != null && te.unshift(Ep(b, xe, me))) : P || (xe = ui(b, V), xe != null && te.push(Ep(b, xe, me)))), b = b.return;
    }
    te.length !== 0 && d.push({ event: h, listeners: te });
  }
  var h0 = /\r\n?/g, yT = /\u0000|\uFFFD/g;
  function p0(d) {
    return (typeof d == "string" ? d : "" + d).replace(h0, `
`).replace(yT, "");
  }
  function ky(d, h, b) {
    if (h = p0(h), p0(d) !== h && b) throw Error(n(425));
  }
  function Ay() {
  }
  var m0 = null, td = null;
  function kp(d, h) {
    return d === "textarea" || d === "noscript" || typeof h.children == "string" || typeof h.children == "number" || typeof h.dangerouslySetInnerHTML == "object" && h.dangerouslySetInnerHTML !== null && h.dangerouslySetInnerHTML.__html != null;
  }
  var nd = typeof setTimeout == "function" ? setTimeout : void 0, Qx = typeof clearTimeout == "function" ? clearTimeout : void 0, y0 = typeof Promise == "function" ? Promise : void 0, v0 = typeof queueMicrotask == "function" ? queueMicrotask : typeof y0 < "u" ? function(d) {
    return y0.resolve(null).then(d).catch(vT);
  } : nd;
  function vT(d) {
    setTimeout(function() {
      throw d;
    });
  }
  function nu(d, h) {
    var b = h, T = 0;
    do {
      var P = b.nextSibling;
      if (d.removeChild(b), P && P.nodeType === 8) if (b = P.data, b === "/$") {
        if (T === 0) {
          d.removeChild(P), Qs(h);
          return;
        }
        T--;
      } else b !== "$" && b !== "$?" && b !== "$!" || T++;
      b = P;
    } while (b);
    Qs(h);
  }
  function tl(d) {
    for (; d != null; d = d.nextSibling) {
      var h = d.nodeType;
      if (h === 1 || h === 3) break;
      if (h === 8) {
        if (h = d.data, h === "$" || h === "$!" || h === "$?") break;
        if (h === "/$") return null;
      }
    }
    return d;
  }
  function Ap(d) {
    d = d.previousSibling;
    for (var h = 0; d; ) {
      if (d.nodeType === 8) {
        var b = d.data;
        if (b === "$" || b === "$!" || b === "$?") {
          if (h === 0) return d;
          h--;
        } else b === "/$" && h++;
      }
      d = d.previousSibling;
    }
    return null;
  }
  var ru = Math.random().toString(36).slice(2), gl = "__reactFiber$" + ru, rd = "__reactProps$" + ru, hc = "__reactContainer$" + ru, g0 = "__reactEvents$" + ru, gT = "__reactListeners$" + ru, b0 = "__reactHandles$" + ru;
  function ms(d) {
    var h = d[gl];
    if (h) return h;
    for (var b = d.parentNode; b; ) {
      if (h = b[hc] || b[gl]) {
        if (b = h.alternate, h.child !== null || b !== null && b.child !== null) for (d = Ap(d); d !== null; ) {
          if (b = d[gl]) return b;
          d = Ap(d);
        }
        return h;
      }
      d = b, b = d.parentNode;
    }
    return null;
  }
  function Tp(d) {
    return d = d[gl] || d[hc], !d || d.tag !== 5 && d.tag !== 6 && d.tag !== 13 && d.tag !== 3 ? null : d;
  }
  function Ef(d) {
    if (d.tag === 5 || d.tag === 6) return d.stateNode;
    throw Error(n(33));
  }
  function an(d) {
    return d[rd] || null;
  }
  var iu = [], qr = -1;
  function Bn(d) {
    return { current: d };
  }
  function wr(d) {
    0 > qr || (d.current = iu[qr], iu[qr] = null, qr--);
  }
  function kr(d, h) {
    qr++, iu[qr] = d.current, d.current = h;
  }
  var bl = {}, Sn = Bn(bl), fi = Bn(!1), da = bl;
  function ys(d, h) {
    var b = d.type.contextTypes;
    if (!b) return bl;
    var T = d.stateNode;
    if (T && T.__reactInternalMemoizedUnmaskedChildContext === h) return T.__reactInternalMemoizedMaskedChildContext;
    var P = {}, V;
    for (V in b) P[V] = h[V];
    return T && (d = d.stateNode, d.__reactInternalMemoizedUnmaskedChildContext = h, d.__reactInternalMemoizedMaskedChildContext = P), P;
  }
  function Jr(d) {
    return d = d.childContextTypes, d != null;
  }
  function vs() {
    wr(fi), wr(Sn);
  }
  function ou(d, h, b) {
    if (Sn.current !== bl) throw Error(n(168));
    kr(Sn, h), kr(fi, b);
  }
  function _p(d, h, b) {
    var T = d.stateNode;
    if (h = h.childContextTypes, typeof T.getChildContext != "function") return b;
    T = T.getChildContext();
    for (var P in T) if (!(P in h)) throw Error(n(108, st(d) || "Unknown", P));
    return be({}, b, T);
  }
  function Ty(d) {
    return d = (d = d.stateNode) && d.__reactInternalMemoizedMergedChildContext || bl, da = Sn.current, kr(Sn, d), kr(fi, fi.current), !0;
  }
  function Xx(d, h, b) {
    var T = d.stateNode;
    if (!T) throw Error(n(169));
    b ? (d = _p(d, h, da), T.__reactInternalMemoizedMergedChildContext = d, wr(fi), wr(Sn), kr(Sn, d)) : wr(fi), kr(fi, b);
  }
  var za = null, to = !1, Rp = !1;
  function w0(d) {
    za === null ? za = [d] : za.push(d);
  }
  function C0(d) {
    to = !0, w0(d);
  }
  function fa() {
    if (!Rp && za !== null) {
      Rp = !0;
      var d = 0, h = nr;
      try {
        var b = za;
        for (nr = 1; d < b.length; d++) {
          var T = b[d];
          do
            T = T(!0);
          while (T !== null);
        }
        za = null, to = !1;
      } catch (P) {
        throw za !== null && (za = za.slice(d + 1)), Qt(xr, fa), P;
      } finally {
        nr = h, Rp = !1;
      }
    }
    return null;
  }
  var au = [], ha = 0, id = null, Sf = 0, pa = [], No = 0, gs = null, mo = 1, pc = "";
  function Va(d, h) {
    au[ha++] = Sf, au[ha++] = id, id = d, Sf = h;
  }
  function x0(d, h, b) {
    pa[No++] = mo, pa[No++] = pc, pa[No++] = gs, gs = d;
    var T = mo;
    d = pc;
    var P = 32 - Zt(T) - 1;
    T &= ~(1 << P), b += 1;
    var V = 32 - Zt(h) + P;
    if (30 < V) {
      var te = P - P % 5;
      V = (T & (1 << te) - 1).toString(32), T >>= te, P -= te, mo = 1 << 32 - Zt(h) + P | b << P | T, pc = V + d;
    } else mo = 1 << V | b << P | T, pc = d;
  }
  function _y(d) {
    d.return !== null && (Va(d, 1), x0(d, 1, 0));
  }
  function E0(d) {
    for (; d === id; ) id = au[--ha], au[ha] = null, Sf = au[--ha], au[ha] = null;
    for (; d === gs; ) gs = pa[--No], pa[No] = null, pc = pa[--No], pa[No] = null, mo = pa[--No], pa[No] = null;
  }
  var $a = null, ma = null, Wr = !1, bs = null;
  function S0(d, h) {
    var b = Ts(5, null, null, 0);
    b.elementType = "DELETED", b.stateNode = h, b.return = d, h = d.deletions, h === null ? (d.deletions = [b], d.flags |= 16) : h.push(b);
  }
  function Jx(d, h) {
    switch (d.tag) {
      case 5:
        var b = d.type;
        return h = h.nodeType !== 1 || b.toLowerCase() !== h.nodeName.toLowerCase() ? null : h, h !== null ? (d.stateNode = h, $a = d, ma = tl(h.firstChild), !0) : !1;
      case 6:
        return h = d.pendingProps === "" || h.nodeType !== 3 ? null : h, h !== null ? (d.stateNode = h, $a = d, ma = null, !0) : !1;
      case 13:
        return h = h.nodeType !== 8 ? null : h, h !== null ? (b = gs !== null ? { id: mo, overflow: pc } : null, d.memoizedState = { dehydrated: h, treeContext: b, retryLane: 1073741824 }, b = Ts(18, null, null, 0), b.stateNode = h, b.return = d, d.child = b, $a = d, ma = null, !0) : !1;
      default:
        return !1;
    }
  }
  function Ry(d) {
    return (d.mode & 1) !== 0 && (d.flags & 128) === 0;
  }
  function Oy(d) {
    if (Wr) {
      var h = ma;
      if (h) {
        var b = h;
        if (!Jx(d, h)) {
          if (Ry(d)) throw Error(n(418));
          h = tl(b.nextSibling);
          var T = $a;
          h && Jx(d, h) ? S0(T, b) : (d.flags = d.flags & -4097 | 2, Wr = !1, $a = d);
        }
      } else {
        if (Ry(d)) throw Error(n(418));
        d.flags = d.flags & -4097 | 2, Wr = !1, $a = d;
      }
    }
  }
  function Zx(d) {
    for (d = d.return; d !== null && d.tag !== 5 && d.tag !== 3 && d.tag !== 13; ) d = d.return;
    $a = d;
  }
  function Iy(d) {
    if (d !== $a) return !1;
    if (!Wr) return Zx(d), Wr = !0, !1;
    var h;
    if ((h = d.tag !== 3) && !(h = d.tag !== 5) && (h = d.type, h = h !== "head" && h !== "body" && !kp(d.type, d.memoizedProps)), h && (h = ma)) {
      if (Ry(d)) throw eE(), Error(n(418));
      for (; h; ) S0(d, h), h = tl(h.nextSibling);
    }
    if (Zx(d), d.tag === 13) {
      if (d = d.memoizedState, d = d !== null ? d.dehydrated : null, !d) throw Error(n(317));
      e: {
        for (d = d.nextSibling, h = 0; d; ) {
          if (d.nodeType === 8) {
            var b = d.data;
            if (b === "/$") {
              if (h === 0) {
                ma = tl(d.nextSibling);
                break e;
              }
              h--;
            } else b !== "$" && b !== "$!" && b !== "$?" || h++;
          }
          d = d.nextSibling;
        }
        ma = null;
      }
    } else ma = $a ? tl(d.stateNode.nextSibling) : null;
    return !0;
  }
  function eE() {
    for (var d = ma; d; ) d = tl(d.nextSibling);
  }
  function oi() {
    ma = $a = null, Wr = !1;
  }
  function k0(d) {
    bs === null ? bs = [d] : bs.push(d);
  }
  var Dy = M.ReactCurrentBatchConfig;
  function od(d, h, b) {
    if (d = b.ref, d !== null && typeof d != "function" && typeof d != "object") {
      if (b._owner) {
        if (b = b._owner, b) {
          if (b.tag !== 1) throw Error(n(309));
          var T = b.stateNode;
        }
        if (!T) throw Error(n(147, d));
        var P = T, V = "" + d;
        return h !== null && h.ref !== null && typeof h.ref == "function" && h.ref._stringRef === V ? h.ref : (h = function(te) {
          var me = P.refs;
          te === null ? delete me[V] : me[V] = te;
        }, h._stringRef = V, h);
      }
      if (typeof d != "string") throw Error(n(284));
      if (!b._owner) throw Error(n(290, d));
    }
    return d;
  }
  function wl(d, h) {
    throw d = Object.prototype.toString.call(h), Error(n(31, d === "[object Object]" ? "object with keys {" + Object.keys(h).join(", ") + "}" : d));
  }
  function tE(d) {
    var h = d._init;
    return h(d._payload);
  }
  function My(d) {
    function h(Ne, Oe) {
      if (d) {
        var Ue = Ne.deletions;
        Ue === null ? (Ne.deletions = [Oe], Ne.flags |= 16) : Ue.push(Oe);
      }
    }
    function b(Ne, Oe) {
      if (!d) return null;
      for (; Oe !== null; ) h(Ne, Oe), Oe = Oe.sibling;
      return null;
    }
    function T(Ne, Oe) {
      for (Ne = /* @__PURE__ */ new Map(); Oe !== null; ) Oe.key !== null ? Ne.set(Oe.key, Oe) : Ne.set(Oe.index, Oe), Oe = Oe.sibling;
      return Ne;
    }
    function P(Ne, Oe) {
      return Ne = pu(Ne, Oe), Ne.index = 0, Ne.sibling = null, Ne;
    }
    function V(Ne, Oe, Ue) {
      return Ne.index = Ue, d ? (Ue = Ne.alternate, Ue !== null ? (Ue = Ue.index, Ue < Oe ? (Ne.flags |= 2, Oe) : Ue) : (Ne.flags |= 2, Oe)) : (Ne.flags |= 1048576, Oe);
    }
    function te(Ne) {
      return d && Ne.alternate === null && (Ne.flags |= 2), Ne;
    }
    function me(Ne, Oe, Ue, ht) {
      return Oe === null || Oe.tag !== 6 ? (Oe = wv(Ue, Ne.mode, ht), Oe.return = Ne, Oe) : (Oe = P(Oe, Ue), Oe.return = Ne, Oe);
    }
    function xe(Ne, Oe, Ue, ht) {
      var Kt = Ue.type;
      return Kt === F ? at(Ne, Oe, Ue.props.children, ht, Ue.key) : Oe !== null && (Oe.elementType === Kt || typeof Kt == "object" && Kt !== null && Kt.$$typeof === Z && tE(Kt) === Oe.type) ? (ht = P(Oe, Ue.props), ht.ref = od(Ne, Oe, Ue), ht.return = Ne, ht) : (ht = gv(Ue.type, Ue.key, Ue.props, null, Ne.mode, ht), ht.ref = od(Ne, Oe, Ue), ht.return = Ne, ht);
    }
    function He(Ne, Oe, Ue, ht) {
      return Oe === null || Oe.tag !== 4 || Oe.stateNode.containerInfo !== Ue.containerInfo || Oe.stateNode.implementation !== Ue.implementation ? (Oe = Gp(Ue, Ne.mode, ht), Oe.return = Ne, Oe) : (Oe = P(Oe, Ue.children || []), Oe.return = Ne, Oe);
    }
    function at(Ne, Oe, Ue, ht, Kt) {
      return Oe === null || Oe.tag !== 7 ? (Oe = wd(Ue, Ne.mode, ht, Kt), Oe.return = Ne, Oe) : (Oe = P(Oe, Ue), Oe.return = Ne, Oe);
    }
    function ut(Ne, Oe, Ue) {
      if (typeof Oe == "string" && Oe !== "" || typeof Oe == "number") return Oe = wv("" + Oe, Ne.mode, Ue), Oe.return = Ne, Oe;
      if (typeof Oe == "object" && Oe !== null) {
        switch (Oe.$$typeof) {
          case L:
            return Ue = gv(Oe.type, Oe.key, Oe.props, null, Ne.mode, Ue), Ue.ref = od(Ne, null, Oe), Ue.return = Ne, Ue;
          case j:
            return Oe = Gp(Oe, Ne.mode, Ue), Oe.return = Ne, Oe;
          case Z:
            var ht = Oe._init;
            return ut(Ne, ht(Oe._payload), Ue);
        }
        if (ar(Oe) || oe(Oe)) return Oe = wd(Oe, Ne.mode, Ue, null), Oe.return = Ne, Oe;
        wl(Ne, Oe);
      }
      return null;
    }
    function rt(Ne, Oe, Ue, ht) {
      var Kt = Oe !== null ? Oe.key : null;
      if (typeof Ue == "string" && Ue !== "" || typeof Ue == "number") return Kt !== null ? null : me(Ne, Oe, "" + Ue, ht);
      if (typeof Ue == "object" && Ue !== null) {
        switch (Ue.$$typeof) {
          case L:
            return Ue.key === Kt ? xe(Ne, Oe, Ue, ht) : null;
          case j:
            return Ue.key === Kt ? He(Ne, Oe, Ue, ht) : null;
          case Z:
            return Kt = Ue._init, rt(
              Ne,
              Oe,
              Kt(Ue._payload),
              ht
            );
        }
        if (ar(Ue) || oe(Ue)) return Kt !== null ? null : at(Ne, Oe, Ue, ht, null);
        wl(Ne, Ue);
      }
      return null;
    }
    function _t(Ne, Oe, Ue, ht, Kt) {
      if (typeof ht == "string" && ht !== "" || typeof ht == "number") return Ne = Ne.get(Ue) || null, me(Oe, Ne, "" + ht, Kt);
      if (typeof ht == "object" && ht !== null) {
        switch (ht.$$typeof) {
          case L:
            return Ne = Ne.get(ht.key === null ? Ue : ht.key) || null, xe(Oe, Ne, ht, Kt);
          case j:
            return Ne = Ne.get(ht.key === null ? Ue : ht.key) || null, He(Oe, Ne, ht, Kt);
          case Z:
            var mn = ht._init;
            return _t(Ne, Oe, Ue, mn(ht._payload), Kt);
        }
        if (ar(ht) || oe(ht)) return Ne = Ne.get(Ue) || null, at(Oe, Ne, ht, Kt, null);
        wl(Oe, ht);
      }
      return null;
    }
    function Lt(Ne, Oe, Ue, ht) {
      for (var Kt = null, mn = null, jt = Oe, gn = Oe = 0, Hi = null; jt !== null && gn < Ue.length; gn++) {
        jt.index > gn ? (Hi = jt, jt = null) : Hi = jt.sibling;
        var mr = rt(Ne, jt, Ue[gn], ht);
        if (mr === null) {
          jt === null && (jt = Hi);
          break;
        }
        d && jt && mr.alternate === null && h(Ne, jt), Oe = V(mr, Oe, gn), mn === null ? Kt = mr : mn.sibling = mr, mn = mr, jt = Hi;
      }
      if (gn === Ue.length) return b(Ne, jt), Wr && Va(Ne, gn), Kt;
      if (jt === null) {
        for (; gn < Ue.length; gn++) jt = ut(Ne, Ue[gn], ht), jt !== null && (Oe = V(jt, Oe, gn), mn === null ? Kt = jt : mn.sibling = jt, mn = jt);
        return Wr && Va(Ne, gn), Kt;
      }
      for (jt = T(Ne, jt); gn < Ue.length; gn++) Hi = _t(jt, Ne, gn, Ue[gn], ht), Hi !== null && (d && Hi.alternate !== null && jt.delete(Hi.key === null ? gn : Hi.key), Oe = V(Hi, Oe, gn), mn === null ? Kt = Hi : mn.sibling = Hi, mn = Hi);
      return d && jt.forEach(function(Cc) {
        return h(Ne, Cc);
      }), Wr && Va(Ne, gn), Kt;
    }
    function Vt(Ne, Oe, Ue, ht) {
      var Kt = oe(Ue);
      if (typeof Kt != "function") throw Error(n(150));
      if (Ue = Kt.call(Ue), Ue == null) throw Error(n(151));
      for (var mn = Kt = null, jt = Oe, gn = Oe = 0, Hi = null, mr = Ue.next(); jt !== null && !mr.done; gn++, mr = Ue.next()) {
        jt.index > gn ? (Hi = jt, jt = null) : Hi = jt.sibling;
        var Cc = rt(Ne, jt, mr.value, ht);
        if (Cc === null) {
          jt === null && (jt = Hi);
          break;
        }
        d && jt && Cc.alternate === null && h(Ne, jt), Oe = V(Cc, Oe, gn), mn === null ? Kt = Cc : mn.sibling = Cc, mn = Cc, jt = Hi;
      }
      if (mr.done) return b(
        Ne,
        jt
      ), Wr && Va(Ne, gn), Kt;
      if (jt === null) {
        for (; !mr.done; gn++, mr = Ue.next()) mr = ut(Ne, mr.value, ht), mr !== null && (Oe = V(mr, Oe, gn), mn === null ? Kt = mr : mn.sibling = mr, mn = mr);
        return Wr && Va(Ne, gn), Kt;
      }
      for (jt = T(Ne, jt); !mr.done; gn++, mr = Ue.next()) mr = _t(jt, Ne, gn, mr.value, ht), mr !== null && (d && mr.alternate !== null && jt.delete(mr.key === null ? gn : mr.key), Oe = V(mr, Oe, gn), mn === null ? Kt = mr : mn.sibling = mr, mn = mr);
      return d && jt.forEach(function(BT) {
        return h(Ne, BT);
      }), Wr && Va(Ne, gn), Kt;
    }
    function ki(Ne, Oe, Ue, ht) {
      if (typeof Ue == "object" && Ue !== null && Ue.type === F && Ue.key === null && (Ue = Ue.props.children), typeof Ue == "object" && Ue !== null) {
        switch (Ue.$$typeof) {
          case L:
            e: {
              for (var Kt = Ue.key, mn = Oe; mn !== null; ) {
                if (mn.key === Kt) {
                  if (Kt = Ue.type, Kt === F) {
                    if (mn.tag === 7) {
                      b(Ne, mn.sibling), Oe = P(mn, Ue.props.children), Oe.return = Ne, Ne = Oe;
                      break e;
                    }
                  } else if (mn.elementType === Kt || typeof Kt == "object" && Kt !== null && Kt.$$typeof === Z && tE(Kt) === mn.type) {
                    b(Ne, mn.sibling), Oe = P(mn, Ue.props), Oe.ref = od(Ne, mn, Ue), Oe.return = Ne, Ne = Oe;
                    break e;
                  }
                  b(Ne, mn);
                  break;
                } else h(Ne, mn);
                mn = mn.sibling;
              }
              Ue.type === F ? (Oe = wd(Ue.props.children, Ne.mode, ht, Ue.key), Oe.return = Ne, Ne = Oe) : (ht = gv(Ue.type, Ue.key, Ue.props, null, Ne.mode, ht), ht.ref = od(Ne, Oe, Ue), ht.return = Ne, Ne = ht);
            }
            return te(Ne);
          case j:
            e: {
              for (mn = Ue.key; Oe !== null; ) {
                if (Oe.key === mn) if (Oe.tag === 4 && Oe.stateNode.containerInfo === Ue.containerInfo && Oe.stateNode.implementation === Ue.implementation) {
                  b(Ne, Oe.sibling), Oe = P(Oe, Ue.children || []), Oe.return = Ne, Ne = Oe;
                  break e;
                } else {
                  b(Ne, Oe);
                  break;
                }
                else h(Ne, Oe);
                Oe = Oe.sibling;
              }
              Oe = Gp(Ue, Ne.mode, ht), Oe.return = Ne, Ne = Oe;
            }
            return te(Ne);
          case Z:
            return mn = Ue._init, ki(Ne, Oe, mn(Ue._payload), ht);
        }
        if (ar(Ue)) return Lt(Ne, Oe, Ue, ht);
        if (oe(Ue)) return Vt(Ne, Oe, Ue, ht);
        wl(Ne, Ue);
      }
      return typeof Ue == "string" && Ue !== "" || typeof Ue == "number" ? (Ue = "" + Ue, Oe !== null && Oe.tag === 6 ? (b(Ne, Oe.sibling), Oe = P(Oe, Ue), Oe.return = Ne, Ne = Oe) : (b(Ne, Oe), Oe = wv(Ue, Ne.mode, ht), Oe.return = Ne, Ne = Oe), te(Ne)) : b(Ne, Oe);
    }
    return ki;
  }
  var kf = My(!0), nE = My(!1), mc = Bn(null), Ui = null, bt = null, ws = null;
  function Ha() {
    ws = bt = Ui = null;
  }
  function A0(d) {
    var h = mc.current;
    wr(mc), d._currentValue = h;
  }
  function T0(d, h, b) {
    for (; d !== null; ) {
      var T = d.alternate;
      if ((d.childLanes & h) !== h ? (d.childLanes |= h, T !== null && (T.childLanes |= h)) : T !== null && (T.childLanes & h) !== h && (T.childLanes |= h), d === b) break;
      d = d.return;
    }
  }
  function Af(d, h) {
    Ui = d, ws = bt = null, d = d.dependencies, d !== null && d.firstContext !== null && (d.lanes & h && (ga = !0), d.firstContext = null);
  }
  function Cs(d) {
    var h = d._currentValue;
    if (ws !== d) if (d = { context: d, memoizedValue: h, next: null }, bt === null) {
      if (Ui === null) throw Error(n(308));
      bt = d, Ui.dependencies = { lanes: 0, firstContext: d };
    } else bt = bt.next = d;
    return h;
  }
  var ad = null;
  function Oi(d) {
    ad === null ? ad = [d] : ad.push(d);
  }
  function rE(d, h, b, T) {
    var P = h.interleaved;
    return P === null ? (b.next = b, Oi(h)) : (b.next = P.next, P.next = b), h.interleaved = b, yc(d, T);
  }
  function yc(d, h) {
    d.lanes |= h;
    var b = d.alternate;
    for (b !== null && (b.lanes |= h), b = d, d = d.return; d !== null; ) d.childLanes |= h, b = d.alternate, b !== null && (b.childLanes |= h), b = d, d = d.return;
    return b.tag === 3 ? b.stateNode : null;
  }
  var su = !1;
  function Py(d) {
    d.updateQueue = { baseState: d.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function Tf(d, h) {
    d = d.updateQueue, h.updateQueue === d && (h.updateQueue = { baseState: d.baseState, firstBaseUpdate: d.firstBaseUpdate, lastBaseUpdate: d.lastBaseUpdate, shared: d.shared, effects: d.effects });
  }
  function ya(d, h) {
    return { eventTime: d, lane: h, tag: 0, payload: null, callback: null, next: null };
  }
  function lu(d, h, b) {
    var T = d.updateQueue;
    if (T === null) return null;
    if (T = T.shared, Xn & 2) {
      var P = T.pending;
      return P === null ? h.next = h : (h.next = P.next, P.next = h), T.pending = h, yc(d, b);
    }
    return P = T.interleaved, P === null ? (h.next = h, Oi(T)) : (h.next = P.next, P.next = h), T.interleaved = h, yc(d, b);
  }
  function Ny(d, h, b) {
    if (h = h.updateQueue, h !== null && (h = h.shared, (b & 4194240) !== 0)) {
      var T = h.lanes;
      T &= d.pendingLanes, b |= T, h.lanes = b, ds(d, b);
    }
  }
  function iE(d, h) {
    var b = d.updateQueue, T = d.alternate;
    if (T !== null && (T = T.updateQueue, b === T)) {
      var P = null, V = null;
      if (b = b.firstBaseUpdate, b !== null) {
        do {
          var te = { eventTime: b.eventTime, lane: b.lane, tag: b.tag, payload: b.payload, callback: b.callback, next: null };
          V === null ? P = V = te : V = V.next = te, b = b.next;
        } while (b !== null);
        V === null ? P = V = h : V = V.next = h;
      } else P = V = h;
      b = { baseState: T.baseState, firstBaseUpdate: P, lastBaseUpdate: V, shared: T.shared, effects: T.effects }, d.updateQueue = b;
      return;
    }
    d = b.lastBaseUpdate, d === null ? b.firstBaseUpdate = h : d.next = h, b.lastBaseUpdate = h;
  }
  function By(d, h, b, T) {
    var P = d.updateQueue;
    su = !1;
    var V = P.firstBaseUpdate, te = P.lastBaseUpdate, me = P.shared.pending;
    if (me !== null) {
      P.shared.pending = null;
      var xe = me, He = xe.next;
      xe.next = null, te === null ? V = He : te.next = He, te = xe;
      var at = d.alternate;
      at !== null && (at = at.updateQueue, me = at.lastBaseUpdate, me !== te && (me === null ? at.firstBaseUpdate = He : me.next = He, at.lastBaseUpdate = xe));
    }
    if (V !== null) {
      var ut = P.baseState;
      te = 0, at = He = xe = null, me = V;
      do {
        var rt = me.lane, _t = me.eventTime;
        if ((T & rt) === rt) {
          at !== null && (at = at.next = {
            eventTime: _t,
            lane: 0,
            tag: me.tag,
            payload: me.payload,
            callback: me.callback,
            next: null
          });
          e: {
            var Lt = d, Vt = me;
            switch (rt = h, _t = b, Vt.tag) {
              case 1:
                if (Lt = Vt.payload, typeof Lt == "function") {
                  ut = Lt.call(_t, ut, rt);
                  break e;
                }
                ut = Lt;
                break e;
              case 3:
                Lt.flags = Lt.flags & -65537 | 128;
              case 0:
                if (Lt = Vt.payload, rt = typeof Lt == "function" ? Lt.call(_t, ut, rt) : Lt, rt == null) break e;
                ut = be({}, ut, rt);
                break e;
              case 2:
                su = !0;
            }
          }
          me.callback !== null && me.lane !== 0 && (d.flags |= 64, rt = P.effects, rt === null ? P.effects = [me] : rt.push(me));
        } else _t = { eventTime: _t, lane: rt, tag: me.tag, payload: me.payload, callback: me.callback, next: null }, at === null ? (He = at = _t, xe = ut) : at = at.next = _t, te |= rt;
        if (me = me.next, me === null) {
          if (me = P.shared.pending, me === null) break;
          rt = me, me = rt.next, rt.next = null, P.lastBaseUpdate = rt, P.shared.pending = null;
        }
      } while (!0);
      if (at === null && (xe = ut), P.baseState = xe, P.firstBaseUpdate = He, P.lastBaseUpdate = at, h = P.shared.interleaved, h !== null) {
        P = h;
        do
          te |= P.lane, P = P.next;
        while (P !== h);
      } else V === null && (P.shared.lanes = 0);
      yd |= te, d.lanes = te, d.memoizedState = ut;
    }
  }
  function oE(d, h, b) {
    if (d = h.effects, h.effects = null, d !== null) for (h = 0; h < d.length; h++) {
      var T = d[h], P = T.callback;
      if (P !== null) {
        if (T.callback = null, T = b, typeof P != "function") throw Error(n(191, P));
        P.call(T);
      }
    }
  }
  var Op = {}, nl = Bn(Op), _f = Bn(Op), Ip = Bn(Op);
  function sd(d) {
    if (d === Op) throw Error(n(174));
    return d;
  }
  function _0(d, h) {
    switch (kr(Ip, h), kr(_f, d), kr(nl, Op), d = h.nodeType, d) {
      case 9:
      case 11:
        h = (h = h.documentElement) ? h.namespaceURI : gt(null, "");
        break;
      default:
        d = d === 8 ? h.parentNode : h, h = d.namespaceURI || null, d = d.tagName, h = gt(h, d);
    }
    wr(nl), kr(nl, h);
  }
  function Rf() {
    wr(nl), wr(_f), wr(Ip);
  }
  function aE(d) {
    sd(Ip.current);
    var h = sd(nl.current), b = gt(h, d.type);
    h !== b && (kr(_f, d), kr(nl, b));
  }
  function R0(d) {
    _f.current === d && (wr(nl), wr(_f));
  }
  var Zr = Bn(0);
  function Ly(d) {
    for (var h = d; h !== null; ) {
      if (h.tag === 13) {
        var b = h.memoizedState;
        if (b !== null && (b = b.dehydrated, b === null || b.data === "$?" || b.data === "$!")) return h;
      } else if (h.tag === 19 && h.memoizedProps.revealOrder !== void 0) {
        if (h.flags & 128) return h;
      } else if (h.child !== null) {
        h.child.return = h, h = h.child;
        continue;
      }
      if (h === d) break;
      for (; h.sibling === null; ) {
        if (h.return === null || h.return === d) return null;
        h = h.return;
      }
      h.sibling.return = h.return, h = h.sibling;
    }
    return null;
  }
  var jy = [];
  function O0() {
    for (var d = 0; d < jy.length; d++) jy[d]._workInProgressVersionPrimary = null;
    jy.length = 0;
  }
  var Fy = M.ReactCurrentDispatcher, Dp = M.ReactCurrentBatchConfig, Gt = 0, Xt = null, kn = null, Kn = null, qa = !1, Of = !1, Mp = 0, bT = 0;
  function Bo() {
    throw Error(n(321));
  }
  function Pp(d, h) {
    if (h === null) return !1;
    for (var b = 0; b < h.length && b < d.length; b++) if (!ps(d[b], h[b])) return !1;
    return !0;
  }
  function nt(d, h, b, T, P, V) {
    if (Gt = V, Xt = h, h.memoizedState = null, h.updateQueue = null, h.lanes = 0, Fy.current = d === null || d.memoizedState === null ? wT : Vr, d = b(T, P), Of) {
      V = 0;
      do {
        if (Of = !1, Mp = 0, 25 <= V) throw Error(n(301));
        V += 1, Kn = kn = null, h.updateQueue = null, Fy.current = ev, d = b(T, P);
      } while (Of);
    }
    if (Fy.current = Lo, h = kn !== null && kn.next !== null, Gt = 0, Kn = kn = Xt = null, qa = !1, h) throw Error(n(300));
    return d;
  }
  function Ii() {
    var d = Mp !== 0;
    return Mp = 0, d;
  }
  function nn() {
    var d = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return Kn === null ? Xt.memoizedState = Kn = d : Kn = Kn.next = d, Kn;
  }
  function yo() {
    if (kn === null) {
      var d = Xt.alternate;
      d = d !== null ? d.memoizedState : null;
    } else d = kn.next;
    var h = Kn === null ? Xt.memoizedState : Kn.next;
    if (h !== null) Kn = h, kn = d;
    else {
      if (d === null) throw Error(n(310));
      kn = d, d = { memoizedState: kn.memoizedState, baseState: kn.baseState, baseQueue: kn.baseQueue, queue: kn.queue, next: null }, Kn === null ? Xt.memoizedState = Kn = d : Kn = Kn.next = d;
    }
    return Kn;
  }
  function Wa(d, h) {
    return typeof h == "function" ? h(d) : h;
  }
  function vc(d) {
    var h = yo(), b = h.queue;
    if (b === null) throw Error(n(311));
    b.lastRenderedReducer = d;
    var T = kn, P = T.baseQueue, V = b.pending;
    if (V !== null) {
      if (P !== null) {
        var te = P.next;
        P.next = V.next, V.next = te;
      }
      T.baseQueue = P = V, b.pending = null;
    }
    if (P !== null) {
      V = P.next, T = T.baseState;
      var me = te = null, xe = null, He = V;
      do {
        var at = He.lane;
        if ((Gt & at) === at) xe !== null && (xe = xe.next = { lane: 0, action: He.action, hasEagerState: He.hasEagerState, eagerState: He.eagerState, next: null }), T = He.hasEagerState ? He.eagerState : d(T, He.action);
        else {
          var ut = {
            lane: at,
            action: He.action,
            hasEagerState: He.hasEagerState,
            eagerState: He.eagerState,
            next: null
          };
          xe === null ? (me = xe = ut, te = T) : xe = xe.next = ut, Xt.lanes |= at, yd |= at;
        }
        He = He.next;
      } while (He !== null && He !== V);
      xe === null ? te = T : xe.next = me, ps(T, h.memoizedState) || (ga = !0), h.memoizedState = T, h.baseState = te, h.baseQueue = xe, b.lastRenderedState = T;
    }
    if (d = b.interleaved, d !== null) {
      P = d;
      do
        V = P.lane, Xt.lanes |= V, yd |= V, P = P.next;
      while (P !== d);
    } else P === null && (b.lanes = 0);
    return [h.memoizedState, b.dispatch];
  }
  function xs(d) {
    var h = yo(), b = h.queue;
    if (b === null) throw Error(n(311));
    b.lastRenderedReducer = d;
    var T = b.dispatch, P = b.pending, V = h.memoizedState;
    if (P !== null) {
      b.pending = null;
      var te = P = P.next;
      do
        V = d(V, te.action), te = te.next;
      while (te !== P);
      ps(V, h.memoizedState) || (ga = !0), h.memoizedState = V, h.baseQueue === null && (h.baseState = V), b.lastRenderedState = V;
    }
    return [V, T];
  }
  function If() {
  }
  function ld(d, h) {
    var b = Xt, T = yo(), P = h(), V = !ps(T.memoizedState, P);
    if (V && (T.memoizedState = P, ga = !0), T = T.queue, Np(zy.bind(null, b, T, d), [d]), T.getSnapshot !== h || V || Kn !== null && Kn.memoizedState.tag & 1) {
      if (b.flags |= 2048, cd(9, Uy.bind(null, b, T, P, h), void 0, null), pi === null) throw Error(n(349));
      Gt & 30 || Df(b, h, P);
    }
    return P;
  }
  function Df(d, h, b) {
    d.flags |= 16384, d = { getSnapshot: h, value: b }, h = Xt.updateQueue, h === null ? (h = { lastEffect: null, stores: null }, Xt.updateQueue = h, h.stores = [d]) : (b = h.stores, b === null ? h.stores = [d] : b.push(d));
  }
  function Uy(d, h, b, T) {
    h.value = b, h.getSnapshot = T, Vy(h) && $y(d);
  }
  function zy(d, h, b) {
    return b(function() {
      Vy(h) && $y(d);
    });
  }
  function Vy(d) {
    var h = d.getSnapshot;
    d = d.value;
    try {
      var b = h();
      return !ps(d, b);
    } catch {
      return !0;
    }
  }
  function $y(d) {
    var h = yc(d, 1);
    h !== null && ai(h, d, 1, -1);
  }
  function Hy(d) {
    var h = nn();
    return typeof d == "function" && (d = d()), h.memoizedState = h.baseState = d, d = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Wa, lastRenderedState: d }, h.queue = d, d = d.dispatch = Bp.bind(null, Xt, d), [h.memoizedState, d];
  }
  function cd(d, h, b, T) {
    return d = { tag: d, create: h, destroy: b, deps: T, next: null }, h = Xt.updateQueue, h === null ? (h = { lastEffect: null, stores: null }, Xt.updateQueue = h, h.lastEffect = d.next = d) : (b = h.lastEffect, b === null ? h.lastEffect = d.next = d : (T = b.next, b.next = d, d.next = T, h.lastEffect = d)), d;
  }
  function qy() {
    return yo().memoizedState;
  }
  function Mf(d, h, b, T) {
    var P = nn();
    Xt.flags |= d, P.memoizedState = cd(1 | h, b, void 0, T === void 0 ? null : T);
  }
  function Pf(d, h, b, T) {
    var P = yo();
    T = T === void 0 ? null : T;
    var V = void 0;
    if (kn !== null) {
      var te = kn.memoizedState;
      if (V = te.destroy, T !== null && Pp(T, te.deps)) {
        P.memoizedState = cd(h, b, V, T);
        return;
      }
    }
    Xt.flags |= d, P.memoizedState = cd(1 | h, b, V, T);
  }
  function Wy(d, h) {
    return Mf(8390656, 8, d, h);
  }
  function Np(d, h) {
    return Pf(2048, 8, d, h);
  }
  function Gy(d, h) {
    return Pf(4, 2, d, h);
  }
  function Ky(d, h) {
    return Pf(4, 4, d, h);
  }
  function Yy(d, h) {
    if (typeof h == "function") return d = d(), h(d), function() {
      h(null);
    };
    if (h != null) return d = d(), h.current = d, function() {
      h.current = null;
    };
  }
  function Qy(d, h, b) {
    return b = b != null ? b.concat([d]) : null, Pf(4, 4, Yy.bind(null, h, d), b);
  }
  function Nf() {
  }
  function ud(d, h) {
    var b = yo();
    h = h === void 0 ? null : h;
    var T = b.memoizedState;
    return T !== null && h !== null && Pp(h, T[1]) ? T[0] : (b.memoizedState = [d, h], d);
  }
  function Xy(d, h) {
    var b = yo();
    h = h === void 0 ? null : h;
    var T = b.memoizedState;
    return T !== null && h !== null && Pp(h, T[1]) ? T[0] : (d = d(), b.memoizedState = [d, h], d);
  }
  function Jy(d, h, b) {
    return Gt & 21 ? (ps(b, h) || (b = Qc(), Xt.lanes |= b, yd |= b, d.baseState = !0), h) : (d.baseState && (d.baseState = !1, ga = !0), d.memoizedState = b);
  }
  function I0(d, h) {
    var b = nr;
    nr = b !== 0 && 4 > b ? b : 4, d(!0);
    var T = Dp.transition;
    Dp.transition = {};
    try {
      d(!1), h();
    } finally {
      nr = b, Dp.transition = T;
    }
  }
  function Zy() {
    return yo().memoizedState;
  }
  function sE(d, h, b) {
    var T = wc(d);
    if (b = { lane: T, action: b, hasEagerState: !1, eagerState: null, next: null }, D0(d)) Bf(h, b);
    else if (b = rE(d, h, b, T), b !== null) {
      var P = io();
      ai(b, d, T, P), cu(b, h, T);
    }
  }
  function Bp(d, h, b) {
    var T = wc(d), P = { lane: T, action: b, hasEagerState: !1, eagerState: null, next: null };
    if (D0(d)) Bf(h, P);
    else {
      var V = d.alternate;
      if (d.lanes === 0 && (V === null || V.lanes === 0) && (V = h.lastRenderedReducer, V !== null)) try {
        var te = h.lastRenderedState, me = V(te, b);
        if (P.hasEagerState = !0, P.eagerState = me, ps(me, te)) {
          var xe = h.interleaved;
          xe === null ? (P.next = P, Oi(h)) : (P.next = xe.next, xe.next = P), h.interleaved = P;
          return;
        }
      } catch {
      } finally {
      }
      b = rE(d, h, P, T), b !== null && (P = io(), ai(b, d, T, P), cu(b, h, T));
    }
  }
  function D0(d) {
    var h = d.alternate;
    return d === Xt || h !== null && h === Xt;
  }
  function Bf(d, h) {
    Of = qa = !0;
    var b = d.pending;
    b === null ? h.next = h : (h.next = b.next, b.next = h), d.pending = h;
  }
  function cu(d, h, b) {
    if (b & 4194240) {
      var T = h.lanes;
      T &= d.pendingLanes, b |= T, h.lanes = b, ds(d, b);
    }
  }
  var Lo = { readContext: Cs, useCallback: Bo, useContext: Bo, useEffect: Bo, useImperativeHandle: Bo, useInsertionEffect: Bo, useLayoutEffect: Bo, useMemo: Bo, useReducer: Bo, useRef: Bo, useState: Bo, useDebugValue: Bo, useDeferredValue: Bo, useTransition: Bo, useMutableSource: Bo, useSyncExternalStore: Bo, useId: Bo, unstable_isNewReconciler: !1 }, wT = { readContext: Cs, useCallback: function(d, h) {
    return nn().memoizedState = [d, h === void 0 ? null : h], d;
  }, useContext: Cs, useEffect: Wy, useImperativeHandle: function(d, h, b) {
    return b = b != null ? b.concat([d]) : null, Mf(
      4194308,
      4,
      Yy.bind(null, h, d),
      b
    );
  }, useLayoutEffect: function(d, h) {
    return Mf(4194308, 4, d, h);
  }, useInsertionEffect: function(d, h) {
    return Mf(4, 2, d, h);
  }, useMemo: function(d, h) {
    var b = nn();
    return h = h === void 0 ? null : h, d = d(), b.memoizedState = [d, h], d;
  }, useReducer: function(d, h, b) {
    var T = nn();
    return h = b !== void 0 ? b(h) : h, T.memoizedState = T.baseState = h, d = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: d, lastRenderedState: h }, T.queue = d, d = d.dispatch = sE.bind(null, Xt, d), [T.memoizedState, d];
  }, useRef: function(d) {
    var h = nn();
    return d = { current: d }, h.memoizedState = d;
  }, useState: Hy, useDebugValue: Nf, useDeferredValue: function(d) {
    return nn().memoizedState = d;
  }, useTransition: function() {
    var d = Hy(!1), h = d[0];
    return d = I0.bind(null, d[1]), nn().memoizedState = d, [h, d];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(d, h, b) {
    var T = Xt, P = nn();
    if (Wr) {
      if (b === void 0) throw Error(n(407));
      b = b();
    } else {
      if (b = h(), pi === null) throw Error(n(349));
      Gt & 30 || Df(T, h, b);
    }
    P.memoizedState = b;
    var V = { value: b, getSnapshot: h };
    return P.queue = V, Wy(zy.bind(
      null,
      T,
      V,
      d
    ), [d]), T.flags |= 2048, cd(9, Uy.bind(null, T, V, b, h), void 0, null), b;
  }, useId: function() {
    var d = nn(), h = pi.identifierPrefix;
    if (Wr) {
      var b = pc, T = mo;
      b = (T & ~(1 << 32 - Zt(T) - 1)).toString(32) + b, h = ":" + h + "R" + b, b = Mp++, 0 < b && (h += "H" + b.toString(32)), h += ":";
    } else b = bT++, h = ":" + h + "r" + b.toString(32) + ":";
    return d.memoizedState = h;
  }, unstable_isNewReconciler: !1 }, Vr = {
    readContext: Cs,
    useCallback: ud,
    useContext: Cs,
    useEffect: Np,
    useImperativeHandle: Qy,
    useInsertionEffect: Gy,
    useLayoutEffect: Ky,
    useMemo: Xy,
    useReducer: vc,
    useRef: qy,
    useState: function() {
      return vc(Wa);
    },
    useDebugValue: Nf,
    useDeferredValue: function(d) {
      var h = yo();
      return Jy(h, kn.memoizedState, d);
    },
    useTransition: function() {
      var d = vc(Wa)[0], h = yo().memoizedState;
      return [d, h];
    },
    useMutableSource: If,
    useSyncExternalStore: ld,
    useId: Zy,
    unstable_isNewReconciler: !1
  }, ev = { readContext: Cs, useCallback: ud, useContext: Cs, useEffect: Np, useImperativeHandle: Qy, useInsertionEffect: Gy, useLayoutEffect: Ky, useMemo: Xy, useReducer: xs, useRef: qy, useState: function() {
    return xs(Wa);
  }, useDebugValue: Nf, useDeferredValue: function(d) {
    var h = yo();
    return kn === null ? h.memoizedState = d : Jy(h, kn.memoizedState, d);
  }, useTransition: function() {
    var d = xs(Wa)[0], h = yo().memoizedState;
    return [d, h];
  }, useMutableSource: If, useSyncExternalStore: ld, useId: Zy, unstable_isNewReconciler: !1 };
  function va(d, h) {
    if (d && d.defaultProps) {
      h = be({}, h), d = d.defaultProps;
      for (var b in d) h[b] === void 0 && (h[b] = d[b]);
      return h;
    }
    return h;
  }
  function dd(d, h, b, T) {
    h = d.memoizedState, b = b(T, h), b = b == null ? h : be({}, h, b), d.memoizedState = b, d.lanes === 0 && (d.updateQueue.baseState = b);
  }
  var fd = { isMounted: function(d) {
    return (d = d._reactInternals) ? Qe(d) === d : !1;
  }, enqueueSetState: function(d, h, b) {
    d = d._reactInternals;
    var T = io(), P = wc(d), V = ya(T, P);
    V.payload = h, b != null && (V.callback = b), h = lu(d, V, P), h !== null && (ai(h, d, P, T), Ny(h, d, P));
  }, enqueueReplaceState: function(d, h, b) {
    d = d._reactInternals;
    var T = io(), P = wc(d), V = ya(T, P);
    V.tag = 1, V.payload = h, b != null && (V.callback = b), h = lu(d, V, P), h !== null && (ai(h, d, P, T), Ny(h, d, P));
  }, enqueueForceUpdate: function(d, h) {
    d = d._reactInternals;
    var b = io(), T = wc(d), P = ya(b, T);
    P.tag = 2, h != null && (P.callback = h), h = lu(d, P, T), h !== null && (ai(h, d, T, b), Ny(h, d, T));
  } };
  function lE(d, h, b, T, P, V, te) {
    return d = d.stateNode, typeof d.shouldComponentUpdate == "function" ? d.shouldComponentUpdate(T, V, te) : h.prototype && h.prototype.isPureReactComponent ? !gp(b, T) || !gp(P, V) : !0;
  }
  function cE(d, h, b) {
    var T = !1, P = bl, V = h.contextType;
    return typeof V == "object" && V !== null ? V = Cs(V) : (P = Jr(h) ? da : Sn.current, T = h.contextTypes, V = (T = T != null) ? ys(d, P) : bl), h = new h(b, V), d.memoizedState = h.state !== null && h.state !== void 0 ? h.state : null, h.updater = fd, d.stateNode = h, h._reactInternals = d, T && (d = d.stateNode, d.__reactInternalMemoizedUnmaskedChildContext = P, d.__reactInternalMemoizedMaskedChildContext = V), h;
  }
  function uE(d, h, b, T) {
    d = h.state, typeof h.componentWillReceiveProps == "function" && h.componentWillReceiveProps(b, T), typeof h.UNSAFE_componentWillReceiveProps == "function" && h.UNSAFE_componentWillReceiveProps(b, T), h.state !== d && fd.enqueueReplaceState(h, h.state, null);
  }
  function M0(d, h, b, T) {
    var P = d.stateNode;
    P.props = b, P.state = d.memoizedState, P.refs = {}, Py(d);
    var V = h.contextType;
    typeof V == "object" && V !== null ? P.context = Cs(V) : (V = Jr(h) ? da : Sn.current, P.context = ys(d, V)), P.state = d.memoizedState, V = h.getDerivedStateFromProps, typeof V == "function" && (dd(d, h, V, b), P.state = d.memoizedState), typeof h.getDerivedStateFromProps == "function" || typeof P.getSnapshotBeforeUpdate == "function" || typeof P.UNSAFE_componentWillMount != "function" && typeof P.componentWillMount != "function" || (h = P.state, typeof P.componentWillMount == "function" && P.componentWillMount(), typeof P.UNSAFE_componentWillMount == "function" && P.UNSAFE_componentWillMount(), h !== P.state && fd.enqueueReplaceState(P, P.state, null), By(d, b, P, T), P.state = d.memoizedState), typeof P.componentDidMount == "function" && (d.flags |= 4194308);
  }
  function uu(d, h) {
    try {
      var b = "", T = h;
      do
        b += Me(T), T = T.return;
      while (T);
      var P = b;
    } catch (V) {
      P = `
Error generating stack: ` + V.message + `
` + V.stack;
    }
    return { value: d, source: h, stack: P, digest: null };
  }
  function P0(d, h, b) {
    return { value: d, source: null, stack: b ?? null, digest: h ?? null };
  }
  function Lp(d, h) {
    try {
    } catch (b) {
      setTimeout(function() {
        throw b;
      });
    }
  }
  var dE = typeof WeakMap == "function" ? WeakMap : Map;
  function fE(d, h, b) {
    b = ya(-1, b), b.tag = 3, b.payload = { element: null };
    var T = h.value;
    return b.callback = function() {
      fv || (fv = !0, $0 = T), Lp(d, h);
    }, b;
  }
  function hE(d, h, b) {
    b = ya(-1, b), b.tag = 3;
    var T = d.type.getDerivedStateFromError;
    if (typeof T == "function") {
      var P = h.value;
      b.payload = function() {
        return T(P);
      }, b.callback = function() {
        Lp(d, h);
      };
    }
    var V = d.stateNode;
    return V !== null && typeof V.componentDidCatch == "function" && (b.callback = function() {
      Lp(d, h), typeof T != "function" && (ks === null ? ks = /* @__PURE__ */ new Set([this]) : ks.add(this));
      var te = h.stack;
      this.componentDidCatch(h.value, { componentStack: te !== null ? te : "" });
    }), b;
  }
  function jp(d, h, b) {
    var T = d.pingCache;
    if (T === null) {
      T = d.pingCache = new dE();
      var P = /* @__PURE__ */ new Set();
      T.set(h, P);
    } else P = T.get(h), P === void 0 && (P = /* @__PURE__ */ new Set(), T.set(h, P));
    P.has(b) || (P.add(b), d = OT.bind(null, d, h, b), h.then(d, d));
  }
  function pE(d) {
    do {
      var h;
      if ((h = d.tag === 13) && (h = d.memoizedState, h = h !== null ? h.dehydrated !== null : !0), h) return d;
      d = d.return;
    } while (d !== null);
    return null;
  }
  function N0(d, h, b, T, P) {
    return d.mode & 1 ? (d.flags |= 65536, d.lanes = P, d) : (d === h ? d.flags |= 65536 : (d.flags |= 128, b.flags |= 131072, b.flags &= -52805, b.tag === 1 && (b.alternate === null ? b.tag = 17 : (h = ya(-1, 1), h.tag = 2, lu(b, h, 1))), b.lanes |= 1), d);
  }
  var mE = M.ReactCurrentOwner, ga = !1;
  function Ei(d, h, b, T) {
    h.child = d === null ? nE(h, null, b, T) : kf(h, d.child, b, T);
  }
  function Lf(d, h, b, T, P) {
    b = b.render;
    var V = h.ref;
    return Af(h, P), T = nt(d, h, b, T, V, P), b = Ii(), d !== null && !ga ? (h.updateQueue = d.updateQueue, h.flags &= -2053, d.lanes &= ~P, Si(d, h, P)) : (Wr && b && _y(h), h.flags |= 1, Ei(d, h, T, P), h.child);
  }
  function du(d, h, b, T, P) {
    if (d === null) {
      var V = b.type;
      return typeof V == "function" && !K0(V) && V.defaultProps === void 0 && b.compare === null && b.defaultProps === void 0 ? (h.tag = 15, h.type = V, tv(d, h, V, T, P)) : (d = gv(b.type, null, T, h, h.mode, P), d.ref = h.ref, d.return = h, h.child = d);
    }
    if (V = d.child, !(d.lanes & P)) {
      var te = V.memoizedProps;
      if (b = b.compare, b = b !== null ? b : gp, b(te, T) && d.ref === h.ref) return Si(d, h, P);
    }
    return h.flags |= 1, d = pu(V, T), d.ref = h.ref, d.return = h, h.child = d;
  }
  function tv(d, h, b, T, P) {
    if (d !== null) {
      var V = d.memoizedProps;
      if (gp(V, T) && d.ref === h.ref) if (ga = !1, h.pendingProps = T = V, (d.lanes & P) !== 0) d.flags & 131072 && (ga = !0);
      else return h.lanes = d.lanes, Si(d, h, P);
    }
    return Mn(d, h, b, T, P);
  }
  function ba(d, h, b) {
    var T = h.pendingProps, P = T.children, V = d !== null ? d.memoizedState : null;
    if (T.mode === "hidden") if (!(h.mode & 1)) h.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, kr(Gf, wa), wa |= b;
    else {
      if (!(b & 1073741824)) return d = V !== null ? V.baseLanes | b : b, h.lanes = h.childLanes = 1073741824, h.memoizedState = { baseLanes: d, cachePool: null, transitions: null }, h.updateQueue = null, kr(Gf, wa), wa |= d, null;
      h.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, T = V !== null ? V.baseLanes : b, kr(Gf, wa), wa |= T;
    }
    else V !== null ? (T = V.baseLanes | b, h.memoizedState = null) : T = b, kr(Gf, wa), wa |= T;
    return Ei(d, h, P, b), h.child;
  }
  function hd(d, h) {
    var b = h.ref;
    (d === null && b !== null || d !== null && d.ref !== b) && (h.flags |= 512, h.flags |= 2097152);
  }
  function Mn(d, h, b, T, P) {
    var V = Jr(b) ? da : Sn.current;
    return V = ys(h, V), Af(h, P), b = nt(d, h, b, T, V, P), T = Ii(), d !== null && !ga ? (h.updateQueue = d.updateQueue, h.flags &= -2053, d.lanes &= ~P, Si(d, h, P)) : (Wr && T && _y(h), h.flags |= 1, Ei(d, h, b, P), h.child);
  }
  function Fp(d, h, b, T, P) {
    if (Jr(b)) {
      var V = !0;
      Ty(h);
    } else V = !1;
    if (Af(h, P), h.stateNode === null) zp(d, h), cE(h, b, T), M0(h, b, T, P), T = !0;
    else if (d === null) {
      var te = h.stateNode, me = h.memoizedProps;
      te.props = me;
      var xe = te.context, He = b.contextType;
      typeof He == "object" && He !== null ? He = Cs(He) : (He = Jr(b) ? da : Sn.current, He = ys(h, He));
      var at = b.getDerivedStateFromProps, ut = typeof at == "function" || typeof te.getSnapshotBeforeUpdate == "function";
      ut || typeof te.UNSAFE_componentWillReceiveProps != "function" && typeof te.componentWillReceiveProps != "function" || (me !== T || xe !== He) && uE(h, te, T, He), su = !1;
      var rt = h.memoizedState;
      te.state = rt, By(h, T, te, P), xe = h.memoizedState, me !== T || rt !== xe || fi.current || su ? (typeof at == "function" && (dd(h, b, at, T), xe = h.memoizedState), (me = su || lE(h, b, me, T, rt, xe, He)) ? (ut || typeof te.UNSAFE_componentWillMount != "function" && typeof te.componentWillMount != "function" || (typeof te.componentWillMount == "function" && te.componentWillMount(), typeof te.UNSAFE_componentWillMount == "function" && te.UNSAFE_componentWillMount()), typeof te.componentDidMount == "function" && (h.flags |= 4194308)) : (typeof te.componentDidMount == "function" && (h.flags |= 4194308), h.memoizedProps = T, h.memoizedState = xe), te.props = T, te.state = xe, te.context = He, T = me) : (typeof te.componentDidMount == "function" && (h.flags |= 4194308), T = !1);
    } else {
      te = h.stateNode, Tf(d, h), me = h.memoizedProps, He = h.type === h.elementType ? me : va(h.type, me), te.props = He, ut = h.pendingProps, rt = te.context, xe = b.contextType, typeof xe == "object" && xe !== null ? xe = Cs(xe) : (xe = Jr(b) ? da : Sn.current, xe = ys(h, xe));
      var _t = b.getDerivedStateFromProps;
      (at = typeof _t == "function" || typeof te.getSnapshotBeforeUpdate == "function") || typeof te.UNSAFE_componentWillReceiveProps != "function" && typeof te.componentWillReceiveProps != "function" || (me !== ut || rt !== xe) && uE(h, te, T, xe), su = !1, rt = h.memoizedState, te.state = rt, By(h, T, te, P);
      var Lt = h.memoizedState;
      me !== ut || rt !== Lt || fi.current || su ? (typeof _t == "function" && (dd(h, b, _t, T), Lt = h.memoizedState), (He = su || lE(h, b, He, T, rt, Lt, xe) || !1) ? (at || typeof te.UNSAFE_componentWillUpdate != "function" && typeof te.componentWillUpdate != "function" || (typeof te.componentWillUpdate == "function" && te.componentWillUpdate(T, Lt, xe), typeof te.UNSAFE_componentWillUpdate == "function" && te.UNSAFE_componentWillUpdate(T, Lt, xe)), typeof te.componentDidUpdate == "function" && (h.flags |= 4), typeof te.getSnapshotBeforeUpdate == "function" && (h.flags |= 1024)) : (typeof te.componentDidUpdate != "function" || me === d.memoizedProps && rt === d.memoizedState || (h.flags |= 4), typeof te.getSnapshotBeforeUpdate != "function" || me === d.memoizedProps && rt === d.memoizedState || (h.flags |= 1024), h.memoizedProps = T, h.memoizedState = Lt), te.props = T, te.state = Lt, te.context = xe, T = He) : (typeof te.componentDidUpdate != "function" || me === d.memoizedProps && rt === d.memoizedState || (h.flags |= 4), typeof te.getSnapshotBeforeUpdate != "function" || me === d.memoizedProps && rt === d.memoizedState || (h.flags |= 1024), T = !1);
    }
    return nv(d, h, b, T, V, P);
  }
  function nv(d, h, b, T, P, V) {
    hd(d, h);
    var te = (h.flags & 128) !== 0;
    if (!T && !te) return P && Xx(h, b, !1), Si(d, h, V);
    T = h.stateNode, mE.current = h;
    var me = te && typeof b.getDerivedStateFromError != "function" ? null : T.render();
    return h.flags |= 1, d !== null && te ? (h.child = kf(h, d.child, null, V), h.child = kf(h, null, me, V)) : Ei(d, h, me, V), h.memoizedState = T.state, P && Xx(h, b, !0), h.child;
  }
  function CT(d) {
    var h = d.stateNode;
    h.pendingContext ? ou(d, h.pendingContext, h.pendingContext !== h.context) : h.context && ou(d, h.context, !1), _0(d, h.containerInfo);
  }
  function yE(d, h, b, T, P) {
    return oi(), k0(P), h.flags |= 256, Ei(d, h, b, T), h.child;
  }
  var Up = { dehydrated: null, treeContext: null, retryLane: 0 };
  function pd(d) {
    return { baseLanes: d, cachePool: null, transitions: null };
  }
  function vE(d, h, b) {
    var T = h.pendingProps, P = Zr.current, V = !1, te = (h.flags & 128) !== 0, me;
    if ((me = te) || (me = d !== null && d.memoizedState === null ? !1 : (P & 2) !== 0), me ? (V = !0, h.flags &= -129) : (d === null || d.memoizedState !== null) && (P |= 1), kr(Zr, P & 1), d === null)
      return Oy(h), d = h.memoizedState, d !== null && (d = d.dehydrated, d !== null) ? (h.mode & 1 ? d.data === "$!" ? h.lanes = 8 : h.lanes = 1073741824 : h.lanes = 1, null) : (te = T.children, d = T.fallback, V ? (T = h.mode, V = h.child, te = { mode: "hidden", children: te }, !(T & 1) && V !== null ? (V.childLanes = 0, V.pendingProps = te) : V = bv(te, T, 0, null), d = wd(d, T, b, null), V.return = h, d.return = h, V.sibling = d, h.child = V, h.child.memoizedState = pd(b), h.memoizedState = Up, d) : rv(h, te));
    if (P = d.memoizedState, P !== null && (me = P.dehydrated, me !== null)) return B0(d, h, te, T, me, P, b);
    if (V) {
      V = T.fallback, te = h.mode, P = d.child, me = P.sibling;
      var xe = { mode: "hidden", children: T.children };
      return !(te & 1) && h.child !== P ? (T = h.child, T.childLanes = 0, T.pendingProps = xe, h.deletions = null) : (T = pu(P, xe), T.subtreeFlags = P.subtreeFlags & 14680064), me !== null ? V = pu(me, V) : (V = wd(V, te, b, null), V.flags |= 2), V.return = h, T.return = h, T.sibling = V, h.child = T, T = V, V = h.child, te = d.child.memoizedState, te = te === null ? pd(b) : { baseLanes: te.baseLanes | b, cachePool: null, transitions: te.transitions }, V.memoizedState = te, V.childLanes = d.childLanes & ~b, h.memoizedState = Up, T;
    }
    return V = d.child, d = V.sibling, T = pu(V, { mode: "visible", children: T.children }), !(h.mode & 1) && (T.lanes = b), T.return = h, T.sibling = null, d !== null && (b = h.deletions, b === null ? (h.deletions = [d], h.flags |= 16) : b.push(d)), h.child = T, h.memoizedState = null, T;
  }
  function rv(d, h) {
    return h = bv({ mode: "visible", children: h }, d.mode, 0, null), h.return = d, d.child = h;
  }
  function iv(d, h, b, T) {
    return T !== null && k0(T), kf(h, d.child, null, b), d = rv(h, h.pendingProps.children), d.flags |= 2, h.memoizedState = null, d;
  }
  function B0(d, h, b, T, P, V, te) {
    if (b)
      return h.flags & 256 ? (h.flags &= -257, T = P0(Error(n(422))), iv(d, h, te, T)) : h.memoizedState !== null ? (h.child = d.child, h.flags |= 128, null) : (V = T.fallback, P = h.mode, T = bv({ mode: "visible", children: T.children }, P, 0, null), V = wd(V, P, te, null), V.flags |= 2, T.return = h, V.return = h, T.sibling = V, h.child = T, h.mode & 1 && kf(h, d.child, null, te), h.child.memoizedState = pd(te), h.memoizedState = Up, V);
    if (!(h.mode & 1)) return iv(d, h, te, null);
    if (P.data === "$!") {
      if (T = P.nextSibling && P.nextSibling.dataset, T) var me = T.dgst;
      return T = me, V = Error(n(419)), T = P0(V, T, void 0), iv(d, h, te, T);
    }
    if (me = (te & d.childLanes) !== 0, ga || me) {
      if (T = pi, T !== null) {
        switch (te & -te) {
          case 4:
            P = 2;
            break;
          case 16:
            P = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            P = 32;
            break;
          case 536870912:
            P = 268435456;
            break;
          default:
            P = 0;
        }
        P = P & (T.suspendedLanes | te) ? 0 : P, P !== 0 && P !== V.retryLane && (V.retryLane = P, yc(d, P), ai(T, d, P, -1));
      }
      return Wp(), T = P0(Error(n(421))), iv(d, h, te, T);
    }
    return P.data === "$?" ? (h.flags |= 128, h.child = d.child, h = G0.bind(null, d), P._reactRetry = h, null) : (d = V.treeContext, ma = tl(P.nextSibling), $a = h, Wr = !0, bs = null, d !== null && (pa[No++] = mo, pa[No++] = pc, pa[No++] = gs, mo = d.id, pc = d.overflow, gs = h), h = rv(h, T.children), h.flags |= 4096, h);
  }
  function gE(d, h, b) {
    d.lanes |= h;
    var T = d.alternate;
    T !== null && (T.lanes |= h), T0(d.return, h, b);
  }
  function ov(d, h, b, T, P) {
    var V = d.memoizedState;
    V === null ? d.memoizedState = { isBackwards: h, rendering: null, renderingStartTime: 0, last: T, tail: b, tailMode: P } : (V.isBackwards = h, V.rendering = null, V.renderingStartTime = 0, V.last = T, V.tail = b, V.tailMode = P);
  }
  function L0(d, h, b) {
    var T = h.pendingProps, P = T.revealOrder, V = T.tail;
    if (Ei(d, h, T.children, b), T = Zr.current, T & 2) T = T & 1 | 2, h.flags |= 128;
    else {
      if (d !== null && d.flags & 128) e: for (d = h.child; d !== null; ) {
        if (d.tag === 13) d.memoizedState !== null && gE(d, b, h);
        else if (d.tag === 19) gE(d, b, h);
        else if (d.child !== null) {
          d.child.return = d, d = d.child;
          continue;
        }
        if (d === h) break e;
        for (; d.sibling === null; ) {
          if (d.return === null || d.return === h) break e;
          d = d.return;
        }
        d.sibling.return = d.return, d = d.sibling;
      }
      T &= 1;
    }
    if (kr(Zr, T), !(h.mode & 1)) h.memoizedState = null;
    else switch (P) {
      case "forwards":
        for (b = h.child, P = null; b !== null; ) d = b.alternate, d !== null && Ly(d) === null && (P = b), b = b.sibling;
        b = P, b === null ? (P = h.child, h.child = null) : (P = b.sibling, b.sibling = null), ov(h, !1, P, b, V);
        break;
      case "backwards":
        for (b = null, P = h.child, h.child = null; P !== null; ) {
          if (d = P.alternate, d !== null && Ly(d) === null) {
            h.child = P;
            break;
          }
          d = P.sibling, P.sibling = b, b = P, P = d;
        }
        ov(h, !0, b, null, V);
        break;
      case "together":
        ov(h, !1, null, null, void 0);
        break;
      default:
        h.memoizedState = null;
    }
    return h.child;
  }
  function zp(d, h) {
    !(h.mode & 1) && d !== null && (d.alternate = null, h.alternate = null, h.flags |= 2);
  }
  function Si(d, h, b) {
    if (d !== null && (h.dependencies = d.dependencies), yd |= h.lanes, !(b & h.childLanes)) return null;
    if (d !== null && h.child !== d.child) throw Error(n(153));
    if (h.child !== null) {
      for (d = h.child, b = pu(d, d.pendingProps), h.child = b, b.return = h; d.sibling !== null; ) d = d.sibling, b = b.sibling = pu(d, d.pendingProps), b.return = h;
      b.sibling = null;
    }
    return h.child;
  }
  function gc(d, h, b) {
    switch (h.tag) {
      case 3:
        CT(h), oi();
        break;
      case 5:
        aE(h);
        break;
      case 1:
        Jr(h.type) && Ty(h);
        break;
      case 4:
        _0(h, h.stateNode.containerInfo);
        break;
      case 10:
        var T = h.type._context, P = h.memoizedProps.value;
        kr(mc, T._currentValue), T._currentValue = P;
        break;
      case 13:
        if (T = h.memoizedState, T !== null)
          return T.dehydrated !== null ? (kr(Zr, Zr.current & 1), h.flags |= 128, null) : b & h.child.childLanes ? vE(d, h, b) : (kr(Zr, Zr.current & 1), d = Si(d, h, b), d !== null ? d.sibling : null);
        kr(Zr, Zr.current & 1);
        break;
      case 19:
        if (T = (b & h.childLanes) !== 0, d.flags & 128) {
          if (T) return L0(d, h, b);
          h.flags |= 128;
        }
        if (P = h.memoizedState, P !== null && (P.rendering = null, P.tail = null, P.lastEffect = null), kr(Zr, Zr.current), T) break;
        return null;
      case 22:
      case 23:
        return h.lanes = 0, ba(d, h, b);
    }
    return Si(d, h, b);
  }
  var Cl, jf, Ff, Es;
  Cl = function(d, h) {
    for (var b = h.child; b !== null; ) {
      if (b.tag === 5 || b.tag === 6) d.appendChild(b.stateNode);
      else if (b.tag !== 4 && b.child !== null) {
        b.child.return = b, b = b.child;
        continue;
      }
      if (b === h) break;
      for (; b.sibling === null; ) {
        if (b.return === null || b.return === h) return;
        b = b.return;
      }
      b.sibling.return = b.return, b = b.sibling;
    }
  }, jf = function() {
  }, Ff = function(d, h, b, T) {
    var P = d.memoizedProps;
    if (P !== T) {
      d = h.stateNode, sd(nl.current);
      var V = null;
      switch (b) {
        case "input":
          P = xt(d, P), T = xt(d, T), V = [];
          break;
        case "select":
          P = be({}, P, { value: void 0 }), T = be({}, T, { value: void 0 }), V = [];
          break;
        case "textarea":
          P = Un(d, P), T = Un(d, T), V = [];
          break;
        default:
          typeof P.onClick != "function" && typeof T.onClick == "function" && (d.onclick = Ay);
      }
      Ve(b, T);
      var te;
      b = null;
      for (He in P) if (!T.hasOwnProperty(He) && P.hasOwnProperty(He) && P[He] != null) if (He === "style") {
        var me = P[He];
        for (te in me) me.hasOwnProperty(te) && (b || (b = {}), b[te] = "");
      } else He !== "dangerouslySetInnerHTML" && He !== "children" && He !== "suppressContentEditableWarning" && He !== "suppressHydrationWarning" && He !== "autoFocus" && (i.hasOwnProperty(He) ? V || (V = []) : (V = V || []).push(He, null));
      for (He in T) {
        var xe = T[He];
        if (me = P != null ? P[He] : void 0, T.hasOwnProperty(He) && xe !== me && (xe != null || me != null)) if (He === "style") if (me) {
          for (te in me) !me.hasOwnProperty(te) || xe && xe.hasOwnProperty(te) || (b || (b = {}), b[te] = "");
          for (te in xe) xe.hasOwnProperty(te) && me[te] !== xe[te] && (b || (b = {}), b[te] = xe[te]);
        } else b || (V || (V = []), V.push(
          He,
          b
        )), b = xe;
        else He === "dangerouslySetInnerHTML" ? (xe = xe ? xe.__html : void 0, me = me ? me.__html : void 0, xe != null && me !== xe && (V = V || []).push(He, xe)) : He === "children" ? typeof xe != "string" && typeof xe != "number" || (V = V || []).push(He, "" + xe) : He !== "suppressContentEditableWarning" && He !== "suppressHydrationWarning" && (i.hasOwnProperty(He) ? (xe != null && He === "onScroll" && Fr("scroll", d), V || me === xe || (V = [])) : (V = V || []).push(He, xe));
      }
      b && (V = V || []).push("style", b);
      var He = V;
      (h.updateQueue = He) && (h.flags |= 4);
    }
  }, Es = function(d, h, b, T) {
    b !== T && (h.flags |= 4);
  };
  function hi(d, h) {
    if (!Wr) switch (d.tailMode) {
      case "hidden":
        h = d.tail;
        for (var b = null; h !== null; ) h.alternate !== null && (b = h), h = h.sibling;
        b === null ? d.tail = null : b.sibling = null;
        break;
      case "collapsed":
        b = d.tail;
        for (var T = null; b !== null; ) b.alternate !== null && (T = b), b = b.sibling;
        T === null ? h || d.tail === null ? d.tail = null : d.tail.sibling = null : T.sibling = null;
    }
  }
  function jo(d) {
    var h = d.alternate !== null && d.alternate.child === d.child, b = 0, T = 0;
    if (h) for (var P = d.child; P !== null; ) b |= P.lanes | P.childLanes, T |= P.subtreeFlags & 14680064, T |= P.flags & 14680064, P.return = d, P = P.sibling;
    else for (P = d.child; P !== null; ) b |= P.lanes | P.childLanes, T |= P.subtreeFlags, T |= P.flags, P.return = d, P = P.sibling;
    return d.subtreeFlags |= T, d.childLanes = b, h;
  }
  function xT(d, h, b) {
    var T = h.pendingProps;
    switch (E0(h), h.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return jo(h), null;
      case 1:
        return Jr(h.type) && vs(), jo(h), null;
      case 3:
        return T = h.stateNode, Rf(), wr(fi), wr(Sn), O0(), T.pendingContext && (T.context = T.pendingContext, T.pendingContext = null), (d === null || d.child === null) && (Iy(h) ? h.flags |= 4 : d === null || d.memoizedState.isDehydrated && !(h.flags & 256) || (h.flags |= 1024, bs !== null && (H0(bs), bs = null))), jf(d, h), jo(h), null;
      case 5:
        R0(h);
        var P = sd(Ip.current);
        if (b = h.type, d !== null && h.stateNode != null) Ff(d, h, b, T, P), d.ref !== h.ref && (h.flags |= 512, h.flags |= 2097152);
        else {
          if (!T) {
            if (h.stateNode === null) throw Error(n(166));
            return jo(h), null;
          }
          if (d = sd(nl.current), Iy(h)) {
            T = h.stateNode, b = h.type;
            var V = h.memoizedProps;
            switch (T[gl] = h, T[rd] = V, d = (h.mode & 1) !== 0, b) {
              case "dialog":
                Fr("cancel", T), Fr("close", T);
                break;
              case "iframe":
              case "object":
              case "embed":
                Fr("load", T);
                break;
              case "video":
              case "audio":
                for (P = 0; P < xp.length; P++) Fr(xp[P], T);
                break;
              case "source":
                Fr("error", T);
                break;
              case "img":
              case "image":
              case "link":
                Fr(
                  "error",
                  T
                ), Fr("load", T);
                break;
              case "details":
                Fr("toggle", T);
                break;
              case "input":
                zt(T, V), Fr("invalid", T);
                break;
              case "select":
                T._wrapperState = { wasMultiple: !!V.multiple }, Fr("invalid", T);
                break;
              case "textarea":
                $n(T, V), Fr("invalid", T);
            }
            Ve(b, V), P = null;
            for (var te in V) if (V.hasOwnProperty(te)) {
              var me = V[te];
              te === "children" ? typeof me == "string" ? T.textContent !== me && (V.suppressHydrationWarning !== !0 && ky(T.textContent, me, d), P = ["children", me]) : typeof me == "number" && T.textContent !== "" + me && (V.suppressHydrationWarning !== !0 && ky(
                T.textContent,
                me,
                d
              ), P = ["children", "" + me]) : i.hasOwnProperty(te) && me != null && te === "onScroll" && Fr("scroll", T);
            }
            switch (b) {
              case "input":
                hn(T), tr(T, V, !0);
                break;
              case "textarea":
                hn(T), Tt(T);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof V.onClick == "function" && (T.onclick = Ay);
            }
            T = P, h.updateQueue = T, T !== null && (h.flags |= 4);
          } else {
            te = P.nodeType === 9 ? P : P.ownerDocument, d === "http://www.w3.org/1999/xhtml" && (d = qt(b)), d === "http://www.w3.org/1999/xhtml" ? b === "script" ? (d = te.createElement("div"), d.innerHTML = "<script><\/script>", d = d.removeChild(d.firstChild)) : typeof T.is == "string" ? d = te.createElement(b, { is: T.is }) : (d = te.createElement(b), b === "select" && (te = d, T.multiple ? te.multiple = !0 : T.size && (te.size = T.size))) : d = te.createElementNS(d, b), d[gl] = h, d[rd] = T, Cl(d, h, !1, !1), h.stateNode = d;
            e: {
              switch (te = kt(b, T), b) {
                case "dialog":
                  Fr("cancel", d), Fr("close", d), P = T;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  Fr("load", d), P = T;
                  break;
                case "video":
                case "audio":
                  for (P = 0; P < xp.length; P++) Fr(xp[P], d);
                  P = T;
                  break;
                case "source":
                  Fr("error", d), P = T;
                  break;
                case "img":
                case "image":
                case "link":
                  Fr(
                    "error",
                    d
                  ), Fr("load", d), P = T;
                  break;
                case "details":
                  Fr("toggle", d), P = T;
                  break;
                case "input":
                  zt(d, T), P = xt(d, T), Fr("invalid", d);
                  break;
                case "option":
                  P = T;
                  break;
                case "select":
                  d._wrapperState = { wasMultiple: !!T.multiple }, P = be({}, T, { value: void 0 }), Fr("invalid", d);
                  break;
                case "textarea":
                  $n(d, T), P = Un(d, T), Fr("invalid", d);
                  break;
                default:
                  P = T;
              }
              Ve(b, P), me = P;
              for (V in me) if (me.hasOwnProperty(V)) {
                var xe = me[V];
                V === "style" ? Ce(d, xe) : V === "dangerouslySetInnerHTML" ? (xe = xe ? xe.__html : void 0, xe != null && br(d, xe)) : V === "children" ? typeof xe == "string" ? (b !== "textarea" || xe !== "") && ne(d, xe) : typeof xe == "number" && ne(d, "" + xe) : V !== "suppressContentEditableWarning" && V !== "suppressHydrationWarning" && V !== "autoFocus" && (i.hasOwnProperty(V) ? xe != null && V === "onScroll" && Fr("scroll", d) : xe != null && D(d, V, xe, te));
              }
              switch (b) {
                case "input":
                  hn(d), tr(d, T, !1);
                  break;
                case "textarea":
                  hn(d), Tt(d);
                  break;
                case "option":
                  T.value != null && d.setAttribute("value", "" + mt(T.value));
                  break;
                case "select":
                  d.multiple = !!T.multiple, V = T.value, V != null ? Cr(d, !!T.multiple, V, !1) : T.defaultValue != null && Cr(
                    d,
                    !!T.multiple,
                    T.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof P.onClick == "function" && (d.onclick = Ay);
              }
              switch (b) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  T = !!T.autoFocus;
                  break e;
                case "img":
                  T = !0;
                  break e;
                default:
                  T = !1;
              }
            }
            T && (h.flags |= 4);
          }
          h.ref !== null && (h.flags |= 512, h.flags |= 2097152);
        }
        return jo(h), null;
      case 6:
        if (d && h.stateNode != null) Es(d, h, d.memoizedProps, T);
        else {
          if (typeof T != "string" && h.stateNode === null) throw Error(n(166));
          if (b = sd(Ip.current), sd(nl.current), Iy(h)) {
            if (T = h.stateNode, b = h.memoizedProps, T[gl] = h, (V = T.nodeValue !== b) && (d = $a, d !== null)) switch (d.tag) {
              case 3:
                ky(T.nodeValue, b, (d.mode & 1) !== 0);
                break;
              case 5:
                d.memoizedProps.suppressHydrationWarning !== !0 && ky(T.nodeValue, b, (d.mode & 1) !== 0);
            }
            V && (h.flags |= 4);
          } else T = (b.nodeType === 9 ? b : b.ownerDocument).createTextNode(T), T[gl] = h, h.stateNode = T;
        }
        return jo(h), null;
      case 13:
        if (wr(Zr), T = h.memoizedState, d === null || d.memoizedState !== null && d.memoizedState.dehydrated !== null) {
          if (Wr && ma !== null && h.mode & 1 && !(h.flags & 128)) eE(), oi(), h.flags |= 98560, V = !1;
          else if (V = Iy(h), T !== null && T.dehydrated !== null) {
            if (d === null) {
              if (!V) throw Error(n(318));
              if (V = h.memoizedState, V = V !== null ? V.dehydrated : null, !V) throw Error(n(317));
              V[gl] = h;
            } else oi(), !(h.flags & 128) && (h.memoizedState = null), h.flags |= 4;
            jo(h), V = !1;
          } else bs !== null && (H0(bs), bs = null), V = !0;
          if (!V) return h.flags & 65536 ? h : null;
        }
        return h.flags & 128 ? (h.lanes = b, h) : (T = T !== null, T !== (d !== null && d.memoizedState !== null) && T && (h.child.flags |= 8192, h.mode & 1 && (d === null || Zr.current & 1 ? Vi === 0 && (Vi = 3) : Wp())), h.updateQueue !== null && (h.flags |= 4), jo(h), null);
      case 4:
        return Rf(), jf(d, h), d === null && xf(h.stateNode.containerInfo), jo(h), null;
      case 10:
        return A0(h.type._context), jo(h), null;
      case 17:
        return Jr(h.type) && vs(), jo(h), null;
      case 19:
        if (wr(Zr), V = h.memoizedState, V === null) return jo(h), null;
        if (T = (h.flags & 128) !== 0, te = V.rendering, te === null) if (T) hi(V, !1);
        else {
          if (Vi !== 0 || d !== null && d.flags & 128) for (d = h.child; d !== null; ) {
            if (te = Ly(d), te !== null) {
              for (h.flags |= 128, hi(V, !1), T = te.updateQueue, T !== null && (h.updateQueue = T, h.flags |= 4), h.subtreeFlags = 0, T = b, b = h.child; b !== null; ) V = b, d = T, V.flags &= 14680066, te = V.alternate, te === null ? (V.childLanes = 0, V.lanes = d, V.child = null, V.subtreeFlags = 0, V.memoizedProps = null, V.memoizedState = null, V.updateQueue = null, V.dependencies = null, V.stateNode = null) : (V.childLanes = te.childLanes, V.lanes = te.lanes, V.child = te.child, V.subtreeFlags = 0, V.deletions = null, V.memoizedProps = te.memoizedProps, V.memoizedState = te.memoizedState, V.updateQueue = te.updateQueue, V.type = te.type, d = te.dependencies, V.dependencies = d === null ? null : { lanes: d.lanes, firstContext: d.firstContext }), b = b.sibling;
              return kr(Zr, Zr.current & 1 | 2), h.child;
            }
            d = d.sibling;
          }
          V.tail !== null && tn() > Yf && (h.flags |= 128, T = !0, hi(V, !1), h.lanes = 4194304);
        }
        else {
          if (!T) if (d = Ly(te), d !== null) {
            if (h.flags |= 128, T = !0, b = d.updateQueue, b !== null && (h.updateQueue = b, h.flags |= 4), hi(V, !0), V.tail === null && V.tailMode === "hidden" && !te.alternate && !Wr) return jo(h), null;
          } else 2 * tn() - V.renderingStartTime > Yf && b !== 1073741824 && (h.flags |= 128, T = !0, hi(V, !1), h.lanes = 4194304);
          V.isBackwards ? (te.sibling = h.child, h.child = te) : (b = V.last, b !== null ? b.sibling = te : h.child = te, V.last = te);
        }
        return V.tail !== null ? (h = V.tail, V.rendering = h, V.tail = h.sibling, V.renderingStartTime = tn(), h.sibling = null, b = Zr.current, kr(Zr, T ? b & 1 | 2 : b & 1), h) : (jo(h), null);
      case 22:
      case 23:
        return yv(), T = h.memoizedState !== null, d !== null && d.memoizedState !== null !== T && (h.flags |= 8192), T && h.mode & 1 ? wa & 1073741824 && (jo(h), h.subtreeFlags & 6 && (h.flags |= 8192)) : jo(h), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(n(156, h.tag));
  }
  function ET(d, h) {
    switch (E0(h), h.tag) {
      case 1:
        return Jr(h.type) && vs(), d = h.flags, d & 65536 ? (h.flags = d & -65537 | 128, h) : null;
      case 3:
        return Rf(), wr(fi), wr(Sn), O0(), d = h.flags, d & 65536 && !(d & 128) ? (h.flags = d & -65537 | 128, h) : null;
      case 5:
        return R0(h), null;
      case 13:
        if (wr(Zr), d = h.memoizedState, d !== null && d.dehydrated !== null) {
          if (h.alternate === null) throw Error(n(340));
          oi();
        }
        return d = h.flags, d & 65536 ? (h.flags = d & -65537 | 128, h) : null;
      case 19:
        return wr(Zr), null;
      case 4:
        return Rf(), null;
      case 10:
        return A0(h.type._context), null;
      case 22:
      case 23:
        return yv(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Uf = !1, vo = !1, av = typeof WeakSet == "function" ? WeakSet : Set, Mt = null;
  function zf(d, h) {
    var b = d.ref;
    if (b !== null) if (typeof b == "function") try {
      b(null);
    } catch (T) {
      mi(d, h, T);
    }
    else b.current = null;
  }
  function j0(d, h, b) {
    try {
      b();
    } catch (T) {
      mi(d, h, T);
    }
  }
  var sv = !1;
  function ST(d, h) {
    if (m0 = fe, d = wy(), uc(d)) {
      if ("selectionStart" in d) var b = { start: d.selectionStart, end: d.selectionEnd };
      else e: {
        b = (b = d.ownerDocument) && b.defaultView || window;
        var T = b.getSelection && b.getSelection();
        if (T && T.rangeCount !== 0) {
          b = T.anchorNode;
          var P = T.anchorOffset, V = T.focusNode;
          T = T.focusOffset;
          try {
            b.nodeType, V.nodeType;
          } catch {
            b = null;
            break e;
          }
          var te = 0, me = -1, xe = -1, He = 0, at = 0, ut = d, rt = null;
          t: for (; ; ) {
            for (var _t; ut !== b || P !== 0 && ut.nodeType !== 3 || (me = te + P), ut !== V || T !== 0 && ut.nodeType !== 3 || (xe = te + T), ut.nodeType === 3 && (te += ut.nodeValue.length), (_t = ut.firstChild) !== null; )
              rt = ut, ut = _t;
            for (; ; ) {
              if (ut === d) break t;
              if (rt === b && ++He === P && (me = te), rt === V && ++at === T && (xe = te), (_t = ut.nextSibling) !== null) break;
              ut = rt, rt = ut.parentNode;
            }
            ut = _t;
          }
          b = me === -1 || xe === -1 ? null : { start: me, end: xe };
        } else b = null;
      }
      b = b || { start: 0, end: 0 };
    } else b = null;
    for (td = { focusedElem: d, selectionRange: b }, fe = !1, Mt = h; Mt !== null; ) if (h = Mt, d = h.child, (h.subtreeFlags & 1028) !== 0 && d !== null) d.return = h, Mt = d;
    else for (; Mt !== null; ) {
      h = Mt;
      try {
        var Lt = h.alternate;
        if (h.flags & 1024) switch (h.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (Lt !== null) {
              var Vt = Lt.memoizedProps, ki = Lt.memoizedState, Ne = h.stateNode, Oe = Ne.getSnapshotBeforeUpdate(h.elementType === h.type ? Vt : va(h.type, Vt), ki);
              Ne.__reactInternalSnapshotBeforeUpdate = Oe;
            }
            break;
          case 3:
            var Ue = h.stateNode.containerInfo;
            Ue.nodeType === 1 ? Ue.textContent = "" : Ue.nodeType === 9 && Ue.documentElement && Ue.removeChild(Ue.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(n(163));
        }
      } catch (ht) {
        mi(h, h.return, ht);
      }
      if (d = h.sibling, d !== null) {
        d.return = h.return, Mt = d;
        break;
      }
      Mt = h.return;
    }
    return Lt = sv, sv = !1, Lt;
  }
  function Vf(d, h, b) {
    var T = h.updateQueue;
    if (T = T !== null ? T.lastEffect : null, T !== null) {
      var P = T = T.next;
      do {
        if ((P.tag & d) === d) {
          var V = P.destroy;
          P.destroy = void 0, V !== void 0 && j0(h, b, V);
        }
        P = P.next;
      } while (P !== T);
    }
  }
  function lv(d, h) {
    if (h = h.updateQueue, h = h !== null ? h.lastEffect : null, h !== null) {
      var b = h = h.next;
      do {
        if ((b.tag & d) === d) {
          var T = b.create;
          b.destroy = T();
        }
        b = b.next;
      } while (b !== h);
    }
  }
  function cv(d) {
    var h = d.ref;
    if (h !== null) {
      var b = d.stateNode;
      switch (d.tag) {
        case 5:
          d = b;
          break;
        default:
          d = b;
      }
      typeof h == "function" ? h(d) : h.current = d;
    }
  }
  function bE(d) {
    var h = d.alternate;
    h !== null && (d.alternate = null, bE(h)), d.child = null, d.deletions = null, d.sibling = null, d.tag === 5 && (h = d.stateNode, h !== null && (delete h[gl], delete h[rd], delete h[g0], delete h[gT], delete h[b0])), d.stateNode = null, d.return = null, d.dependencies = null, d.memoizedProps = null, d.memoizedState = null, d.pendingProps = null, d.stateNode = null, d.updateQueue = null;
  }
  function F0(d) {
    return d.tag === 5 || d.tag === 3 || d.tag === 4;
  }
  function wE(d) {
    e: for (; ; ) {
      for (; d.sibling === null; ) {
        if (d.return === null || F0(d.return)) return null;
        d = d.return;
      }
      for (d.sibling.return = d.return, d = d.sibling; d.tag !== 5 && d.tag !== 6 && d.tag !== 18; ) {
        if (d.flags & 2 || d.child === null || d.tag === 4) continue e;
        d.child.return = d, d = d.child;
      }
      if (!(d.flags & 2)) return d.stateNode;
    }
  }
  function Vp(d, h, b) {
    var T = d.tag;
    if (T === 5 || T === 6) d = d.stateNode, h ? b.nodeType === 8 ? b.parentNode.insertBefore(d, h) : b.insertBefore(d, h) : (b.nodeType === 8 ? (h = b.parentNode, h.insertBefore(d, b)) : (h = b, h.appendChild(d)), b = b._reactRootContainer, b != null || h.onclick !== null || (h.onclick = Ay));
    else if (T !== 4 && (d = d.child, d !== null)) for (Vp(d, h, b), d = d.sibling; d !== null; ) Vp(d, h, b), d = d.sibling;
  }
  function $f(d, h, b) {
    var T = d.tag;
    if (T === 5 || T === 6) d = d.stateNode, h ? b.insertBefore(d, h) : b.appendChild(d);
    else if (T !== 4 && (d = d.child, d !== null)) for ($f(d, h, b), d = d.sibling; d !== null; ) $f(d, h, b), d = d.sibling;
  }
  var ei = null, no = !1;
  function Go(d, h, b) {
    for (b = b.child; b !== null; ) Hf(d, h, b), b = b.sibling;
  }
  function Hf(d, h, b) {
    if (Ci && typeof Ci.onCommitFiberUnmount == "function") try {
      Ci.onCommitFiberUnmount(Po, b);
    } catch {
    }
    switch (b.tag) {
      case 5:
        vo || zf(b, h);
      case 6:
        var T = ei, P = no;
        ei = null, Go(d, h, b), ei = T, no = P, ei !== null && (no ? (d = ei, b = b.stateNode, d.nodeType === 8 ? d.parentNode.removeChild(b) : d.removeChild(b)) : ei.removeChild(b.stateNode));
        break;
      case 18:
        ei !== null && (no ? (d = ei, b = b.stateNode, d.nodeType === 8 ? nu(d.parentNode, b) : d.nodeType === 1 && nu(d, b), Qs(d)) : nu(ei, b.stateNode));
        break;
      case 4:
        T = ei, P = no, ei = b.stateNode.containerInfo, no = !0, Go(d, h, b), ei = T, no = P;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!vo && (T = b.updateQueue, T !== null && (T = T.lastEffect, T !== null))) {
          P = T = T.next;
          do {
            var V = P, te = V.destroy;
            V = V.tag, te !== void 0 && (V & 2 || V & 4) && j0(b, h, te), P = P.next;
          } while (P !== T);
        }
        Go(d, h, b);
        break;
      case 1:
        if (!vo && (zf(b, h), T = b.stateNode, typeof T.componentWillUnmount == "function")) try {
          T.props = b.memoizedProps, T.state = b.memoizedState, T.componentWillUnmount();
        } catch (me) {
          mi(b, h, me);
        }
        Go(d, h, b);
        break;
      case 21:
        Go(d, h, b);
        break;
      case 22:
        b.mode & 1 ? (vo = (T = vo) || b.memoizedState !== null, Go(d, h, b), vo = T) : Go(d, h, b);
        break;
      default:
        Go(d, h, b);
    }
  }
  function qf(d) {
    var h = d.updateQueue;
    if (h !== null) {
      d.updateQueue = null;
      var b = d.stateNode;
      b === null && (b = d.stateNode = new av()), h.forEach(function(T) {
        var P = IT.bind(null, d, T);
        b.has(T) || (b.add(T), T.then(P, P));
      });
    }
  }
  function ro(d, h) {
    var b = h.deletions;
    if (b !== null) for (var T = 0; T < b.length; T++) {
      var P = b[T];
      try {
        var V = d, te = h, me = te;
        e: for (; me !== null; ) {
          switch (me.tag) {
            case 5:
              ei = me.stateNode, no = !1;
              break e;
            case 3:
              ei = me.stateNode.containerInfo, no = !0;
              break e;
            case 4:
              ei = me.stateNode.containerInfo, no = !0;
              break e;
          }
          me = me.return;
        }
        if (ei === null) throw Error(n(160));
        Hf(V, te, P), ei = null, no = !1;
        var xe = P.alternate;
        xe !== null && (xe.return = null), P.return = null;
      } catch (He) {
        mi(P, h, He);
      }
    }
    if (h.subtreeFlags & 12854) for (h = h.child; h !== null; ) CE(h, d), h = h.sibling;
  }
  function CE(d, h) {
    var b = d.alternate, T = d.flags;
    switch (d.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (ro(h, d), xl(d), T & 4) {
          try {
            Vf(3, d, d.return), lv(3, d);
          } catch (Vt) {
            mi(d, d.return, Vt);
          }
          try {
            Vf(5, d, d.return);
          } catch (Vt) {
            mi(d, d.return, Vt);
          }
        }
        break;
      case 1:
        ro(h, d), xl(d), T & 512 && b !== null && zf(b, b.return);
        break;
      case 5:
        if (ro(h, d), xl(d), T & 512 && b !== null && zf(b, b.return), d.flags & 32) {
          var P = d.stateNode;
          try {
            ne(P, "");
          } catch (Vt) {
            mi(d, d.return, Vt);
          }
        }
        if (T & 4 && (P = d.stateNode, P != null)) {
          var V = d.memoizedProps, te = b !== null ? b.memoizedProps : V, me = d.type, xe = d.updateQueue;
          if (d.updateQueue = null, xe !== null) try {
            me === "input" && V.type === "radio" && V.name != null && Pn(P, V), kt(me, te);
            var He = kt(me, V);
            for (te = 0; te < xe.length; te += 2) {
              var at = xe[te], ut = xe[te + 1];
              at === "style" ? Ce(P, ut) : at === "dangerouslySetInnerHTML" ? br(P, ut) : at === "children" ? ne(P, ut) : D(P, at, ut, He);
            }
            switch (me) {
              case "input":
                Fn(P, V);
                break;
              case "textarea":
                gr(P, V);
                break;
              case "select":
                var rt = P._wrapperState.wasMultiple;
                P._wrapperState.wasMultiple = !!V.multiple;
                var _t = V.value;
                _t != null ? Cr(P, !!V.multiple, _t, !1) : rt !== !!V.multiple && (V.defaultValue != null ? Cr(
                  P,
                  !!V.multiple,
                  V.defaultValue,
                  !0
                ) : Cr(P, !!V.multiple, V.multiple ? [] : "", !1));
            }
            P[rd] = V;
          } catch (Vt) {
            mi(d, d.return, Vt);
          }
        }
        break;
      case 6:
        if (ro(h, d), xl(d), T & 4) {
          if (d.stateNode === null) throw Error(n(162));
          P = d.stateNode, V = d.memoizedProps;
          try {
            P.nodeValue = V;
          } catch (Vt) {
            mi(d, d.return, Vt);
          }
        }
        break;
      case 3:
        if (ro(h, d), xl(d), T & 4 && b !== null && b.memoizedState.isDehydrated) try {
          Qs(h.containerInfo);
        } catch (Vt) {
          mi(d, d.return, Vt);
        }
        break;
      case 4:
        ro(h, d), xl(d);
        break;
      case 13:
        ro(h, d), xl(d), P = d.child, P.flags & 8192 && (V = P.memoizedState !== null, P.stateNode.isHidden = V, !V || P.alternate !== null && P.alternate.memoizedState !== null || (dv = tn())), T & 4 && qf(d);
        break;
      case 22:
        if (at = b !== null && b.memoizedState !== null, d.mode & 1 ? (vo = (He = vo) || at, ro(h, d), vo = He) : ro(h, d), xl(d), T & 8192) {
          if (He = d.memoizedState !== null, (d.stateNode.isHidden = He) && !at && d.mode & 1) for (Mt = d, at = d.child; at !== null; ) {
            for (ut = Mt = at; Mt !== null; ) {
              switch (rt = Mt, _t = rt.child, rt.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Vf(4, rt, rt.return);
                  break;
                case 1:
                  zf(rt, rt.return);
                  var Lt = rt.stateNode;
                  if (typeof Lt.componentWillUnmount == "function") {
                    T = rt, b = rt.return;
                    try {
                      h = T, Lt.props = h.memoizedProps, Lt.state = h.memoizedState, Lt.componentWillUnmount();
                    } catch (Vt) {
                      mi(T, b, Vt);
                    }
                  }
                  break;
                case 5:
                  zf(rt, rt.return);
                  break;
                case 22:
                  if (rt.memoizedState !== null) {
                    xE(ut);
                    continue;
                  }
              }
              _t !== null ? (_t.return = rt, Mt = _t) : xE(ut);
            }
            at = at.sibling;
          }
          e: for (at = null, ut = d; ; ) {
            if (ut.tag === 5) {
              if (at === null) {
                at = ut;
                try {
                  P = ut.stateNode, He ? (V = P.style, typeof V.setProperty == "function" ? V.setProperty("display", "none", "important") : V.display = "none") : (me = ut.stateNode, xe = ut.memoizedProps.style, te = xe != null && xe.hasOwnProperty("display") ? xe.display : null, me.style.display = le("display", te));
                } catch (Vt) {
                  mi(d, d.return, Vt);
                }
              }
            } else if (ut.tag === 6) {
              if (at === null) try {
                ut.stateNode.nodeValue = He ? "" : ut.memoizedProps;
              } catch (Vt) {
                mi(d, d.return, Vt);
              }
            } else if ((ut.tag !== 22 && ut.tag !== 23 || ut.memoizedState === null || ut === d) && ut.child !== null) {
              ut.child.return = ut, ut = ut.child;
              continue;
            }
            if (ut === d) break e;
            for (; ut.sibling === null; ) {
              if (ut.return === null || ut.return === d) break e;
              at === ut && (at = null), ut = ut.return;
            }
            at === ut && (at = null), ut.sibling.return = ut.return, ut = ut.sibling;
          }
        }
        break;
      case 19:
        ro(h, d), xl(d), T & 4 && qf(d);
        break;
      case 21:
        break;
      default:
        ro(
          h,
          d
        ), xl(d);
    }
  }
  function xl(d) {
    var h = d.flags;
    if (h & 2) {
      try {
        e: {
          for (var b = d.return; b !== null; ) {
            if (F0(b)) {
              var T = b;
              break e;
            }
            b = b.return;
          }
          throw Error(n(160));
        }
        switch (T.tag) {
          case 5:
            var P = T.stateNode;
            T.flags & 32 && (ne(P, ""), T.flags &= -33);
            var V = wE(d);
            $f(d, V, P);
            break;
          case 3:
          case 4:
            var te = T.stateNode.containerInfo, me = wE(d);
            Vp(d, me, te);
            break;
          default:
            throw Error(n(161));
        }
      } catch (xe) {
        mi(d, d.return, xe);
      }
      d.flags &= -3;
    }
    h & 4096 && (d.flags &= -4097);
  }
  function kT(d, h, b) {
    Mt = d, U0(d);
  }
  function U0(d, h, b) {
    for (var T = (d.mode & 1) !== 0; Mt !== null; ) {
      var P = Mt, V = P.child;
      if (P.tag === 22 && T) {
        var te = P.memoizedState !== null || Uf;
        if (!te) {
          var me = P.alternate, xe = me !== null && me.memoizedState !== null || vo;
          me = Uf;
          var He = vo;
          if (Uf = te, (vo = xe) && !He) for (Mt = P; Mt !== null; ) te = Mt, xe = te.child, te.tag === 22 && te.memoizedState !== null ? z0(P) : xe !== null ? (xe.return = te, Mt = xe) : z0(P);
          for (; V !== null; ) Mt = V, U0(V), V = V.sibling;
          Mt = P, Uf = me, vo = He;
        }
        Wf(d);
      } else P.subtreeFlags & 8772 && V !== null ? (V.return = P, Mt = V) : Wf(d);
    }
  }
  function Wf(d) {
    for (; Mt !== null; ) {
      var h = Mt;
      if (h.flags & 8772) {
        var b = h.alternate;
        try {
          if (h.flags & 8772) switch (h.tag) {
            case 0:
            case 11:
            case 15:
              vo || lv(5, h);
              break;
            case 1:
              var T = h.stateNode;
              if (h.flags & 4 && !vo) if (b === null) T.componentDidMount();
              else {
                var P = h.elementType === h.type ? b.memoizedProps : va(h.type, b.memoizedProps);
                T.componentDidUpdate(P, b.memoizedState, T.__reactInternalSnapshotBeforeUpdate);
              }
              var V = h.updateQueue;
              V !== null && oE(h, V, T);
              break;
            case 3:
              var te = h.updateQueue;
              if (te !== null) {
                if (b = null, h.child !== null) switch (h.child.tag) {
                  case 5:
                    b = h.child.stateNode;
                    break;
                  case 1:
                    b = h.child.stateNode;
                }
                oE(h, te, b);
              }
              break;
            case 5:
              var me = h.stateNode;
              if (b === null && h.flags & 4) {
                b = me;
                var xe = h.memoizedProps;
                switch (h.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    xe.autoFocus && b.focus();
                    break;
                  case "img":
                    xe.src && (b.src = xe.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (h.memoizedState === null) {
                var He = h.alternate;
                if (He !== null) {
                  var at = He.memoizedState;
                  if (at !== null) {
                    var ut = at.dehydrated;
                    ut !== null && Qs(ut);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(n(163));
          }
          vo || h.flags & 512 && cv(h);
        } catch (rt) {
          mi(h, h.return, rt);
        }
      }
      if (h === d) {
        Mt = null;
        break;
      }
      if (b = h.sibling, b !== null) {
        b.return = h.return, Mt = b;
        break;
      }
      Mt = h.return;
    }
  }
  function xE(d) {
    for (; Mt !== null; ) {
      var h = Mt;
      if (h === d) {
        Mt = null;
        break;
      }
      var b = h.sibling;
      if (b !== null) {
        b.return = h.return, Mt = b;
        break;
      }
      Mt = h.return;
    }
  }
  function z0(d) {
    for (; Mt !== null; ) {
      var h = Mt;
      try {
        switch (h.tag) {
          case 0:
          case 11:
          case 15:
            var b = h.return;
            try {
              lv(4, h);
            } catch (xe) {
              mi(h, b, xe);
            }
            break;
          case 1:
            var T = h.stateNode;
            if (typeof T.componentDidMount == "function") {
              var P = h.return;
              try {
                T.componentDidMount();
              } catch (xe) {
                mi(h, P, xe);
              }
            }
            var V = h.return;
            try {
              cv(h);
            } catch (xe) {
              mi(h, V, xe);
            }
            break;
          case 5:
            var te = h.return;
            try {
              cv(h);
            } catch (xe) {
              mi(h, te, xe);
            }
        }
      } catch (xe) {
        mi(h, h.return, xe);
      }
      if (h === d) {
        Mt = null;
        break;
      }
      var me = h.sibling;
      if (me !== null) {
        me.return = h.return, Mt = me;
        break;
      }
      Mt = h.return;
    }
  }
  var AT = Math.ceil, md = M.ReactCurrentDispatcher, uv = M.ReactCurrentOwner, Ss = M.ReactCurrentBatchConfig, Xn = 0, pi = null, Gr = null, zi = 0, wa = 0, Gf = Bn(0), Vi = 0, $p = null, yd = 0, Kf = 0, V0 = 0, fu = null, Fo = null, dv = 0, Yf = 1 / 0, bc = null, fv = !1, $0 = null, ks = null, Qf = !1, As = null, hv = 0, Hp = 0, pv = null, qp = -1, vd = 0;
  function io() {
    return Xn & 6 ? tn() : qp !== -1 ? qp : qp = tn();
  }
  function wc(d) {
    return d.mode & 1 ? Xn & 2 && zi !== 0 ? zi & -zi : Dy.transition !== null ? (vd === 0 && (vd = Qc()), vd) : (d = nr, d !== 0 || (d = window.event, d = d === void 0 ? 16 : Sr(d.type)), d) : 1;
  }
  function ai(d, h, b, T) {
    if (50 < Hp) throw Hp = 0, pv = null, Error(n(185));
    Gs(d, b, T), (!(Xn & 2) || d !== pi) && (d === pi && (!(Xn & 2) && (Kf |= b), Vi === 4 && El(d, zi)), $i(d, T), b === 1 && Xn === 0 && !(h.mode & 1) && (Yf = tn() + 500, to && fa()));
  }
  function $i(d, h) {
    var b = d.callbackNode;
    us(d, h);
    var T = po(d, d === pi ? zi : 0);
    if (T === 0) b !== null && on(b), d.callbackNode = null, d.callbackPriority = 0;
    else if (h = T & -T, d.callbackPriority !== h) {
      if (b != null && on(b), h === 1) d.tag === 0 ? C0(Xf.bind(null, d)) : w0(Xf.bind(null, d)), v0(function() {
        !(Xn & 6) && fa();
      }), b = null;
      else {
        switch (Xc(T)) {
          case 1:
            b = xr;
            break;
          case 4:
            b = vn;
            break;
          case 16:
            b = ii;
            break;
          case 536870912:
            b = Xi;
            break;
          default:
            b = ii;
        }
        b = OE(b, mv.bind(null, d));
      }
      d.callbackPriority = h, d.callbackNode = b;
    }
  }
  function mv(d, h) {
    if (qp = -1, vd = 0, Xn & 6) throw Error(n(327));
    var b = d.callbackNode;
    if (Jf() && d.callbackNode !== b) return null;
    var T = po(d, d === pi ? zi : 0);
    if (T === 0) return null;
    if (T & 30 || T & d.expiredLanes || h) h = vv(d, T);
    else {
      h = T;
      var P = Xn;
      Xn |= 2;
      var V = SE();
      (pi !== d || zi !== h) && (bc = null, Yf = tn() + 500, bd(d, h));
      do
        try {
          _T();
          break;
        } catch (me) {
          EE(d, me);
        }
      while (!0);
      Ha(), md.current = V, Xn = P, Gr !== null ? h = 0 : (pi = null, zi = 0, h = Vi);
    }
    if (h !== 0) {
      if (h === 2 && (P = yl(d), P !== 0 && (T = P, h = gd(d, P))), h === 1) throw b = $p, bd(d, 0), El(d, T), $i(d, tn()), b;
      if (h === 6) El(d, T);
      else {
        if (P = d.current.alternate, !(T & 30) && !q0(P) && (h = vv(d, T), h === 2 && (V = yl(d), V !== 0 && (T = V, h = gd(d, V))), h === 1)) throw b = $p, bd(d, 0), El(d, T), $i(d, tn()), b;
        switch (d.finishedWork = P, d.finishedLanes = T, h) {
          case 0:
          case 1:
            throw Error(n(345));
          case 2:
            hu(d, Fo, bc);
            break;
          case 3:
            if (El(d, T), (T & 130023424) === T && (h = dv + 500 - tn(), 10 < h)) {
              if (po(d, 0) !== 0) break;
              if (P = d.suspendedLanes, (P & T) !== T) {
                io(), d.pingedLanes |= d.suspendedLanes & P;
                break;
              }
              d.timeoutHandle = nd(hu.bind(null, d, Fo, bc), h);
              break;
            }
            hu(d, Fo, bc);
            break;
          case 4:
            if (El(d, T), (T & 4194240) === T) break;
            for (h = d.eventTimes, P = -1; 0 < T; ) {
              var te = 31 - Zt(T);
              V = 1 << te, te = h[te], te > P && (P = te), T &= ~V;
            }
            if (T = P, T = tn() - T, T = (120 > T ? 120 : 480 > T ? 480 : 1080 > T ? 1080 : 1920 > T ? 1920 : 3e3 > T ? 3e3 : 4320 > T ? 4320 : 1960 * AT(T / 1960)) - T, 10 < T) {
              d.timeoutHandle = nd(hu.bind(null, d, Fo, bc), T);
              break;
            }
            hu(d, Fo, bc);
            break;
          case 5:
            hu(d, Fo, bc);
            break;
          default:
            throw Error(n(329));
        }
      }
    }
    return $i(d, tn()), d.callbackNode === b ? mv.bind(null, d) : null;
  }
  function gd(d, h) {
    var b = fu;
    return d.current.memoizedState.isDehydrated && (bd(d, h).flags |= 256), d = vv(d, h), d !== 2 && (h = Fo, Fo = b, h !== null && H0(h)), d;
  }
  function H0(d) {
    Fo === null ? Fo = d : Fo.push.apply(Fo, d);
  }
  function q0(d) {
    for (var h = d; ; ) {
      if (h.flags & 16384) {
        var b = h.updateQueue;
        if (b !== null && (b = b.stores, b !== null)) for (var T = 0; T < b.length; T++) {
          var P = b[T], V = P.getSnapshot;
          P = P.value;
          try {
            if (!ps(V(), P)) return !1;
          } catch {
            return !1;
          }
        }
      }
      if (b = h.child, h.subtreeFlags & 16384 && b !== null) b.return = h, h = b;
      else {
        if (h === d) break;
        for (; h.sibling === null; ) {
          if (h.return === null || h.return === d) return !0;
          h = h.return;
        }
        h.sibling.return = h.return, h = h.sibling;
      }
    }
    return !0;
  }
  function El(d, h) {
    for (h &= ~V0, h &= ~Kf, d.suspendedLanes |= h, d.pingedLanes &= ~h, d = d.expirationTimes; 0 < h; ) {
      var b = 31 - Zt(h), T = 1 << b;
      d[b] = -1, h &= ~T;
    }
  }
  function Xf(d) {
    if (Xn & 6) throw Error(n(327));
    Jf();
    var h = po(d, 0);
    if (!(h & 1)) return $i(d, tn()), null;
    var b = vv(d, h);
    if (d.tag !== 0 && b === 2) {
      var T = yl(d);
      T !== 0 && (h = T, b = gd(d, T));
    }
    if (b === 1) throw b = $p, bd(d, 0), El(d, h), $i(d, tn()), b;
    if (b === 6) throw Error(n(345));
    return d.finishedWork = d.current.alternate, d.finishedLanes = h, hu(d, Fo, bc), $i(d, tn()), null;
  }
  function W0(d, h) {
    var b = Xn;
    Xn |= 1;
    try {
      return d(h);
    } finally {
      Xn = b, Xn === 0 && (Yf = tn() + 500, to && fa());
    }
  }
  function Sl(d) {
    As !== null && As.tag === 0 && !(Xn & 6) && Jf();
    var h = Xn;
    Xn |= 1;
    var b = Ss.transition, T = nr;
    try {
      if (Ss.transition = null, nr = 1, d) return d();
    } finally {
      nr = T, Ss.transition = b, Xn = h, !(Xn & 6) && fa();
    }
  }
  function yv() {
    wa = Gf.current, wr(Gf);
  }
  function bd(d, h) {
    d.finishedWork = null, d.finishedLanes = 0;
    var b = d.timeoutHandle;
    if (b !== -1 && (d.timeoutHandle = -1, Qx(b)), Gr !== null) for (b = Gr.return; b !== null; ) {
      var T = b;
      switch (E0(T), T.tag) {
        case 1:
          T = T.type.childContextTypes, T != null && vs();
          break;
        case 3:
          Rf(), wr(fi), wr(Sn), O0();
          break;
        case 5:
          R0(T);
          break;
        case 4:
          Rf();
          break;
        case 13:
          wr(Zr);
          break;
        case 19:
          wr(Zr);
          break;
        case 10:
          A0(T.type._context);
          break;
        case 22:
        case 23:
          yv();
      }
      b = b.return;
    }
    if (pi = d, Gr = d = pu(d.current, null), zi = wa = h, Vi = 0, $p = null, V0 = Kf = yd = 0, Fo = fu = null, ad !== null) {
      for (h = 0; h < ad.length; h++) if (b = ad[h], T = b.interleaved, T !== null) {
        b.interleaved = null;
        var P = T.next, V = b.pending;
        if (V !== null) {
          var te = V.next;
          V.next = P, T.next = te;
        }
        b.pending = T;
      }
      ad = null;
    }
    return d;
  }
  function EE(d, h) {
    do {
      var b = Gr;
      try {
        if (Ha(), Fy.current = Lo, qa) {
          for (var T = Xt.memoizedState; T !== null; ) {
            var P = T.queue;
            P !== null && (P.pending = null), T = T.next;
          }
          qa = !1;
        }
        if (Gt = 0, Kn = kn = Xt = null, Of = !1, Mp = 0, uv.current = null, b === null || b.return === null) {
          Vi = 1, $p = h, Gr = null;
          break;
        }
        e: {
          var V = d, te = b.return, me = b, xe = h;
          if (h = zi, me.flags |= 32768, xe !== null && typeof xe == "object" && typeof xe.then == "function") {
            var He = xe, at = me, ut = at.tag;
            if (!(at.mode & 1) && (ut === 0 || ut === 11 || ut === 15)) {
              var rt = at.alternate;
              rt ? (at.updateQueue = rt.updateQueue, at.memoizedState = rt.memoizedState, at.lanes = rt.lanes) : (at.updateQueue = null, at.memoizedState = null);
            }
            var _t = pE(te);
            if (_t !== null) {
              _t.flags &= -257, N0(_t, te, me, V, h), _t.mode & 1 && jp(V, He, h), h = _t, xe = He;
              var Lt = h.updateQueue;
              if (Lt === null) {
                var Vt = /* @__PURE__ */ new Set();
                Vt.add(xe), h.updateQueue = Vt;
              } else Lt.add(xe);
              break e;
            } else {
              if (!(h & 1)) {
                jp(V, He, h), Wp();
                break e;
              }
              xe = Error(n(426));
            }
          } else if (Wr && me.mode & 1) {
            var ki = pE(te);
            if (ki !== null) {
              !(ki.flags & 65536) && (ki.flags |= 256), N0(ki, te, me, V, h), k0(uu(xe, me));
              break e;
            }
          }
          V = xe = uu(xe, me), Vi !== 4 && (Vi = 2), fu === null ? fu = [V] : fu.push(V), V = te;
          do {
            switch (V.tag) {
              case 3:
                V.flags |= 65536, h &= -h, V.lanes |= h;
                var Ne = fE(V, xe, h);
                iE(V, Ne);
                break e;
              case 1:
                me = xe;
                var Oe = V.type, Ue = V.stateNode;
                if (!(V.flags & 128) && (typeof Oe.getDerivedStateFromError == "function" || Ue !== null && typeof Ue.componentDidCatch == "function" && (ks === null || !ks.has(Ue)))) {
                  V.flags |= 65536, h &= -h, V.lanes |= h;
                  var ht = hE(V, me, h);
                  iE(V, ht);
                  break e;
                }
            }
            V = V.return;
          } while (V !== null);
        }
        AE(b);
      } catch (Kt) {
        h = Kt, Gr === b && b !== null && (Gr = b = b.return);
        continue;
      }
      break;
    } while (!0);
  }
  function SE() {
    var d = md.current;
    return md.current = Lo, d === null ? Lo : d;
  }
  function Wp() {
    (Vi === 0 || Vi === 3 || Vi === 2) && (Vi = 4), pi === null || !(yd & 268435455) && !(Kf & 268435455) || El(pi, zi);
  }
  function vv(d, h) {
    var b = Xn;
    Xn |= 2;
    var T = SE();
    (pi !== d || zi !== h) && (bc = null, bd(d, h));
    do
      try {
        TT();
        break;
      } catch (P) {
        EE(d, P);
      }
    while (!0);
    if (Ha(), Xn = b, md.current = T, Gr !== null) throw Error(n(261));
    return pi = null, zi = 0, Vi;
  }
  function TT() {
    for (; Gr !== null; ) kE(Gr);
  }
  function _T() {
    for (; Gr !== null && !pn(); ) kE(Gr);
  }
  function kE(d) {
    var h = RE(d.alternate, d, wa);
    d.memoizedProps = d.pendingProps, h === null ? AE(d) : Gr = h, uv.current = null;
  }
  function AE(d) {
    var h = d;
    do {
      var b = h.alternate;
      if (d = h.return, h.flags & 32768) {
        if (b = ET(b, h), b !== null) {
          b.flags &= 32767, Gr = b;
          return;
        }
        if (d !== null) d.flags |= 32768, d.subtreeFlags = 0, d.deletions = null;
        else {
          Vi = 6, Gr = null;
          return;
        }
      } else if (b = xT(b, h, wa), b !== null) {
        Gr = b;
        return;
      }
      if (h = h.sibling, h !== null) {
        Gr = h;
        return;
      }
      Gr = h = d;
    } while (h !== null);
    Vi === 0 && (Vi = 5);
  }
  function hu(d, h, b) {
    var T = nr, P = Ss.transition;
    try {
      Ss.transition = null, nr = 1, RT(d, h, b, T);
    } finally {
      Ss.transition = P, nr = T;
    }
    return null;
  }
  function RT(d, h, b, T) {
    do
      Jf();
    while (As !== null);
    if (Xn & 6) throw Error(n(327));
    b = d.finishedWork;
    var P = d.finishedLanes;
    if (b === null) return null;
    if (d.finishedWork = null, d.finishedLanes = 0, b === d.current) throw Error(n(177));
    d.callbackNode = null, d.callbackPriority = 0;
    var V = b.lanes | b.childLanes;
    if (hp(d, V), d === pi && (Gr = pi = null, zi = 0), !(b.subtreeFlags & 2064) && !(b.flags & 2064) || Qf || (Qf = !0, OE(ii, function() {
      return Jf(), null;
    })), V = (b.flags & 15990) !== 0, b.subtreeFlags & 15990 || V) {
      V = Ss.transition, Ss.transition = null;
      var te = nr;
      nr = 1;
      var me = Xn;
      Xn |= 4, uv.current = null, ST(d, b), CE(b, d), Cy(td), fe = !!m0, td = m0 = null, d.current = b, kT(b), sr(), Xn = me, nr = te, Ss.transition = V;
    } else d.current = b;
    if (Qf && (Qf = !1, As = d, hv = P), V = d.pendingLanes, V === 0 && (ks = null), cs(b.stateNode), $i(d, tn()), h !== null) for (T = d.onRecoverableError, b = 0; b < h.length; b++) P = h[b], T(P.value, { componentStack: P.stack, digest: P.digest });
    if (fv) throw fv = !1, d = $0, $0 = null, d;
    return hv & 1 && d.tag !== 0 && Jf(), V = d.pendingLanes, V & 1 ? d === pv ? Hp++ : (Hp = 0, pv = d) : Hp = 0, fa(), null;
  }
  function Jf() {
    if (As !== null) {
      var d = Xc(hv), h = Ss.transition, b = nr;
      try {
        if (Ss.transition = null, nr = 16 > d ? 16 : d, As === null) var T = !1;
        else {
          if (d = As, As = null, hv = 0, Xn & 6) throw Error(n(331));
          var P = Xn;
          for (Xn |= 4, Mt = d.current; Mt !== null; ) {
            var V = Mt, te = V.child;
            if (Mt.flags & 16) {
              var me = V.deletions;
              if (me !== null) {
                for (var xe = 0; xe < me.length; xe++) {
                  var He = me[xe];
                  for (Mt = He; Mt !== null; ) {
                    var at = Mt;
                    switch (at.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Vf(8, at, V);
                    }
                    var ut = at.child;
                    if (ut !== null) ut.return = at, Mt = ut;
                    else for (; Mt !== null; ) {
                      at = Mt;
                      var rt = at.sibling, _t = at.return;
                      if (bE(at), at === He) {
                        Mt = null;
                        break;
                      }
                      if (rt !== null) {
                        rt.return = _t, Mt = rt;
                        break;
                      }
                      Mt = _t;
                    }
                  }
                }
                var Lt = V.alternate;
                if (Lt !== null) {
                  var Vt = Lt.child;
                  if (Vt !== null) {
                    Lt.child = null;
                    do {
                      var ki = Vt.sibling;
                      Vt.sibling = null, Vt = ki;
                    } while (Vt !== null);
                  }
                }
                Mt = V;
              }
            }
            if (V.subtreeFlags & 2064 && te !== null) te.return = V, Mt = te;
            else e: for (; Mt !== null; ) {
              if (V = Mt, V.flags & 2048) switch (V.tag) {
                case 0:
                case 11:
                case 15:
                  Vf(9, V, V.return);
              }
              var Ne = V.sibling;
              if (Ne !== null) {
                Ne.return = V.return, Mt = Ne;
                break e;
              }
              Mt = V.return;
            }
          }
          var Oe = d.current;
          for (Mt = Oe; Mt !== null; ) {
            te = Mt;
            var Ue = te.child;
            if (te.subtreeFlags & 2064 && Ue !== null) Ue.return = te, Mt = Ue;
            else e: for (te = Oe; Mt !== null; ) {
              if (me = Mt, me.flags & 2048) try {
                switch (me.tag) {
                  case 0:
                  case 11:
                  case 15:
                    lv(9, me);
                }
              } catch (Kt) {
                mi(me, me.return, Kt);
              }
              if (me === te) {
                Mt = null;
                break e;
              }
              var ht = me.sibling;
              if (ht !== null) {
                ht.return = me.return, Mt = ht;
                break e;
              }
              Mt = me.return;
            }
          }
          if (Xn = P, fa(), Ci && typeof Ci.onPostCommitFiberRoot == "function") try {
            Ci.onPostCommitFiberRoot(Po, d);
          } catch {
          }
          T = !0;
        }
        return T;
      } finally {
        nr = b, Ss.transition = h;
      }
    }
    return !1;
  }
  function TE(d, h, b) {
    h = uu(b, h), h = fE(d, h, 1), d = lu(d, h, 1), h = io(), d !== null && (Gs(d, 1, h), $i(d, h));
  }
  function mi(d, h, b) {
    if (d.tag === 3) TE(d, d, b);
    else for (; h !== null; ) {
      if (h.tag === 3) {
        TE(h, d, b);
        break;
      } else if (h.tag === 1) {
        var T = h.stateNode;
        if (typeof h.type.getDerivedStateFromError == "function" || typeof T.componentDidCatch == "function" && (ks === null || !ks.has(T))) {
          d = uu(b, d), d = hE(h, d, 1), h = lu(h, d, 1), d = io(), h !== null && (Gs(h, 1, d), $i(h, d));
          break;
        }
      }
      h = h.return;
    }
  }
  function OT(d, h, b) {
    var T = d.pingCache;
    T !== null && T.delete(h), h = io(), d.pingedLanes |= d.suspendedLanes & b, pi === d && (zi & b) === b && (Vi === 4 || Vi === 3 && (zi & 130023424) === zi && 500 > tn() - dv ? bd(d, 0) : V0 |= b), $i(d, h);
  }
  function _E(d, h) {
    h === 0 && (d.mode & 1 ? (h = Fa, Fa <<= 1, !(Fa & 130023424) && (Fa = 4194304)) : h = 1);
    var b = io();
    d = yc(d, h), d !== null && (Gs(d, h, b), $i(d, b));
  }
  function G0(d) {
    var h = d.memoizedState, b = 0;
    h !== null && (b = h.retryLane), _E(d, b);
  }
  function IT(d, h) {
    var b = 0;
    switch (d.tag) {
      case 13:
        var T = d.stateNode, P = d.memoizedState;
        P !== null && (b = P.retryLane);
        break;
      case 19:
        T = d.stateNode;
        break;
      default:
        throw Error(n(314));
    }
    T !== null && T.delete(h), _E(d, b);
  }
  var RE;
  RE = function(d, h, b) {
    if (d !== null) if (d.memoizedProps !== h.pendingProps || fi.current) ga = !0;
    else {
      if (!(d.lanes & b) && !(h.flags & 128)) return ga = !1, gc(d, h, b);
      ga = !!(d.flags & 131072);
    }
    else ga = !1, Wr && h.flags & 1048576 && x0(h, Sf, h.index);
    switch (h.lanes = 0, h.tag) {
      case 2:
        var T = h.type;
        zp(d, h), d = h.pendingProps;
        var P = ys(h, Sn.current);
        Af(h, b), P = nt(null, h, T, d, P, b);
        var V = Ii();
        return h.flags |= 1, typeof P == "object" && P !== null && typeof P.render == "function" && P.$$typeof === void 0 ? (h.tag = 1, h.memoizedState = null, h.updateQueue = null, Jr(T) ? (V = !0, Ty(h)) : V = !1, h.memoizedState = P.state !== null && P.state !== void 0 ? P.state : null, Py(h), P.updater = fd, h.stateNode = P, P._reactInternals = h, M0(h, T, d, b), h = nv(null, h, T, !0, V, b)) : (h.tag = 0, Wr && V && _y(h), Ei(null, h, P, b), h = h.child), h;
      case 16:
        T = h.elementType;
        e: {
          switch (zp(d, h), d = h.pendingProps, P = T._init, T = P(T._payload), h.type = T, P = h.tag = DT(T), d = va(T, d), P) {
            case 0:
              h = Mn(null, h, T, d, b);
              break e;
            case 1:
              h = Fp(null, h, T, d, b);
              break e;
            case 11:
              h = Lf(null, h, T, d, b);
              break e;
            case 14:
              h = du(null, h, T, va(T.type, d), b);
              break e;
          }
          throw Error(n(
            306,
            T,
            ""
          ));
        }
        return h;
      case 0:
        return T = h.type, P = h.pendingProps, P = h.elementType === T ? P : va(T, P), Mn(d, h, T, P, b);
      case 1:
        return T = h.type, P = h.pendingProps, P = h.elementType === T ? P : va(T, P), Fp(d, h, T, P, b);
      case 3:
        e: {
          if (CT(h), d === null) throw Error(n(387));
          T = h.pendingProps, V = h.memoizedState, P = V.element, Tf(d, h), By(h, T, null, b);
          var te = h.memoizedState;
          if (T = te.element, V.isDehydrated) if (V = { element: T, isDehydrated: !1, cache: te.cache, pendingSuspenseBoundaries: te.pendingSuspenseBoundaries, transitions: te.transitions }, h.updateQueue.baseState = V, h.memoizedState = V, h.flags & 256) {
            P = uu(Error(n(423)), h), h = yE(d, h, T, b, P);
            break e;
          } else if (T !== P) {
            P = uu(Error(n(424)), h), h = yE(d, h, T, b, P);
            break e;
          } else for (ma = tl(h.stateNode.containerInfo.firstChild), $a = h, Wr = !0, bs = null, b = nE(h, null, T, b), h.child = b; b; ) b.flags = b.flags & -3 | 4096, b = b.sibling;
          else {
            if (oi(), T === P) {
              h = Si(d, h, b);
              break e;
            }
            Ei(d, h, T, b);
          }
          h = h.child;
        }
        return h;
      case 5:
        return aE(h), d === null && Oy(h), T = h.type, P = h.pendingProps, V = d !== null ? d.memoizedProps : null, te = P.children, kp(T, P) ? te = null : V !== null && kp(T, V) && (h.flags |= 32), hd(d, h), Ei(d, h, te, b), h.child;
      case 6:
        return d === null && Oy(h), null;
      case 13:
        return vE(d, h, b);
      case 4:
        return _0(h, h.stateNode.containerInfo), T = h.pendingProps, d === null ? h.child = kf(h, null, T, b) : Ei(d, h, T, b), h.child;
      case 11:
        return T = h.type, P = h.pendingProps, P = h.elementType === T ? P : va(T, P), Lf(d, h, T, P, b);
      case 7:
        return Ei(d, h, h.pendingProps, b), h.child;
      case 8:
        return Ei(d, h, h.pendingProps.children, b), h.child;
      case 12:
        return Ei(d, h, h.pendingProps.children, b), h.child;
      case 10:
        e: {
          if (T = h.type._context, P = h.pendingProps, V = h.memoizedProps, te = P.value, kr(mc, T._currentValue), T._currentValue = te, V !== null) if (ps(V.value, te)) {
            if (V.children === P.children && !fi.current) {
              h = Si(d, h, b);
              break e;
            }
          } else for (V = h.child, V !== null && (V.return = h); V !== null; ) {
            var me = V.dependencies;
            if (me !== null) {
              te = V.child;
              for (var xe = me.firstContext; xe !== null; ) {
                if (xe.context === T) {
                  if (V.tag === 1) {
                    xe = ya(-1, b & -b), xe.tag = 2;
                    var He = V.updateQueue;
                    if (He !== null) {
                      He = He.shared;
                      var at = He.pending;
                      at === null ? xe.next = xe : (xe.next = at.next, at.next = xe), He.pending = xe;
                    }
                  }
                  V.lanes |= b, xe = V.alternate, xe !== null && (xe.lanes |= b), T0(
                    V.return,
                    b,
                    h
                  ), me.lanes |= b;
                  break;
                }
                xe = xe.next;
              }
            } else if (V.tag === 10) te = V.type === h.type ? null : V.child;
            else if (V.tag === 18) {
              if (te = V.return, te === null) throw Error(n(341));
              te.lanes |= b, me = te.alternate, me !== null && (me.lanes |= b), T0(te, b, h), te = V.sibling;
            } else te = V.child;
            if (te !== null) te.return = V;
            else for (te = V; te !== null; ) {
              if (te === h) {
                te = null;
                break;
              }
              if (V = te.sibling, V !== null) {
                V.return = te.return, te = V;
                break;
              }
              te = te.return;
            }
            V = te;
          }
          Ei(d, h, P.children, b), h = h.child;
        }
        return h;
      case 9:
        return P = h.type, T = h.pendingProps.children, Af(h, b), P = Cs(P), T = T(P), h.flags |= 1, Ei(d, h, T, b), h.child;
      case 14:
        return T = h.type, P = va(T, h.pendingProps), P = va(T.type, P), du(d, h, T, P, b);
      case 15:
        return tv(d, h, h.type, h.pendingProps, b);
      case 17:
        return T = h.type, P = h.pendingProps, P = h.elementType === T ? P : va(T, P), zp(d, h), h.tag = 1, Jr(T) ? (d = !0, Ty(h)) : d = !1, Af(h, b), cE(h, T, P), M0(h, T, P, b), nv(null, h, T, !0, d, b);
      case 19:
        return L0(d, h, b);
      case 22:
        return ba(d, h, b);
    }
    throw Error(n(156, h.tag));
  };
  function OE(d, h) {
    return Qt(d, h);
  }
  function IE(d, h, b, T) {
    this.tag = d, this.key = b, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = h, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = T, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Ts(d, h, b, T) {
    return new IE(d, h, b, T);
  }
  function K0(d) {
    return d = d.prototype, !(!d || !d.isReactComponent);
  }
  function DT(d) {
    if (typeof d == "function") return K0(d) ? 1 : 0;
    if (d != null) {
      if (d = d.$$typeof, d === Y) return 11;
      if (d === X) return 14;
    }
    return 2;
  }
  function pu(d, h) {
    var b = d.alternate;
    return b === null ? (b = Ts(d.tag, h, d.key, d.mode), b.elementType = d.elementType, b.type = d.type, b.stateNode = d.stateNode, b.alternate = d, d.alternate = b) : (b.pendingProps = h, b.type = d.type, b.flags = 0, b.subtreeFlags = 0, b.deletions = null), b.flags = d.flags & 14680064, b.childLanes = d.childLanes, b.lanes = d.lanes, b.child = d.child, b.memoizedProps = d.memoizedProps, b.memoizedState = d.memoizedState, b.updateQueue = d.updateQueue, h = d.dependencies, b.dependencies = h === null ? null : { lanes: h.lanes, firstContext: h.firstContext }, b.sibling = d.sibling, b.index = d.index, b.ref = d.ref, b;
  }
  function gv(d, h, b, T, P, V) {
    var te = 2;
    if (T = d, typeof d == "function") K0(d) && (te = 1);
    else if (typeof d == "string") te = 5;
    else e: switch (d) {
      case F:
        return wd(b.children, P, V, h);
      case O:
        te = 8, P |= 8;
        break;
      case z:
        return d = Ts(12, b, h, P | 2), d.elementType = z, d.lanes = V, d;
      case ee:
        return d = Ts(13, b, h, P), d.elementType = ee, d.lanes = V, d;
      case ie:
        return d = Ts(19, b, h, P), d.elementType = ie, d.lanes = V, d;
      case J:
        return bv(b, P, V, h);
      default:
        if (typeof d == "object" && d !== null) switch (d.$$typeof) {
          case H:
            te = 10;
            break e;
          case Q:
            te = 9;
            break e;
          case Y:
            te = 11;
            break e;
          case X:
            te = 14;
            break e;
          case Z:
            te = 16, T = null;
            break e;
        }
        throw Error(n(130, d == null ? d : typeof d, ""));
    }
    return h = Ts(te, b, h, P), h.elementType = d, h.type = T, h.lanes = V, h;
  }
  function wd(d, h, b, T) {
    return d = Ts(7, d, T, h), d.lanes = b, d;
  }
  function bv(d, h, b, T) {
    return d = Ts(22, d, T, h), d.elementType = J, d.lanes = b, d.stateNode = { isHidden: !1 }, d;
  }
  function wv(d, h, b) {
    return d = Ts(6, d, null, h), d.lanes = b, d;
  }
  function Gp(d, h, b) {
    return h = Ts(4, d.children !== null ? d.children : [], d.key, h), h.lanes = b, h.stateNode = { containerInfo: d.containerInfo, pendingChildren: null, implementation: d.implementation }, h;
  }
  function Kp(d, h, b, T, P) {
    this.tag = h, this.containerInfo = d, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = oc(0), this.expirationTimes = oc(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = oc(0), this.identifierPrefix = T, this.onRecoverableError = P, this.mutableSourceEagerHydrationData = null;
  }
  function Y0(d, h, b, T, P, V, te, me, xe) {
    return d = new Kp(d, h, b, me, xe), h === 1 ? (h = 1, V === !0 && (h |= 8)) : h = 0, V = Ts(3, null, null, h), d.current = V, V.stateNode = d, V.memoizedState = { element: T, isDehydrated: b, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Py(V), d;
  }
  function DE(d, h, b) {
    var T = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: j, key: T == null ? null : "" + T, children: d, containerInfo: h, implementation: b };
  }
  function Q0(d) {
    if (!d) return bl;
    d = d._reactInternals;
    e: {
      if (Qe(d) !== d || d.tag !== 1) throw Error(n(170));
      var h = d;
      do {
        switch (h.tag) {
          case 3:
            h = h.stateNode.context;
            break e;
          case 1:
            if (Jr(h.type)) {
              h = h.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        h = h.return;
      } while (h !== null);
      throw Error(n(171));
    }
    if (d.tag === 1) {
      var b = d.type;
      if (Jr(b)) return _p(d, b, h);
    }
    return h;
  }
  function X0(d, h, b, T, P, V, te, me, xe) {
    return d = Y0(b, T, !0, d, P, V, te, me, xe), d.context = Q0(null), b = d.current, T = io(), P = wc(b), V = ya(T, P), V.callback = h ?? null, lu(b, V, P), d.current.lanes = P, Gs(d, P, T), $i(d, T), d;
  }
  function Cv(d, h, b, T) {
    var P = h.current, V = io(), te = wc(P);
    return b = Q0(b), h.context === null ? h.context = b : h.pendingContext = b, h = ya(V, te), h.payload = { element: d }, T = T === void 0 ? null : T, T !== null && (h.callback = T), d = lu(P, h, te), d !== null && (ai(d, P, te, V), Ny(d, P, te)), te;
  }
  function Yp(d) {
    if (d = d.current, !d.child) return null;
    switch (d.child.tag) {
      case 5:
        return d.child.stateNode;
      default:
        return d.child.stateNode;
    }
  }
  function ME(d, h) {
    if (d = d.memoizedState, d !== null && d.dehydrated !== null) {
      var b = d.retryLane;
      d.retryLane = b !== 0 && b < h ? b : h;
    }
  }
  function J0(d, h) {
    ME(d, h), (d = d.alternate) && ME(d, h);
  }
  function MT() {
    return null;
  }
  var Z0 = typeof reportError == "function" ? reportError : function(d) {
  };
  function xv(d) {
    this._internalRoot = d;
  }
  Qp.prototype.render = xv.prototype.render = function(d) {
    var h = this._internalRoot;
    if (h === null) throw Error(n(409));
    Cv(d, h, null, null);
  }, Qp.prototype.unmount = xv.prototype.unmount = function() {
    var d = this._internalRoot;
    if (d !== null) {
      this._internalRoot = null;
      var h = d.containerInfo;
      Sl(function() {
        Cv(null, d, null, null);
      }), h[hc] = null;
    }
  };
  function Qp(d) {
    this._internalRoot = d;
  }
  Qp.prototype.unstable_scheduleHydration = function(d) {
    if (d) {
      var h = Zc();
      d = { blockedOn: null, target: d, priority: h };
      for (var b = 0; b < lr.length && h !== 0 && h < lr[b].priority; b++) ;
      lr.splice(b, 0, d), b === 0 && Qu(d);
    }
  };
  function mu(d) {
    return !(!d || d.nodeType !== 1 && d.nodeType !== 9 && d.nodeType !== 11);
  }
  function Ev(d) {
    return !(!d || d.nodeType !== 1 && d.nodeType !== 9 && d.nodeType !== 11 && (d.nodeType !== 8 || d.nodeValue !== " react-mount-point-unstable "));
  }
  function PE() {
  }
  function PT(d, h, b, T, P) {
    if (P) {
      if (typeof T == "function") {
        var V = T;
        T = function() {
          var He = Yp(te);
          V.call(He);
        };
      }
      var te = X0(h, T, d, 0, null, !1, !1, "", PE);
      return d._reactRootContainer = te, d[hc] = te.current, xf(d.nodeType === 8 ? d.parentNode : d), Sl(), te;
    }
    for (; P = d.lastChild; ) d.removeChild(P);
    if (typeof T == "function") {
      var me = T;
      T = function() {
        var He = Yp(xe);
        me.call(He);
      };
    }
    var xe = Y0(d, 0, !1, null, null, !1, !1, "", PE);
    return d._reactRootContainer = xe, d[hc] = xe.current, xf(d.nodeType === 8 ? d.parentNode : d), Sl(function() {
      Cv(h, xe, b, T);
    }), xe;
  }
  function Sv(d, h, b, T, P) {
    var V = b._reactRootContainer;
    if (V) {
      var te = V;
      if (typeof P == "function") {
        var me = P;
        P = function() {
          var xe = Yp(te);
          me.call(xe);
        };
      }
      Cv(h, te, d, P);
    } else te = PT(b, h, d, P, T);
    return Yp(te);
  }
  ac = function(d) {
    switch (d.tag) {
      case 3:
        var h = d.stateNode;
        if (h.current.memoizedState.isDehydrated) {
          var b = Wo(h.pendingLanes);
          b !== 0 && (ds(h, b | 1), $i(h, tn()), !(Xn & 6) && (Yf = tn() + 500, fa()));
        }
        break;
      case 13:
        Sl(function() {
          var T = yc(d, 1);
          if (T !== null) {
            var P = io();
            ai(T, d, 1, P);
          }
        }), J0(d, 1);
    }
  }, Jc = function(d) {
    if (d.tag === 13) {
      var h = yc(d, 134217728);
      if (h !== null) {
        var b = io();
        ai(h, d, 134217728, b);
      }
      J0(d, 134217728);
    }
  }, Hn = function(d) {
    if (d.tag === 13) {
      var h = wc(d), b = yc(d, h);
      if (b !== null) {
        var T = io();
        ai(b, d, h, T);
      }
      J0(d, h);
    }
  }, Zc = function() {
    return nr;
  }, eu = function(d, h) {
    var b = nr;
    try {
      return nr = d, h();
    } finally {
      nr = b;
    }
  }, xn = function(d, h, b) {
    switch (h) {
      case "input":
        if (Fn(d, b), h = b.name, b.type === "radio" && h != null) {
          for (b = d; b.parentNode; ) b = b.parentNode;
          for (b = b.querySelectorAll("input[name=" + JSON.stringify("" + h) + '][type="radio"]'), h = 0; h < b.length; h++) {
            var T = b[h];
            if (T !== d && T.form === d.form) {
              var P = an(T);
              if (!P) throw Error(n(90));
              wn(T), Fn(T, P);
            }
          }
        }
        break;
      case "textarea":
        gr(d, b);
        break;
      case "select":
        h = b.value, h != null && Cr(d, !!b.multiple, h, !1);
    }
  }, la = W0, ja = Sl;
  var NT = { usingClientEntryPoint: !1, Events: [Tp, Ef, an, bi, Do, W0] }, Xp = { findFiberByHostInstance: ms, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, NE = { bundleType: Xp.bundleType, version: Xp.version, rendererPackageName: Xp.rendererPackageName, rendererConfig: Xp.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: M.ReactCurrentDispatcher, findHostInstanceByFiber: function(d) {
    return d = ot(d), d === null ? null : d.stateNode;
  }, findFiberByHostInstance: Xp.findFiberByHostInstance || MT, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var kv = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!kv.isDisabled && kv.supportsFiber) try {
      Po = kv.inject(NE), Ci = kv;
    } catch {
    }
  }
  return Ps.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = NT, Ps.createPortal = function(d, h) {
    var b = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!mu(h)) throw Error(n(200));
    return DE(d, h, null, b);
  }, Ps.createRoot = function(d, h) {
    if (!mu(d)) throw Error(n(299));
    var b = !1, T = "", P = Z0;
    return h != null && (h.unstable_strictMode === !0 && (b = !0), h.identifierPrefix !== void 0 && (T = h.identifierPrefix), h.onRecoverableError !== void 0 && (P = h.onRecoverableError)), h = Y0(d, 1, !1, null, null, b, !1, T, P), d[hc] = h.current, xf(d.nodeType === 8 ? d.parentNode : d), new xv(h);
  }, Ps.findDOMNode = function(d) {
    if (d == null) return null;
    if (d.nodeType === 1) return d;
    var h = d._reactInternals;
    if (h === void 0)
      throw typeof d.render == "function" ? Error(n(188)) : (d = Object.keys(d).join(","), Error(n(268, d)));
    return d = ot(h), d = d === null ? null : d.stateNode, d;
  }, Ps.flushSync = function(d) {
    return Sl(d);
  }, Ps.hydrate = function(d, h, b) {
    if (!Ev(h)) throw Error(n(200));
    return Sv(null, d, h, !0, b);
  }, Ps.hydrateRoot = function(d, h, b) {
    if (!mu(d)) throw Error(n(405));
    var T = b != null && b.hydratedSources || null, P = !1, V = "", te = Z0;
    if (b != null && (b.unstable_strictMode === !0 && (P = !0), b.identifierPrefix !== void 0 && (V = b.identifierPrefix), b.onRecoverableError !== void 0 && (te = b.onRecoverableError)), h = X0(h, null, d, 1, b ?? null, P, !1, V, te), d[hc] = h.current, xf(d), T) for (d = 0; d < T.length; d++) b = T[d], P = b._getVersion, P = P(b._source), h.mutableSourceEagerHydrationData == null ? h.mutableSourceEagerHydrationData = [b, P] : h.mutableSourceEagerHydrationData.push(
      b,
      P
    );
    return new Qp(h);
  }, Ps.render = function(d, h, b) {
    if (!Ev(h)) throw Error(n(200));
    return Sv(null, d, h, !1, b);
  }, Ps.unmountComponentAtNode = function(d) {
    if (!Ev(d)) throw Error(n(40));
    return d._reactRootContainer ? (Sl(function() {
      Sv(null, null, d, !1, function() {
        d._reactRootContainer = null, d[hc] = null;
      });
    }), !0) : !1;
  }, Ps.unstable_batchedUpdates = W0, Ps.unstable_renderSubtreeIntoContainer = function(d, h, b, T) {
    if (!Ev(b)) throw Error(n(200));
    if (d == null || d._reactInternals === void 0) throw Error(n(38));
    return Sv(d, h, b, !1, T);
  }, Ps.version = "18.3.1-next-f1338f8080-20240426", Ps;
}
var Ns = {}, nU;
function hwe() {
  return nU || (nU = 1, ct.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = k, t = MW(), n = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, r = !1;
    function i(a) {
      r = a;
    }
    function o(a) {
      if (!r) {
        for (var l = arguments.length, m = new Array(l > 1 ? l - 1 : 0), g = 1; g < l; g++)
          m[g - 1] = arguments[g];
        c("warn", a, m);
      }
    }
    function s(a) {
      if (!r) {
        for (var l = arguments.length, m = new Array(l > 1 ? l - 1 : 0), g = 1; g < l; g++)
          m[g - 1] = arguments[g];
        c("error", a, m);
      }
    }
    function c(a, l, m) {
      {
        var g = n.ReactDebugCurrentFrame, E = g.getStackAddendum();
        E !== "" && (l += "%s", m = m.concat([E]));
        var _ = m.map(function(B) {
          return String(B);
        });
        _.unshift("Warning: " + l), Function.prototype.apply.call(console[a], console, _);
      }
    }
    var u = 0, f = 1, p = 2, y = 3, v = 4, w = 5, C = 6, x = 7, A = 8, R = 9, I = 10, D = 11, M = 12, L = 13, j = 14, F = 15, O = 16, z = 17, H = 18, Q = 19, Y = 21, ee = 22, ie = 23, X = 24, Z = 25, J = !0, K = !1, oe = !1, be = !1, ce = !1, pe = !0, Ee = !1, Se = !0, Me = !0, Fe = !0, st = !0, mt = /* @__PURE__ */ new Set(), yt = {}, Ut = {};
    function hn(a, l) {
      wn(a, l), wn(a + "Capture", l);
    }
    function wn(a, l) {
      yt[a] && s("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", a), yt[a] = l;
      {
        var m = a.toLowerCase();
        Ut[m] = a, a === "onDoubleClick" && (Ut.ondblclick = a);
      }
      for (var g = 0; g < l.length; g++)
        mt.add(l[g]);
    }
    var Ot = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", xt = Object.prototype.hasOwnProperty;
    function zt(a) {
      {
        var l = typeof Symbol == "function" && Symbol.toStringTag, m = l && a[Symbol.toStringTag] || a.constructor.name || "Object";
        return m;
      }
    }
    function Pn(a) {
      try {
        return Fn(a), !1;
      } catch {
        return !0;
      }
    }
    function Fn(a) {
      return "" + a;
    }
    function tr(a, l) {
      if (Pn(a))
        return s("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", l, zt(a)), Fn(a);
    }
    function or(a) {
      if (Pn(a))
        return s("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", zt(a)), Fn(a);
    }
    function ar(a, l) {
      if (Pn(a))
        return s("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", l, zt(a)), Fn(a);
    }
    function Cr(a, l) {
      if (Pn(a))
        return s("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", l, zt(a)), Fn(a);
    }
    function Un(a) {
      if (Pn(a))
        return s("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", zt(a)), Fn(a);
    }
    function $n(a) {
      if (Pn(a))
        return s("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", zt(a)), Fn(a);
    }
    var gr = 0, Tt = 1, qt = 2, gt = 3, Ht = 4, br = 5, ne = 6, N = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", U = N + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", le = new RegExp("^[" + N + "][" + U + "]*$"), Ce = {}, Te = {};
    function Ve(a) {
      return xt.call(Te, a) ? !0 : xt.call(Ce, a) ? !1 : le.test(a) ? (Te[a] = !0, !0) : (Ce[a] = !0, s("Invalid attribute name: `%s`", a), !1);
    }
    function kt(a, l, m) {
      return l !== null ? l.type === gr : m ? !1 : a.length > 2 && (a[0] === "o" || a[0] === "O") && (a[1] === "n" || a[1] === "N");
    }
    function bn(a, l, m, g) {
      if (m !== null && m.type === gr)
        return !1;
      switch (typeof l) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (g)
            return !1;
          if (m !== null)
            return !m.acceptsBooleans;
          var E = a.toLowerCase().slice(0, 5);
          return E !== "data-" && E !== "aria-";
        }
        default:
          return !1;
      }
    }
    function Wt(a, l, m, g) {
      if (l === null || typeof l > "u" || bn(a, l, m, g))
        return !0;
      if (g)
        return !1;
      if (m !== null)
        switch (m.type) {
          case gt:
            return !l;
          case Ht:
            return l === !1;
          case br:
            return isNaN(l);
          case ne:
            return isNaN(l) || l < 1;
        }
      return !1;
    }
    function xn(a) {
      return Qn.hasOwnProperty(a) ? Qn[a] : null;
    }
    function St(a, l, m, g, E, _, B) {
      this.acceptsBooleans = l === qt || l === gt || l === Ht, this.attributeName = g, this.attributeNamespace = E, this.mustUseProperty = m, this.propertyName = a, this.type = l, this.sanitizeURL = _, this.removeEmptyString = B;
    }
    var Qn = {}, Nr = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    Nr.forEach(function(a) {
      Qn[a] = new St(
        a,
        gr,
        !1,
        // mustUseProperty
        a,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
      var l = a[0], m = a[1];
      Qn[l] = new St(
        l,
        Tt,
        !1,
        // mustUseProperty
        m,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
      Qn[a] = new St(
        a,
        qt,
        !1,
        // mustUseProperty
        a.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
      Qn[a] = new St(
        a,
        qt,
        !1,
        // mustUseProperty
        a,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(a) {
      Qn[a] = new St(
        a,
        gt,
        !1,
        // mustUseProperty
        a.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(a) {
      Qn[a] = new St(
        a,
        gt,
        !0,
        // mustUseProperty
        a,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(a) {
      Qn[a] = new St(
        a,
        Ht,
        !1,
        // mustUseProperty
        a,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(a) {
      Qn[a] = new St(
        a,
        ne,
        !1,
        // mustUseProperty
        a,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(a) {
      Qn[a] = new St(
        a,
        br,
        !1,
        // mustUseProperty
        a.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var bi = /[\-\:]([a-z])/g, Do = function(a) {
      return a[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(a) {
      var l = a.replace(bi, Do);
      Qn[l] = new St(
        l,
        Tt,
        !1,
        // mustUseProperty
        a,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(a) {
      var l = a.replace(bi, Do);
      Qn[l] = new St(
        l,
        Tt,
        !1,
        // mustUseProperty
        a,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(a) {
      var l = a.replace(bi, Do);
      Qn[l] = new St(
        l,
        Tt,
        !1,
        // mustUseProperty
        a,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(a) {
      Qn[a] = new St(
        a,
        Tt,
        !1,
        // mustUseProperty
        a.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var la = "xlinkHref";
    Qn[la] = new St(
      "xlinkHref",
      Tt,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(a) {
      Qn[a] = new St(
        a,
        Tt,
        !1,
        // mustUseProperty
        a.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var ja = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, Mo = !1;
    function ri(a) {
      !Mo && ja.test(a) && (Mo = !0, s("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(a)));
    }
    function ui(a, l, m, g) {
      if (g.mustUseProperty) {
        var E = g.propertyName;
        return a[E];
      } else {
        tr(m, l), g.sanitizeURL && ri("" + m);
        var _ = g.attributeName, B = null;
        if (g.type === Ht) {
          if (a.hasAttribute(_)) {
            var q = a.getAttribute(_);
            return q === "" ? !0 : Wt(l, m, g, !1) ? q : q === "" + m ? m : q;
          }
        } else if (a.hasAttribute(_)) {
          if (Wt(l, m, g, !1))
            return a.getAttribute(_);
          if (g.type === gt)
            return m;
          B = a.getAttribute(_);
        }
        return Wt(l, m, g, !1) ? B === null ? m : B : B === "" + m ? m : B;
      }
    }
    function ji(a, l, m, g) {
      {
        if (!Ve(l))
          return;
        if (!a.hasAttribute(l))
          return m === void 0 ? void 0 : null;
        var E = a.getAttribute(l);
        return tr(m, l), E === "" + m ? m : E;
      }
    }
    function _i(a, l, m, g) {
      var E = xn(l);
      if (!kt(l, E, g)) {
        if (Wt(l, m, E, g) && (m = null), g || E === null) {
          if (Ve(l)) {
            var _ = l;
            m === null ? a.removeAttribute(_) : (tr(m, l), a.setAttribute(_, "" + m));
          }
          return;
        }
        var B = E.mustUseProperty;
        if (B) {
          var q = E.propertyName;
          if (m === null) {
            var G = E.type;
            a[q] = G === gt ? !1 : "";
          } else
            a[q] = m;
          return;
        }
        var se = E.attributeName, ue = E.attributeNamespace;
        if (m === null)
          a.removeAttribute(se);
        else {
          var De = E.type, Re;
          De === gt || De === Ht && m === !0 ? Re = "" : (tr(m, se), Re = "" + m, E.sanitizeURL && ri(Re.toString())), ue ? a.setAttributeNS(ue, se, Re) : a.setAttribute(se, Re);
        }
      }
    }
    var ho = Symbol.for("react.element"), wi = Symbol.for("react.portal"), we = Symbol.for("react.fragment"), Ae = Symbol.for("react.strict_mode"), ye = Symbol.for("react.profiler"), re = Symbol.for("react.provider"), _e = Symbol.for("react.context"), Pe = Symbol.for("react.forward_ref"), Qe = Symbol.for("react.suspense"), Ke = Symbol.for("react.suspense_list"), lt = Symbol.for("react.memo"), tt = Symbol.for("react.lazy"), ot = Symbol.for("react.scope"), cn = Symbol.for("react.debug_trace_mode"), Qt = Symbol.for("react.offscreen"), on = Symbol.for("react.legacy_hidden"), pn = Symbol.for("react.cache"), sr = Symbol.for("react.tracing_marker"), tn = Symbol.iterator, Ur = "@@iterator";
    function xr(a) {
      if (a === null || typeof a != "object")
        return null;
      var l = tn && a[tn] || a[Ur];
      return typeof l == "function" ? l : null;
    }
    var vn = Object.assign, ii = 0, qo, Xi, Po, Ci, cs, Zt, Er;
    function xi() {
    }
    xi.__reactDisabledLog = !0;
    function _r() {
      {
        if (ii === 0) {
          qo = console.log, Xi = console.info, Po = console.warn, Ci = console.error, cs = console.group, Zt = console.groupCollapsed, Er = console.groupEnd;
          var a = {
            configurable: !0,
            enumerable: !0,
            value: xi,
            writable: !0
          };
          Object.defineProperties(console, {
            info: a,
            log: a,
            warn: a,
            error: a,
            group: a,
            groupCollapsed: a,
            groupEnd: a
          });
        }
        ii++;
      }
    }
    function Ji() {
      {
        if (ii--, ii === 0) {
          var a = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: vn({}, a, {
              value: qo
            }),
            info: vn({}, a, {
              value: Xi
            }),
            warn: vn({}, a, {
              value: Po
            }),
            error: vn({}, a, {
              value: Ci
            }),
            group: vn({}, a, {
              value: cs
            }),
            groupCollapsed: vn({}, a, {
              value: Zt
            }),
            groupEnd: vn({}, a, {
              value: Er
            })
          });
        }
        ii < 0 && s("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Fa = n.ReactCurrentDispatcher, Wo;
    function po(a, l, m) {
      {
        if (Wo === void 0)
          try {
            throw Error();
          } catch (E) {
            var g = E.stack.trim().match(/\n( *(at )?)/);
            Wo = g && g[1] || "";
          }
        return `
` + Wo + a;
      }
    }
    var Ua = !1, us;
    {
      var yl = typeof WeakMap == "function" ? WeakMap : Map;
      us = new yl();
    }
    function Qc(a, l) {
      if (!a || Ua)
        return "";
      {
        var m = us.get(a);
        if (m !== void 0)
          return m;
      }
      var g;
      Ua = !0;
      var E = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var _;
      _ = Fa.current, Fa.current = null, _r();
      try {
        if (l) {
          var B = function() {
            throw Error();
          };
          if (Object.defineProperty(B.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(B, []);
            } catch (qe) {
              g = qe;
            }
            Reflect.construct(a, [], B);
          } else {
            try {
              B.call();
            } catch (qe) {
              g = qe;
            }
            a.call(B.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (qe) {
            g = qe;
          }
          a();
        }
      } catch (qe) {
        if (qe && g && typeof qe.stack == "string") {
          for (var q = qe.stack.split(`
`), G = g.stack.split(`
`), se = q.length - 1, ue = G.length - 1; se >= 1 && ue >= 0 && q[se] !== G[ue]; )
            ue--;
          for (; se >= 1 && ue >= 0; se--, ue--)
            if (q[se] !== G[ue]) {
              if (se !== 1 || ue !== 1)
                do
                  if (se--, ue--, ue < 0 || q[se] !== G[ue]) {
                    var De = `
` + q[se].replace(" at new ", " at ");
                    return a.displayName && De.includes("<anonymous>") && (De = De.replace("<anonymous>", a.displayName)), typeof a == "function" && us.set(a, De), De;
                  }
                while (se >= 1 && ue >= 0);
              break;
            }
        }
      } finally {
        Ua = !1, Fa.current = _, Ji(), Error.prepareStackTrace = E;
      }
      var Re = a ? a.displayName || a.name : "", ze = Re ? po(Re) : "";
      return typeof a == "function" && us.set(a, ze), ze;
    }
    function oc(a, l, m) {
      return Qc(a, !0);
    }
    function Gs(a, l, m) {
      return Qc(a, !1);
    }
    function hp(a) {
      var l = a.prototype;
      return !!(l && l.isReactComponent);
    }
    function ds(a, l, m) {
      if (a == null)
        return "";
      if (typeof a == "function")
        return Qc(a, hp(a));
      if (typeof a == "string")
        return po(a);
      switch (a) {
        case Qe:
          return po("Suspense");
        case Ke:
          return po("SuspenseList");
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case Pe:
            return Gs(a.render);
          case lt:
            return ds(a.type, l, m);
          case tt: {
            var g = a, E = g._payload, _ = g._init;
            try {
              return ds(_(E), l, m);
            } catch {
            }
          }
        }
      return "";
    }
    function nr(a) {
      switch (a._debugOwner && a._debugOwner.type, a._debugSource, a.tag) {
        case w:
          return po(a.type);
        case O:
          return po("Lazy");
        case L:
          return po("Suspense");
        case Q:
          return po("SuspenseList");
        case u:
        case p:
        case F:
          return Gs(a.type);
        case D:
          return Gs(a.type.render);
        case f:
          return oc(a.type);
        default:
          return "";
      }
    }
    function Xc(a) {
      try {
        var l = "", m = a;
        do
          l += nr(m), m = m.return;
        while (m);
        return l;
      } catch (g) {
        return `
Error generating stack: ` + g.message + `
` + g.stack;
      }
    }
    function ac(a, l, m) {
      var g = a.displayName;
      if (g)
        return g;
      var E = l.displayName || l.name || "";
      return E !== "" ? m + "(" + E + ")" : m;
    }
    function Jc(a) {
      return a.displayName || "Context";
    }
    function Hn(a) {
      if (a == null)
        return null;
      if (typeof a.tag == "number" && s("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof a == "function")
        return a.displayName || a.name || null;
      if (typeof a == "string")
        return a;
      switch (a) {
        case we:
          return "Fragment";
        case wi:
          return "Portal";
        case ye:
          return "Profiler";
        case Ae:
          return "StrictMode";
        case Qe:
          return "Suspense";
        case Ke:
          return "SuspenseList";
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case _e:
            var l = a;
            return Jc(l) + ".Consumer";
          case re:
            var m = a;
            return Jc(m._context) + ".Provider";
          case Pe:
            return ac(a, a.render, "ForwardRef");
          case lt:
            var g = a.displayName || null;
            return g !== null ? g : Hn(a.type) || "Memo";
          case tt: {
            var E = a, _ = E._payload, B = E._init;
            try {
              return Hn(B(_));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function Zc(a, l, m) {
      var g = l.displayName || l.name || "";
      return a.displayName || (g !== "" ? m + "(" + g + ")" : m);
    }
    function eu(a) {
      return a.displayName || "Context";
    }
    function En(a) {
      var l = a.tag, m = a.type;
      switch (l) {
        case X:
          return "Cache";
        case R:
          var g = m;
          return eu(g) + ".Consumer";
        case I:
          var E = m;
          return eu(E._context) + ".Provider";
        case H:
          return "DehydratedFragment";
        case D:
          return Zc(m, m.render, "ForwardRef");
        case x:
          return "Fragment";
        case w:
          return m;
        case v:
          return "Portal";
        case y:
          return "Root";
        case C:
          return "Text";
        case O:
          return Hn(m);
        case A:
          return m === Ae ? "StrictMode" : "Mode";
        case ee:
          return "Offscreen";
        case M:
          return "Profiler";
        case Y:
          return "Scope";
        case L:
          return "Suspense";
        case Q:
          return "SuspenseList";
        case Z:
          return "TracingMarker";
        case f:
        case u:
        case z:
        case p:
        case j:
        case F:
          if (typeof m == "function")
            return m.displayName || m.name || null;
          if (typeof m == "string")
            return m;
          break;
      }
      return null;
    }
    var fs = n.ReactDebugCurrentFrame, Br = null, Zi = !1;
    function Fi() {
      {
        if (Br === null)
          return null;
        var a = Br._debugOwner;
        if (a !== null && typeof a < "u")
          return En(a);
      }
      return null;
    }
    function vl() {
      return Br === null ? "" : Xc(Br);
    }
    function Hr() {
      fs.getCurrentStack = null, Br = null, Zi = !1;
    }
    function lr(a) {
      fs.getCurrentStack = a === null ? null : vl, Br = a, Zi = !1;
    }
    function Yu() {
      return Br;
    }
    function di(a) {
      Zi = a;
    }
    function Xr(a) {
      return "" + a;
    }
    function hs(a) {
      switch (typeof a) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return a;
        case "object":
          return $n(a), a;
        default:
          return "";
      }
    }
    var Qu = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function Ks(a, l) {
      Qu[l.type] || l.onChange || l.onInput || l.readOnly || l.disabled || l.value == null || s("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), l.onChange || l.readOnly || l.disabled || l.checked == null || s("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function Ys(a) {
      var l = a.type, m = a.nodeName;
      return m && m.toLowerCase() === "input" && (l === "checkbox" || l === "radio");
    }
    function mf(a) {
      return a._valueTracker;
    }
    function ca(a) {
      a._valueTracker = null;
    }
    function Qs(a) {
      var l = "";
      return a && (Ys(a) ? l = a.checked ? "true" : "false" : l = a.value), l;
    }
    function Xs(a) {
      var l = Ys(a) ? "checked" : "value", m = Object.getOwnPropertyDescriptor(a.constructor.prototype, l);
      $n(a[l]);
      var g = "" + a[l];
      if (!(a.hasOwnProperty(l) || typeof m > "u" || typeof m.get != "function" || typeof m.set != "function")) {
        var E = m.get, _ = m.set;
        Object.defineProperty(a, l, {
          configurable: !0,
          get: function() {
            return E.call(this);
          },
          set: function(q) {
            $n(q), g = "" + q, _.call(this, q);
          }
        }), Object.defineProperty(a, l, {
          enumerable: m.enumerable
        });
        var B = {
          getValue: function() {
            return g;
          },
          setValue: function(q) {
            $n(q), g = "" + q;
          },
          stopTracking: function() {
            ca(a), delete a[l];
          }
        };
        return B;
      }
    }
    function fe(a) {
      mf(a) || (a._valueTracker = Xs(a));
    }
    function Ie(a) {
      if (!a)
        return !1;
      var l = mf(a);
      if (!l)
        return !0;
      var m = l.getValue(), g = Qs(a);
      return g !== m ? (l.setValue(g), !0) : !1;
    }
    function $e(a) {
      if (a = a || (typeof document < "u" ? document : void 0), typeof a > "u")
        return null;
      try {
        return a.activeElement || a.body;
      } catch {
        return a.body;
      }
    }
    var It = !1, jn = !1, cr = !1, Sr = !1;
    function Nn(a) {
      var l = a.type === "checkbox" || a.type === "radio";
      return l ? a.checked != null : a.value != null;
    }
    function W(a, l) {
      var m = a, g = l.checked, E = vn({}, l, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: g ?? m._wrapperState.initialChecked
      });
      return E;
    }
    function ve(a, l) {
      Ks("input", l), l.checked !== void 0 && l.defaultChecked !== void 0 && !jn && (s("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", Fi() || "A component", l.type), jn = !0), l.value !== void 0 && l.defaultValue !== void 0 && !It && (s("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", Fi() || "A component", l.type), It = !0);
      var m = a, g = l.defaultValue == null ? "" : l.defaultValue;
      m._wrapperState = {
        initialChecked: l.checked != null ? l.checked : l.defaultChecked,
        initialValue: hs(l.value != null ? l.value : g),
        controlled: Nn(l)
      };
    }
    function Be(a, l) {
      var m = a, g = l.checked;
      g != null && _i(m, "checked", g, !1);
    }
    function We(a, l) {
      var m = a;
      {
        var g = Nn(l);
        !m._wrapperState.controlled && g && !Sr && (s("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Sr = !0), m._wrapperState.controlled && !g && !cr && (s("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), cr = !0);
      }
      Be(a, l);
      var E = hs(l.value), _ = l.type;
      if (E != null)
        _ === "number" ? (E === 0 && m.value === "" || // We explicitly want to coerce to number here if possible.
        // eslint-disable-next-line
        m.value != E) && (m.value = Xr(E)) : m.value !== Xr(E) && (m.value = Xr(E));
      else if (_ === "submit" || _ === "reset") {
        m.removeAttribute("value");
        return;
      }
      l.hasOwnProperty("value") ? dn(m, l.type, E) : l.hasOwnProperty("defaultValue") && dn(m, l.type, hs(l.defaultValue)), l.checked == null && l.defaultChecked != null && (m.defaultChecked = !!l.defaultChecked);
    }
    function ft(a, l, m) {
      var g = a;
      if (l.hasOwnProperty("value") || l.hasOwnProperty("defaultValue")) {
        var E = l.type, _ = E === "submit" || E === "reset";
        if (_ && (l.value === void 0 || l.value === null))
          return;
        var B = Xr(g._wrapperState.initialValue);
        m || B !== g.value && (g.value = B), g.defaultValue = B;
      }
      var q = g.name;
      q !== "" && (g.name = ""), g.defaultChecked = !g.defaultChecked, g.defaultChecked = !!g._wrapperState.initialChecked, q !== "" && (g.name = q);
    }
    function rn(a, l) {
      var m = a;
      We(m, l), vt(m, l);
    }
    function vt(a, l) {
      var m = l.name;
      if (l.type === "radio" && m != null) {
        for (var g = a; g.parentNode; )
          g = g.parentNode;
        tr(m, "name");
        for (var E = g.querySelectorAll("input[name=" + JSON.stringify("" + m) + '][type="radio"]'), _ = 0; _ < E.length; _++) {
          var B = E[_];
          if (!(B === a || B.form !== a.form)) {
            var q = JE(B);
            if (!q)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            Ie(B), We(B, q);
          }
        }
      }
    }
    function dn(a, l, m) {
      // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
      (l !== "number" || $e(a.ownerDocument) !== a) && (m == null ? a.defaultValue = Xr(a._wrapperState.initialValue) : a.defaultValue !== Xr(m) && (a.defaultValue = Xr(m)));
    }
    var Gn = !1, ur = !1, Lr = !1;
    function Rr(a, l) {
      l.value == null && (typeof l.children == "object" && l.children !== null ? e.Children.forEach(l.children, function(m) {
        m != null && (typeof m == "string" || typeof m == "number" || ur || (ur = !0, s("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : l.dangerouslySetInnerHTML != null && (Lr || (Lr = !0, s("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), l.selected != null && !Gn && (s("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Gn = !0);
    }
    function jr(a, l) {
      l.value != null && a.setAttribute("value", Xr(hs(l.value)));
    }
    var zr = Array.isArray;
    function Zn(a) {
      return zr(a);
    }
    var sc;
    sc = !1;
    function yf() {
      var a = Fi();
      return a ? `

Check the render method of \`` + a + "`." : "";
    }
    var pp = ["value", "defaultValue"];
    function Xb(a) {
      {
        Ks("select", a);
        for (var l = 0; l < pp.length; l++) {
          var m = pp[l];
          if (a[m] != null) {
            var g = Zn(a[m]);
            a.multiple && !g ? s("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", m, yf()) : !a.multiple && g && s("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", m, yf());
          }
        }
      }
    }
    function Js(a, l, m, g) {
      var E = a.options;
      if (l) {
        for (var _ = m, B = {}, q = 0; q < _.length; q++)
          B["$" + _[q]] = !0;
        for (var G = 0; G < E.length; G++) {
          var se = B.hasOwnProperty("$" + E[G].value);
          E[G].selected !== se && (E[G].selected = se), se && g && (E[G].defaultSelected = !0);
        }
      } else {
        for (var ue = Xr(hs(m)), De = null, Re = 0; Re < E.length; Re++) {
          if (E[Re].value === ue) {
            E[Re].selected = !0, g && (E[Re].defaultSelected = !0);
            return;
          }
          De === null && !E[Re].disabled && (De = E[Re]);
        }
        De !== null && (De.selected = !0);
      }
    }
    function mp(a, l) {
      return vn({}, l, {
        value: void 0
      });
    }
    function yp(a, l) {
      var m = a;
      Xb(l), m._wrapperState = {
        wasMultiple: !!l.multiple
      }, l.value !== void 0 && l.defaultValue !== void 0 && !sc && (s("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), sc = !0);
    }
    function Jb(a, l) {
      var m = a;
      m.multiple = !!l.multiple;
      var g = l.value;
      g != null ? Js(m, !!l.multiple, g, !1) : l.defaultValue != null && Js(m, !!l.multiple, l.defaultValue, !0);
    }
    function iT(a, l) {
      var m = a, g = m._wrapperState.wasMultiple;
      m._wrapperState.wasMultiple = !!l.multiple;
      var E = l.value;
      E != null ? Js(m, !!l.multiple, E, !1) : g !== !!l.multiple && (l.defaultValue != null ? Js(m, !!l.multiple, l.defaultValue, !0) : Js(m, !!l.multiple, l.multiple ? [] : "", !1));
    }
    function oT(a, l) {
      var m = a, g = l.value;
      g != null && Js(m, !!l.multiple, g, !1);
    }
    var Zb = !1;
    function e0(a, l) {
      var m = a;
      if (l.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var g = vn({}, l, {
        value: void 0,
        defaultValue: void 0,
        children: Xr(m._wrapperState.initialValue)
      });
      return g;
    }
    function Ex(a, l) {
      var m = a;
      Ks("textarea", l), l.value !== void 0 && l.defaultValue !== void 0 && !Zb && (s("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", Fi() || "A component"), Zb = !0);
      var g = l.value;
      if (g == null) {
        var E = l.children, _ = l.defaultValue;
        if (E != null) {
          s("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (_ != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (Zn(E)) {
              if (E.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              E = E[0];
            }
            _ = E;
          }
        }
        _ == null && (_ = ""), g = _;
      }
      m._wrapperState = {
        initialValue: hs(g)
      };
    }
    function Sx(a, l) {
      var m = a, g = hs(l.value), E = hs(l.defaultValue);
      if (g != null) {
        var _ = Xr(g);
        _ !== m.value && (m.value = _), l.defaultValue == null && m.defaultValue !== _ && (m.defaultValue = _);
      }
      E != null && (m.defaultValue = Xr(E));
    }
    function kx(a, l) {
      var m = a, g = m.textContent;
      g === m._wrapperState.initialValue && g !== "" && g !== null && (m.value = g);
    }
    function t0(a, l) {
      Sx(a, l);
    }
    var lc = "http://www.w3.org/1999/xhtml", aT = "http://www.w3.org/1998/Math/MathML", n0 = "http://www.w3.org/2000/svg";
    function yy(a) {
      switch (a) {
        case "svg":
          return n0;
        case "math":
          return aT;
        default:
          return lc;
      }
    }
    function r0(a, l) {
      return a == null || a === lc ? yy(l) : a === n0 && l === "foreignObject" ? lc : a;
    }
    var sT = function(a) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(l, m, g, E) {
        MSApp.execUnsafeLocalFunction(function() {
          return a(l, m, g, E);
        });
      } : a;
    }, vy, Ax = sT(function(a, l) {
      if (a.namespaceURI === n0 && !("innerHTML" in a)) {
        vy = vy || document.createElement("div"), vy.innerHTML = "<svg>" + l.valueOf().toString() + "</svg>";
        for (var m = vy.firstChild; a.firstChild; )
          a.removeChild(a.firstChild);
        for (; m.firstChild; )
          a.appendChild(m.firstChild);
        return;
      }
      a.innerHTML = l;
    }), ua = 1, cc = 3, Ri = 8, Zs = 9, Xu = 11, gy = function(a, l) {
      if (l) {
        var m = a.firstChild;
        if (m && m === a.lastChild && m.nodeType === cc) {
          m.nodeValue = l;
          return;
        }
      }
      a.textContent = l;
    }, Tx = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, vf = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function _x(a, l) {
      return a + l.charAt(0).toUpperCase() + l.substring(1);
    }
    var Rx = ["Webkit", "ms", "Moz", "O"];
    Object.keys(vf).forEach(function(a) {
      Rx.forEach(function(l) {
        vf[_x(l, a)] = vf[a];
      });
    });
    function by(a, l, m) {
      var g = l == null || typeof l == "boolean" || l === "";
      return g ? "" : !m && typeof l == "number" && l !== 0 && !(vf.hasOwnProperty(a) && vf[a]) ? l + "px" : (Cr(l, a), ("" + l).trim());
    }
    var gf = /([A-Z])/g, lT = /^ms-/;
    function cT(a) {
      return a.replace(gf, "-$1").toLowerCase().replace(lT, "-ms-");
    }
    var Ox = function() {
    };
    {
      var Ix = /^(?:webkit|moz|o)[A-Z]/, Dx = /^-ms-/, vp = /-(.)/g, bf = /;\s*$/, wf = {}, Cf = {}, Mx = !1, i0 = !1, o0 = function(a) {
        return a.replace(vp, function(l, m) {
          return m.toUpperCase();
        });
      }, a0 = function(a) {
        wf.hasOwnProperty(a) && wf[a] || (wf[a] = !0, s(
          "Unsupported style property %s. Did you mean %s?",
          a,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          o0(a.replace(Dx, "ms-"))
        ));
      }, Px = function(a) {
        wf.hasOwnProperty(a) && wf[a] || (wf[a] = !0, s("Unsupported vendor-prefixed style property %s. Did you mean %s?", a, a.charAt(0).toUpperCase() + a.slice(1)));
      }, Nx = function(a, l) {
        Cf.hasOwnProperty(l) && Cf[l] || (Cf[l] = !0, s(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, a, l.replace(bf, "")));
      }, Bx = function(a, l) {
        Mx || (Mx = !0, s("`NaN` is an invalid value for the `%s` css style property.", a));
      }, uT = function(a, l) {
        i0 || (i0 = !0, s("`Infinity` is an invalid value for the `%s` css style property.", a));
      };
      Ox = function(a, l) {
        a.indexOf("-") > -1 ? a0(a) : Ix.test(a) ? Px(a) : bf.test(l) && Nx(a, l), typeof l == "number" && (isNaN(l) ? Bx(a, l) : isFinite(l) || uT(a, l));
      };
    }
    var dT = Ox;
    function fT(a) {
      {
        var l = "", m = "";
        for (var g in a)
          if (a.hasOwnProperty(g)) {
            var E = a[g];
            if (E != null) {
              var _ = g.indexOf("--") === 0;
              l += m + (_ ? g : cT(g)) + ":", l += by(g, E, _), m = ";";
            }
          }
        return l || null;
      }
    }
    function Lx(a, l) {
      var m = a.style;
      for (var g in l)
        if (l.hasOwnProperty(g)) {
          var E = g.indexOf("--") === 0;
          E || dT(g, l[g]);
          var _ = by(g, l[g], E);
          g === "float" && (g = "cssFloat"), E ? m.setProperty(g, _) : m[g] = _;
        }
    }
    function hT(a) {
      return a == null || typeof a == "boolean" || a === "";
    }
    function ps(a) {
      var l = {};
      for (var m in a)
        for (var g = Tx[m] || [m], E = 0; E < g.length; E++)
          l[g[E]] = m;
      return l;
    }
    function gp(a, l) {
      {
        if (!l)
          return;
        var m = ps(a), g = ps(l), E = {};
        for (var _ in m) {
          var B = m[_], q = g[_];
          if (q && B !== q) {
            var G = B + "," + q;
            if (E[G])
              continue;
            E[G] = !0, s("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", hT(a[B]) ? "Removing" : "Updating", B, q);
          }
        }
      }
    }
    var jx = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
      // NOTE: menuitem's close tag should be omitted, but that causes problems.
    }, Fx = vn({
      menuitem: !0
    }, jx), Ux = "__html";
    function wy(a, l) {
      if (l) {
        if (Fx[a] && (l.children != null || l.dangerouslySetInnerHTML != null))
          throw new Error(a + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (l.dangerouslySetInnerHTML != null) {
          if (l.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof l.dangerouslySetInnerHTML != "object" || !(Ux in l.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!l.suppressContentEditableWarning && l.contentEditable && l.children != null && s("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), l.style != null && typeof l.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function uc(a, l) {
      if (a.indexOf("-") === -1)
        return typeof l.is == "string";
      switch (a) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var Cy = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, zx = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, el = {}, s0 = new RegExp("^(aria)-[" + U + "]*$"), bp = new RegExp("^(aria)[A-Z][" + U + "]*$");
    function l0(a, l) {
      {
        if (xt.call(el, l) && el[l])
          return !0;
        if (bp.test(l)) {
          var m = "aria-" + l.slice(4).toLowerCase(), g = zx.hasOwnProperty(m) ? m : null;
          if (g == null)
            return s("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", l), el[l] = !0, !0;
          if (l !== g)
            return s("Invalid ARIA attribute `%s`. Did you mean `%s`?", l, g), el[l] = !0, !0;
        }
        if (s0.test(l)) {
          var E = l.toLowerCase(), _ = zx.hasOwnProperty(E) ? E : null;
          if (_ == null)
            return el[l] = !0, !1;
          if (l !== _)
            return s("Unknown ARIA attribute `%s`. Did you mean `%s`?", l, _), el[l] = !0, !0;
        }
      }
      return !0;
    }
    function Vx(a, l) {
      {
        var m = [];
        for (var g in l) {
          var E = l0(a, g);
          E || m.push(g);
        }
        var _ = m.map(function(B) {
          return "`" + B + "`";
        }).join(", ");
        m.length === 1 ? s("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", _, a) : m.length > 1 && s("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", _, a);
      }
    }
    function xy(a, l) {
      uc(a, l) || Vx(a, l);
    }
    var Ju = !1;
    function c0(a, l) {
      {
        if (a !== "input" && a !== "textarea" && a !== "select")
          return;
        l != null && l.value === null && !Ju && (Ju = !0, a === "select" && l.multiple ? s("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", a) : s("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", a));
      }
    }
    var u0 = function() {
    };
    {
      var eo = {}, d0 = /^on./, $x = /^on[^A-Z]/, Hx = new RegExp("^(aria)-[" + U + "]*$"), qx = new RegExp("^(aria)[A-Z][" + U + "]*$");
      u0 = function(a, l, m, g) {
        if (xt.call(eo, l) && eo[l])
          return !0;
        var E = l.toLowerCase();
        if (E === "onfocusin" || E === "onfocusout")
          return s("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), eo[l] = !0, !0;
        if (g != null) {
          var _ = g.registrationNameDependencies, B = g.possibleRegistrationNames;
          if (_.hasOwnProperty(l))
            return !0;
          var q = B.hasOwnProperty(E) ? B[E] : null;
          if (q != null)
            return s("Invalid event handler property `%s`. Did you mean `%s`?", l, q), eo[l] = !0, !0;
          if (d0.test(l))
            return s("Unknown event handler property `%s`. It will be ignored.", l), eo[l] = !0, !0;
        } else if (d0.test(l))
          return $x.test(l) && s("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", l), eo[l] = !0, !0;
        if (Hx.test(l) || qx.test(l))
          return !0;
        if (E === "innerhtml")
          return s("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), eo[l] = !0, !0;
        if (E === "aria")
          return s("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), eo[l] = !0, !0;
        if (E === "is" && m !== null && m !== void 0 && typeof m != "string")
          return s("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof m), eo[l] = !0, !0;
        if (typeof m == "number" && isNaN(m))
          return s("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", l), eo[l] = !0, !0;
        var G = xn(l), se = G !== null && G.type === gr;
        if (Cy.hasOwnProperty(E)) {
          var ue = Cy[E];
          if (ue !== l)
            return s("Invalid DOM property `%s`. Did you mean `%s`?", l, ue), eo[l] = !0, !0;
        } else if (!se && l !== E)
          return s("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", l, E), eo[l] = !0, !0;
        return typeof m == "boolean" && bn(l, m, G, !1) ? (m ? s('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', m, l, l, m, l) : s('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', m, l, l, m, l, l, l), eo[l] = !0, !0) : se ? !0 : bn(l, m, G, !1) ? (eo[l] = !0, !1) : ((m === "false" || m === "true") && G !== null && G.type === gt && (s("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", m, l, m === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', l, m), eo[l] = !0), !0);
      };
    }
    var Wx = function(a, l, m) {
      {
        var g = [];
        for (var E in l) {
          var _ = u0(a, E, l[E], m);
          _ || g.push(E);
        }
        var B = g.map(function(q) {
          return "`" + q + "`";
        }).join(", ");
        g.length === 1 ? s("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", B, a) : g.length > 1 && s("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", B, a);
      }
    };
    function Gx(a, l, m) {
      uc(a, l) || Wx(a, l, m);
    }
    var dc = 1, wp = 2, Zu = 4, pT = dc | wp | Zu, Cp = null;
    function xp(a) {
      Cp !== null && s("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), Cp = a;
    }
    function mT() {
      Cp === null && s("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), Cp = null;
    }
    function Kx(a) {
      return a === Cp;
    }
    function Ey(a) {
      var l = a.target || a.srcElement || window;
      return l.correspondingUseElement && (l = l.correspondingUseElement), l.nodeType === cc ? l.parentNode : l;
    }
    var Fr = null, tu = null, fc = null;
    function xf(a) {
      var l = th(a);
      if (l) {
        if (typeof Fr != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var m = l.stateNode;
        if (m) {
          var g = JE(m);
          Fr(l.stateNode, l.type, g);
        }
      }
    }
    function Yx(a) {
      Fr = a;
    }
    function Sy(a) {
      tu ? fc ? fc.push(a) : fc = [a] : tu = a;
    }
    function Ep() {
      return tu !== null || fc !== null;
    }
    function Sp() {
      if (tu) {
        var a = tu, l = fc;
        if (tu = null, fc = null, xf(a), l)
          for (var m = 0; m < l.length; m++)
            xf(l[m]);
      }
    }
    var ed = function(a, l) {
      return a(l);
    }, f0 = function() {
    }, h0 = !1;
    function yT() {
      var a = Ep();
      a && (f0(), Sp());
    }
    function p0(a, l, m) {
      if (h0)
        return a(l, m);
      h0 = !0;
      try {
        return ed(a, l, m);
      } finally {
        h0 = !1, yT();
      }
    }
    function ky(a, l, m) {
      ed = a, f0 = m;
    }
    function Ay(a) {
      return a === "button" || a === "input" || a === "select" || a === "textarea";
    }
    function m0(a, l, m) {
      switch (a) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(m.disabled && Ay(l));
        default:
          return !1;
      }
    }
    function td(a, l) {
      var m = a.stateNode;
      if (m === null)
        return null;
      var g = JE(m);
      if (g === null)
        return null;
      var E = g[l];
      if (m0(l, a.type, g))
        return null;
      if (E && typeof E != "function")
        throw new Error("Expected `" + l + "` listener to be a function, instead got a value of `" + typeof E + "` type.");
      return E;
    }
    var kp = !1;
    if (Ot)
      try {
        var nd = {};
        Object.defineProperty(nd, "passive", {
          get: function() {
            kp = !0;
          }
        }), window.addEventListener("test", nd, nd), window.removeEventListener("test", nd, nd);
      } catch {
        kp = !1;
      }
    function Qx(a, l, m, g, E, _, B, q, G) {
      var se = Array.prototype.slice.call(arguments, 3);
      try {
        l.apply(m, se);
      } catch (ue) {
        this.onError(ue);
      }
    }
    var y0 = Qx;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var v0 = document.createElement("react");
      y0 = function(l, m, g, E, _, B, q, G, se) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var ue = document.createEvent("Event"), De = !1, Re = !0, ze = window.event, qe = Object.getOwnPropertyDescriptor(window, "event");
        function Je() {
          v0.removeEventListener(Ze, un, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = ze);
        }
        var Et = Array.prototype.slice.call(arguments, 3);
        function un() {
          De = !0, Je(), m.apply(g, Et), Re = !1;
        }
        var Jt, ir = !1, Jn = !1;
        function Le(je) {
          if (Jt = je.error, ir = !0, Jt === null && je.colno === 0 && je.lineno === 0 && (Jn = !0), je.defaultPrevented && Jt != null && typeof Jt == "object")
            try {
              Jt._suppressLogging = !0;
            } catch {
            }
        }
        var Ze = "react-" + (l || "invokeguardedcallback");
        if (window.addEventListener("error", Le), v0.addEventListener(Ze, un, !1), ue.initEvent(Ze, !1, !1), v0.dispatchEvent(ue), qe && Object.defineProperty(window, "event", qe), De && Re && (ir ? Jn && (Jt = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : Jt = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(Jt)), window.removeEventListener("error", Le), !De)
          return Je(), Qx.apply(this, arguments);
      };
    }
    var vT = y0, nu = !1, tl = null, Ap = !1, ru = null, gl = {
      onError: function(a) {
        nu = !0, tl = a;
      }
    };
    function rd(a, l, m, g, E, _, B, q, G) {
      nu = !1, tl = null, vT.apply(gl, arguments);
    }
    function hc(a, l, m, g, E, _, B, q, G) {
      if (rd.apply(this, arguments), nu) {
        var se = b0();
        Ap || (Ap = !0, ru = se);
      }
    }
    function g0() {
      if (Ap) {
        var a = ru;
        throw Ap = !1, ru = null, a;
      }
    }
    function gT() {
      return nu;
    }
    function b0() {
      if (nu) {
        var a = tl;
        return nu = !1, tl = null, a;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function ms(a) {
      return a._reactInternals;
    }
    function Tp(a) {
      return a._reactInternals !== void 0;
    }
    function Ef(a, l) {
      a._reactInternals = l;
    }
    var an = (
      /*                      */
      0
    ), iu = (
      /*                */
      1
    ), qr = (
      /*                    */
      2
    ), Bn = (
      /*                       */
      4
    ), wr = (
      /*                */
      16
    ), kr = (
      /*                 */
      32
    ), bl = (
      /*                     */
      64
    ), Sn = (
      /*                   */
      128
    ), fi = (
      /*            */
      256
    ), da = (
      /*                          */
      512
    ), ys = (
      /*                     */
      1024
    ), Jr = (
      /*                      */
      2048
    ), vs = (
      /*                    */
      4096
    ), ou = (
      /*                   */
      8192
    ), _p = (
      /*             */
      16384
    ), Ty = Jr | Bn | bl | da | ys | _p, Xx = (
      /*               */
      32767
    ), za = (
      /*                   */
      32768
    ), to = (
      /*                */
      65536
    ), Rp = (
      /* */
      131072
    ), w0 = (
      /*                       */
      1048576
    ), C0 = (
      /*                    */
      2097152
    ), fa = (
      /*                 */
      4194304
    ), au = (
      /*                */
      8388608
    ), ha = (
      /*               */
      16777216
    ), id = (
      /*              */
      33554432
    ), Sf = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      Bn | ys | 0
    ), pa = qr | Bn | wr | kr | da | vs | ou, No = Bn | bl | da | ou, gs = Jr | wr, mo = fa | au | C0, pc = n.ReactCurrentOwner;
    function Va(a) {
      var l = a, m = a;
      if (a.alternate)
        for (; l.return; )
          l = l.return;
      else {
        var g = l;
        do
          l = g, (l.flags & (qr | vs)) !== an && (m = l.return), g = l.return;
        while (g);
      }
      return l.tag === y ? m : null;
    }
    function x0(a) {
      if (a.tag === L) {
        var l = a.memoizedState;
        if (l === null) {
          var m = a.alternate;
          m !== null && (l = m.memoizedState);
        }
        if (l !== null)
          return l.dehydrated;
      }
      return null;
    }
    function _y(a) {
      return a.tag === y ? a.stateNode.containerInfo : null;
    }
    function E0(a) {
      return Va(a) === a;
    }
    function $a(a) {
      {
        var l = pc.current;
        if (l !== null && l.tag === f) {
          var m = l, g = m.stateNode;
          g._warnedAboutRefsInRender || s("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", En(m) || "A component"), g._warnedAboutRefsInRender = !0;
        }
      }
      var E = ms(a);
      return E ? Va(E) === E : !1;
    }
    function ma(a) {
      if (Va(a) !== a)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function Wr(a) {
      var l = a.alternate;
      if (!l) {
        var m = Va(a);
        if (m === null)
          throw new Error("Unable to find node on an unmounted component.");
        return m !== a ? null : a;
      }
      for (var g = a, E = l; ; ) {
        var _ = g.return;
        if (_ === null)
          break;
        var B = _.alternate;
        if (B === null) {
          var q = _.return;
          if (q !== null) {
            g = E = q;
            continue;
          }
          break;
        }
        if (_.child === B.child) {
          for (var G = _.child; G; ) {
            if (G === g)
              return ma(_), a;
            if (G === E)
              return ma(_), l;
            G = G.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (g.return !== E.return)
          g = _, E = B;
        else {
          for (var se = !1, ue = _.child; ue; ) {
            if (ue === g) {
              se = !0, g = _, E = B;
              break;
            }
            if (ue === E) {
              se = !0, E = _, g = B;
              break;
            }
            ue = ue.sibling;
          }
          if (!se) {
            for (ue = B.child; ue; ) {
              if (ue === g) {
                se = !0, g = B, E = _;
                break;
              }
              if (ue === E) {
                se = !0, E = B, g = _;
                break;
              }
              ue = ue.sibling;
            }
            if (!se)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (g.alternate !== E)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (g.tag !== y)
        throw new Error("Unable to find node on an unmounted component.");
      return g.stateNode.current === g ? a : l;
    }
    function bs(a) {
      var l = Wr(a);
      return l !== null ? S0(l) : null;
    }
    function S0(a) {
      if (a.tag === w || a.tag === C)
        return a;
      for (var l = a.child; l !== null; ) {
        var m = S0(l);
        if (m !== null)
          return m;
        l = l.sibling;
      }
      return null;
    }
    function Jx(a) {
      var l = Wr(a);
      return l !== null ? Ry(l) : null;
    }
    function Ry(a) {
      if (a.tag === w || a.tag === C)
        return a;
      for (var l = a.child; l !== null; ) {
        if (l.tag !== v) {
          var m = Ry(l);
          if (m !== null)
            return m;
        }
        l = l.sibling;
      }
      return null;
    }
    var Oy = t.unstable_scheduleCallback, Zx = t.unstable_cancelCallback, Iy = t.unstable_shouldYield, eE = t.unstable_requestPaint, oi = t.unstable_now, k0 = t.unstable_getCurrentPriorityLevel, Dy = t.unstable_ImmediatePriority, od = t.unstable_UserBlockingPriority, wl = t.unstable_NormalPriority, tE = t.unstable_LowPriority, My = t.unstable_IdlePriority, kf = t.unstable_yieldValue, nE = t.unstable_setDisableYieldValue, mc = null, Ui = null, bt = null, ws = !1, Ha = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function A0(a) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var l = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (l.isDisabled)
        return !0;
      if (!l.supportsFiber)
        return s("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        Me && (a = vn({}, a, {
          getLaneLabelMap: yc,
          injectProfilingHooks: rE
        })), mc = l.inject(a), Ui = l;
      } catch (m) {
        s("React instrumentation encountered an error: %s.", m);
      }
      return !!l.checkDCE;
    }
    function T0(a, l) {
      if (Ui && typeof Ui.onScheduleFiberRoot == "function")
        try {
          Ui.onScheduleFiberRoot(mc, a, l);
        } catch (m) {
          ws || (ws = !0, s("React instrumentation encountered an error: %s", m));
        }
    }
    function Af(a, l) {
      if (Ui && typeof Ui.onCommitFiberRoot == "function")
        try {
          var m = (a.current.flags & Sn) === Sn;
          if (Fe) {
            var g;
            switch (l) {
              case Si:
                g = Dy;
                break;
              case gc:
                g = od;
                break;
              case Cl:
                g = wl;
                break;
              case jf:
                g = My;
                break;
              default:
                g = wl;
                break;
            }
            Ui.onCommitFiberRoot(mc, a, g, m);
          }
        } catch (E) {
          ws || (ws = !0, s("React instrumentation encountered an error: %s", E));
        }
    }
    function Cs(a) {
      if (Ui && typeof Ui.onPostCommitFiberRoot == "function")
        try {
          Ui.onPostCommitFiberRoot(mc, a);
        } catch (l) {
          ws || (ws = !0, s("React instrumentation encountered an error: %s", l));
        }
    }
    function ad(a) {
      if (Ui && typeof Ui.onCommitFiberUnmount == "function")
        try {
          Ui.onCommitFiberUnmount(mc, a);
        } catch (l) {
          ws || (ws = !0, s("React instrumentation encountered an error: %s", l));
        }
    }
    function Oi(a) {
      if (typeof kf == "function" && (nE(a), i(a)), Ui && typeof Ui.setStrictMode == "function")
        try {
          Ui.setStrictMode(mc, a);
        } catch (l) {
          ws || (ws = !0, s("React instrumentation encountered an error: %s", l));
        }
    }
    function rE(a) {
      bt = a;
    }
    function yc() {
      {
        for (var a = /* @__PURE__ */ new Map(), l = 1, m = 0; m < Pp; m++) {
          var g = wT(l);
          a.set(l, g), l *= 2;
        }
        return a;
      }
    }
    function su(a) {
      bt !== null && typeof bt.markCommitStarted == "function" && bt.markCommitStarted(a);
    }
    function Py() {
      bt !== null && typeof bt.markCommitStopped == "function" && bt.markCommitStopped();
    }
    function Tf(a) {
      bt !== null && typeof bt.markComponentRenderStarted == "function" && bt.markComponentRenderStarted(a);
    }
    function ya() {
      bt !== null && typeof bt.markComponentRenderStopped == "function" && bt.markComponentRenderStopped();
    }
    function lu(a) {
      bt !== null && typeof bt.markComponentPassiveEffectMountStarted == "function" && bt.markComponentPassiveEffectMountStarted(a);
    }
    function Ny() {
      bt !== null && typeof bt.markComponentPassiveEffectMountStopped == "function" && bt.markComponentPassiveEffectMountStopped();
    }
    function iE(a) {
      bt !== null && typeof bt.markComponentPassiveEffectUnmountStarted == "function" && bt.markComponentPassiveEffectUnmountStarted(a);
    }
    function By() {
      bt !== null && typeof bt.markComponentPassiveEffectUnmountStopped == "function" && bt.markComponentPassiveEffectUnmountStopped();
    }
    function oE(a) {
      bt !== null && typeof bt.markComponentLayoutEffectMountStarted == "function" && bt.markComponentLayoutEffectMountStarted(a);
    }
    function Op() {
      bt !== null && typeof bt.markComponentLayoutEffectMountStopped == "function" && bt.markComponentLayoutEffectMountStopped();
    }
    function nl(a) {
      bt !== null && typeof bt.markComponentLayoutEffectUnmountStarted == "function" && bt.markComponentLayoutEffectUnmountStarted(a);
    }
    function _f() {
      bt !== null && typeof bt.markComponentLayoutEffectUnmountStopped == "function" && bt.markComponentLayoutEffectUnmountStopped();
    }
    function Ip(a, l, m) {
      bt !== null && typeof bt.markComponentErrored == "function" && bt.markComponentErrored(a, l, m);
    }
    function sd(a, l, m) {
      bt !== null && typeof bt.markComponentSuspended == "function" && bt.markComponentSuspended(a, l, m);
    }
    function _0(a) {
      bt !== null && typeof bt.markLayoutEffectsStarted == "function" && bt.markLayoutEffectsStarted(a);
    }
    function Rf() {
      bt !== null && typeof bt.markLayoutEffectsStopped == "function" && bt.markLayoutEffectsStopped();
    }
    function aE(a) {
      bt !== null && typeof bt.markPassiveEffectsStarted == "function" && bt.markPassiveEffectsStarted(a);
    }
    function R0() {
      bt !== null && typeof bt.markPassiveEffectsStopped == "function" && bt.markPassiveEffectsStopped();
    }
    function Zr(a) {
      bt !== null && typeof bt.markRenderStarted == "function" && bt.markRenderStarted(a);
    }
    function Ly() {
      bt !== null && typeof bt.markRenderYielded == "function" && bt.markRenderYielded();
    }
    function jy() {
      bt !== null && typeof bt.markRenderStopped == "function" && bt.markRenderStopped();
    }
    function O0(a) {
      bt !== null && typeof bt.markRenderScheduled == "function" && bt.markRenderScheduled(a);
    }
    function Fy(a, l) {
      bt !== null && typeof bt.markForceUpdateScheduled == "function" && bt.markForceUpdateScheduled(a, l);
    }
    function Dp(a, l) {
      bt !== null && typeof bt.markStateUpdateScheduled == "function" && bt.markStateUpdateScheduled(a, l);
    }
    var Gt = (
      /*                         */
      0
    ), Xt = (
      /*                 */
      1
    ), kn = (
      /*                    */
      2
    ), Kn = (
      /*               */
      8
    ), qa = (
      /*              */
      16
    ), Of = Math.clz32 ? Math.clz32 : Bo, Mp = Math.log, bT = Math.LN2;
    function Bo(a) {
      var l = a >>> 0;
      return l === 0 ? 32 : 31 - (Mp(l) / bT | 0) | 0;
    }
    var Pp = 31, nt = (
      /*                        */
      0
    ), Ii = (
      /*                          */
      0
    ), nn = (
      /*                        */
      1
    ), yo = (
      /*    */
      2
    ), Wa = (
      /*             */
      4
    ), vc = (
      /*            */
      8
    ), xs = (
      /*                     */
      16
    ), If = (
      /*                */
      32
    ), ld = (
      /*                       */
      4194240
    ), Df = (
      /*                        */
      64
    ), Uy = (
      /*                        */
      128
    ), zy = (
      /*                        */
      256
    ), Vy = (
      /*                        */
      512
    ), $y = (
      /*                        */
      1024
    ), Hy = (
      /*                        */
      2048
    ), cd = (
      /*                        */
      4096
    ), qy = (
      /*                        */
      8192
    ), Mf = (
      /*                        */
      16384
    ), Pf = (
      /*                       */
      32768
    ), Wy = (
      /*                       */
      65536
    ), Np = (
      /*                       */
      131072
    ), Gy = (
      /*                       */
      262144
    ), Ky = (
      /*                       */
      524288
    ), Yy = (
      /*                       */
      1048576
    ), Qy = (
      /*                       */
      2097152
    ), Nf = (
      /*                            */
      130023424
    ), ud = (
      /*                             */
      4194304
    ), Xy = (
      /*                             */
      8388608
    ), Jy = (
      /*                             */
      16777216
    ), I0 = (
      /*                             */
      33554432
    ), Zy = (
      /*                             */
      67108864
    ), sE = ud, Bp = (
      /*          */
      134217728
    ), D0 = (
      /*                          */
      268435455
    ), Bf = (
      /*               */
      268435456
    ), cu = (
      /*                        */
      536870912
    ), Lo = (
      /*                   */
      1073741824
    );
    function wT(a) {
      {
        if (a & nn)
          return "Sync";
        if (a & yo)
          return "InputContinuousHydration";
        if (a & Wa)
          return "InputContinuous";
        if (a & vc)
          return "DefaultHydration";
        if (a & xs)
          return "Default";
        if (a & If)
          return "TransitionHydration";
        if (a & ld)
          return "Transition";
        if (a & Nf)
          return "Retry";
        if (a & Bp)
          return "SelectiveHydration";
        if (a & Bf)
          return "IdleHydration";
        if (a & cu)
          return "Idle";
        if (a & Lo)
          return "Offscreen";
      }
    }
    var Vr = -1, ev = Df, va = ud;
    function dd(a) {
      switch (Ei(a)) {
        case nn:
          return nn;
        case yo:
          return yo;
        case Wa:
          return Wa;
        case vc:
          return vc;
        case xs:
          return xs;
        case If:
          return If;
        case Df:
        case Uy:
        case zy:
        case Vy:
        case $y:
        case Hy:
        case cd:
        case qy:
        case Mf:
        case Pf:
        case Wy:
        case Np:
        case Gy:
        case Ky:
        case Yy:
        case Qy:
          return a & ld;
        case ud:
        case Xy:
        case Jy:
        case I0:
        case Zy:
          return a & Nf;
        case Bp:
          return Bp;
        case Bf:
          return Bf;
        case cu:
          return cu;
        case Lo:
          return Lo;
        default:
          return s("Should have found matching lanes. This is a bug in React."), a;
      }
    }
    function fd(a, l) {
      var m = a.pendingLanes;
      if (m === nt)
        return nt;
      var g = nt, E = a.suspendedLanes, _ = a.pingedLanes, B = m & D0;
      if (B !== nt) {
        var q = B & ~E;
        if (q !== nt)
          g = dd(q);
        else {
          var G = B & _;
          G !== nt && (g = dd(G));
        }
      } else {
        var se = m & ~E;
        se !== nt ? g = dd(se) : _ !== nt && (g = dd(_));
      }
      if (g === nt)
        return nt;
      if (l !== nt && l !== g && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (l & E) === nt) {
        var ue = Ei(g), De = Ei(l);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          ue >= De || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          ue === xs && (De & ld) !== nt
        )
          return l;
      }
      (g & Wa) !== nt && (g |= m & xs);
      var Re = a.entangledLanes;
      if (Re !== nt)
        for (var ze = a.entanglements, qe = g & Re; qe > 0; ) {
          var Je = du(qe), Et = 1 << Je;
          g |= ze[Je], qe &= ~Et;
        }
      return g;
    }
    function lE(a, l) {
      for (var m = a.eventTimes, g = Vr; l > 0; ) {
        var E = du(l), _ = 1 << E, B = m[E];
        B > g && (g = B), l &= ~_;
      }
      return g;
    }
    function cE(a, l) {
      switch (a) {
        case nn:
        case yo:
        case Wa:
          return l + 250;
        case vc:
        case xs:
        case If:
        case Df:
        case Uy:
        case zy:
        case Vy:
        case $y:
        case Hy:
        case cd:
        case qy:
        case Mf:
        case Pf:
        case Wy:
        case Np:
        case Gy:
        case Ky:
        case Yy:
        case Qy:
          return l + 5e3;
        case ud:
        case Xy:
        case Jy:
        case I0:
        case Zy:
          return Vr;
        case Bp:
        case Bf:
        case cu:
        case Lo:
          return Vr;
        default:
          return s("Should have found matching lanes. This is a bug in React."), Vr;
      }
    }
    function uE(a, l) {
      for (var m = a.pendingLanes, g = a.suspendedLanes, E = a.pingedLanes, _ = a.expirationTimes, B = m; B > 0; ) {
        var q = du(B), G = 1 << q, se = _[q];
        se === Vr ? ((G & g) === nt || (G & E) !== nt) && (_[q] = cE(G, l)) : se <= l && (a.expiredLanes |= G), B &= ~G;
      }
    }
    function M0(a) {
      return dd(a.pendingLanes);
    }
    function uu(a) {
      var l = a.pendingLanes & ~Lo;
      return l !== nt ? l : l & Lo ? Lo : nt;
    }
    function P0(a) {
      return (a & nn) !== nt;
    }
    function Lp(a) {
      return (a & D0) !== nt;
    }
    function dE(a) {
      return (a & Nf) === a;
    }
    function fE(a) {
      var l = nn | Wa | xs;
      return (a & l) === nt;
    }
    function hE(a) {
      return (a & ld) === a;
    }
    function jp(a, l) {
      var m = yo | Wa | vc | xs;
      return (l & m) !== nt;
    }
    function pE(a, l) {
      return (l & a.expiredLanes) !== nt;
    }
    function N0(a) {
      return (a & ld) !== nt;
    }
    function mE() {
      var a = ev;
      return ev <<= 1, (ev & ld) === nt && (ev = Df), a;
    }
    function ga() {
      var a = va;
      return va <<= 1, (va & Nf) === nt && (va = ud), a;
    }
    function Ei(a) {
      return a & -a;
    }
    function Lf(a) {
      return Ei(a);
    }
    function du(a) {
      return 31 - Of(a);
    }
    function tv(a) {
      return du(a);
    }
    function ba(a, l) {
      return (a & l) !== nt;
    }
    function hd(a, l) {
      return (a & l) === l;
    }
    function Mn(a, l) {
      return a | l;
    }
    function Fp(a, l) {
      return a & ~l;
    }
    function nv(a, l) {
      return a & l;
    }
    function CT(a) {
      return a;
    }
    function yE(a, l) {
      return a !== Ii && a < l ? a : l;
    }
    function Up(a) {
      for (var l = [], m = 0; m < Pp; m++)
        l.push(a);
      return l;
    }
    function pd(a, l, m) {
      a.pendingLanes |= l, l !== cu && (a.suspendedLanes = nt, a.pingedLanes = nt);
      var g = a.eventTimes, E = tv(l);
      g[E] = m;
    }
    function vE(a, l) {
      a.suspendedLanes |= l, a.pingedLanes &= ~l;
      for (var m = a.expirationTimes, g = l; g > 0; ) {
        var E = du(g), _ = 1 << E;
        m[E] = Vr, g &= ~_;
      }
    }
    function rv(a, l, m) {
      a.pingedLanes |= a.suspendedLanes & l;
    }
    function iv(a, l) {
      var m = a.pendingLanes & ~l;
      a.pendingLanes = l, a.suspendedLanes = nt, a.pingedLanes = nt, a.expiredLanes &= l, a.mutableReadLanes &= l, a.entangledLanes &= l;
      for (var g = a.entanglements, E = a.eventTimes, _ = a.expirationTimes, B = m; B > 0; ) {
        var q = du(B), G = 1 << q;
        g[q] = nt, E[q] = Vr, _[q] = Vr, B &= ~G;
      }
    }
    function B0(a, l) {
      for (var m = a.entangledLanes |= l, g = a.entanglements, E = m; E; ) {
        var _ = du(E), B = 1 << _;
        // Is this one of the newly entangled lanes?
        B & l | // Is this lane transitively entangled with the newly entangled lanes?
        g[_] & l && (g[_] |= l), E &= ~B;
      }
    }
    function gE(a, l) {
      var m = Ei(l), g;
      switch (m) {
        case Wa:
          g = yo;
          break;
        case xs:
          g = vc;
          break;
        case Df:
        case Uy:
        case zy:
        case Vy:
        case $y:
        case Hy:
        case cd:
        case qy:
        case Mf:
        case Pf:
        case Wy:
        case Np:
        case Gy:
        case Ky:
        case Yy:
        case Qy:
        case ud:
        case Xy:
        case Jy:
        case I0:
        case Zy:
          g = If;
          break;
        case cu:
          g = Bf;
          break;
        default:
          g = Ii;
          break;
      }
      return (g & (a.suspendedLanes | l)) !== Ii ? Ii : g;
    }
    function ov(a, l, m) {
      if (Ha)
        for (var g = a.pendingUpdatersLaneMap; m > 0; ) {
          var E = tv(m), _ = 1 << E, B = g[E];
          B.add(l), m &= ~_;
        }
    }
    function L0(a, l) {
      if (Ha)
        for (var m = a.pendingUpdatersLaneMap, g = a.memoizedUpdaters; l > 0; ) {
          var E = tv(l), _ = 1 << E, B = m[E];
          B.size > 0 && (B.forEach(function(q) {
            var G = q.alternate;
            (G === null || !g.has(G)) && g.add(q);
          }), B.clear()), l &= ~_;
        }
    }
    function zp(a, l) {
      return null;
    }
    var Si = nn, gc = Wa, Cl = xs, jf = cu, Ff = Ii;
    function Es() {
      return Ff;
    }
    function hi(a) {
      Ff = a;
    }
    function jo(a, l) {
      var m = Ff;
      try {
        return Ff = a, l();
      } finally {
        Ff = m;
      }
    }
    function xT(a, l) {
      return a !== 0 && a < l ? a : l;
    }
    function ET(a, l) {
      return a > l ? a : l;
    }
    function Uf(a, l) {
      return a !== 0 && a < l;
    }
    function vo(a) {
      var l = Ei(a);
      return Uf(Si, l) ? Uf(gc, l) ? Lp(l) ? Cl : jf : gc : Si;
    }
    function av(a) {
      var l = a.current.memoizedState;
      return l.isDehydrated;
    }
    var Mt;
    function zf(a) {
      Mt = a;
    }
    function j0(a) {
      Mt(a);
    }
    var sv;
    function ST(a) {
      sv = a;
    }
    var Vf;
    function lv(a) {
      Vf = a;
    }
    var cv;
    function bE(a) {
      cv = a;
    }
    var F0;
    function wE(a) {
      F0 = a;
    }
    var Vp = !1, $f = [], ei = null, no = null, Go = null, Hf = /* @__PURE__ */ new Map(), qf = /* @__PURE__ */ new Map(), ro = [], CE = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      // Intentionally camelCase
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function xl(a) {
      return CE.indexOf(a) > -1;
    }
    function kT(a, l, m, g, E) {
      return {
        blockedOn: a,
        domEventName: l,
        eventSystemFlags: m,
        nativeEvent: E,
        targetContainers: [g]
      };
    }
    function U0(a, l) {
      switch (a) {
        case "focusin":
        case "focusout":
          ei = null;
          break;
        case "dragenter":
        case "dragleave":
          no = null;
          break;
        case "mouseover":
        case "mouseout":
          Go = null;
          break;
        case "pointerover":
        case "pointerout": {
          var m = l.pointerId;
          Hf.delete(m);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var g = l.pointerId;
          qf.delete(g);
          break;
        }
      }
    }
    function Wf(a, l, m, g, E, _) {
      if (a === null || a.nativeEvent !== _) {
        var B = kT(l, m, g, E, _);
        if (l !== null) {
          var q = th(l);
          q !== null && sv(q);
        }
        return B;
      }
      a.eventSystemFlags |= g;
      var G = a.targetContainers;
      return E !== null && G.indexOf(E) === -1 && G.push(E), a;
    }
    function xE(a, l, m, g, E) {
      switch (l) {
        case "focusin": {
          var _ = E;
          return ei = Wf(ei, a, l, m, g, _), !0;
        }
        case "dragenter": {
          var B = E;
          return no = Wf(no, a, l, m, g, B), !0;
        }
        case "mouseover": {
          var q = E;
          return Go = Wf(Go, a, l, m, g, q), !0;
        }
        case "pointerover": {
          var G = E, se = G.pointerId;
          return Hf.set(se, Wf(Hf.get(se) || null, a, l, m, g, G)), !0;
        }
        case "gotpointercapture": {
          var ue = E, De = ue.pointerId;
          return qf.set(De, Wf(qf.get(De) || null, a, l, m, g, ue)), !0;
        }
      }
      return !1;
    }
    function z0(a) {
      var l = em(a.target);
      if (l !== null) {
        var m = Va(l);
        if (m !== null) {
          var g = m.tag;
          if (g === L) {
            var E = x0(m);
            if (E !== null) {
              a.blockedOn = E, F0(a.priority, function() {
                Vf(m);
              });
              return;
            }
          } else if (g === y) {
            var _ = m.stateNode;
            if (av(_)) {
              a.blockedOn = _y(m);
              return;
            }
          }
        }
      }
      a.blockedOn = null;
    }
    function AT(a) {
      for (var l = cv(), m = {
        blockedOn: null,
        target: a,
        priority: l
      }, g = 0; g < ro.length && Uf(l, ro[g].priority); g++)
        ;
      ro.splice(g, 0, m), g === 0 && z0(m);
    }
    function md(a) {
      if (a.blockedOn !== null)
        return !1;
      for (var l = a.targetContainers; l.length > 0; ) {
        var m = l[0], g = Fo(a.domEventName, a.eventSystemFlags, m, a.nativeEvent);
        if (g === null) {
          var E = a.nativeEvent, _ = new E.constructor(E.type, E);
          xp(_), E.target.dispatchEvent(_), mT();
        } else {
          var B = th(g);
          return B !== null && sv(B), a.blockedOn = g, !1;
        }
        l.shift();
      }
      return !0;
    }
    function uv(a, l, m) {
      md(a) && m.delete(l);
    }
    function Ss() {
      Vp = !1, ei !== null && md(ei) && (ei = null), no !== null && md(no) && (no = null), Go !== null && md(Go) && (Go = null), Hf.forEach(uv), qf.forEach(uv);
    }
    function Xn(a, l) {
      a.blockedOn === l && (a.blockedOn = null, Vp || (Vp = !0, t.unstable_scheduleCallback(t.unstable_NormalPriority, Ss)));
    }
    function pi(a) {
      if ($f.length > 0) {
        Xn($f[0], a);
        for (var l = 1; l < $f.length; l++) {
          var m = $f[l];
          m.blockedOn === a && (m.blockedOn = null);
        }
      }
      ei !== null && Xn(ei, a), no !== null && Xn(no, a), Go !== null && Xn(Go, a);
      var g = function(q) {
        return Xn(q, a);
      };
      Hf.forEach(g), qf.forEach(g);
      for (var E = 0; E < ro.length; E++) {
        var _ = ro[E];
        _.blockedOn === a && (_.blockedOn = null);
      }
      for (; ro.length > 0; ) {
        var B = ro[0];
        if (B.blockedOn !== null)
          break;
        z0(B), B.blockedOn === null && ro.shift();
      }
    }
    var Gr = n.ReactCurrentBatchConfig, zi = !0;
    function wa(a) {
      zi = !!a;
    }
    function Gf() {
      return zi;
    }
    function Vi(a, l, m) {
      var g = dv(l), E;
      switch (g) {
        case Si:
          E = $p;
          break;
        case gc:
          E = yd;
          break;
        case Cl:
        default:
          E = Kf;
          break;
      }
      return E.bind(null, l, m, a);
    }
    function $p(a, l, m, g) {
      var E = Es(), _ = Gr.transition;
      Gr.transition = null;
      try {
        hi(Si), Kf(a, l, m, g);
      } finally {
        hi(E), Gr.transition = _;
      }
    }
    function yd(a, l, m, g) {
      var E = Es(), _ = Gr.transition;
      Gr.transition = null;
      try {
        hi(gc), Kf(a, l, m, g);
      } finally {
        hi(E), Gr.transition = _;
      }
    }
    function Kf(a, l, m, g) {
      zi && V0(a, l, m, g);
    }
    function V0(a, l, m, g) {
      var E = Fo(a, l, m, g);
      if (E === null) {
        $T(a, l, g, fu, m), U0(a, g);
        return;
      }
      if (xE(E, a, l, m, g)) {
        g.stopPropagation();
        return;
      }
      if (U0(a, g), l & Zu && xl(a)) {
        for (; E !== null; ) {
          var _ = th(E);
          _ !== null && j0(_);
          var B = Fo(a, l, m, g);
          if (B === null && $T(a, l, g, fu, m), B === E)
            break;
          E = B;
        }
        E !== null && g.stopPropagation();
        return;
      }
      $T(a, l, g, null, m);
    }
    var fu = null;
    function Fo(a, l, m, g) {
      fu = null;
      var E = Ey(g), _ = em(E);
      if (_ !== null) {
        var B = Va(_);
        if (B === null)
          _ = null;
        else {
          var q = B.tag;
          if (q === L) {
            var G = x0(B);
            if (G !== null)
              return G;
            _ = null;
          } else if (q === y) {
            var se = B.stateNode;
            if (av(se))
              return _y(B);
            _ = null;
          } else B !== _ && (_ = null);
        }
      }
      return fu = _, null;
    }
    function dv(a) {
      switch (a) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return Si;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return gc;
        case "message": {
          var l = k0();
          switch (l) {
            case Dy:
              return Si;
            case od:
              return gc;
            case wl:
            case tE:
              return Cl;
            case My:
              return jf;
            default:
              return Cl;
          }
        }
        default:
          return Cl;
      }
    }
    function Yf(a, l, m) {
      return a.addEventListener(l, m, !1), m;
    }
    function bc(a, l, m) {
      return a.addEventListener(l, m, !0), m;
    }
    function fv(a, l, m, g) {
      return a.addEventListener(l, m, {
        capture: !0,
        passive: g
      }), m;
    }
    function $0(a, l, m, g) {
      return a.addEventListener(l, m, {
        passive: g
      }), m;
    }
    var ks = null, Qf = null, As = null;
    function hv(a) {
      return ks = a, Qf = qp(), !0;
    }
    function Hp() {
      ks = null, Qf = null, As = null;
    }
    function pv() {
      if (As)
        return As;
      var a, l = Qf, m = l.length, g, E = qp(), _ = E.length;
      for (a = 0; a < m && l[a] === E[a]; a++)
        ;
      var B = m - a;
      for (g = 1; g <= B && l[m - g] === E[_ - g]; g++)
        ;
      var q = g > 1 ? 1 - g : void 0;
      return As = E.slice(a, q), As;
    }
    function qp() {
      return "value" in ks ? ks.value : ks.textContent;
    }
    function vd(a) {
      var l, m = a.keyCode;
      return "charCode" in a ? (l = a.charCode, l === 0 && m === 13 && (l = 13)) : l = m, l === 10 && (l = 13), l >= 32 || l === 13 ? l : 0;
    }
    function io() {
      return !0;
    }
    function wc() {
      return !1;
    }
    function ai(a) {
      function l(m, g, E, _, B) {
        this._reactName = m, this._targetInst = E, this.type = g, this.nativeEvent = _, this.target = B, this.currentTarget = null;
        for (var q in a)
          if (a.hasOwnProperty(q)) {
            var G = a[q];
            G ? this[q] = G(_) : this[q] = _[q];
          }
        var se = _.defaultPrevented != null ? _.defaultPrevented : _.returnValue === !1;
        return se ? this.isDefaultPrevented = io : this.isDefaultPrevented = wc, this.isPropagationStopped = wc, this;
      }
      return vn(l.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var m = this.nativeEvent;
          m && (m.preventDefault ? m.preventDefault() : typeof m.returnValue != "unknown" && (m.returnValue = !1), this.isDefaultPrevented = io);
        },
        stopPropagation: function() {
          var m = this.nativeEvent;
          m && (m.stopPropagation ? m.stopPropagation() : typeof m.cancelBubble != "unknown" && (m.cancelBubble = !0), this.isPropagationStopped = io);
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function() {
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: io
      }), l;
    }
    var $i = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(a) {
        return a.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, mv = ai($i), gd = vn({}, $i, {
      view: 0,
      detail: 0
    }), H0 = ai(gd), q0, El, Xf;
    function W0(a) {
      a !== Xf && (Xf && a.type === "mousemove" ? (q0 = a.screenX - Xf.screenX, El = a.screenY - Xf.screenY) : (q0 = 0, El = 0), Xf = a);
    }
    var Sl = vn({}, gd, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: G0,
      button: 0,
      buttons: 0,
      relatedTarget: function(a) {
        return a.relatedTarget === void 0 ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
      },
      movementX: function(a) {
        return "movementX" in a ? a.movementX : (W0(a), q0);
      },
      movementY: function(a) {
        return "movementY" in a ? a.movementY : El;
      }
    }), yv = ai(Sl), bd = vn({}, Sl, {
      dataTransfer: 0
    }), EE = ai(bd), SE = vn({}, gd, {
      relatedTarget: 0
    }), Wp = ai(SE), vv = vn({}, $i, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), TT = ai(vv), _T = vn({}, $i, {
      clipboardData: function(a) {
        return "clipboardData" in a ? a.clipboardData : window.clipboardData;
      }
    }), kE = ai(_T), AE = vn({}, $i, {
      data: 0
    }), hu = ai(AE), RT = hu, Jf = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, TE = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function mi(a) {
      if (a.key) {
        var l = Jf[a.key] || a.key;
        if (l !== "Unidentified")
          return l;
      }
      if (a.type === "keypress") {
        var m = vd(a);
        return m === 13 ? "Enter" : String.fromCharCode(m);
      }
      return a.type === "keydown" || a.type === "keyup" ? TE[a.keyCode] || "Unidentified" : "";
    }
    var OT = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function _E(a) {
      var l = this, m = l.nativeEvent;
      if (m.getModifierState)
        return m.getModifierState(a);
      var g = OT[a];
      return g ? !!m[g] : !1;
    }
    function G0(a) {
      return _E;
    }
    var IT = vn({}, gd, {
      key: mi,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: G0,
      // Legacy Interface
      charCode: function(a) {
        return a.type === "keypress" ? vd(a) : 0;
      },
      keyCode: function(a) {
        return a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
      },
      which: function(a) {
        return a.type === "keypress" ? vd(a) : a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
      }
    }), RE = ai(IT), OE = vn({}, Sl, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), IE = ai(OE), Ts = vn({}, gd, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: G0
    }), K0 = ai(Ts), DT = vn({}, $i, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), pu = ai(DT), gv = vn({}, Sl, {
      deltaX: function(a) {
        return "deltaX" in a ? a.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in a ? -a.wheelDeltaX : 0
        );
      },
      deltaY: function(a) {
        return "deltaY" in a ? a.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in a ? -a.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in a ? -a.wheelDelta : 0
          )
        );
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    }), wd = ai(gv), bv = [9, 13, 27, 32], wv = 229, Gp = Ot && "CompositionEvent" in window, Kp = null;
    Ot && "documentMode" in document && (Kp = document.documentMode);
    var Y0 = Ot && "TextEvent" in window && !Kp, DE = Ot && (!Gp || Kp && Kp > 8 && Kp <= 11), Q0 = 32, X0 = String.fromCharCode(Q0);
    function Cv() {
      hn("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), hn("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), hn("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), hn("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var Yp = !1;
    function ME(a) {
      return (a.ctrlKey || a.altKey || a.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
      !(a.ctrlKey && a.altKey);
    }
    function J0(a) {
      switch (a) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function MT(a, l) {
      return a === "keydown" && l.keyCode === wv;
    }
    function Z0(a, l) {
      switch (a) {
        case "keyup":
          return bv.indexOf(l.keyCode) !== -1;
        case "keydown":
          return l.keyCode !== wv;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function xv(a) {
      var l = a.detail;
      return typeof l == "object" && "data" in l ? l.data : null;
    }
    function Qp(a) {
      return a.locale === "ko";
    }
    var mu = !1;
    function Ev(a, l, m, g, E) {
      var _, B;
      if (Gp ? _ = J0(l) : mu ? Z0(l, g) && (_ = "onCompositionEnd") : MT(l, g) && (_ = "onCompositionStart"), !_)
        return null;
      DE && !Qp(g) && (!mu && _ === "onCompositionStart" ? mu = hv(E) : _ === "onCompositionEnd" && mu && (B = pv()));
      var q = FE(m, _);
      if (q.length > 0) {
        var G = new hu(_, l, null, g, E);
        if (a.push({
          event: G,
          listeners: q
        }), B)
          G.data = B;
        else {
          var se = xv(g);
          se !== null && (G.data = se);
        }
      }
    }
    function PE(a, l) {
      switch (a) {
        case "compositionend":
          return xv(l);
        case "keypress":
          var m = l.which;
          return m !== Q0 ? null : (Yp = !0, X0);
        case "textInput":
          var g = l.data;
          return g === X0 && Yp ? null : g;
        default:
          return null;
      }
    }
    function PT(a, l) {
      if (mu) {
        if (a === "compositionend" || !Gp && Z0(a, l)) {
          var m = pv();
          return Hp(), mu = !1, m;
        }
        return null;
      }
      switch (a) {
        case "paste":
          return null;
        case "keypress":
          if (!ME(l)) {
            if (l.char && l.char.length > 1)
              return l.char;
            if (l.which)
              return String.fromCharCode(l.which);
          }
          return null;
        case "compositionend":
          return DE && !Qp(l) ? null : l.data;
        default:
          return null;
      }
    }
    function Sv(a, l, m, g, E) {
      var _;
      if (Y0 ? _ = PE(l, g) : _ = PT(l, g), !_)
        return null;
      var B = FE(m, "onBeforeInput");
      if (B.length > 0) {
        var q = new RT("onBeforeInput", "beforeinput", null, g, E);
        a.push({
          event: q,
          listeners: B
        }), q.data = _;
      }
    }
    function NT(a, l, m, g, E, _, B) {
      Ev(a, l, m, g, E), Sv(a, l, m, g, E);
    }
    var Xp = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function NE(a) {
      var l = a && a.nodeName && a.nodeName.toLowerCase();
      return l === "input" ? !!Xp[a.type] : l === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function kv(a) {
      if (!Ot)
        return !1;
      var l = "on" + a, m = l in document;
      if (!m) {
        var g = document.createElement("div");
        g.setAttribute(l, "return;"), m = typeof g[l] == "function";
      }
      return m;
    }
    function d() {
      hn("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function h(a, l, m, g) {
      Sy(g);
      var E = FE(l, "onChange");
      if (E.length > 0) {
        var _ = new mv("onChange", "change", null, m, g);
        a.push({
          event: _,
          listeners: E
        });
      }
    }
    var b = null, T = null;
    function P(a) {
      var l = a.nodeName && a.nodeName.toLowerCase();
      return l === "select" || l === "input" && a.type === "file";
    }
    function V(a) {
      var l = [];
      h(l, T, a, Ey(a)), p0(te, l);
    }
    function te(a) {
      S3(a, 0);
    }
    function me(a) {
      var l = Iv(a);
      if (Ie(l))
        return a;
    }
    function xe(a, l) {
      if (a === "change")
        return l;
    }
    var He = !1;
    Ot && (He = kv("input") && (!document.documentMode || document.documentMode > 9));
    function at(a, l) {
      b = a, T = l, b.attachEvent("onpropertychange", rt);
    }
    function ut() {
      b && (b.detachEvent("onpropertychange", rt), b = null, T = null);
    }
    function rt(a) {
      a.propertyName === "value" && me(T) && V(a);
    }
    function _t(a, l, m) {
      a === "focusin" ? (ut(), at(l, m)) : a === "focusout" && ut();
    }
    function Lt(a, l) {
      if (a === "selectionchange" || a === "keyup" || a === "keydown")
        return me(T);
    }
    function Vt(a) {
      var l = a.nodeName;
      return l && l.toLowerCase() === "input" && (a.type === "checkbox" || a.type === "radio");
    }
    function ki(a, l) {
      if (a === "click")
        return me(l);
    }
    function Ne(a, l) {
      if (a === "input" || a === "change")
        return me(l);
    }
    function Oe(a) {
      var l = a._wrapperState;
      !l || !l.controlled || a.type !== "number" || dn(a, "number", a.value);
    }
    function Ue(a, l, m, g, E, _, B) {
      var q = m ? Iv(m) : window, G, se;
      if (P(q) ? G = xe : NE(q) ? He ? G = Ne : (G = Lt, se = _t) : Vt(q) && (G = ki), G) {
        var ue = G(l, m);
        if (ue) {
          h(a, ue, g, E);
          return;
        }
      }
      se && se(l, q, m), l === "focusout" && Oe(q);
    }
    function ht() {
      wn("onMouseEnter", ["mouseout", "mouseover"]), wn("onMouseLeave", ["mouseout", "mouseover"]), wn("onPointerEnter", ["pointerout", "pointerover"]), wn("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function Kt(a, l, m, g, E, _, B) {
      var q = l === "mouseover" || l === "pointerover", G = l === "mouseout" || l === "pointerout";
      if (q && !Kx(g)) {
        var se = g.relatedTarget || g.fromElement;
        if (se && (em(se) || hw(se)))
          return;
      }
      if (!(!G && !q)) {
        var ue;
        if (E.window === E)
          ue = E;
        else {
          var De = E.ownerDocument;
          De ? ue = De.defaultView || De.parentWindow : ue = window;
        }
        var Re, ze;
        if (G) {
          var qe = g.relatedTarget || g.toElement;
          if (Re = m, ze = qe ? em(qe) : null, ze !== null) {
            var Je = Va(ze);
            (ze !== Je || ze.tag !== w && ze.tag !== C) && (ze = null);
          }
        } else
          Re = null, ze = m;
        if (Re !== ze) {
          var Et = yv, un = "onMouseLeave", Jt = "onMouseEnter", ir = "mouse";
          (l === "pointerout" || l === "pointerover") && (Et = IE, un = "onPointerLeave", Jt = "onPointerEnter", ir = "pointer");
          var Jn = Re == null ? ue : Iv(Re), Le = ze == null ? ue : Iv(ze), Ze = new Et(un, ir + "leave", Re, g, E);
          Ze.target = Jn, Ze.relatedTarget = Le;
          var je = null, dt = em(E);
          if (dt === m) {
            var Dt = new Et(Jt, ir + "enter", ze, g, E);
            Dt.target = Le, Dt.relatedTarget = Jn, je = Dt;
          }
          zee(a, Ze, je, Re, ze);
        }
      }
    }
    function mn(a, l) {
      return a === l && (a !== 0 || 1 / a === 1 / l) || a !== a && l !== l;
    }
    var jt = typeof Object.is == "function" ? Object.is : mn;
    function gn(a, l) {
      if (jt(a, l))
        return !0;
      if (typeof a != "object" || a === null || typeof l != "object" || l === null)
        return !1;
      var m = Object.keys(a), g = Object.keys(l);
      if (m.length !== g.length)
        return !1;
      for (var E = 0; E < m.length; E++) {
        var _ = m[E];
        if (!xt.call(l, _) || !jt(a[_], l[_]))
          return !1;
      }
      return !0;
    }
    function Hi(a) {
      for (; a && a.firstChild; )
        a = a.firstChild;
      return a;
    }
    function mr(a) {
      for (; a; ) {
        if (a.nextSibling)
          return a.nextSibling;
        a = a.parentNode;
      }
    }
    function Cc(a, l) {
      for (var m = Hi(a), g = 0, E = 0; m; ) {
        if (m.nodeType === cc) {
          if (E = g + m.textContent.length, g <= l && E >= l)
            return {
              node: m,
              offset: l - g
            };
          g = E;
        }
        m = Hi(mr(m));
      }
    }
    function BT(a) {
      var l = a.ownerDocument, m = l && l.defaultView || window, g = m.getSelection && m.getSelection();
      if (!g || g.rangeCount === 0)
        return null;
      var E = g.anchorNode, _ = g.anchorOffset, B = g.focusNode, q = g.focusOffset;
      try {
        E.nodeType, B.nodeType;
      } catch {
        return null;
      }
      return Cee(a, E, _, B, q);
    }
    function Cee(a, l, m, g, E) {
      var _ = 0, B = -1, q = -1, G = 0, se = 0, ue = a, De = null;
      e: for (; ; ) {
        for (var Re = null; ue === l && (m === 0 || ue.nodeType === cc) && (B = _ + m), ue === g && (E === 0 || ue.nodeType === cc) && (q = _ + E), ue.nodeType === cc && (_ += ue.nodeValue.length), (Re = ue.firstChild) !== null; )
          De = ue, ue = Re;
        for (; ; ) {
          if (ue === a)
            break e;
          if (De === l && ++G === m && (B = _), De === g && ++se === E && (q = _), (Re = ue.nextSibling) !== null)
            break;
          ue = De, De = ue.parentNode;
        }
        ue = Re;
      }
      return B === -1 || q === -1 ? null : {
        start: B,
        end: q
      };
    }
    function xee(a, l) {
      var m = a.ownerDocument || document, g = m && m.defaultView || window;
      if (g.getSelection) {
        var E = g.getSelection(), _ = a.textContent.length, B = Math.min(l.start, _), q = l.end === void 0 ? B : Math.min(l.end, _);
        if (!E.extend && B > q) {
          var G = q;
          q = B, B = G;
        }
        var se = Cc(a, B), ue = Cc(a, q);
        if (se && ue) {
          if (E.rangeCount === 1 && E.anchorNode === se.node && E.anchorOffset === se.offset && E.focusNode === ue.node && E.focusOffset === ue.offset)
            return;
          var De = m.createRange();
          De.setStart(se.node, se.offset), E.removeAllRanges(), B > q ? (E.addRange(De), E.extend(ue.node, ue.offset)) : (De.setEnd(ue.node, ue.offset), E.addRange(De));
        }
      }
    }
    function f3(a) {
      return a && a.nodeType === cc;
    }
    function h3(a, l) {
      return !a || !l ? !1 : a === l ? !0 : f3(a) ? !1 : f3(l) ? h3(a, l.parentNode) : "contains" in a ? a.contains(l) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(l) & 16) : !1;
    }
    function Eee(a) {
      return a && a.ownerDocument && h3(a.ownerDocument.documentElement, a);
    }
    function See(a) {
      try {
        return typeof a.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function p3() {
      for (var a = window, l = $e(); l instanceof a.HTMLIFrameElement; ) {
        if (See(l))
          a = l.contentWindow;
        else
          return l;
        l = $e(a.document);
      }
      return l;
    }
    function LT(a) {
      var l = a && a.nodeName && a.nodeName.toLowerCase();
      return l && (l === "input" && (a.type === "text" || a.type === "search" || a.type === "tel" || a.type === "url" || a.type === "password") || l === "textarea" || a.contentEditable === "true");
    }
    function kee() {
      var a = p3();
      return {
        focusedElem: a,
        selectionRange: LT(a) ? Tee(a) : null
      };
    }
    function Aee(a) {
      var l = p3(), m = a.focusedElem, g = a.selectionRange;
      if (l !== m && Eee(m)) {
        g !== null && LT(m) && _ee(m, g);
        for (var E = [], _ = m; _ = _.parentNode; )
          _.nodeType === ua && E.push({
            element: _,
            left: _.scrollLeft,
            top: _.scrollTop
          });
        typeof m.focus == "function" && m.focus();
        for (var B = 0; B < E.length; B++) {
          var q = E[B];
          q.element.scrollLeft = q.left, q.element.scrollTop = q.top;
        }
      }
    }
    function Tee(a) {
      var l;
      return "selectionStart" in a ? l = {
        start: a.selectionStart,
        end: a.selectionEnd
      } : l = BT(a), l || {
        start: 0,
        end: 0
      };
    }
    function _ee(a, l) {
      var m = l.start, g = l.end;
      g === void 0 && (g = m), "selectionStart" in a ? (a.selectionStart = m, a.selectionEnd = Math.min(g, a.value.length)) : xee(a, l);
    }
    var Ree = Ot && "documentMode" in document && document.documentMode <= 11;
    function Oee() {
      hn("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var Av = null, jT = null, ew = null, FT = !1;
    function Iee(a) {
      if ("selectionStart" in a && LT(a))
        return {
          start: a.selectionStart,
          end: a.selectionEnd
        };
      var l = a.ownerDocument && a.ownerDocument.defaultView || window, m = l.getSelection();
      return {
        anchorNode: m.anchorNode,
        anchorOffset: m.anchorOffset,
        focusNode: m.focusNode,
        focusOffset: m.focusOffset
      };
    }
    function Dee(a) {
      return a.window === a ? a.document : a.nodeType === Zs ? a : a.ownerDocument;
    }
    function m3(a, l, m) {
      var g = Dee(m);
      if (!(FT || Av == null || Av !== $e(g))) {
        var E = Iee(Av);
        if (!ew || !gn(ew, E)) {
          ew = E;
          var _ = FE(jT, "onSelect");
          if (_.length > 0) {
            var B = new mv("onSelect", "select", null, l, m);
            a.push({
              event: B,
              listeners: _
            }), B.target = Av;
          }
        }
      }
    }
    function Mee(a, l, m, g, E, _, B) {
      var q = m ? Iv(m) : window;
      switch (l) {
        case "focusin":
          (NE(q) || q.contentEditable === "true") && (Av = q, jT = m, ew = null);
          break;
        case "focusout":
          Av = null, jT = null, ew = null;
          break;
        case "mousedown":
          FT = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          FT = !1, m3(a, g, E);
          break;
        case "selectionchange":
          if (Ree)
            break;
        case "keydown":
        case "keyup":
          m3(a, g, E);
      }
    }
    function BE(a, l) {
      var m = {};
      return m[a.toLowerCase()] = l.toLowerCase(), m["Webkit" + a] = "webkit" + l, m["Moz" + a] = "moz" + l, m;
    }
    var Tv = {
      animationend: BE("Animation", "AnimationEnd"),
      animationiteration: BE("Animation", "AnimationIteration"),
      animationstart: BE("Animation", "AnimationStart"),
      transitionend: BE("Transition", "TransitionEnd")
    }, UT = {}, y3 = {};
    Ot && (y3 = document.createElement("div").style, "AnimationEvent" in window || (delete Tv.animationend.animation, delete Tv.animationiteration.animation, delete Tv.animationstart.animation), "TransitionEvent" in window || delete Tv.transitionend.transition);
    function LE(a) {
      if (UT[a])
        return UT[a];
      if (!Tv[a])
        return a;
      var l = Tv[a];
      for (var m in l)
        if (l.hasOwnProperty(m) && m in y3)
          return UT[a] = l[m];
      return a;
    }
    var v3 = LE("animationend"), g3 = LE("animationiteration"), b3 = LE("animationstart"), w3 = LE("transitionend"), C3 = /* @__PURE__ */ new Map(), x3 = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function Zf(a, l) {
      C3.set(a, l), hn(l, [a]);
    }
    function Pee() {
      for (var a = 0; a < x3.length; a++) {
        var l = x3[a], m = l.toLowerCase(), g = l[0].toUpperCase() + l.slice(1);
        Zf(m, "on" + g);
      }
      Zf(v3, "onAnimationEnd"), Zf(g3, "onAnimationIteration"), Zf(b3, "onAnimationStart"), Zf("dblclick", "onDoubleClick"), Zf("focusin", "onFocus"), Zf("focusout", "onBlur"), Zf(w3, "onTransitionEnd");
    }
    function Nee(a, l, m, g, E, _, B) {
      var q = C3.get(l);
      if (q !== void 0) {
        var G = mv, se = l;
        switch (l) {
          case "keypress":
            if (vd(g) === 0)
              return;
          case "keydown":
          case "keyup":
            G = RE;
            break;
          case "focusin":
            se = "focus", G = Wp;
            break;
          case "focusout":
            se = "blur", G = Wp;
            break;
          case "beforeblur":
          case "afterblur":
            G = Wp;
            break;
          case "click":
            if (g.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            G = yv;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            G = EE;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            G = K0;
            break;
          case v3:
          case g3:
          case b3:
            G = TT;
            break;
          case w3:
            G = pu;
            break;
          case "scroll":
            G = H0;
            break;
          case "wheel":
            G = wd;
            break;
          case "copy":
          case "cut":
          case "paste":
            G = kE;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            G = IE;
            break;
        }
        var ue = (_ & Zu) !== 0;
        {
          var De = !ue && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          l === "scroll", Re = Fee(m, q, g.type, ue, De);
          if (Re.length > 0) {
            var ze = new G(q, se, null, g, E);
            a.push({
              event: ze,
              listeners: Re
            });
          }
        }
      }
    }
    Pee(), ht(), d(), Oee(), Cv();
    function Bee(a, l, m, g, E, _, B) {
      Nee(a, l, m, g, E, _);
      var q = (_ & pT) === 0;
      q && (Kt(a, l, m, g, E), Ue(a, l, m, g, E), Mee(a, l, m, g, E), NT(a, l, m, g, E));
    }
    var tw = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], zT = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(tw));
    function E3(a, l, m) {
      var g = a.type || "unknown-event";
      a.currentTarget = m, hc(g, l, void 0, a), a.currentTarget = null;
    }
    function Lee(a, l, m) {
      var g;
      if (m)
        for (var E = l.length - 1; E >= 0; E--) {
          var _ = l[E], B = _.instance, q = _.currentTarget, G = _.listener;
          if (B !== g && a.isPropagationStopped())
            return;
          E3(a, G, q), g = B;
        }
      else
        for (var se = 0; se < l.length; se++) {
          var ue = l[se], De = ue.instance, Re = ue.currentTarget, ze = ue.listener;
          if (De !== g && a.isPropagationStopped())
            return;
          E3(a, ze, Re), g = De;
        }
    }
    function S3(a, l) {
      for (var m = (l & Zu) !== 0, g = 0; g < a.length; g++) {
        var E = a[g], _ = E.event, B = E.listeners;
        Lee(_, B, m);
      }
      g0();
    }
    function jee(a, l, m, g, E) {
      var _ = Ey(m), B = [];
      Bee(B, a, g, m, _, l), S3(B, l);
    }
    function si(a, l) {
      zT.has(a) || s('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', a);
      var m = !1, g = pne(l), E = Vee(a);
      g.has(E) || (k3(l, a, wp, m), g.add(E));
    }
    function VT(a, l, m) {
      zT.has(a) && !l && s('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', a);
      var g = 0;
      l && (g |= Zu), k3(m, a, g, l);
    }
    var jE = "_reactListening" + Math.random().toString(36).slice(2);
    function nw(a) {
      if (!a[jE]) {
        a[jE] = !0, mt.forEach(function(m) {
          m !== "selectionchange" && (zT.has(m) || VT(m, !1, a), VT(m, !0, a));
        });
        var l = a.nodeType === Zs ? a : a.ownerDocument;
        l !== null && (l[jE] || (l[jE] = !0, VT("selectionchange", !1, l)));
      }
    }
    function k3(a, l, m, g, E) {
      var _ = Vi(a, l, m), B = void 0;
      kp && (l === "touchstart" || l === "touchmove" || l === "wheel") && (B = !0), a = a, g ? B !== void 0 ? fv(a, l, _, B) : bc(a, l, _) : B !== void 0 ? $0(a, l, _, B) : Yf(a, l, _);
    }
    function A3(a, l) {
      return a === l || a.nodeType === Ri && a.parentNode === l;
    }
    function $T(a, l, m, g, E) {
      var _ = g;
      if (!(l & dc) && !(l & wp)) {
        var B = E;
        if (g !== null) {
          var q = g;
          e: for (; ; ) {
            if (q === null)
              return;
            var G = q.tag;
            if (G === y || G === v) {
              var se = q.stateNode.containerInfo;
              if (A3(se, B))
                break;
              if (G === v)
                for (var ue = q.return; ue !== null; ) {
                  var De = ue.tag;
                  if (De === y || De === v) {
                    var Re = ue.stateNode.containerInfo;
                    if (A3(Re, B))
                      return;
                  }
                  ue = ue.return;
                }
              for (; se !== null; ) {
                var ze = em(se);
                if (ze === null)
                  return;
                var qe = ze.tag;
                if (qe === w || qe === C) {
                  q = _ = ze;
                  continue e;
                }
                se = se.parentNode;
              }
            }
            q = q.return;
          }
        }
      }
      p0(function() {
        return jee(a, l, m, _);
      });
    }
    function rw(a, l, m) {
      return {
        instance: a,
        listener: l,
        currentTarget: m
      };
    }
    function Fee(a, l, m, g, E, _) {
      for (var B = l !== null ? l + "Capture" : null, q = g ? B : l, G = [], se = a, ue = null; se !== null; ) {
        var De = se, Re = De.stateNode, ze = De.tag;
        if (ze === w && Re !== null && (ue = Re, q !== null)) {
          var qe = td(se, q);
          qe != null && G.push(rw(se, qe, ue));
        }
        if (E)
          break;
        se = se.return;
      }
      return G;
    }
    function FE(a, l) {
      for (var m = l + "Capture", g = [], E = a; E !== null; ) {
        var _ = E, B = _.stateNode, q = _.tag;
        if (q === w && B !== null) {
          var G = B, se = td(E, m);
          se != null && g.unshift(rw(E, se, G));
          var ue = td(E, l);
          ue != null && g.push(rw(E, ue, G));
        }
        E = E.return;
      }
      return g;
    }
    function _v(a) {
      if (a === null)
        return null;
      do
        a = a.return;
      while (a && a.tag !== w);
      return a || null;
    }
    function Uee(a, l) {
      for (var m = a, g = l, E = 0, _ = m; _; _ = _v(_))
        E++;
      for (var B = 0, q = g; q; q = _v(q))
        B++;
      for (; E - B > 0; )
        m = _v(m), E--;
      for (; B - E > 0; )
        g = _v(g), B--;
      for (var G = E; G--; ) {
        if (m === g || g !== null && m === g.alternate)
          return m;
        m = _v(m), g = _v(g);
      }
      return null;
    }
    function T3(a, l, m, g, E) {
      for (var _ = l._reactName, B = [], q = m; q !== null && q !== g; ) {
        var G = q, se = G.alternate, ue = G.stateNode, De = G.tag;
        if (se !== null && se === g)
          break;
        if (De === w && ue !== null) {
          var Re = ue;
          if (E) {
            var ze = td(q, _);
            ze != null && B.unshift(rw(q, ze, Re));
          } else if (!E) {
            var qe = td(q, _);
            qe != null && B.push(rw(q, qe, Re));
          }
        }
        q = q.return;
      }
      B.length !== 0 && a.push({
        event: l,
        listeners: B
      });
    }
    function zee(a, l, m, g, E) {
      var _ = g && E ? Uee(g, E) : null;
      g !== null && T3(a, l, g, _, !1), E !== null && m !== null && T3(a, m, E, _, !0);
    }
    function Vee(a, l) {
      return a + "__bubble";
    }
    var _s = !1, iw = "dangerouslySetInnerHTML", UE = "suppressContentEditableWarning", eh = "suppressHydrationWarning", _3 = "autoFocus", Jp = "children", Zp = "style", zE = "__html", HT, VE, ow, R3, $E, O3, I3;
    HT = {
      // There are working polyfills for <dialog>. Let people use it.
      dialog: !0,
      // Electron ships a custom <webview> tag to display external web content in
      // an isolated frame and process.
      // This tag is not present in non Electron environments such as JSDom which
      // is often used for testing purposes.
      // @see https://electronjs.org/docs/api/webview-tag
      webview: !0
    }, VE = function(a, l) {
      xy(a, l), c0(a, l), Gx(a, l, {
        registrationNameDependencies: yt,
        possibleRegistrationNames: Ut
      });
    }, O3 = Ot && !document.documentMode, ow = function(a, l, m) {
      if (!_s) {
        var g = HE(m), E = HE(l);
        E !== g && (_s = !0, s("Prop `%s` did not match. Server: %s Client: %s", a, JSON.stringify(E), JSON.stringify(g)));
      }
    }, R3 = function(a) {
      if (!_s) {
        _s = !0;
        var l = [];
        a.forEach(function(m) {
          l.push(m);
        }), s("Extra attributes from the server: %s", l);
      }
    }, $E = function(a, l) {
      l === !1 ? s("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", a, a, a) : s("Expected `%s` listener to be a function, instead got a value of `%s` type.", a, typeof l);
    }, I3 = function(a, l) {
      var m = a.namespaceURI === lc ? a.ownerDocument.createElement(a.tagName) : a.ownerDocument.createElementNS(a.namespaceURI, a.tagName);
      return m.innerHTML = l, m.innerHTML;
    };
    var $ee = /\r\n?/g, Hee = /\u0000|\uFFFD/g;
    function HE(a) {
      Un(a);
      var l = typeof a == "string" ? a : "" + a;
      return l.replace($ee, `
`).replace(Hee, "");
    }
    function qE(a, l, m, g) {
      var E = HE(l), _ = HE(a);
      if (_ !== E && (g && (_s || (_s = !0, s('Text content did not match. Server: "%s" Client: "%s"', _, E))), m && J))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function D3(a) {
      return a.nodeType === Zs ? a : a.ownerDocument;
    }
    function qee() {
    }
    function WE(a) {
      a.onclick = qee;
    }
    function Wee(a, l, m, g, E) {
      for (var _ in g)
        if (g.hasOwnProperty(_)) {
          var B = g[_];
          if (_ === Zp)
            B && Object.freeze(B), Lx(l, B);
          else if (_ === iw) {
            var q = B ? B[zE] : void 0;
            q != null && Ax(l, q);
          } else if (_ === Jp)
            if (typeof B == "string") {
              var G = a !== "textarea" || B !== "";
              G && gy(l, B);
            } else typeof B == "number" && gy(l, "" + B);
          else _ === UE || _ === eh || _ === _3 || (yt.hasOwnProperty(_) ? B != null && (typeof B != "function" && $E(_, B), _ === "onScroll" && si("scroll", l)) : B != null && _i(l, _, B, E));
        }
    }
    function Gee(a, l, m, g) {
      for (var E = 0; E < l.length; E += 2) {
        var _ = l[E], B = l[E + 1];
        _ === Zp ? Lx(a, B) : _ === iw ? Ax(a, B) : _ === Jp ? gy(a, B) : _i(a, _, B, g);
      }
    }
    function Kee(a, l, m, g) {
      var E, _ = D3(m), B, q = g;
      if (q === lc && (q = yy(a)), q === lc) {
        if (E = uc(a, l), !E && a !== a.toLowerCase() && s("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", a), a === "script") {
          var G = _.createElement("div");
          G.innerHTML = "<script><\/script>";
          var se = G.firstChild;
          B = G.removeChild(se);
        } else if (typeof l.is == "string")
          B = _.createElement(a, {
            is: l.is
          });
        else if (B = _.createElement(a), a === "select") {
          var ue = B;
          l.multiple ? ue.multiple = !0 : l.size && (ue.size = l.size);
        }
      } else
        B = _.createElementNS(q, a);
      return q === lc && !E && Object.prototype.toString.call(B) === "[object HTMLUnknownElement]" && !xt.call(HT, a) && (HT[a] = !0, s("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", a)), B;
    }
    function Yee(a, l) {
      return D3(l).createTextNode(a);
    }
    function Qee(a, l, m, g) {
      var E = uc(l, m);
      VE(l, m);
      var _;
      switch (l) {
        case "dialog":
          si("cancel", a), si("close", a), _ = m;
          break;
        case "iframe":
        case "object":
        case "embed":
          si("load", a), _ = m;
          break;
        case "video":
        case "audio":
          for (var B = 0; B < tw.length; B++)
            si(tw[B], a);
          _ = m;
          break;
        case "source":
          si("error", a), _ = m;
          break;
        case "img":
        case "image":
        case "link":
          si("error", a), si("load", a), _ = m;
          break;
        case "details":
          si("toggle", a), _ = m;
          break;
        case "input":
          ve(a, m), _ = W(a, m), si("invalid", a);
          break;
        case "option":
          Rr(a, m), _ = m;
          break;
        case "select":
          yp(a, m), _ = mp(a, m), si("invalid", a);
          break;
        case "textarea":
          Ex(a, m), _ = e0(a, m), si("invalid", a);
          break;
        default:
          _ = m;
      }
      switch (wy(l, _), Wee(l, a, g, _, E), l) {
        case "input":
          fe(a), ft(a, m, !1);
          break;
        case "textarea":
          fe(a), kx(a);
          break;
        case "option":
          jr(a, m);
          break;
        case "select":
          Jb(a, m);
          break;
        default:
          typeof _.onClick == "function" && WE(a);
          break;
      }
    }
    function Xee(a, l, m, g, E) {
      VE(l, g);
      var _ = null, B, q;
      switch (l) {
        case "input":
          B = W(a, m), q = W(a, g), _ = [];
          break;
        case "select":
          B = mp(a, m), q = mp(a, g), _ = [];
          break;
        case "textarea":
          B = e0(a, m), q = e0(a, g), _ = [];
          break;
        default:
          B = m, q = g, typeof B.onClick != "function" && typeof q.onClick == "function" && WE(a);
          break;
      }
      wy(l, q);
      var G, se, ue = null;
      for (G in B)
        if (!(q.hasOwnProperty(G) || !B.hasOwnProperty(G) || B[G] == null))
          if (G === Zp) {
            var De = B[G];
            for (se in De)
              De.hasOwnProperty(se) && (ue || (ue = {}), ue[se] = "");
          } else G === iw || G === Jp || G === UE || G === eh || G === _3 || (yt.hasOwnProperty(G) ? _ || (_ = []) : (_ = _ || []).push(G, null));
      for (G in q) {
        var Re = q[G], ze = B != null ? B[G] : void 0;
        if (!(!q.hasOwnProperty(G) || Re === ze || Re == null && ze == null))
          if (G === Zp)
            if (Re && Object.freeze(Re), ze) {
              for (se in ze)
                ze.hasOwnProperty(se) && (!Re || !Re.hasOwnProperty(se)) && (ue || (ue = {}), ue[se] = "");
              for (se in Re)
                Re.hasOwnProperty(se) && ze[se] !== Re[se] && (ue || (ue = {}), ue[se] = Re[se]);
            } else
              ue || (_ || (_ = []), _.push(G, ue)), ue = Re;
          else if (G === iw) {
            var qe = Re ? Re[zE] : void 0, Je = ze ? ze[zE] : void 0;
            qe != null && Je !== qe && (_ = _ || []).push(G, qe);
          } else G === Jp ? (typeof Re == "string" || typeof Re == "number") && (_ = _ || []).push(G, "" + Re) : G === UE || G === eh || (yt.hasOwnProperty(G) ? (Re != null && (typeof Re != "function" && $E(G, Re), G === "onScroll" && si("scroll", a)), !_ && ze !== Re && (_ = [])) : (_ = _ || []).push(G, Re));
      }
      return ue && (gp(ue, q[Zp]), (_ = _ || []).push(Zp, ue)), _;
    }
    function Jee(a, l, m, g, E) {
      m === "input" && E.type === "radio" && E.name != null && Be(a, E);
      var _ = uc(m, g), B = uc(m, E);
      switch (Gee(a, l, _, B), m) {
        case "input":
          We(a, E);
          break;
        case "textarea":
          Sx(a, E);
          break;
        case "select":
          iT(a, E);
          break;
      }
    }
    function Zee(a) {
      {
        var l = a.toLowerCase();
        return Cy.hasOwnProperty(l) && Cy[l] || null;
      }
    }
    function ete(a, l, m, g, E, _, B) {
      var q, G;
      switch (q = uc(l, m), VE(l, m), l) {
        case "dialog":
          si("cancel", a), si("close", a);
          break;
        case "iframe":
        case "object":
        case "embed":
          si("load", a);
          break;
        case "video":
        case "audio":
          for (var se = 0; se < tw.length; se++)
            si(tw[se], a);
          break;
        case "source":
          si("error", a);
          break;
        case "img":
        case "image":
        case "link":
          si("error", a), si("load", a);
          break;
        case "details":
          si("toggle", a);
          break;
        case "input":
          ve(a, m), si("invalid", a);
          break;
        case "option":
          Rr(a, m);
          break;
        case "select":
          yp(a, m), si("invalid", a);
          break;
        case "textarea":
          Ex(a, m), si("invalid", a);
          break;
      }
      wy(l, m);
      {
        G = /* @__PURE__ */ new Set();
        for (var ue = a.attributes, De = 0; De < ue.length; De++) {
          var Re = ue[De].name.toLowerCase();
          switch (Re) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              G.add(ue[De].name);
          }
        }
      }
      var ze = null;
      for (var qe in m)
        if (m.hasOwnProperty(qe)) {
          var Je = m[qe];
          if (qe === Jp)
            typeof Je == "string" ? a.textContent !== Je && (m[eh] !== !0 && qE(a.textContent, Je, _, B), ze = [Jp, Je]) : typeof Je == "number" && a.textContent !== "" + Je && (m[eh] !== !0 && qE(a.textContent, Je, _, B), ze = [Jp, "" + Je]);
          else if (yt.hasOwnProperty(qe))
            Je != null && (typeof Je != "function" && $E(qe, Je), qe === "onScroll" && si("scroll", a));
          else if (B && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof q == "boolean") {
            var Et = void 0, un = q && Ee ? null : xn(qe);
            if (m[eh] !== !0) {
              if (!(qe === UE || qe === eh || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              qe === "value" || qe === "checked" || qe === "selected")) {
                if (qe === iw) {
                  var Jt = a.innerHTML, ir = Je ? Je[zE] : void 0;
                  if (ir != null) {
                    var Jn = I3(a, ir);
                    Jn !== Jt && ow(qe, Jt, Jn);
                  }
                } else if (qe === Zp) {
                  if (G.delete(qe), O3) {
                    var Le = fT(Je);
                    Et = a.getAttribute("style"), Le !== Et && ow(qe, Et, Le);
                  }
                } else if (q && !Ee)
                  G.delete(qe.toLowerCase()), Et = ji(a, qe, Je), Je !== Et && ow(qe, Et, Je);
                else if (!kt(qe, un, q) && !Wt(qe, Je, un, q)) {
                  var Ze = !1;
                  if (un !== null)
                    G.delete(un.attributeName), Et = ui(a, qe, Je, un);
                  else {
                    var je = g;
                    if (je === lc && (je = yy(l)), je === lc)
                      G.delete(qe.toLowerCase());
                    else {
                      var dt = Zee(qe);
                      dt !== null && dt !== qe && (Ze = !0, G.delete(dt)), G.delete(qe);
                    }
                    Et = ji(a, qe, Je);
                  }
                  var Dt = Ee;
                  !Dt && Je !== Et && !Ze && ow(qe, Et, Je);
                }
              }
            }
          }
        }
      switch (B && // $FlowFixMe - Should be inferred as not undefined.
      G.size > 0 && m[eh] !== !0 && R3(G), l) {
        case "input":
          fe(a), ft(a, m, !0);
          break;
        case "textarea":
          fe(a), kx(a);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof m.onClick == "function" && WE(a);
          break;
      }
      return ze;
    }
    function tte(a, l, m) {
      var g = a.nodeValue !== l;
      return g;
    }
    function qT(a, l) {
      {
        if (_s)
          return;
        _s = !0, s("Did not expect server HTML to contain a <%s> in <%s>.", l.nodeName.toLowerCase(), a.nodeName.toLowerCase());
      }
    }
    function WT(a, l) {
      {
        if (_s)
          return;
        _s = !0, s('Did not expect server HTML to contain the text node "%s" in <%s>.', l.nodeValue, a.nodeName.toLowerCase());
      }
    }
    function GT(a, l, m) {
      {
        if (_s)
          return;
        _s = !0, s("Expected server HTML to contain a matching <%s> in <%s>.", l, a.nodeName.toLowerCase());
      }
    }
    function KT(a, l) {
      {
        if (l === "" || _s)
          return;
        _s = !0, s('Expected server HTML to contain a matching text node for "%s" in <%s>.', l, a.nodeName.toLowerCase());
      }
    }
    function nte(a, l, m) {
      switch (l) {
        case "input":
          rn(a, m);
          return;
        case "textarea":
          t0(a, m);
          return;
        case "select":
          oT(a, m);
          return;
      }
    }
    var aw = function() {
    }, sw = function() {
    };
    {
      var rte = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], M3 = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        "foreignObject",
        "desc",
        "title"
      ], ite = M3.concat(["button"]), ote = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], P3 = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      sw = function(a, l) {
        var m = vn({}, a || P3), g = {
          tag: l
        };
        return M3.indexOf(l) !== -1 && (m.aTagInScope = null, m.buttonTagInScope = null, m.nobrTagInScope = null), ite.indexOf(l) !== -1 && (m.pTagInButtonScope = null), rte.indexOf(l) !== -1 && l !== "address" && l !== "div" && l !== "p" && (m.listItemTagAutoclosing = null, m.dlItemTagAutoclosing = null), m.current = g, l === "form" && (m.formTag = g), l === "a" && (m.aTagInScope = g), l === "button" && (m.buttonTagInScope = g), l === "nobr" && (m.nobrTagInScope = g), l === "p" && (m.pTagInButtonScope = g), l === "li" && (m.listItemTagAutoclosing = g), (l === "dd" || l === "dt") && (m.dlItemTagAutoclosing = g), m;
      };
      var ate = function(a, l) {
        switch (l) {
          case "select":
            return a === "option" || a === "optgroup" || a === "#text";
          case "optgroup":
            return a === "option" || a === "#text";
          case "option":
            return a === "#text";
          case "tr":
            return a === "th" || a === "td" || a === "style" || a === "script" || a === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return a === "tr" || a === "style" || a === "script" || a === "template";
          case "colgroup":
            return a === "col" || a === "template";
          case "table":
            return a === "caption" || a === "colgroup" || a === "tbody" || a === "tfoot" || a === "thead" || a === "style" || a === "script" || a === "template";
          case "head":
            return a === "base" || a === "basefont" || a === "bgsound" || a === "link" || a === "meta" || a === "title" || a === "noscript" || a === "noframes" || a === "style" || a === "script" || a === "template";
          case "html":
            return a === "head" || a === "body" || a === "frameset";
          case "frameset":
            return a === "frame";
          case "#document":
            return a === "html";
        }
        switch (a) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return l !== "h1" && l !== "h2" && l !== "h3" && l !== "h4" && l !== "h5" && l !== "h6";
          case "rp":
          case "rt":
            return ote.indexOf(l) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return l == null;
        }
        return !0;
      }, ste = function(a, l) {
        switch (a) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return l.pTagInButtonScope;
          case "form":
            return l.formTag || l.pTagInButtonScope;
          case "li":
            return l.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return l.dlItemTagAutoclosing;
          case "button":
            return l.buttonTagInScope;
          case "a":
            return l.aTagInScope;
          case "nobr":
            return l.nobrTagInScope;
        }
        return null;
      }, N3 = {};
      aw = function(a, l, m) {
        m = m || P3;
        var g = m.current, E = g && g.tag;
        l != null && (a != null && s("validateDOMNesting: when childText is passed, childTag should be null"), a = "#text");
        var _ = ate(a, E) ? null : g, B = _ ? null : ste(a, m), q = _ || B;
        if (q) {
          var G = q.tag, se = !!_ + "|" + a + "|" + G;
          if (!N3[se]) {
            N3[se] = !0;
            var ue = a, De = "";
            if (a === "#text" ? /\S/.test(l) ? ue = "Text nodes" : (ue = "Whitespace text nodes", De = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : ue = "<" + a + ">", _) {
              var Re = "";
              G === "table" && a === "tr" && (Re += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), s("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", ue, G, De, Re);
            } else
              s("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", ue, G);
          }
        }
      };
    }
    var GE = "suppressHydrationWarning", KE = "$", YE = "/$", lw = "$?", cw = "$!", lte = "style", YT = null, QT = null;
    function cte(a) {
      var l, m, g = a.nodeType;
      switch (g) {
        case Zs:
        case Xu: {
          l = g === Zs ? "#document" : "#fragment";
          var E = a.documentElement;
          m = E ? E.namespaceURI : r0(null, "");
          break;
        }
        default: {
          var _ = g === Ri ? a.parentNode : a, B = _.namespaceURI || null;
          l = _.tagName, m = r0(B, l);
          break;
        }
      }
      {
        var q = l.toLowerCase(), G = sw(null, q);
        return {
          namespace: m,
          ancestorInfo: G
        };
      }
    }
    function ute(a, l, m) {
      {
        var g = a, E = r0(g.namespace, l), _ = sw(g.ancestorInfo, l);
        return {
          namespace: E,
          ancestorInfo: _
        };
      }
    }
    function nje(a) {
      return a;
    }
    function dte(a) {
      YT = Gf(), QT = kee();
      var l = null;
      return wa(!1), l;
    }
    function fte(a) {
      Aee(QT), wa(YT), YT = null, QT = null;
    }
    function hte(a, l, m, g, E) {
      var _;
      {
        var B = g;
        if (aw(a, null, B.ancestorInfo), typeof l.children == "string" || typeof l.children == "number") {
          var q = "" + l.children, G = sw(B.ancestorInfo, a);
          aw(null, q, G);
        }
        _ = B.namespace;
      }
      var se = Kee(a, l, m, _);
      return fw(E, se), i2(se, l), se;
    }
    function pte(a, l) {
      a.appendChild(l);
    }
    function mte(a, l, m, g, E) {
      switch (Qee(a, l, m, g), l) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!m.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function yte(a, l, m, g, E, _) {
      {
        var B = _;
        if (typeof g.children != typeof m.children && (typeof g.children == "string" || typeof g.children == "number")) {
          var q = "" + g.children, G = sw(B.ancestorInfo, l);
          aw(null, q, G);
        }
      }
      return Xee(a, l, m, g);
    }
    function XT(a, l) {
      return a === "textarea" || a === "noscript" || typeof l.children == "string" || typeof l.children == "number" || typeof l.dangerouslySetInnerHTML == "object" && l.dangerouslySetInnerHTML !== null && l.dangerouslySetInnerHTML.__html != null;
    }
    function vte(a, l, m, g) {
      {
        var E = m;
        aw(null, a, E.ancestorInfo);
      }
      var _ = Yee(a, l);
      return fw(g, _), _;
    }
    function gte() {
      var a = window.event;
      return a === void 0 ? Cl : dv(a.type);
    }
    var JT = typeof setTimeout == "function" ? setTimeout : void 0, bte = typeof clearTimeout == "function" ? clearTimeout : void 0, ZT = -1, B3 = typeof Promise == "function" ? Promise : void 0, wte = typeof queueMicrotask == "function" ? queueMicrotask : typeof B3 < "u" ? function(a) {
      return B3.resolve(null).then(a).catch(Cte);
    } : JT;
    function Cte(a) {
      setTimeout(function() {
        throw a;
      });
    }
    function xte(a, l, m, g) {
      switch (l) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          m.autoFocus && a.focus();
          return;
        case "img": {
          m.src && (a.src = m.src);
          return;
        }
      }
    }
    function Ete(a, l, m, g, E, _) {
      Jee(a, l, m, g, E), i2(a, E);
    }
    function L3(a) {
      gy(a, "");
    }
    function Ste(a, l, m) {
      a.nodeValue = m;
    }
    function kte(a, l) {
      a.appendChild(l);
    }
    function Ate(a, l) {
      var m;
      a.nodeType === Ri ? (m = a.parentNode, m.insertBefore(l, a)) : (m = a, m.appendChild(l));
      var g = a._reactRootContainer;
      g == null && m.onclick === null && WE(m);
    }
    function Tte(a, l, m) {
      a.insertBefore(l, m);
    }
    function _te(a, l, m) {
      a.nodeType === Ri ? a.parentNode.insertBefore(l, m) : a.insertBefore(l, m);
    }
    function Rte(a, l) {
      a.removeChild(l);
    }
    function Ote(a, l) {
      a.nodeType === Ri ? a.parentNode.removeChild(l) : a.removeChild(l);
    }
    function e2(a, l) {
      var m = l, g = 0;
      do {
        var E = m.nextSibling;
        if (a.removeChild(m), E && E.nodeType === Ri) {
          var _ = E.data;
          if (_ === YE)
            if (g === 0) {
              a.removeChild(E), pi(l);
              return;
            } else
              g--;
          else (_ === KE || _ === lw || _ === cw) && g++;
        }
        m = E;
      } while (m);
      pi(l);
    }
    function Ite(a, l) {
      a.nodeType === Ri ? e2(a.parentNode, l) : a.nodeType === ua && e2(a, l), pi(a);
    }
    function Dte(a) {
      a = a;
      var l = a.style;
      typeof l.setProperty == "function" ? l.setProperty("display", "none", "important") : l.display = "none";
    }
    function Mte(a) {
      a.nodeValue = "";
    }
    function Pte(a, l) {
      a = a;
      var m = l[lte], g = m != null && m.hasOwnProperty("display") ? m.display : null;
      a.style.display = by("display", g);
    }
    function Nte(a, l) {
      a.nodeValue = l;
    }
    function Bte(a) {
      a.nodeType === ua ? a.textContent = "" : a.nodeType === Zs && a.documentElement && a.removeChild(a.documentElement);
    }
    function Lte(a, l, m) {
      return a.nodeType !== ua || l.toLowerCase() !== a.nodeName.toLowerCase() ? null : a;
    }
    function jte(a, l) {
      return l === "" || a.nodeType !== cc ? null : a;
    }
    function Fte(a) {
      return a.nodeType !== Ri ? null : a;
    }
    function j3(a) {
      return a.data === lw;
    }
    function t2(a) {
      return a.data === cw;
    }
    function Ute(a) {
      var l = a.nextSibling && a.nextSibling.dataset, m, g, E;
      return l && (m = l.dgst, g = l.msg, E = l.stck), {
        message: g,
        digest: m,
        stack: E
      };
    }
    function zte(a, l) {
      a._reactRetry = l;
    }
    function QE(a) {
      for (; a != null; a = a.nextSibling) {
        var l = a.nodeType;
        if (l === ua || l === cc)
          break;
        if (l === Ri) {
          var m = a.data;
          if (m === KE || m === cw || m === lw)
            break;
          if (m === YE)
            return null;
        }
      }
      return a;
    }
    function uw(a) {
      return QE(a.nextSibling);
    }
    function Vte(a) {
      return QE(a.firstChild);
    }
    function $te(a) {
      return QE(a.firstChild);
    }
    function Hte(a) {
      return QE(a.nextSibling);
    }
    function qte(a, l, m, g, E, _, B) {
      fw(_, a), i2(a, m);
      var q;
      {
        var G = E;
        q = G.namespace;
      }
      var se = (_.mode & Xt) !== Gt;
      return ete(a, l, m, q, g, se, B);
    }
    function Wte(a, l, m, g) {
      return fw(m, a), m.mode & Xt, tte(a, l);
    }
    function Gte(a, l) {
      fw(l, a);
    }
    function Kte(a) {
      for (var l = a.nextSibling, m = 0; l; ) {
        if (l.nodeType === Ri) {
          var g = l.data;
          if (g === YE) {
            if (m === 0)
              return uw(l);
            m--;
          } else (g === KE || g === cw || g === lw) && m++;
        }
        l = l.nextSibling;
      }
      return null;
    }
    function F3(a) {
      for (var l = a.previousSibling, m = 0; l; ) {
        if (l.nodeType === Ri) {
          var g = l.data;
          if (g === KE || g === cw || g === lw) {
            if (m === 0)
              return l;
            m--;
          } else g === YE && m++;
        }
        l = l.previousSibling;
      }
      return null;
    }
    function Yte(a) {
      pi(a);
    }
    function Qte(a) {
      pi(a);
    }
    function Xte(a) {
      return a !== "head" && a !== "body";
    }
    function Jte(a, l, m, g) {
      var E = !0;
      qE(l.nodeValue, m, g, E);
    }
    function Zte(a, l, m, g, E, _) {
      if (l[GE] !== !0) {
        var B = !0;
        qE(g.nodeValue, E, _, B);
      }
    }
    function ene(a, l) {
      l.nodeType === ua ? qT(a, l) : l.nodeType === Ri || WT(a, l);
    }
    function tne(a, l) {
      {
        var m = a.parentNode;
        m !== null && (l.nodeType === ua ? qT(m, l) : l.nodeType === Ri || WT(m, l));
      }
    }
    function nne(a, l, m, g, E) {
      (E || l[GE] !== !0) && (g.nodeType === ua ? qT(m, g) : g.nodeType === Ri || WT(m, g));
    }
    function rne(a, l, m) {
      GT(a, l);
    }
    function ine(a, l) {
      KT(a, l);
    }
    function one(a, l, m) {
      {
        var g = a.parentNode;
        g !== null && GT(g, l);
      }
    }
    function ane(a, l) {
      {
        var m = a.parentNode;
        m !== null && KT(m, l);
      }
    }
    function sne(a, l, m, g, E, _) {
      (_ || l[GE] !== !0) && GT(m, g);
    }
    function lne(a, l, m, g, E) {
      (E || l[GE] !== !0) && KT(m, g);
    }
    function cne(a) {
      s("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", a.nodeName.toLowerCase());
    }
    function une(a) {
      nw(a);
    }
    var Rv = Math.random().toString(36).slice(2), Ov = "__reactFiber$" + Rv, n2 = "__reactProps$" + Rv, dw = "__reactContainer$" + Rv, r2 = "__reactEvents$" + Rv, dne = "__reactListeners$" + Rv, fne = "__reactHandles$" + Rv;
    function hne(a) {
      delete a[Ov], delete a[n2], delete a[r2], delete a[dne], delete a[fne];
    }
    function fw(a, l) {
      l[Ov] = a;
    }
    function XE(a, l) {
      l[dw] = a;
    }
    function U3(a) {
      a[dw] = null;
    }
    function hw(a) {
      return !!a[dw];
    }
    function em(a) {
      var l = a[Ov];
      if (l)
        return l;
      for (var m = a.parentNode; m; ) {
        if (l = m[dw] || m[Ov], l) {
          var g = l.alternate;
          if (l.child !== null || g !== null && g.child !== null)
            for (var E = F3(a); E !== null; ) {
              var _ = E[Ov];
              if (_)
                return _;
              E = F3(E);
            }
          return l;
        }
        a = m, m = a.parentNode;
      }
      return null;
    }
    function th(a) {
      var l = a[Ov] || a[dw];
      return l && (l.tag === w || l.tag === C || l.tag === L || l.tag === y) ? l : null;
    }
    function Iv(a) {
      if (a.tag === w || a.tag === C)
        return a.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function JE(a) {
      return a[n2] || null;
    }
    function i2(a, l) {
      a[n2] = l;
    }
    function pne(a) {
      var l = a[r2];
      return l === void 0 && (l = a[r2] = /* @__PURE__ */ new Set()), l;
    }
    var z3 = {}, V3 = n.ReactDebugCurrentFrame;
    function ZE(a) {
      if (a) {
        var l = a._owner, m = ds(a.type, a._source, l ? l.type : null);
        V3.setExtraStackFrame(m);
      } else
        V3.setExtraStackFrame(null);
    }
    function xc(a, l, m, g, E) {
      {
        var _ = Function.call.bind(xt);
        for (var B in a)
          if (_(a, B)) {
            var q = void 0;
            try {
              if (typeof a[B] != "function") {
                var G = Error((g || "React class") + ": " + m + " type `" + B + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof a[B] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw G.name = "Invariant Violation", G;
              }
              q = a[B](l, B, g, m, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (se) {
              q = se;
            }
            q && !(q instanceof Error) && (ZE(E), s("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", g || "React class", m, B, typeof q), ZE(null)), q instanceof Error && !(q.message in z3) && (z3[q.message] = !0, ZE(E), s("Failed %s type: %s", m, q.message), ZE(null));
          }
      }
    }
    var o2 = [], eS;
    eS = [];
    var Cd = -1;
    function nh(a) {
      return {
        current: a
      };
    }
    function Ca(a, l) {
      if (Cd < 0) {
        s("Unexpected pop.");
        return;
      }
      l !== eS[Cd] && s("Unexpected Fiber popped."), a.current = o2[Cd], o2[Cd] = null, eS[Cd] = null, Cd--;
    }
    function xa(a, l, m) {
      Cd++, o2[Cd] = a.current, eS[Cd] = m, a.current = l;
    }
    var a2;
    a2 = {};
    var rl = {};
    Object.freeze(rl);
    var xd = nh(rl), yu = nh(!1), s2 = rl;
    function Dv(a, l, m) {
      return m && vu(l) ? s2 : xd.current;
    }
    function $3(a, l, m) {
      {
        var g = a.stateNode;
        g.__reactInternalMemoizedUnmaskedChildContext = l, g.__reactInternalMemoizedMaskedChildContext = m;
      }
    }
    function Mv(a, l) {
      {
        var m = a.type, g = m.contextTypes;
        if (!g)
          return rl;
        var E = a.stateNode;
        if (E && E.__reactInternalMemoizedUnmaskedChildContext === l)
          return E.__reactInternalMemoizedMaskedChildContext;
        var _ = {};
        for (var B in g)
          _[B] = l[B];
        {
          var q = En(a) || "Unknown";
          xc(g, _, "context", q);
        }
        return E && $3(a, l, _), _;
      }
    }
    function tS() {
      return yu.current;
    }
    function vu(a) {
      {
        var l = a.childContextTypes;
        return l != null;
      }
    }
    function nS(a) {
      Ca(yu, a), Ca(xd, a);
    }
    function l2(a) {
      Ca(yu, a), Ca(xd, a);
    }
    function H3(a, l, m) {
      {
        if (xd.current !== rl)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        xa(xd, l, a), xa(yu, m, a);
      }
    }
    function q3(a, l, m) {
      {
        var g = a.stateNode, E = l.childContextTypes;
        if (typeof g.getChildContext != "function") {
          {
            var _ = En(a) || "Unknown";
            a2[_] || (a2[_] = !0, s("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", _, _));
          }
          return m;
        }
        var B = g.getChildContext();
        for (var q in B)
          if (!(q in E))
            throw new Error((En(a) || "Unknown") + '.getChildContext(): key "' + q + '" is not defined in childContextTypes.');
        {
          var G = En(a) || "Unknown";
          xc(E, B, "child context", G);
        }
        return vn({}, m, B);
      }
    }
    function rS(a) {
      {
        var l = a.stateNode, m = l && l.__reactInternalMemoizedMergedChildContext || rl;
        return s2 = xd.current, xa(xd, m, a), xa(yu, yu.current, a), !0;
      }
    }
    function W3(a, l, m) {
      {
        var g = a.stateNode;
        if (!g)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (m) {
          var E = q3(a, l, s2);
          g.__reactInternalMemoizedMergedChildContext = E, Ca(yu, a), Ca(xd, a), xa(xd, E, a), xa(yu, m, a);
        } else
          Ca(yu, a), xa(yu, m, a);
      }
    }
    function mne(a) {
      {
        if (!E0(a) || a.tag !== f)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var l = a;
        do {
          switch (l.tag) {
            case y:
              return l.stateNode.context;
            case f: {
              var m = l.type;
              if (vu(m))
                return l.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          l = l.return;
        } while (l !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var rh = 0, iS = 1, Ed = null, c2 = !1, u2 = !1;
    function G3(a) {
      Ed === null ? Ed = [a] : Ed.push(a);
    }
    function yne(a) {
      c2 = !0, G3(a);
    }
    function K3() {
      c2 && ih();
    }
    function ih() {
      if (!u2 && Ed !== null) {
        u2 = !0;
        var a = 0, l = Es();
        try {
          var m = !0, g = Ed;
          for (hi(Si); a < g.length; a++) {
            var E = g[a];
            do
              E = E(m);
            while (E !== null);
          }
          Ed = null, c2 = !1;
        } catch (_) {
          throw Ed !== null && (Ed = Ed.slice(a + 1)), Oy(Dy, ih), _;
        } finally {
          hi(l), u2 = !1;
        }
      }
      return null;
    }
    var Pv = [], Nv = 0, oS = null, aS = 0, kl = [], Al = 0, tm = null, Sd = 1, kd = "";
    function vne(a) {
      return rm(), (a.flags & w0) !== an;
    }
    function gne(a) {
      return rm(), aS;
    }
    function bne() {
      var a = kd, l = Sd, m = l & ~wne(l);
      return m.toString(32) + a;
    }
    function nm(a, l) {
      rm(), Pv[Nv++] = aS, Pv[Nv++] = oS, oS = a, aS = l;
    }
    function Y3(a, l, m) {
      rm(), kl[Al++] = Sd, kl[Al++] = kd, kl[Al++] = tm, tm = a;
      var g = Sd, E = kd, _ = sS(g) - 1, B = g & ~(1 << _), q = m + 1, G = sS(l) + _;
      if (G > 30) {
        var se = _ - _ % 5, ue = (1 << se) - 1, De = (B & ue).toString(32), Re = B >> se, ze = _ - se, qe = sS(l) + ze, Je = q << ze, Et = Je | Re, un = De + E;
        Sd = 1 << qe | Et, kd = un;
      } else {
        var Jt = q << _, ir = Jt | B, Jn = E;
        Sd = 1 << G | ir, kd = Jn;
      }
    }
    function d2(a) {
      rm();
      var l = a.return;
      if (l !== null) {
        var m = 1, g = 0;
        nm(a, m), Y3(a, m, g);
      }
    }
    function sS(a) {
      return 32 - Of(a);
    }
    function wne(a) {
      return 1 << sS(a) - 1;
    }
    function f2(a) {
      for (; a === oS; )
        oS = Pv[--Nv], Pv[Nv] = null, aS = Pv[--Nv], Pv[Nv] = null;
      for (; a === tm; )
        tm = kl[--Al], kl[Al] = null, kd = kl[--Al], kl[Al] = null, Sd = kl[--Al], kl[Al] = null;
    }
    function Cne() {
      return rm(), tm !== null ? {
        id: Sd,
        overflow: kd
      } : null;
    }
    function xne(a, l) {
      rm(), kl[Al++] = Sd, kl[Al++] = kd, kl[Al++] = tm, Sd = l.id, kd = l.overflow, tm = a;
    }
    function rm() {
      Yo() || s("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var Ko = null, Tl = null, Ec = !1, im = !1, oh = null;
    function Ene() {
      Ec && s("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function Q3() {
      im = !0;
    }
    function Sne() {
      return im;
    }
    function kne(a) {
      var l = a.stateNode.containerInfo;
      return Tl = $te(l), Ko = a, Ec = !0, oh = null, im = !1, !0;
    }
    function Ane(a, l, m) {
      return Tl = Hte(l), Ko = a, Ec = !0, oh = null, im = !1, m !== null && xne(a, m), !0;
    }
    function X3(a, l) {
      switch (a.tag) {
        case y: {
          ene(a.stateNode.containerInfo, l);
          break;
        }
        case w: {
          var m = (a.mode & Xt) !== Gt;
          nne(
            a.type,
            a.memoizedProps,
            a.stateNode,
            l,
            // TODO: Delete this argument when we remove the legacy root API.
            m
          );
          break;
        }
        case L: {
          var g = a.memoizedState;
          g.dehydrated !== null && tne(g.dehydrated, l);
          break;
        }
      }
    }
    function J3(a, l) {
      X3(a, l);
      var m = Ooe();
      m.stateNode = l, m.return = a;
      var g = a.deletions;
      g === null ? (a.deletions = [m], a.flags |= wr) : g.push(m);
    }
    function h2(a, l) {
      {
        if (im)
          return;
        switch (a.tag) {
          case y: {
            var m = a.stateNode.containerInfo;
            switch (l.tag) {
              case w:
                var g = l.type;
                l.pendingProps, rne(m, g);
                break;
              case C:
                var E = l.pendingProps;
                ine(m, E);
                break;
            }
            break;
          }
          case w: {
            var _ = a.type, B = a.memoizedProps, q = a.stateNode;
            switch (l.tag) {
              case w: {
                var G = l.type, se = l.pendingProps, ue = (a.mode & Xt) !== Gt;
                sne(
                  _,
                  B,
                  q,
                  G,
                  se,
                  // TODO: Delete this argument when we remove the legacy root API.
                  ue
                );
                break;
              }
              case C: {
                var De = l.pendingProps, Re = (a.mode & Xt) !== Gt;
                lne(
                  _,
                  B,
                  q,
                  De,
                  // TODO: Delete this argument when we remove the legacy root API.
                  Re
                );
                break;
              }
            }
            break;
          }
          case L: {
            var ze = a.memoizedState, qe = ze.dehydrated;
            if (qe !== null) switch (l.tag) {
              case w:
                var Je = l.type;
                l.pendingProps, one(qe, Je);
                break;
              case C:
                var Et = l.pendingProps;
                ane(qe, Et);
                break;
            }
            break;
          }
          default:
            return;
        }
      }
    }
    function Z3(a, l) {
      l.flags = l.flags & ~vs | qr, h2(a, l);
    }
    function eB(a, l) {
      switch (a.tag) {
        case w: {
          var m = a.type;
          a.pendingProps;
          var g = Lte(l, m);
          return g !== null ? (a.stateNode = g, Ko = a, Tl = Vte(g), !0) : !1;
        }
        case C: {
          var E = a.pendingProps, _ = jte(l, E);
          return _ !== null ? (a.stateNode = _, Ko = a, Tl = null, !0) : !1;
        }
        case L: {
          var B = Fte(l);
          if (B !== null) {
            var q = {
              dehydrated: B,
              treeContext: Cne(),
              retryLane: Lo
            };
            a.memoizedState = q;
            var G = Ioe(B);
            return G.return = a, a.child = G, Ko = a, Tl = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function p2(a) {
      return (a.mode & Xt) !== Gt && (a.flags & Sn) === an;
    }
    function m2(a) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function y2(a) {
      if (Ec) {
        var l = Tl;
        if (!l) {
          p2(a) && (h2(Ko, a), m2()), Z3(Ko, a), Ec = !1, Ko = a;
          return;
        }
        var m = l;
        if (!eB(a, l)) {
          p2(a) && (h2(Ko, a), m2()), l = uw(m);
          var g = Ko;
          if (!l || !eB(a, l)) {
            Z3(Ko, a), Ec = !1, Ko = a;
            return;
          }
          J3(g, m);
        }
      }
    }
    function Tne(a, l, m) {
      var g = a.stateNode, E = !im, _ = qte(g, a.type, a.memoizedProps, l, m, a, E);
      return a.updateQueue = _, _ !== null;
    }
    function _ne(a) {
      var l = a.stateNode, m = a.memoizedProps, g = Wte(l, m, a);
      if (g) {
        var E = Ko;
        if (E !== null)
          switch (E.tag) {
            case y: {
              var _ = E.stateNode.containerInfo, B = (E.mode & Xt) !== Gt;
              Jte(
                _,
                l,
                m,
                // TODO: Delete this argument when we remove the legacy root API.
                B
              );
              break;
            }
            case w: {
              var q = E.type, G = E.memoizedProps, se = E.stateNode, ue = (E.mode & Xt) !== Gt;
              Zte(
                q,
                G,
                se,
                l,
                m,
                // TODO: Delete this argument when we remove the legacy root API.
                ue
              );
              break;
            }
          }
      }
      return g;
    }
    function Rne(a) {
      var l = a.memoizedState, m = l !== null ? l.dehydrated : null;
      if (!m)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      Gte(m, a);
    }
    function One(a) {
      var l = a.memoizedState, m = l !== null ? l.dehydrated : null;
      if (!m)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return Kte(m);
    }
    function tB(a) {
      for (var l = a.return; l !== null && l.tag !== w && l.tag !== y && l.tag !== L; )
        l = l.return;
      Ko = l;
    }
    function lS(a) {
      if (a !== Ko)
        return !1;
      if (!Ec)
        return tB(a), Ec = !0, !1;
      if (a.tag !== y && (a.tag !== w || Xte(a.type) && !XT(a.type, a.memoizedProps))) {
        var l = Tl;
        if (l)
          if (p2(a))
            nB(a), m2();
          else
            for (; l; )
              J3(a, l), l = uw(l);
      }
      return tB(a), a.tag === L ? Tl = One(a) : Tl = Ko ? uw(a.stateNode) : null, !0;
    }
    function Ine() {
      return Ec && Tl !== null;
    }
    function nB(a) {
      for (var l = Tl; l; )
        X3(a, l), l = uw(l);
    }
    function Bv() {
      Ko = null, Tl = null, Ec = !1, im = !1;
    }
    function rB() {
      oh !== null && (Q6(oh), oh = null);
    }
    function Yo() {
      return Ec;
    }
    function v2(a) {
      oh === null ? oh = [a] : oh.push(a);
    }
    var Dne = n.ReactCurrentBatchConfig, Mne = null;
    function Pne() {
      return Dne.transition;
    }
    var Sc = {
      recordUnsafeLifecycleWarnings: function(a, l) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(a, l) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var Nne = function(a) {
        for (var l = null, m = a; m !== null; )
          m.mode & Kn && (l = m), m = m.return;
        return l;
      }, om = function(a) {
        var l = [];
        return a.forEach(function(m) {
          l.push(m);
        }), l.sort().join(", ");
      }, pw = [], mw = [], yw = [], vw = [], gw = [], bw = [], am = /* @__PURE__ */ new Set();
      Sc.recordUnsafeLifecycleWarnings = function(a, l) {
        am.has(a.type) || (typeof l.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        l.componentWillMount.__suppressDeprecationWarning !== !0 && pw.push(a), a.mode & Kn && typeof l.UNSAFE_componentWillMount == "function" && mw.push(a), typeof l.componentWillReceiveProps == "function" && l.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && yw.push(a), a.mode & Kn && typeof l.UNSAFE_componentWillReceiveProps == "function" && vw.push(a), typeof l.componentWillUpdate == "function" && l.componentWillUpdate.__suppressDeprecationWarning !== !0 && gw.push(a), a.mode & Kn && typeof l.UNSAFE_componentWillUpdate == "function" && bw.push(a));
      }, Sc.flushPendingUnsafeLifecycleWarnings = function() {
        var a = /* @__PURE__ */ new Set();
        pw.length > 0 && (pw.forEach(function(Re) {
          a.add(En(Re) || "Component"), am.add(Re.type);
        }), pw = []);
        var l = /* @__PURE__ */ new Set();
        mw.length > 0 && (mw.forEach(function(Re) {
          l.add(En(Re) || "Component"), am.add(Re.type);
        }), mw = []);
        var m = /* @__PURE__ */ new Set();
        yw.length > 0 && (yw.forEach(function(Re) {
          m.add(En(Re) || "Component"), am.add(Re.type);
        }), yw = []);
        var g = /* @__PURE__ */ new Set();
        vw.length > 0 && (vw.forEach(function(Re) {
          g.add(En(Re) || "Component"), am.add(Re.type);
        }), vw = []);
        var E = /* @__PURE__ */ new Set();
        gw.length > 0 && (gw.forEach(function(Re) {
          E.add(En(Re) || "Component"), am.add(Re.type);
        }), gw = []);
        var _ = /* @__PURE__ */ new Set();
        if (bw.length > 0 && (bw.forEach(function(Re) {
          _.add(En(Re) || "Component"), am.add(Re.type);
        }), bw = []), l.size > 0) {
          var B = om(l);
          s(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, B);
        }
        if (g.size > 0) {
          var q = om(g);
          s(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, q);
        }
        if (_.size > 0) {
          var G = om(_);
          s(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, G);
        }
        if (a.size > 0) {
          var se = om(a);
          o(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, se);
        }
        if (m.size > 0) {
          var ue = om(m);
          o(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, ue);
        }
        if (E.size > 0) {
          var De = om(E);
          o(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, De);
        }
      };
      var cS = /* @__PURE__ */ new Map(), iB = /* @__PURE__ */ new Set();
      Sc.recordLegacyContextWarning = function(a, l) {
        var m = Nne(a);
        if (m === null) {
          s("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!iB.has(a.type)) {
          var g = cS.get(m);
          (a.type.contextTypes != null || a.type.childContextTypes != null || l !== null && typeof l.getChildContext == "function") && (g === void 0 && (g = [], cS.set(m, g)), g.push(a));
        }
      }, Sc.flushLegacyContextWarning = function() {
        cS.forEach(function(a, l) {
          if (a.length !== 0) {
            var m = a[0], g = /* @__PURE__ */ new Set();
            a.forEach(function(_) {
              g.add(En(_) || "Component"), iB.add(_.type);
            });
            var E = om(g);
            try {
              lr(m), s(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, E);
            } finally {
              Hr();
            }
          }
        });
      }, Sc.discardPendingWarnings = function() {
        pw = [], mw = [], yw = [], vw = [], gw = [], bw = [], cS = /* @__PURE__ */ new Map();
      };
    }
    var g2, b2, w2, C2, x2, oB = function(a, l) {
    };
    g2 = !1, b2 = !1, w2 = {}, C2 = {}, x2 = {}, oB = function(a, l) {
      if (!(a === null || typeof a != "object") && !(!a._store || a._store.validated || a.key != null)) {
        if (typeof a._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        a._store.validated = !0;
        var m = En(l) || "Component";
        C2[m] || (C2[m] = !0, s('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function Bne(a) {
      return a.prototype && a.prototype.isReactComponent;
    }
    function ww(a, l, m) {
      var g = m.ref;
      if (g !== null && typeof g != "function" && typeof g != "object") {
        if ((a.mode & Kn || Se) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(m._owner && m._self && m._owner.stateNode !== m._self) && // Will already throw with "Function components cannot have string refs"
        !(m._owner && m._owner.tag !== f) && // Will already warn with "Function components cannot be given refs"
        !(typeof m.type == "function" && !Bne(m.type)) && // Will already throw with "Element ref was specified as a string (someStringRef) but no owner was set"
        m._owner) {
          var E = En(a) || "Component";
          w2[E] || (s('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', E, g), w2[E] = !0);
        }
        if (m._owner) {
          var _ = m._owner, B;
          if (_) {
            var q = _;
            if (q.tag !== f)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            B = q.stateNode;
          }
          if (!B)
            throw new Error("Missing owner for string ref " + g + ". This error is likely caused by a bug in React. Please file an issue.");
          var G = B;
          ar(g, "ref");
          var se = "" + g;
          if (l !== null && l.ref !== null && typeof l.ref == "function" && l.ref._stringRef === se)
            return l.ref;
          var ue = function(De) {
            var Re = G.refs;
            De === null ? delete Re[se] : Re[se] = De;
          };
          return ue._stringRef = se, ue;
        } else {
          if (typeof g != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!m._owner)
            throw new Error("Element ref was specified as a string (" + g + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return g;
    }
    function uS(a, l) {
      var m = Object.prototype.toString.call(l);
      throw new Error("Objects are not valid as a React child (found: " + (m === "[object Object]" ? "object with keys {" + Object.keys(l).join(", ") + "}" : m) + "). If you meant to render a collection of children, use an array instead.");
    }
    function dS(a) {
      {
        var l = En(a) || "Component";
        if (x2[l])
          return;
        x2[l] = !0, s("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function aB(a) {
      var l = a._payload, m = a._init;
      return m(l);
    }
    function sB(a) {
      function l(Le, Ze) {
        if (a) {
          var je = Le.deletions;
          je === null ? (Le.deletions = [Ze], Le.flags |= wr) : je.push(Ze);
        }
      }
      function m(Le, Ze) {
        if (!a)
          return null;
        for (var je = Ze; je !== null; )
          l(Le, je), je = je.sibling;
        return null;
      }
      function g(Le, Ze) {
        for (var je = /* @__PURE__ */ new Map(), dt = Ze; dt !== null; )
          dt.key !== null ? je.set(dt.key, dt) : je.set(dt.index, dt), dt = dt.sibling;
        return je;
      }
      function E(Le, Ze) {
        var je = mm(Le, Ze);
        return je.index = 0, je.sibling = null, je;
      }
      function _(Le, Ze, je) {
        if (Le.index = je, !a)
          return Le.flags |= w0, Ze;
        var dt = Le.alternate;
        if (dt !== null) {
          var Dt = dt.index;
          return Dt < Ze ? (Le.flags |= qr, Ze) : Dt;
        } else
          return Le.flags |= qr, Ze;
      }
      function B(Le) {
        return a && Le.alternate === null && (Le.flags |= qr), Le;
      }
      function q(Le, Ze, je, dt) {
        if (Ze === null || Ze.tag !== C) {
          var Dt = vR(je, Le.mode, dt);
          return Dt.return = Le, Dt;
        } else {
          var At = E(Ze, je);
          return At.return = Le, At;
        }
      }
      function G(Le, Ze, je, dt) {
        var Dt = je.type;
        if (Dt === we)
          return ue(Le, Ze, je.props.children, dt, je.key);
        if (Ze !== null && (Ze.elementType === Dt || // Keep this check inline so it only runs on the false path:
        fL(Ze, je) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof Dt == "object" && Dt !== null && Dt.$$typeof === tt && aB(Dt) === Ze.type)) {
          var At = E(Ze, je.props);
          return At.ref = ww(Le, Ze, je), At.return = Le, At._debugSource = je._source, At._debugOwner = je._owner, At;
        }
        var Cn = yR(je, Le.mode, dt);
        return Cn.ref = ww(Le, Ze, je), Cn.return = Le, Cn;
      }
      function se(Le, Ze, je, dt) {
        if (Ze === null || Ze.tag !== v || Ze.stateNode.containerInfo !== je.containerInfo || Ze.stateNode.implementation !== je.implementation) {
          var Dt = gR(je, Le.mode, dt);
          return Dt.return = Le, Dt;
        } else {
          var At = E(Ze, je.children || []);
          return At.return = Le, At;
        }
      }
      function ue(Le, Ze, je, dt, Dt) {
        if (Ze === null || Ze.tag !== x) {
          var At = yh(je, Le.mode, dt, Dt);
          return At.return = Le, At;
        } else {
          var Cn = E(Ze, je);
          return Cn.return = Le, Cn;
        }
      }
      function De(Le, Ze, je) {
        if (typeof Ze == "string" && Ze !== "" || typeof Ze == "number") {
          var dt = vR("" + Ze, Le.mode, je);
          return dt.return = Le, dt;
        }
        if (typeof Ze == "object" && Ze !== null) {
          switch (Ze.$$typeof) {
            case ho: {
              var Dt = yR(Ze, Le.mode, je);
              return Dt.ref = ww(Le, null, Ze), Dt.return = Le, Dt;
            }
            case wi: {
              var At = gR(Ze, Le.mode, je);
              return At.return = Le, At;
            }
            case tt: {
              var Cn = Ze._payload, In = Ze._init;
              return De(Le, In(Cn), je);
            }
          }
          if (Zn(Ze) || xr(Ze)) {
            var Dr = yh(Ze, Le.mode, je, null);
            return Dr.return = Le, Dr;
          }
          uS(Le, Ze);
        }
        return typeof Ze == "function" && dS(Le), null;
      }
      function Re(Le, Ze, je, dt) {
        var Dt = Ze !== null ? Ze.key : null;
        if (typeof je == "string" && je !== "" || typeof je == "number")
          return Dt !== null ? null : q(Le, Ze, "" + je, dt);
        if (typeof je == "object" && je !== null) {
          switch (je.$$typeof) {
            case ho:
              return je.key === Dt ? G(Le, Ze, je, dt) : null;
            case wi:
              return je.key === Dt ? se(Le, Ze, je, dt) : null;
            case tt: {
              var At = je._payload, Cn = je._init;
              return Re(Le, Ze, Cn(At), dt);
            }
          }
          if (Zn(je) || xr(je))
            return Dt !== null ? null : ue(Le, Ze, je, dt, null);
          uS(Le, je);
        }
        return typeof je == "function" && dS(Le), null;
      }
      function ze(Le, Ze, je, dt, Dt) {
        if (typeof dt == "string" && dt !== "" || typeof dt == "number") {
          var At = Le.get(je) || null;
          return q(Ze, At, "" + dt, Dt);
        }
        if (typeof dt == "object" && dt !== null) {
          switch (dt.$$typeof) {
            case ho: {
              var Cn = Le.get(dt.key === null ? je : dt.key) || null;
              return G(Ze, Cn, dt, Dt);
            }
            case wi: {
              var In = Le.get(dt.key === null ? je : dt.key) || null;
              return se(Ze, In, dt, Dt);
            }
            case tt:
              var Dr = dt._payload, yr = dt._init;
              return ze(Le, Ze, je, yr(Dr), Dt);
          }
          if (Zn(dt) || xr(dt)) {
            var qi = Le.get(je) || null;
            return ue(Ze, qi, dt, Dt, null);
          }
          uS(Ze, dt);
        }
        return typeof dt == "function" && dS(Ze), null;
      }
      function qe(Le, Ze, je) {
        {
          if (typeof Le != "object" || Le === null)
            return Ze;
          switch (Le.$$typeof) {
            case ho:
            case wi:
              oB(Le, je);
              var dt = Le.key;
              if (typeof dt != "string")
                break;
              if (Ze === null) {
                Ze = /* @__PURE__ */ new Set(), Ze.add(dt);
                break;
              }
              if (!Ze.has(dt)) {
                Ze.add(dt);
                break;
              }
              s("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", dt);
              break;
            case tt:
              var Dt = Le._payload, At = Le._init;
              qe(At(Dt), Ze, je);
              break;
          }
        }
        return Ze;
      }
      function Je(Le, Ze, je, dt) {
        for (var Dt = null, At = 0; At < je.length; At++) {
          var Cn = je[At];
          Dt = qe(Cn, Dt, Le);
        }
        for (var In = null, Dr = null, yr = Ze, qi = 0, vr = 0, Di = null; yr !== null && vr < je.length; vr++) {
          yr.index > vr ? (Di = yr, yr = null) : Di = yr.sibling;
          var Sa = Re(Le, yr, je[vr], dt);
          if (Sa === null) {
            yr === null && (yr = Di);
            break;
          }
          a && yr && Sa.alternate === null && l(Le, yr), qi = _(Sa, qi, vr), Dr === null ? In = Sa : Dr.sibling = Sa, Dr = Sa, yr = Di;
        }
        if (vr === je.length) {
          if (m(Le, yr), Yo()) {
            var na = vr;
            nm(Le, na);
          }
          return In;
        }
        if (yr === null) {
          for (; vr < je.length; vr++) {
            var ol = De(Le, je[vr], dt);
            ol !== null && (qi = _(ol, qi, vr), Dr === null ? In = ol : Dr.sibling = ol, Dr = ol);
          }
          if (Yo()) {
            var Qa = vr;
            nm(Le, Qa);
          }
          return In;
        }
        for (var Xa = g(Le, yr); vr < je.length; vr++) {
          var ka = ze(Xa, Le, vr, je[vr], dt);
          ka !== null && (a && ka.alternate !== null && Xa.delete(ka.key === null ? vr : ka.key), qi = _(ka, qi, vr), Dr === null ? In = ka : Dr.sibling = ka, Dr = ka);
        }
        if (a && Xa.forEach(function(tg) {
          return l(Le, tg);
        }), Yo()) {
          var Dd = vr;
          nm(Le, Dd);
        }
        return In;
      }
      function Et(Le, Ze, je, dt) {
        var Dt = xr(je);
        if (typeof Dt != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          je[Symbol.toStringTag] === "Generator" && (b2 || s("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), b2 = !0), je.entries === Dt && (g2 || s("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), g2 = !0);
          var At = Dt.call(je);
          if (At)
            for (var Cn = null, In = At.next(); !In.done; In = At.next()) {
              var Dr = In.value;
              Cn = qe(Dr, Cn, Le);
            }
        }
        var yr = Dt.call(je);
        if (yr == null)
          throw new Error("An iterable object provided no iterator.");
        for (var qi = null, vr = null, Di = Ze, Sa = 0, na = 0, ol = null, Qa = yr.next(); Di !== null && !Qa.done; na++, Qa = yr.next()) {
          Di.index > na ? (ol = Di, Di = null) : ol = Di.sibling;
          var Xa = Re(Le, Di, Qa.value, dt);
          if (Xa === null) {
            Di === null && (Di = ol);
            break;
          }
          a && Di && Xa.alternate === null && l(Le, Di), Sa = _(Xa, Sa, na), vr === null ? qi = Xa : vr.sibling = Xa, vr = Xa, Di = ol;
        }
        if (Qa.done) {
          if (m(Le, Di), Yo()) {
            var ka = na;
            nm(Le, ka);
          }
          return qi;
        }
        if (Di === null) {
          for (; !Qa.done; na++, Qa = yr.next()) {
            var Dd = De(Le, Qa.value, dt);
            Dd !== null && (Sa = _(Dd, Sa, na), vr === null ? qi = Dd : vr.sibling = Dd, vr = Dd);
          }
          if (Yo()) {
            var tg = na;
            nm(Le, tg);
          }
          return qi;
        }
        for (var Jw = g(Le, Di); !Qa.done; na++, Qa = yr.next()) {
          var ku = ze(Jw, Le, na, Qa.value, dt);
          ku !== null && (a && ku.alternate !== null && Jw.delete(ku.key === null ? na : ku.key), Sa = _(ku, Sa, na), vr === null ? qi = ku : vr.sibling = ku, vr = ku);
        }
        if (a && Jw.forEach(function(cae) {
          return l(Le, cae);
        }), Yo()) {
          var lae = na;
          nm(Le, lae);
        }
        return qi;
      }
      function un(Le, Ze, je, dt) {
        if (Ze !== null && Ze.tag === C) {
          m(Le, Ze.sibling);
          var Dt = E(Ze, je);
          return Dt.return = Le, Dt;
        }
        m(Le, Ze);
        var At = vR(je, Le.mode, dt);
        return At.return = Le, At;
      }
      function Jt(Le, Ze, je, dt) {
        for (var Dt = je.key, At = Ze; At !== null; ) {
          if (At.key === Dt) {
            var Cn = je.type;
            if (Cn === we) {
              if (At.tag === x) {
                m(Le, At.sibling);
                var In = E(At, je.props.children);
                return In.return = Le, In._debugSource = je._source, In._debugOwner = je._owner, In;
              }
            } else if (At.elementType === Cn || // Keep this check inline so it only runs on the false path:
            fL(At, je) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof Cn == "object" && Cn !== null && Cn.$$typeof === tt && aB(Cn) === At.type) {
              m(Le, At.sibling);
              var Dr = E(At, je.props);
              return Dr.ref = ww(Le, At, je), Dr.return = Le, Dr._debugSource = je._source, Dr._debugOwner = je._owner, Dr;
            }
            m(Le, At);
            break;
          } else
            l(Le, At);
          At = At.sibling;
        }
        if (je.type === we) {
          var yr = yh(je.props.children, Le.mode, dt, je.key);
          return yr.return = Le, yr;
        } else {
          var qi = yR(je, Le.mode, dt);
          return qi.ref = ww(Le, Ze, je), qi.return = Le, qi;
        }
      }
      function ir(Le, Ze, je, dt) {
        for (var Dt = je.key, At = Ze; At !== null; ) {
          if (At.key === Dt)
            if (At.tag === v && At.stateNode.containerInfo === je.containerInfo && At.stateNode.implementation === je.implementation) {
              m(Le, At.sibling);
              var Cn = E(At, je.children || []);
              return Cn.return = Le, Cn;
            } else {
              m(Le, At);
              break;
            }
          else
            l(Le, At);
          At = At.sibling;
        }
        var In = gR(je, Le.mode, dt);
        return In.return = Le, In;
      }
      function Jn(Le, Ze, je, dt) {
        var Dt = typeof je == "object" && je !== null && je.type === we && je.key === null;
        if (Dt && (je = je.props.children), typeof je == "object" && je !== null) {
          switch (je.$$typeof) {
            case ho:
              return B(Jt(Le, Ze, je, dt));
            case wi:
              return B(ir(Le, Ze, je, dt));
            case tt:
              var At = je._payload, Cn = je._init;
              return Jn(Le, Ze, Cn(At), dt);
          }
          if (Zn(je))
            return Je(Le, Ze, je, dt);
          if (xr(je))
            return Et(Le, Ze, je, dt);
          uS(Le, je);
        }
        return typeof je == "string" && je !== "" || typeof je == "number" ? B(un(Le, Ze, "" + je, dt)) : (typeof je == "function" && dS(Le), m(Le, Ze));
      }
      return Jn;
    }
    var Lv = sB(!0), lB = sB(!1);
    function Lne(a, l) {
      if (a !== null && l.child !== a.child)
        throw new Error("Resuming work not yet implemented.");
      if (l.child !== null) {
        var m = l.child, g = mm(m, m.pendingProps);
        for (l.child = g, g.return = l; m.sibling !== null; )
          m = m.sibling, g = g.sibling = mm(m, m.pendingProps), g.return = l;
        g.sibling = null;
      }
    }
    function jne(a, l) {
      for (var m = a.child; m !== null; )
        koe(m, l), m = m.sibling;
    }
    var E2 = nh(null), S2;
    S2 = {};
    var fS = null, jv = null, k2 = null, hS = !1;
    function pS() {
      fS = null, jv = null, k2 = null, hS = !1;
    }
    function cB() {
      hS = !0;
    }
    function uB() {
      hS = !1;
    }
    function dB(a, l, m) {
      xa(E2, l._currentValue, a), l._currentValue = m, l._currentRenderer !== void 0 && l._currentRenderer !== null && l._currentRenderer !== S2 && s("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), l._currentRenderer = S2;
    }
    function A2(a, l) {
      var m = E2.current;
      Ca(E2, l), a._currentValue = m;
    }
    function T2(a, l, m) {
      for (var g = a; g !== null; ) {
        var E = g.alternate;
        if (hd(g.childLanes, l) ? E !== null && !hd(E.childLanes, l) && (E.childLanes = Mn(E.childLanes, l)) : (g.childLanes = Mn(g.childLanes, l), E !== null && (E.childLanes = Mn(E.childLanes, l))), g === m)
          break;
        g = g.return;
      }
      g !== m && s("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function Fne(a, l, m) {
      Une(a, l, m);
    }
    function Une(a, l, m) {
      var g = a.child;
      for (g !== null && (g.return = a); g !== null; ) {
        var E = void 0, _ = g.dependencies;
        if (_ !== null) {
          E = g.child;
          for (var B = _.firstContext; B !== null; ) {
            if (B.context === l) {
              if (g.tag === f) {
                var q = Lf(m), G = Ad(Vr, q);
                G.tag = yS;
                var se = g.updateQueue;
                if (se !== null) {
                  var ue = se.shared, De = ue.pending;
                  De === null ? G.next = G : (G.next = De.next, De.next = G), ue.pending = G;
                }
              }
              g.lanes = Mn(g.lanes, m);
              var Re = g.alternate;
              Re !== null && (Re.lanes = Mn(Re.lanes, m)), T2(g.return, m, a), _.lanes = Mn(_.lanes, m);
              break;
            }
            B = B.next;
          }
        } else if (g.tag === I)
          E = g.type === a.type ? null : g.child;
        else if (g.tag === H) {
          var ze = g.return;
          if (ze === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          ze.lanes = Mn(ze.lanes, m);
          var qe = ze.alternate;
          qe !== null && (qe.lanes = Mn(qe.lanes, m)), T2(ze, m, a), E = g.sibling;
        } else
          E = g.child;
        if (E !== null)
          E.return = g;
        else
          for (E = g; E !== null; ) {
            if (E === a) {
              E = null;
              break;
            }
            var Je = E.sibling;
            if (Je !== null) {
              Je.return = E.return, E = Je;
              break;
            }
            E = E.return;
          }
        g = E;
      }
    }
    function Fv(a, l) {
      fS = a, jv = null, k2 = null;
      var m = a.dependencies;
      if (m !== null) {
        var g = m.firstContext;
        g !== null && (ba(m.lanes, l) && Nw(), m.firstContext = null);
      }
    }
    function oo(a) {
      hS && s("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var l = a._currentValue;
      if (k2 !== a) {
        var m = {
          context: a,
          memoizedValue: l,
          next: null
        };
        if (jv === null) {
          if (fS === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          jv = m, fS.dependencies = {
            lanes: nt,
            firstContext: m
          };
        } else
          jv = jv.next = m;
      }
      return l;
    }
    var sm = null;
    function _2(a) {
      sm === null ? sm = [a] : sm.push(a);
    }
    function zne() {
      if (sm !== null) {
        for (var a = 0; a < sm.length; a++) {
          var l = sm[a], m = l.interleaved;
          if (m !== null) {
            l.interleaved = null;
            var g = m.next, E = l.pending;
            if (E !== null) {
              var _ = E.next;
              E.next = g, m.next = _;
            }
            l.pending = m;
          }
        }
        sm = null;
      }
    }
    function fB(a, l, m, g) {
      var E = l.interleaved;
      return E === null ? (m.next = m, _2(l)) : (m.next = E.next, E.next = m), l.interleaved = m, mS(a, g);
    }
    function Vne(a, l, m, g) {
      var E = l.interleaved;
      E === null ? (m.next = m, _2(l)) : (m.next = E.next, E.next = m), l.interleaved = m;
    }
    function $ne(a, l, m, g) {
      var E = l.interleaved;
      return E === null ? (m.next = m, _2(l)) : (m.next = E.next, E.next = m), l.interleaved = m, mS(a, g);
    }
    function Rs(a, l) {
      return mS(a, l);
    }
    var Hne = mS;
    function mS(a, l) {
      a.lanes = Mn(a.lanes, l);
      var m = a.alternate;
      m !== null && (m.lanes = Mn(m.lanes, l)), m === null && (a.flags & (qr | vs)) !== an && lL(a);
      for (var g = a, E = a.return; E !== null; )
        E.childLanes = Mn(E.childLanes, l), m = E.alternate, m !== null ? m.childLanes = Mn(m.childLanes, l) : (E.flags & (qr | vs)) !== an && lL(a), g = E, E = E.return;
      if (g.tag === y) {
        var _ = g.stateNode;
        return _;
      } else
        return null;
    }
    var hB = 0, pB = 1, yS = 2, R2 = 3, vS = !1, O2, gS;
    O2 = !1, gS = null;
    function I2(a) {
      var l = {
        baseState: a.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: nt
        },
        effects: null
      };
      a.updateQueue = l;
    }
    function mB(a, l) {
      var m = l.updateQueue, g = a.updateQueue;
      if (m === g) {
        var E = {
          baseState: g.baseState,
          firstBaseUpdate: g.firstBaseUpdate,
          lastBaseUpdate: g.lastBaseUpdate,
          shared: g.shared,
          effects: g.effects
        };
        l.updateQueue = E;
      }
    }
    function Ad(a, l) {
      var m = {
        eventTime: a,
        lane: l,
        tag: hB,
        payload: null,
        callback: null,
        next: null
      };
      return m;
    }
    function ah(a, l, m) {
      var g = a.updateQueue;
      if (g === null)
        return null;
      var E = g.shared;
      if (gS === E && !O2 && (s("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), O2 = !0), Vie()) {
        var _ = E.pending;
        return _ === null ? l.next = l : (l.next = _.next, _.next = l), E.pending = l, Hne(a, m);
      } else
        return $ne(a, E, l, m);
    }
    function bS(a, l, m) {
      var g = l.updateQueue;
      if (g !== null) {
        var E = g.shared;
        if (N0(m)) {
          var _ = E.lanes;
          _ = nv(_, a.pendingLanes);
          var B = Mn(_, m);
          E.lanes = B, B0(a, B);
        }
      }
    }
    function D2(a, l) {
      var m = a.updateQueue, g = a.alternate;
      if (g !== null) {
        var E = g.updateQueue;
        if (m === E) {
          var _ = null, B = null, q = m.firstBaseUpdate;
          if (q !== null) {
            var G = q;
            do {
              var se = {
                eventTime: G.eventTime,
                lane: G.lane,
                tag: G.tag,
                payload: G.payload,
                callback: G.callback,
                next: null
              };
              B === null ? _ = B = se : (B.next = se, B = se), G = G.next;
            } while (G !== null);
            B === null ? _ = B = l : (B.next = l, B = l);
          } else
            _ = B = l;
          m = {
            baseState: E.baseState,
            firstBaseUpdate: _,
            lastBaseUpdate: B,
            shared: E.shared,
            effects: E.effects
          }, a.updateQueue = m;
          return;
        }
      }
      var ue = m.lastBaseUpdate;
      ue === null ? m.firstBaseUpdate = l : ue.next = l, m.lastBaseUpdate = l;
    }
    function qne(a, l, m, g, E, _) {
      switch (m.tag) {
        case pB: {
          var B = m.payload;
          if (typeof B == "function") {
            cB();
            var q = B.call(_, g, E);
            {
              if (a.mode & Kn) {
                Oi(!0);
                try {
                  B.call(_, g, E);
                } finally {
                  Oi(!1);
                }
              }
              uB();
            }
            return q;
          }
          return B;
        }
        case R2:
          a.flags = a.flags & ~to | Sn;
        case hB: {
          var G = m.payload, se;
          if (typeof G == "function") {
            cB(), se = G.call(_, g, E);
            {
              if (a.mode & Kn) {
                Oi(!0);
                try {
                  G.call(_, g, E);
                } finally {
                  Oi(!1);
                }
              }
              uB();
            }
          } else
            se = G;
          return se == null ? g : vn({}, g, se);
        }
        case yS:
          return vS = !0, g;
      }
      return g;
    }
    function wS(a, l, m, g) {
      var E = a.updateQueue;
      vS = !1, gS = E.shared;
      var _ = E.firstBaseUpdate, B = E.lastBaseUpdate, q = E.shared.pending;
      if (q !== null) {
        E.shared.pending = null;
        var G = q, se = G.next;
        G.next = null, B === null ? _ = se : B.next = se, B = G;
        var ue = a.alternate;
        if (ue !== null) {
          var De = ue.updateQueue, Re = De.lastBaseUpdate;
          Re !== B && (Re === null ? De.firstBaseUpdate = se : Re.next = se, De.lastBaseUpdate = G);
        }
      }
      if (_ !== null) {
        var ze = E.baseState, qe = nt, Je = null, Et = null, un = null, Jt = _;
        do {
          var ir = Jt.lane, Jn = Jt.eventTime;
          if (hd(g, ir)) {
            if (un !== null) {
              var Ze = {
                eventTime: Jn,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Ii,
                tag: Jt.tag,
                payload: Jt.payload,
                callback: Jt.callback,
                next: null
              };
              un = un.next = Ze;
            }
            ze = qne(a, E, Jt, ze, l, m);
            var je = Jt.callback;
            if (je !== null && // If the update was already committed, we should not queue its
            // callback again.
            Jt.lane !== Ii) {
              a.flags |= bl;
              var dt = E.effects;
              dt === null ? E.effects = [Jt] : dt.push(Jt);
            }
          } else {
            var Le = {
              eventTime: Jn,
              lane: ir,
              tag: Jt.tag,
              payload: Jt.payload,
              callback: Jt.callback,
              next: null
            };
            un === null ? (Et = un = Le, Je = ze) : un = un.next = Le, qe = Mn(qe, ir);
          }
          if (Jt = Jt.next, Jt === null) {
            if (q = E.shared.pending, q === null)
              break;
            var Dt = q, At = Dt.next;
            Dt.next = null, Jt = At, E.lastBaseUpdate = Dt, E.shared.pending = null;
          }
        } while (!0);
        un === null && (Je = ze), E.baseState = Je, E.firstBaseUpdate = Et, E.lastBaseUpdate = un;
        var Cn = E.shared.interleaved;
        if (Cn !== null) {
          var In = Cn;
          do
            qe = Mn(qe, In.lane), In = In.next;
          while (In !== Cn);
        } else _ === null && (E.shared.lanes = nt);
        Gw(qe), a.lanes = qe, a.memoizedState = ze;
      }
      gS = null;
    }
    function Wne(a, l) {
      if (typeof a != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + a));
      a.call(l);
    }
    function yB() {
      vS = !1;
    }
    function CS() {
      return vS;
    }
    function vB(a, l, m) {
      var g = l.effects;
      if (l.effects = null, g !== null)
        for (var E = 0; E < g.length; E++) {
          var _ = g[E], B = _.callback;
          B !== null && (_.callback = null, Wne(B, m));
        }
    }
    var Cw = {}, sh = nh(Cw), xw = nh(Cw), xS = nh(Cw);
    function ES(a) {
      if (a === Cw)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return a;
    }
    function gB() {
      var a = ES(xS.current);
      return a;
    }
    function M2(a, l) {
      xa(xS, l, a), xa(xw, a, a), xa(sh, Cw, a);
      var m = cte(l);
      Ca(sh, a), xa(sh, m, a);
    }
    function Uv(a) {
      Ca(sh, a), Ca(xw, a), Ca(xS, a);
    }
    function P2() {
      var a = ES(sh.current);
      return a;
    }
    function bB(a) {
      ES(xS.current);
      var l = ES(sh.current), m = ute(l, a.type);
      l !== m && (xa(xw, a, a), xa(sh, m, a));
    }
    function N2(a) {
      xw.current === a && (Ca(sh, a), Ca(xw, a));
    }
    var Gne = 0, wB = 1, CB = 1, Ew = 2, kc = nh(Gne);
    function B2(a, l) {
      return (a & l) !== 0;
    }
    function zv(a) {
      return a & wB;
    }
    function L2(a, l) {
      return a & wB | l;
    }
    function Kne(a, l) {
      return a | l;
    }
    function lh(a, l) {
      xa(kc, l, a);
    }
    function Vv(a) {
      Ca(kc, a);
    }
    function Yne(a, l) {
      var m = a.memoizedState;
      return m !== null ? m.dehydrated !== null : (a.memoizedProps, !0);
    }
    function SS(a) {
      for (var l = a; l !== null; ) {
        if (l.tag === L) {
          var m = l.memoizedState;
          if (m !== null) {
            var g = m.dehydrated;
            if (g === null || j3(g) || t2(g))
              return l;
          }
        } else if (l.tag === Q && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        l.memoizedProps.revealOrder !== void 0) {
          var E = (l.flags & Sn) !== an;
          if (E)
            return l;
        } else if (l.child !== null) {
          l.child.return = l, l = l.child;
          continue;
        }
        if (l === a)
          return null;
        for (; l.sibling === null; ) {
          if (l.return === null || l.return === a)
            return null;
          l = l.return;
        }
        l.sibling.return = l.return, l = l.sibling;
      }
      return null;
    }
    var Os = (
      /*   */
      0
    ), go = (
      /* */
      1
    ), gu = (
      /*  */
      2
    ), bo = (
      /*    */
      4
    ), Qo = (
      /*   */
      8
    ), j2 = [];
    function F2() {
      for (var a = 0; a < j2.length; a++) {
        var l = j2[a];
        l._workInProgressVersionPrimary = null;
      }
      j2.length = 0;
    }
    function Qne(a, l) {
      var m = l._getVersion, g = m(l._source);
      a.mutableSourceEagerHydrationData == null ? a.mutableSourceEagerHydrationData = [l, g] : a.mutableSourceEagerHydrationData.push(l, g);
    }
    var Rt = n.ReactCurrentDispatcher, Sw = n.ReactCurrentBatchConfig, U2, $v;
    U2 = /* @__PURE__ */ new Set();
    var lm = nt, Ir = null, wo = null, Co = null, kS = !1, kw = !1, Aw = 0, Xne = 0, Jne = 25, et = null, _l = null, ch = -1, z2 = !1;
    function Ar() {
      {
        var a = et;
        _l === null ? _l = [a] : _l.push(a);
      }
    }
    function wt() {
      {
        var a = et;
        _l !== null && (ch++, _l[ch] !== a && Zne(a));
      }
    }
    function Hv(a) {
      a != null && !Zn(a) && s("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", et, typeof a);
    }
    function Zne(a) {
      {
        var l = En(Ir);
        if (!U2.has(l) && (U2.add(l), _l !== null)) {
          for (var m = "", g = 30, E = 0; E <= ch; E++) {
            for (var _ = _l[E], B = E === ch ? a : _, q = E + 1 + ". " + _; q.length < g; )
              q += " ";
            q += B + `
`, m += q;
          }
          s(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, l, m);
        }
      }
    }
    function Ea() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function V2(a, l) {
      if (z2)
        return !1;
      if (l === null)
        return s("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", et), !1;
      a.length !== l.length && s(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, et, "[" + l.join(", ") + "]", "[" + a.join(", ") + "]");
      for (var m = 0; m < l.length && m < a.length; m++)
        if (!jt(a[m], l[m]))
          return !1;
      return !0;
    }
    function qv(a, l, m, g, E, _) {
      lm = _, Ir = l, _l = a !== null ? a._debugHookTypes : null, ch = -1, z2 = a !== null && a.type !== l.type, l.memoizedState = null, l.updateQueue = null, l.lanes = nt, a !== null && a.memoizedState !== null ? Rt.current = $B : _l !== null ? Rt.current = VB : Rt.current = zB;
      var B = m(g, E);
      if (kw) {
        var q = 0;
        do {
          if (kw = !1, Aw = 0, q >= Jne)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          q += 1, z2 = !1, wo = null, Co = null, l.updateQueue = null, ch = -1, Rt.current = HB, B = m(g, E);
        } while (kw);
      }
      Rt.current = jS, l._debugHookTypes = _l;
      var G = wo !== null && wo.next !== null;
      if (lm = nt, Ir = null, wo = null, Co = null, et = null, _l = null, ch = -1, a !== null && (a.flags & mo) !== (l.flags & mo) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (a.mode & Xt) !== Gt && s("Internal React error: Expected static flag was missing. Please notify the React team."), kS = !1, G)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return B;
    }
    function Wv() {
      var a = Aw !== 0;
      return Aw = 0, a;
    }
    function xB(a, l, m) {
      l.updateQueue = a.updateQueue, (l.mode & qa) !== Gt ? l.flags &= ~(id | ha | Jr | Bn) : l.flags &= ~(Jr | Bn), a.lanes = Fp(a.lanes, m);
    }
    function EB() {
      if (Rt.current = jS, kS) {
        for (var a = Ir.memoizedState; a !== null; ) {
          var l = a.queue;
          l !== null && (l.pending = null), a = a.next;
        }
        kS = !1;
      }
      lm = nt, Ir = null, wo = null, Co = null, _l = null, ch = -1, et = null, BB = !1, kw = !1, Aw = 0;
    }
    function bu() {
      var a = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Co === null ? Ir.memoizedState = Co = a : Co = Co.next = a, Co;
    }
    function Rl() {
      var a;
      if (wo === null) {
        var l = Ir.alternate;
        l !== null ? a = l.memoizedState : a = null;
      } else
        a = wo.next;
      var m;
      if (Co === null ? m = Ir.memoizedState : m = Co.next, m !== null)
        Co = m, m = Co.next, wo = a;
      else {
        if (a === null)
          throw new Error("Rendered more hooks than during the previous render.");
        wo = a;
        var g = {
          memoizedState: wo.memoizedState,
          baseState: wo.baseState,
          baseQueue: wo.baseQueue,
          queue: wo.queue,
          next: null
        };
        Co === null ? Ir.memoizedState = Co = g : Co = Co.next = g;
      }
      return Co;
    }
    function SB() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function $2(a, l) {
      return typeof l == "function" ? l(a) : l;
    }
    function H2(a, l, m) {
      var g = bu(), E;
      m !== void 0 ? E = m(l) : E = l, g.memoizedState = g.baseState = E;
      var _ = {
        pending: null,
        interleaved: null,
        lanes: nt,
        dispatch: null,
        lastRenderedReducer: a,
        lastRenderedState: E
      };
      g.queue = _;
      var B = _.dispatch = rre.bind(null, Ir, _);
      return [g.memoizedState, B];
    }
    function q2(a, l, m) {
      var g = Rl(), E = g.queue;
      if (E === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      E.lastRenderedReducer = a;
      var _ = wo, B = _.baseQueue, q = E.pending;
      if (q !== null) {
        if (B !== null) {
          var G = B.next, se = q.next;
          B.next = se, q.next = G;
        }
        _.baseQueue !== B && s("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), _.baseQueue = B = q, E.pending = null;
      }
      if (B !== null) {
        var ue = B.next, De = _.baseState, Re = null, ze = null, qe = null, Je = ue;
        do {
          var Et = Je.lane;
          if (hd(lm, Et)) {
            if (qe !== null) {
              var Jt = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Ii,
                action: Je.action,
                hasEagerState: Je.hasEagerState,
                eagerState: Je.eagerState,
                next: null
              };
              qe = qe.next = Jt;
            }
            if (Je.hasEagerState)
              De = Je.eagerState;
            else {
              var ir = Je.action;
              De = a(De, ir);
            }
          } else {
            var un = {
              lane: Et,
              action: Je.action,
              hasEagerState: Je.hasEagerState,
              eagerState: Je.eagerState,
              next: null
            };
            qe === null ? (ze = qe = un, Re = De) : qe = qe.next = un, Ir.lanes = Mn(Ir.lanes, Et), Gw(Et);
          }
          Je = Je.next;
        } while (Je !== null && Je !== ue);
        qe === null ? Re = De : qe.next = ze, jt(De, g.memoizedState) || Nw(), g.memoizedState = De, g.baseState = Re, g.baseQueue = qe, E.lastRenderedState = De;
      }
      var Jn = E.interleaved;
      if (Jn !== null) {
        var Le = Jn;
        do {
          var Ze = Le.lane;
          Ir.lanes = Mn(Ir.lanes, Ze), Gw(Ze), Le = Le.next;
        } while (Le !== Jn);
      } else B === null && (E.lanes = nt);
      var je = E.dispatch;
      return [g.memoizedState, je];
    }
    function W2(a, l, m) {
      var g = Rl(), E = g.queue;
      if (E === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      E.lastRenderedReducer = a;
      var _ = E.dispatch, B = E.pending, q = g.memoizedState;
      if (B !== null) {
        E.pending = null;
        var G = B.next, se = G;
        do {
          var ue = se.action;
          q = a(q, ue), se = se.next;
        } while (se !== G);
        jt(q, g.memoizedState) || Nw(), g.memoizedState = q, g.baseQueue === null && (g.baseState = q), E.lastRenderedState = q;
      }
      return [q, _];
    }
    function rje(a, l, m) {
    }
    function ije(a, l, m) {
    }
    function G2(a, l, m) {
      var g = Ir, E = bu(), _, B = Yo();
      if (B) {
        if (m === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        _ = m(), $v || _ !== m() && (s("The result of getServerSnapshot should be cached to avoid an infinite loop"), $v = !0);
      } else {
        if (_ = l(), !$v) {
          var q = l();
          jt(_, q) || (s("The result of getSnapshot should be cached to avoid an infinite loop"), $v = !0);
        }
        var G = rk();
        if (G === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        jp(G, lm) || kB(g, l, _);
      }
      E.memoizedState = _;
      var se = {
        value: _,
        getSnapshot: l
      };
      return E.queue = se, OS(TB.bind(null, g, se, a), [a]), g.flags |= Jr, Tw(go | Qo, AB.bind(null, g, se, _, l), void 0, null), _;
    }
    function AS(a, l, m) {
      var g = Ir, E = Rl(), _ = l();
      if (!$v) {
        var B = l();
        jt(_, B) || (s("The result of getSnapshot should be cached to avoid an infinite loop"), $v = !0);
      }
      var q = E.memoizedState, G = !jt(q, _);
      G && (E.memoizedState = _, Nw());
      var se = E.queue;
      if (Rw(TB.bind(null, g, se, a), [a]), se.getSnapshot !== l || G || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      Co !== null && Co.memoizedState.tag & go) {
        g.flags |= Jr, Tw(go | Qo, AB.bind(null, g, se, _, l), void 0, null);
        var ue = rk();
        if (ue === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        jp(ue, lm) || kB(g, l, _);
      }
      return _;
    }
    function kB(a, l, m) {
      a.flags |= _p;
      var g = {
        getSnapshot: l,
        value: m
      }, E = Ir.updateQueue;
      if (E === null)
        E = SB(), Ir.updateQueue = E, E.stores = [g];
      else {
        var _ = E.stores;
        _ === null ? E.stores = [g] : _.push(g);
      }
    }
    function AB(a, l, m, g) {
      l.value = m, l.getSnapshot = g, _B(l) && RB(a);
    }
    function TB(a, l, m) {
      var g = function() {
        _B(l) && RB(a);
      };
      return m(g);
    }
    function _B(a) {
      var l = a.getSnapshot, m = a.value;
      try {
        var g = l();
        return !jt(m, g);
      } catch {
        return !0;
      }
    }
    function RB(a) {
      var l = Rs(a, nn);
      l !== null && ko(l, a, nn, Vr);
    }
    function TS(a) {
      var l = bu();
      typeof a == "function" && (a = a()), l.memoizedState = l.baseState = a;
      var m = {
        pending: null,
        interleaved: null,
        lanes: nt,
        dispatch: null,
        lastRenderedReducer: $2,
        lastRenderedState: a
      };
      l.queue = m;
      var g = m.dispatch = ire.bind(null, Ir, m);
      return [l.memoizedState, g];
    }
    function K2(a) {
      return q2($2);
    }
    function Y2(a) {
      return W2($2);
    }
    function Tw(a, l, m, g) {
      var E = {
        tag: a,
        create: l,
        destroy: m,
        deps: g,
        // Circular
        next: null
      }, _ = Ir.updateQueue;
      if (_ === null)
        _ = SB(), Ir.updateQueue = _, _.lastEffect = E.next = E;
      else {
        var B = _.lastEffect;
        if (B === null)
          _.lastEffect = E.next = E;
        else {
          var q = B.next;
          B.next = E, E.next = q, _.lastEffect = E;
        }
      }
      return E;
    }
    function Q2(a) {
      var l = bu();
      {
        var m = {
          current: a
        };
        return l.memoizedState = m, m;
      }
    }
    function _S(a) {
      var l = Rl();
      return l.memoizedState;
    }
    function _w(a, l, m, g) {
      var E = bu(), _ = g === void 0 ? null : g;
      Ir.flags |= a, E.memoizedState = Tw(go | l, m, void 0, _);
    }
    function RS(a, l, m, g) {
      var E = Rl(), _ = g === void 0 ? null : g, B = void 0;
      if (wo !== null) {
        var q = wo.memoizedState;
        if (B = q.destroy, _ !== null) {
          var G = q.deps;
          if (V2(_, G)) {
            E.memoizedState = Tw(l, m, B, _);
            return;
          }
        }
      }
      Ir.flags |= a, E.memoizedState = Tw(go | l, m, B, _);
    }
    function OS(a, l) {
      return (Ir.mode & qa) !== Gt ? _w(id | Jr | au, Qo, a, l) : _w(Jr | au, Qo, a, l);
    }
    function Rw(a, l) {
      return RS(Jr, Qo, a, l);
    }
    function X2(a, l) {
      return _w(Bn, gu, a, l);
    }
    function IS(a, l) {
      return RS(Bn, gu, a, l);
    }
    function J2(a, l) {
      var m = Bn;
      return m |= fa, (Ir.mode & qa) !== Gt && (m |= ha), _w(m, bo, a, l);
    }
    function DS(a, l) {
      return RS(Bn, bo, a, l);
    }
    function OB(a, l) {
      if (typeof l == "function") {
        var m = l, g = a();
        return m(g), function() {
          m(null);
        };
      } else if (l != null) {
        var E = l;
        E.hasOwnProperty("current") || s("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(E).join(", ") + "}");
        var _ = a();
        return E.current = _, function() {
          E.current = null;
        };
      }
    }
    function Z2(a, l, m) {
      typeof l != "function" && s("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", l !== null ? typeof l : "null");
      var g = m != null ? m.concat([a]) : null, E = Bn;
      return E |= fa, (Ir.mode & qa) !== Gt && (E |= ha), _w(E, bo, OB.bind(null, l, a), g);
    }
    function MS(a, l, m) {
      typeof l != "function" && s("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", l !== null ? typeof l : "null");
      var g = m != null ? m.concat([a]) : null;
      return RS(Bn, bo, OB.bind(null, l, a), g);
    }
    function ere(a, l) {
    }
    var PS = ere;
    function e_(a, l) {
      var m = bu(), g = l === void 0 ? null : l;
      return m.memoizedState = [a, g], a;
    }
    function NS(a, l) {
      var m = Rl(), g = l === void 0 ? null : l, E = m.memoizedState;
      if (E !== null && g !== null) {
        var _ = E[1];
        if (V2(g, _))
          return E[0];
      }
      return m.memoizedState = [a, g], a;
    }
    function t_(a, l) {
      var m = bu(), g = l === void 0 ? null : l, E = a();
      return m.memoizedState = [E, g], E;
    }
    function BS(a, l) {
      var m = Rl(), g = l === void 0 ? null : l, E = m.memoizedState;
      if (E !== null && g !== null) {
        var _ = E[1];
        if (V2(g, _))
          return E[0];
      }
      var B = a();
      return m.memoizedState = [B, g], B;
    }
    function n_(a) {
      var l = bu();
      return l.memoizedState = a, a;
    }
    function IB(a) {
      var l = Rl(), m = wo, g = m.memoizedState;
      return MB(l, g, a);
    }
    function DB(a) {
      var l = Rl();
      if (wo === null)
        return l.memoizedState = a, a;
      var m = wo.memoizedState;
      return MB(l, m, a);
    }
    function MB(a, l, m) {
      var g = !fE(lm);
      if (g) {
        if (!jt(m, l)) {
          var E = mE();
          Ir.lanes = Mn(Ir.lanes, E), Gw(E), a.baseState = !0;
        }
        return l;
      } else
        return a.baseState && (a.baseState = !1, Nw()), a.memoizedState = m, m;
    }
    function tre(a, l, m) {
      var g = Es();
      hi(xT(g, gc)), a(!0);
      var E = Sw.transition;
      Sw.transition = {};
      var _ = Sw.transition;
      Sw.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        a(!1), l();
      } finally {
        if (hi(g), Sw.transition = E, E === null && _._updatedFibers) {
          var B = _._updatedFibers.size;
          B > 10 && o("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), _._updatedFibers.clear();
        }
      }
    }
    function r_() {
      var a = TS(!1), l = a[0], m = a[1], g = tre.bind(null, m), E = bu();
      return E.memoizedState = g, [l, g];
    }
    function PB() {
      var a = K2(), l = a[0], m = Rl(), g = m.memoizedState;
      return [l, g];
    }
    function NB() {
      var a = Y2(), l = a[0], m = Rl(), g = m.memoizedState;
      return [l, g];
    }
    var BB = !1;
    function nre() {
      return BB;
    }
    function i_() {
      var a = bu(), l = rk(), m = l.identifierPrefix, g;
      if (Yo()) {
        var E = bne();
        g = ":" + m + "R" + E;
        var _ = Aw++;
        _ > 0 && (g += "H" + _.toString(32)), g += ":";
      } else {
        var B = Xne++;
        g = ":" + m + "r" + B.toString(32) + ":";
      }
      return a.memoizedState = g, g;
    }
    function LS() {
      var a = Rl(), l = a.memoizedState;
      return l;
    }
    function rre(a, l, m) {
      typeof arguments[3] == "function" && s("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var g = ph(a), E = {
        lane: g,
        action: m,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (LB(a))
        jB(l, E);
      else {
        var _ = fB(a, l, E, g);
        if (_ !== null) {
          var B = Ya();
          ko(_, a, g, B), FB(_, l, g);
        }
      }
      UB(a, g);
    }
    function ire(a, l, m) {
      typeof arguments[3] == "function" && s("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var g = ph(a), E = {
        lane: g,
        action: m,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (LB(a))
        jB(l, E);
      else {
        var _ = a.alternate;
        if (a.lanes === nt && (_ === null || _.lanes === nt)) {
          var B = l.lastRenderedReducer;
          if (B !== null) {
            var q;
            q = Rt.current, Rt.current = Ac;
            try {
              var G = l.lastRenderedState, se = B(G, m);
              if (E.hasEagerState = !0, E.eagerState = se, jt(se, G)) {
                Vne(a, l, E, g);
                return;
              }
            } catch {
            } finally {
              Rt.current = q;
            }
          }
        }
        var ue = fB(a, l, E, g);
        if (ue !== null) {
          var De = Ya();
          ko(ue, a, g, De), FB(ue, l, g);
        }
      }
      UB(a, g);
    }
    function LB(a) {
      var l = a.alternate;
      return a === Ir || l !== null && l === Ir;
    }
    function jB(a, l) {
      kw = kS = !0;
      var m = a.pending;
      m === null ? l.next = l : (l.next = m.next, m.next = l), a.pending = l;
    }
    function FB(a, l, m) {
      if (N0(m)) {
        var g = l.lanes;
        g = nv(g, a.pendingLanes);
        var E = Mn(g, m);
        l.lanes = E, B0(a, E);
      }
    }
    function UB(a, l, m) {
      Dp(a, l);
    }
    var jS = {
      readContext: oo,
      useCallback: Ea,
      useContext: Ea,
      useEffect: Ea,
      useImperativeHandle: Ea,
      useInsertionEffect: Ea,
      useLayoutEffect: Ea,
      useMemo: Ea,
      useReducer: Ea,
      useRef: Ea,
      useState: Ea,
      useDebugValue: Ea,
      useDeferredValue: Ea,
      useTransition: Ea,
      useMutableSource: Ea,
      useSyncExternalStore: Ea,
      useId: Ea,
      unstable_isNewReconciler: K
    }, zB = null, VB = null, $B = null, HB = null, wu = null, Ac = null, FS = null;
    {
      var o_ = function() {
        s("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, On = function() {
        s("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      zB = {
        readContext: function(a) {
          return oo(a);
        },
        useCallback: function(a, l) {
          return et = "useCallback", Ar(), Hv(l), e_(a, l);
        },
        useContext: function(a) {
          return et = "useContext", Ar(), oo(a);
        },
        useEffect: function(a, l) {
          return et = "useEffect", Ar(), Hv(l), OS(a, l);
        },
        useImperativeHandle: function(a, l, m) {
          return et = "useImperativeHandle", Ar(), Hv(m), Z2(a, l, m);
        },
        useInsertionEffect: function(a, l) {
          return et = "useInsertionEffect", Ar(), Hv(l), X2(a, l);
        },
        useLayoutEffect: function(a, l) {
          return et = "useLayoutEffect", Ar(), Hv(l), J2(a, l);
        },
        useMemo: function(a, l) {
          et = "useMemo", Ar(), Hv(l);
          var m = Rt.current;
          Rt.current = wu;
          try {
            return t_(a, l);
          } finally {
            Rt.current = m;
          }
        },
        useReducer: function(a, l, m) {
          et = "useReducer", Ar();
          var g = Rt.current;
          Rt.current = wu;
          try {
            return H2(a, l, m);
          } finally {
            Rt.current = g;
          }
        },
        useRef: function(a) {
          return et = "useRef", Ar(), Q2(a);
        },
        useState: function(a) {
          et = "useState", Ar();
          var l = Rt.current;
          Rt.current = wu;
          try {
            return TS(a);
          } finally {
            Rt.current = l;
          }
        },
        useDebugValue: function(a, l) {
          return et = "useDebugValue", Ar(), void 0;
        },
        useDeferredValue: function(a) {
          return et = "useDeferredValue", Ar(), n_(a);
        },
        useTransition: function() {
          return et = "useTransition", Ar(), r_();
        },
        useMutableSource: function(a, l, m) {
          return et = "useMutableSource", Ar(), void 0;
        },
        useSyncExternalStore: function(a, l, m) {
          return et = "useSyncExternalStore", Ar(), G2(a, l, m);
        },
        useId: function() {
          return et = "useId", Ar(), i_();
        },
        unstable_isNewReconciler: K
      }, VB = {
        readContext: function(a) {
          return oo(a);
        },
        useCallback: function(a, l) {
          return et = "useCallback", wt(), e_(a, l);
        },
        useContext: function(a) {
          return et = "useContext", wt(), oo(a);
        },
        useEffect: function(a, l) {
          return et = "useEffect", wt(), OS(a, l);
        },
        useImperativeHandle: function(a, l, m) {
          return et = "useImperativeHandle", wt(), Z2(a, l, m);
        },
        useInsertionEffect: function(a, l) {
          return et = "useInsertionEffect", wt(), X2(a, l);
        },
        useLayoutEffect: function(a, l) {
          return et = "useLayoutEffect", wt(), J2(a, l);
        },
        useMemo: function(a, l) {
          et = "useMemo", wt();
          var m = Rt.current;
          Rt.current = wu;
          try {
            return t_(a, l);
          } finally {
            Rt.current = m;
          }
        },
        useReducer: function(a, l, m) {
          et = "useReducer", wt();
          var g = Rt.current;
          Rt.current = wu;
          try {
            return H2(a, l, m);
          } finally {
            Rt.current = g;
          }
        },
        useRef: function(a) {
          return et = "useRef", wt(), Q2(a);
        },
        useState: function(a) {
          et = "useState", wt();
          var l = Rt.current;
          Rt.current = wu;
          try {
            return TS(a);
          } finally {
            Rt.current = l;
          }
        },
        useDebugValue: function(a, l) {
          return et = "useDebugValue", wt(), void 0;
        },
        useDeferredValue: function(a) {
          return et = "useDeferredValue", wt(), n_(a);
        },
        useTransition: function() {
          return et = "useTransition", wt(), r_();
        },
        useMutableSource: function(a, l, m) {
          return et = "useMutableSource", wt(), void 0;
        },
        useSyncExternalStore: function(a, l, m) {
          return et = "useSyncExternalStore", wt(), G2(a, l, m);
        },
        useId: function() {
          return et = "useId", wt(), i_();
        },
        unstable_isNewReconciler: K
      }, $B = {
        readContext: function(a) {
          return oo(a);
        },
        useCallback: function(a, l) {
          return et = "useCallback", wt(), NS(a, l);
        },
        useContext: function(a) {
          return et = "useContext", wt(), oo(a);
        },
        useEffect: function(a, l) {
          return et = "useEffect", wt(), Rw(a, l);
        },
        useImperativeHandle: function(a, l, m) {
          return et = "useImperativeHandle", wt(), MS(a, l, m);
        },
        useInsertionEffect: function(a, l) {
          return et = "useInsertionEffect", wt(), IS(a, l);
        },
        useLayoutEffect: function(a, l) {
          return et = "useLayoutEffect", wt(), DS(a, l);
        },
        useMemo: function(a, l) {
          et = "useMemo", wt();
          var m = Rt.current;
          Rt.current = Ac;
          try {
            return BS(a, l);
          } finally {
            Rt.current = m;
          }
        },
        useReducer: function(a, l, m) {
          et = "useReducer", wt();
          var g = Rt.current;
          Rt.current = Ac;
          try {
            return q2(a, l, m);
          } finally {
            Rt.current = g;
          }
        },
        useRef: function(a) {
          return et = "useRef", wt(), _S();
        },
        useState: function(a) {
          et = "useState", wt();
          var l = Rt.current;
          Rt.current = Ac;
          try {
            return K2(a);
          } finally {
            Rt.current = l;
          }
        },
        useDebugValue: function(a, l) {
          return et = "useDebugValue", wt(), PS();
        },
        useDeferredValue: function(a) {
          return et = "useDeferredValue", wt(), IB(a);
        },
        useTransition: function() {
          return et = "useTransition", wt(), PB();
        },
        useMutableSource: function(a, l, m) {
          return et = "useMutableSource", wt(), void 0;
        },
        useSyncExternalStore: function(a, l, m) {
          return et = "useSyncExternalStore", wt(), AS(a, l);
        },
        useId: function() {
          return et = "useId", wt(), LS();
        },
        unstable_isNewReconciler: K
      }, HB = {
        readContext: function(a) {
          return oo(a);
        },
        useCallback: function(a, l) {
          return et = "useCallback", wt(), NS(a, l);
        },
        useContext: function(a) {
          return et = "useContext", wt(), oo(a);
        },
        useEffect: function(a, l) {
          return et = "useEffect", wt(), Rw(a, l);
        },
        useImperativeHandle: function(a, l, m) {
          return et = "useImperativeHandle", wt(), MS(a, l, m);
        },
        useInsertionEffect: function(a, l) {
          return et = "useInsertionEffect", wt(), IS(a, l);
        },
        useLayoutEffect: function(a, l) {
          return et = "useLayoutEffect", wt(), DS(a, l);
        },
        useMemo: function(a, l) {
          et = "useMemo", wt();
          var m = Rt.current;
          Rt.current = FS;
          try {
            return BS(a, l);
          } finally {
            Rt.current = m;
          }
        },
        useReducer: function(a, l, m) {
          et = "useReducer", wt();
          var g = Rt.current;
          Rt.current = FS;
          try {
            return W2(a, l, m);
          } finally {
            Rt.current = g;
          }
        },
        useRef: function(a) {
          return et = "useRef", wt(), _S();
        },
        useState: function(a) {
          et = "useState", wt();
          var l = Rt.current;
          Rt.current = FS;
          try {
            return Y2(a);
          } finally {
            Rt.current = l;
          }
        },
        useDebugValue: function(a, l) {
          return et = "useDebugValue", wt(), PS();
        },
        useDeferredValue: function(a) {
          return et = "useDeferredValue", wt(), DB(a);
        },
        useTransition: function() {
          return et = "useTransition", wt(), NB();
        },
        useMutableSource: function(a, l, m) {
          return et = "useMutableSource", wt(), void 0;
        },
        useSyncExternalStore: function(a, l, m) {
          return et = "useSyncExternalStore", wt(), AS(a, l);
        },
        useId: function() {
          return et = "useId", wt(), LS();
        },
        unstable_isNewReconciler: K
      }, wu = {
        readContext: function(a) {
          return o_(), oo(a);
        },
        useCallback: function(a, l) {
          return et = "useCallback", On(), Ar(), e_(a, l);
        },
        useContext: function(a) {
          return et = "useContext", On(), Ar(), oo(a);
        },
        useEffect: function(a, l) {
          return et = "useEffect", On(), Ar(), OS(a, l);
        },
        useImperativeHandle: function(a, l, m) {
          return et = "useImperativeHandle", On(), Ar(), Z2(a, l, m);
        },
        useInsertionEffect: function(a, l) {
          return et = "useInsertionEffect", On(), Ar(), X2(a, l);
        },
        useLayoutEffect: function(a, l) {
          return et = "useLayoutEffect", On(), Ar(), J2(a, l);
        },
        useMemo: function(a, l) {
          et = "useMemo", On(), Ar();
          var m = Rt.current;
          Rt.current = wu;
          try {
            return t_(a, l);
          } finally {
            Rt.current = m;
          }
        },
        useReducer: function(a, l, m) {
          et = "useReducer", On(), Ar();
          var g = Rt.current;
          Rt.current = wu;
          try {
            return H2(a, l, m);
          } finally {
            Rt.current = g;
          }
        },
        useRef: function(a) {
          return et = "useRef", On(), Ar(), Q2(a);
        },
        useState: function(a) {
          et = "useState", On(), Ar();
          var l = Rt.current;
          Rt.current = wu;
          try {
            return TS(a);
          } finally {
            Rt.current = l;
          }
        },
        useDebugValue: function(a, l) {
          return et = "useDebugValue", On(), Ar(), void 0;
        },
        useDeferredValue: function(a) {
          return et = "useDeferredValue", On(), Ar(), n_(a);
        },
        useTransition: function() {
          return et = "useTransition", On(), Ar(), r_();
        },
        useMutableSource: function(a, l, m) {
          return et = "useMutableSource", On(), Ar(), void 0;
        },
        useSyncExternalStore: function(a, l, m) {
          return et = "useSyncExternalStore", On(), Ar(), G2(a, l, m);
        },
        useId: function() {
          return et = "useId", On(), Ar(), i_();
        },
        unstable_isNewReconciler: K
      }, Ac = {
        readContext: function(a) {
          return o_(), oo(a);
        },
        useCallback: function(a, l) {
          return et = "useCallback", On(), wt(), NS(a, l);
        },
        useContext: function(a) {
          return et = "useContext", On(), wt(), oo(a);
        },
        useEffect: function(a, l) {
          return et = "useEffect", On(), wt(), Rw(a, l);
        },
        useImperativeHandle: function(a, l, m) {
          return et = "useImperativeHandle", On(), wt(), MS(a, l, m);
        },
        useInsertionEffect: function(a, l) {
          return et = "useInsertionEffect", On(), wt(), IS(a, l);
        },
        useLayoutEffect: function(a, l) {
          return et = "useLayoutEffect", On(), wt(), DS(a, l);
        },
        useMemo: function(a, l) {
          et = "useMemo", On(), wt();
          var m = Rt.current;
          Rt.current = Ac;
          try {
            return BS(a, l);
          } finally {
            Rt.current = m;
          }
        },
        useReducer: function(a, l, m) {
          et = "useReducer", On(), wt();
          var g = Rt.current;
          Rt.current = Ac;
          try {
            return q2(a, l, m);
          } finally {
            Rt.current = g;
          }
        },
        useRef: function(a) {
          return et = "useRef", On(), wt(), _S();
        },
        useState: function(a) {
          et = "useState", On(), wt();
          var l = Rt.current;
          Rt.current = Ac;
          try {
            return K2(a);
          } finally {
            Rt.current = l;
          }
        },
        useDebugValue: function(a, l) {
          return et = "useDebugValue", On(), wt(), PS();
        },
        useDeferredValue: function(a) {
          return et = "useDeferredValue", On(), wt(), IB(a);
        },
        useTransition: function() {
          return et = "useTransition", On(), wt(), PB();
        },
        useMutableSource: function(a, l, m) {
          return et = "useMutableSource", On(), wt(), void 0;
        },
        useSyncExternalStore: function(a, l, m) {
          return et = "useSyncExternalStore", On(), wt(), AS(a, l);
        },
        useId: function() {
          return et = "useId", On(), wt(), LS();
        },
        unstable_isNewReconciler: K
      }, FS = {
        readContext: function(a) {
          return o_(), oo(a);
        },
        useCallback: function(a, l) {
          return et = "useCallback", On(), wt(), NS(a, l);
        },
        useContext: function(a) {
          return et = "useContext", On(), wt(), oo(a);
        },
        useEffect: function(a, l) {
          return et = "useEffect", On(), wt(), Rw(a, l);
        },
        useImperativeHandle: function(a, l, m) {
          return et = "useImperativeHandle", On(), wt(), MS(a, l, m);
        },
        useInsertionEffect: function(a, l) {
          return et = "useInsertionEffect", On(), wt(), IS(a, l);
        },
        useLayoutEffect: function(a, l) {
          return et = "useLayoutEffect", On(), wt(), DS(a, l);
        },
        useMemo: function(a, l) {
          et = "useMemo", On(), wt();
          var m = Rt.current;
          Rt.current = Ac;
          try {
            return BS(a, l);
          } finally {
            Rt.current = m;
          }
        },
        useReducer: function(a, l, m) {
          et = "useReducer", On(), wt();
          var g = Rt.current;
          Rt.current = Ac;
          try {
            return W2(a, l, m);
          } finally {
            Rt.current = g;
          }
        },
        useRef: function(a) {
          return et = "useRef", On(), wt(), _S();
        },
        useState: function(a) {
          et = "useState", On(), wt();
          var l = Rt.current;
          Rt.current = Ac;
          try {
            return Y2(a);
          } finally {
            Rt.current = l;
          }
        },
        useDebugValue: function(a, l) {
          return et = "useDebugValue", On(), wt(), PS();
        },
        useDeferredValue: function(a) {
          return et = "useDeferredValue", On(), wt(), DB(a);
        },
        useTransition: function() {
          return et = "useTransition", On(), wt(), NB();
        },
        useMutableSource: function(a, l, m) {
          return et = "useMutableSource", On(), wt(), void 0;
        },
        useSyncExternalStore: function(a, l, m) {
          return et = "useSyncExternalStore", On(), wt(), AS(a, l);
        },
        useId: function() {
          return et = "useId", On(), wt(), LS();
        },
        unstable_isNewReconciler: K
      };
    }
    var uh = t.unstable_now, qB = 0, US = -1, Ow = -1, zS = -1, a_ = !1, VS = !1;
    function WB() {
      return a_;
    }
    function ore() {
      VS = !0;
    }
    function are() {
      a_ = !1, VS = !1;
    }
    function sre() {
      a_ = VS, VS = !1;
    }
    function GB() {
      return qB;
    }
    function KB() {
      qB = uh();
    }
    function s_(a) {
      Ow = uh(), a.actualStartTime < 0 && (a.actualStartTime = uh());
    }
    function YB(a) {
      Ow = -1;
    }
    function $S(a, l) {
      if (Ow >= 0) {
        var m = uh() - Ow;
        a.actualDuration += m, l && (a.selfBaseDuration = m), Ow = -1;
      }
    }
    function Cu(a) {
      if (US >= 0) {
        var l = uh() - US;
        US = -1;
        for (var m = a.return; m !== null; ) {
          switch (m.tag) {
            case y:
              var g = m.stateNode;
              g.effectDuration += l;
              return;
            case M:
              var E = m.stateNode;
              E.effectDuration += l;
              return;
          }
          m = m.return;
        }
      }
    }
    function l_(a) {
      if (zS >= 0) {
        var l = uh() - zS;
        zS = -1;
        for (var m = a.return; m !== null; ) {
          switch (m.tag) {
            case y:
              var g = m.stateNode;
              g !== null && (g.passiveEffectDuration += l);
              return;
            case M:
              var E = m.stateNode;
              E !== null && (E.passiveEffectDuration += l);
              return;
          }
          m = m.return;
        }
      }
    }
    function xu() {
      US = uh();
    }
    function c_() {
      zS = uh();
    }
    function u_(a) {
      for (var l = a.child; l; )
        a.actualDuration += l.actualDuration, l = l.sibling;
    }
    function Tc(a, l) {
      if (a && a.defaultProps) {
        var m = vn({}, l), g = a.defaultProps;
        for (var E in g)
          m[E] === void 0 && (m[E] = g[E]);
        return m;
      }
      return l;
    }
    var d_ = {}, f_, h_, p_, m_, y_, QB, HS, v_, g_, b_, Iw;
    {
      f_ = /* @__PURE__ */ new Set(), h_ = /* @__PURE__ */ new Set(), p_ = /* @__PURE__ */ new Set(), m_ = /* @__PURE__ */ new Set(), v_ = /* @__PURE__ */ new Set(), y_ = /* @__PURE__ */ new Set(), g_ = /* @__PURE__ */ new Set(), b_ = /* @__PURE__ */ new Set(), Iw = /* @__PURE__ */ new Set();
      var XB = /* @__PURE__ */ new Set();
      HS = function(a, l) {
        if (!(a === null || typeof a == "function")) {
          var m = l + "_" + a;
          XB.has(m) || (XB.add(m), s("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", l, a));
        }
      }, QB = function(a, l) {
        if (l === void 0) {
          var m = Hn(a) || "Component";
          y_.has(m) || (y_.add(m), s("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", m));
        }
      }, Object.defineProperty(d_, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(d_);
    }
    function w_(a, l, m, g) {
      var E = a.memoizedState, _ = m(g, E);
      {
        if (a.mode & Kn) {
          Oi(!0);
          try {
            _ = m(g, E);
          } finally {
            Oi(!1);
          }
        }
        QB(l, _);
      }
      var B = _ == null ? E : vn({}, E, _);
      if (a.memoizedState = B, a.lanes === nt) {
        var q = a.updateQueue;
        q.baseState = B;
      }
    }
    var C_ = {
      isMounted: $a,
      enqueueSetState: function(a, l, m) {
        var g = ms(a), E = Ya(), _ = ph(g), B = Ad(E, _);
        B.payload = l, m != null && (HS(m, "setState"), B.callback = m);
        var q = ah(g, B, _);
        q !== null && (ko(q, g, _, E), bS(q, g, _)), Dp(g, _);
      },
      enqueueReplaceState: function(a, l, m) {
        var g = ms(a), E = Ya(), _ = ph(g), B = Ad(E, _);
        B.tag = pB, B.payload = l, m != null && (HS(m, "replaceState"), B.callback = m);
        var q = ah(g, B, _);
        q !== null && (ko(q, g, _, E), bS(q, g, _)), Dp(g, _);
      },
      enqueueForceUpdate: function(a, l) {
        var m = ms(a), g = Ya(), E = ph(m), _ = Ad(g, E);
        _.tag = yS, l != null && (HS(l, "forceUpdate"), _.callback = l);
        var B = ah(m, _, E);
        B !== null && (ko(B, m, E, g), bS(B, m, E)), Fy(m, E);
      }
    };
    function JB(a, l, m, g, E, _, B) {
      var q = a.stateNode;
      if (typeof q.shouldComponentUpdate == "function") {
        var G = q.shouldComponentUpdate(g, _, B);
        {
          if (a.mode & Kn) {
            Oi(!0);
            try {
              G = q.shouldComponentUpdate(g, _, B);
            } finally {
              Oi(!1);
            }
          }
          G === void 0 && s("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", Hn(l) || "Component");
        }
        return G;
      }
      return l.prototype && l.prototype.isPureReactComponent ? !gn(m, g) || !gn(E, _) : !0;
    }
    function lre(a, l, m) {
      var g = a.stateNode;
      {
        var E = Hn(l) || "Component", _ = g.render;
        _ || (l.prototype && typeof l.prototype.render == "function" ? s("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", E) : s("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", E)), g.getInitialState && !g.getInitialState.isReactClassApproved && !g.state && s("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", E), g.getDefaultProps && !g.getDefaultProps.isReactClassApproved && s("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", E), g.propTypes && s("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", E), g.contextType && s("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", E), l.childContextTypes && !Iw.has(l) && // Strict Mode has its own warning for legacy context, so we can skip
        // this one.
        (a.mode & Kn) === Gt && (Iw.add(l), s(`%s uses the legacy childContextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() instead

.Learn more about this warning here: https://reactjs.org/link/legacy-context`, E)), l.contextTypes && !Iw.has(l) && // Strict Mode has its own warning for legacy context, so we can skip
        // this one.
        (a.mode & Kn) === Gt && (Iw.add(l), s(`%s uses the legacy contextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() with static contextType instead.

Learn more about this warning here: https://reactjs.org/link/legacy-context`, E)), g.contextTypes && s("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", E), l.contextType && l.contextTypes && !g_.has(l) && (g_.add(l), s("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", E)), typeof g.componentShouldUpdate == "function" && s("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", E), l.prototype && l.prototype.isPureReactComponent && typeof g.shouldComponentUpdate < "u" && s("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", Hn(l) || "A pure component"), typeof g.componentDidUnmount == "function" && s("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", E), typeof g.componentDidReceiveProps == "function" && s("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", E), typeof g.componentWillRecieveProps == "function" && s("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", E), typeof g.UNSAFE_componentWillRecieveProps == "function" && s("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", E);
        var B = g.props !== m;
        g.props !== void 0 && B && s("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", E, E), g.defaultProps && s("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", E, E), typeof g.getSnapshotBeforeUpdate == "function" && typeof g.componentDidUpdate != "function" && !p_.has(l) && (p_.add(l), s("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", Hn(l))), typeof g.getDerivedStateFromProps == "function" && s("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", E), typeof g.getDerivedStateFromError == "function" && s("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", E), typeof l.getSnapshotBeforeUpdate == "function" && s("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", E);
        var q = g.state;
        q && (typeof q != "object" || Zn(q)) && s("%s.state: must be set to an object or null", E), typeof g.getChildContext == "function" && typeof l.childContextTypes != "object" && s("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", E);
      }
    }
    function ZB(a, l) {
      l.updater = C_, a.stateNode = l, Ef(l, a), l._reactInternalInstance = d_;
    }
    function e6(a, l, m) {
      var g = !1, E = rl, _ = rl, B = l.contextType;
      if ("contextType" in l) {
        var q = (
          // Allow null for conditional declaration
          B === null || B !== void 0 && B.$$typeof === _e && B._context === void 0
        );
        if (!q && !b_.has(l)) {
          b_.add(l);
          var G = "";
          B === void 0 ? G = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof B != "object" ? G = " However, it is set to a " + typeof B + "." : B.$$typeof === re ? G = " Did you accidentally pass the Context.Provider instead?" : B._context !== void 0 ? G = " Did you accidentally pass the Context.Consumer instead?" : G = " However, it is set to an object with keys {" + Object.keys(B).join(", ") + "}.", s("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", Hn(l) || "Component", G);
        }
      }
      if (typeof B == "object" && B !== null)
        _ = oo(B);
      else {
        E = Dv(a, l, !0);
        var se = l.contextTypes;
        g = se != null, _ = g ? Mv(a, E) : rl;
      }
      var ue = new l(m, _);
      if (a.mode & Kn) {
        Oi(!0);
        try {
          ue = new l(m, _);
        } finally {
          Oi(!1);
        }
      }
      var De = a.memoizedState = ue.state !== null && ue.state !== void 0 ? ue.state : null;
      ZB(a, ue);
      {
        if (typeof l.getDerivedStateFromProps == "function" && De === null) {
          var Re = Hn(l) || "Component";
          h_.has(Re) || (h_.add(Re), s("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", Re, ue.state === null ? "null" : "undefined", Re));
        }
        if (typeof l.getDerivedStateFromProps == "function" || typeof ue.getSnapshotBeforeUpdate == "function") {
          var ze = null, qe = null, Je = null;
          if (typeof ue.componentWillMount == "function" && ue.componentWillMount.__suppressDeprecationWarning !== !0 ? ze = "componentWillMount" : typeof ue.UNSAFE_componentWillMount == "function" && (ze = "UNSAFE_componentWillMount"), typeof ue.componentWillReceiveProps == "function" && ue.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? qe = "componentWillReceiveProps" : typeof ue.UNSAFE_componentWillReceiveProps == "function" && (qe = "UNSAFE_componentWillReceiveProps"), typeof ue.componentWillUpdate == "function" && ue.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Je = "componentWillUpdate" : typeof ue.UNSAFE_componentWillUpdate == "function" && (Je = "UNSAFE_componentWillUpdate"), ze !== null || qe !== null || Je !== null) {
            var Et = Hn(l) || "Component", un = typeof l.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            m_.has(Et) || (m_.add(Et), s(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, Et, un, ze !== null ? `
  ` + ze : "", qe !== null ? `
  ` + qe : "", Je !== null ? `
  ` + Je : ""));
          }
        }
      }
      return g && $3(a, E, _), ue;
    }
    function cre(a, l) {
      var m = l.state;
      typeof l.componentWillMount == "function" && l.componentWillMount(), typeof l.UNSAFE_componentWillMount == "function" && l.UNSAFE_componentWillMount(), m !== l.state && (s("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", En(a) || "Component"), C_.enqueueReplaceState(l, l.state, null));
    }
    function t6(a, l, m, g) {
      var E = l.state;
      if (typeof l.componentWillReceiveProps == "function" && l.componentWillReceiveProps(m, g), typeof l.UNSAFE_componentWillReceiveProps == "function" && l.UNSAFE_componentWillReceiveProps(m, g), l.state !== E) {
        {
          var _ = En(a) || "Component";
          f_.has(_) || (f_.add(_), s("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", _));
        }
        C_.enqueueReplaceState(l, l.state, null);
      }
    }
    function x_(a, l, m, g) {
      lre(a, l, m);
      var E = a.stateNode;
      E.props = m, E.state = a.memoizedState, E.refs = {}, I2(a);
      var _ = l.contextType;
      if (typeof _ == "object" && _ !== null)
        E.context = oo(_);
      else {
        var B = Dv(a, l, !0);
        E.context = Mv(a, B);
      }
      {
        if (E.state === m) {
          var q = Hn(l) || "Component";
          v_.has(q) || (v_.add(q), s("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", q));
        }
        a.mode & Kn && Sc.recordLegacyContextWarning(a, E), Sc.recordUnsafeLifecycleWarnings(a, E);
      }
      E.state = a.memoizedState;
      var G = l.getDerivedStateFromProps;
      if (typeof G == "function" && (w_(a, l, G, m), E.state = a.memoizedState), typeof l.getDerivedStateFromProps != "function" && typeof E.getSnapshotBeforeUpdate != "function" && (typeof E.UNSAFE_componentWillMount == "function" || typeof E.componentWillMount == "function") && (cre(a, E), wS(a, m, E, g), E.state = a.memoizedState), typeof E.componentDidMount == "function") {
        var se = Bn;
        se |= fa, (a.mode & qa) !== Gt && (se |= ha), a.flags |= se;
      }
    }
    function ure(a, l, m, g) {
      var E = a.stateNode, _ = a.memoizedProps;
      E.props = _;
      var B = E.context, q = l.contextType, G = rl;
      if (typeof q == "object" && q !== null)
        G = oo(q);
      else {
        var se = Dv(a, l, !0);
        G = Mv(a, se);
      }
      var ue = l.getDerivedStateFromProps, De = typeof ue == "function" || typeof E.getSnapshotBeforeUpdate == "function";
      !De && (typeof E.UNSAFE_componentWillReceiveProps == "function" || typeof E.componentWillReceiveProps == "function") && (_ !== m || B !== G) && t6(a, E, m, G), yB();
      var Re = a.memoizedState, ze = E.state = Re;
      if (wS(a, m, E, g), ze = a.memoizedState, _ === m && Re === ze && !tS() && !CS()) {
        if (typeof E.componentDidMount == "function") {
          var qe = Bn;
          qe |= fa, (a.mode & qa) !== Gt && (qe |= ha), a.flags |= qe;
        }
        return !1;
      }
      typeof ue == "function" && (w_(a, l, ue, m), ze = a.memoizedState);
      var Je = CS() || JB(a, l, _, m, Re, ze, G);
      if (Je) {
        if (!De && (typeof E.UNSAFE_componentWillMount == "function" || typeof E.componentWillMount == "function") && (typeof E.componentWillMount == "function" && E.componentWillMount(), typeof E.UNSAFE_componentWillMount == "function" && E.UNSAFE_componentWillMount()), typeof E.componentDidMount == "function") {
          var Et = Bn;
          Et |= fa, (a.mode & qa) !== Gt && (Et |= ha), a.flags |= Et;
        }
      } else {
        if (typeof E.componentDidMount == "function") {
          var un = Bn;
          un |= fa, (a.mode & qa) !== Gt && (un |= ha), a.flags |= un;
        }
        a.memoizedProps = m, a.memoizedState = ze;
      }
      return E.props = m, E.state = ze, E.context = G, Je;
    }
    function dre(a, l, m, g, E) {
      var _ = l.stateNode;
      mB(a, l);
      var B = l.memoizedProps, q = l.type === l.elementType ? B : Tc(l.type, B);
      _.props = q;
      var G = l.pendingProps, se = _.context, ue = m.contextType, De = rl;
      if (typeof ue == "object" && ue !== null)
        De = oo(ue);
      else {
        var Re = Dv(l, m, !0);
        De = Mv(l, Re);
      }
      var ze = m.getDerivedStateFromProps, qe = typeof ze == "function" || typeof _.getSnapshotBeforeUpdate == "function";
      !qe && (typeof _.UNSAFE_componentWillReceiveProps == "function" || typeof _.componentWillReceiveProps == "function") && (B !== G || se !== De) && t6(l, _, g, De), yB();
      var Je = l.memoizedState, Et = _.state = Je;
      if (wS(l, g, _, E), Et = l.memoizedState, B === G && Je === Et && !tS() && !CS() && !oe)
        return typeof _.componentDidUpdate == "function" && (B !== a.memoizedProps || Je !== a.memoizedState) && (l.flags |= Bn), typeof _.getSnapshotBeforeUpdate == "function" && (B !== a.memoizedProps || Je !== a.memoizedState) && (l.flags |= ys), !1;
      typeof ze == "function" && (w_(l, m, ze, g), Et = l.memoizedState);
      var un = CS() || JB(l, m, q, g, Je, Et, De) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      oe;
      return un ? (!qe && (typeof _.UNSAFE_componentWillUpdate == "function" || typeof _.componentWillUpdate == "function") && (typeof _.componentWillUpdate == "function" && _.componentWillUpdate(g, Et, De), typeof _.UNSAFE_componentWillUpdate == "function" && _.UNSAFE_componentWillUpdate(g, Et, De)), typeof _.componentDidUpdate == "function" && (l.flags |= Bn), typeof _.getSnapshotBeforeUpdate == "function" && (l.flags |= ys)) : (typeof _.componentDidUpdate == "function" && (B !== a.memoizedProps || Je !== a.memoizedState) && (l.flags |= Bn), typeof _.getSnapshotBeforeUpdate == "function" && (B !== a.memoizedProps || Je !== a.memoizedState) && (l.flags |= ys), l.memoizedProps = g, l.memoizedState = Et), _.props = g, _.state = Et, _.context = De, un;
    }
    function cm(a, l) {
      return {
        value: a,
        source: l,
        stack: Xc(l),
        digest: null
      };
    }
    function E_(a, l, m) {
      return {
        value: a,
        source: null,
        stack: m ?? null,
        digest: l ?? null
      };
    }
    function fre(a, l) {
      return !0;
    }
    function S_(a, l) {
      try {
        var m = fre(a, l);
        if (m === !1)
          return;
        var g = l.value, E = l.source, _ = l.stack, B = _ !== null ? _ : "";
        if (g != null && g._suppressLogging && a.tag === f)
          return;
        var q = E ? En(E) : null, G = q ? "The above error occurred in the <" + q + "> component:" : "The above error occurred in one of your React components:", se;
        if (a.tag === y)
          se = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var ue = En(a) || "Anonymous";
          se = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + ue + ".");
        }
        var De = G + `
` + B + `

` + ("" + se);
      } catch (Re) {
        setTimeout(function() {
          throw Re;
        });
      }
    }
    var hre = typeof WeakMap == "function" ? WeakMap : Map;
    function n6(a, l, m) {
      var g = Ad(Vr, m);
      g.tag = R2, g.payload = {
        element: null
      };
      var E = l.value;
      return g.callback = function() {
        ooe(E), S_(a, l);
      }, g;
    }
    function k_(a, l, m) {
      var g = Ad(Vr, m);
      g.tag = R2;
      var E = a.type.getDerivedStateFromError;
      if (typeof E == "function") {
        var _ = l.value;
        g.payload = function() {
          return E(_);
        }, g.callback = function() {
          hL(a), S_(a, l);
        };
      }
      var B = a.stateNode;
      return B !== null && typeof B.componentDidCatch == "function" && (g.callback = function() {
        hL(a), S_(a, l), typeof E != "function" && roe(this);
        var G = l.value, se = l.stack;
        this.componentDidCatch(G, {
          componentStack: se !== null ? se : ""
        }), typeof E != "function" && (ba(a.lanes, nn) || s("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", En(a) || "Unknown"));
      }), g;
    }
    function r6(a, l, m) {
      var g = a.pingCache, E;
      if (g === null ? (g = a.pingCache = new hre(), E = /* @__PURE__ */ new Set(), g.set(l, E)) : (E = g.get(l), E === void 0 && (E = /* @__PURE__ */ new Set(), g.set(l, E))), !E.has(m)) {
        E.add(m);
        var _ = aoe.bind(null, a, l, m);
        Ha && Kw(a, m), l.then(_, _);
      }
    }
    function pre(a, l, m, g) {
      var E = a.updateQueue;
      if (E === null) {
        var _ = /* @__PURE__ */ new Set();
        _.add(m), a.updateQueue = _;
      } else
        E.add(m);
    }
    function mre(a, l) {
      var m = a.tag;
      if ((a.mode & Xt) === Gt && (m === u || m === D || m === F)) {
        var g = a.alternate;
        g ? (a.updateQueue = g.updateQueue, a.memoizedState = g.memoizedState, a.lanes = g.lanes) : (a.updateQueue = null, a.memoizedState = null);
      }
    }
    function i6(a) {
      var l = a;
      do {
        if (l.tag === L && Yne(l))
          return l;
        l = l.return;
      } while (l !== null);
      return null;
    }
    function o6(a, l, m, g, E) {
      if ((a.mode & Xt) === Gt) {
        if (a === l)
          a.flags |= to;
        else {
          if (a.flags |= Sn, m.flags |= Rp, m.flags &= ~(Ty | za), m.tag === f) {
            var _ = m.alternate;
            if (_ === null)
              m.tag = z;
            else {
              var B = Ad(Vr, nn);
              B.tag = yS, ah(m, B, nn);
            }
          }
          m.lanes = Mn(m.lanes, nn);
        }
        return a;
      }
      return a.flags |= to, a.lanes = E, a;
    }
    function yre(a, l, m, g, E) {
      if (m.flags |= za, Ha && Kw(a, E), g !== null && typeof g == "object" && typeof g.then == "function") {
        var _ = g;
        mre(m), Yo() && m.mode & Xt && Q3();
        var B = i6(l);
        if (B !== null) {
          B.flags &= ~fi, o6(B, l, m, a, E), B.mode & Xt && r6(a, _, E), pre(B, a, _);
          return;
        } else {
          if (!P0(E)) {
            r6(a, _, E), iR();
            return;
          }
          var q = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          g = q;
        }
      } else if (Yo() && m.mode & Xt) {
        Q3();
        var G = i6(l);
        if (G !== null) {
          (G.flags & to) === an && (G.flags |= fi), o6(G, l, m, a, E), v2(cm(g, m));
          return;
        }
      }
      g = cm(g, m), Yie(g);
      var se = l;
      do {
        switch (se.tag) {
          case y: {
            var ue = g;
            se.flags |= to;
            var De = Lf(E);
            se.lanes = Mn(se.lanes, De);
            var Re = n6(se, ue, De);
            D2(se, Re);
            return;
          }
          case f:
            var ze = g, qe = se.type, Je = se.stateNode;
            if ((se.flags & Sn) === an && (typeof qe.getDerivedStateFromError == "function" || Je !== null && typeof Je.componentDidCatch == "function" && !iL(Je))) {
              se.flags |= to;
              var Et = Lf(E);
              se.lanes = Mn(se.lanes, Et);
              var un = k_(se, ze, Et);
              D2(se, un);
              return;
            }
            break;
        }
        se = se.return;
      } while (se !== null);
    }
    function vre() {
      return null;
    }
    var Dw = n.ReactCurrentOwner, _c = !1, A_, Mw, T_, __, R_, um, O_, qS, Pw;
    A_ = {}, Mw = {}, T_ = {}, __ = {}, R_ = {}, um = !1, O_ = {}, qS = {}, Pw = {};
    function Ga(a, l, m, g) {
      a === null ? l.child = lB(l, null, m, g) : l.child = Lv(l, a.child, m, g);
    }
    function gre(a, l, m, g) {
      l.child = Lv(l, a.child, null, g), l.child = Lv(l, null, m, g);
    }
    function a6(a, l, m, g, E) {
      if (l.type !== l.elementType) {
        var _ = m.propTypes;
        _ && xc(
          _,
          g,
          // Resolved props
          "prop",
          Hn(m)
        );
      }
      var B = m.render, q = l.ref, G, se;
      Fv(l, E), Tf(l);
      {
        if (Dw.current = l, di(!0), G = qv(a, l, B, g, q, E), se = Wv(), l.mode & Kn) {
          Oi(!0);
          try {
            G = qv(a, l, B, g, q, E), se = Wv();
          } finally {
            Oi(!1);
          }
        }
        di(!1);
      }
      return ya(), a !== null && !_c ? (xB(a, l, E), Td(a, l, E)) : (Yo() && se && d2(l), l.flags |= iu, Ga(a, l, G, E), l.child);
    }
    function s6(a, l, m, g, E) {
      if (a === null) {
        var _ = m.type;
        if (Eoe(_) && m.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        m.defaultProps === void 0) {
          var B = _;
          return B = eg(_), l.tag = F, l.type = B, M_(l, _), l6(a, l, B, g, E);
        }
        {
          var q = _.propTypes;
          if (q && xc(
            q,
            g,
            // Resolved props
            "prop",
            Hn(_)
          ), m.defaultProps !== void 0) {
            var G = Hn(_) || "Unknown";
            Pw[G] || (s("%s: Support for defaultProps will be removed from memo components in a future major release. Use JavaScript default parameters instead.", G), Pw[G] = !0);
          }
        }
        var se = mR(m.type, null, g, l, l.mode, E);
        return se.ref = l.ref, se.return = l, l.child = se, se;
      }
      {
        var ue = m.type, De = ue.propTypes;
        De && xc(
          De,
          g,
          // Resolved props
          "prop",
          Hn(ue)
        );
      }
      var Re = a.child, ze = F_(a, E);
      if (!ze) {
        var qe = Re.memoizedProps, Je = m.compare;
        if (Je = Je !== null ? Je : gn, Je(qe, g) && a.ref === l.ref)
          return Td(a, l, E);
      }
      l.flags |= iu;
      var Et = mm(Re, g);
      return Et.ref = l.ref, Et.return = l, l.child = Et, Et;
    }
    function l6(a, l, m, g, E) {
      if (l.type !== l.elementType) {
        var _ = l.elementType;
        if (_.$$typeof === tt) {
          var B = _, q = B._payload, G = B._init;
          try {
            _ = G(q);
          } catch {
            _ = null;
          }
          var se = _ && _.propTypes;
          se && xc(
            se,
            g,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            Hn(_)
          );
        }
      }
      if (a !== null) {
        var ue = a.memoizedProps;
        if (gn(ue, g) && a.ref === l.ref && // Prevent bailout if the implementation changed due to hot reload.
        l.type === a.type)
          if (_c = !1, l.pendingProps = g = ue, F_(a, E))
            (a.flags & Rp) !== an && (_c = !0);
          else return l.lanes = a.lanes, Td(a, l, E);
      }
      return I_(a, l, m, g, E);
    }
    function c6(a, l, m) {
      var g = l.pendingProps, E = g.children, _ = a !== null ? a.memoizedState : null;
      if (g.mode === "hidden" || be)
        if ((l.mode & Xt) === Gt) {
          var B = {
            baseLanes: nt,
            cachePool: null,
            transitions: null
          };
          l.memoizedState = B, ik(l, m);
        } else if (ba(m, Lo)) {
          var De = {
            baseLanes: nt,
            cachePool: null,
            transitions: null
          };
          l.memoizedState = De;
          var Re = _ !== null ? _.baseLanes : m;
          ik(l, Re);
        } else {
          var q = null, G;
          if (_ !== null) {
            var se = _.baseLanes;
            G = Mn(se, m);
          } else
            G = m;
          l.lanes = l.childLanes = Lo;
          var ue = {
            baseLanes: G,
            cachePool: q,
            transitions: null
          };
          return l.memoizedState = ue, l.updateQueue = null, ik(l, G), null;
        }
      else {
        var ze;
        _ !== null ? (ze = Mn(_.baseLanes, m), l.memoizedState = null) : ze = m, ik(l, ze);
      }
      return Ga(a, l, E, m), l.child;
    }
    function bre(a, l, m) {
      var g = l.pendingProps;
      return Ga(a, l, g, m), l.child;
    }
    function wre(a, l, m) {
      var g = l.pendingProps.children;
      return Ga(a, l, g, m), l.child;
    }
    function Cre(a, l, m) {
      {
        l.flags |= Bn;
        {
          var g = l.stateNode;
          g.effectDuration = 0, g.passiveEffectDuration = 0;
        }
      }
      var E = l.pendingProps, _ = E.children;
      return Ga(a, l, _, m), l.child;
    }
    function u6(a, l) {
      var m = l.ref;
      (a === null && m !== null || a !== null && a.ref !== m) && (l.flags |= da, l.flags |= C0);
    }
    function I_(a, l, m, g, E) {
      if (l.type !== l.elementType) {
        var _ = m.propTypes;
        _ && xc(
          _,
          g,
          // Resolved props
          "prop",
          Hn(m)
        );
      }
      var B;
      {
        var q = Dv(l, m, !0);
        B = Mv(l, q);
      }
      var G, se;
      Fv(l, E), Tf(l);
      {
        if (Dw.current = l, di(!0), G = qv(a, l, m, g, B, E), se = Wv(), l.mode & Kn) {
          Oi(!0);
          try {
            G = qv(a, l, m, g, B, E), se = Wv();
          } finally {
            Oi(!1);
          }
        }
        di(!1);
      }
      return ya(), a !== null && !_c ? (xB(a, l, E), Td(a, l, E)) : (Yo() && se && d2(l), l.flags |= iu, Ga(a, l, G, E), l.child);
    }
    function d6(a, l, m, g, E) {
      {
        switch (joe(l)) {
          case !1: {
            var _ = l.stateNode, B = l.type, q = new B(l.memoizedProps, _.context), G = q.state;
            _.updater.enqueueSetState(_, G, null);
            break;
          }
          case !0: {
            l.flags |= Sn, l.flags |= to;
            var se = new Error("Simulated error coming from DevTools"), ue = Lf(E);
            l.lanes = Mn(l.lanes, ue);
            var De = k_(l, cm(se, l), ue);
            D2(l, De);
            break;
          }
        }
        if (l.type !== l.elementType) {
          var Re = m.propTypes;
          Re && xc(
            Re,
            g,
            // Resolved props
            "prop",
            Hn(m)
          );
        }
      }
      var ze;
      vu(m) ? (ze = !0, rS(l)) : ze = !1, Fv(l, E);
      var qe = l.stateNode, Je;
      qe === null ? (GS(a, l), e6(l, m, g), x_(l, m, g, E), Je = !0) : a === null ? Je = ure(l, m, g, E) : Je = dre(a, l, m, g, E);
      var Et = D_(a, l, m, Je, ze, E);
      {
        var un = l.stateNode;
        Je && un.props !== g && (um || s("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", En(l) || "a component"), um = !0);
      }
      return Et;
    }
    function D_(a, l, m, g, E, _) {
      u6(a, l);
      var B = (l.flags & Sn) !== an;
      if (!g && !B)
        return E && W3(l, m, !1), Td(a, l, _);
      var q = l.stateNode;
      Dw.current = l;
      var G;
      if (B && typeof m.getDerivedStateFromError != "function")
        G = null, YB();
      else {
        Tf(l);
        {
          if (di(!0), G = q.render(), l.mode & Kn) {
            Oi(!0);
            try {
              q.render();
            } finally {
              Oi(!1);
            }
          }
          di(!1);
        }
        ya();
      }
      return l.flags |= iu, a !== null && B ? gre(a, l, G, _) : Ga(a, l, G, _), l.memoizedState = q.state, E && W3(l, m, !0), l.child;
    }
    function f6(a) {
      var l = a.stateNode;
      l.pendingContext ? H3(a, l.pendingContext, l.pendingContext !== l.context) : l.context && H3(a, l.context, !1), M2(a, l.containerInfo);
    }
    function xre(a, l, m) {
      if (f6(l), a === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var g = l.pendingProps, E = l.memoizedState, _ = E.element;
      mB(a, l), wS(l, g, null, m);
      var B = l.memoizedState;
      l.stateNode;
      var q = B.element;
      if (E.isDehydrated) {
        var G = {
          element: q,
          isDehydrated: !1,
          cache: B.cache,
          pendingSuspenseBoundaries: B.pendingSuspenseBoundaries,
          transitions: B.transitions
        }, se = l.updateQueue;
        if (se.baseState = G, l.memoizedState = G, l.flags & fi) {
          var ue = cm(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), l);
          return h6(a, l, q, m, ue);
        } else if (q !== _) {
          var De = cm(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), l);
          return h6(a, l, q, m, De);
        } else {
          kne(l);
          var Re = lB(l, null, q, m);
          l.child = Re;
          for (var ze = Re; ze; )
            ze.flags = ze.flags & ~qr | vs, ze = ze.sibling;
        }
      } else {
        if (Bv(), q === _)
          return Td(a, l, m);
        Ga(a, l, q, m);
      }
      return l.child;
    }
    function h6(a, l, m, g, E) {
      return Bv(), v2(E), l.flags |= fi, Ga(a, l, m, g), l.child;
    }
    function Ere(a, l, m) {
      bB(l), a === null && y2(l);
      var g = l.type, E = l.pendingProps, _ = a !== null ? a.memoizedProps : null, B = E.children, q = XT(g, E);
      return q ? B = null : _ !== null && XT(g, _) && (l.flags |= kr), u6(a, l), Ga(a, l, B, m), l.child;
    }
    function Sre(a, l) {
      return a === null && y2(l), null;
    }
    function kre(a, l, m, g) {
      GS(a, l);
      var E = l.pendingProps, _ = m, B = _._payload, q = _._init, G = q(B);
      l.type = G;
      var se = l.tag = Soe(G), ue = Tc(G, E), De;
      switch (se) {
        case u:
          return M_(l, G), l.type = G = eg(G), De = I_(null, l, G, ue, g), De;
        case f:
          return l.type = G = cR(G), De = d6(null, l, G, ue, g), De;
        case D:
          return l.type = G = uR(G), De = a6(null, l, G, ue, g), De;
        case j: {
          if (l.type !== l.elementType) {
            var Re = G.propTypes;
            Re && xc(
              Re,
              ue,
              // Resolved for outer only
              "prop",
              Hn(G)
            );
          }
          return De = s6(
            null,
            l,
            G,
            Tc(G.type, ue),
            // The inner type can have defaults too
            g
          ), De;
        }
      }
      var ze = "";
      throw G !== null && typeof G == "object" && G.$$typeof === tt && (ze = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + G + ". " + ("Lazy element type must resolve to a class or function." + ze));
    }
    function Are(a, l, m, g, E) {
      GS(a, l), l.tag = f;
      var _;
      return vu(m) ? (_ = !0, rS(l)) : _ = !1, Fv(l, E), e6(l, m, g), x_(l, m, g, E), D_(null, l, m, !0, _, E);
    }
    function Tre(a, l, m, g) {
      GS(a, l);
      var E = l.pendingProps, _;
      {
        var B = Dv(l, m, !1);
        _ = Mv(l, B);
      }
      Fv(l, g);
      var q, G;
      Tf(l);
      {
        if (m.prototype && typeof m.prototype.render == "function") {
          var se = Hn(m) || "Unknown";
          A_[se] || (s("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", se, se), A_[se] = !0);
        }
        l.mode & Kn && Sc.recordLegacyContextWarning(l, null), di(!0), Dw.current = l, q = qv(null, l, m, E, _, g), G = Wv(), di(!1);
      }
      if (ya(), l.flags |= iu, typeof q == "object" && q !== null && typeof q.render == "function" && q.$$typeof === void 0) {
        var ue = Hn(m) || "Unknown";
        Mw[ue] || (s("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", ue, ue, ue), Mw[ue] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof q == "object" && q !== null && typeof q.render == "function" && q.$$typeof === void 0
      ) {
        {
          var De = Hn(m) || "Unknown";
          Mw[De] || (s("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", De, De, De), Mw[De] = !0);
        }
        l.tag = f, l.memoizedState = null, l.updateQueue = null;
        var Re = !1;
        return vu(m) ? (Re = !0, rS(l)) : Re = !1, l.memoizedState = q.state !== null && q.state !== void 0 ? q.state : null, I2(l), ZB(l, q), x_(l, m, E, g), D_(null, l, m, !0, Re, g);
      } else {
        if (l.tag = u, l.mode & Kn) {
          Oi(!0);
          try {
            q = qv(null, l, m, E, _, g), G = Wv();
          } finally {
            Oi(!1);
          }
        }
        return Yo() && G && d2(l), Ga(null, l, q, g), M_(l, m), l.child;
      }
    }
    function M_(a, l) {
      {
        if (l && l.childContextTypes && s("%s(...): childContextTypes cannot be defined on a function component.", l.displayName || l.name || "Component"), a.ref !== null) {
          var m = "", g = Fi();
          g && (m += `

Check the render method of \`` + g + "`.");
          var E = g || "", _ = a._debugSource;
          _ && (E = _.fileName + ":" + _.lineNumber), R_[E] || (R_[E] = !0, s("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", m));
        }
        if (l.defaultProps !== void 0) {
          var B = Hn(l) || "Unknown";
          Pw[B] || (s("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", B), Pw[B] = !0);
        }
        if (typeof l.getDerivedStateFromProps == "function") {
          var q = Hn(l) || "Unknown";
          __[q] || (s("%s: Function components do not support getDerivedStateFromProps.", q), __[q] = !0);
        }
        if (typeof l.contextType == "object" && l.contextType !== null) {
          var G = Hn(l) || "Unknown";
          T_[G] || (s("%s: Function components do not support contextType.", G), T_[G] = !0);
        }
      }
    }
    var P_ = {
      dehydrated: null,
      treeContext: null,
      retryLane: Ii
    };
    function N_(a) {
      return {
        baseLanes: a,
        cachePool: vre(),
        transitions: null
      };
    }
    function _re(a, l) {
      var m = null;
      return {
        baseLanes: Mn(a.baseLanes, l),
        cachePool: m,
        transitions: a.transitions
      };
    }
    function Rre(a, l, m, g) {
      if (l !== null) {
        var E = l.memoizedState;
        if (E === null)
          return !1;
      }
      return B2(a, Ew);
    }
    function Ore(a, l) {
      return Fp(a.childLanes, l);
    }
    function p6(a, l, m) {
      var g = l.pendingProps;
      Foe(l) && (l.flags |= Sn);
      var E = kc.current, _ = !1, B = (l.flags & Sn) !== an;
      if (B || Rre(E, a) ? (_ = !0, l.flags &= ~Sn) : (a === null || a.memoizedState !== null) && (E = Kne(E, CB)), E = zv(E), lh(l, E), a === null) {
        y2(l);
        var q = l.memoizedState;
        if (q !== null) {
          var G = q.dehydrated;
          if (G !== null)
            return Nre(l, G);
        }
        var se = g.children, ue = g.fallback;
        if (_) {
          var De = Ire(l, se, ue, m), Re = l.child;
          return Re.memoizedState = N_(m), l.memoizedState = P_, De;
        } else
          return B_(l, se);
      } else {
        var ze = a.memoizedState;
        if (ze !== null) {
          var qe = ze.dehydrated;
          if (qe !== null)
            return Bre(a, l, B, g, qe, ze, m);
        }
        if (_) {
          var Je = g.fallback, Et = g.children, un = Mre(a, l, Et, Je, m), Jt = l.child, ir = a.child.memoizedState;
          return Jt.memoizedState = ir === null ? N_(m) : _re(ir, m), Jt.childLanes = Ore(a, m), l.memoizedState = P_, un;
        } else {
          var Jn = g.children, Le = Dre(a, l, Jn, m);
          return l.memoizedState = null, Le;
        }
      }
    }
    function B_(a, l, m) {
      var g = a.mode, E = {
        mode: "visible",
        children: l
      }, _ = L_(E, g);
      return _.return = a, a.child = _, _;
    }
    function Ire(a, l, m, g) {
      var E = a.mode, _ = a.child, B = {
        mode: "hidden",
        children: l
      }, q, G;
      return (E & Xt) === Gt && _ !== null ? (q = _, q.childLanes = nt, q.pendingProps = B, a.mode & kn && (q.actualDuration = 0, q.actualStartTime = -1, q.selfBaseDuration = 0, q.treeBaseDuration = 0), G = yh(m, E, g, null)) : (q = L_(B, E), G = yh(m, E, g, null)), q.return = a, G.return = a, q.sibling = G, a.child = q, G;
    }
    function L_(a, l, m) {
      return mL(a, l, nt, null);
    }
    function m6(a, l) {
      return mm(a, l);
    }
    function Dre(a, l, m, g) {
      var E = a.child, _ = E.sibling, B = m6(E, {
        mode: "visible",
        children: m
      });
      if ((l.mode & Xt) === Gt && (B.lanes = g), B.return = l, B.sibling = null, _ !== null) {
        var q = l.deletions;
        q === null ? (l.deletions = [_], l.flags |= wr) : q.push(_);
      }
      return l.child = B, B;
    }
    function Mre(a, l, m, g, E) {
      var _ = l.mode, B = a.child, q = B.sibling, G = {
        mode: "hidden",
        children: m
      }, se;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (_ & Xt) === Gt && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        l.child !== B
      ) {
        var ue = l.child;
        se = ue, se.childLanes = nt, se.pendingProps = G, l.mode & kn && (se.actualDuration = 0, se.actualStartTime = -1, se.selfBaseDuration = B.selfBaseDuration, se.treeBaseDuration = B.treeBaseDuration), l.deletions = null;
      } else
        se = m6(B, G), se.subtreeFlags = B.subtreeFlags & mo;
      var De;
      return q !== null ? De = mm(q, g) : (De = yh(g, _, E, null), De.flags |= qr), De.return = l, se.return = l, se.sibling = De, l.child = se, De;
    }
    function WS(a, l, m, g) {
      g !== null && v2(g), Lv(l, a.child, null, m);
      var E = l.pendingProps, _ = E.children, B = B_(l, _);
      return B.flags |= qr, l.memoizedState = null, B;
    }
    function Pre(a, l, m, g, E) {
      var _ = l.mode, B = {
        mode: "visible",
        children: m
      }, q = L_(B, _), G = yh(g, _, E, null);
      return G.flags |= qr, q.return = l, G.return = l, q.sibling = G, l.child = q, (l.mode & Xt) !== Gt && Lv(l, a.child, null, E), G;
    }
    function Nre(a, l, m) {
      return (a.mode & Xt) === Gt ? (s("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), a.lanes = nn) : t2(l) ? a.lanes = vc : a.lanes = Lo, null;
    }
    function Bre(a, l, m, g, E, _, B) {
      if (m)
        if (l.flags & fi) {
          l.flags &= ~fi;
          var Le = E_(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return WS(a, l, B, Le);
        } else {
          if (l.memoizedState !== null)
            return l.child = a.child, l.flags |= Sn, null;
          var Ze = g.children, je = g.fallback, dt = Pre(a, l, Ze, je, B), Dt = l.child;
          return Dt.memoizedState = N_(B), l.memoizedState = P_, dt;
        }
      else {
        if (Ene(), (l.mode & Xt) === Gt)
          return WS(
            a,
            l,
            B,
            // TODO: When we delete legacy mode, we should make this error argument
            // required  every concurrent mode path that causes hydration to
            // de-opt to client rendering should have an error message.
            null
          );
        if (t2(E)) {
          var q, G, se;
          {
            var ue = Ute(E);
            q = ue.digest, G = ue.message, se = ue.stack;
          }
          var De;
          G ? De = new Error(G) : De = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var Re = E_(De, q, se);
          return WS(a, l, B, Re);
        }
        var ze = ba(B, a.childLanes);
        if (_c || ze) {
          var qe = rk();
          if (qe !== null) {
            var Je = gE(qe, B);
            if (Je !== Ii && Je !== _.retryLane) {
              _.retryLane = Je;
              var Et = Vr;
              Rs(a, Je), ko(qe, a, Je, Et);
            }
          }
          iR();
          var un = E_(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return WS(a, l, B, un);
        } else if (j3(E)) {
          l.flags |= Sn, l.child = a.child;
          var Jt = soe.bind(null, a);
          return zte(E, Jt), null;
        } else {
          Ane(l, E, _.treeContext);
          var ir = g.children, Jn = B_(l, ir);
          return Jn.flags |= vs, Jn;
        }
      }
    }
    function y6(a, l, m) {
      a.lanes = Mn(a.lanes, l);
      var g = a.alternate;
      g !== null && (g.lanes = Mn(g.lanes, l)), T2(a.return, l, m);
    }
    function Lre(a, l, m) {
      for (var g = l; g !== null; ) {
        if (g.tag === L) {
          var E = g.memoizedState;
          E !== null && y6(g, m, a);
        } else if (g.tag === Q)
          y6(g, m, a);
        else if (g.child !== null) {
          g.child.return = g, g = g.child;
          continue;
        }
        if (g === a)
          return;
        for (; g.sibling === null; ) {
          if (g.return === null || g.return === a)
            return;
          g = g.return;
        }
        g.sibling.return = g.return, g = g.sibling;
      }
    }
    function jre(a) {
      for (var l = a, m = null; l !== null; ) {
        var g = l.alternate;
        g !== null && SS(g) === null && (m = l), l = l.sibling;
      }
      return m;
    }
    function Fre(a) {
      if (a !== void 0 && a !== "forwards" && a !== "backwards" && a !== "together" && !O_[a])
        if (O_[a] = !0, typeof a == "string")
          switch (a.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              s('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', a, a.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              s('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', a, a.toLowerCase());
              break;
            }
            default:
              s('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', a);
              break;
          }
        else
          s('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', a);
    }
    function Ure(a, l) {
      a !== void 0 && !qS[a] && (a !== "collapsed" && a !== "hidden" ? (qS[a] = !0, s('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', a)) : l !== "forwards" && l !== "backwards" && (qS[a] = !0, s('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', a)));
    }
    function v6(a, l) {
      {
        var m = Zn(a), g = !m && typeof xr(a) == "function";
        if (m || g) {
          var E = m ? "array" : "iterable";
          return s("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", E, l, E), !1;
        }
      }
      return !0;
    }
    function zre(a, l) {
      if ((l === "forwards" || l === "backwards") && a !== void 0 && a !== null && a !== !1)
        if (Zn(a)) {
          for (var m = 0; m < a.length; m++)
            if (!v6(a[m], m))
              return;
        } else {
          var g = xr(a);
          if (typeof g == "function") {
            var E = g.call(a);
            if (E)
              for (var _ = E.next(), B = 0; !_.done; _ = E.next()) {
                if (!v6(_.value, B))
                  return;
                B++;
              }
          } else
            s('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', l);
        }
    }
    function j_(a, l, m, g, E) {
      var _ = a.memoizedState;
      _ === null ? a.memoizedState = {
        isBackwards: l,
        rendering: null,
        renderingStartTime: 0,
        last: g,
        tail: m,
        tailMode: E
      } : (_.isBackwards = l, _.rendering = null, _.renderingStartTime = 0, _.last = g, _.tail = m, _.tailMode = E);
    }
    function g6(a, l, m) {
      var g = l.pendingProps, E = g.revealOrder, _ = g.tail, B = g.children;
      Fre(E), Ure(_, E), zre(B, E), Ga(a, l, B, m);
      var q = kc.current, G = B2(q, Ew);
      if (G)
        q = L2(q, Ew), l.flags |= Sn;
      else {
        var se = a !== null && (a.flags & Sn) !== an;
        se && Lre(l, l.child, m), q = zv(q);
      }
      if (lh(l, q), (l.mode & Xt) === Gt)
        l.memoizedState = null;
      else
        switch (E) {
          case "forwards": {
            var ue = jre(l.child), De;
            ue === null ? (De = l.child, l.child = null) : (De = ue.sibling, ue.sibling = null), j_(
              l,
              !1,
              // isBackwards
              De,
              ue,
              _
            );
            break;
          }
          case "backwards": {
            var Re = null, ze = l.child;
            for (l.child = null; ze !== null; ) {
              var qe = ze.alternate;
              if (qe !== null && SS(qe) === null) {
                l.child = ze;
                break;
              }
              var Je = ze.sibling;
              ze.sibling = Re, Re = ze, ze = Je;
            }
            j_(
              l,
              !0,
              // isBackwards
              Re,
              null,
              // last
              _
            );
            break;
          }
          case "together": {
            j_(
              l,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            l.memoizedState = null;
        }
      return l.child;
    }
    function Vre(a, l, m) {
      M2(l, l.stateNode.containerInfo);
      var g = l.pendingProps;
      return a === null ? l.child = Lv(l, null, g, m) : Ga(a, l, g, m), l.child;
    }
    var b6 = !1;
    function $re(a, l, m) {
      var g = l.type, E = g._context, _ = l.pendingProps, B = l.memoizedProps, q = _.value;
      {
        "value" in _ || b6 || (b6 = !0, s("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var G = l.type.propTypes;
        G && xc(G, _, "prop", "Context.Provider");
      }
      if (dB(l, E, q), B !== null) {
        var se = B.value;
        if (jt(se, q)) {
          if (B.children === _.children && !tS())
            return Td(a, l, m);
        } else
          Fne(l, E, m);
      }
      var ue = _.children;
      return Ga(a, l, ue, m), l.child;
    }
    var w6 = !1;
    function Hre(a, l, m) {
      var g = l.type;
      g._context === void 0 ? g !== g.Consumer && (w6 || (w6 = !0, s("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : g = g._context;
      var E = l.pendingProps, _ = E.children;
      typeof _ != "function" && s("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), Fv(l, m);
      var B = oo(g);
      Tf(l);
      var q;
      return Dw.current = l, di(!0), q = _(B), di(!1), ya(), l.flags |= iu, Ga(a, l, q, m), l.child;
    }
    function Nw() {
      _c = !0;
    }
    function GS(a, l) {
      (l.mode & Xt) === Gt && a !== null && (a.alternate = null, l.alternate = null, l.flags |= qr);
    }
    function Td(a, l, m) {
      return a !== null && (l.dependencies = a.dependencies), YB(), Gw(l.lanes), ba(m, l.childLanes) ? (Lne(a, l), l.child) : null;
    }
    function qre(a, l, m) {
      {
        var g = l.return;
        if (g === null)
          throw new Error("Cannot swap the root fiber.");
        if (a.alternate = null, l.alternate = null, m.index = l.index, m.sibling = l.sibling, m.return = l.return, m.ref = l.ref, l === g.child)
          g.child = m;
        else {
          var E = g.child;
          if (E === null)
            throw new Error("Expected parent to have a child.");
          for (; E.sibling !== l; )
            if (E = E.sibling, E === null)
              throw new Error("Expected to find the previous sibling.");
          E.sibling = m;
        }
        var _ = g.deletions;
        return _ === null ? (g.deletions = [a], g.flags |= wr) : _.push(a), m.flags |= qr, m;
      }
    }
    function F_(a, l) {
      var m = a.lanes;
      return !!ba(m, l);
    }
    function Wre(a, l, m) {
      switch (l.tag) {
        case y:
          f6(l), l.stateNode, Bv();
          break;
        case w:
          bB(l);
          break;
        case f: {
          var g = l.type;
          vu(g) && rS(l);
          break;
        }
        case v:
          M2(l, l.stateNode.containerInfo);
          break;
        case I: {
          var E = l.memoizedProps.value, _ = l.type._context;
          dB(l, _, E);
          break;
        }
        case M:
          {
            var B = ba(m, l.childLanes);
            B && (l.flags |= Bn);
            {
              var q = l.stateNode;
              q.effectDuration = 0, q.passiveEffectDuration = 0;
            }
          }
          break;
        case L: {
          var G = l.memoizedState;
          if (G !== null) {
            if (G.dehydrated !== null)
              return lh(l, zv(kc.current)), l.flags |= Sn, null;
            var se = l.child, ue = se.childLanes;
            if (ba(m, ue))
              return p6(a, l, m);
            lh(l, zv(kc.current));
            var De = Td(a, l, m);
            return De !== null ? De.sibling : null;
          } else
            lh(l, zv(kc.current));
          break;
        }
        case Q: {
          var Re = (a.flags & Sn) !== an, ze = ba(m, l.childLanes);
          if (Re) {
            if (ze)
              return g6(a, l, m);
            l.flags |= Sn;
          }
          var qe = l.memoizedState;
          if (qe !== null && (qe.rendering = null, qe.tail = null, qe.lastEffect = null), lh(l, kc.current), ze)
            break;
          return null;
        }
        case ee:
        case ie:
          return l.lanes = nt, c6(a, l, m);
      }
      return Td(a, l, m);
    }
    function C6(a, l, m) {
      if (l._debugNeedsRemount && a !== null)
        return qre(a, l, mR(l.type, l.key, l.pendingProps, l._debugOwner || null, l.mode, l.lanes));
      if (a !== null) {
        var g = a.memoizedProps, E = l.pendingProps;
        if (g !== E || tS() || // Force a re-render if the implementation changed due to hot reload:
        l.type !== a.type)
          _c = !0;
        else {
          var _ = F_(a, m);
          if (!_ && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (l.flags & Sn) === an)
            return _c = !1, Wre(a, l, m);
          (a.flags & Rp) !== an ? _c = !0 : _c = !1;
        }
      } else if (_c = !1, Yo() && vne(l)) {
        var B = l.index, q = gne();
        Y3(l, q, B);
      }
      switch (l.lanes = nt, l.tag) {
        case p:
          return Tre(a, l, l.type, m);
        case O: {
          var G = l.elementType;
          return kre(a, l, G, m);
        }
        case u: {
          var se = l.type, ue = l.pendingProps, De = l.elementType === se ? ue : Tc(se, ue);
          return I_(a, l, se, De, m);
        }
        case f: {
          var Re = l.type, ze = l.pendingProps, qe = l.elementType === Re ? ze : Tc(Re, ze);
          return d6(a, l, Re, qe, m);
        }
        case y:
          return xre(a, l, m);
        case w:
          return Ere(a, l, m);
        case C:
          return Sre(a, l);
        case L:
          return p6(a, l, m);
        case v:
          return Vre(a, l, m);
        case D: {
          var Je = l.type, Et = l.pendingProps, un = l.elementType === Je ? Et : Tc(Je, Et);
          return a6(a, l, Je, un, m);
        }
        case x:
          return bre(a, l, m);
        case A:
          return wre(a, l, m);
        case M:
          return Cre(a, l, m);
        case I:
          return $re(a, l, m);
        case R:
          return Hre(a, l, m);
        case j: {
          var Jt = l.type, ir = l.pendingProps, Jn = Tc(Jt, ir);
          if (l.type !== l.elementType) {
            var Le = Jt.propTypes;
            Le && xc(
              Le,
              Jn,
              // Resolved for outer only
              "prop",
              Hn(Jt)
            );
          }
          return Jn = Tc(Jt.type, Jn), s6(a, l, Jt, Jn, m);
        }
        case F:
          return l6(a, l, l.type, l.pendingProps, m);
        case z: {
          var Ze = l.type, je = l.pendingProps, dt = l.elementType === Ze ? je : Tc(Ze, je);
          return Are(a, l, Ze, dt, m);
        }
        case Q:
          return g6(a, l, m);
        case Y:
          break;
        case ee:
          return c6(a, l, m);
      }
      throw new Error("Unknown unit of work tag (" + l.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function Gv(a) {
      a.flags |= Bn;
    }
    function x6(a) {
      a.flags |= da, a.flags |= C0;
    }
    var E6, U_, S6, k6;
    E6 = function(a, l, m, g) {
      for (var E = l.child; E !== null; ) {
        if (E.tag === w || E.tag === C)
          pte(a, E.stateNode);
        else if (E.tag !== v) {
          if (E.child !== null) {
            E.child.return = E, E = E.child;
            continue;
          }
        }
        if (E === l)
          return;
        for (; E.sibling === null; ) {
          if (E.return === null || E.return === l)
            return;
          E = E.return;
        }
        E.sibling.return = E.return, E = E.sibling;
      }
    }, U_ = function(a, l) {
    }, S6 = function(a, l, m, g, E) {
      var _ = a.memoizedProps;
      if (_ !== g) {
        var B = l.stateNode, q = P2(), G = yte(B, m, _, g, E, q);
        l.updateQueue = G, G && Gv(l);
      }
    }, k6 = function(a, l, m, g) {
      m !== g && Gv(l);
    };
    function Bw(a, l) {
      if (!Yo())
        switch (a.tailMode) {
          case "hidden": {
            for (var m = a.tail, g = null; m !== null; )
              m.alternate !== null && (g = m), m = m.sibling;
            g === null ? a.tail = null : g.sibling = null;
            break;
          }
          case "collapsed": {
            for (var E = a.tail, _ = null; E !== null; )
              E.alternate !== null && (_ = E), E = E.sibling;
            _ === null ? !l && a.tail !== null ? a.tail.sibling = null : a.tail = null : _.sibling = null;
            break;
          }
        }
    }
    function Xo(a) {
      var l = a.alternate !== null && a.alternate.child === a.child, m = nt, g = an;
      if (l) {
        if ((a.mode & kn) !== Gt) {
          for (var G = a.selfBaseDuration, se = a.child; se !== null; )
            m = Mn(m, Mn(se.lanes, se.childLanes)), g |= se.subtreeFlags & mo, g |= se.flags & mo, G += se.treeBaseDuration, se = se.sibling;
          a.treeBaseDuration = G;
        } else
          for (var ue = a.child; ue !== null; )
            m = Mn(m, Mn(ue.lanes, ue.childLanes)), g |= ue.subtreeFlags & mo, g |= ue.flags & mo, ue.return = a, ue = ue.sibling;
        a.subtreeFlags |= g;
      } else {
        if ((a.mode & kn) !== Gt) {
          for (var E = a.actualDuration, _ = a.selfBaseDuration, B = a.child; B !== null; )
            m = Mn(m, Mn(B.lanes, B.childLanes)), g |= B.subtreeFlags, g |= B.flags, E += B.actualDuration, _ += B.treeBaseDuration, B = B.sibling;
          a.actualDuration = E, a.treeBaseDuration = _;
        } else
          for (var q = a.child; q !== null; )
            m = Mn(m, Mn(q.lanes, q.childLanes)), g |= q.subtreeFlags, g |= q.flags, q.return = a, q = q.sibling;
        a.subtreeFlags |= g;
      }
      return a.childLanes = m, l;
    }
    function Gre(a, l, m) {
      if (Ine() && (l.mode & Xt) !== Gt && (l.flags & Sn) === an)
        return nB(l), Bv(), l.flags |= fi | za | to, !1;
      var g = lS(l);
      if (m !== null && m.dehydrated !== null)
        if (a === null) {
          if (!g)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (Rne(l), Xo(l), (l.mode & kn) !== Gt) {
            var E = m !== null;
            if (E) {
              var _ = l.child;
              _ !== null && (l.treeBaseDuration -= _.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (Bv(), (l.flags & Sn) === an && (l.memoizedState = null), l.flags |= Bn, Xo(l), (l.mode & kn) !== Gt) {
            var B = m !== null;
            if (B) {
              var q = l.child;
              q !== null && (l.treeBaseDuration -= q.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return rB(), !0;
    }
    function A6(a, l, m) {
      var g = l.pendingProps;
      switch (f2(l), l.tag) {
        case p:
        case O:
        case F:
        case u:
        case D:
        case x:
        case A:
        case M:
        case R:
        case j:
          return Xo(l), null;
        case f: {
          var E = l.type;
          return vu(E) && nS(l), Xo(l), null;
        }
        case y: {
          var _ = l.stateNode;
          if (Uv(l), l2(l), F2(), _.pendingContext && (_.context = _.pendingContext, _.pendingContext = null), a === null || a.child === null) {
            var B = lS(l);
            if (B)
              Gv(l);
            else if (a !== null) {
              var q = a.memoizedState;
              // Check if this is a client root
              (!q.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (l.flags & fi) !== an) && (l.flags |= ys, rB());
            }
          }
          return U_(a, l), Xo(l), null;
        }
        case w: {
          N2(l);
          var G = gB(), se = l.type;
          if (a !== null && l.stateNode != null)
            S6(a, l, se, g, G), a.ref !== l.ref && x6(l);
          else {
            if (!g) {
              if (l.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return Xo(l), null;
            }
            var ue = P2(), De = lS(l);
            if (De)
              Tne(l, G, ue) && Gv(l);
            else {
              var Re = hte(se, g, G, ue, l);
              E6(Re, l, !1, !1), l.stateNode = Re, mte(Re, se, g, G) && Gv(l);
            }
            l.ref !== null && x6(l);
          }
          return Xo(l), null;
        }
        case C: {
          var ze = g;
          if (a && l.stateNode != null) {
            var qe = a.memoizedProps;
            k6(a, l, qe, ze);
          } else {
            if (typeof ze != "string" && l.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var Je = gB(), Et = P2(), un = lS(l);
            un ? _ne(l) && Gv(l) : l.stateNode = vte(ze, Je, Et, l);
          }
          return Xo(l), null;
        }
        case L: {
          Vv(l);
          var Jt = l.memoizedState;
          if (a === null || a.memoizedState !== null && a.memoizedState.dehydrated !== null) {
            var ir = Gre(a, l, Jt);
            if (!ir)
              return l.flags & to ? l : null;
          }
          if ((l.flags & Sn) !== an)
            return l.lanes = m, (l.mode & kn) !== Gt && u_(l), l;
          var Jn = Jt !== null, Le = a !== null && a.memoizedState !== null;
          if (Jn !== Le && Jn) {
            var Ze = l.child;
            if (Ze.flags |= ou, (l.mode & Xt) !== Gt) {
              var je = a === null && (l.memoizedProps.unstable_avoidThisFallback !== !0 || !ce);
              je || B2(kc.current, CB) ? Kie() : iR();
            }
          }
          var dt = l.updateQueue;
          if (dt !== null && (l.flags |= Bn), Xo(l), (l.mode & kn) !== Gt && Jn) {
            var Dt = l.child;
            Dt !== null && (l.treeBaseDuration -= Dt.treeBaseDuration);
          }
          return null;
        }
        case v:
          return Uv(l), U_(a, l), a === null && une(l.stateNode.containerInfo), Xo(l), null;
        case I:
          var At = l.type._context;
          return A2(At, l), Xo(l), null;
        case z: {
          var Cn = l.type;
          return vu(Cn) && nS(l), Xo(l), null;
        }
        case Q: {
          Vv(l);
          var In = l.memoizedState;
          if (In === null)
            return Xo(l), null;
          var Dr = (l.flags & Sn) !== an, yr = In.rendering;
          if (yr === null)
            if (Dr)
              Bw(In, !1);
            else {
              var qi = Qie() && (a === null || (a.flags & Sn) === an);
              if (!qi)
                for (var vr = l.child; vr !== null; ) {
                  var Di = SS(vr);
                  if (Di !== null) {
                    Dr = !0, l.flags |= Sn, Bw(In, !1);
                    var Sa = Di.updateQueue;
                    return Sa !== null && (l.updateQueue = Sa, l.flags |= Bn), l.subtreeFlags = an, jne(l, m), lh(l, L2(kc.current, Ew)), l.child;
                  }
                  vr = vr.sibling;
                }
              In.tail !== null && oi() > G6() && (l.flags |= Sn, Dr = !0, Bw(In, !1), l.lanes = sE);
            }
          else {
            if (!Dr) {
              var na = SS(yr);
              if (na !== null) {
                l.flags |= Sn, Dr = !0;
                var ol = na.updateQueue;
                if (ol !== null && (l.updateQueue = ol, l.flags |= Bn), Bw(In, !0), In.tail === null && In.tailMode === "hidden" && !yr.alternate && !Yo())
                  return Xo(l), null;
              } else // The time it took to render last row is greater than the remaining
              // time we have to render. So rendering one more row would likely
              // exceed it.
              oi() * 2 - In.renderingStartTime > G6() && m !== Lo && (l.flags |= Sn, Dr = !0, Bw(In, !1), l.lanes = sE);
            }
            if (In.isBackwards)
              yr.sibling = l.child, l.child = yr;
            else {
              var Qa = In.last;
              Qa !== null ? Qa.sibling = yr : l.child = yr, In.last = yr;
            }
          }
          if (In.tail !== null) {
            var Xa = In.tail;
            In.rendering = Xa, In.tail = Xa.sibling, In.renderingStartTime = oi(), Xa.sibling = null;
            var ka = kc.current;
            return Dr ? ka = L2(ka, Ew) : ka = zv(ka), lh(l, ka), Xa;
          }
          return Xo(l), null;
        }
        case Y:
          break;
        case ee:
        case ie: {
          rR(l);
          var Dd = l.memoizedState, tg = Dd !== null;
          if (a !== null) {
            var Jw = a.memoizedState, ku = Jw !== null;
            ku !== tg && // LegacyHidden doesn't do any hiding  it only pre-renders.
            !be && (l.flags |= ou);
          }
          return !tg || (l.mode & Xt) === Gt ? Xo(l) : ba(Su, Lo) && (Xo(l), l.subtreeFlags & (qr | Bn) && (l.flags |= ou)), null;
        }
        case X:
          return null;
        case Z:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + l.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function Kre(a, l, m) {
      switch (f2(l), l.tag) {
        case f: {
          var g = l.type;
          vu(g) && nS(l);
          var E = l.flags;
          return E & to ? (l.flags = E & ~to | Sn, (l.mode & kn) !== Gt && u_(l), l) : null;
        }
        case y: {
          l.stateNode, Uv(l), l2(l), F2();
          var _ = l.flags;
          return (_ & to) !== an && (_ & Sn) === an ? (l.flags = _ & ~to | Sn, l) : null;
        }
        case w:
          return N2(l), null;
        case L: {
          Vv(l);
          var B = l.memoizedState;
          if (B !== null && B.dehydrated !== null) {
            if (l.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            Bv();
          }
          var q = l.flags;
          return q & to ? (l.flags = q & ~to | Sn, (l.mode & kn) !== Gt && u_(l), l) : null;
        }
        case Q:
          return Vv(l), null;
        case v:
          return Uv(l), null;
        case I:
          var G = l.type._context;
          return A2(G, l), null;
        case ee:
        case ie:
          return rR(l), null;
        case X:
          return null;
        default:
          return null;
      }
    }
    function T6(a, l, m) {
      switch (f2(l), l.tag) {
        case f: {
          var g = l.type.childContextTypes;
          g != null && nS(l);
          break;
        }
        case y: {
          l.stateNode, Uv(l), l2(l), F2();
          break;
        }
        case w: {
          N2(l);
          break;
        }
        case v:
          Uv(l);
          break;
        case L:
          Vv(l);
          break;
        case Q:
          Vv(l);
          break;
        case I:
          var E = l.type._context;
          A2(E, l);
          break;
        case ee:
        case ie:
          rR(l);
          break;
      }
    }
    var _6 = null;
    _6 = /* @__PURE__ */ new Set();
    var KS = !1, Jo = !1, Yre = typeof WeakSet == "function" ? WeakSet : Set, Ft = null, Kv = null, Yv = null;
    function Qre(a) {
      rd(null, function() {
        throw a;
      }), b0();
    }
    var Xre = function(a, l) {
      if (l.props = a.memoizedProps, l.state = a.memoizedState, a.mode & kn)
        try {
          xu(), l.componentWillUnmount();
        } finally {
          Cu(a);
        }
      else
        l.componentWillUnmount();
    };
    function R6(a, l) {
      try {
        dh(bo, a);
      } catch (m) {
        Kr(a, l, m);
      }
    }
    function z_(a, l, m) {
      try {
        Xre(a, m);
      } catch (g) {
        Kr(a, l, g);
      }
    }
    function Jre(a, l, m) {
      try {
        m.componentDidMount();
      } catch (g) {
        Kr(a, l, g);
      }
    }
    function O6(a, l) {
      try {
        D6(a);
      } catch (m) {
        Kr(a, l, m);
      }
    }
    function Qv(a, l) {
      var m = a.ref;
      if (m !== null)
        if (typeof m == "function") {
          var g;
          try {
            if (Fe && st && a.mode & kn)
              try {
                xu(), g = m(null);
              } finally {
                Cu(a);
              }
            else
              g = m(null);
          } catch (E) {
            Kr(a, l, E);
          }
          typeof g == "function" && s("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", En(a));
        } else
          m.current = null;
    }
    function YS(a, l, m) {
      try {
        m();
      } catch (g) {
        Kr(a, l, g);
      }
    }
    var I6 = !1;
    function Zre(a, l) {
      dte(a.containerInfo), Ft = l, eie();
      var m = I6;
      return I6 = !1, m;
    }
    function eie() {
      for (; Ft !== null; ) {
        var a = Ft, l = a.child;
        (a.subtreeFlags & Sf) !== an && l !== null ? (l.return = a, Ft = l) : tie();
      }
    }
    function tie() {
      for (; Ft !== null; ) {
        var a = Ft;
        lr(a);
        try {
          nie(a);
        } catch (m) {
          Kr(a, a.return, m);
        }
        Hr();
        var l = a.sibling;
        if (l !== null) {
          l.return = a.return, Ft = l;
          return;
        }
        Ft = a.return;
      }
    }
    function nie(a) {
      var l = a.alternate, m = a.flags;
      if ((m & ys) !== an) {
        switch (lr(a), a.tag) {
          case u:
          case D:
          case F:
            break;
          case f: {
            if (l !== null) {
              var g = l.memoizedProps, E = l.memoizedState, _ = a.stateNode;
              a.type === a.elementType && !um && (_.props !== a.memoizedProps && s("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", En(a) || "instance"), _.state !== a.memoizedState && s("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", En(a) || "instance"));
              var B = _.getSnapshotBeforeUpdate(a.elementType === a.type ? g : Tc(a.type, g), E);
              {
                var q = _6;
                B === void 0 && !q.has(a.type) && (q.add(a.type), s("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", En(a)));
              }
              _.__reactInternalSnapshotBeforeUpdate = B;
            }
            break;
          }
          case y: {
            {
              var G = a.stateNode;
              Bte(G.containerInfo);
            }
            break;
          }
          case w:
          case C:
          case v:
          case z:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        Hr();
      }
    }
    function Rc(a, l, m) {
      var g = l.updateQueue, E = g !== null ? g.lastEffect : null;
      if (E !== null) {
        var _ = E.next, B = _;
        do {
          if ((B.tag & a) === a) {
            var q = B.destroy;
            B.destroy = void 0, q !== void 0 && ((a & Qo) !== Os ? iE(l) : (a & bo) !== Os && nl(l), (a & gu) !== Os && Yw(!0), YS(l, m, q), (a & gu) !== Os && Yw(!1), (a & Qo) !== Os ? By() : (a & bo) !== Os && _f());
          }
          B = B.next;
        } while (B !== _);
      }
    }
    function dh(a, l) {
      var m = l.updateQueue, g = m !== null ? m.lastEffect : null;
      if (g !== null) {
        var E = g.next, _ = E;
        do {
          if ((_.tag & a) === a) {
            (a & Qo) !== Os ? lu(l) : (a & bo) !== Os && oE(l);
            var B = _.create;
            (a & gu) !== Os && Yw(!0), _.destroy = B(), (a & gu) !== Os && Yw(!1), (a & Qo) !== Os ? Ny() : (a & bo) !== Os && Op();
            {
              var q = _.destroy;
              if (q !== void 0 && typeof q != "function") {
                var G = void 0;
                (_.tag & bo) !== an ? G = "useLayoutEffect" : (_.tag & gu) !== an ? G = "useInsertionEffect" : G = "useEffect";
                var se = void 0;
                q === null ? se = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof q.then == "function" ? se = `

It looks like you wrote ` + G + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + G + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : se = " You returned: " + q, s("%s must not return anything besides a function, which is used for clean-up.%s", G, se);
              }
            }
          }
          _ = _.next;
        } while (_ !== E);
      }
    }
    function rie(a, l) {
      if ((l.flags & Bn) !== an)
        switch (l.tag) {
          case M: {
            var m = l.stateNode.passiveEffectDuration, g = l.memoizedProps, E = g.id, _ = g.onPostCommit, B = GB(), q = l.alternate === null ? "mount" : "update";
            WB() && (q = "nested-update"), typeof _ == "function" && _(E, q, m, B);
            var G = l.return;
            e: for (; G !== null; ) {
              switch (G.tag) {
                case y:
                  var se = G.stateNode;
                  se.passiveEffectDuration += m;
                  break e;
                case M:
                  var ue = G.stateNode;
                  ue.passiveEffectDuration += m;
                  break e;
              }
              G = G.return;
            }
            break;
          }
        }
    }
    function iie(a, l, m, g) {
      if ((m.flags & No) !== an)
        switch (m.tag) {
          case u:
          case D:
          case F: {
            if (!Jo)
              if (m.mode & kn)
                try {
                  xu(), dh(bo | go, m);
                } finally {
                  Cu(m);
                }
              else
                dh(bo | go, m);
            break;
          }
          case f: {
            var E = m.stateNode;
            if (m.flags & Bn && !Jo)
              if (l === null)
                if (m.type === m.elementType && !um && (E.props !== m.memoizedProps && s("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", En(m) || "instance"), E.state !== m.memoizedState && s("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", En(m) || "instance")), m.mode & kn)
                  try {
                    xu(), E.componentDidMount();
                  } finally {
                    Cu(m);
                  }
                else
                  E.componentDidMount();
              else {
                var _ = m.elementType === m.type ? l.memoizedProps : Tc(m.type, l.memoizedProps), B = l.memoizedState;
                if (m.type === m.elementType && !um && (E.props !== m.memoizedProps && s("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", En(m) || "instance"), E.state !== m.memoizedState && s("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", En(m) || "instance")), m.mode & kn)
                  try {
                    xu(), E.componentDidUpdate(_, B, E.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    Cu(m);
                  }
                else
                  E.componentDidUpdate(_, B, E.__reactInternalSnapshotBeforeUpdate);
              }
            var q = m.updateQueue;
            q !== null && (m.type === m.elementType && !um && (E.props !== m.memoizedProps && s("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", En(m) || "instance"), E.state !== m.memoizedState && s("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", En(m) || "instance")), vB(m, q, E));
            break;
          }
          case y: {
            var G = m.updateQueue;
            if (G !== null) {
              var se = null;
              if (m.child !== null)
                switch (m.child.tag) {
                  case w:
                    se = m.child.stateNode;
                    break;
                  case f:
                    se = m.child.stateNode;
                    break;
                }
              vB(m, G, se);
            }
            break;
          }
          case w: {
            var ue = m.stateNode;
            if (l === null && m.flags & Bn) {
              var De = m.type, Re = m.memoizedProps;
              xte(ue, De, Re);
            }
            break;
          }
          case C:
            break;
          case v:
            break;
          case M: {
            {
              var ze = m.memoizedProps, qe = ze.onCommit, Je = ze.onRender, Et = m.stateNode.effectDuration, un = GB(), Jt = l === null ? "mount" : "update";
              WB() && (Jt = "nested-update"), typeof Je == "function" && Je(m.memoizedProps.id, Jt, m.actualDuration, m.treeBaseDuration, m.actualStartTime, un);
              {
                typeof qe == "function" && qe(m.memoizedProps.id, Jt, Et, un), toe(m);
                var ir = m.return;
                e: for (; ir !== null; ) {
                  switch (ir.tag) {
                    case y:
                      var Jn = ir.stateNode;
                      Jn.effectDuration += Et;
                      break e;
                    case M:
                      var Le = ir.stateNode;
                      Le.effectDuration += Et;
                      break e;
                  }
                  ir = ir.return;
                }
              }
            }
            break;
          }
          case L: {
            fie(a, m);
            break;
          }
          case Q:
          case z:
          case Y:
          case ee:
          case ie:
          case Z:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      Jo || m.flags & da && D6(m);
    }
    function oie(a) {
      switch (a.tag) {
        case u:
        case D:
        case F: {
          if (a.mode & kn)
            try {
              xu(), R6(a, a.return);
            } finally {
              Cu(a);
            }
          else
            R6(a, a.return);
          break;
        }
        case f: {
          var l = a.stateNode;
          typeof l.componentDidMount == "function" && Jre(a, a.return, l), O6(a, a.return);
          break;
        }
        case w: {
          O6(a, a.return);
          break;
        }
      }
    }
    function aie(a, l) {
      for (var m = null, g = a; ; ) {
        if (g.tag === w) {
          if (m === null) {
            m = g;
            try {
              var E = g.stateNode;
              l ? Dte(E) : Pte(g.stateNode, g.memoizedProps);
            } catch (B) {
              Kr(a, a.return, B);
            }
          }
        } else if (g.tag === C) {
          if (m === null)
            try {
              var _ = g.stateNode;
              l ? Mte(_) : Nte(_, g.memoizedProps);
            } catch (B) {
              Kr(a, a.return, B);
            }
        } else if (!((g.tag === ee || g.tag === ie) && g.memoizedState !== null && g !== a)) {
          if (g.child !== null) {
            g.child.return = g, g = g.child;
            continue;
          }
        }
        if (g === a)
          return;
        for (; g.sibling === null; ) {
          if (g.return === null || g.return === a)
            return;
          m === g && (m = null), g = g.return;
        }
        m === g && (m = null), g.sibling.return = g.return, g = g.sibling;
      }
    }
    function D6(a) {
      var l = a.ref;
      if (l !== null) {
        var m = a.stateNode, g;
        switch (a.tag) {
          case w:
            g = m;
            break;
          default:
            g = m;
        }
        if (typeof l == "function") {
          var E;
          if (a.mode & kn)
            try {
              xu(), E = l(g);
            } finally {
              Cu(a);
            }
          else
            E = l(g);
          typeof E == "function" && s("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", En(a));
        } else
          l.hasOwnProperty("current") || s("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", En(a)), l.current = g;
      }
    }
    function sie(a) {
      var l = a.alternate;
      l !== null && (l.return = null), a.return = null;
    }
    function M6(a) {
      var l = a.alternate;
      l !== null && (a.alternate = null, M6(l));
      {
        if (a.child = null, a.deletions = null, a.sibling = null, a.tag === w) {
          var m = a.stateNode;
          m !== null && hne(m);
        }
        a.stateNode = null, a._debugOwner = null, a.return = null, a.dependencies = null, a.memoizedProps = null, a.memoizedState = null, a.pendingProps = null, a.stateNode = null, a.updateQueue = null;
      }
    }
    function lie(a) {
      for (var l = a.return; l !== null; ) {
        if (P6(l))
          return l;
        l = l.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function P6(a) {
      return a.tag === w || a.tag === y || a.tag === v;
    }
    function N6(a) {
      var l = a;
      e: for (; ; ) {
        for (; l.sibling === null; ) {
          if (l.return === null || P6(l.return))
            return null;
          l = l.return;
        }
        for (l.sibling.return = l.return, l = l.sibling; l.tag !== w && l.tag !== C && l.tag !== H; ) {
          if (l.flags & qr || l.child === null || l.tag === v)
            continue e;
          l.child.return = l, l = l.child;
        }
        if (!(l.flags & qr))
          return l.stateNode;
      }
    }
    function cie(a) {
      var l = lie(a);
      switch (l.tag) {
        case w: {
          var m = l.stateNode;
          l.flags & kr && (L3(m), l.flags &= ~kr);
          var g = N6(a);
          $_(a, g, m);
          break;
        }
        case y:
        case v: {
          var E = l.stateNode.containerInfo, _ = N6(a);
          V_(a, _, E);
          break;
        }
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function V_(a, l, m) {
      var g = a.tag, E = g === w || g === C;
      if (E) {
        var _ = a.stateNode;
        l ? _te(m, _, l) : Ate(m, _);
      } else if (g !== v) {
        var B = a.child;
        if (B !== null) {
          V_(B, l, m);
          for (var q = B.sibling; q !== null; )
            V_(q, l, m), q = q.sibling;
        }
      }
    }
    function $_(a, l, m) {
      var g = a.tag, E = g === w || g === C;
      if (E) {
        var _ = a.stateNode;
        l ? Tte(m, _, l) : kte(m, _);
      } else if (g !== v) {
        var B = a.child;
        if (B !== null) {
          $_(B, l, m);
          for (var q = B.sibling; q !== null; )
            $_(q, l, m), q = q.sibling;
        }
      }
    }
    var Zo = null, Oc = !1;
    function uie(a, l, m) {
      {
        var g = l;
        e: for (; g !== null; ) {
          switch (g.tag) {
            case w: {
              Zo = g.stateNode, Oc = !1;
              break e;
            }
            case y: {
              Zo = g.stateNode.containerInfo, Oc = !0;
              break e;
            }
            case v: {
              Zo = g.stateNode.containerInfo, Oc = !0;
              break e;
            }
          }
          g = g.return;
        }
        if (Zo === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        B6(a, l, m), Zo = null, Oc = !1;
      }
      sie(m);
    }
    function fh(a, l, m) {
      for (var g = m.child; g !== null; )
        B6(a, l, g), g = g.sibling;
    }
    function B6(a, l, m) {
      switch (ad(m), m.tag) {
        case w:
          Jo || Qv(m, l);
        case C: {
          {
            var g = Zo, E = Oc;
            Zo = null, fh(a, l, m), Zo = g, Oc = E, Zo !== null && (Oc ? Ote(Zo, m.stateNode) : Rte(Zo, m.stateNode));
          }
          return;
        }
        case H: {
          Zo !== null && (Oc ? Ite(Zo, m.stateNode) : e2(Zo, m.stateNode));
          return;
        }
        case v: {
          {
            var _ = Zo, B = Oc;
            Zo = m.stateNode.containerInfo, Oc = !0, fh(a, l, m), Zo = _, Oc = B;
          }
          return;
        }
        case u:
        case D:
        case j:
        case F: {
          if (!Jo) {
            var q = m.updateQueue;
            if (q !== null) {
              var G = q.lastEffect;
              if (G !== null) {
                var se = G.next, ue = se;
                do {
                  var De = ue, Re = De.destroy, ze = De.tag;
                  Re !== void 0 && ((ze & gu) !== Os ? YS(m, l, Re) : (ze & bo) !== Os && (nl(m), m.mode & kn ? (xu(), YS(m, l, Re), Cu(m)) : YS(m, l, Re), _f())), ue = ue.next;
                } while (ue !== se);
              }
            }
          }
          fh(a, l, m);
          return;
        }
        case f: {
          if (!Jo) {
            Qv(m, l);
            var qe = m.stateNode;
            typeof qe.componentWillUnmount == "function" && z_(m, l, qe);
          }
          fh(a, l, m);
          return;
        }
        case Y: {
          fh(a, l, m);
          return;
        }
        case ee: {
          if (
            // TODO: Remove this dead flag
            m.mode & Xt
          ) {
            var Je = Jo;
            Jo = Je || m.memoizedState !== null, fh(a, l, m), Jo = Je;
          } else
            fh(a, l, m);
          break;
        }
        default: {
          fh(a, l, m);
          return;
        }
      }
    }
    function die(a) {
      a.memoizedState;
    }
    function fie(a, l) {
      var m = l.memoizedState;
      if (m === null) {
        var g = l.alternate;
        if (g !== null) {
          var E = g.memoizedState;
          if (E !== null) {
            var _ = E.dehydrated;
            _ !== null && Qte(_);
          }
        }
      }
    }
    function L6(a) {
      var l = a.updateQueue;
      if (l !== null) {
        a.updateQueue = null;
        var m = a.stateNode;
        m === null && (m = a.stateNode = new Yre()), l.forEach(function(g) {
          var E = loe.bind(null, a, g);
          if (!m.has(g)) {
            if (m.add(g), Ha)
              if (Kv !== null && Yv !== null)
                Kw(Yv, Kv);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            g.then(E, E);
          }
        });
      }
    }
    function hie(a, l, m) {
      Kv = m, Yv = a, lr(l), j6(l, a), lr(l), Kv = null, Yv = null;
    }
    function Ic(a, l, m) {
      var g = l.deletions;
      if (g !== null)
        for (var E = 0; E < g.length; E++) {
          var _ = g[E];
          try {
            uie(a, l, _);
          } catch (G) {
            Kr(_, l, G);
          }
        }
      var B = Yu();
      if (l.subtreeFlags & pa)
        for (var q = l.child; q !== null; )
          lr(q), j6(q, a), q = q.sibling;
      lr(B);
    }
    function j6(a, l, m) {
      var g = a.alternate, E = a.flags;
      switch (a.tag) {
        case u:
        case D:
        case j:
        case F: {
          if (Ic(l, a), Eu(a), E & Bn) {
            try {
              Rc(gu | go, a, a.return), dh(gu | go, a);
            } catch (Cn) {
              Kr(a, a.return, Cn);
            }
            if (a.mode & kn) {
              try {
                xu(), Rc(bo | go, a, a.return);
              } catch (Cn) {
                Kr(a, a.return, Cn);
              }
              Cu(a);
            } else
              try {
                Rc(bo | go, a, a.return);
              } catch (Cn) {
                Kr(a, a.return, Cn);
              }
          }
          return;
        }
        case f: {
          Ic(l, a), Eu(a), E & da && g !== null && Qv(g, g.return);
          return;
        }
        case w: {
          Ic(l, a), Eu(a), E & da && g !== null && Qv(g, g.return);
          {
            if (a.flags & kr) {
              var _ = a.stateNode;
              try {
                L3(_);
              } catch (Cn) {
                Kr(a, a.return, Cn);
              }
            }
            if (E & Bn) {
              var B = a.stateNode;
              if (B != null) {
                var q = a.memoizedProps, G = g !== null ? g.memoizedProps : q, se = a.type, ue = a.updateQueue;
                if (a.updateQueue = null, ue !== null)
                  try {
                    Ete(B, ue, se, G, q, a);
                  } catch (Cn) {
                    Kr(a, a.return, Cn);
                  }
              }
            }
          }
          return;
        }
        case C: {
          if (Ic(l, a), Eu(a), E & Bn) {
            if (a.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var De = a.stateNode, Re = a.memoizedProps, ze = g !== null ? g.memoizedProps : Re;
            try {
              Ste(De, ze, Re);
            } catch (Cn) {
              Kr(a, a.return, Cn);
            }
          }
          return;
        }
        case y: {
          if (Ic(l, a), Eu(a), E & Bn && g !== null) {
            var qe = g.memoizedState;
            if (qe.isDehydrated)
              try {
                Yte(l.containerInfo);
              } catch (Cn) {
                Kr(a, a.return, Cn);
              }
          }
          return;
        }
        case v: {
          Ic(l, a), Eu(a);
          return;
        }
        case L: {
          Ic(l, a), Eu(a);
          var Je = a.child;
          if (Je.flags & ou) {
            var Et = Je.stateNode, un = Je.memoizedState, Jt = un !== null;
            if (Et.isHidden = Jt, Jt) {
              var ir = Je.alternate !== null && Je.alternate.memoizedState !== null;
              ir || Gie();
            }
          }
          if (E & Bn) {
            try {
              die(a);
            } catch (Cn) {
              Kr(a, a.return, Cn);
            }
            L6(a);
          }
          return;
        }
        case ee: {
          var Jn = g !== null && g.memoizedState !== null;
          if (
            // TODO: Remove this dead flag
            a.mode & Xt
          ) {
            var Le = Jo;
            Jo = Le || Jn, Ic(l, a), Jo = Le;
          } else
            Ic(l, a);
          if (Eu(a), E & ou) {
            var Ze = a.stateNode, je = a.memoizedState, dt = je !== null, Dt = a;
            if (Ze.isHidden = dt, dt && !Jn && (Dt.mode & Xt) !== Gt) {
              Ft = Dt;
              for (var At = Dt.child; At !== null; )
                Ft = At, mie(At), At = At.sibling;
            }
            aie(Dt, dt);
          }
          return;
        }
        case Q: {
          Ic(l, a), Eu(a), E & Bn && L6(a);
          return;
        }
        case Y:
          return;
        default: {
          Ic(l, a), Eu(a);
          return;
        }
      }
    }
    function Eu(a) {
      var l = a.flags;
      if (l & qr) {
        try {
          cie(a);
        } catch (m) {
          Kr(a, a.return, m);
        }
        a.flags &= ~qr;
      }
      l & vs && (a.flags &= ~vs);
    }
    function pie(a, l, m) {
      Kv = m, Yv = l, Ft = a, F6(a, l, m), Kv = null, Yv = null;
    }
    function F6(a, l, m) {
      for (var g = (a.mode & Xt) !== Gt; Ft !== null; ) {
        var E = Ft, _ = E.child;
        if (E.tag === ee && g) {
          var B = E.memoizedState !== null, q = B || KS;
          if (q) {
            H_(a, l, m);
            continue;
          } else {
            var G = E.alternate, se = G !== null && G.memoizedState !== null, ue = se || Jo, De = KS, Re = Jo;
            KS = q, Jo = ue, Jo && !Re && (Ft = E, yie(E));
            for (var ze = _; ze !== null; )
              Ft = ze, F6(
                ze,
                // New root; bubble back up to here and stop.
                l,
                m
              ), ze = ze.sibling;
            Ft = E, KS = De, Jo = Re, H_(a, l, m);
            continue;
          }
        }
        (E.subtreeFlags & No) !== an && _ !== null ? (_.return = E, Ft = _) : H_(a, l, m);
      }
    }
    function H_(a, l, m) {
      for (; Ft !== null; ) {
        var g = Ft;
        if ((g.flags & No) !== an) {
          var E = g.alternate;
          lr(g);
          try {
            iie(l, E, g, m);
          } catch (B) {
            Kr(g, g.return, B);
          }
          Hr();
        }
        if (g === a) {
          Ft = null;
          return;
        }
        var _ = g.sibling;
        if (_ !== null) {
          _.return = g.return, Ft = _;
          return;
        }
        Ft = g.return;
      }
    }
    function mie(a) {
      for (; Ft !== null; ) {
        var l = Ft, m = l.child;
        switch (l.tag) {
          case u:
          case D:
          case j:
          case F: {
            if (l.mode & kn)
              try {
                xu(), Rc(bo, l, l.return);
              } finally {
                Cu(l);
              }
            else
              Rc(bo, l, l.return);
            break;
          }
          case f: {
            Qv(l, l.return);
            var g = l.stateNode;
            typeof g.componentWillUnmount == "function" && z_(l, l.return, g);
            break;
          }
          case w: {
            Qv(l, l.return);
            break;
          }
          case ee: {
            var E = l.memoizedState !== null;
            if (E) {
              U6(a);
              continue;
            }
            break;
          }
        }
        m !== null ? (m.return = l, Ft = m) : U6(a);
      }
    }
    function U6(a) {
      for (; Ft !== null; ) {
        var l = Ft;
        if (l === a) {
          Ft = null;
          return;
        }
        var m = l.sibling;
        if (m !== null) {
          m.return = l.return, Ft = m;
          return;
        }
        Ft = l.return;
      }
    }
    function yie(a) {
      for (; Ft !== null; ) {
        var l = Ft, m = l.child;
        if (l.tag === ee) {
          var g = l.memoizedState !== null;
          if (g) {
            z6(a);
            continue;
          }
        }
        m !== null ? (m.return = l, Ft = m) : z6(a);
      }
    }
    function z6(a) {
      for (; Ft !== null; ) {
        var l = Ft;
        lr(l);
        try {
          oie(l);
        } catch (g) {
          Kr(l, l.return, g);
        }
        if (Hr(), l === a) {
          Ft = null;
          return;
        }
        var m = l.sibling;
        if (m !== null) {
          m.return = l.return, Ft = m;
          return;
        }
        Ft = l.return;
      }
    }
    function vie(a, l, m, g) {
      Ft = l, gie(l, a, m, g);
    }
    function gie(a, l, m, g) {
      for (; Ft !== null; ) {
        var E = Ft, _ = E.child;
        (E.subtreeFlags & gs) !== an && _ !== null ? (_.return = E, Ft = _) : bie(a, l, m, g);
      }
    }
    function bie(a, l, m, g) {
      for (; Ft !== null; ) {
        var E = Ft;
        if ((E.flags & Jr) !== an) {
          lr(E);
          try {
            wie(l, E, m, g);
          } catch (B) {
            Kr(E, E.return, B);
          }
          Hr();
        }
        if (E === a) {
          Ft = null;
          return;
        }
        var _ = E.sibling;
        if (_ !== null) {
          _.return = E.return, Ft = _;
          return;
        }
        Ft = E.return;
      }
    }
    function wie(a, l, m, g) {
      switch (l.tag) {
        case u:
        case D:
        case F: {
          if (l.mode & kn) {
            c_();
            try {
              dh(Qo | go, l);
            } finally {
              l_(l);
            }
          } else
            dh(Qo | go, l);
          break;
        }
      }
    }
    function Cie(a) {
      Ft = a, xie();
    }
    function xie() {
      for (; Ft !== null; ) {
        var a = Ft, l = a.child;
        if ((Ft.flags & wr) !== an) {
          var m = a.deletions;
          if (m !== null) {
            for (var g = 0; g < m.length; g++) {
              var E = m[g];
              Ft = E, kie(E, a);
            }
            {
              var _ = a.alternate;
              if (_ !== null) {
                var B = _.child;
                if (B !== null) {
                  _.child = null;
                  do {
                    var q = B.sibling;
                    B.sibling = null, B = q;
                  } while (B !== null);
                }
              }
            }
            Ft = a;
          }
        }
        (a.subtreeFlags & gs) !== an && l !== null ? (l.return = a, Ft = l) : Eie();
      }
    }
    function Eie() {
      for (; Ft !== null; ) {
        var a = Ft;
        (a.flags & Jr) !== an && (lr(a), Sie(a), Hr());
        var l = a.sibling;
        if (l !== null) {
          l.return = a.return, Ft = l;
          return;
        }
        Ft = a.return;
      }
    }
    function Sie(a) {
      switch (a.tag) {
        case u:
        case D:
        case F: {
          a.mode & kn ? (c_(), Rc(Qo | go, a, a.return), l_(a)) : Rc(Qo | go, a, a.return);
          break;
        }
      }
    }
    function kie(a, l) {
      for (; Ft !== null; ) {
        var m = Ft;
        lr(m), Tie(m, l), Hr();
        var g = m.child;
        g !== null ? (g.return = m, Ft = g) : Aie(a);
      }
    }
    function Aie(a) {
      for (; Ft !== null; ) {
        var l = Ft, m = l.sibling, g = l.return;
        if (M6(l), l === a) {
          Ft = null;
          return;
        }
        if (m !== null) {
          m.return = g, Ft = m;
          return;
        }
        Ft = g;
      }
    }
    function Tie(a, l) {
      switch (a.tag) {
        case u:
        case D:
        case F: {
          a.mode & kn ? (c_(), Rc(Qo, a, l), l_(a)) : Rc(Qo, a, l);
          break;
        }
      }
    }
    function _ie(a) {
      switch (a.tag) {
        case u:
        case D:
        case F: {
          try {
            dh(bo | go, a);
          } catch (m) {
            Kr(a, a.return, m);
          }
          break;
        }
        case f: {
          var l = a.stateNode;
          try {
            l.componentDidMount();
          } catch (m) {
            Kr(a, a.return, m);
          }
          break;
        }
      }
    }
    function Rie(a) {
      switch (a.tag) {
        case u:
        case D:
        case F: {
          try {
            dh(Qo | go, a);
          } catch (l) {
            Kr(a, a.return, l);
          }
          break;
        }
      }
    }
    function Oie(a) {
      switch (a.tag) {
        case u:
        case D:
        case F: {
          try {
            Rc(bo | go, a, a.return);
          } catch (m) {
            Kr(a, a.return, m);
          }
          break;
        }
        case f: {
          var l = a.stateNode;
          typeof l.componentWillUnmount == "function" && z_(a, a.return, l);
          break;
        }
      }
    }
    function Iie(a) {
      switch (a.tag) {
        case u:
        case D:
        case F:
          try {
            Rc(Qo | go, a, a.return);
          } catch (l) {
            Kr(a, a.return, l);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var Lw = Symbol.for;
      Lw("selector.component"), Lw("selector.has_pseudo_class"), Lw("selector.role"), Lw("selector.test_id"), Lw("selector.text");
    }
    var Die = [];
    function Mie() {
      Die.forEach(function(a) {
        return a();
      });
    }
    var Pie = n.ReactCurrentActQueue;
    function Nie(a) {
      {
        var l = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), m = typeof jest < "u";
        return m && l !== !1;
      }
    }
    function V6() {
      {
        var a = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !a && Pie.current !== null && s("The current testing environment is not configured to support act(...)"), a;
      }
    }
    var Bie = Math.ceil, q_ = n.ReactCurrentDispatcher, W_ = n.ReactCurrentOwner, ea = n.ReactCurrentBatchConfig, Dc = n.ReactCurrentActQueue, xo = (
      /*             */
      0
    ), $6 = (
      /*               */
      1
    ), ta = (
      /*                */
      2
    ), Ol = (
      /*                */
      4
    ), _d = 0, jw = 1, dm = 2, QS = 3, Fw = 4, H6 = 5, G_ = 6, rr = xo, Ka = null, Ai = null, Eo = nt, Su = nt, K_ = nh(nt), So = _d, Uw = null, XS = nt, zw = nt, JS = nt, Vw = null, Is = null, Y_ = 0, q6 = 500, W6 = 1 / 0, Lie = 500, Rd = null;
    function $w() {
      W6 = oi() + Lie;
    }
    function G6() {
      return W6;
    }
    var ZS = !1, Q_ = null, Xv = null, fm = !1, hh = null, Hw = nt, X_ = [], J_ = null, jie = 50, qw = 0, Z_ = null, eR = !1, ek = !1, Fie = 50, Jv = 0, tk = null, Ww = Vr, nk = nt, K6 = !1;
    function rk() {
      return Ka;
    }
    function Ya() {
      return (rr & (ta | Ol)) !== xo ? oi() : (Ww !== Vr || (Ww = oi()), Ww);
    }
    function ph(a) {
      var l = a.mode;
      if ((l & Xt) === Gt)
        return nn;
      if ((rr & ta) !== xo && Eo !== nt)
        return Lf(Eo);
      var m = Pne() !== Mne;
      if (m) {
        if (ea.transition !== null) {
          var g = ea.transition;
          g._updatedFibers || (g._updatedFibers = /* @__PURE__ */ new Set()), g._updatedFibers.add(a);
        }
        return nk === Ii && (nk = mE()), nk;
      }
      var E = Es();
      if (E !== Ii)
        return E;
      var _ = gte();
      return _;
    }
    function Uie(a) {
      var l = a.mode;
      return (l & Xt) === Gt ? nn : ga();
    }
    function ko(a, l, m, g) {
      uoe(), K6 && s("useInsertionEffect must not schedule updates."), eR && (ek = !0), pd(a, m, g), (rr & ta) !== nt && a === Ka ? hoe(l) : (Ha && ov(a, l, m), poe(l), a === Ka && ((rr & ta) === xo && (zw = Mn(zw, m)), So === Fw && mh(a, Eo)), Ds(a, g), m === nn && rr === xo && (l.mode & Xt) === Gt && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !Dc.isBatchingLegacy && ($w(), K3()));
    }
    function zie(a, l, m) {
      var g = a.current;
      g.lanes = l, pd(a, l, m), Ds(a, m);
    }
    function Vie(a) {
      return (
        // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
        // decided not to enable it.
        (rr & ta) !== xo
      );
    }
    function Ds(a, l) {
      var m = a.callbackNode;
      uE(a, l);
      var g = fd(a, a === Ka ? Eo : nt);
      if (g === nt) {
        m !== null && uL(m), a.callbackNode = null, a.callbackPriority = Ii;
        return;
      }
      var E = Ei(g), _ = a.callbackPriority;
      if (_ === E && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(Dc.current !== null && m !== sR)) {
        m == null && _ !== nn && s("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      m != null && uL(m);
      var B;
      if (E === nn)
        a.tag === rh ? (Dc.isBatchingLegacy !== null && (Dc.didScheduleLegacyUpdate = !0), yne(X6.bind(null, a))) : G3(X6.bind(null, a)), Dc.current !== null ? Dc.current.push(ih) : wte(function() {
          (rr & (ta | Ol)) === xo && ih();
        }), B = null;
      else {
        var q;
        switch (vo(g)) {
          case Si:
            q = Dy;
            break;
          case gc:
            q = od;
            break;
          case Cl:
            q = wl;
            break;
          case jf:
            q = My;
            break;
          default:
            q = wl;
            break;
        }
        B = lR(q, Y6.bind(null, a));
      }
      a.callbackPriority = E, a.callbackNode = B;
    }
    function Y6(a, l) {
      if (are(), Ww = Vr, nk = nt, (rr & (ta | Ol)) !== xo)
        throw new Error("Should not already be working.");
      var m = a.callbackNode, g = Id();
      if (g && a.callbackNode !== m)
        return null;
      var E = fd(a, a === Ka ? Eo : nt);
      if (E === nt)
        return null;
      var _ = !jp(a, E) && !pE(a, E) && !l, B = _ ? Jie(a, E) : ok(a, E);
      if (B !== _d) {
        if (B === dm) {
          var q = uu(a);
          q !== nt && (E = q, B = tR(a, q));
        }
        if (B === jw) {
          var G = Uw;
          throw hm(a, nt), mh(a, E), Ds(a, oi()), G;
        }
        if (B === G_)
          mh(a, E);
        else {
          var se = !jp(a, E), ue = a.current.alternate;
          if (se && !Hie(ue)) {
            if (B = ok(a, E), B === dm) {
              var De = uu(a);
              De !== nt && (E = De, B = tR(a, De));
            }
            if (B === jw) {
              var Re = Uw;
              throw hm(a, nt), mh(a, E), Ds(a, oi()), Re;
            }
          }
          a.finishedWork = ue, a.finishedLanes = E, $ie(a, B, E);
        }
      }
      return Ds(a, oi()), a.callbackNode === m ? Y6.bind(null, a) : null;
    }
    function tR(a, l) {
      var m = Vw;
      if (av(a)) {
        var g = hm(a, l);
        g.flags |= fi, cne(a.containerInfo);
      }
      var E = ok(a, l);
      if (E !== dm) {
        var _ = Is;
        Is = m, _ !== null && Q6(_);
      }
      return E;
    }
    function Q6(a) {
      Is === null ? Is = a : Is.push.apply(Is, a);
    }
    function $ie(a, l, m) {
      switch (l) {
        case _d:
        case jw:
          throw new Error("Root did not complete. This is a bug in React.");
        case dm: {
          pm(a, Is, Rd);
          break;
        }
        case QS: {
          if (mh(a, m), dE(m) && // do not delay if we're inside an act() scope
          !dL()) {
            var g = Y_ + q6 - oi();
            if (g > 10) {
              var E = fd(a, nt);
              if (E !== nt)
                break;
              var _ = a.suspendedLanes;
              if (!hd(_, m)) {
                Ya(), rv(a, _);
                break;
              }
              a.timeoutHandle = JT(pm.bind(null, a, Is, Rd), g);
              break;
            }
          }
          pm(a, Is, Rd);
          break;
        }
        case Fw: {
          if (mh(a, m), hE(m))
            break;
          if (!dL()) {
            var B = lE(a, m), q = B, G = oi() - q, se = coe(G) - G;
            if (se > 10) {
              a.timeoutHandle = JT(pm.bind(null, a, Is, Rd), se);
              break;
            }
          }
          pm(a, Is, Rd);
          break;
        }
        case H6: {
          pm(a, Is, Rd);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function Hie(a) {
      for (var l = a; ; ) {
        if (l.flags & _p) {
          var m = l.updateQueue;
          if (m !== null) {
            var g = m.stores;
            if (g !== null)
              for (var E = 0; E < g.length; E++) {
                var _ = g[E], B = _.getSnapshot, q = _.value;
                try {
                  if (!jt(B(), q))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var G = l.child;
        if (l.subtreeFlags & _p && G !== null) {
          G.return = l, l = G;
          continue;
        }
        if (l === a)
          return !0;
        for (; l.sibling === null; ) {
          if (l.return === null || l.return === a)
            return !0;
          l = l.return;
        }
        l.sibling.return = l.return, l = l.sibling;
      }
      return !0;
    }
    function mh(a, l) {
      l = Fp(l, JS), l = Fp(l, zw), vE(a, l);
    }
    function X6(a) {
      if (sre(), (rr & (ta | Ol)) !== xo)
        throw new Error("Should not already be working.");
      Id();
      var l = fd(a, nt);
      if (!ba(l, nn))
        return Ds(a, oi()), null;
      var m = ok(a, l);
      if (a.tag !== rh && m === dm) {
        var g = uu(a);
        g !== nt && (l = g, m = tR(a, g));
      }
      if (m === jw) {
        var E = Uw;
        throw hm(a, nt), mh(a, l), Ds(a, oi()), E;
      }
      if (m === G_)
        throw new Error("Root did not complete. This is a bug in React.");
      var _ = a.current.alternate;
      return a.finishedWork = _, a.finishedLanes = l, pm(a, Is, Rd), Ds(a, oi()), null;
    }
    function qie(a, l) {
      l !== nt && (B0(a, Mn(l, nn)), Ds(a, oi()), (rr & (ta | Ol)) === xo && ($w(), ih()));
    }
    function nR(a, l) {
      var m = rr;
      rr |= $6;
      try {
        return a(l);
      } finally {
        rr = m, rr === xo && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !Dc.isBatchingLegacy && ($w(), K3());
      }
    }
    function Wie(a, l, m, g, E) {
      var _ = Es(), B = ea.transition;
      try {
        return ea.transition = null, hi(Si), a(l, m, g, E);
      } finally {
        hi(_), ea.transition = B, rr === xo && $w();
      }
    }
    function Od(a) {
      hh !== null && hh.tag === rh && (rr & (ta | Ol)) === xo && Id();
      var l = rr;
      rr |= $6;
      var m = ea.transition, g = Es();
      try {
        return ea.transition = null, hi(Si), a ? a() : void 0;
      } finally {
        hi(g), ea.transition = m, rr = l, (rr & (ta | Ol)) === xo && ih();
      }
    }
    function J6() {
      return (rr & (ta | Ol)) !== xo;
    }
    function ik(a, l) {
      xa(K_, Su, a), Su = Mn(Su, l);
    }
    function rR(a) {
      Su = K_.current, Ca(K_, a);
    }
    function hm(a, l) {
      a.finishedWork = null, a.finishedLanes = nt;
      var m = a.timeoutHandle;
      if (m !== ZT && (a.timeoutHandle = ZT, bte(m)), Ai !== null)
        for (var g = Ai.return; g !== null; ) {
          var E = g.alternate;
          T6(E, g), g = g.return;
        }
      Ka = a;
      var _ = mm(a.current, null);
      return Ai = _, Eo = Su = l, So = _d, Uw = null, XS = nt, zw = nt, JS = nt, Vw = null, Is = null, zne(), Sc.discardPendingWarnings(), _;
    }
    function Z6(a, l) {
      do {
        var m = Ai;
        try {
          if (pS(), EB(), Hr(), W_.current = null, m === null || m.return === null) {
            So = jw, Uw = l, Ai = null;
            return;
          }
          if (Fe && m.mode & kn && $S(m, !0), Me)
            if (ya(), l !== null && typeof l == "object" && typeof l.then == "function") {
              var g = l;
              sd(m, g, Eo);
            } else
              Ip(m, l, Eo);
          yre(a, m.return, m, l, Eo), rL(m);
        } catch (E) {
          l = E, Ai === m && m !== null ? (m = m.return, Ai = m) : m = Ai;
          continue;
        }
        return;
      } while (!0);
    }
    function eL() {
      var a = q_.current;
      return q_.current = jS, a === null ? jS : a;
    }
    function tL(a) {
      q_.current = a;
    }
    function Gie() {
      Y_ = oi();
    }
    function Gw(a) {
      XS = Mn(a, XS);
    }
    function Kie() {
      So === _d && (So = QS);
    }
    function iR() {
      (So === _d || So === QS || So === dm) && (So = Fw), Ka !== null && (Lp(XS) || Lp(zw)) && mh(Ka, Eo);
    }
    function Yie(a) {
      So !== Fw && (So = dm), Vw === null ? Vw = [a] : Vw.push(a);
    }
    function Qie() {
      return So === _d;
    }
    function ok(a, l) {
      var m = rr;
      rr |= ta;
      var g = eL();
      if (Ka !== a || Eo !== l) {
        if (Ha) {
          var E = a.memoizedUpdaters;
          E.size > 0 && (Kw(a, Eo), E.clear()), L0(a, l);
        }
        Rd = zp(), hm(a, l);
      }
      Zr(l);
      do
        try {
          Xie();
          break;
        } catch (_) {
          Z6(a, _);
        }
      while (!0);
      if (pS(), rr = m, tL(g), Ai !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return jy(), Ka = null, Eo = nt, So;
    }
    function Xie() {
      for (; Ai !== null; )
        nL(Ai);
    }
    function Jie(a, l) {
      var m = rr;
      rr |= ta;
      var g = eL();
      if (Ka !== a || Eo !== l) {
        if (Ha) {
          var E = a.memoizedUpdaters;
          E.size > 0 && (Kw(a, Eo), E.clear()), L0(a, l);
        }
        Rd = zp(), $w(), hm(a, l);
      }
      Zr(l);
      do
        try {
          Zie();
          break;
        } catch (_) {
          Z6(a, _);
        }
      while (!0);
      return pS(), tL(g), rr = m, Ai !== null ? (Ly(), _d) : (jy(), Ka = null, Eo = nt, So);
    }
    function Zie() {
      for (; Ai !== null && !Iy(); )
        nL(Ai);
    }
    function nL(a) {
      var l = a.alternate;
      lr(a);
      var m;
      (a.mode & kn) !== Gt ? (s_(a), m = oR(l, a, Su), $S(a, !0)) : m = oR(l, a, Su), Hr(), a.memoizedProps = a.pendingProps, m === null ? rL(a) : Ai = m, W_.current = null;
    }
    function rL(a) {
      var l = a;
      do {
        var m = l.alternate, g = l.return;
        if ((l.flags & za) === an) {
          lr(l);
          var E = void 0;
          if ((l.mode & kn) === Gt ? E = A6(m, l, Su) : (s_(l), E = A6(m, l, Su), $S(l, !1)), Hr(), E !== null) {
            Ai = E;
            return;
          }
        } else {
          var _ = Kre(m, l);
          if (_ !== null) {
            _.flags &= Xx, Ai = _;
            return;
          }
          if ((l.mode & kn) !== Gt) {
            $S(l, !1);
            for (var B = l.actualDuration, q = l.child; q !== null; )
              B += q.actualDuration, q = q.sibling;
            l.actualDuration = B;
          }
          if (g !== null)
            g.flags |= za, g.subtreeFlags = an, g.deletions = null;
          else {
            So = G_, Ai = null;
            return;
          }
        }
        var G = l.sibling;
        if (G !== null) {
          Ai = G;
          return;
        }
        l = g, Ai = l;
      } while (l !== null);
      So === _d && (So = H6);
    }
    function pm(a, l, m) {
      var g = Es(), E = ea.transition;
      try {
        ea.transition = null, hi(Si), eoe(a, l, m, g);
      } finally {
        ea.transition = E, hi(g);
      }
      return null;
    }
    function eoe(a, l, m, g) {
      do
        Id();
      while (hh !== null);
      if (doe(), (rr & (ta | Ol)) !== xo)
        throw new Error("Should not already be working.");
      var E = a.finishedWork, _ = a.finishedLanes;
      if (su(_), E === null)
        return Py(), null;
      if (_ === nt && s("root.finishedLanes should not be empty during a commit. This is a bug in React."), a.finishedWork = null, a.finishedLanes = nt, E === a.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      a.callbackNode = null, a.callbackPriority = Ii;
      var B = Mn(E.lanes, E.childLanes);
      iv(a, B), a === Ka && (Ka = null, Ai = null, Eo = nt), ((E.subtreeFlags & gs) !== an || (E.flags & gs) !== an) && (fm || (fm = !0, J_ = m, lR(wl, function() {
        return Id(), null;
      })));
      var q = (E.subtreeFlags & (Sf | pa | No | gs)) !== an, G = (E.flags & (Sf | pa | No | gs)) !== an;
      if (q || G) {
        var se = ea.transition;
        ea.transition = null;
        var ue = Es();
        hi(Si);
        var De = rr;
        rr |= Ol, W_.current = null, Zre(a, E), KB(), hie(a, E, _), fte(a.containerInfo), a.current = E, _0(_), pie(E, a, _), Rf(), eE(), rr = De, hi(ue), ea.transition = se;
      } else
        a.current = E, KB();
      var Re = fm;
      if (fm ? (fm = !1, hh = a, Hw = _) : (Jv = 0, tk = null), B = a.pendingLanes, B === nt && (Xv = null), Re || sL(a.current, !1), Af(E.stateNode, g), Ha && a.memoizedUpdaters.clear(), Mie(), Ds(a, oi()), l !== null)
        for (var ze = a.onRecoverableError, qe = 0; qe < l.length; qe++) {
          var Je = l[qe], Et = Je.stack, un = Je.digest;
          ze(Je.value, {
            componentStack: Et,
            digest: un
          });
        }
      if (ZS) {
        ZS = !1;
        var Jt = Q_;
        throw Q_ = null, Jt;
      }
      return ba(Hw, nn) && a.tag !== rh && Id(), B = a.pendingLanes, ba(B, nn) ? (ore(), a === Z_ ? qw++ : (qw = 0, Z_ = a)) : qw = 0, ih(), Py(), null;
    }
    function Id() {
      if (hh !== null) {
        var a = vo(Hw), l = ET(Cl, a), m = ea.transition, g = Es();
        try {
          return ea.transition = null, hi(l), noe();
        } finally {
          hi(g), ea.transition = m;
        }
      }
      return !1;
    }
    function toe(a) {
      X_.push(a), fm || (fm = !0, lR(wl, function() {
        return Id(), null;
      }));
    }
    function noe() {
      if (hh === null)
        return !1;
      var a = J_;
      J_ = null;
      var l = hh, m = Hw;
      if (hh = null, Hw = nt, (rr & (ta | Ol)) !== xo)
        throw new Error("Cannot flush passive effects while already rendering.");
      eR = !0, ek = !1, aE(m);
      var g = rr;
      rr |= Ol, Cie(l.current), vie(l, l.current, m, a);
      {
        var E = X_;
        X_ = [];
        for (var _ = 0; _ < E.length; _++) {
          var B = E[_];
          rie(l, B);
        }
      }
      R0(), sL(l.current, !0), rr = g, ih(), ek ? l === tk ? Jv++ : (Jv = 0, tk = l) : Jv = 0, eR = !1, ek = !1, Cs(l);
      {
        var q = l.current.stateNode;
        q.effectDuration = 0, q.passiveEffectDuration = 0;
      }
      return !0;
    }
    function iL(a) {
      return Xv !== null && Xv.has(a);
    }
    function roe(a) {
      Xv === null ? Xv = /* @__PURE__ */ new Set([a]) : Xv.add(a);
    }
    function ioe(a) {
      ZS || (ZS = !0, Q_ = a);
    }
    var ooe = ioe;
    function oL(a, l, m) {
      var g = cm(m, l), E = n6(a, g, nn), _ = ah(a, E, nn), B = Ya();
      _ !== null && (pd(_, nn, B), Ds(_, B));
    }
    function Kr(a, l, m) {
      if (Qre(m), Yw(!1), a.tag === y) {
        oL(a, a, m);
        return;
      }
      var g = null;
      for (g = l; g !== null; ) {
        if (g.tag === y) {
          oL(g, a, m);
          return;
        } else if (g.tag === f) {
          var E = g.type, _ = g.stateNode;
          if (typeof E.getDerivedStateFromError == "function" || typeof _.componentDidCatch == "function" && !iL(_)) {
            var B = cm(m, a), q = k_(g, B, nn), G = ah(g, q, nn), se = Ya();
            G !== null && (pd(G, nn, se), Ds(G, se));
            return;
          }
        }
        g = g.return;
      }
      s(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, m);
    }
    function aoe(a, l, m) {
      var g = a.pingCache;
      g !== null && g.delete(l);
      var E = Ya();
      rv(a, m), moe(a), Ka === a && hd(Eo, m) && (So === Fw || So === QS && dE(Eo) && oi() - Y_ < q6 ? hm(a, nt) : JS = Mn(JS, m)), Ds(a, E);
    }
    function aL(a, l) {
      l === Ii && (l = Uie(a));
      var m = Ya(), g = Rs(a, l);
      g !== null && (pd(g, l, m), Ds(g, m));
    }
    function soe(a) {
      var l = a.memoizedState, m = Ii;
      l !== null && (m = l.retryLane), aL(a, m);
    }
    function loe(a, l) {
      var m = Ii, g;
      switch (a.tag) {
        case L:
          g = a.stateNode;
          var E = a.memoizedState;
          E !== null && (m = E.retryLane);
          break;
        case Q:
          g = a.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      g !== null && g.delete(l), aL(a, m);
    }
    function coe(a) {
      return a < 120 ? 120 : a < 480 ? 480 : a < 1080 ? 1080 : a < 1920 ? 1920 : a < 3e3 ? 3e3 : a < 4320 ? 4320 : Bie(a / 1960) * 1960;
    }
    function uoe() {
      if (qw > jie)
        throw qw = 0, Z_ = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      Jv > Fie && (Jv = 0, tk = null, s("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function doe() {
      Sc.flushLegacyContextWarning(), Sc.flushPendingUnsafeLifecycleWarnings();
    }
    function sL(a, l) {
      lr(a), ak(a, ha, Oie), l && ak(a, id, Iie), ak(a, ha, _ie), l && ak(a, id, Rie), Hr();
    }
    function ak(a, l, m) {
      for (var g = a, E = null; g !== null; ) {
        var _ = g.subtreeFlags & l;
        g !== E && g.child !== null && _ !== an ? g = g.child : ((g.flags & l) !== an && m(g), g.sibling !== null ? g = g.sibling : g = E = g.return);
      }
    }
    var sk = null;
    function lL(a) {
      {
        if ((rr & ta) !== xo || !(a.mode & Xt))
          return;
        var l = a.tag;
        if (l !== p && l !== y && l !== f && l !== u && l !== D && l !== j && l !== F)
          return;
        var m = En(a) || "ReactComponent";
        if (sk !== null) {
          if (sk.has(m))
            return;
          sk.add(m);
        } else
          sk = /* @__PURE__ */ new Set([m]);
        var g = Br;
        try {
          lr(a), s("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          g ? lr(a) : Hr();
        }
      }
    }
    var oR;
    {
      var foe = null;
      oR = function(a, l, m) {
        var g = yL(foe, l);
        try {
          return C6(a, l, m);
        } catch (_) {
          if (Sne() || _ !== null && typeof _ == "object" && typeof _.then == "function")
            throw _;
          if (pS(), EB(), T6(a, l), yL(l, g), l.mode & kn && s_(l), rd(null, C6, null, a, l, m), gT()) {
            var E = b0();
            typeof E == "object" && E !== null && E._suppressLogging && typeof _ == "object" && _ !== null && !_._suppressLogging && (_._suppressLogging = !0);
          }
          throw _;
        }
      };
    }
    var cL = !1, aR;
    aR = /* @__PURE__ */ new Set();
    function hoe(a) {
      if (Zi && !nre())
        switch (a.tag) {
          case u:
          case D:
          case F: {
            var l = Ai && En(Ai) || "Unknown", m = l;
            if (!aR.has(m)) {
              aR.add(m);
              var g = En(a) || "Unknown";
              s("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", g, l, l);
            }
            break;
          }
          case f: {
            cL || (s("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), cL = !0);
            break;
          }
        }
    }
    function Kw(a, l) {
      if (Ha) {
        var m = a.memoizedUpdaters;
        m.forEach(function(g) {
          ov(a, g, l);
        });
      }
    }
    var sR = {};
    function lR(a, l) {
      {
        var m = Dc.current;
        return m !== null ? (m.push(l), sR) : Oy(a, l);
      }
    }
    function uL(a) {
      if (a !== sR)
        return Zx(a);
    }
    function dL() {
      return Dc.current !== null;
    }
    function poe(a) {
      {
        if (a.mode & Xt) {
          if (!V6())
            return;
        } else if (!Nie() || rr !== xo || a.tag !== u && a.tag !== D && a.tag !== F)
          return;
        if (Dc.current === null) {
          var l = Br;
          try {
            lr(a), s(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, En(a));
          } finally {
            l ? lr(a) : Hr();
          }
        }
      }
    }
    function moe(a) {
      a.tag !== rh && V6() && Dc.current === null && s(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function Yw(a) {
      K6 = a;
    }
    var Il = null, Zv = null, yoe = function(a) {
      Il = a;
    };
    function eg(a) {
      {
        if (Il === null)
          return a;
        var l = Il(a);
        return l === void 0 ? a : l.current;
      }
    }
    function cR(a) {
      return eg(a);
    }
    function uR(a) {
      {
        if (Il === null)
          return a;
        var l = Il(a);
        if (l === void 0) {
          if (a != null && typeof a.render == "function") {
            var m = eg(a.render);
            if (a.render !== m) {
              var g = {
                $$typeof: Pe,
                render: m
              };
              return a.displayName !== void 0 && (g.displayName = a.displayName), g;
            }
          }
          return a;
        }
        return l.current;
      }
    }
    function fL(a, l) {
      {
        if (Il === null)
          return !1;
        var m = a.elementType, g = l.type, E = !1, _ = typeof g == "object" && g !== null ? g.$$typeof : null;
        switch (a.tag) {
          case f: {
            typeof g == "function" && (E = !0);
            break;
          }
          case u: {
            (typeof g == "function" || _ === tt) && (E = !0);
            break;
          }
          case D: {
            (_ === Pe || _ === tt) && (E = !0);
            break;
          }
          case j:
          case F: {
            (_ === lt || _ === tt) && (E = !0);
            break;
          }
          default:
            return !1;
        }
        if (E) {
          var B = Il(m);
          if (B !== void 0 && B === Il(g))
            return !0;
        }
        return !1;
      }
    }
    function hL(a) {
      {
        if (Il === null || typeof WeakSet != "function")
          return;
        Zv === null && (Zv = /* @__PURE__ */ new WeakSet()), Zv.add(a);
      }
    }
    var voe = function(a, l) {
      {
        if (Il === null)
          return;
        var m = l.staleFamilies, g = l.updatedFamilies;
        Id(), Od(function() {
          dR(a.current, g, m);
        });
      }
    }, goe = function(a, l) {
      {
        if (a.context !== rl)
          return;
        Id(), Od(function() {
          Qw(l, a, null, null);
        });
      }
    };
    function dR(a, l, m) {
      {
        var g = a.alternate, E = a.child, _ = a.sibling, B = a.tag, q = a.type, G = null;
        switch (B) {
          case u:
          case F:
          case f:
            G = q;
            break;
          case D:
            G = q.render;
            break;
        }
        if (Il === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var se = !1, ue = !1;
        if (G !== null) {
          var De = Il(G);
          De !== void 0 && (m.has(De) ? ue = !0 : l.has(De) && (B === f ? ue = !0 : se = !0));
        }
        if (Zv !== null && (Zv.has(a) || g !== null && Zv.has(g)) && (ue = !0), ue && (a._debugNeedsRemount = !0), ue || se) {
          var Re = Rs(a, nn);
          Re !== null && ko(Re, a, nn, Vr);
        }
        E !== null && !ue && dR(E, l, m), _ !== null && dR(_, l, m);
      }
    }
    var boe = function(a, l) {
      {
        var m = /* @__PURE__ */ new Set(), g = new Set(l.map(function(E) {
          return E.current;
        }));
        return fR(a.current, g, m), m;
      }
    };
    function fR(a, l, m) {
      {
        var g = a.child, E = a.sibling, _ = a.tag, B = a.type, q = null;
        switch (_) {
          case u:
          case F:
          case f:
            q = B;
            break;
          case D:
            q = B.render;
            break;
        }
        var G = !1;
        q !== null && l.has(q) && (G = !0), G ? woe(a, m) : g !== null && fR(g, l, m), E !== null && fR(E, l, m);
      }
    }
    function woe(a, l) {
      {
        var m = Coe(a, l);
        if (m)
          return;
        for (var g = a; ; ) {
          switch (g.tag) {
            case w:
              l.add(g.stateNode);
              return;
            case v:
              l.add(g.stateNode.containerInfo);
              return;
            case y:
              l.add(g.stateNode.containerInfo);
              return;
          }
          if (g.return === null)
            throw new Error("Expected to reach root first.");
          g = g.return;
        }
      }
    }
    function Coe(a, l) {
      for (var m = a, g = !1; ; ) {
        if (m.tag === w)
          g = !0, l.add(m.stateNode);
        else if (m.child !== null) {
          m.child.return = m, m = m.child;
          continue;
        }
        if (m === a)
          return g;
        for (; m.sibling === null; ) {
          if (m.return === null || m.return === a)
            return g;
          m = m.return;
        }
        m.sibling.return = m.return, m = m.sibling;
      }
      return !1;
    }
    var hR;
    {
      hR = !1;
      try {
        var pL = Object.preventExtensions({});
      } catch {
        hR = !0;
      }
    }
    function xoe(a, l, m, g) {
      this.tag = a, this.key = m, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = l, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = g, this.flags = an, this.subtreeFlags = an, this.deletions = null, this.lanes = nt, this.childLanes = nt, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !hR && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var il = function(a, l, m, g) {
      return new xoe(a, l, m, g);
    };
    function pR(a) {
      var l = a.prototype;
      return !!(l && l.isReactComponent);
    }
    function Eoe(a) {
      return typeof a == "function" && !pR(a) && a.defaultProps === void 0;
    }
    function Soe(a) {
      if (typeof a == "function")
        return pR(a) ? f : u;
      if (a != null) {
        var l = a.$$typeof;
        if (l === Pe)
          return D;
        if (l === lt)
          return j;
      }
      return p;
    }
    function mm(a, l) {
      var m = a.alternate;
      m === null ? (m = il(a.tag, l, a.key, a.mode), m.elementType = a.elementType, m.type = a.type, m.stateNode = a.stateNode, m._debugSource = a._debugSource, m._debugOwner = a._debugOwner, m._debugHookTypes = a._debugHookTypes, m.alternate = a, a.alternate = m) : (m.pendingProps = l, m.type = a.type, m.flags = an, m.subtreeFlags = an, m.deletions = null, m.actualDuration = 0, m.actualStartTime = -1), m.flags = a.flags & mo, m.childLanes = a.childLanes, m.lanes = a.lanes, m.child = a.child, m.memoizedProps = a.memoizedProps, m.memoizedState = a.memoizedState, m.updateQueue = a.updateQueue;
      var g = a.dependencies;
      switch (m.dependencies = g === null ? null : {
        lanes: g.lanes,
        firstContext: g.firstContext
      }, m.sibling = a.sibling, m.index = a.index, m.ref = a.ref, m.selfBaseDuration = a.selfBaseDuration, m.treeBaseDuration = a.treeBaseDuration, m._debugNeedsRemount = a._debugNeedsRemount, m.tag) {
        case p:
        case u:
        case F:
          m.type = eg(a.type);
          break;
        case f:
          m.type = cR(a.type);
          break;
        case D:
          m.type = uR(a.type);
          break;
      }
      return m;
    }
    function koe(a, l) {
      a.flags &= mo | qr;
      var m = a.alternate;
      if (m === null)
        a.childLanes = nt, a.lanes = l, a.child = null, a.subtreeFlags = an, a.memoizedProps = null, a.memoizedState = null, a.updateQueue = null, a.dependencies = null, a.stateNode = null, a.selfBaseDuration = 0, a.treeBaseDuration = 0;
      else {
        a.childLanes = m.childLanes, a.lanes = m.lanes, a.child = m.child, a.subtreeFlags = an, a.deletions = null, a.memoizedProps = m.memoizedProps, a.memoizedState = m.memoizedState, a.updateQueue = m.updateQueue, a.type = m.type;
        var g = m.dependencies;
        a.dependencies = g === null ? null : {
          lanes: g.lanes,
          firstContext: g.firstContext
        }, a.selfBaseDuration = m.selfBaseDuration, a.treeBaseDuration = m.treeBaseDuration;
      }
      return a;
    }
    function Aoe(a, l, m) {
      var g;
      return a === iS ? (g = Xt, l === !0 && (g |= Kn, g |= qa)) : g = Gt, Ha && (g |= kn), il(y, null, null, g);
    }
    function mR(a, l, m, g, E, _) {
      var B = p, q = a;
      if (typeof a == "function")
        pR(a) ? (B = f, q = cR(q)) : q = eg(q);
      else if (typeof a == "string")
        B = w;
      else
        e: switch (a) {
          case we:
            return yh(m.children, E, _, l);
          case Ae:
            B = A, E |= Kn, (E & Xt) !== Gt && (E |= qa);
            break;
          case ye:
            return Toe(m, E, _, l);
          case Qe:
            return _oe(m, E, _, l);
          case Ke:
            return Roe(m, E, _, l);
          case Qt:
            return mL(m, E, _, l);
          case on:
          case ot:
          case pn:
          case sr:
          case cn:
          default: {
            if (typeof a == "object" && a !== null)
              switch (a.$$typeof) {
                case re:
                  B = I;
                  break e;
                case _e:
                  B = R;
                  break e;
                case Pe:
                  B = D, q = uR(q);
                  break e;
                case lt:
                  B = j;
                  break e;
                case tt:
                  B = O, q = null;
                  break e;
              }
            var G = "";
            {
              (a === void 0 || typeof a == "object" && a !== null && Object.keys(a).length === 0) && (G += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
              var se = g ? En(g) : null;
              se && (G += `

Check the render method of \`` + se + "`.");
            }
            throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (a == null ? a : typeof a) + "." + G));
          }
        }
      var ue = il(B, m, l, E);
      return ue.elementType = a, ue.type = q, ue.lanes = _, ue._debugOwner = g, ue;
    }
    function yR(a, l, m) {
      var g = null;
      g = a._owner;
      var E = a.type, _ = a.key, B = a.props, q = mR(E, _, B, g, l, m);
      return q._debugSource = a._source, q._debugOwner = a._owner, q;
    }
    function yh(a, l, m, g) {
      var E = il(x, a, g, l);
      return E.lanes = m, E;
    }
    function Toe(a, l, m, g) {
      typeof a.id != "string" && s('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof a.id);
      var E = il(M, a, g, l | kn);
      return E.elementType = ye, E.lanes = m, E.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, E;
    }
    function _oe(a, l, m, g) {
      var E = il(L, a, g, l);
      return E.elementType = Qe, E.lanes = m, E;
    }
    function Roe(a, l, m, g) {
      var E = il(Q, a, g, l);
      return E.elementType = Ke, E.lanes = m, E;
    }
    function mL(a, l, m, g) {
      var E = il(ee, a, g, l);
      E.elementType = Qt, E.lanes = m;
      var _ = {
        isHidden: !1
      };
      return E.stateNode = _, E;
    }
    function vR(a, l, m) {
      var g = il(C, a, null, l);
      return g.lanes = m, g;
    }
    function Ooe() {
      var a = il(w, null, null, Gt);
      return a.elementType = "DELETED", a;
    }
    function Ioe(a) {
      var l = il(H, null, null, Gt);
      return l.stateNode = a, l;
    }
    function gR(a, l, m) {
      var g = a.children !== null ? a.children : [], E = il(v, g, a.key, l);
      return E.lanes = m, E.stateNode = {
        containerInfo: a.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: a.implementation
      }, E;
    }
    function yL(a, l) {
      return a === null && (a = il(p, null, null, Gt)), a.tag = l.tag, a.key = l.key, a.elementType = l.elementType, a.type = l.type, a.stateNode = l.stateNode, a.return = l.return, a.child = l.child, a.sibling = l.sibling, a.index = l.index, a.ref = l.ref, a.pendingProps = l.pendingProps, a.memoizedProps = l.memoizedProps, a.updateQueue = l.updateQueue, a.memoizedState = l.memoizedState, a.dependencies = l.dependencies, a.mode = l.mode, a.flags = l.flags, a.subtreeFlags = l.subtreeFlags, a.deletions = l.deletions, a.lanes = l.lanes, a.childLanes = l.childLanes, a.alternate = l.alternate, a.actualDuration = l.actualDuration, a.actualStartTime = l.actualStartTime, a.selfBaseDuration = l.selfBaseDuration, a.treeBaseDuration = l.treeBaseDuration, a._debugSource = l._debugSource, a._debugOwner = l._debugOwner, a._debugNeedsRemount = l._debugNeedsRemount, a._debugHookTypes = l._debugHookTypes, a;
    }
    function Doe(a, l, m, g, E) {
      this.tag = l, this.containerInfo = a, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = ZT, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = Ii, this.eventTimes = Up(nt), this.expirationTimes = Up(Vr), this.pendingLanes = nt, this.suspendedLanes = nt, this.pingedLanes = nt, this.expiredLanes = nt, this.mutableReadLanes = nt, this.finishedLanes = nt, this.entangledLanes = nt, this.entanglements = Up(nt), this.identifierPrefix = g, this.onRecoverableError = E, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var _ = this.pendingUpdatersLaneMap = [], B = 0; B < Pp; B++)
          _.push(/* @__PURE__ */ new Set());
      }
      switch (l) {
        case iS:
          this._debugRootType = m ? "hydrateRoot()" : "createRoot()";
          break;
        case rh:
          this._debugRootType = m ? "hydrate()" : "render()";
          break;
      }
    }
    function vL(a, l, m, g, E, _, B, q, G, se) {
      var ue = new Doe(a, l, m, q, G), De = Aoe(l, _);
      ue.current = De, De.stateNode = ue;
      {
        var Re = {
          element: g,
          isDehydrated: m,
          cache: null,
          // not enabled yet
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        De.memoizedState = Re;
      }
      return I2(De), ue;
    }
    var bR = "18.3.1";
    function Moe(a, l, m) {
      var g = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return or(g), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: wi,
        key: g == null ? null : "" + g,
        children: a,
        containerInfo: l,
        implementation: m
      };
    }
    var wR, CR;
    wR = !1, CR = {};
    function gL(a) {
      if (!a)
        return rl;
      var l = ms(a), m = mne(l);
      if (l.tag === f) {
        var g = l.type;
        if (vu(g))
          return q3(l, g, m);
      }
      return m;
    }
    function Poe(a, l) {
      {
        var m = ms(a);
        if (m === void 0) {
          if (typeof a.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var g = Object.keys(a).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + g);
        }
        var E = bs(m);
        if (E === null)
          return null;
        if (E.mode & Kn) {
          var _ = En(m) || "Component";
          if (!CR[_]) {
            CR[_] = !0;
            var B = Br;
            try {
              lr(E), m.mode & Kn ? s("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", l, l, _) : s("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", l, l, _);
            } finally {
              B ? lr(B) : Hr();
            }
          }
        }
        return E.stateNode;
      }
    }
    function bL(a, l, m, g, E, _, B, q) {
      var G = !1, se = null;
      return vL(a, l, G, se, m, g, E, _, B);
    }
    function wL(a, l, m, g, E, _, B, q, G, se) {
      var ue = !0, De = vL(m, g, ue, a, E, _, B, q, G);
      De.context = gL(null);
      var Re = De.current, ze = Ya(), qe = ph(Re), Je = Ad(ze, qe);
      return Je.callback = l ?? null, ah(Re, Je, qe), zie(De, qe, ze), De;
    }
    function Qw(a, l, m, g) {
      T0(l, a);
      var E = l.current, _ = Ya(), B = ph(E);
      O0(B);
      var q = gL(m);
      l.context === null ? l.context = q : l.pendingContext = q, Zi && Br !== null && !wR && (wR = !0, s(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, En(Br) || "Unknown"));
      var G = Ad(_, B);
      G.payload = {
        element: a
      }, g = g === void 0 ? null : g, g !== null && (typeof g != "function" && s("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", g), G.callback = g);
      var se = ah(E, G, B);
      return se !== null && (ko(se, E, B, _), bS(se, E, B)), B;
    }
    function lk(a) {
      var l = a.current;
      if (!l.child)
        return null;
      switch (l.child.tag) {
        case w:
          return l.child.stateNode;
        default:
          return l.child.stateNode;
      }
    }
    function Noe(a) {
      switch (a.tag) {
        case y: {
          var l = a.stateNode;
          if (av(l)) {
            var m = M0(l);
            qie(l, m);
          }
          break;
        }
        case L: {
          Od(function() {
            var E = Rs(a, nn);
            if (E !== null) {
              var _ = Ya();
              ko(E, a, nn, _);
            }
          });
          var g = nn;
          xR(a, g);
          break;
        }
      }
    }
    function CL(a, l) {
      var m = a.memoizedState;
      m !== null && m.dehydrated !== null && (m.retryLane = yE(m.retryLane, l));
    }
    function xR(a, l) {
      CL(a, l);
      var m = a.alternate;
      m && CL(m, l);
    }
    function Boe(a) {
      if (a.tag === L) {
        var l = Bp, m = Rs(a, l);
        if (m !== null) {
          var g = Ya();
          ko(m, a, l, g);
        }
        xR(a, l);
      }
    }
    function Loe(a) {
      if (a.tag === L) {
        var l = ph(a), m = Rs(a, l);
        if (m !== null) {
          var g = Ya();
          ko(m, a, l, g);
        }
        xR(a, l);
      }
    }
    function xL(a) {
      var l = Jx(a);
      return l === null ? null : l.stateNode;
    }
    var EL = function(a) {
      return null;
    };
    function joe(a) {
      return EL(a);
    }
    var SL = function(a) {
      return !1;
    };
    function Foe(a) {
      return SL(a);
    }
    var kL = null, AL = null, TL = null, _L = null, RL = null, OL = null, IL = null, DL = null, ML = null;
    {
      var PL = function(a, l, m) {
        var g = l[m], E = Zn(a) ? a.slice() : vn({}, a);
        return m + 1 === l.length ? (Zn(E) ? E.splice(g, 1) : delete E[g], E) : (E[g] = PL(a[g], l, m + 1), E);
      }, NL = function(a, l) {
        return PL(a, l, 0);
      }, BL = function(a, l, m, g) {
        var E = l[g], _ = Zn(a) ? a.slice() : vn({}, a);
        if (g + 1 === l.length) {
          var B = m[g];
          _[B] = _[E], Zn(_) ? _.splice(E, 1) : delete _[E];
        } else
          _[E] = BL(
            // $FlowFixMe number or string is fine here
            a[E],
            l,
            m,
            g + 1
          );
        return _;
      }, LL = function(a, l, m) {
        if (l.length !== m.length) {
          o("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var g = 0; g < m.length - 1; g++)
            if (l[g] !== m[g]) {
              o("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return BL(a, l, m, 0);
      }, jL = function(a, l, m, g) {
        if (m >= l.length)
          return g;
        var E = l[m], _ = Zn(a) ? a.slice() : vn({}, a);
        return _[E] = jL(a[E], l, m + 1, g), _;
      }, FL = function(a, l, m) {
        return jL(a, l, 0, m);
      }, ER = function(a, l) {
        for (var m = a.memoizedState; m !== null && l > 0; )
          m = m.next, l--;
        return m;
      };
      kL = function(a, l, m, g) {
        var E = ER(a, l);
        if (E !== null) {
          var _ = FL(E.memoizedState, m, g);
          E.memoizedState = _, E.baseState = _, a.memoizedProps = vn({}, a.memoizedProps);
          var B = Rs(a, nn);
          B !== null && ko(B, a, nn, Vr);
        }
      }, AL = function(a, l, m) {
        var g = ER(a, l);
        if (g !== null) {
          var E = NL(g.memoizedState, m);
          g.memoizedState = E, g.baseState = E, a.memoizedProps = vn({}, a.memoizedProps);
          var _ = Rs(a, nn);
          _ !== null && ko(_, a, nn, Vr);
        }
      }, TL = function(a, l, m, g) {
        var E = ER(a, l);
        if (E !== null) {
          var _ = LL(E.memoizedState, m, g);
          E.memoizedState = _, E.baseState = _, a.memoizedProps = vn({}, a.memoizedProps);
          var B = Rs(a, nn);
          B !== null && ko(B, a, nn, Vr);
        }
      }, _L = function(a, l, m) {
        a.pendingProps = FL(a.memoizedProps, l, m), a.alternate && (a.alternate.pendingProps = a.pendingProps);
        var g = Rs(a, nn);
        g !== null && ko(g, a, nn, Vr);
      }, RL = function(a, l) {
        a.pendingProps = NL(a.memoizedProps, l), a.alternate && (a.alternate.pendingProps = a.pendingProps);
        var m = Rs(a, nn);
        m !== null && ko(m, a, nn, Vr);
      }, OL = function(a, l, m) {
        a.pendingProps = LL(a.memoizedProps, l, m), a.alternate && (a.alternate.pendingProps = a.pendingProps);
        var g = Rs(a, nn);
        g !== null && ko(g, a, nn, Vr);
      }, IL = function(a) {
        var l = Rs(a, nn);
        l !== null && ko(l, a, nn, Vr);
      }, DL = function(a) {
        EL = a;
      }, ML = function(a) {
        SL = a;
      };
    }
    function Uoe(a) {
      var l = bs(a);
      return l === null ? null : l.stateNode;
    }
    function zoe(a) {
      return null;
    }
    function Voe() {
      return Br;
    }
    function $oe(a) {
      var l = a.findFiberByHostInstance, m = n.ReactCurrentDispatcher;
      return A0({
        bundleType: a.bundleType,
        version: a.version,
        rendererPackageName: a.rendererPackageName,
        rendererConfig: a.rendererConfig,
        overrideHookState: kL,
        overrideHookStateDeletePath: AL,
        overrideHookStateRenamePath: TL,
        overrideProps: _L,
        overridePropsDeletePath: RL,
        overridePropsRenamePath: OL,
        setErrorHandler: DL,
        setSuspenseHandler: ML,
        scheduleUpdate: IL,
        currentDispatcherRef: m,
        findHostInstanceByFiber: Uoe,
        findFiberByHostInstance: l || zoe,
        // React Refresh
        findHostInstancesForRefresh: boe,
        scheduleRefresh: voe,
        scheduleRoot: goe,
        setRefreshHandler: yoe,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: Voe,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: bR
      });
    }
    var UL = typeof reportError == "function" ? (
      // In modern browsers, reportError will dispatch an error event,
      // emulating an uncaught JavaScript error.
      reportError
    ) : function(a) {
    };
    function SR(a) {
      this._internalRoot = a;
    }
    ck.prototype.render = SR.prototype.render = function(a) {
      var l = this._internalRoot;
      if (l === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? s("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : uk(arguments[1]) ? s("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && s("You passed a second argument to root.render(...) but it only accepts one argument.");
        var m = l.containerInfo;
        if (m.nodeType !== Ri) {
          var g = xL(l.current);
          g && g.parentNode !== m && s("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      Qw(a, l, null, null);
    }, ck.prototype.unmount = SR.prototype.unmount = function() {
      typeof arguments[0] == "function" && s("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var a = this._internalRoot;
      if (a !== null) {
        this._internalRoot = null;
        var l = a.containerInfo;
        J6() && s("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), Od(function() {
          Qw(null, a, null, null);
        }), U3(l);
      }
    };
    function Hoe(a, l) {
      if (!uk(a))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      zL(a);
      var m = !1, g = !1, E = "", _ = UL;
      l != null && (l.hydrate ? o("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof l == "object" && l !== null && l.$$typeof === ho && s(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), l.unstable_strictMode === !0 && (m = !0), l.identifierPrefix !== void 0 && (E = l.identifierPrefix), l.onRecoverableError !== void 0 && (_ = l.onRecoverableError), l.transitionCallbacks !== void 0 && l.transitionCallbacks);
      var B = bL(a, iS, null, m, g, E, _);
      XE(B.current, a);
      var q = a.nodeType === Ri ? a.parentNode : a;
      return nw(q), new SR(B);
    }
    function ck(a) {
      this._internalRoot = a;
    }
    function qoe(a) {
      a && AT(a);
    }
    ck.prototype.unstable_scheduleHydration = qoe;
    function Woe(a, l, m) {
      if (!uk(a))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      zL(a), l === void 0 && s("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var g = m ?? null, E = m != null && m.hydratedSources || null, _ = !1, B = !1, q = "", G = UL;
      m != null && (m.unstable_strictMode === !0 && (_ = !0), m.identifierPrefix !== void 0 && (q = m.identifierPrefix), m.onRecoverableError !== void 0 && (G = m.onRecoverableError));
      var se = wL(l, null, a, iS, g, _, B, q, G);
      if (XE(se.current, a), nw(a), E)
        for (var ue = 0; ue < E.length; ue++) {
          var De = E[ue];
          Qne(se, De);
        }
      return new ck(se);
    }
    function uk(a) {
      return !!(a && (a.nodeType === ua || a.nodeType === Zs || a.nodeType === Xu || !pe));
    }
    function Xw(a) {
      return !!(a && (a.nodeType === ua || a.nodeType === Zs || a.nodeType === Xu || a.nodeType === Ri && a.nodeValue === " react-mount-point-unstable "));
    }
    function zL(a) {
      a.nodeType === ua && a.tagName && a.tagName.toUpperCase() === "BODY" && s("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), hw(a) && (a._reactRootContainer ? s("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : s("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var Goe = n.ReactCurrentOwner, VL;
    VL = function(a) {
      if (a._reactRootContainer && a.nodeType !== Ri) {
        var l = xL(a._reactRootContainer.current);
        l && l.parentNode !== a && s("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var m = !!a._reactRootContainer, g = kR(a), E = !!(g && th(g));
      E && !m && s("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), a.nodeType === ua && a.tagName && a.tagName.toUpperCase() === "BODY" && s("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function kR(a) {
      return a ? a.nodeType === Zs ? a.documentElement : a.firstChild : null;
    }
    function $L() {
    }
    function Koe(a, l, m, g, E) {
      if (E) {
        if (typeof g == "function") {
          var _ = g;
          g = function() {
            var Re = lk(B);
            _.call(Re);
          };
        }
        var B = wL(
          l,
          g,
          a,
          rh,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          $L
        );
        a._reactRootContainer = B, XE(B.current, a);
        var q = a.nodeType === Ri ? a.parentNode : a;
        return nw(q), Od(), B;
      } else {
        for (var G; G = a.lastChild; )
          a.removeChild(G);
        if (typeof g == "function") {
          var se = g;
          g = function() {
            var Re = lk(ue);
            se.call(Re);
          };
        }
        var ue = bL(
          a,
          rh,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          $L
        );
        a._reactRootContainer = ue, XE(ue.current, a);
        var De = a.nodeType === Ri ? a.parentNode : a;
        return nw(De), Od(function() {
          Qw(l, ue, m, g);
        }), ue;
      }
    }
    function Yoe(a, l) {
      a !== null && typeof a != "function" && s("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", l, a);
    }
    function dk(a, l, m, g, E) {
      VL(m), Yoe(E === void 0 ? null : E, "render");
      var _ = m._reactRootContainer, B;
      if (!_)
        B = Koe(m, l, a, E, g);
      else {
        if (B = _, typeof E == "function") {
          var q = E;
          E = function() {
            var G = lk(B);
            q.call(G);
          };
        }
        Qw(l, B, a, E);
      }
      return lk(B);
    }
    var HL = !1;
    function Qoe(a) {
      {
        HL || (HL = !0, s("findDOMNode is deprecated and will be removed in the next major release. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node"));
        var l = Goe.current;
        if (l !== null && l.stateNode !== null) {
          var m = l.stateNode._warnedAboutRefsInRender;
          m || s("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Hn(l.type) || "A component"), l.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return a == null ? null : a.nodeType === ua ? a : Poe(a, "findDOMNode");
    }
    function Xoe(a, l, m) {
      if (s("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Xw(l))
        throw new Error("Target container is not a DOM element.");
      {
        var g = hw(l) && l._reactRootContainer === void 0;
        g && s("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return dk(null, a, l, !0, m);
    }
    function Joe(a, l, m) {
      if (s("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Xw(l))
        throw new Error("Target container is not a DOM element.");
      {
        var g = hw(l) && l._reactRootContainer === void 0;
        g && s("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return dk(null, a, l, !1, m);
    }
    function Zoe(a, l, m, g) {
      if (s("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Xw(m))
        throw new Error("Target container is not a DOM element.");
      if (a == null || !Tp(a))
        throw new Error("parentComponent must be a valid React Component");
      return dk(a, l, m, !1, g);
    }
    var qL = !1;
    function eae(a) {
      if (qL || (qL = !0, s("unmountComponentAtNode is deprecated and will be removed in the next major release. Switch to the createRoot API. Learn more: https://reactjs.org/link/switch-to-createroot")), !Xw(a))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var l = hw(a) && a._reactRootContainer === void 0;
        l && s("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (a._reactRootContainer) {
        {
          var m = kR(a), g = m && !th(m);
          g && s("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return Od(function() {
          dk(null, null, a, !1, function() {
            a._reactRootContainer = null, U3(a);
          });
        }), !0;
      } else {
        {
          var E = kR(a), _ = !!(E && th(E)), B = a.nodeType === ua && Xw(a.parentNode) && !!a.parentNode._reactRootContainer;
          _ && s("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", B ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    zf(Noe), ST(Boe), lv(Loe), bE(Es), wE(jo), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
    Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
    Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && s("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), Yx(nte), ky(nR, Wie, Od);
    function tae(a, l) {
      var m = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!uk(l))
        throw new Error("Target container is not a DOM element.");
      return Moe(a, l, null, m);
    }
    function nae(a, l, m, g) {
      return Zoe(a, l, m, g);
    }
    var AR = {
      usingClientEntryPoint: !1,
      // Keep in sync with ReactTestUtils.js.
      // This is an array for better minification.
      Events: [th, Iv, JE, Sy, Sp, nR]
    };
    function rae(a, l) {
      return AR.usingClientEntryPoint || s('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), Hoe(a, l);
    }
    function iae(a, l, m) {
      return AR.usingClientEntryPoint || s('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), Woe(a, l, m);
    }
    function oae(a) {
      return J6() && s("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), Od(a);
    }
    var aae = $oe({
      findFiberByHostInstance: em,
      bundleType: 1,
      version: bR,
      rendererPackageName: "react-dom"
    });
    if (!aae && Ot && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var sae = window.location.protocol;
      /^(https?|file):$/.test(sae);
    }
    Ns.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = AR, Ns.createPortal = tae, Ns.createRoot = rae, Ns.findDOMNode = Qoe, Ns.flushSync = oae, Ns.hydrate = Xoe, Ns.hydrateRoot = iae, Ns.render = Joe, Ns.unmountComponentAtNode = eae, Ns.unstable_batchedUpdates = nR, Ns.unstable_renderSubtreeIntoContainer = nae, Ns.version = bR, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Ns;
}
function PW() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
    if (ct.env.NODE_ENV !== "production")
      throw new Error("^_^");
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(PW);
    } catch {
    }
  }
}
ct.env.NODE_ENV === "production" ? (PW(), H5.exports = fwe()) : H5.exports = hwe();
var Wu = H5.exports;
const NW = /* @__PURE__ */ DC(Wu), pwe = /* @__PURE__ */ qz({
  __proto__: null,
  default: NW
}, [Wu]);
var d4 = "right-scroll-bar-position", f4 = "width-before-scroll-bar", mwe = "with-scroll-bars-hidden", ywe = "--removed-body-scroll-bar-size";
function vwe(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function gwe(e, t) {
  var n = k.useState(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var i = n.value;
          i !== r && (n.value = r, n.callback(r, i));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
function bwe(e, t) {
  return gwe(null, function(n) {
    return e.forEach(function(r) {
      return vwe(r, n);
    });
  });
}
function wwe(e) {
  return e;
}
function Cwe(e, t) {
  t === void 0 && (t = wwe);
  var n = [], r = !1, i = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(o) {
      var s = t(o, r);
      return n.push(s), function() {
        n = n.filter(function(c) {
          return c !== s;
        });
      };
    },
    assignSyncMedium: function(o) {
      for (r = !0; n.length; ) {
        var s = n;
        n = [], s.forEach(o);
      }
      n = {
        push: function(c) {
          return o(c);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(o) {
      r = !0;
      var s = [];
      if (n.length) {
        var c = n;
        n = [], c.forEach(o), s = n;
      }
      var u = function() {
        var p = s;
        s = [], p.forEach(o);
      }, f = function() {
        return Promise.resolve().then(u);
      };
      f(), n = {
        push: function(p) {
          s.push(p), f();
        },
        filter: function(p) {
          return s = s.filter(p), n;
        }
      };
    }
  };
  return i;
}
function xwe(e) {
  e === void 0 && (e = {});
  var t = Cwe(null);
  return t.options = $l({ async: !0, ssr: !1 }, e), t;
}
var BW = function(e) {
  var t = e.sideCar, n = k8(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return k.createElement(r, $l({}, n));
};
BW.isSideCarExport = !0;
function Ewe(e, t) {
  return e.useMedium(t), BW;
}
var LW = xwe(), gO = function() {
}, X8 = k.forwardRef(function(e, t) {
  var n = k.useRef(null), r = k.useState({
    onScrollCapture: gO,
    onWheelCapture: gO,
    onTouchMoveCapture: gO
  }), i = r[0], o = r[1], s = e.forwardProps, c = e.children, u = e.className, f = e.removeScrollBar, p = e.enabled, y = e.shards, v = e.sideCar, w = e.noIsolation, C = e.inert, x = e.allowPinchZoom, A = e.as, R = A === void 0 ? "div" : A, I = e.gapMode, D = k8(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), M = v, L = bwe([n, t]), j = $l($l({}, D), i);
  return k.createElement(
    k.Fragment,
    null,
    p && k.createElement(M, { sideCar: LW, removeScrollBar: f, shards: y, noIsolation: w, inert: C, setCallbacks: o, allowPinchZoom: !!x, lockRef: n, gapMode: I }),
    s ? k.cloneElement(k.Children.only(c), $l($l({}, j), { ref: L })) : k.createElement(R, $l({}, j, { className: u, ref: L }), c)
  );
});
X8.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
X8.classNames = {
  fullWidth: f4,
  zeroRight: d4
};
var Swe = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function kwe() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = Swe();
  return t && e.setAttribute("nonce", t), e;
}
function Awe(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function Twe(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var _we = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = kwe()) && (Awe(t, n), Twe(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, Rwe = function() {
  var e = _we();
  return function(t, n) {
    k.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, jW = function() {
  var e = Rwe(), t = function(n) {
    var r = n.styles, i = n.dynamic;
    return e(r, i), null;
  };
  return t;
}, Owe = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, bO = function(e) {
  return parseInt(e || "", 10) || 0;
}, Iwe = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], i = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [bO(n), bO(r), bO(i)];
}, Dwe = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return Owe;
  var t = Iwe(e), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, r - n + t[2] - t[0])
  };
}, Mwe = jW(), V4 = "data-scroll-locked", Pwe = function(e, t, n, r) {
  var i = e.left, o = e.top, s = e.right, c = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(mwe, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(c, "px ").concat(r, `;
  }
  body[`).concat(V4, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(i, `px;
    padding-top: `).concat(o, `px;
    padding-right: `).concat(s, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(c, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(c, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(d4, ` {
    right: `).concat(c, "px ").concat(r, `;
  }
  
  .`).concat(f4, ` {
    margin-right: `).concat(c, "px ").concat(r, `;
  }
  
  .`).concat(d4, " .").concat(d4, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(f4, " .").concat(f4, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(V4, `] {
    `).concat(ywe, ": ").concat(c, `px;
  }
`);
}, Nwe = function(e) {
  var t = e.noRelative, n = e.noImportant, r = e.gapMode, i = r === void 0 ? "margin" : r, o = k.useMemo(function() {
    return Dwe(i);
  }, [i]);
  return k.useEffect(function() {
    return document.body.setAttribute(V4, ""), function() {
      document.body.removeAttribute(V4);
    };
  }, []), k.createElement(Mwe, { styles: Pwe(o, !t, i, n ? "" : "!important") });
}, q5 = !1;
if (typeof window < "u")
  try {
    var Rk = Object.defineProperty({}, "passive", {
      get: function() {
        return q5 = !0, !0;
      }
    });
    window.addEventListener("test", Rk, Rk), window.removeEventListener("test", Rk, Rk);
  } catch {
    q5 = !1;
  }
var og = q5 ? { passive: !1 } : !1, Bwe = function(e) {
  return e.tagName === "TEXTAREA";
}, FW = function(e, t) {
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !Bwe(e) && n[t] === "visible")
  );
}, Lwe = function(e) {
  return FW(e, "overflowY");
}, jwe = function(e) {
  return FW(e, "overflowX");
}, rU = function(e, t) {
  var n = t.ownerDocument, r = t;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var i = UW(e, r);
    if (i) {
      var o = zW(e, r), s = o[1], c = o[2];
      if (s > c)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, Fwe = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
  return [
    t,
    n,
    r
  ];
}, Uwe = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
  return [
    t,
    n,
    r
  ];
}, UW = function(e, t) {
  return e === "v" ? Lwe(t) : jwe(t);
}, zW = function(e, t) {
  return e === "v" ? Fwe(t) : Uwe(t);
}, zwe = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, Vwe = function(e, t, n, r, i) {
  var o = zwe(e, window.getComputedStyle(t).direction), s = o * r, c = n.target, u = t.contains(c), f = !1, p = s > 0, y = 0, v = 0;
  do {
    var w = zW(e, c), C = w[0], x = w[1], A = w[2], R = x - A - o * C;
    (C || R) && UW(e, c) && (y += R, v += C), c instanceof ShadowRoot ? c = c.host : c = c.parentNode;
  } while (
    // portaled content
    !u && c !== document.body || // self content
    u && (t.contains(c) || t === c)
  );
  return (p && (Math.abs(y) < 1 || !i) || !p && (Math.abs(v) < 1 || !i)) && (f = !0), f;
}, Ok = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, iU = function(e) {
  return [e.deltaX, e.deltaY];
}, oU = function(e) {
  return e && "current" in e ? e.current : e;
}, $we = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, Hwe = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, qwe = 0, ag = [];
function Wwe(e) {
  var t = k.useRef([]), n = k.useRef([0, 0]), r = k.useRef(), i = k.useState(qwe++)[0], o = k.useState(jW)[0], s = k.useRef(e);
  k.useEffect(function() {
    s.current = e;
  }, [e]), k.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(i));
      var x = Xg([e.lockRef.current], (e.shards || []).map(oU), !0).filter(Boolean);
      return x.forEach(function(A) {
        return A.classList.add("allow-interactivity-".concat(i));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(i)), x.forEach(function(A) {
          return A.classList.remove("allow-interactivity-".concat(i));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var c = k.useCallback(function(x, A) {
    if ("touches" in x && x.touches.length === 2)
      return !s.current.allowPinchZoom;
    var R = Ok(x), I = n.current, D = "deltaX" in x ? x.deltaX : I[0] - R[0], M = "deltaY" in x ? x.deltaY : I[1] - R[1], L, j = x.target, F = Math.abs(D) > Math.abs(M) ? "h" : "v";
    if ("touches" in x && F === "h" && j.type === "range")
      return !1;
    var O = rU(F, j);
    if (!O)
      return !0;
    if (O ? L = F : (L = F === "v" ? "h" : "v", O = rU(F, j)), !O)
      return !1;
    if (!r.current && "changedTouches" in x && (D || M) && (r.current = L), !L)
      return !0;
    var z = r.current || L;
    return Vwe(z, A, x, z === "h" ? D : M, !0);
  }, []), u = k.useCallback(function(x) {
    var A = x;
    if (!(!ag.length || ag[ag.length - 1] !== o)) {
      var R = "deltaY" in A ? iU(A) : Ok(A), I = t.current.filter(function(L) {
        return L.name === A.type && (L.target === A.target || A.target === L.shadowParent) && $we(L.delta, R);
      })[0];
      if (I && I.should) {
        A.cancelable && A.preventDefault();
        return;
      }
      if (!I) {
        var D = (s.current.shards || []).map(oU).filter(Boolean).filter(function(L) {
          return L.contains(A.target);
        }), M = D.length > 0 ? c(A, D[0]) : !s.current.noIsolation;
        M && A.cancelable && A.preventDefault();
      }
    }
  }, []), f = k.useCallback(function(x, A, R, I) {
    var D = { name: x, delta: A, target: R, should: I, shadowParent: Gwe(R) };
    t.current.push(D), setTimeout(function() {
      t.current = t.current.filter(function(M) {
        return M !== D;
      });
    }, 1);
  }, []), p = k.useCallback(function(x) {
    n.current = Ok(x), r.current = void 0;
  }, []), y = k.useCallback(function(x) {
    f(x.type, iU(x), x.target, c(x, e.lockRef.current));
  }, []), v = k.useCallback(function(x) {
    f(x.type, Ok(x), x.target, c(x, e.lockRef.current));
  }, []);
  k.useEffect(function() {
    return ag.push(o), e.setCallbacks({
      onScrollCapture: y,
      onWheelCapture: y,
      onTouchMoveCapture: v
    }), document.addEventListener("wheel", u, og), document.addEventListener("touchmove", u, og), document.addEventListener("touchstart", p, og), function() {
      ag = ag.filter(function(x) {
        return x !== o;
      }), document.removeEventListener("wheel", u, og), document.removeEventListener("touchmove", u, og), document.removeEventListener("touchstart", p, og);
    };
  }, []);
  var w = e.removeScrollBar, C = e.inert;
  return k.createElement(
    k.Fragment,
    null,
    C ? k.createElement(o, { styles: Hwe(i) }) : null,
    w ? k.createElement(Nwe, { gapMode: e.gapMode }) : null
  );
}
function Gwe(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const Kwe = Ewe(LW, Wwe);
var J8 = k.forwardRef(function(e, t) {
  return k.createElement(X8, $l({}, e, { ref: t, sideCar: Kwe }));
});
J8.classNames = X8.classNames;
function aU(e) {
  var t = e.match(/^var\((.*)\)$/);
  return t ? t[1] : e;
}
function Ywe(e, t) {
  var n = e;
  for (var r of t) {
    if (!(r in n))
      throw new Error("Path ".concat(t.join(" -> "), " does not exist in object"));
    n = n[r];
  }
  return n;
}
function VW(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], r = e.constructor();
  for (var i in e) {
    var o = e[i], s = [...n, i];
    typeof o == "string" || typeof o == "number" || o == null ? r[i] = t(o, s) : typeof o == "object" && !Array.isArray(o) && (r[i] = VW(o, t, s));
  }
  return r;
}
function sU(e, t) {
  var n = {};
  if (typeof t == "object") {
    var r = e;
    VW(t, (c, u) => {
      if (c != null) {
        var f = Ywe(r, u);
        n[aU(f)] = String(c);
      }
    });
  } else {
    var i = e;
    for (var o in i) {
      var s = i[o];
      s != null && (n[aU(o)] = s);
    }
  }
  return Object.defineProperty(n, "toString", {
    value: function() {
      return Object.keys(this).map((u) => "".concat(u, ":").concat(this[u])).join(";");
    },
    writable: !1
  }), n;
}
var W5 = { exports: {} };
(function(e, t) {
  (function(n, r) {
    var i = "1.0.37", o = "", s = "?", c = "function", u = "undefined", f = "object", p = "string", y = "major", v = "model", w = "name", C = "type", x = "vendor", A = "version", R = "architecture", I = "console", D = "mobile", M = "tablet", L = "smarttv", j = "wearable", F = "embedded", O = 500, z = "Amazon", H = "Apple", Q = "ASUS", Y = "BlackBerry", ee = "Browser", ie = "Chrome", X = "Edge", Z = "Firefox", J = "Google", K = "Huawei", oe = "LG", be = "Microsoft", ce = "Motorola", pe = "Opera", Ee = "Samsung", Se = "Sharp", Me = "Sony", Fe = "Xiaomi", st = "Zebra", mt = "Facebook", yt = "Chromium OS", Ut = "Mac OS", hn = function(Tt, qt) {
      var gt = {};
      for (var Ht in Tt)
        qt[Ht] && qt[Ht].length % 2 === 0 ? gt[Ht] = qt[Ht].concat(Tt[Ht]) : gt[Ht] = Tt[Ht];
      return gt;
    }, wn = function(Tt) {
      for (var qt = {}, gt = 0; gt < Tt.length; gt++)
        qt[Tt[gt].toUpperCase()] = Tt[gt];
      return qt;
    }, Ot = function(Tt, qt) {
      return typeof Tt === p ? xt(qt).indexOf(xt(Tt)) !== -1 : !1;
    }, xt = function(Tt) {
      return Tt.toLowerCase();
    }, zt = function(Tt) {
      return typeof Tt === p ? Tt.replace(/[^\d\.]/g, o).split(".")[0] : r;
    }, Pn = function(Tt, qt) {
      if (typeof Tt === p)
        return Tt = Tt.replace(/^\s\s*/, o), typeof qt === u ? Tt : Tt.substring(0, O);
    }, Fn = function(Tt, qt) {
      for (var gt = 0, Ht, br, ne, N, U, le; gt < qt.length && !U; ) {
        var Ce = qt[gt], Te = qt[gt + 1];
        for (Ht = br = 0; Ht < Ce.length && !U && Ce[Ht]; )
          if (U = Ce[Ht++].exec(Tt), U)
            for (ne = 0; ne < Te.length; ne++)
              le = U[++br], N = Te[ne], typeof N === f && N.length > 0 ? N.length === 2 ? typeof N[1] == c ? this[N[0]] = N[1].call(this, le) : this[N[0]] = N[1] : N.length === 3 ? typeof N[1] === c && !(N[1].exec && N[1].test) ? this[N[0]] = le ? N[1].call(this, le, N[2]) : r : this[N[0]] = le ? le.replace(N[1], N[2]) : r : N.length === 4 && (this[N[0]] = le ? N[3].call(this, le.replace(N[1], N[2])) : r) : this[N] = le || r;
        gt += 2;
      }
    }, tr = function(Tt, qt) {
      for (var gt in qt)
        if (typeof qt[gt] === f && qt[gt].length > 0) {
          for (var Ht = 0; Ht < qt[gt].length; Ht++)
            if (Ot(qt[gt][Ht], Tt))
              return gt === s ? r : gt;
        } else if (Ot(qt[gt], Tt))
          return gt === s ? r : gt;
      return Tt;
    }, or = {
      "1.0": "/8",
      "1.2": "/1",
      "1.3": "/3",
      "2.0": "/412",
      "2.0.2": "/416",
      "2.0.3": "/417",
      "2.0.4": "/419",
      "?": "/"
    }, ar = {
      ME: "4.90",
      "NT 3.11": "NT3.51",
      "NT 4.0": "NT4.0",
      2e3: "NT 5.0",
      XP: ["NT 5.1", "NT 5.2"],
      Vista: "NT 6.0",
      7: "NT 6.1",
      8: "NT 6.2",
      "8.1": "NT 6.3",
      10: ["NT 6.4", "NT 10.0"],
      RT: "ARM"
    }, Cr = {
      browser: [
        [
          /\b(?:crmo|crios)\/([\w\.]+)/i
          // Chrome for Android/iOS
        ],
        [A, [w, "Chrome"]],
        [
          /edg(?:e|ios|a)?\/([\w\.]+)/i
          // Microsoft Edge
        ],
        [A, [w, "Edge"]],
        [
          // Presto based
          /(opera mini)\/([-\w\.]+)/i,
          // Opera Mini
          /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
          // Opera Mobi/Tablet
          /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i
          // Opera
        ],
        [w, A],
        [
          /opios[\/ ]+([\w\.]+)/i
          // Opera mini on iphone >= 8.0
        ],
        [A, [w, pe + " Mini"]],
        [
          /\bopr\/([\w\.]+)/i
          // Opera Webkit
        ],
        [A, [w, pe]],
        [
          // Mixed
          /\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i
          // Baidu
        ],
        [A, [w, "Baidu"]],
        [
          /(kindle)\/([\w\.]+)/i,
          // Kindle
          /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i,
          // Lunascape/Maxthon/Netfront/Jasmine/Blazer
          // Trident based
          /(avant|iemobile|slim)\s?(?:browser)?[\/ ]?([\w\.]*)/i,
          // Avant/IEMobile/SlimBrowser
          /(?:ms|\()(ie) ([\w\.]+)/i,
          // Internet Explorer
          // Webkit/KHTML based                                               // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
          /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i,
          // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ, aka ShouQ
          /(heytap|ovi)browser\/([\d\.]+)/i,
          // Heytap/Ovi
          /(weibo)__([\d\.]+)/i
          // Weibo
        ],
        [w, A],
        [
          /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i
          // UCBrowser
        ],
        [A, [w, "UC" + ee]],
        [
          /microm.+\bqbcore\/([\w\.]+)/i,
          // WeChat Desktop for Windows Built-in Browser
          /\bqbcore\/([\w\.]+).+microm/i,
          /micromessenger\/([\w\.]+)/i
          // WeChat
        ],
        [A, [w, "WeChat"]],
        [
          /konqueror\/([\w\.]+)/i
          // Konqueror
        ],
        [A, [w, "Konqueror"]],
        [
          /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i
          // IE11
        ],
        [A, [w, "IE"]],
        [
          /ya(?:search)?browser\/([\w\.]+)/i
          // Yandex
        ],
        [A, [w, "Yandex"]],
        [
          /slbrowser\/([\w\.]+)/i
          // Smart Lenovo Browser
        ],
        [A, [w, "Smart Lenovo " + ee]],
        [
          /(avast|avg)\/([\w\.]+)/i
          // Avast/AVG Secure Browser
        ],
        [[w, /(.+)/, "$1 Secure " + ee], A],
        [
          /\bfocus\/([\w\.]+)/i
          // Firefox Focus
        ],
        [A, [w, Z + " Focus"]],
        [
          /\bopt\/([\w\.]+)/i
          // Opera Touch
        ],
        [A, [w, pe + " Touch"]],
        [
          /coc_coc\w+\/([\w\.]+)/i
          // Coc Coc Browser
        ],
        [A, [w, "Coc Coc"]],
        [
          /dolfin\/([\w\.]+)/i
          // Dolphin
        ],
        [A, [w, "Dolphin"]],
        [
          /coast\/([\w\.]+)/i
          // Opera Coast
        ],
        [A, [w, pe + " Coast"]],
        [
          /miuibrowser\/([\w\.]+)/i
          // MIUI Browser
        ],
        [A, [w, "MIUI " + ee]],
        [
          /fxios\/([-\w\.]+)/i
          // Firefox for iOS
        ],
        [A, [w, Z]],
        [
          /\bqihu|(qi?ho?o?|360)browser/i
          // 360
        ],
        [[w, "360 " + ee]],
        [
          /(oculus|sailfish|huawei|vivo)browser\/([\w\.]+)/i
        ],
        [[w, /(.+)/, "$1 " + ee], A],
        [
          // Oculus/Sailfish/HuaweiBrowser/VivoBrowser
          /samsungbrowser\/([\w\.]+)/i
          // Samsung Internet
        ],
        [A, [w, Ee + " Internet"]],
        [
          /(comodo_dragon)\/([\w\.]+)/i
          // Comodo Dragon
        ],
        [[w, /_/g, " "], A],
        [
          /metasr[\/ ]?([\d\.]+)/i
          // Sogou Explorer
        ],
        [A, [w, "Sogou Explorer"]],
        [
          /(sogou)mo\w+\/([\d\.]+)/i
          // Sogou Mobile
        ],
        [[w, "Sogou Mobile"], A],
        [
          /(electron)\/([\w\.]+) safari/i,
          // Electron-based App
          /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
          // Tesla
          /m?(qqbrowser|2345Explorer)[\/ ]?([\w\.]+)/i
          // QQBrowser/2345 Browser
        ],
        [w, A],
        [
          /(lbbrowser)/i,
          // LieBao Browser
          /\[(linkedin)app\]/i
          // LinkedIn App for iOS & Android
        ],
        [w],
        [
          // WebView
          /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i
          // Facebook App for iOS & Android
        ],
        [[w, mt], A],
        [
          /(Klarna)\/([\w\.]+)/i,
          // Klarna Shopping Browser for iOS & Android
          /(kakao(?:talk|story))[\/ ]([\w\.]+)/i,
          // Kakao App
          /(naver)\(.*?(\d+\.[\w\.]+).*\)/i,
          // Naver InApp
          /safari (line)\/([\w\.]+)/i,
          // Line App for iOS
          /\b(line)\/([\w\.]+)\/iab/i,
          // Line App for Android
          /(alipay)client\/([\w\.]+)/i,
          // Alipay
          /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i
          // Chromium/Instagram/Snapchat
        ],
        [w, A],
        [
          /\bgsa\/([\w\.]+) .*safari\//i
          // Google Search Appliance on iOS
        ],
        [A, [w, "GSA"]],
        [
          /musical_ly(?:.+app_?version\/|_)([\w\.]+)/i
          // TikTok
        ],
        [A, [w, "TikTok"]],
        [
          /headlesschrome(?:\/([\w\.]+)| )/i
          // Chrome Headless
        ],
        [A, [w, ie + " Headless"]],
        [
          / wv\).+(chrome)\/([\w\.]+)/i
          // Chrome WebView
        ],
        [[w, ie + " WebView"], A],
        [
          /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i
          // Android Browser
        ],
        [A, [w, "Android " + ee]],
        [
          /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i
          // Chrome/OmniWeb/Arora/Tizen/Nokia
        ],
        [w, A],
        [
          /version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i
          // Mobile Safari
        ],
        [A, [w, "Mobile Safari"]],
        [
          /version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i
          // Safari & Safari Mobile
        ],
        [A, w],
        [
          /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i
          // Safari < 3.0
        ],
        [w, [A, tr, or]],
        [
          /(webkit|khtml)\/([\w\.]+)/i
        ],
        [w, A],
        [
          // Gecko based
          /(navigator|netscape\d?)\/([-\w\.]+)/i
          // Netscape
        ],
        [[w, "Netscape"], A],
        [
          /mobile vr; rv:([\w\.]+)\).+firefox/i
          // Firefox Reality
        ],
        [A, [w, Z + " Reality"]],
        [
          /ekiohf.+(flow)\/([\w\.]+)/i,
          // Flow
          /(swiftfox)/i,
          // Swiftfox
          /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i,
          // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror/Klar
          /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
          // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
          /(firefox)\/([\w\.]+)/i,
          // Other Firefox-based
          /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
          // Mozilla
          // Other
          /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
          // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir/Obigo/Mosaic/Go/ICE/UP.Browser
          /(links) \(([\w\.]+)/i,
          // Links
          /panasonic;(viera)/i
          // Panasonic Viera
        ],
        [w, A],
        [
          /(cobalt)\/([\w\.]+)/i
          // Cobalt
        ],
        [w, [A, /master.|lts./, ""]]
      ],
      cpu: [
        [
          /(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i
          // AMD64 (x64)
        ],
        [[R, "amd64"]],
        [
          /(ia32(?=;))/i
          // IA32 (quicktime)
        ],
        [[R, xt]],
        [
          /((?:i[346]|x)86)[;\)]/i
          // IA32 (x86)
        ],
        [[R, "ia32"]],
        [
          /\b(aarch64|arm(v?8e?l?|_?64))\b/i
          // ARM64
        ],
        [[R, "arm64"]],
        [
          /\b(arm(?:v[67])?ht?n?[fl]p?)\b/i
          // ARMHF
        ],
        [[R, "armhf"]],
        [
          // PocketPC mistakenly identified as PowerPC
          /windows (ce|mobile); ppc;/i
        ],
        [[R, "arm"]],
        [
          /((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i
          // PowerPC
        ],
        [[R, /ower/, o, xt]],
        [
          /(sun4\w)[;\)]/i
          // SPARC
        ],
        [[R, "sparc"]],
        [
          /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i
          // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
        ],
        [[R, xt]]
      ],
      device: [
        [
          //////////////////////////
          // MOBILES & TABLETS
          /////////////////////////
          // Samsung
          /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i
        ],
        [v, [x, Ee], [C, M]],
        [
          /\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,
          /samsung[- ]([-\w]+)/i,
          /sec-(sgh\w+)/i
        ],
        [v, [x, Ee], [C, D]],
        [
          // Apple
          /(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i
          // iPod/iPhone
        ],
        [v, [x, H], [C, D]],
        [
          /\((ipad);[-\w\),; ]+apple/i,
          // iPad
          /applecoremedia\/[\w\.]+ \((ipad)/i,
          /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
        ],
        [v, [x, H], [C, M]],
        [
          /(macintosh);/i
        ],
        [v, [x, H]],
        [
          // Sharp
          /\b(sh-?[altvz]?\d\d[a-ekm]?)/i
        ],
        [v, [x, Se], [C, D]],
        [
          // Huawei
          /\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i
        ],
        [v, [x, K], [C, M]],
        [
          /(?:huawei|honor)([-\w ]+)[;\)]/i,
          /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i
        ],
        [v, [x, K], [C, D]],
        [
          // Xiaomi
          /\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i,
          // Xiaomi POCO
          /\b; (\w+) build\/hm\1/i,
          // Xiaomi Hongmi 'numeric' models
          /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
          // Xiaomi Hongmi
          /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
          // Xiaomi Redmi
          /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i,
          // Xiaomi Redmi 'numeric' models
          /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i
          // Xiaomi Mi
        ],
        [[v, /_/g, " "], [x, Fe], [C, D]],
        [
          /oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i,
          // Redmi Pad
          /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i
          // Mi Pad tablets
        ],
        [[v, /_/g, " "], [x, Fe], [C, M]],
        [
          // OPPO
          /; (\w+) bui.+ oppo/i,
          /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
        ],
        [v, [x, "OPPO"], [C, D]],
        [
          // Vivo
          /vivo (\w+)(?: bui|\))/i,
          /\b(v[12]\d{3}\w?[at])(?: bui|;)/i
        ],
        [v, [x, "Vivo"], [C, D]],
        [
          // Realme
          /\b(rmx[1-3]\d{3})(?: bui|;|\))/i
        ],
        [v, [x, "Realme"], [C, D]],
        [
          // Motorola
          /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
          /\bmot(?:orola)?[- ](\w*)/i,
          /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i
        ],
        [v, [x, ce], [C, D]],
        [
          /\b(mz60\d|xoom[2 ]{0,2}) build\//i
        ],
        [v, [x, ce], [C, M]],
        [
          // LG
          /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i
        ],
        [v, [x, oe], [C, M]],
        [
          /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
          /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,
          /\blg-?([\d\w]+) bui/i
        ],
        [v, [x, oe], [C, D]],
        [
          // Lenovo
          /(ideatab[-\w ]+)/i,
          /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i
        ],
        [v, [x, "Lenovo"], [C, M]],
        [
          // Nokia
          /(?:maemo|nokia).*(n900|lumia \d+)/i,
          /nokia[-_ ]?([-\w\.]*)/i
        ],
        [[v, /_/g, " "], [x, "Nokia"], [C, D]],
        [
          // Google
          /(pixel c)\b/i
          // Google Pixel C
        ],
        [v, [x, J], [C, M]],
        [
          /droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i
          // Google Pixel
        ],
        [v, [x, J], [C, D]],
        [
          // Sony
          /droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
        ],
        [v, [x, Me], [C, D]],
        [
          /sony tablet [ps]/i,
          /\b(?:sony)?sgp\w+(?: bui|\))/i
        ],
        [[v, "Xperia Tablet"], [x, Me], [C, M]],
        [
          // OnePlus
          / (kb2005|in20[12]5|be20[12][59])\b/i,
          /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
        ],
        [v, [x, "OnePlus"], [C, D]],
        [
          // Amazon
          /(alexa)webm/i,
          /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i,
          // Kindle Fire without Silk / Echo Show
          /(kf[a-z]+)( bui|\)).+silk\//i
          // Kindle Fire HD
        ],
        [v, [x, z], [C, M]],
        [
          /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i
          // Fire Phone
        ],
        [[v, /(.+)/g, "Fire Phone $1"], [x, z], [C, D]],
        [
          // BlackBerry
          /(playbook);[-\w\),; ]+(rim)/i
          // BlackBerry PlayBook
        ],
        [v, x, [C, M]],
        [
          /\b((?:bb[a-f]|st[hv])100-\d)/i,
          /\(bb10; (\w+)/i
          // BlackBerry 10
        ],
        [v, [x, Y], [C, D]],
        [
          // Asus
          /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i
        ],
        [v, [x, Q], [C, M]],
        [
          / (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i
        ],
        [v, [x, Q], [C, D]],
        [
          // HTC
          /(nexus 9)/i
          // HTC Nexus 9
        ],
        [v, [x, "HTC"], [C, M]],
        [
          /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
          // HTC
          // ZTE
          /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
          /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i
          // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
        ],
        [x, [v, /_/g, " "], [C, D]],
        [
          // Acer
          /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i
        ],
        [v, [x, "Acer"], [C, M]],
        [
          // Meizu
          /droid.+; (m[1-5] note) bui/i,
          /\bmz-([-\w]{2,})/i
        ],
        [v, [x, "Meizu"], [C, D]],
        [
          // Ulefone
          /; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i
        ],
        [v, [x, "Ulefone"], [C, D]],
        [
          // MIXED
          /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno)[-_ ]?([-\w]*)/i,
          // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron
          /(hp) ([\w ]+\w)/i,
          // HP iPAQ
          /(asus)-?(\w+)/i,
          // Asus
          /(microsoft); (lumia[\w ]+)/i,
          // Microsoft Lumia
          /(lenovo)[-_ ]?([-\w]+)/i,
          // Lenovo
          /(jolla)/i,
          // Jolla
          /(oppo) ?([\w ]+) bui/i
          // OPPO
        ],
        [x, v, [C, D]],
        [
          /(kobo)\s(ereader|touch)/i,
          // Kobo
          /(archos) (gamepad2?)/i,
          // Archos
          /(hp).+(touchpad(?!.+tablet)|tablet)/i,
          // HP TouchPad
          /(kindle)\/([\w\.]+)/i,
          // Kindle
          /(nook)[\w ]+build\/(\w+)/i,
          // Nook
          /(dell) (strea[kpr\d ]*[\dko])/i,
          // Dell Streak
          /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
          // Le Pan Tablets
          /(trinity)[- ]*(t\d{3}) bui/i,
          // Trinity Tablets
          /(gigaset)[- ]+(q\w{1,9}) bui/i,
          // Gigaset Tablets
          /(vodafone) ([\w ]+)(?:\)| bui)/i
          // Vodafone
        ],
        [x, v, [C, M]],
        [
          /(surface duo)/i
          // Surface Duo
        ],
        [v, [x, be], [C, M]],
        [
          /droid [\d\.]+; (fp\du?)(?: b|\))/i
          // Fairphone
        ],
        [v, [x, "Fairphone"], [C, D]],
        [
          /(u304aa)/i
          // AT&T
        ],
        [v, [x, "AT&T"], [C, D]],
        [
          /\bsie-(\w*)/i
          // Siemens
        ],
        [v, [x, "Siemens"], [C, D]],
        [
          /\b(rct\w+) b/i
          // RCA Tablets
        ],
        [v, [x, "RCA"], [C, M]],
        [
          /\b(venue[\d ]{2,7}) b/i
          // Dell Venue Tablets
        ],
        [v, [x, "Dell"], [C, M]],
        [
          /\b(q(?:mv|ta)\w+) b/i
          // Verizon Tablet
        ],
        [v, [x, "Verizon"], [C, M]],
        [
          /\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i
          // Barnes & Noble Tablet
        ],
        [v, [x, "Barnes & Noble"], [C, M]],
        [
          /\b(tm\d{3}\w+) b/i
        ],
        [v, [x, "NuVision"], [C, M]],
        [
          /\b(k88) b/i
          // ZTE K Series Tablet
        ],
        [v, [x, "ZTE"], [C, M]],
        [
          /\b(nx\d{3}j) b/i
          // ZTE Nubia
        ],
        [v, [x, "ZTE"], [C, D]],
        [
          /\b(gen\d{3}) b.+49h/i
          // Swiss GEN Mobile
        ],
        [v, [x, "Swiss"], [C, D]],
        [
          /\b(zur\d{3}) b/i
          // Swiss ZUR Tablet
        ],
        [v, [x, "Swiss"], [C, M]],
        [
          /\b((zeki)?tb.*\b) b/i
          // Zeki Tablets
        ],
        [v, [x, "Zeki"], [C, M]],
        [
          /\b([yr]\d{2}) b/i,
          /\b(dragon[- ]+touch |dt)(\w{5}) b/i
          // Dragon Touch Tablet
        ],
        [[x, "Dragon Touch"], v, [C, M]],
        [
          /\b(ns-?\w{0,9}) b/i
          // Insignia Tablets
        ],
        [v, [x, "Insignia"], [C, M]],
        [
          /\b((nxa|next)-?\w{0,9}) b/i
          // NextBook Tablets
        ],
        [v, [x, "NextBook"], [C, M]],
        [
          /\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i
          // Voice Xtreme Phones
        ],
        [[x, "Voice"], v, [C, D]],
        [
          /\b(lvtel\-)?(v1[12]) b/i
          // LvTel Phones
        ],
        [[x, "LvTel"], v, [C, D]],
        [
          /\b(ph-1) /i
          // Essential PH-1
        ],
        [v, [x, "Essential"], [C, D]],
        [
          /\b(v(100md|700na|7011|917g).*\b) b/i
          // Envizen Tablets
        ],
        [v, [x, "Envizen"], [C, M]],
        [
          /\b(trio[-\w\. ]+) b/i
          // MachSpeed Tablets
        ],
        [v, [x, "MachSpeed"], [C, M]],
        [
          /\btu_(1491) b/i
          // Rotor Tablets
        ],
        [v, [x, "Rotor"], [C, M]],
        [
          /(shield[\w ]+) b/i
          // Nvidia Shield Tablets
        ],
        [v, [x, "Nvidia"], [C, M]],
        [
          /(sprint) (\w+)/i
          // Sprint Phones
        ],
        [x, v, [C, D]],
        [
          /(kin\.[onetw]{3})/i
          // Microsoft Kin
        ],
        [[v, /\./g, " "], [x, be], [C, D]],
        [
          /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i
          // Zebra
        ],
        [v, [x, st], [C, M]],
        [
          /droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i
        ],
        [v, [x, st], [C, D]],
        [
          ///////////////////
          // SMARTTVS
          ///////////////////
          /smart-tv.+(samsung)/i
          // Samsung
        ],
        [x, [C, L]],
        [
          /hbbtv.+maple;(\d+)/i
        ],
        [[v, /^/, "SmartTV"], [x, Ee], [C, L]],
        [
          /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i
          // LG SmartTV
        ],
        [[x, oe], [C, L]],
        [
          /(apple) ?tv/i
          // Apple TV
        ],
        [x, [v, H + " TV"], [C, L]],
        [
          /crkey/i
          // Google Chromecast
        ],
        [[v, ie + "cast"], [x, J], [C, L]],
        [
          /droid.+aft(\w+)( bui|\))/i
          // Fire TV
        ],
        [v, [x, z], [C, L]],
        [
          /\(dtv[\);].+(aquos)/i,
          /(aquos-tv[\w ]+)\)/i
          // Sharp
        ],
        [v, [x, Se], [C, L]],
        [
          /(bravia[\w ]+)( bui|\))/i
          // Sony
        ],
        [v, [x, Me], [C, L]],
        [
          /(mitv-\w{5}) bui/i
          // Xiaomi
        ],
        [v, [x, Fe], [C, L]],
        [
          /Hbbtv.*(technisat) (.*);/i
          // TechniSAT
        ],
        [x, v, [C, L]],
        [
          /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
          // Roku
          /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i
          // HbbTV devices
        ],
        [[x, Pn], [v, Pn], [C, L]],
        [
          /\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i
          // SmartTV from Unidentified Vendors
        ],
        [[C, L]],
        [
          ///////////////////
          // CONSOLES
          ///////////////////
          /(ouya)/i,
          // Ouya
          /(nintendo) ([wids3utch]+)/i
          // Nintendo
        ],
        [x, v, [C, I]],
        [
          /droid.+; (shield) bui/i
          // Nvidia
        ],
        [v, [x, "Nvidia"], [C, I]],
        [
          /(playstation [345portablevi]+)/i
          // Playstation
        ],
        [v, [x, Me], [C, I]],
        [
          /\b(xbox(?: one)?(?!; xbox))[\); ]/i
          // Microsoft Xbox
        ],
        [v, [x, be], [C, I]],
        [
          ///////////////////
          // WEARABLES
          ///////////////////
          /((pebble))app/i
          // Pebble
        ],
        [x, v, [C, j]],
        [
          /(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i
          // Apple Watch
        ],
        [v, [x, H], [C, j]],
        [
          /droid.+; (glass) \d/i
          // Google Glass
        ],
        [v, [x, J], [C, j]],
        [
          /droid.+; (wt63?0{2,3})\)/i
        ],
        [v, [x, st], [C, j]],
        [
          /(quest( 2| pro)?)/i
          // Oculus Quest
        ],
        [v, [x, mt], [C, j]],
        [
          ///////////////////
          // EMBEDDED
          ///////////////////
          /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i
          // Tesla
        ],
        [x, [C, F]],
        [
          /(aeobc)\b/i
          // Echo Dot
        ],
        [v, [x, z], [C, F]],
        [
          ////////////////////
          // MIXED (GENERIC)
          ///////////////////
          /droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i
          // Android Phones from Unidentified Vendors
        ],
        [v, [C, D]],
        [
          /droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i
          // Android Tablets from Unidentified Vendors
        ],
        [v, [C, M]],
        [
          /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i
          // Unidentifiable Tablet
        ],
        [[C, M]],
        [
          /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i
          // Unidentifiable Mobile
        ],
        [[C, D]],
        [
          /(android[-\w\. ]{0,9});.+buil/i
          // Generic Android Device
        ],
        [v, [x, "Generic"]]
      ],
      engine: [
        [
          /windows.+ edge\/([\w\.]+)/i
          // EdgeHTML
        ],
        [A, [w, X + "HTML"]],
        [
          /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i
          // Blink
        ],
        [A, [w, "Blink"]],
        [
          /(presto)\/([\w\.]+)/i,
          // Presto
          /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i,
          // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna
          /ekioh(flow)\/([\w\.]+)/i,
          // Flow
          /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
          // KHTML/Tasman/Links
          /(icab)[\/ ]([23]\.[\d\.]+)/i,
          // iCab
          /\b(libweb)/i
        ],
        [w, A],
        [
          /rv\:([\w\.]{1,9})\b.+(gecko)/i
          // Gecko
        ],
        [A, w]
      ],
      os: [
        [
          // Windows
          /microsoft (windows) (vista|xp)/i
          // Windows (iTunes)
        ],
        [w, A],
        [
          /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i
          // Windows Phone
        ],
        [w, [A, tr, ar]],
        [
          /windows nt 6\.2; (arm)/i,
          // Windows RT
          /windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i,
          /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i
        ],
        [[A, tr, ar], [w, "Windows"]],
        [
          // iOS/macOS
          /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,
          // iOS
          /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i,
          /cfnetwork\/.+darwin/i
        ],
        [[A, /_/g, "."], [w, "iOS"]],
        [
          /(mac os x) ?([\w\. ]*)/i,
          /(macintosh|mac_powerpc\b)(?!.+haiku)/i
          // Mac OS
        ],
        [[w, Ut], [A, /_/g, "."]],
        [
          // Mobile OSes
          /droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i
          // Android-x86/HarmonyOS
        ],
        [A, w],
        [
          // Android/WebOS/QNX/Bada/RIM/Maemo/MeeGo/Sailfish OS
          /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i,
          /(blackberry)\w*\/([\w\.]*)/i,
          // Blackberry
          /(tizen|kaios)[\/ ]([\w\.]+)/i,
          // Tizen/KaiOS
          /\((series40);/i
          // Series 40
        ],
        [w, A],
        [
          /\(bb(10);/i
          // BlackBerry 10
        ],
        [A, [w, Y]],
        [
          /(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i
          // Symbian
        ],
        [A, [w, "Symbian"]],
        [
          /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i
          // Firefox OS
        ],
        [A, [w, Z + " OS"]],
        [
          /web0s;.+rt(tv)/i,
          /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i
          // WebOS
        ],
        [A, [w, "webOS"]],
        [
          /watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i
          // watchOS
        ],
        [A, [w, "watchOS"]],
        [
          // Google Chromecast
          /crkey\/([\d\.]+)/i
          // Google Chromecast
        ],
        [A, [w, ie + "cast"]],
        [
          /(cros) [\w]+(?:\)| ([\w\.]+)\b)/i
          // Chromium OS
        ],
        [[w, yt], A],
        [
          // Smart TVs
          /panasonic;(viera)/i,
          // Panasonic Viera
          /(netrange)mmh/i,
          // Netrange
          /(nettv)\/(\d+\.[\w\.]+)/i,
          // NetTV
          // Console
          /(nintendo|playstation) ([wids345portablevuch]+)/i,
          // Nintendo/Playstation
          /(xbox); +xbox ([^\);]+)/i,
          // Microsoft Xbox (360, One, X, S, Series X, Series S)
          // Other
          /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
          // Joli/Palm
          /(mint)[\/\(\) ]?(\w*)/i,
          // Mint
          /(mageia|vectorlinux)[; ]/i,
          // Mageia/VectorLinux
          /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
          // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire
          /(hurd|linux) ?([\w\.]*)/i,
          // Hurd/Linux
          /(gnu) ?([\w\.]*)/i,
          // GNU
          /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
          // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly
          /(haiku) (\w+)/i
          // Haiku
        ],
        [w, A],
        [
          /(sunos) ?([\w\.\d]*)/i
          // Solaris
        ],
        [[w, "Solaris"], A],
        [
          /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
          // Solaris
          /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
          // AIX
          /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i,
          // BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX/SerenityOS
          /(unix) ?([\w\.]*)/i
          // UNIX
        ],
        [w, A]
      ]
    }, Un = function(Tt, qt) {
      if (typeof Tt === f && (qt = Tt, Tt = r), !(this instanceof Un))
        return new Un(Tt, qt).getResult();
      var gt = typeof n !== u && n.navigator ? n.navigator : r, Ht = Tt || (gt && gt.userAgent ? gt.userAgent : o), br = gt && gt.userAgentData ? gt.userAgentData : r, ne = qt ? hn(Cr, qt) : Cr, N = gt && gt.userAgent == Ht;
      return this.getBrowser = function() {
        var U = {};
        return U[w] = r, U[A] = r, Fn.call(U, Ht, ne.browser), U[y] = zt(U[A]), N && gt && gt.brave && typeof gt.brave.isBrave == c && (U[w] = "Brave"), U;
      }, this.getCPU = function() {
        var U = {};
        return U[R] = r, Fn.call(U, Ht, ne.cpu), U;
      }, this.getDevice = function() {
        var U = {};
        return U[x] = r, U[v] = r, U[C] = r, Fn.call(U, Ht, ne.device), N && !U[C] && br && br.mobile && (U[C] = D), N && U[v] == "Macintosh" && gt && typeof gt.standalone !== u && gt.maxTouchPoints && gt.maxTouchPoints > 2 && (U[v] = "iPad", U[C] = M), U;
      }, this.getEngine = function() {
        var U = {};
        return U[w] = r, U[A] = r, Fn.call(U, Ht, ne.engine), U;
      }, this.getOS = function() {
        var U = {};
        return U[w] = r, U[A] = r, Fn.call(U, Ht, ne.os), N && !U[w] && br && br.platform != "Unknown" && (U[w] = br.platform.replace(/chrome os/i, yt).replace(/macos/i, Ut)), U;
      }, this.getResult = function() {
        return {
          ua: this.getUA(),
          browser: this.getBrowser(),
          engine: this.getEngine(),
          os: this.getOS(),
          device: this.getDevice(),
          cpu: this.getCPU()
        };
      }, this.getUA = function() {
        return Ht;
      }, this.setUA = function(U) {
        return Ht = typeof U === p && U.length > O ? Pn(U, O) : U, this;
      }, this.setUA(Ht), this;
    };
    Un.VERSION = i, Un.BROWSER = wn([w, A, y]), Un.CPU = wn([R]), Un.DEVICE = wn([v, x, C, I, D, L, M, j, F]), Un.ENGINE = Un.OS = wn([w, A]), e.exports && (t = e.exports = Un), t.UAParser = Un;
    var $n = typeof n !== u && (n.jQuery || n.Zepto);
    if ($n && !$n.ua) {
      var gr = new Un();
      $n.ua = gr.getResult(), $n.ua.get = function() {
        return gr.getUA();
      }, $n.ua.set = function(Tt) {
        gr.setUA(Tt);
        var qt = gr.getResult();
        for (var gt in qt)
          $n.ua[gt] = qt[gt];
      };
    }
  })(typeof window == "object" ? window : v1);
})(W5, W5.exports);
var Qwe = W5.exports, XC = {}, Xwe = function() {
  return typeof Promise == "function" && Promise.prototype && Promise.prototype.then;
}, $W = {}, pl = {};
let ZM;
const Jwe = [
  0,
  // Not used
  26,
  44,
  70,
  100,
  134,
  172,
  196,
  242,
  292,
  346,
  404,
  466,
  532,
  581,
  655,
  733,
  815,
  901,
  991,
  1085,
  1156,
  1258,
  1364,
  1474,
  1588,
  1706,
  1828,
  1921,
  2051,
  2185,
  2323,
  2465,
  2611,
  2761,
  2876,
  3034,
  3196,
  3362,
  3532,
  3706
];
pl.getSymbolSize = function(t) {
  if (!t) throw new Error('"version" cannot be null or undefined');
  if (t < 1 || t > 40) throw new Error('"version" should be in range from 1 to 40');
  return t * 4 + 17;
};
pl.getSymbolTotalCodewords = function(t) {
  return Jwe[t];
};
pl.getBCHDigit = function(e) {
  let t = 0;
  for (; e !== 0; )
    t++, e >>>= 1;
  return t;
};
pl.setToSJISFunction = function(t) {
  if (typeof t != "function")
    throw new Error('"toSJISFunc" is not a valid function.');
  ZM = t;
};
pl.isKanjiModeEnabled = function() {
  return typeof ZM < "u";
};
pl.toSJIS = function(t) {
  return ZM(t);
};
var Z8 = {};
(function(e) {
  e.L = { bit: 1 }, e.M = { bit: 0 }, e.Q = { bit: 3 }, e.H = { bit: 2 };
  function t(n) {
    if (typeof n != "string")
      throw new Error("Param is not a string");
    switch (n.toLowerCase()) {
      case "l":
      case "low":
        return e.L;
      case "m":
      case "medium":
        return e.M;
      case "q":
      case "quartile":
        return e.Q;
      case "h":
      case "high":
        return e.H;
      default:
        throw new Error("Unknown EC Level: " + n);
    }
  }
  e.isValid = function(r) {
    return r && typeof r.bit < "u" && r.bit >= 0 && r.bit < 4;
  }, e.from = function(r, i) {
    if (e.isValid(r))
      return r;
    try {
      return t(r);
    } catch {
      return i;
    }
  };
})(Z8);
function HW() {
  this.buffer = [], this.length = 0;
}
HW.prototype = {
  get: function(e) {
    const t = Math.floor(e / 8);
    return (this.buffer[t] >>> 7 - e % 8 & 1) === 1;
  },
  put: function(e, t) {
    for (let n = 0; n < t; n++)
      this.putBit((e >>> t - n - 1 & 1) === 1);
  },
  getLengthInBits: function() {
    return this.length;
  },
  putBit: function(e) {
    const t = Math.floor(this.length / 8);
    this.buffer.length <= t && this.buffer.push(0), e && (this.buffer[t] |= 128 >>> this.length % 8), this.length++;
  }
};
var Zwe = HW;
function JC(e) {
  if (!e || e < 1)
    throw new Error("BitMatrix size must be defined and greater than 0");
  this.size = e, this.data = new Uint8Array(e * e), this.reservedBit = new Uint8Array(e * e);
}
JC.prototype.set = function(e, t, n, r) {
  const i = e * this.size + t;
  this.data[i] = n, r && (this.reservedBit[i] = !0);
};
JC.prototype.get = function(e, t) {
  return this.data[e * this.size + t];
};
JC.prototype.xor = function(e, t, n) {
  this.data[e * this.size + t] ^= n;
};
JC.prototype.isReserved = function(e, t) {
  return this.reservedBit[e * this.size + t];
};
var e1e = JC, qW = {};
(function(e) {
  const t = pl.getSymbolSize;
  e.getRowColCoords = function(r) {
    if (r === 1) return [];
    const i = Math.floor(r / 7) + 2, o = t(r), s = o === 145 ? 26 : Math.ceil((o - 13) / (2 * i - 2)) * 2, c = [o - 7];
    for (let u = 1; u < i - 1; u++)
      c[u] = c[u - 1] - s;
    return c.push(6), c.reverse();
  }, e.getPositions = function(r) {
    const i = [], o = e.getRowColCoords(r), s = o.length;
    for (let c = 0; c < s; c++)
      for (let u = 0; u < s; u++)
        c === 0 && u === 0 || // top-left
        c === 0 && u === s - 1 || // bottom-left
        c === s - 1 && u === 0 || i.push([o[c], o[u]]);
    return i;
  };
})(qW);
var WW = {};
const t1e = pl.getSymbolSize, lU = 7;
WW.getPositions = function(t) {
  const n = t1e(t);
  return [
    // top-left
    [0, 0],
    // top-right
    [n - lU, 0],
    // bottom-left
    [0, n - lU]
  ];
};
var GW = {};
(function(e) {
  e.Patterns = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7
  };
  const t = {
    N1: 3,
    N2: 3,
    N3: 40,
    N4: 10
  };
  e.isValid = function(i) {
    return i != null && i !== "" && !isNaN(i) && i >= 0 && i <= 7;
  }, e.from = function(i) {
    return e.isValid(i) ? parseInt(i, 10) : void 0;
  }, e.getPenaltyN1 = function(i) {
    const o = i.size;
    let s = 0, c = 0, u = 0, f = null, p = null;
    for (let y = 0; y < o; y++) {
      c = u = 0, f = p = null;
      for (let v = 0; v < o; v++) {
        let w = i.get(y, v);
        w === f ? c++ : (c >= 5 && (s += t.N1 + (c - 5)), f = w, c = 1), w = i.get(v, y), w === p ? u++ : (u >= 5 && (s += t.N1 + (u - 5)), p = w, u = 1);
      }
      c >= 5 && (s += t.N1 + (c - 5)), u >= 5 && (s += t.N1 + (u - 5));
    }
    return s;
  }, e.getPenaltyN2 = function(i) {
    const o = i.size;
    let s = 0;
    for (let c = 0; c < o - 1; c++)
      for (let u = 0; u < o - 1; u++) {
        const f = i.get(c, u) + i.get(c, u + 1) + i.get(c + 1, u) + i.get(c + 1, u + 1);
        (f === 4 || f === 0) && s++;
      }
    return s * t.N2;
  }, e.getPenaltyN3 = function(i) {
    const o = i.size;
    let s = 0, c = 0, u = 0;
    for (let f = 0; f < o; f++) {
      c = u = 0;
      for (let p = 0; p < o; p++)
        c = c << 1 & 2047 | i.get(f, p), p >= 10 && (c === 1488 || c === 93) && s++, u = u << 1 & 2047 | i.get(p, f), p >= 10 && (u === 1488 || u === 93) && s++;
    }
    return s * t.N3;
  }, e.getPenaltyN4 = function(i) {
    let o = 0;
    const s = i.data.length;
    for (let u = 0; u < s; u++) o += i.data[u];
    return Math.abs(Math.ceil(o * 100 / s / 5) - 10) * t.N4;
  };
  function n(r, i, o) {
    switch (r) {
      case e.Patterns.PATTERN000:
        return (i + o) % 2 === 0;
      case e.Patterns.PATTERN001:
        return i % 2 === 0;
      case e.Patterns.PATTERN010:
        return o % 3 === 0;
      case e.Patterns.PATTERN011:
        return (i + o) % 3 === 0;
      case e.Patterns.PATTERN100:
        return (Math.floor(i / 2) + Math.floor(o / 3)) % 2 === 0;
      case e.Patterns.PATTERN101:
        return i * o % 2 + i * o % 3 === 0;
      case e.Patterns.PATTERN110:
        return (i * o % 2 + i * o % 3) % 2 === 0;
      case e.Patterns.PATTERN111:
        return (i * o % 3 + (i + o) % 2) % 2 === 0;
      default:
        throw new Error("bad maskPattern:" + r);
    }
  }
  e.applyMask = function(i, o) {
    const s = o.size;
    for (let c = 0; c < s; c++)
      for (let u = 0; u < s; u++)
        o.isReserved(u, c) || o.xor(u, c, n(i, u, c));
  }, e.getBestMask = function(i, o) {
    const s = Object.keys(e.Patterns).length;
    let c = 0, u = 1 / 0;
    for (let f = 0; f < s; f++) {
      o(f), e.applyMask(f, i);
      const p = e.getPenaltyN1(i) + e.getPenaltyN2(i) + e.getPenaltyN3(i) + e.getPenaltyN4(i);
      e.applyMask(f, i), p < u && (u = p, c = f);
    }
    return c;
  };
})(GW);
var eA = {};
const Lh = Z8, Ik = [
  // L  M  Q  H
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  2,
  1,
  2,
  2,
  4,
  1,
  2,
  4,
  4,
  2,
  4,
  4,
  4,
  2,
  4,
  6,
  5,
  2,
  4,
  6,
  6,
  2,
  5,
  8,
  8,
  4,
  5,
  8,
  8,
  4,
  5,
  8,
  11,
  4,
  8,
  10,
  11,
  4,
  9,
  12,
  16,
  4,
  9,
  16,
  16,
  6,
  10,
  12,
  18,
  6,
  10,
  17,
  16,
  6,
  11,
  16,
  19,
  6,
  13,
  18,
  21,
  7,
  14,
  21,
  25,
  8,
  16,
  20,
  25,
  8,
  17,
  23,
  25,
  9,
  17,
  23,
  34,
  9,
  18,
  25,
  30,
  10,
  20,
  27,
  32,
  12,
  21,
  29,
  35,
  12,
  23,
  34,
  37,
  12,
  25,
  34,
  40,
  13,
  26,
  35,
  42,
  14,
  28,
  38,
  45,
  15,
  29,
  40,
  48,
  16,
  31,
  43,
  51,
  17,
  33,
  45,
  54,
  18,
  35,
  48,
  57,
  19,
  37,
  51,
  60,
  19,
  38,
  53,
  63,
  20,
  40,
  56,
  66,
  21,
  43,
  59,
  70,
  22,
  45,
  62,
  74,
  24,
  47,
  65,
  77,
  25,
  49,
  68,
  81
], Dk = [
  // L  M  Q  H
  7,
  10,
  13,
  17,
  10,
  16,
  22,
  28,
  15,
  26,
  36,
  44,
  20,
  36,
  52,
  64,
  26,
  48,
  72,
  88,
  36,
  64,
  96,
  112,
  40,
  72,
  108,
  130,
  48,
  88,
  132,
  156,
  60,
  110,
  160,
  192,
  72,
  130,
  192,
  224,
  80,
  150,
  224,
  264,
  96,
  176,
  260,
  308,
  104,
  198,
  288,
  352,
  120,
  216,
  320,
  384,
  132,
  240,
  360,
  432,
  144,
  280,
  408,
  480,
  168,
  308,
  448,
  532,
  180,
  338,
  504,
  588,
  196,
  364,
  546,
  650,
  224,
  416,
  600,
  700,
  224,
  442,
  644,
  750,
  252,
  476,
  690,
  816,
  270,
  504,
  750,
  900,
  300,
  560,
  810,
  960,
  312,
  588,
  870,
  1050,
  336,
  644,
  952,
  1110,
  360,
  700,
  1020,
  1200,
  390,
  728,
  1050,
  1260,
  420,
  784,
  1140,
  1350,
  450,
  812,
  1200,
  1440,
  480,
  868,
  1290,
  1530,
  510,
  924,
  1350,
  1620,
  540,
  980,
  1440,
  1710,
  570,
  1036,
  1530,
  1800,
  570,
  1064,
  1590,
  1890,
  600,
  1120,
  1680,
  1980,
  630,
  1204,
  1770,
  2100,
  660,
  1260,
  1860,
  2220,
  720,
  1316,
  1950,
  2310,
  750,
  1372,
  2040,
  2430
];
eA.getBlocksCount = function(t, n) {
  switch (n) {
    case Lh.L:
      return Ik[(t - 1) * 4 + 0];
    case Lh.M:
      return Ik[(t - 1) * 4 + 1];
    case Lh.Q:
      return Ik[(t - 1) * 4 + 2];
    case Lh.H:
      return Ik[(t - 1) * 4 + 3];
    default:
      return;
  }
};
eA.getTotalCodewordsCount = function(t, n) {
  switch (n) {
    case Lh.L:
      return Dk[(t - 1) * 4 + 0];
    case Lh.M:
      return Dk[(t - 1) * 4 + 1];
    case Lh.Q:
      return Dk[(t - 1) * 4 + 2];
    case Lh.H:
      return Dk[(t - 1) * 4 + 3];
    default:
      return;
  }
};
var KW = {}, tA = {};
const N1 = new Uint8Array(512), $4 = new Uint8Array(256);
(function() {
  let t = 1;
  for (let n = 0; n < 255; n++)
    N1[n] = t, $4[t] = n, t <<= 1, t & 256 && (t ^= 285);
  for (let n = 255; n < 512; n++)
    N1[n] = N1[n - 255];
})();
tA.log = function(t) {
  if (t < 1) throw new Error("log(" + t + ")");
  return $4[t];
};
tA.exp = function(t) {
  return N1[t];
};
tA.mul = function(t, n) {
  return t === 0 || n === 0 ? 0 : N1[$4[t] + $4[n]];
};
(function(e) {
  const t = tA;
  e.mul = function(r, i) {
    const o = new Uint8Array(r.length + i.length - 1);
    for (let s = 0; s < r.length; s++)
      for (let c = 0; c < i.length; c++)
        o[s + c] ^= t.mul(r[s], i[c]);
    return o;
  }, e.mod = function(r, i) {
    let o = new Uint8Array(r);
    for (; o.length - i.length >= 0; ) {
      const s = o[0];
      for (let u = 0; u < i.length; u++)
        o[u] ^= t.mul(i[u], s);
      let c = 0;
      for (; c < o.length && o[c] === 0; ) c++;
      o = o.slice(c);
    }
    return o;
  }, e.generateECPolynomial = function(r) {
    let i = new Uint8Array([1]);
    for (let o = 0; o < r; o++)
      i = e.mul(i, new Uint8Array([1, t.exp(o)]));
    return i;
  };
})(KW);
const YW = KW;
function eP(e) {
  this.genPoly = void 0, this.degree = e, this.degree && this.initialize(this.degree);
}
eP.prototype.initialize = function(t) {
  this.degree = t, this.genPoly = YW.generateECPolynomial(this.degree);
};
eP.prototype.encode = function(t) {
  if (!this.genPoly)
    throw new Error("Encoder not initialized");
  const n = new Uint8Array(t.length + this.degree);
  n.set(t);
  const r = YW.mod(n, this.genPoly), i = this.degree - r.length;
  if (i > 0) {
    const o = new Uint8Array(this.degree);
    return o.set(r, i), o;
  }
  return r;
};
var n1e = eP, QW = {}, lp = {}, tP = {};
tP.isValid = function(t) {
  return !isNaN(t) && t >= 1 && t <= 40;
};
var Gu = {};
const XW = "[0-9]+", r1e = "[A-Z $%*+\\-./:]+";
let dC = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
dC = dC.replace(/u/g, "\\u");
const i1e = "(?:(?![A-Z0-9 $%*+\\-./:]|" + dC + `)(?:.|[\r
]))+`;
Gu.KANJI = new RegExp(dC, "g");
Gu.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
Gu.BYTE = new RegExp(i1e, "g");
Gu.NUMERIC = new RegExp(XW, "g");
Gu.ALPHANUMERIC = new RegExp(r1e, "g");
const o1e = new RegExp("^" + dC + "$"), a1e = new RegExp("^" + XW + "$"), s1e = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
Gu.testKanji = function(t) {
  return o1e.test(t);
};
Gu.testNumeric = function(t) {
  return a1e.test(t);
};
Gu.testAlphanumeric = function(t) {
  return s1e.test(t);
};
(function(e) {
  const t = tP, n = Gu;
  e.NUMERIC = {
    id: "Numeric",
    bit: 1,
    ccBits: [10, 12, 14]
  }, e.ALPHANUMERIC = {
    id: "Alphanumeric",
    bit: 2,
    ccBits: [9, 11, 13]
  }, e.BYTE = {
    id: "Byte",
    bit: 4,
    ccBits: [8, 16, 16]
  }, e.KANJI = {
    id: "Kanji",
    bit: 8,
    ccBits: [8, 10, 12]
  }, e.MIXED = {
    bit: -1
  }, e.getCharCountIndicator = function(o, s) {
    if (!o.ccBits) throw new Error("Invalid mode: " + o);
    if (!t.isValid(s))
      throw new Error("Invalid version: " + s);
    return s >= 1 && s < 10 ? o.ccBits[0] : s < 27 ? o.ccBits[1] : o.ccBits[2];
  }, e.getBestModeForData = function(o) {
    return n.testNumeric(o) ? e.NUMERIC : n.testAlphanumeric(o) ? e.ALPHANUMERIC : n.testKanji(o) ? e.KANJI : e.BYTE;
  }, e.toString = function(o) {
    if (o && o.id) return o.id;
    throw new Error("Invalid mode");
  }, e.isValid = function(o) {
    return o && o.bit && o.ccBits;
  };
  function r(i) {
    if (typeof i != "string")
      throw new Error("Param is not a string");
    switch (i.toLowerCase()) {
      case "numeric":
        return e.NUMERIC;
      case "alphanumeric":
        return e.ALPHANUMERIC;
      case "kanji":
        return e.KANJI;
      case "byte":
        return e.BYTE;
      default:
        throw new Error("Unknown mode: " + i);
    }
  }
  e.from = function(o, s) {
    if (e.isValid(o))
      return o;
    try {
      return r(o);
    } catch {
      return s;
    }
  };
})(lp);
(function(e) {
  const t = pl, n = eA, r = Z8, i = lp, o = tP, s = 7973, c = t.getBCHDigit(s);
  function u(v, w, C) {
    for (let x = 1; x <= 40; x++)
      if (w <= e.getCapacity(x, C, v))
        return x;
  }
  function f(v, w) {
    return i.getCharCountIndicator(v, w) + 4;
  }
  function p(v, w) {
    let C = 0;
    return v.forEach(function(x) {
      const A = f(x.mode, w);
      C += A + x.getBitsLength();
    }), C;
  }
  function y(v, w) {
    for (let C = 1; C <= 40; C++)
      if (p(v, C) <= e.getCapacity(C, w, i.MIXED))
        return C;
  }
  e.from = function(w, C) {
    return o.isValid(w) ? parseInt(w, 10) : C;
  }, e.getCapacity = function(w, C, x) {
    if (!o.isValid(w))
      throw new Error("Invalid QR Code version");
    typeof x > "u" && (x = i.BYTE);
    const A = t.getSymbolTotalCodewords(w), R = n.getTotalCodewordsCount(w, C), I = (A - R) * 8;
    if (x === i.MIXED) return I;
    const D = I - f(x, w);
    switch (x) {
      case i.NUMERIC:
        return Math.floor(D / 10 * 3);
      case i.ALPHANUMERIC:
        return Math.floor(D / 11 * 2);
      case i.KANJI:
        return Math.floor(D / 13);
      case i.BYTE:
      default:
        return Math.floor(D / 8);
    }
  }, e.getBestVersionForData = function(w, C) {
    let x;
    const A = r.from(C, r.M);
    if (Array.isArray(w)) {
      if (w.length > 1)
        return y(w, A);
      if (w.length === 0)
        return 1;
      x = w[0];
    } else
      x = w;
    return u(x.mode, x.getLength(), A);
  }, e.getEncodedBits = function(w) {
    if (!o.isValid(w) || w < 7)
      throw new Error("Invalid QR Code version");
    let C = w << 12;
    for (; t.getBCHDigit(C) - c >= 0; )
      C ^= s << t.getBCHDigit(C) - c;
    return w << 12 | C;
  };
})(QW);
var JW = {};
const G5 = pl, ZW = 1335, l1e = 21522, cU = G5.getBCHDigit(ZW);
JW.getEncodedBits = function(t, n) {
  const r = t.bit << 3 | n;
  let i = r << 10;
  for (; G5.getBCHDigit(i) - cU >= 0; )
    i ^= ZW << G5.getBCHDigit(i) - cU;
  return (r << 10 | i) ^ l1e;
};
var eG = {};
const c1e = lp;
function lb(e) {
  this.mode = c1e.NUMERIC, this.data = e.toString();
}
lb.getBitsLength = function(t) {
  return 10 * Math.floor(t / 3) + (t % 3 ? t % 3 * 3 + 1 : 0);
};
lb.prototype.getLength = function() {
  return this.data.length;
};
lb.prototype.getBitsLength = function() {
  return lb.getBitsLength(this.data.length);
};
lb.prototype.write = function(t) {
  let n, r, i;
  for (n = 0; n + 3 <= this.data.length; n += 3)
    r = this.data.substr(n, 3), i = parseInt(r, 10), t.put(i, 10);
  const o = this.data.length - n;
  o > 0 && (r = this.data.substr(n), i = parseInt(r, 10), t.put(i, o * 3 + 1));
};
var u1e = lb;
const d1e = lp, wO = [
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  " ",
  "$",
  "%",
  "*",
  "+",
  "-",
  ".",
  "/",
  ":"
];
function cb(e) {
  this.mode = d1e.ALPHANUMERIC, this.data = e;
}
cb.getBitsLength = function(t) {
  return 11 * Math.floor(t / 2) + 6 * (t % 2);
};
cb.prototype.getLength = function() {
  return this.data.length;
};
cb.prototype.getBitsLength = function() {
  return cb.getBitsLength(this.data.length);
};
cb.prototype.write = function(t) {
  let n;
  for (n = 0; n + 2 <= this.data.length; n += 2) {
    let r = wO.indexOf(this.data[n]) * 45;
    r += wO.indexOf(this.data[n + 1]), t.put(r, 11);
  }
  this.data.length % 2 && t.put(wO.indexOf(this.data[n]), 6);
};
var f1e = cb, h1e = function(t) {
  for (var n = [], r = t.length, i = 0; i < r; i++) {
    var o = t.charCodeAt(i);
    if (o >= 55296 && o <= 56319 && r > i + 1) {
      var s = t.charCodeAt(i + 1);
      s >= 56320 && s <= 57343 && (o = (o - 55296) * 1024 + s - 56320 + 65536, i += 1);
    }
    if (o < 128) {
      n.push(o);
      continue;
    }
    if (o < 2048) {
      n.push(o >> 6 | 192), n.push(o & 63 | 128);
      continue;
    }
    if (o < 55296 || o >= 57344 && o < 65536) {
      n.push(o >> 12 | 224), n.push(o >> 6 & 63 | 128), n.push(o & 63 | 128);
      continue;
    }
    if (o >= 65536 && o <= 1114111) {
      n.push(o >> 18 | 240), n.push(o >> 12 & 63 | 128), n.push(o >> 6 & 63 | 128), n.push(o & 63 | 128);
      continue;
    }
    n.push(239, 191, 189);
  }
  return new Uint8Array(n).buffer;
};
const p1e = h1e, m1e = lp;
function ub(e) {
  this.mode = m1e.BYTE, typeof e == "string" && (e = p1e(e)), this.data = new Uint8Array(e);
}
ub.getBitsLength = function(t) {
  return t * 8;
};
ub.prototype.getLength = function() {
  return this.data.length;
};
ub.prototype.getBitsLength = function() {
  return ub.getBitsLength(this.data.length);
};
ub.prototype.write = function(e) {
  for (let t = 0, n = this.data.length; t < n; t++)
    e.put(this.data[t], 8);
};
var y1e = ub;
const v1e = lp, g1e = pl;
function db(e) {
  this.mode = v1e.KANJI, this.data = e;
}
db.getBitsLength = function(t) {
  return t * 13;
};
db.prototype.getLength = function() {
  return this.data.length;
};
db.prototype.getBitsLength = function() {
  return db.getBitsLength(this.data.length);
};
db.prototype.write = function(e) {
  let t;
  for (t = 0; t < this.data.length; t++) {
    let n = g1e.toSJIS(this.data[t]);
    if (n >= 33088 && n <= 40956)
      n -= 33088;
    else if (n >= 57408 && n <= 60351)
      n -= 49472;
    else
      throw new Error(
        "Invalid SJIS character: " + this.data[t] + `
Make sure your charset is UTF-8`
      );
    n = (n >>> 8 & 255) * 192 + (n & 255), e.put(n, 13);
  }
};
var b1e = db, tG = { exports: {} };
(function(e) {
  var t = {
    single_source_shortest_paths: function(n, r, i) {
      var o = {}, s = {};
      s[r] = 0;
      var c = t.PriorityQueue.make();
      c.push(r, 0);
      for (var u, f, p, y, v, w, C, x, A; !c.empty(); ) {
        u = c.pop(), f = u.value, y = u.cost, v = n[f] || {};
        for (p in v)
          v.hasOwnProperty(p) && (w = v[p], C = y + w, x = s[p], A = typeof s[p] > "u", (A || x > C) && (s[p] = C, c.push(p, C), o[p] = f));
      }
      if (typeof i < "u" && typeof s[i] > "u") {
        var R = ["Could not find a path from ", r, " to ", i, "."].join("");
        throw new Error(R);
      }
      return o;
    },
    extract_shortest_path_from_predecessor_list: function(n, r) {
      for (var i = [], o = r; o; )
        i.push(o), n[o], o = n[o];
      return i.reverse(), i;
    },
    find_path: function(n, r, i) {
      var o = t.single_source_shortest_paths(n, r, i);
      return t.extract_shortest_path_from_predecessor_list(
        o,
        i
      );
    },
    /**
     * A very naive priority queue implementation.
     */
    PriorityQueue: {
      make: function(n) {
        var r = t.PriorityQueue, i = {}, o;
        n = n || {};
        for (o in r)
          r.hasOwnProperty(o) && (i[o] = r[o]);
        return i.queue = [], i.sorter = n.sorter || r.default_sorter, i;
      },
      default_sorter: function(n, r) {
        return n.cost - r.cost;
      },
      /**
       * Add a new item to the queue and ensure the highest priority element
       * is at the front of the queue.
       */
      push: function(n, r) {
        var i = { value: n, cost: r };
        this.queue.push(i), this.queue.sort(this.sorter);
      },
      /**
       * Return the highest priority element in the queue.
       */
      pop: function() {
        return this.queue.shift();
      },
      empty: function() {
        return this.queue.length === 0;
      }
    }
  };
  e.exports = t;
})(tG);
var w1e = tG.exports;
(function(e) {
  const t = lp, n = u1e, r = f1e, i = y1e, o = b1e, s = Gu, c = pl, u = w1e;
  function f(R) {
    return unescape(encodeURIComponent(R)).length;
  }
  function p(R, I, D) {
    const M = [];
    let L;
    for (; (L = R.exec(D)) !== null; )
      M.push({
        data: L[0],
        index: L.index,
        mode: I,
        length: L[0].length
      });
    return M;
  }
  function y(R) {
    const I = p(s.NUMERIC, t.NUMERIC, R), D = p(s.ALPHANUMERIC, t.ALPHANUMERIC, R);
    let M, L;
    return c.isKanjiModeEnabled() ? (M = p(s.BYTE, t.BYTE, R), L = p(s.KANJI, t.KANJI, R)) : (M = p(s.BYTE_KANJI, t.BYTE, R), L = []), I.concat(D, M, L).sort(function(F, O) {
      return F.index - O.index;
    }).map(function(F) {
      return {
        data: F.data,
        mode: F.mode,
        length: F.length
      };
    });
  }
  function v(R, I) {
    switch (I) {
      case t.NUMERIC:
        return n.getBitsLength(R);
      case t.ALPHANUMERIC:
        return r.getBitsLength(R);
      case t.KANJI:
        return o.getBitsLength(R);
      case t.BYTE:
        return i.getBitsLength(R);
    }
  }
  function w(R) {
    return R.reduce(function(I, D) {
      const M = I.length - 1 >= 0 ? I[I.length - 1] : null;
      return M && M.mode === D.mode ? (I[I.length - 1].data += D.data, I) : (I.push(D), I);
    }, []);
  }
  function C(R) {
    const I = [];
    for (let D = 0; D < R.length; D++) {
      const M = R[D];
      switch (M.mode) {
        case t.NUMERIC:
          I.push([
            M,
            { data: M.data, mode: t.ALPHANUMERIC, length: M.length },
            { data: M.data, mode: t.BYTE, length: M.length }
          ]);
          break;
        case t.ALPHANUMERIC:
          I.push([
            M,
            { data: M.data, mode: t.BYTE, length: M.length }
          ]);
          break;
        case t.KANJI:
          I.push([
            M,
            { data: M.data, mode: t.BYTE, length: f(M.data) }
          ]);
          break;
        case t.BYTE:
          I.push([
            { data: M.data, mode: t.BYTE, length: f(M.data) }
          ]);
      }
    }
    return I;
  }
  function x(R, I) {
    const D = {}, M = { start: {} };
    let L = ["start"];
    for (let j = 0; j < R.length; j++) {
      const F = R[j], O = [];
      for (let z = 0; z < F.length; z++) {
        const H = F[z], Q = "" + j + z;
        O.push(Q), D[Q] = { node: H, lastCount: 0 }, M[Q] = {};
        for (let Y = 0; Y < L.length; Y++) {
          const ee = L[Y];
          D[ee] && D[ee].node.mode === H.mode ? (M[ee][Q] = v(D[ee].lastCount + H.length, H.mode) - v(D[ee].lastCount, H.mode), D[ee].lastCount += H.length) : (D[ee] && (D[ee].lastCount = H.length), M[ee][Q] = v(H.length, H.mode) + 4 + t.getCharCountIndicator(H.mode, I));
        }
      }
      L = O;
    }
    for (let j = 0; j < L.length; j++)
      M[L[j]].end = 0;
    return { map: M, table: D };
  }
  function A(R, I) {
    let D;
    const M = t.getBestModeForData(R);
    if (D = t.from(I, M), D !== t.BYTE && D.bit < M.bit)
      throw new Error('"' + R + '" cannot be encoded with mode ' + t.toString(D) + `.
 Suggested mode is: ` + t.toString(M));
    switch (D === t.KANJI && !c.isKanjiModeEnabled() && (D = t.BYTE), D) {
      case t.NUMERIC:
        return new n(R);
      case t.ALPHANUMERIC:
        return new r(R);
      case t.KANJI:
        return new o(R);
      case t.BYTE:
        return new i(R);
    }
  }
  e.fromArray = function(I) {
    return I.reduce(function(D, M) {
      return typeof M == "string" ? D.push(A(M, null)) : M.data && D.push(A(M.data, M.mode)), D;
    }, []);
  }, e.fromString = function(I, D) {
    const M = y(I, c.isKanjiModeEnabled()), L = C(M), j = x(L, D), F = u.find_path(j.map, "start", "end"), O = [];
    for (let z = 1; z < F.length - 1; z++)
      O.push(j.table[F[z]].node);
    return e.fromArray(w(O));
  }, e.rawSplit = function(I) {
    return e.fromArray(
      y(I, c.isKanjiModeEnabled())
    );
  };
})(eG);
const nA = pl, CO = Z8, C1e = Zwe, x1e = e1e, E1e = qW, S1e = WW, K5 = GW, Y5 = eA, k1e = n1e, H4 = QW, A1e = JW, T1e = lp, xO = eG;
function _1e(e, t) {
  const n = e.size, r = S1e.getPositions(t);
  for (let i = 0; i < r.length; i++) {
    const o = r[i][0], s = r[i][1];
    for (let c = -1; c <= 7; c++)
      if (!(o + c <= -1 || n <= o + c))
        for (let u = -1; u <= 7; u++)
          s + u <= -1 || n <= s + u || (c >= 0 && c <= 6 && (u === 0 || u === 6) || u >= 0 && u <= 6 && (c === 0 || c === 6) || c >= 2 && c <= 4 && u >= 2 && u <= 4 ? e.set(o + c, s + u, !0, !0) : e.set(o + c, s + u, !1, !0));
  }
}
function R1e(e) {
  const t = e.size;
  for (let n = 8; n < t - 8; n++) {
    const r = n % 2 === 0;
    e.set(n, 6, r, !0), e.set(6, n, r, !0);
  }
}
function O1e(e, t) {
  const n = E1e.getPositions(t);
  for (let r = 0; r < n.length; r++) {
    const i = n[r][0], o = n[r][1];
    for (let s = -2; s <= 2; s++)
      for (let c = -2; c <= 2; c++)
        s === -2 || s === 2 || c === -2 || c === 2 || s === 0 && c === 0 ? e.set(i + s, o + c, !0, !0) : e.set(i + s, o + c, !1, !0);
  }
}
function I1e(e, t) {
  const n = e.size, r = H4.getEncodedBits(t);
  let i, o, s;
  for (let c = 0; c < 18; c++)
    i = Math.floor(c / 3), o = c % 3 + n - 8 - 3, s = (r >> c & 1) === 1, e.set(i, o, s, !0), e.set(o, i, s, !0);
}
function EO(e, t, n) {
  const r = e.size, i = A1e.getEncodedBits(t, n);
  let o, s;
  for (o = 0; o < 15; o++)
    s = (i >> o & 1) === 1, o < 6 ? e.set(o, 8, s, !0) : o < 8 ? e.set(o + 1, 8, s, !0) : e.set(r - 15 + o, 8, s, !0), o < 8 ? e.set(8, r - o - 1, s, !0) : o < 9 ? e.set(8, 15 - o - 1 + 1, s, !0) : e.set(8, 15 - o - 1, s, !0);
  e.set(r - 8, 8, 1, !0);
}
function D1e(e, t) {
  const n = e.size;
  let r = -1, i = n - 1, o = 7, s = 0;
  for (let c = n - 1; c > 0; c -= 2)
    for (c === 6 && c--; ; ) {
      for (let u = 0; u < 2; u++)
        if (!e.isReserved(i, c - u)) {
          let f = !1;
          s < t.length && (f = (t[s] >>> o & 1) === 1), e.set(i, c - u, f), o--, o === -1 && (s++, o = 7);
        }
      if (i += r, i < 0 || n <= i) {
        i -= r, r = -r;
        break;
      }
    }
}
function M1e(e, t, n) {
  const r = new C1e();
  n.forEach(function(u) {
    r.put(u.mode.bit, 4), r.put(u.getLength(), T1e.getCharCountIndicator(u.mode, e)), u.write(r);
  });
  const i = nA.getSymbolTotalCodewords(e), o = Y5.getTotalCodewordsCount(e, t), s = (i - o) * 8;
  for (r.getLengthInBits() + 4 <= s && r.put(0, 4); r.getLengthInBits() % 8 !== 0; )
    r.putBit(0);
  const c = (s - r.getLengthInBits()) / 8;
  for (let u = 0; u < c; u++)
    r.put(u % 2 ? 17 : 236, 8);
  return P1e(r, e, t);
}
function P1e(e, t, n) {
  const r = nA.getSymbolTotalCodewords(t), i = Y5.getTotalCodewordsCount(t, n), o = r - i, s = Y5.getBlocksCount(t, n), c = r % s, u = s - c, f = Math.floor(r / s), p = Math.floor(o / s), y = p + 1, v = f - p, w = new k1e(v);
  let C = 0;
  const x = new Array(s), A = new Array(s);
  let R = 0;
  const I = new Uint8Array(e.buffer);
  for (let F = 0; F < s; F++) {
    const O = F < u ? p : y;
    x[F] = I.slice(C, C + O), A[F] = w.encode(x[F]), C += O, R = Math.max(R, O);
  }
  const D = new Uint8Array(r);
  let M = 0, L, j;
  for (L = 0; L < R; L++)
    for (j = 0; j < s; j++)
      L < x[j].length && (D[M++] = x[j][L]);
  for (L = 0; L < v; L++)
    for (j = 0; j < s; j++)
      D[M++] = A[j][L];
  return D;
}
function N1e(e, t, n, r) {
  let i;
  if (Array.isArray(e))
    i = xO.fromArray(e);
  else if (typeof e == "string") {
    let f = t;
    if (!f) {
      const p = xO.rawSplit(e);
      f = H4.getBestVersionForData(p, n);
    }
    i = xO.fromString(e, f || 40);
  } else
    throw new Error("Invalid data");
  const o = H4.getBestVersionForData(i, n);
  if (!o)
    throw new Error("The amount of data is too big to be stored in a QR Code");
  if (!t)
    t = o;
  else if (t < o)
    throw new Error(
      `
The chosen QR Code version cannot contain this amount of data.
Minimum version required to store current data is: ` + o + `.
`
    );
  const s = M1e(t, n, i), c = nA.getSymbolSize(t), u = new x1e(c);
  return _1e(u, t), R1e(u), O1e(u, t), EO(u, n, 0), t >= 7 && I1e(u, t), D1e(u, s), isNaN(r) && (r = K5.getBestMask(
    u,
    EO.bind(null, u, n)
  )), K5.applyMask(r, u), EO(u, n, r), {
    modules: u,
    version: t,
    errorCorrectionLevel: n,
    maskPattern: r,
    segments: i
  };
}
$W.create = function(t, n) {
  if (typeof t > "u" || t === "")
    throw new Error("No input text");
  let r = CO.M, i, o;
  return typeof n < "u" && (r = CO.from(n.errorCorrectionLevel, CO.M), i = H4.from(n.version), o = K5.from(n.maskPattern), n.toSJISFunc && nA.setToSJISFunction(n.toSJISFunc)), N1e(t, i, r, o);
};
var nG = {}, nP = {};
(function(e) {
  function t(n) {
    if (typeof n == "number" && (n = n.toString()), typeof n != "string")
      throw new Error("Color should be defined as hex string");
    let r = n.slice().replace("#", "").split("");
    if (r.length < 3 || r.length === 5 || r.length > 8)
      throw new Error("Invalid hex color: " + n);
    (r.length === 3 || r.length === 4) && (r = Array.prototype.concat.apply([], r.map(function(o) {
      return [o, o];
    }))), r.length === 6 && r.push("F", "F");
    const i = parseInt(r.join(""), 16);
    return {
      r: i >> 24 & 255,
      g: i >> 16 & 255,
      b: i >> 8 & 255,
      a: i & 255,
      hex: "#" + r.slice(0, 6).join("")
    };
  }
  e.getOptions = function(r) {
    r || (r = {}), r.color || (r.color = {});
    const i = typeof r.margin > "u" || r.margin === null || r.margin < 0 ? 4 : r.margin, o = r.width && r.width >= 21 ? r.width : void 0, s = r.scale || 4;
    return {
      width: o,
      scale: o ? 4 : s,
      margin: i,
      color: {
        dark: t(r.color.dark || "#000000ff"),
        light: t(r.color.light || "#ffffffff")
      },
      type: r.type,
      rendererOpts: r.rendererOpts || {}
    };
  }, e.getScale = function(r, i) {
    return i.width && i.width >= r + i.margin * 2 ? i.width / (r + i.margin * 2) : i.scale;
  }, e.getImageWidth = function(r, i) {
    const o = e.getScale(r, i);
    return Math.floor((r + i.margin * 2) * o);
  }, e.qrToImageData = function(r, i, o) {
    const s = i.modules.size, c = i.modules.data, u = e.getScale(s, o), f = Math.floor((s + o.margin * 2) * u), p = o.margin * u, y = [o.color.light, o.color.dark];
    for (let v = 0; v < f; v++)
      for (let w = 0; w < f; w++) {
        let C = (v * f + w) * 4, x = o.color.light;
        if (v >= p && w >= p && v < f - p && w < f - p) {
          const A = Math.floor((v - p) / u), R = Math.floor((w - p) / u);
          x = y[c[A * s + R] ? 1 : 0];
        }
        r[C++] = x.r, r[C++] = x.g, r[C++] = x.b, r[C] = x.a;
      }
  };
})(nP);
(function(e) {
  const t = nP;
  function n(i, o, s) {
    i.clearRect(0, 0, o.width, o.height), o.style || (o.style = {}), o.height = s, o.width = s, o.style.height = s + "px", o.style.width = s + "px";
  }
  function r() {
    try {
      return document.createElement("canvas");
    } catch {
      throw new Error("You need to specify a canvas element");
    }
  }
  e.render = function(o, s, c) {
    let u = c, f = s;
    typeof u > "u" && (!s || !s.getContext) && (u = s, s = void 0), s || (f = r()), u = t.getOptions(u);
    const p = t.getImageWidth(o.modules.size, u), y = f.getContext("2d"), v = y.createImageData(p, p);
    return t.qrToImageData(v.data, o, u), n(y, f, p), y.putImageData(v, 0, 0), f;
  }, e.renderToDataURL = function(o, s, c) {
    let u = c;
    typeof u > "u" && (!s || !s.getContext) && (u = s, s = void 0), u || (u = {});
    const f = e.render(o, s, u), p = u.type || "image/png", y = u.rendererOpts || {};
    return f.toDataURL(p, y.quality);
  };
})(nG);
var rG = {};
const B1e = nP;
function uU(e, t) {
  const n = e.a / 255, r = t + '="' + e.hex + '"';
  return n < 1 ? r + " " + t + '-opacity="' + n.toFixed(2).slice(1) + '"' : r;
}
function SO(e, t, n) {
  let r = e + t;
  return typeof n < "u" && (r += " " + n), r;
}
function L1e(e, t, n) {
  let r = "", i = 0, o = !1, s = 0;
  for (let c = 0; c < e.length; c++) {
    const u = Math.floor(c % t), f = Math.floor(c / t);
    !u && !o && (o = !0), e[c] ? (s++, c > 0 && u > 0 && e[c - 1] || (r += o ? SO("M", u + n, 0.5 + f + n) : SO("m", i, 0), i = 0, o = !1), u + 1 < t && e[c + 1] || (r += SO("h", s), s = 0)) : i++;
  }
  return r;
}
rG.render = function(t, n, r) {
  const i = B1e.getOptions(n), o = t.modules.size, s = t.modules.data, c = o + i.margin * 2, u = i.color.light.a ? "<path " + uU(i.color.light, "fill") + ' d="M0 0h' + c + "v" + c + 'H0z"/>' : "", f = "<path " + uU(i.color.dark, "stroke") + ' d="' + L1e(s, o, i.margin) + '"/>', p = 'viewBox="0 0 ' + c + " " + c + '"', v = '<svg xmlns="http://www.w3.org/2000/svg" ' + (i.width ? 'width="' + i.width + '" height="' + i.width + '" ' : "") + p + ' shape-rendering="crispEdges">' + u + f + `</svg>
`;
  return typeof r == "function" && r(null, v), v;
};
const j1e = Xwe, Q5 = $W, iG = nG, F1e = rG;
function rP(e, t, n, r, i) {
  const o = [].slice.call(arguments, 1), s = o.length, c = typeof o[s - 1] == "function";
  if (!c && !j1e())
    throw new Error("Callback required as last argument");
  if (c) {
    if (s < 2)
      throw new Error("Too few arguments provided");
    s === 2 ? (i = n, n = t, t = r = void 0) : s === 3 && (t.getContext && typeof i > "u" ? (i = r, r = void 0) : (i = r, r = n, n = t, t = void 0));
  } else {
    if (s < 1)
      throw new Error("Too few arguments provided");
    return s === 1 ? (n = t, t = r = void 0) : s === 2 && !t.getContext && (r = n, n = t, t = void 0), new Promise(function(u, f) {
      try {
        const p = Q5.create(n, r);
        u(e(p, t, r));
      } catch (p) {
        f(p);
      }
    });
  }
  try {
    const u = Q5.create(n, r);
    i(null, e(u, t, r));
  } catch (u) {
    i(u);
  }
}
XC.create = Q5.create;
XC.toCanvas = rP.bind(null, iG.render);
XC.toDataURL = rP.bind(null, iG.renderToDataURL);
XC.toString = rP.bind(null, function(e, t, n) {
  return F1e.render(e, n);
});
rA.type = "coinbaseWallet";
function rA(e = {}) {
  return e.version === "3" || e.headlessMode ? z1e(e) : U1e(e);
}
function U1e(e) {
  let t, n, r, i, o;
  return (s) => ({
    id: "coinbaseWalletSDK",
    name: "Coinbase Wallet",
    rdns: "com.coinbase.wallet",
    supportsSimulation: !0,
    type: rA.type,
    async connect({ chainId: c } = {}) {
      try {
        const u = await this.getProvider(), f = (await u.request({
          method: "eth_requestAccounts"
        })).map((y) => Ma(y));
        r || (r = this.onAccountsChanged.bind(this), u.on("accountsChanged", r)), i || (i = this.onChainChanged.bind(this), u.on("chainChanged", i)), o || (o = this.onDisconnect.bind(this), u.on("disconnect", o));
        let p = await this.getChainId();
        if (c && p !== c) {
          const y = await this.switchChain({ chainId: c }).catch((v) => {
            if (v.code === li.code)
              throw v;
            return { id: p };
          });
          p = (y == null ? void 0 : y.id) ?? p;
        }
        return { accounts: f, chainId: p };
      } catch (u) {
        throw /(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(u.message) ? new li(u) : u;
      }
    },
    async disconnect() {
      var u;
      const c = await this.getProvider();
      r && (c.removeListener("accountsChanged", r), r = void 0), i && (c.removeListener("chainChanged", i), i = void 0), o && (c.removeListener("disconnect", o), o = void 0), c.disconnect(), (u = c.close) == null || u.call(c);
    },
    async getAccounts() {
      return (await (await this.getProvider()).request({
        method: "eth_accounts"
      })).map((u) => Ma(u));
    },
    async getChainId() {
      const u = await (await this.getProvider()).request({
        method: "eth_chainId"
      });
      return Number(u);
    },
    async getProvider() {
      if (!n) {
        const c = await (async () => {
          const { default: u } = await import("./index-vHB5AAy2.js").then((f) => f.i);
          return typeof u != "function" && typeof u.default == "function" ? u.default : u;
        })();
        t = new c({
          ...e,
          appChainIds: s.chains.map((u) => u.id)
        }), n = t.makeWeb3Provider({
          ...e,
          options: e.preference ?? "all"
        });
      }
      return n;
    },
    async isAuthorized() {
      try {
        return !!(await this.getAccounts()).length;
      } catch {
        return !1;
      }
    },
    async switchChain({ addEthereumChainParameter: c, chainId: u }) {
      var y, v, w, C;
      const f = s.chains.find((x) => x.id === u);
      if (!f)
        throw new Xl(new Zm());
      const p = await this.getProvider();
      try {
        return await p.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: en(f.id) }]
        }), f;
      } catch (x) {
        if (x.code === 4902)
          try {
            let A;
            c != null && c.blockExplorerUrls ? A = c.blockExplorerUrls : A = (y = f.blockExplorers) != null && y.default.url ? [(v = f.blockExplorers) == null ? void 0 : v.default.url] : [];
            let R;
            (w = c == null ? void 0 : c.rpcUrls) != null && w.length ? R = c.rpcUrls : R = [((C = f.rpcUrls.default) == null ? void 0 : C.http[0]) ?? ""];
            const I = {
              blockExplorerUrls: A,
              chainId: en(u),
              chainName: (c == null ? void 0 : c.chainName) ?? f.name,
              iconUrls: c == null ? void 0 : c.iconUrls,
              nativeCurrency: (c == null ? void 0 : c.nativeCurrency) ?? f.nativeCurrency,
              rpcUrls: R
            };
            return await p.request({
              method: "wallet_addEthereumChain",
              params: [I]
            }), f;
          } catch (A) {
            throw new li(A);
          }
        throw new Xl(x);
      }
    },
    onAccountsChanged(c) {
      c.length === 0 ? this.onDisconnect() : s.emitter.emit("change", {
        accounts: c.map((u) => Ma(u))
      });
    },
    onChainChanged(c) {
      const u = Number(c);
      s.emitter.emit("change", { chainId: u });
    },
    async onDisconnect(c) {
      s.emitter.emit("disconnect");
      const u = await this.getProvider();
      r && (u.removeListener("accountsChanged", r), r = void 0), i && (u.removeListener("chainChanged", i), i = void 0), o && (u.removeListener("disconnect", o), o = void 0);
    }
  });
}
function z1e(e) {
  let n, r, i, o, s;
  return (c) => ({
    id: "coinbaseWalletSDK",
    name: "Coinbase Wallet",
    supportsSimulation: !0,
    type: rA.type,
    async connect({ chainId: u } = {}) {
      try {
        const f = await this.getProvider(), p = (await f.request({
          method: "eth_requestAccounts"
        })).map((v) => Ma(v));
        i || (i = this.onAccountsChanged.bind(this), f.on("accountsChanged", i)), o || (o = this.onChainChanged.bind(this), f.on("chainChanged", o)), s || (s = this.onDisconnect.bind(this), f.on("disconnect", s));
        let y = await this.getChainId();
        if (u && y !== u) {
          const v = await this.switchChain({ chainId: u }).catch((w) => {
            if (w.code === li.code)
              throw w;
            return { id: y };
          });
          y = (v == null ? void 0 : v.id) ?? y;
        }
        return { accounts: p, chainId: y };
      } catch (f) {
        throw /(user closed modal|accounts received is empty|user denied account)/i.test(f.message) ? new li(f) : f;
      }
    },
    async disconnect() {
      const u = await this.getProvider();
      i && (u.removeListener("accountsChanged", i), i = void 0), o && (u.removeListener("chainChanged", o), o = void 0), s && (u.removeListener("disconnect", s), s = void 0), u.disconnect(), u.close();
    },
    async getAccounts() {
      return (await (await this.getProvider()).request({
        method: "eth_accounts"
      })).map((f) => Ma(f));
    },
    async getChainId() {
      const f = await (await this.getProvider()).request({
        method: "eth_chainId"
      });
      return Number(f);
    },
    async getProvider() {
      var u;
      if (!r) {
        const f = await (async () => {
          const { default: C } = await import("./index-eIWbcuVU.js").then((x) => x.i);
          return typeof C != "function" && typeof C.default == "function" ? C.default : C;
        })();
        n = new f({ ...e, reloadOnDisconnect: !1 });
        const p = (u = n.walletExtension) == null ? void 0 : u.getChainId(), y = c.chains.find((C) => e.chainId ? C.id === e.chainId : C.id === p) || c.chains[0], v = e.chainId || (y == null ? void 0 : y.id), w = e.jsonRpcUrl || (y == null ? void 0 : y.rpcUrls.default.http[0]);
        r = n.makeWeb3Provider(w, v);
      }
      return r;
    },
    async isAuthorized() {
      try {
        return !!(await this.getAccounts()).length;
      } catch {
        return !1;
      }
    },
    async switchChain({ addEthereumChainParameter: u, chainId: f }) {
      var v, w, C, x;
      const p = c.chains.find((A) => A.id === f);
      if (!p)
        throw new Xl(new Zm());
      const y = await this.getProvider();
      try {
        return await y.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: en(p.id) }]
        }), p;
      } catch (A) {
        if (A.code === 4902)
          try {
            let R;
            u != null && u.blockExplorerUrls ? R = u.blockExplorerUrls : R = (v = p.blockExplorers) != null && v.default.url ? [(w = p.blockExplorers) == null ? void 0 : w.default.url] : [];
            let I;
            (C = u == null ? void 0 : u.rpcUrls) != null && C.length ? I = u.rpcUrls : I = [((x = p.rpcUrls.default) == null ? void 0 : x.http[0]) ?? ""];
            const D = {
              blockExplorerUrls: R,
              chainId: en(f),
              chainName: (u == null ? void 0 : u.chainName) ?? p.name,
              iconUrls: u == null ? void 0 : u.iconUrls,
              nativeCurrency: (u == null ? void 0 : u.nativeCurrency) ?? p.nativeCurrency,
              rpcUrls: I
            };
            return await y.request({
              method: "wallet_addEthereumChain",
              params: [D]
            }), p;
          } catch (R) {
            throw new li(R);
          }
        throw new Xl(A);
      }
    },
    onAccountsChanged(u) {
      u.length === 0 ? this.onDisconnect() : c.emitter.emit("change", {
        accounts: u.map((f) => Ma(f))
      });
    },
    onChainChanged(u) {
      const f = Number(u);
      c.emitter.emit("change", { chainId: f });
    },
    async onDisconnect(u) {
      c.emitter.emit("disconnect");
      const f = await this.getProvider();
      i && (f.removeListener("accountsChanged", i), i = void 0), o && (f.removeListener("chainChanged", o), o = void 0), s && (f.removeListener("disconnect", s), s = void 0);
    }
  });
}
iP.type = "walletConnect";
function iP(e) {
  const t = e.isNewChainsStale ?? !0;
  let n, r;
  const i = "eip155";
  let o, s, c, u, f, p;
  return (y) => ({
    id: "walletConnect",
    name: "WalletConnect",
    type: iP.type,
    async setup() {
      const v = await this.getProvider().catch(() => null);
      v && (c || (c = this.onConnect.bind(this), v.on("connect", c)), f || (f = this.onSessionDelete.bind(this), v.on("session_delete", f)));
    },
    async connect({ chainId: v, ...w } = {}) {
      var C, x;
      try {
        const A = await this.getProvider();
        if (!A)
          throw new Th();
        u || (u = this.onDisplayUri, A.on("display_uri", u));
        let R = v;
        if (!R) {
          const L = await ((C = y.storage) == null ? void 0 : C.getItem("state")) ?? {};
          y.chains.some((F) => F.id === L.chainId) ? R = L.chainId : R = (x = y.chains[0]) == null ? void 0 : x.id;
        }
        if (!R)
          throw new Error("No chains found on connector.");
        const I = await this.isChainsStale();
        if (A.session && I && await A.disconnect(), !A.session || I) {
          const L = y.chains.filter((j) => j.id !== R).map((j) => j.id);
          await A.connect({
            optionalChains: [R, ...L],
            ..."pairingTopic" in w ? { pairingTopic: w.pairingTopic } : {}
          }), this.setRequestedChainsIds(y.chains.map((j) => j.id));
        }
        const D = (await A.enable()).map((L) => Ma(L)), M = await this.getChainId();
        return u && (A.removeListener("display_uri", u), u = void 0), c && (A.removeListener("connect", c), c = void 0), o || (o = this.onAccountsChanged.bind(this), A.on("accountsChanged", o)), s || (s = this.onChainChanged.bind(this), A.on("chainChanged", s)), p || (p = this.onDisconnect.bind(this), A.on("disconnect", p)), f || (f = this.onSessionDelete.bind(this), A.on("session_delete", f)), { accounts: D, chainId: M };
      } catch (A) {
        throw /(user rejected|connection request reset)/i.test(A == null ? void 0 : A.message) ? new li(A) : A;
      }
    },
    async disconnect() {
      const v = await this.getProvider();
      try {
        await (v == null ? void 0 : v.disconnect());
      } catch (w) {
        if (!/No matching key/i.test(w.message))
          throw w;
      } finally {
        s && (v == null || v.removeListener("chainChanged", s), s = void 0), p && (v == null || v.removeListener("disconnect", p), p = void 0), c || (c = this.onConnect.bind(this), v == null || v.on("connect", c)), o && (v == null || v.removeListener("accountsChanged", o), o = void 0), f && (v == null || v.removeListener("session_delete", f), f = void 0), this.setRequestedChainsIds([]);
      }
    },
    async getAccounts() {
      return (await this.getProvider()).accounts.map((w) => Ma(w));
    },
    async getProvider({ chainId: v } = {}) {
      var C;
      async function w() {
        const x = y.chains.map((R) => R.id);
        if (!x.length)
          return;
        const { EthereumProvider: A } = await import("./index.es-C92RkcLo.js");
        return await A.init({
          ...e,
          disableProviderPing: !0,
          optionalChains: x,
          projectId: e.projectId,
          rpcMap: Object.fromEntries(y.chains.map((R) => {
            const [I] = wbe({
              chain: R,
              transports: y.transports
            });
            return [R.id, I];
          })),
          showQrModal: e.showQrModal ?? !0
        });
      }
      return n || (r || (r = w()), n = await r, n == null || n.events.setMaxListeners(Number.POSITIVE_INFINITY)), v && await ((C = this.switchChain) == null ? void 0 : C.call(this, { chainId: v })), n;
    },
    async getChainId() {
      return (await this.getProvider()).chainId;
    },
    async isAuthorized() {
      try {
        const [v, w] = await Promise.all([
          this.getAccounts(),
          this.getProvider()
        ]);
        return v.length ? await this.isChainsStale() && w.session ? (await w.disconnect().catch(() => {
        }), !1) : !0 : !1;
      } catch {
        return !1;
      }
    },
    async switchChain({ addEthereumChainParameter: v, chainId: w }) {
      var A, R, I;
      const C = await this.getProvider();
      if (!C)
        throw new Th();
      const x = y.chains.find((D) => D.id === w);
      if (!x)
        throw new Xl(new Zm());
      try {
        await Promise.all([
          new Promise((M) => {
            const L = ({ chainId: j }) => {
              j === w && (y.emitter.off("change", L), M());
            };
            y.emitter.on("change", L);
          }),
          C.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: en(w) }]
          })
        ]);
        const D = await this.getRequestedChainsIds();
        return this.setRequestedChainsIds([...D, w]), x;
      } catch (D) {
        const M = D;
        if (/(user rejected)/i.test(M.message))
          throw new li(M);
        try {
          let L;
          v != null && v.blockExplorerUrls ? L = v.blockExplorerUrls : L = (A = x.blockExplorers) != null && A.default.url ? [(R = x.blockExplorers) == null ? void 0 : R.default.url] : [];
          let j;
          (I = v == null ? void 0 : v.rpcUrls) != null && I.length ? j = v.rpcUrls : j = [...x.rpcUrls.default.http];
          const F = {
            blockExplorerUrls: L,
            chainId: en(w),
            chainName: (v == null ? void 0 : v.chainName) ?? x.name,
            iconUrls: v == null ? void 0 : v.iconUrls,
            nativeCurrency: (v == null ? void 0 : v.nativeCurrency) ?? x.nativeCurrency,
            rpcUrls: j
          };
          await C.request({
            method: "wallet_addEthereumChain",
            params: [F]
          });
          const O = await this.getRequestedChainsIds();
          return this.setRequestedChainsIds([...O, w]), x;
        } catch (L) {
          throw new li(L);
        }
      }
    },
    onAccountsChanged(v) {
      v.length === 0 ? this.onDisconnect() : y.emitter.emit("change", {
        accounts: v.map((w) => Ma(w))
      });
    },
    onChainChanged(v) {
      const w = Number(v);
      y.emitter.emit("change", { chainId: w });
    },
    async onConnect(v) {
      const w = Number(v.chainId), C = await this.getAccounts();
      y.emitter.emit("connect", { accounts: C, chainId: w });
    },
    async onDisconnect(v) {
      this.setRequestedChainsIds([]), y.emitter.emit("disconnect");
      const w = await this.getProvider();
      o && (w.removeListener("accountsChanged", o), o = void 0), s && (w.removeListener("chainChanged", s), s = void 0), p && (w.removeListener("disconnect", p), p = void 0), f && (w.removeListener("session_delete", f), f = void 0), c || (c = this.onConnect.bind(this), w.on("connect", c));
    },
    onDisplayUri(v) {
      y.emitter.emit("message", { type: "display_uri", data: v });
    },
    onSessionDelete() {
      this.onDisconnect();
    },
    getNamespaceChainsIds() {
      var w, C, x;
      return n ? ((x = (C = (w = n.session) == null ? void 0 : w.namespaces[i]) == null ? void 0 : C.accounts) == null ? void 0 : x.map((A) => Number.parseInt(A.split(":")[1] || ""))) ?? [] : [];
    },
    async getRequestedChainsIds() {
      var v;
      return await ((v = y.storage) == null ? void 0 : v.getItem(this.requestedChainsStorageKey)) ?? [];
    },
    /**
     * Checks if the target chains match the chains that were
     * initially requested by the connector for the WalletConnect session.
     * If there is a mismatch, this means that the chains on the connector
     * are considered stale, and need to be revalidated at a later point (via
     * connection).
     *
     * There may be a scenario where a dapp adds a chain to the
     * connector later on, however, this chain will not have been approved or rejected
     * by the wallet. In this case, the chain is considered stale.
     */
    async isChainsStale() {
      if (!t)
        return !1;
      const v = y.chains.map((x) => x.id), w = this.getNamespaceChainsIds();
      if (w.length && !w.some((x) => v.includes(x)))
        return !1;
      const C = await this.getRequestedChainsIds();
      return !v.every((x) => C.includes(x));
    },
    async setRequestedChainsIds(v) {
      var w;
      await ((w = y.storage) == null ? void 0 : w.setItem(this.requestedChainsStorageKey, v));
    },
    get requestedChainsStorageKey() {
      return `${this.id}.requestedChains`;
    }
  });
}
var V1e = 768, sg = ahe({ conditions: { defaultCondition: "smallScreen", conditionNames: ["smallScreen", "largeScreen"], responsiveArray: void 0 } }), $1e = X$({ conditions: { defaultCondition: "smallScreen", conditionNames: ["smallScreen", "largeScreen"], responsiveArray: void 0 } }), X5 = fhe({ conditions: { defaultCondition: "base", conditionNames: ["base", "hover", "active"], responsiveArray: void 0 }, styles: { background: { values: { accentColor: { conditions: { base: "in5bvi9i", hover: "in5bvi9j", active: "in5bvi9k" }, defaultClass: "in5bvi9i" }, accentColorForeground: { conditions: { base: "in5bvi9l", hover: "in5bvi9m", active: "in5bvi9n" }, defaultClass: "in5bvi9l" }, actionButtonBorder: { conditions: { base: "in5bvi9o", hover: "in5bvi9p", active: "in5bvi9q" }, defaultClass: "in5bvi9o" }, actionButtonBorderMobile: { conditions: { base: "in5bvi9r", hover: "in5bvi9s", active: "in5bvi9t" }, defaultClass: "in5bvi9r" }, actionButtonSecondaryBackground: { conditions: { base: "in5bvi9u", hover: "in5bvi9v", active: "in5bvi9w" }, defaultClass: "in5bvi9u" }, closeButton: { conditions: { base: "in5bvi9x", hover: "in5bvi9y", active: "in5bvi9z" }, defaultClass: "in5bvi9x" }, closeButtonBackground: { conditions: { base: "in5bvia0", hover: "in5bvia1", active: "in5bvia2" }, defaultClass: "in5bvia0" }, connectButtonBackground: { conditions: { base: "in5bvia3", hover: "in5bvia4", active: "in5bvia5" }, defaultClass: "in5bvia3" }, connectButtonBackgroundError: { conditions: { base: "in5bvia6", hover: "in5bvia7", active: "in5bvia8" }, defaultClass: "in5bvia6" }, connectButtonInnerBackground: { conditions: { base: "in5bvia9", hover: "in5bviaa", active: "in5bviab" }, defaultClass: "in5bvia9" }, connectButtonText: { conditions: { base: "in5bviac", hover: "in5bviad", active: "in5bviae" }, defaultClass: "in5bviac" }, connectButtonTextError: { conditions: { base: "in5bviaf", hover: "in5bviag", active: "in5bviah" }, defaultClass: "in5bviaf" }, connectionIndicator: { conditions: { base: "in5bviai", hover: "in5bviaj", active: "in5bviak" }, defaultClass: "in5bviai" }, downloadBottomCardBackground: { conditions: { base: "in5bvial", hover: "in5bviam", active: "in5bvian" }, defaultClass: "in5bvial" }, downloadTopCardBackground: { conditions: { base: "in5bviao", hover: "in5bviap", active: "in5bviaq" }, defaultClass: "in5bviao" }, error: { conditions: { base: "in5bviar", hover: "in5bvias", active: "in5bviat" }, defaultClass: "in5bviar" }, generalBorder: { conditions: { base: "in5bviau", hover: "in5bviav", active: "in5bviaw" }, defaultClass: "in5bviau" }, generalBorderDim: { conditions: { base: "in5bviax", hover: "in5bviay", active: "in5bviaz" }, defaultClass: "in5bviax" }, menuItemBackground: { conditions: { base: "in5bvib0", hover: "in5bvib1", active: "in5bvib2" }, defaultClass: "in5bvib0" }, modalBackdrop: { conditions: { base: "in5bvib3", hover: "in5bvib4", active: "in5bvib5" }, defaultClass: "in5bvib3" }, modalBackground: { conditions: { base: "in5bvib6", hover: "in5bvib7", active: "in5bvib8" }, defaultClass: "in5bvib6" }, modalBorder: { conditions: { base: "in5bvib9", hover: "in5bviba", active: "in5bvibb" }, defaultClass: "in5bvib9" }, modalText: { conditions: { base: "in5bvibc", hover: "in5bvibd", active: "in5bvibe" }, defaultClass: "in5bvibc" }, modalTextDim: { conditions: { base: "in5bvibf", hover: "in5bvibg", active: "in5bvibh" }, defaultClass: "in5bvibf" }, modalTextSecondary: { conditions: { base: "in5bvibi", hover: "in5bvibj", active: "in5bvibk" }, defaultClass: "in5bvibi" }, profileAction: { conditions: { base: "in5bvibl", hover: "in5bvibm", active: "in5bvibn" }, defaultClass: "in5bvibl" }, profileActionHover: { conditions: { base: "in5bvibo", hover: "in5bvibp", active: "in5bvibq" }, defaultClass: "in5bvibo" }, profileForeground: { conditions: { base: "in5bvibr", hover: "in5bvibs", active: "in5bvibt" }, defaultClass: "in5bvibr" }, selectedOptionBorder: { conditions: { base: "in5bvibu", hover: "in5bvibv", active: "in5bvibw" }, defaultClass: "in5bvibu" }, standby: { conditions: { base: "in5bvibx", hover: "in5bviby", active: "in5bvibz" }, defaultClass: "in5bvibx" } } }, borderColor: { values: { accentColor: { conditions: { base: "in5bvic0", hover: "in5bvic1", active: "in5bvic2" }, defaultClass: "in5bvic0" }, accentColorForeground: { conditions: { base: "in5bvic3", hover: "in5bvic4", active: "in5bvic5" }, defaultClass: "in5bvic3" }, actionButtonBorder: { conditions: { base: "in5bvic6", hover: "in5bvic7", active: "in5bvic8" }, defaultClass: "in5bvic6" }, actionButtonBorderMobile: { conditions: { base: "in5bvic9", hover: "in5bvica", active: "in5bvicb" }, defaultClass: "in5bvic9" }, actionButtonSecondaryBackground: { conditions: { base: "in5bvicc", hover: "in5bvicd", active: "in5bvice" }, defaultClass: "in5bvicc" }, closeButton: { conditions: { base: "in5bvicf", hover: "in5bvicg", active: "in5bvich" }, defaultClass: "in5bvicf" }, closeButtonBackground: { conditions: { base: "in5bvici", hover: "in5bvicj", active: "in5bvick" }, defaultClass: "in5bvici" }, connectButtonBackground: { conditions: { base: "in5bvicl", hover: "in5bvicm", active: "in5bvicn" }, defaultClass: "in5bvicl" }, connectButtonBackgroundError: { conditions: { base: "in5bvico", hover: "in5bvicp", active: "in5bvicq" }, defaultClass: "in5bvico" }, connectButtonInnerBackground: { conditions: { base: "in5bvicr", hover: "in5bvics", active: "in5bvict" }, defaultClass: "in5bvicr" }, connectButtonText: { conditions: { base: "in5bvicu", hover: "in5bvicv", active: "in5bvicw" }, defaultClass: "in5bvicu" }, connectButtonTextError: { conditions: { base: "in5bvicx", hover: "in5bvicy", active: "in5bvicz" }, defaultClass: "in5bvicx" }, connectionIndicator: { conditions: { base: "in5bvid0", hover: "in5bvid1", active: "in5bvid2" }, defaultClass: "in5bvid0" }, downloadBottomCardBackground: { conditions: { base: "in5bvid3", hover: "in5bvid4", active: "in5bvid5" }, defaultClass: "in5bvid3" }, downloadTopCardBackground: { conditions: { base: "in5bvid6", hover: "in5bvid7", active: "in5bvid8" }, defaultClass: "in5bvid6" }, error: { conditions: { base: "in5bvid9", hover: "in5bvida", active: "in5bvidb" }, defaultClass: "in5bvid9" }, generalBorder: { conditions: { base: "in5bvidc", hover: "in5bvidd", active: "in5bvide" }, defaultClass: "in5bvidc" }, generalBorderDim: { conditions: { base: "in5bvidf", hover: "in5bvidg", active: "in5bvidh" }, defaultClass: "in5bvidf" }, menuItemBackground: { conditions: { base: "in5bvidi", hover: "in5bvidj", active: "in5bvidk" }, defaultClass: "in5bvidi" }, modalBackdrop: { conditions: { base: "in5bvidl", hover: "in5bvidm", active: "in5bvidn" }, defaultClass: "in5bvidl" }, modalBackground: { conditions: { base: "in5bvido", hover: "in5bvidp", active: "in5bvidq" }, defaultClass: "in5bvido" }, modalBorder: { conditions: { base: "in5bvidr", hover: "in5bvids", active: "in5bvidt" }, defaultClass: "in5bvidr" }, modalText: { conditions: { base: "in5bvidu", hover: "in5bvidv", active: "in5bvidw" }, defaultClass: "in5bvidu" }, modalTextDim: { conditions: { base: "in5bvidx", hover: "in5bvidy", active: "in5bvidz" }, defaultClass: "in5bvidx" }, modalTextSecondary: { conditions: { base: "in5bvie0", hover: "in5bvie1", active: "in5bvie2" }, defaultClass: "in5bvie0" }, profileAction: { conditions: { base: "in5bvie3", hover: "in5bvie4", active: "in5bvie5" }, defaultClass: "in5bvie3" }, profileActionHover: { conditions: { base: "in5bvie6", hover: "in5bvie7", active: "in5bvie8" }, defaultClass: "in5bvie6" }, profileForeground: { conditions: { base: "in5bvie9", hover: "in5bviea", active: "in5bvieb" }, defaultClass: "in5bvie9" }, selectedOptionBorder: { conditions: { base: "in5bviec", hover: "in5bvied", active: "in5bviee" }, defaultClass: "in5bviec" }, standby: { conditions: { base: "in5bvief", hover: "in5bvieg", active: "in5bvieh" }, defaultClass: "in5bvief" } } }, boxShadow: { values: { connectButton: { conditions: { base: "in5bviei", hover: "in5bviej", active: "in5bviek" }, defaultClass: "in5bviei" }, dialog: { conditions: { base: "in5bviel", hover: "in5bviem", active: "in5bvien" }, defaultClass: "in5bviel" }, profileDetailsAction: { conditions: { base: "in5bvieo", hover: "in5bviep", active: "in5bvieq" }, defaultClass: "in5bvieo" }, selectedOption: { conditions: { base: "in5bvier", hover: "in5bvies", active: "in5bviet" }, defaultClass: "in5bvier" }, selectedWallet: { conditions: { base: "in5bvieu", hover: "in5bviev", active: "in5bview" }, defaultClass: "in5bvieu" }, walletLogo: { conditions: { base: "in5bviex", hover: "in5bviey", active: "in5bviez" }, defaultClass: "in5bviex" } } }, color: { values: { accentColor: { conditions: { base: "in5bvif0", hover: "in5bvif1", active: "in5bvif2" }, defaultClass: "in5bvif0" }, accentColorForeground: { conditions: { base: "in5bvif3", hover: "in5bvif4", active: "in5bvif5" }, defaultClass: "in5bvif3" }, actionButtonBorder: { conditions: { base: "in5bvif6", hover: "in5bvif7", active: "in5bvif8" }, defaultClass: "in5bvif6" }, actionButtonBorderMobile: { conditions: { base: "in5bvif9", hover: "in5bvifa", active: "in5bvifb" }, defaultClass: "in5bvif9" }, actionButtonSecondaryBackground: { conditions: { base: "in5bvifc", hover: "in5bvifd", active: "in5bvife" }, defaultClass: "in5bvifc" }, closeButton: { conditions: { base: "in5bviff", hover: "in5bvifg", active: "in5bvifh" }, defaultClass: "in5bviff" }, closeButtonBackground: { conditions: { base: "in5bvifi", hover: "in5bvifj", active: "in5bvifk" }, defaultClass: "in5bvifi" }, connectButtonBackground: { conditions: { base: "in5bvifl", hover: "in5bvifm", active: "in5bvifn" }, defaultClass: "in5bvifl" }, connectButtonBackgroundError: { conditions: { base: "in5bvifo", hover: "in5bvifp", active: "in5bvifq" }, defaultClass: "in5bvifo" }, connectButtonInnerBackground: { conditions: { base: "in5bvifr", hover: "in5bvifs", active: "in5bvift" }, defaultClass: "in5bvifr" }, connectButtonText: { conditions: { base: "in5bvifu", hover: "in5bvifv", active: "in5bvifw" }, defaultClass: "in5bvifu" }, connectButtonTextError: { conditions: { base: "in5bvifx", hover: "in5bvify", active: "in5bvifz" }, defaultClass: "in5bvifx" }, connectionIndicator: { conditions: { base: "in5bvig0", hover: "in5bvig1", active: "in5bvig2" }, defaultClass: "in5bvig0" }, downloadBottomCardBackground: { conditions: { base: "in5bvig3", hover: "in5bvig4", active: "in5bvig5" }, defaultClass: "in5bvig3" }, downloadTopCardBackground: { conditions: { base: "in5bvig6", hover: "in5bvig7", active: "in5bvig8" }, defaultClass: "in5bvig6" }, error: { conditions: { base: "in5bvig9", hover: "in5bviga", active: "in5bvigb" }, defaultClass: "in5bvig9" }, generalBorder: { conditions: { base: "in5bvigc", hover: "in5bvigd", active: "in5bvige" }, defaultClass: "in5bvigc" }, generalBorderDim: { conditions: { base: "in5bvigf", hover: "in5bvigg", active: "in5bvigh" }, defaultClass: "in5bvigf" }, menuItemBackground: { conditions: { base: "in5bvigi", hover: "in5bvigj", active: "in5bvigk" }, defaultClass: "in5bvigi" }, modalBackdrop: { conditions: { base: "in5bvigl", hover: "in5bvigm", active: "in5bvign" }, defaultClass: "in5bvigl" }, modalBackground: { conditions: { base: "in5bvigo", hover: "in5bvigp", active: "in5bvigq" }, defaultClass: "in5bvigo" }, modalBorder: { conditions: { base: "in5bvigr", hover: "in5bvigs", active: "in5bvigt" }, defaultClass: "in5bvigr" }, modalText: { conditions: { base: "in5bvigu", hover: "in5bvigv", active: "in5bvigw" }, defaultClass: "in5bvigu" }, modalTextDim: { conditions: { base: "in5bvigx", hover: "in5bvigy", active: "in5bvigz" }, defaultClass: "in5bvigx" }, modalTextSecondary: { conditions: { base: "in5bvih0", hover: "in5bvih1", active: "in5bvih2" }, defaultClass: "in5bvih0" }, profileAction: { conditions: { base: "in5bvih3", hover: "in5bvih4", active: "in5bvih5" }, defaultClass: "in5bvih3" }, profileActionHover: { conditions: { base: "in5bvih6", hover: "in5bvih7", active: "in5bvih8" }, defaultClass: "in5bvih6" }, profileForeground: { conditions: { base: "in5bvih9", hover: "in5bviha", active: "in5bvihb" }, defaultClass: "in5bvih9" }, selectedOptionBorder: { conditions: { base: "in5bvihc", hover: "in5bvihd", active: "in5bvihe" }, defaultClass: "in5bvihc" }, standby: { conditions: { base: "in5bvihf", hover: "in5bvihg", active: "in5bvihh" }, defaultClass: "in5bvihf" } } } } }, { conditions: { defaultCondition: "smallScreen", conditionNames: ["smallScreen", "largeScreen"], responsiveArray: void 0 }, styles: { alignItems: { values: { "flex-start": { conditions: { smallScreen: "in5bvi0", largeScreen: "in5bvi1" }, defaultClass: "in5bvi0" }, "flex-end": { conditions: { smallScreen: "in5bvi2", largeScreen: "in5bvi3" }, defaultClass: "in5bvi2" }, center: { conditions: { smallScreen: "in5bvi4", largeScreen: "in5bvi5" }, defaultClass: "in5bvi4" } } }, display: { values: { none: { conditions: { smallScreen: "in5bvi6", largeScreen: "in5bvi7" }, defaultClass: "in5bvi6" }, block: { conditions: { smallScreen: "in5bvi8", largeScreen: "in5bvi9" }, defaultClass: "in5bvi8" }, flex: { conditions: { smallScreen: "in5bvia", largeScreen: "in5bvib" }, defaultClass: "in5bvia" }, inline: { conditions: { smallScreen: "in5bvic", largeScreen: "in5bvid" }, defaultClass: "in5bvic" } } } } }, { conditions: void 0, styles: { margin: { mappings: ["marginTop", "marginBottom", "marginLeft", "marginRight"] }, marginX: { mappings: ["marginLeft", "marginRight"] }, marginY: { mappings: ["marginTop", "marginBottom"] }, padding: { mappings: ["paddingTop", "paddingBottom", "paddingLeft", "paddingRight"] }, paddingX: { mappings: ["paddingLeft", "paddingRight"] }, paddingY: { mappings: ["paddingTop", "paddingBottom"] }, alignSelf: { values: { "flex-start": { defaultClass: "in5bvie" }, "flex-end": { defaultClass: "in5bvif" }, center: { defaultClass: "in5bvig" } } }, backgroundSize: { values: { cover: { defaultClass: "in5bvih" } } }, borderRadius: { values: { 1: { defaultClass: "in5bvii" }, 6: { defaultClass: "in5bvij" }, 10: { defaultClass: "in5bvik" }, 13: { defaultClass: "in5bvil" }, actionButton: { defaultClass: "in5bvim" }, connectButton: { defaultClass: "in5bvin" }, menuButton: { defaultClass: "in5bvio" }, modal: { defaultClass: "in5bvip" }, modalMobile: { defaultClass: "in5bviq" }, "25%": { defaultClass: "in5bvir" }, full: { defaultClass: "in5bvis" } } }, borderStyle: { values: { solid: { defaultClass: "in5bvit" } } }, borderWidth: { values: { 0: { defaultClass: "in5bviu" }, 1: { defaultClass: "in5bviv" }, 2: { defaultClass: "in5bviw" }, 4: { defaultClass: "in5bvix" } } }, cursor: { values: { pointer: { defaultClass: "in5bviy" }, none: { defaultClass: "in5bviz" } } }, pointerEvents: { values: { none: { defaultClass: "in5bvi10" }, all: { defaultClass: "in5bvi11" } } }, minHeight: { values: { 8: { defaultClass: "in5bvi12" }, 44: { defaultClass: "in5bvi13" } } }, flexDirection: { values: { row: { defaultClass: "in5bvi14" }, column: { defaultClass: "in5bvi15" } } }, fontFamily: { values: { body: { defaultClass: "in5bvi16" } } }, fontSize: { values: { 12: { defaultClass: "in5bvi17" }, 13: { defaultClass: "in5bvi18" }, 14: { defaultClass: "in5bvi19" }, 16: { defaultClass: "in5bvi1a" }, 18: { defaultClass: "in5bvi1b" }, 20: { defaultClass: "in5bvi1c" }, 23: { defaultClass: "in5bvi1d" } } }, fontWeight: { values: { regular: { defaultClass: "in5bvi1e" }, medium: { defaultClass: "in5bvi1f" }, semibold: { defaultClass: "in5bvi1g" }, bold: { defaultClass: "in5bvi1h" }, heavy: { defaultClass: "in5bvi1i" } } }, gap: { values: { 0: { defaultClass: "in5bvi1j" }, 1: { defaultClass: "in5bvi1k" }, 2: { defaultClass: "in5bvi1l" }, 3: { defaultClass: "in5bvi1m" }, 4: { defaultClass: "in5bvi1n" }, 5: { defaultClass: "in5bvi1o" }, 6: { defaultClass: "in5bvi1p" }, 8: { defaultClass: "in5bvi1q" }, 10: { defaultClass: "in5bvi1r" }, 12: { defaultClass: "in5bvi1s" }, 14: { defaultClass: "in5bvi1t" }, 16: { defaultClass: "in5bvi1u" }, 18: { defaultClass: "in5bvi1v" }, 20: { defaultClass: "in5bvi1w" }, 24: { defaultClass: "in5bvi1x" }, 28: { defaultClass: "in5bvi1y" }, 32: { defaultClass: "in5bvi1z" }, 36: { defaultClass: "in5bvi20" }, 44: { defaultClass: "in5bvi21" }, 64: { defaultClass: "in5bvi22" }, "-1": { defaultClass: "in5bvi23" } } }, height: { values: { 1: { defaultClass: "in5bvi24" }, 2: { defaultClass: "in5bvi25" }, 4: { defaultClass: "in5bvi26" }, 8: { defaultClass: "in5bvi27" }, 12: { defaultClass: "in5bvi28" }, 20: { defaultClass: "in5bvi29" }, 24: { defaultClass: "in5bvi2a" }, 28: { defaultClass: "in5bvi2b" }, 30: { defaultClass: "in5bvi2c" }, 32: { defaultClass: "in5bvi2d" }, 34: { defaultClass: "in5bvi2e" }, 36: { defaultClass: "in5bvi2f" }, 40: { defaultClass: "in5bvi2g" }, 44: { defaultClass: "in5bvi2h" }, 48: { defaultClass: "in5bvi2i" }, 54: { defaultClass: "in5bvi2j" }, 60: { defaultClass: "in5bvi2k" }, 200: { defaultClass: "in5bvi2l" }, full: { defaultClass: "in5bvi2m" }, max: { defaultClass: "in5bvi2n" } } }, justifyContent: { values: { "flex-start": { defaultClass: "in5bvi2o" }, "flex-end": { defaultClass: "in5bvi2p" }, center: { defaultClass: "in5bvi2q" }, "space-between": { defaultClass: "in5bvi2r" }, "space-around": { defaultClass: "in5bvi2s" } } }, textAlign: { values: { left: { defaultClass: "in5bvi2t" }, center: { defaultClass: "in5bvi2u" }, inherit: { defaultClass: "in5bvi2v" } } }, marginBottom: { values: { 0: { defaultClass: "in5bvi2w" }, 1: { defaultClass: "in5bvi2x" }, 2: { defaultClass: "in5bvi2y" }, 3: { defaultClass: "in5bvi2z" }, 4: { defaultClass: "in5bvi30" }, 5: { defaultClass: "in5bvi31" }, 6: { defaultClass: "in5bvi32" }, 8: { defaultClass: "in5bvi33" }, 10: { defaultClass: "in5bvi34" }, 12: { defaultClass: "in5bvi35" }, 14: { defaultClass: "in5bvi36" }, 16: { defaultClass: "in5bvi37" }, 18: { defaultClass: "in5bvi38" }, 20: { defaultClass: "in5bvi39" }, 24: { defaultClass: "in5bvi3a" }, 28: { defaultClass: "in5bvi3b" }, 32: { defaultClass: "in5bvi3c" }, 36: { defaultClass: "in5bvi3d" }, 44: { defaultClass: "in5bvi3e" }, 64: { defaultClass: "in5bvi3f" }, "-1": { defaultClass: "in5bvi3g" } } }, marginLeft: { values: { 0: { defaultClass: "in5bvi3h" }, 1: { defaultClass: "in5bvi3i" }, 2: { defaultClass: "in5bvi3j" }, 3: { defaultClass: "in5bvi3k" }, 4: { defaultClass: "in5bvi3l" }, 5: { defaultClass: "in5bvi3m" }, 6: { defaultClass: "in5bvi3n" }, 8: { defaultClass: "in5bvi3o" }, 10: { defaultClass: "in5bvi3p" }, 12: { defaultClass: "in5bvi3q" }, 14: { defaultClass: "in5bvi3r" }, 16: { defaultClass: "in5bvi3s" }, 18: { defaultClass: "in5bvi3t" }, 20: { defaultClass: "in5bvi3u" }, 24: { defaultClass: "in5bvi3v" }, 28: { defaultClass: "in5bvi3w" }, 32: { defaultClass: "in5bvi3x" }, 36: { defaultClass: "in5bvi3y" }, 44: { defaultClass: "in5bvi3z" }, 64: { defaultClass: "in5bvi40" }, "-1": { defaultClass: "in5bvi41" } } }, marginRight: { values: { 0: { defaultClass: "in5bvi42" }, 1: { defaultClass: "in5bvi43" }, 2: { defaultClass: "in5bvi44" }, 3: { defaultClass: "in5bvi45" }, 4: { defaultClass: "in5bvi46" }, 5: { defaultClass: "in5bvi47" }, 6: { defaultClass: "in5bvi48" }, 8: { defaultClass: "in5bvi49" }, 10: { defaultClass: "in5bvi4a" }, 12: { defaultClass: "in5bvi4b" }, 14: { defaultClass: "in5bvi4c" }, 16: { defaultClass: "in5bvi4d" }, 18: { defaultClass: "in5bvi4e" }, 20: { defaultClass: "in5bvi4f" }, 24: { defaultClass: "in5bvi4g" }, 28: { defaultClass: "in5bvi4h" }, 32: { defaultClass: "in5bvi4i" }, 36: { defaultClass: "in5bvi4j" }, 44: { defaultClass: "in5bvi4k" }, 64: { defaultClass: "in5bvi4l" }, "-1": { defaultClass: "in5bvi4m" } } }, marginTop: { values: { 0: { defaultClass: "in5bvi4n" }, 1: { defaultClass: "in5bvi4o" }, 2: { defaultClass: "in5bvi4p" }, 3: { defaultClass: "in5bvi4q" }, 4: { defaultClass: "in5bvi4r" }, 5: { defaultClass: "in5bvi4s" }, 6: { defaultClass: "in5bvi4t" }, 8: { defaultClass: "in5bvi4u" }, 10: { defaultClass: "in5bvi4v" }, 12: { defaultClass: "in5bvi4w" }, 14: { defaultClass: "in5bvi4x" }, 16: { defaultClass: "in5bvi4y" }, 18: { defaultClass: "in5bvi4z" }, 20: { defaultClass: "in5bvi50" }, 24: { defaultClass: "in5bvi51" }, 28: { defaultClass: "in5bvi52" }, 32: { defaultClass: "in5bvi53" }, 36: { defaultClass: "in5bvi54" }, 44: { defaultClass: "in5bvi55" }, 64: { defaultClass: "in5bvi56" }, "-1": { defaultClass: "in5bvi57" } } }, maxWidth: { values: { 1: { defaultClass: "in5bvi58" }, 2: { defaultClass: "in5bvi59" }, 4: { defaultClass: "in5bvi5a" }, 8: { defaultClass: "in5bvi5b" }, 12: { defaultClass: "in5bvi5c" }, 20: { defaultClass: "in5bvi5d" }, 24: { defaultClass: "in5bvi5e" }, 28: { defaultClass: "in5bvi5f" }, 30: { defaultClass: "in5bvi5g" }, 32: { defaultClass: "in5bvi5h" }, 34: { defaultClass: "in5bvi5i" }, 36: { defaultClass: "in5bvi5j" }, 40: { defaultClass: "in5bvi5k" }, 44: { defaultClass: "in5bvi5l" }, 48: { defaultClass: "in5bvi5m" }, 54: { defaultClass: "in5bvi5n" }, 60: { defaultClass: "in5bvi5o" }, 200: { defaultClass: "in5bvi5p" }, full: { defaultClass: "in5bvi5q" }, max: { defaultClass: "in5bvi5r" } } }, minWidth: { values: { 1: { defaultClass: "in5bvi5s" }, 2: { defaultClass: "in5bvi5t" }, 4: { defaultClass: "in5bvi5u" }, 8: { defaultClass: "in5bvi5v" }, 12: { defaultClass: "in5bvi5w" }, 20: { defaultClass: "in5bvi5x" }, 24: { defaultClass: "in5bvi5y" }, 28: { defaultClass: "in5bvi5z" }, 30: { defaultClass: "in5bvi60" }, 32: { defaultClass: "in5bvi61" }, 34: { defaultClass: "in5bvi62" }, 36: { defaultClass: "in5bvi63" }, 40: { defaultClass: "in5bvi64" }, 44: { defaultClass: "in5bvi65" }, 48: { defaultClass: "in5bvi66" }, 54: { defaultClass: "in5bvi67" }, 60: { defaultClass: "in5bvi68" }, 200: { defaultClass: "in5bvi69" }, full: { defaultClass: "in5bvi6a" }, max: { defaultClass: "in5bvi6b" } } }, overflow: { values: { hidden: { defaultClass: "in5bvi6c" } } }, paddingBottom: { values: { 0: { defaultClass: "in5bvi6d" }, 1: { defaultClass: "in5bvi6e" }, 2: { defaultClass: "in5bvi6f" }, 3: { defaultClass: "in5bvi6g" }, 4: { defaultClass: "in5bvi6h" }, 5: { defaultClass: "in5bvi6i" }, 6: { defaultClass: "in5bvi6j" }, 8: { defaultClass: "in5bvi6k" }, 10: { defaultClass: "in5bvi6l" }, 12: { defaultClass: "in5bvi6m" }, 14: { defaultClass: "in5bvi6n" }, 16: { defaultClass: "in5bvi6o" }, 18: { defaultClass: "in5bvi6p" }, 20: { defaultClass: "in5bvi6q" }, 24: { defaultClass: "in5bvi6r" }, 28: { defaultClass: "in5bvi6s" }, 32: { defaultClass: "in5bvi6t" }, 36: { defaultClass: "in5bvi6u" }, 44: { defaultClass: "in5bvi6v" }, 64: { defaultClass: "in5bvi6w" }, "-1": { defaultClass: "in5bvi6x" } } }, paddingLeft: { values: { 0: { defaultClass: "in5bvi6y" }, 1: { defaultClass: "in5bvi6z" }, 2: { defaultClass: "in5bvi70" }, 3: { defaultClass: "in5bvi71" }, 4: { defaultClass: "in5bvi72" }, 5: { defaultClass: "in5bvi73" }, 6: { defaultClass: "in5bvi74" }, 8: { defaultClass: "in5bvi75" }, 10: { defaultClass: "in5bvi76" }, 12: { defaultClass: "in5bvi77" }, 14: { defaultClass: "in5bvi78" }, 16: { defaultClass: "in5bvi79" }, 18: { defaultClass: "in5bvi7a" }, 20: { defaultClass: "in5bvi7b" }, 24: { defaultClass: "in5bvi7c" }, 28: { defaultClass: "in5bvi7d" }, 32: { defaultClass: "in5bvi7e" }, 36: { defaultClass: "in5bvi7f" }, 44: { defaultClass: "in5bvi7g" }, 64: { defaultClass: "in5bvi7h" }, "-1": { defaultClass: "in5bvi7i" } } }, paddingRight: { values: { 0: { defaultClass: "in5bvi7j" }, 1: { defaultClass: "in5bvi7k" }, 2: { defaultClass: "in5bvi7l" }, 3: { defaultClass: "in5bvi7m" }, 4: { defaultClass: "in5bvi7n" }, 5: { defaultClass: "in5bvi7o" }, 6: { defaultClass: "in5bvi7p" }, 8: { defaultClass: "in5bvi7q" }, 10: { defaultClass: "in5bvi7r" }, 12: { defaultClass: "in5bvi7s" }, 14: { defaultClass: "in5bvi7t" }, 16: { defaultClass: "in5bvi7u" }, 18: { defaultClass: "in5bvi7v" }, 20: { defaultClass: "in5bvi7w" }, 24: { defaultClass: "in5bvi7x" }, 28: { defaultClass: "in5bvi7y" }, 32: { defaultClass: "in5bvi7z" }, 36: { defaultClass: "in5bvi80" }, 44: { defaultClass: "in5bvi81" }, 64: { defaultClass: "in5bvi82" }, "-1": { defaultClass: "in5bvi83" } } }, paddingTop: { values: { 0: { defaultClass: "in5bvi84" }, 1: { defaultClass: "in5bvi85" }, 2: { defaultClass: "in5bvi86" }, 3: { defaultClass: "in5bvi87" }, 4: { defaultClass: "in5bvi88" }, 5: { defaultClass: "in5bvi89" }, 6: { defaultClass: "in5bvi8a" }, 8: { defaultClass: "in5bvi8b" }, 10: { defaultClass: "in5bvi8c" }, 12: { defaultClass: "in5bvi8d" }, 14: { defaultClass: "in5bvi8e" }, 16: { defaultClass: "in5bvi8f" }, 18: { defaultClass: "in5bvi8g" }, 20: { defaultClass: "in5bvi8h" }, 24: { defaultClass: "in5bvi8i" }, 28: { defaultClass: "in5bvi8j" }, 32: { defaultClass: "in5bvi8k" }, 36: { defaultClass: "in5bvi8l" }, 44: { defaultClass: "in5bvi8m" }, 64: { defaultClass: "in5bvi8n" }, "-1": { defaultClass: "in5bvi8o" } } }, position: { values: { absolute: { defaultClass: "in5bvi8p" }, fixed: { defaultClass: "in5bvi8q" }, relative: { defaultClass: "in5bvi8r" } } }, WebkitUserSelect: { values: { none: { defaultClass: "in5bvi8s" } } }, right: { values: { 0: { defaultClass: "in5bvi8t" } } }, transition: { values: { default: { defaultClass: "in5bvi8u" }, transform: { defaultClass: "in5bvi8v" } } }, userSelect: { values: { none: { defaultClass: "in5bvi8w" } } }, width: { values: { 1: { defaultClass: "in5bvi8x" }, 2: { defaultClass: "in5bvi8y" }, 4: { defaultClass: "in5bvi8z" }, 8: { defaultClass: "in5bvi90" }, 12: { defaultClass: "in5bvi91" }, 20: { defaultClass: "in5bvi92" }, 24: { defaultClass: "in5bvi93" }, 28: { defaultClass: "in5bvi94" }, 30: { defaultClass: "in5bvi95" }, 32: { defaultClass: "in5bvi96" }, 34: { defaultClass: "in5bvi97" }, 36: { defaultClass: "in5bvi98" }, 40: { defaultClass: "in5bvi99" }, 44: { defaultClass: "in5bvi9a" }, 48: { defaultClass: "in5bvi9b" }, 54: { defaultClass: "in5bvi9c" }, 60: { defaultClass: "in5bvi9d" }, 200: { defaultClass: "in5bvi9e" }, full: { defaultClass: "in5bvi9f" }, max: { defaultClass: "in5bvi9g" } } }, backdropFilter: { values: { modalOverlay: { defaultClass: "in5bvi9h" } } } } }), dU = { colors: { accentColor: "var(--rk-colors-accentColor)", accentColorForeground: "var(--rk-colors-accentColorForeground)", actionButtonBorder: "var(--rk-colors-actionButtonBorder)", actionButtonBorderMobile: "var(--rk-colors-actionButtonBorderMobile)", actionButtonSecondaryBackground: "var(--rk-colors-actionButtonSecondaryBackground)", closeButton: "var(--rk-colors-closeButton)", closeButtonBackground: "var(--rk-colors-closeButtonBackground)", connectButtonBackground: "var(--rk-colors-connectButtonBackground)", connectButtonBackgroundError: "var(--rk-colors-connectButtonBackgroundError)", connectButtonInnerBackground: "var(--rk-colors-connectButtonInnerBackground)", connectButtonText: "var(--rk-colors-connectButtonText)", connectButtonTextError: "var(--rk-colors-connectButtonTextError)", connectionIndicator: "var(--rk-colors-connectionIndicator)", downloadBottomCardBackground: "var(--rk-colors-downloadBottomCardBackground)", downloadTopCardBackground: "var(--rk-colors-downloadTopCardBackground)", error: "var(--rk-colors-error)", generalBorder: "var(--rk-colors-generalBorder)", generalBorderDim: "var(--rk-colors-generalBorderDim)", menuItemBackground: "var(--rk-colors-menuItemBackground)", modalBackdrop: "var(--rk-colors-modalBackdrop)", modalBackground: "var(--rk-colors-modalBackground)", modalBorder: "var(--rk-colors-modalBorder)", modalText: "var(--rk-colors-modalText)", modalTextDim: "var(--rk-colors-modalTextDim)", modalTextSecondary: "var(--rk-colors-modalTextSecondary)", profileAction: "var(--rk-colors-profileAction)", profileActionHover: "var(--rk-colors-profileActionHover)", profileForeground: "var(--rk-colors-profileForeground)", selectedOptionBorder: "var(--rk-colors-selectedOptionBorder)", standby: "var(--rk-colors-standby)" }, fonts: { body: "var(--rk-fonts-body)" }, radii: { actionButton: "var(--rk-radii-actionButton)", connectButton: "var(--rk-radii-connectButton)", menuButton: "var(--rk-radii-menuButton)", modal: "var(--rk-radii-modal)", modalMobile: "var(--rk-radii-modalMobile)" }, shadows: { connectButton: "var(--rk-shadows-connectButton)", dialog: "var(--rk-shadows-dialog)", profileDetailsAction: "var(--rk-shadows-profileDetailsAction)", selectedOption: "var(--rk-shadows-selectedOption)", selectedWallet: "var(--rk-shadows-selectedWallet)", walletLogo: "var(--rk-shadows-walletLogo)" }, blurs: { modalOverlay: "var(--rk-blurs-modalOverlay)" } }, H1e = { shrink: "_1y8a2mu6", shrinkSm: "_1y8a2mu7" }, q1e = "_1y8a2mu3 in5bvi8r", W1e = { grow: "_1y8a2mu4", growLg: "_1y8a2mu5" };
function ao({ active: e, hover: t }) {
  return [q1e, t && W1e[t], H1e[e]];
}
var oG = k.createContext(
  null
);
function G1e() {
  const { adapter: e } = k.useContext(oG) ?? {};
  if (!e)
    throw new Error("No authentication adapter found");
  return e;
}
function iA() {
  const e = k.useContext(oG);
  return (e == null ? void 0 : e.status) ?? null;
}
function oP() {
  const e = iA(), { isConnected: t } = os();
  return t ? e && (e === "loading" || e === "unauthenticated") ? e : "connected" : "disconnected";
}
function K1e() {
  return typeof navigator < "u" && /android/i.test(navigator.userAgent);
}
function Y1e() {
  return typeof navigator < "u" && /iPhone|iPod/.test(navigator.userAgent);
}
function Q1e() {
  return typeof navigator < "u" && (/iPad/.test(navigator.userAgent) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
}
function oA() {
  return Y1e() || Q1e();
}
function aa() {
  return K1e() || oA();
}
var X1e = "ssroob0", J1e = { a: "ssrooba", blockquote: "ssroob2", button: "ssroob9", input: "ssroob8 ssroob5 ssroob4", mark: "ssroob6", ol: "ssroob1", q: "ssroob2", select: "ssroob7 ssroob5 ssroob4", table: "ssroob3", textarea: "ssroob5 ssroob4", ul: "ssroob1" }, Z1e = ({ reset: e, ...t }) => {
  if (!e)
    return X5(t);
  const n = J1e[e], r = X5(t);
  return cW(X1e, n, r);
}, ge = k.forwardRef(
  ({ as: e = "div", className: t, testId: n, ...r }, i) => {
    const o = {}, s = {};
    for (const u in r)
      X5.properties.has(u) ? o[u] = r[u] : s[u] = r[u];
    const c = Z1e({
      reset: typeof e == "string" ? e : "div",
      ...o
    });
    return k.createElement(e, {
      className: cW(c, t),
      ...s,
      "data-testid": n ? `rk-${n.replace(/^rk-/, "")}` : void 0,
      ref: i
    });
  }
);
ge.displayName = "Box";
var aG = /* @__PURE__ */ new Map(), kO = /* @__PURE__ */ new Map();
async function sG(e) {
  const t = kO.get(e);
  if (t)
    return t;
  const n = async () => e().then(async (i) => (aG.set(e, i), i)), r = n().catch((i) => n().catch((o) => {
    kO.delete(e);
  }));
  return kO.set(e, r), r;
}
async function zu(...e) {
  return await Promise.all(
    e.map((t) => typeof t == "function" ? sG(t) : t)
  );
}
function eCe() {
  const [, e] = k.useReducer((t) => t + 1, 0);
  return e;
}
function aP(e) {
  const t = typeof e == "function" ? aG.get(e) : void 0, n = eCe();
  return k.useEffect(() => {
    typeof e == "function" && !t && sG(e).then(n);
  }, [e, t, n]), typeof e == "function" ? t : e;
}
function _o({
  alt: e,
  background: t,
  borderColor: n,
  borderRadius: r,
  useAsImage: i,
  boxShadow: o,
  height: s,
  src: c,
  width: u,
  testId: f
}) {
  const p = oA(), y = aP(c), v = y && /^http/.test(y), [w, C] = k.useReducer(
    () => !0,
    !1
  );
  return /* @__PURE__ */ $.createElement(
    ge,
    {
      "aria-label": e,
      borderRadius: r,
      boxShadow: o,
      height: typeof s == "string" ? s : void 0,
      overflow: "hidden",
      position: "relative",
      role: "img",
      style: {
        background: t,
        height: typeof s == "number" ? s : void 0,
        width: typeof u == "number" ? u : void 0
      },
      width: typeof u == "string" ? u : void 0,
      testId: f
    },
    /* @__PURE__ */ $.createElement(
      ge,
      {
        ...v ? (
          // biome-ignore format: design system keys
          {
            "aria-hidden": !0,
            as: "img",
            onLoad: C,
            src: y
          }
        ) : { "aria-hidden": !0, as: "img", src: y },
        height: "full",
        position: "absolute",
        ...p ? { WebkitUserSelect: "none" } : {},
        style: {
          WebkitTouchCallout: "none",
          transition: "opacity .15s linear",
          userSelect: "none",
          ...!i && v ? {
            opacity: w ? 1 : 0
          } : {}
        },
        width: "full"
      }
    ),
    n ? /* @__PURE__ */ $.createElement(
      ge,
      {
        ...typeof n == "object" && "custom" in n ? { style: { borderColor: n.custom } } : { borderColor: n },
        borderRadius: r,
        borderStyle: "solid",
        borderWidth: "1",
        height: "full",
        position: "relative",
        width: "full"
      }
    ) : null
  );
}
var tCe = "ovowzo2", nCe = "ovowzo3", rCe = (e) => k.useMemo(
  () => `${e}_${Math.round(Math.random() * 1e9)}`,
  [e]
), fC = ({
  height: e = 21,
  width: t = 21
}) => {
  const n = rCe("spinner");
  return /* @__PURE__ */ $.createElement(
    "svg",
    {
      className: tCe,
      fill: "none",
      height: e,
      viewBox: "0 0 21 21",
      width: t,
      xmlns: "http://www.w3.org/2000/svg"
    },
    /* @__PURE__ */ $.createElement("title", null, "Loading"),
    /* @__PURE__ */ $.createElement("clipPath", { id: n }, /* @__PURE__ */ $.createElement("path", { d: "M10.5 3C6.35786 3 3 6.35786 3 10.5C3 14.6421 6.35786 18 10.5 18C11.3284 18 12 18.6716 12 19.5C12 20.3284 11.3284 21 10.5 21C4.70101 21 0 16.299 0 10.5C0 4.70101 4.70101 0 10.5 0C16.299 0 21 4.70101 21 10.5C21 11.3284 20.3284 12 19.5 12C18.6716 12 18 11.3284 18 10.5C18 6.35786 14.6421 3 10.5 3Z" })),
    /* @__PURE__ */ $.createElement(
      "foreignObject",
      {
        clipPath: `url(#${n})`,
        height: "21",
        width: "21",
        x: "0",
        y: "0"
      },
      /* @__PURE__ */ $.createElement("div", { className: nCe })
    )
  );
}, hr = [
  "#FC5C54",
  "#FFD95A",
  "#E95D72",
  "#6A87C8",
  "#5FD0F3",
  "#75C06B",
  "#FFDD86",
  "#5FC6D4",
  "#FF949A",
  "#FF8024",
  "#9BA1A4",
  "#EC66FF",
  "#FF8CBC",
  "#FF9A23",
  "#C5DADB",
  "#A8CE63",
  "#71ABFF",
  "#FFE279",
  "#B6B1B6",
  "#FF6780",
  "#A575FF",
  "#4D82FF",
  "#FFB35A"
], fU = [
  { color: hr[0], emoji: "" },
  { color: hr[1], emoji: "" },
  { color: hr[2], emoji: "" },
  { color: hr[3], emoji: "" },
  { color: hr[4], emoji: "" },
  { color: hr[0], emoji: "" },
  { color: hr[5], emoji: "" },
  { color: hr[6], emoji: "" },
  { color: hr[7], emoji: "" },
  { color: hr[8], emoji: "" },
  { color: hr[9], emoji: "" },
  { color: hr[10], emoji: "" },
  { color: hr[11], emoji: "" },
  { color: hr[12], emoji: "" },
  { color: hr[13], emoji: "" },
  { color: hr[8], emoji: "" },
  { color: hr[14], emoji: "" },
  { color: hr[0], emoji: "" },
  { color: hr[8], emoji: "" },
  { color: hr[1], emoji: "" },
  { color: hr[15], emoji: "" },
  { color: hr[16], emoji: "" },
  { color: hr[17], emoji: "" },
  { color: hr[18], emoji: "" },
  { color: hr[19], emoji: "" },
  { color: hr[1], emoji: "" },
  { color: hr[20], emoji: "" },
  { color: hr[15], emoji: "" },
  { color: hr[0], emoji: "" },
  { color: hr[17], emoji: "" },
  { color: hr[4], emoji: "" },
  { color: hr[21], emoji: "" },
  { color: hr[17], emoji: "" },
  { color: hr[8], emoji: "" },
  { color: hr[22], emoji: "" }
];
function iCe(e) {
  let t = 0;
  if (e.length === 0)
    return t;
  for (let n = 0; n < e.length; n++) {
    const r = e.charCodeAt(n);
    t = (t << 5) - t + r, t |= 0;
  }
  return t;
}
function oCe(e) {
  const n = Math.abs(
    iCe((typeof e == "string" ? e : "").toLowerCase()) % fU.length
  );
  return fU[n ?? 0];
}
var aCe = ({ address: e, ensImage: t, size: n }) => {
  const [r, i] = k.useState(!1);
  k.useEffect(() => {
    if (t) {
      const c = new Image();
      c.src = t, c.onload = () => i(!0);
    }
  }, [t]);
  const { color: o, emoji: s } = k.useMemo(
    () => oCe(e),
    [e]
  );
  return t ? r ? /* @__PURE__ */ $.createElement(
    ge,
    {
      backgroundSize: "cover",
      borderRadius: "full",
      position: "absolute",
      style: {
        backgroundImage: `url(${t})`,
        backgroundPosition: "center",
        height: n,
        width: n
      }
    }
  ) : /* @__PURE__ */ $.createElement(
    ge,
    {
      alignItems: "center",
      backgroundSize: "cover",
      borderRadius: "full",
      color: "modalText",
      display: "flex",
      justifyContent: "center",
      position: "absolute",
      style: {
        height: n,
        width: n
      }
    },
    /* @__PURE__ */ $.createElement(fC, null)
  ) : /* @__PURE__ */ $.createElement(
    ge,
    {
      alignItems: "center",
      display: "flex",
      justifyContent: "center",
      overflow: "hidden",
      style: {
        ...!t && { backgroundColor: o },
        height: n,
        width: n
      }
    },
    s
  );
}, lG = aCe, sP = k.createContext(lG);
function cG({ address: e, imageUrl: t, loading: n, size: r }) {
  const i = k.useContext(sP);
  return /* @__PURE__ */ $.createElement(
    ge,
    {
      "aria-hidden": !0,
      borderRadius: "full",
      overflow: "hidden",
      position: "relative",
      style: {
        height: `${r}px`,
        width: `${r}px`
      },
      userSelect: "none"
    },
    /* @__PURE__ */ $.createElement(
      ge,
      {
        alignItems: "center",
        borderRadius: "full",
        display: "flex",
        justifyContent: "center",
        overflow: "hidden",
        position: "absolute",
        style: {
          fontSize: `${Math.round(r * 0.55)}px`,
          height: `${r}px`,
          transform: n ? "scale(0.72)" : void 0,
          transition: ".25s ease",
          transitionDelay: n ? void 0 : ".1s",
          width: `${r}px`,
          willChange: "transform"
        },
        userSelect: "none"
      },
      /* @__PURE__ */ $.createElement(i, { address: e, ensImage: t, size: r })
    ),
    n && /* @__PURE__ */ $.createElement(
      ge,
      {
        color: "accentColor",
        display: "flex",
        height: "full",
        position: "absolute",
        width: "full"
      },
      /* @__PURE__ */ $.createElement(fC, { height: "100%", width: "100%" })
    )
  );
}
var hU = () => /* @__PURE__ */ $.createElement("svg", { fill: "none", height: "7", width: "14", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ $.createElement("title", null, "Dropdown"), /* @__PURE__ */ $.createElement(
  "path",
  {
    d: "M12.75 1.54001L8.51647 5.0038C7.77974 5.60658 6.72026 5.60658 5.98352 5.0038L1.75 1.54001",
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: "2.5",
    xmlns: "http://www.w3.org/2000/svg"
  }
)), pU = {
  defaultLocale: "en",
  locale: "en"
}, sCe = class {
  constructor(e) {
    this.listeners = /* @__PURE__ */ new Set(), this.defaultLocale = pU.defaultLocale, this.enableFallback = !1, this.locale = pU.locale, this.cachedLocales = [], this.translations = {};
    for (const [t, n] of Object.entries(e))
      this.cachedLocales = [...this.cachedLocales, t], this.translations = {
        ...this.translations,
        ...this.flattenTranslation(n, t)
      };
  }
  missingMessage(e) {
    return `[missing: "${this.locale}.${e}" translation]`;
  }
  flattenTranslation(e, t) {
    const n = {}, r = (i, o) => {
      for (const s of Object.keys(i)) {
        const c = `${o}.${s}`, u = i[s];
        typeof u == "object" && u !== null ? r(u, c) : n[c] = u;
      }
    };
    return r(e, t), n;
  }
  translateWithReplacements(e, t = {}) {
    let n = e;
    for (const r in t) {
      const i = t[r];
      n = n.replace(
        `%{${r}}`,
        i
      );
    }
    return n;
  }
  t(e, t, n) {
    const r = `${this.locale}.${e}`, i = this.translations[r];
    if (!i) {
      if (this.enableFallback) {
        const o = `${this.defaultLocale}.${e}`, s = this.translations[o];
        if (s)
          return this.translateWithReplacements(
            s,
            t
          );
      }
      return n != null && n.rawKeyIfTranslationMissing ? e : this.missingMessage(e);
    }
    return this.translateWithReplacements(i, t);
  }
  isLocaleCached(e) {
    return this.cachedLocales.includes(e);
  }
  updateLocale(e) {
    this.locale = e, this.notifyListeners();
  }
  setTranslations(e, t) {
    this.isLocaleCached(e) || (this.cachedLocales = [...this.cachedLocales, e], this.translations = {
      ...this.translations,
      ...this.flattenTranslation(t, e)
    }), this.locale = e, this.notifyListeners();
  }
  notifyListeners() {
    for (const e of this.listeners)
      e();
  }
  onChange(e) {
    return this.listeners.add(e), () => {
      this.listeners.delete(e);
    };
  }
}, Hl = new sCe({
  en: JSON.parse(s5),
  "en-US": JSON.parse(s5)
});
Hl.defaultLocale = "en-US";
Hl.locale = "en-US";
Hl.enableFallback = !0;
var lCe = async (e) => {
  switch (e) {
    case "ar":
    case "ar-AR":
      return (await import("./ar_AR-OBNLAES4-CP8uriDC.js")).default;
    case "en":
    case "en-US":
      return (await Promise.resolve().then(() => Mz)).default;
    case "es":
    case "es-419":
      return (await import("./es_419-O2GTQZ7N-CktXSPbx.js")).default;
    case "fr":
    case "fr-FR":
      return (await import("./fr_FR-L4QMIDHZ-CCvrhIhL.js")).default;
    case "hi":
    case "hi-IN":
      return (await import("./hi_IN-JNRRBHWZ-CV6ETqFR.js")).default;
    case "id":
    case "id-ID":
      return (await import("./id_ID-ZGYTXMOP-CJW1alZM.js")).default;
    case "ja":
    case "ja-JP":
      return (await import("./ja_JP-HOTHN4EA-D8x1lfTC.js")).default;
    case "ko":
    case "ko-KR":
      return (await import("./ko_KR-GIW3THCV-C0_jdZ5q.js")).default;
    case "pt":
    case "pt-BR":
      return (await import("./pt_BR-F7QMXAJN-DQfbbVyM.js")).default;
    case "ru":
    case "ru-RU":
      return (await import("./ru_RU-X7PLXGFL-BLEDrcZ5.js")).default;
    case "th":
    case "th-TH":
      return (await import("./th_TH-SRCDFUPR-D-CraGpH.js")).default;
    case "tr":
    case "tr-TR":
      return (await import("./tr_TR-YZS5CIK5-BC6lPtp-.js")).default;
    case "ua":
    case "uk-UA":
      return (await import("./uk_UA-Y3657REC-sU17JGKp.js")).default;
    case "zh":
    case "zh-CN":
      return (await import("./zh_CN-UU5O3W4T-W_jRIpOa.js")).default;
    default:
      return (await Promise.resolve().then(() => Mz)).default;
  }
};
async function mU(e) {
  if (Hl.isLocaleCached(e)) {
    Hl.updateLocale(e);
    return;
  }
  const n = await lCe(e);
  Hl.setTranslations(e, JSON.parse(n));
}
var cCe = () => {
  var e;
  if (typeof window < "u" && typeof navigator < "u") {
    if ((e = navigator.languages) != null && e.length)
      return navigator.languages[0];
    if (navigator.language)
      return navigator.language;
  }
}, fo = k.createContext({ i18n: Hl }), uCe = ({ children: e, locale: t }) => {
  const [n, r] = k.useState(0), i = k.useMemo(
    () => cCe(),
    []
  );
  k.useEffect(() => Hl.onChange(() => {
    r((c) => c + 1);
  }), []), k.useEffect(() => {
    t && t !== Hl.locale ? mU(t) : !t && i && i !== Hl.locale && mU(i);
  }, [t, i]);
  const o = k.useMemo(() => ({ t: (c, u) => Hl.t(c, u), i18n: Hl }), [n]);
  return /* @__PURE__ */ $.createElement(fo.Provider, { value: o }, e);
};
function uG(e) {
  return e != null;
}
var AO = {
  iconBackground: "#96bedc",
  iconUrl: async () => (await import("./arbitrum-IA4OWRTN-LVcx04aO.js")).default
}, yU = {
  iconBackground: "#e84141",
  iconUrl: async () => (await import("./avalanche-MXEFEDSW-DlgO0qQx.js")).default
}, TO = {
  iconBackground: "#0052ff",
  iconUrl: async () => (await import("./base-Z4LFBE5D-BqATp9LA.js")).default
}, vU = {
  iconBackground: "#000000",
  iconUrl: async () => (await import("./blast-TN2WIMWF-BaQl6p0Y.js")).default
}, gU = {
  iconBackground: "#ebac0e",
  iconUrl: async () => (await import("./bsc-RVE67I5L-Cj5-b_tF.js")).default
}, bU = {
  iconBackground: "#002D74",
  iconUrl: async () => (await import("./cronos-ROYR77VZ-CNKuAMt6.js")).default
}, Ch = {
  iconBackground: "#484c50",
  iconUrl: async () => (await import("./ethereum-RFBAMUVK-CFKFlsOS.js")).default
}, dCe = {
  iconBackground: "#f9f7ec",
  iconUrl: async () => (await import("./hardhat-NEEC6JX7-B-CuVQdM.js")).default
}, wU = {
  iconBackground: "transparent",
  iconUrl: async () => (await import("./klaytn-OYHSPTO4-CLgeScaa.js")).default
}, Mk = {
  iconBackground: "#ff5a57",
  iconUrl: async () => (await import("./optimism-VD7XDD2W-CUTi_PRJ.js")).default
}, _O = {
  iconBackground: "#ffffff",
  iconUrl: async () => (await import("./manta-5V6W5D7G-KOQ8pJGF.js")).default
}, CU = {
  iconBackground: "#000000",
  iconUrl: async () => (await import("./mantle-KBL3OIYT-D6WQlfnc.js")).default
}, xU = {
  iconBackground: "#9f71ec",
  iconUrl: async () => (await import("./polygon-WWEUOMKW-DqF_DIy6.js")).default
}, EU = {
  iconBackground: "#f9f7ec",
  iconUrl: async () => (await import("./xdc-X7V4QFNF-Db083PW0.js")).default
}, SU = {
  iconBackground: "#000000",
  iconUrl: async () => (await import("./zetachain-BMJKVYBN-BnlPqG25.js")).default
}, kU = {
  iconBackground: "#f9f7ec",
  iconUrl: async () => (await import("./zkSync-JL26RB7U-h4LBdf7l.js")).default
}, RO = {
  iconBackground: "#000000",
  iconUrl: async () => (await import("./zora-YZH32HP3-Bb6XLxks.js")).default
}, fCe = {
  iconBackground: "#1273EA",
  iconUrl: async () => (await import("./ronin-PNHX5V6H-CdeCKQnT.js")).default
}, hCe = {
  arbitrum: { chainId: 42161, name: "Arbitrum", ...AO },
  arbitrumGoerli: { chainId: 421613, ...AO },
  arbitrumSepolia: { chainId: 421614, ...AO },
  avalanche: { chainId: 43114, ...yU },
  avalancheFuji: { chainId: 43113, ...yU },
  base: { chainId: 8453, name: "Base", ...TO },
  baseGoerli: { chainId: 84531, ...TO },
  baseSepolia: { chainId: 84532, ...TO },
  blast: { chainId: 81457, name: "Blast", ...vU },
  blastSepolia: { chainId: 168587773, ...vU },
  bsc: { chainId: 56, name: "BSC", ...gU },
  bscTestnet: { chainId: 97, ...gU },
  cronos: { chainId: 25, ...bU },
  cronosTestnet: { chainId: 338, ...bU },
  goerli: { chainId: 5, ...Ch },
  hardhat: { chainId: 31337, ...dCe },
  holesky: { chainId: 17e3, ...Ch },
  kovan: { chainId: 42, ...Ch },
  klaytn: { chainId: 8217, name: "Klaytn", ...wU },
  klaytnBaobab: { chainId: 1001, name: "Klaytn Baobab", ...wU },
  localhost: { chainId: 1337, ...Ch },
  mainnet: { chainId: 1, name: "Ethereum", ...Ch },
  manta: { chainId: 169, name: "Manta", ..._O },
  mantaSepolia: { chainId: 3441006, ..._O },
  mantaTestnet: { chainId: 3441005, ..._O },
  mantle: { chainId: 5e3, ...CU },
  mantleTestnet: { chainId: 5001, ...CU },
  optimism: { chainId: 10, name: "Optimism", ...Mk },
  optimismGoerli: { chainId: 420, ...Mk },
  optimismKovan: { chainId: 69, ...Mk },
  optimismSepolia: { chainId: 11155420, ...Mk },
  polygon: { chainId: 137, name: "Polygon", ...xU },
  polygonMumbai: { chainId: 80001, ...xU },
  rinkeby: { chainId: 4, ...Ch },
  ropsten: { chainId: 3, ...Ch },
  ronin: { chainId: 2020, ...fCe },
  sepolia: { chainId: 11155111, ...Ch },
  xdc: { chainId: 50, name: "XinFin", ...EU },
  xdcTestnet: { chainId: 51, ...EU },
  zetachain: { chainId: 7e3, name: "ZetaChain", ...SU },
  zetachainAthensTestnet: {
    chainId: 7001,
    name: "Zeta Athens",
    ...SU
  },
  zkSync: { chainId: 324, name: "zkSync", ...kU },
  zkSyncTestnet: { chainId: 280, ...kU },
  zora: { chainId: 7777777, name: "Zora", ...RO },
  zoraSepolia: { chainId: 999999999, ...RO },
  zoraTestnet: { chainId: 999, ...RO }
}, pCe = Object.fromEntries(
  Object.values(hCe).filter(uG).map(({ chainId: e, ...t }) => [e, t])
), AU = (e) => e.map((t) => {
  const n = pCe[t.id] ?? {};
  return {
    ...t,
    name: n.name ?? t.name,
    // favor colloquial names
    iconUrl: t.iconUrl ?? n.iconUrl,
    iconBackground: t.iconBackground ?? n.iconBackground
  };
}), ZC = k.createContext({
  disabledChains: [],
  chains: []
});
function mCe({
  chainIdsToUse: e,
  disabledChains: t,
  onDisabledChainClick: n,
  children: r,
  initialChain: i
}) {
  const { chains: o } = Ho(), s = k.useMemo(
    () => AU(
      e ? o.filter(
        (c) => e.has(c.id)
      ) : o
    ),
    [e, o]
  );
  return /* @__PURE__ */ $.createElement(
    ZC.Provider,
    {
      value: k.useMemo(
        () => ({
          chains: s,
          disabledChains: AU(
            t ?? []
          ),
          onDisabledChainClick: n,
          initialChainId: typeof i == "number" ? i : i == null ? void 0 : i.id
        }),
        [
          o,
          i,
          t,
          n,
          s
        ]
      )
    },
    r
  );
}
var uy = () => k.useContext(ZC).chains, yCe = () => k.useContext(ZC).disabledChains, vCe = () => k.useContext(ZC).onDisabledChainClick, gCe = () => k.useContext(ZC).initialChainId, bCe = () => {
  const e = uy();
  return k.useMemo(() => {
    const t = {};
    for (const n of e)
      t[n.id] = n;
    return t;
  }, [e]);
}, dG = k.createContext({
  showBalance: void 0,
  setShowBalance: () => {
  }
});
function wCe({ children: e }) {
  const [t, n] = k.useState();
  return /* @__PURE__ */ $.createElement(dG.Provider, { value: { showBalance: t, setShowBalance: n } }, e);
}
var CCe = () => k.useContext(dG);
function xCe() {
  const [e, t] = k.useState(!1);
  return k.useEffect(() => (t(!0), () => {
    t(!1);
  }), []), k.useCallback(() => e, [e]);
}
function fG() {
  const e = uy(), t = Ub.id;
  return e.some(
    (r) => r.id === t
  );
}
function ECe(e) {
  const t = fG(), n = (i) => {
    try {
      return D0e(i);
    } catch {
    }
  }, { data: r } = qbe({
    chainId: Ub.id,
    name: e ? n(e) : void 0,
    query: {
      enabled: t
    }
  });
  return r;
}
function SCe(e) {
  const t = fG(), { data: n } = Wbe({
    chainId: Ub.id,
    address: e,
    query: {
      enabled: t
    }
  });
  return n;
}
function hG({ address: e }) {
  const t = SCe(e), n = ECe(t);
  return { ensName: t, ensAvatar: n };
}
function lP() {
  const { chain: e } = os();
  return (e == null ? void 0 : e.id) ?? null;
}
var pG = "rk-transactions";
function kCe(e) {
  try {
    const t = e ? JSON.parse(e) : {};
    return typeof t == "object" ? t : {};
  } catch {
    return {};
  }
}
function TU() {
  return kCe(
    typeof localStorage < "u" ? localStorage.getItem(pG) : null
  );
}
var ACe = /^0x([A-Fa-f0-9]{64})$/;
function TCe(e) {
  const t = [];
  return ACe.test(e.hash) || t.push("Invalid transaction hash"), typeof e.description != "string" && t.push("Transaction must have a description"), typeof e.confirmations < "u" && (!Number.isInteger(e.confirmations) || e.confirmations < 1) && t.push("Transaction confirmations must be a positiver integer"), t;
}
function _Ce({
  provider: e
}) {
  let t = TU(), n = e;
  const r = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Map();
  function s(I) {
    n = I;
  }
  function c(I, D) {
    var M;
    return ((M = t[I]) == null ? void 0 : M[D]) ?? [];
  }
  function u(I, D, M) {
    const L = TCe(M);
    if (L.length > 0)
      throw new Error(["Unable to add transaction", ...L].join(`
`));
    v(I, D, (j) => [
      { ...M, status: "pending" },
      ...j.filter(({ hash: F }) => F !== M.hash)
    ]);
  }
  function f(I, D) {
    v(I, D, () => []);
  }
  function p(I, D, M, L) {
    v(I, D, (j) => j.map(
      (F) => F.hash === M ? { ...F, status: L } : F
    ));
  }
  async function y(I, D) {
    await Promise.all(
      c(I, D).filter((M) => M.status === "pending").map(async (M) => {
        const { confirmations: L, hash: j } = M, F = o.get(j);
        if (F)
          return await F;
        const O = n.waitForTransactionReceipt({
          confirmations: L,
          hash: j,
          timeout: 3e5
          // 5 minutes
        }).then(({ status: z }) => {
          o.delete(j), z !== void 0 && (p(
            I,
            D,
            j,
            // @ts-ignore - types changed with viem@1.1.0
            z === 0 || z === "reverted" ? "failed" : "confirmed"
          ), x(z));
        }).catch(() => {
          p(I, D, j, "failed");
        });
        return o.set(j, O), await O;
      })
    );
  }
  function v(I, D, M) {
    t = TU(), t[I] = t[I] ?? {};
    let L = 0;
    const j = 10, F = M(t[I][D] ?? []).filter(({ status: O }) => O === "pending" ? !0 : L++ <= j);
    t[I][D] = F.length > 0 ? F : void 0, w(), C(), y(I, D);
  }
  function w() {
    localStorage.setItem(pG, JSON.stringify(t));
  }
  function C() {
    for (const I of r)
      I();
  }
  function x(I) {
    for (const D of i)
      D(I);
  }
  function A(I) {
    return r.add(I), () => {
      r.delete(I);
    };
  }
  function R(I) {
    return i.add(I), () => {
      i.delete(I);
    };
  }
  return {
    addTransaction: u,
    clearTransactions: f,
    getTransactions: c,
    onTransactionStatus: R,
    onChange: A,
    setProvider: s,
    waitForPendingTransactions: y
  };
}
var _U, mG = k.createContext(null);
function RCe({
  children: e
}) {
  const t = Gbe(), { address: n } = os(), r = lP(), [i] = k.useState(
    () => _U ?? (_U = _Ce({ provider: t }))
  );
  return k.useEffect(() => {
    i.setProvider(t);
  }, [i, t]), k.useEffect(() => {
    n && r && i.waitForPendingTransactions(n, r);
  }, [i, n, r]), /* @__PURE__ */ $.createElement(mG.Provider, { value: i }, e);
}
function yG() {
  const e = k.useContext(mG);
  if (!e)
    throw new Error("Transaction hooks must be used within RainbowKitProvider");
  return e;
}
function vG() {
  const e = yG(), { address: t } = os(), n = lP(), [r, i] = k.useState(
    () => e && t && n ? e.getTransactions(t, n) : []
  );
  return k.useEffect(() => {
    if (e && t && n)
      return i(e.getTransactions(t, n)), e.onChange(() => {
        i(e.getTransactions(t, n));
      });
  }, [e, t, n]), r;
}
var RU = (e) => typeof e == "function" ? e() : e;
function OCe(e, { extends: t } = {}) {
  const n = {
    // We use an object spread here to ensure it's a plain object since vanilla-extract's
    // var objects have a custom 'toString' method that returns a CSS string, but we don't
    // want to leak this to our consumers since they're unaware we're using vanilla-extract.
    // Instead, we want them to handle this explicitly via our 'cssStringFromTheme' function.
    ...sU(dU, RU(e))
  };
  if (!t)
    return n;
  const r = sU(
    dU,
    RU(t)
  );
  return Object.fromEntries(
    Object.entries(n).filter(
      ([o, s]) => s !== r[o]
    )
  );
}
function OU(e, t = {}) {
  return Object.entries(OCe(e, t)).map(([n, r]) => `${n}:${r.replace(/[:;{}</>]/g, "")};`).join("");
}
var gG = {
  appName: void 0,
  disclaimer: void 0,
  learnMoreUrl: "https://learn.rainbow.me/understanding-web3?utm_source=rainbowkit&utm_campaign=learnmore"
}, ex = k.createContext(gG), bG = k.createContext(!1);
function ICe(e, t) {
  let n;
  return () => {
    n && clearTimeout(n), n = setTimeout(() => {
      n = null, e();
    }, t);
  };
}
var wG = () => {
  const [e, t] = k.useState({
    height: void 0,
    width: void 0
  });
  return k.useEffect(() => {
    let n = !1;
    const r = ICe(() => {
      n || t({
        height: window.innerHeight,
        width: window.innerWidth
      });
    }, 500);
    return window.addEventListener("resize", r), r(), () => {
      n = !0, window.removeEventListener("resize", r);
    };
  }, []), e;
}, tx = k.createContext({
  connector: null,
  setConnector: () => {
  }
});
function DCe({ children: e }) {
  const [t, n] = k.useState(null);
  return /* @__PURE__ */ $.createElement(
    tx.Provider,
    {
      value: k.useMemo(
        () => ({
          connector: t,
          setConnector: n
        }),
        [t]
      )
    },
    e
  );
}
var nx = {
  COMPACT: "compact",
  WIDE: "wide"
}, aA = k.createContext(
  nx.WIDE
);
function MCe({
  children: e,
  modalSize: t
}) {
  const { width: n } = wG(), r = n && n < V1e, { connector: i } = k.useContext(tx);
  return /* @__PURE__ */ $.createElement(
    aA.Provider,
    {
      value: r || i ? nx.COMPACT : t
    },
    e
  );
}
var cP = k.createContext(!1), PCe = "rk-version";
function NCe({ version: e }) {
  localStorage.setItem(PCe, e);
}
function BCe() {
  const e = k.useCallback(() => {
    NCe({ version: "2.1.7" });
  }, []);
  k.useEffect(() => {
    e();
  }, [e]);
}
function LCe(e, t) {
  const n = {};
  for (const r of e) {
    const i = t(r);
    i && (n[i] = r);
  }
  return n;
}
function uP() {
  return typeof navigator < "u" && typeof navigator.userAgent < "u" && /Version\/([0-9._]+).*Safari/.test(navigator.userAgent);
}
function jCe() {
  return typeof document < "u" && getComputedStyle(document.body).getPropertyValue("--arc-palette-focus") !== "";
}
function dP() {
  var t, n;
  if (typeof navigator > "u")
    return "Browser";
  const e = (t = navigator.userAgent) == null ? void 0 : t.toLowerCase();
  return (n = navigator.brave) != null && n.isBrave ? "Brave" : (e == null ? void 0 : e.indexOf("edg/")) > -1 ? "Edge" : (e == null ? void 0 : e.indexOf("op")) > -1 ? "Opera" : jCe() ? "Arc" : (e == null ? void 0 : e.indexOf("chrome")) > -1 ? "Chrome" : (e == null ? void 0 : e.indexOf("firefox")) > -1 ? "Firefox" : uP() ? "Safari" : "Browser";
}
var FCe = Qwe.UAParser(), { os: fP } = FCe;
function UCe() {
  return fP.name === "Windows";
}
function zCe() {
  return fP.name === "Mac OS";
}
function VCe() {
  return ["Ubuntu", "Mint", "Fedora", "Debian", "Arch", "Linux"].includes(
    fP.name
  );
}
function hP() {
  return UCe() ? "Windows" : zCe() ? "macOS" : VCe() ? "Linux" : "Desktop";
}
var $Ce = (e) => {
  var n, r, i, o, s, c, u, f, p, y, v;
  const t = dP();
  return {
    Arc: (n = e == null ? void 0 : e.downloadUrls) == null ? void 0 : n.chrome,
    Brave: (r = e == null ? void 0 : e.downloadUrls) == null ? void 0 : r.chrome,
    Chrome: (i = e == null ? void 0 : e.downloadUrls) == null ? void 0 : i.chrome,
    Edge: ((o = e == null ? void 0 : e.downloadUrls) == null ? void 0 : o.edge) || ((s = e == null ? void 0 : e.downloadUrls) == null ? void 0 : s.chrome),
    Firefox: (c = e == null ? void 0 : e.downloadUrls) == null ? void 0 : c.firefox,
    Opera: ((u = e == null ? void 0 : e.downloadUrls) == null ? void 0 : u.opera) || ((f = e == null ? void 0 : e.downloadUrls) == null ? void 0 : f.chrome),
    Safari: (p = e == null ? void 0 : e.downloadUrls) == null ? void 0 : p.safari,
    Browser: (y = e == null ? void 0 : e.downloadUrls) == null ? void 0 : y.browserExtension
  }[t] ?? ((v = e == null ? void 0 : e.downloadUrls) == null ? void 0 : v.browserExtension);
}, HCe = (e) => {
  var n, r, i;
  return (oA() ? (n = e == null ? void 0 : e.downloadUrls) == null ? void 0 : n.ios : (r = e == null ? void 0 : e.downloadUrls) == null ? void 0 : r.android) ?? ((i = e == null ? void 0 : e.downloadUrls) == null ? void 0 : i.mobile);
}, qCe = (e) => {
  var n, r, i, o, s;
  const t = hP();
  return {
    Windows: (n = e == null ? void 0 : e.downloadUrls) == null ? void 0 : n.windows,
    macOS: (r = e == null ? void 0 : e.downloadUrls) == null ? void 0 : r.macos,
    Linux: (i = e == null ? void 0 : e.downloadUrls) == null ? void 0 : i.linux,
    Desktop: (o = e == null ? void 0 : e.downloadUrls) == null ? void 0 : o.desktop
  }[t] ?? ((s = e == null ? void 0 : e.downloadUrls) == null ? void 0 : s.desktop);
}, CG = (e, t) => e.some((n) => n.id === t), WCe = (e) => !!e.isRainbowKitConnector, IU = (e) => {
  var t;
  return !!(!e.isRainbowKitConnector && ((t = e.icon) != null && t.startsWith("data:image")) && e.uid && e.name);
}, GCe = (e, t) => e.id === "walletConnect" && t ? { ...e, walletConnectModalConnector: t } : e, KCe = ({
  wallets: e,
  recentWallets: t
}) => [
  ...t,
  ...e.filter((n) => !CG(t, n.id))
], xG = "rk-recent";
function YCe(e) {
  try {
    const t = e ? JSON.parse(e) : [];
    return Array.isArray(t) ? t : [];
  } catch {
    return [];
  }
}
function EG() {
  return typeof localStorage < "u" ? YCe(localStorage.getItem(xG)) : [];
}
function QCe(e) {
  return [...new Set(e)];
}
function XCe(e) {
  const t = QCe([e, ...EG()]);
  localStorage.setItem(xG, JSON.stringify(t));
}
function sA(e = !1) {
  var M, L, j;
  const t = uy(), n = gCe(), { connectAsync: r, connectors: i } = aW(), o = i, { setIsWalletConnectModalOpen: s } = YG(), c = o.map((F) => ({
    ...F,
    // rkDetails is optional it does not exist in eip6963 connectors.
    // We only inject `rkDetails` in `connectorsForWallets` when we
    // want to have additional information in the connector.
    ...F.rkDetails || {}
  }));
  async function u(F) {
    var H, Q;
    const O = await F.getChainId(), z = await r({
      chainId: (
        // The goal here is to ensure users are always on a supported chain when connecting.
        // If an `initialChain` prop was provided to RainbowKitProvider, use that.
        n ?? // Otherwise, if the wallet is already on a supported chain, use that to avoid a chain switch prompt.
        ((H = t.find(({ id: Y }) => Y === O)) == null ? void 0 : H.id) ?? // Finally, fall back to the first chain provided to RainbowKitProvider.
        ((Q = t[0]) == null ? void 0 : Q.id)
      ),
      connector: F
    });
    return z && XCe(F.id), z;
  }
  async function f(F) {
    try {
      s(!0), await u(F), s(!1);
    } catch (O) {
      const z = (
        // @ts-expect-error - Web3Modal v1 error name
        O.name === "UserRejectedRequestError" || // @ts-expect-error - Web3Modal v2 error message on desktop
        O.message === "Connection request reset. Please try again."
      );
      if (s(!1), !z)
        throw O;
    }
  }
  const p = async (F, O) => {
    const z = await F.getProvider();
    return F.id === "coinbase" ? z.qrUrl : new Promise(
      (H) => (
        // Wagmi v2 doesn't have a return type for provider yet
        // @ts-expect-error
        z.once("display_uri", (Q) => {
          H(O(Q));
        })
      )
    );
  }, y = c.find(
    (F) => F.id === "walletConnect" && F.isWalletConnectModalConnector
  ), v = c.filter(IU).map((F) => ({
    ...F,
    groupIndex: 0
  })), w = c.filter(WCe).filter((F) => !F.isWalletConnectModalConnector).filter((F) => e ? !v.some(
    (z) => z.id === F.rdns
  ) : !0).map(
    (F) => GCe(
      F,
      y
    )
  ), C = [...v, ...w], x = LCe(
    C,
    (F) => F.id
  ), R = EG().map((F) => x[F]).filter(Boolean).slice(0, 3), I = [], D = KCe({
    wallets: C,
    recentWallets: R
  });
  for (const F of D) {
    if (!F)
      continue;
    const O = IU(F), z = CG(R, F.id);
    if (O) {
      I.push({
        ...F,
        iconUrl: F.icon,
        ready: !0,
        connect: () => u(F),
        groupName: "Installed",
        recent: z
      });
      continue;
    }
    I.push({
      ...F,
      ready: F.installed ?? !0,
      connect: () => u(F),
      desktopDownloadUrl: qCe(F),
      extensionDownloadUrl: $Ce(F),
      groupName: F.groupName,
      mobileDownloadUrl: HCe(F),
      getQrCodeUri: (M = F.qrCode) != null && M.getUri ? () => p(F, F.qrCode.getUri) : void 0,
      getDesktopUri: (L = F.desktop) != null && L.getUri ? () => p(F, F.desktop.getUri) : void 0,
      getMobileUri: (j = F.mobile) != null && j.getUri ? () => {
        var H;
        return p(F, (H = F.mobile) == null ? void 0 : H.getUri);
      } : void 0,
      recent: z,
      showWalletConnectModal: F.walletConnectModalConnector ? () => f(F.walletConnectModalConnector) : void 0
    });
  }
  return I;
}
var SG = async () => (await import("./assets-NU2OP443-D_x-WLe0.js")).default, JCe = () => zu(SG), ZCe = () => /* @__PURE__ */ $.createElement(
  _o,
  {
    background: "#d0d5de",
    borderRadius: "10",
    height: "48",
    src: SG,
    width: "48"
  }
), kG = async () => (await import("./login-CWDTIDNK-Csd2htw9.js")).default, exe = () => zu(kG), txe = () => /* @__PURE__ */ $.createElement(
  _o,
  {
    background: "#d0d5de",
    borderRadius: "10",
    height: "48",
    src: kG,
    width: "48"
  }
), Yt = $.forwardRef(
  ({
    as: e = "div",
    children: t,
    className: n,
    color: r,
    display: i,
    font: o = "body",
    id: s,
    size: c = "16",
    style: u,
    tabIndex: f,
    textAlign: p = "inherit",
    weight: y = "regular",
    testId: v
  }, w) => /* @__PURE__ */ $.createElement(
    ge,
    {
      as: e,
      className: n,
      color: r,
      display: i,
      fontFamily: o,
      fontSize: c,
      fontWeight: y,
      id: s,
      ref: w,
      style: u,
      tabIndex: f,
      textAlign: p,
      testId: v
    },
    t
  )
);
Yt.displayName = "Text";
var nxe = {
  large: {
    fontSize: "16",
    paddingX: "24",
    paddingY: "10"
  },
  medium: {
    fontSize: "14",
    height: "28",
    paddingX: "12",
    paddingY: "4"
  },
  small: {
    fontSize: "14",
    paddingX: "10",
    paddingY: "5"
  }
};
function is({
  disabled: e = !1,
  href: t,
  label: n,
  onClick: r,
  rel: i = "noreferrer noopener",
  size: o = "medium",
  target: s = "_blank",
  testId: c,
  type: u = "primary"
}) {
  const f = u === "primary", p = o !== "large", y = aa(), v = e ? "actionButtonSecondaryBackground" : f ? "accentColor" : p ? "actionButtonSecondaryBackground" : null, { fontSize: w, height: C, paddingX: x, paddingY: A } = nxe[o], R = !y || !p;
  return /* @__PURE__ */ $.createElement(
    ge,
    {
      ...t ? e ? {} : { as: "a", href: t, rel: i, target: s } : { as: "button", type: "button" },
      onClick: e ? void 0 : r,
      ...R ? {
        borderColor: y && !p && !f ? "actionButtonBorderMobile" : "actionButtonBorder",
        borderStyle: "solid",
        borderWidth: "1"
      } : {},
      borderRadius: "actionButton",
      className: !e && ao({ active: "shrinkSm", hover: "grow" }),
      display: "block",
      paddingX: x,
      paddingY: A,
      style: { willChange: "transform" },
      testId: c,
      textAlign: "center",
      transition: "transform",
      ...v ? { background: v } : {},
      ...C ? { height: C } : {}
    },
    /* @__PURE__ */ $.createElement(
      Yt,
      {
        color: e ? "modalTextSecondary" : f ? "accentColorForeground" : "accentColor",
        size: w,
        weight: "bold"
      },
      n
    )
  );
}
var rxe = () => aa() ? /* @__PURE__ */ $.createElement(
  "svg",
  {
    "aria-hidden": !0,
    fill: "none",
    height: "11.5",
    viewBox: "0 0 11.5 11.5",
    width: "11.5",
    xmlns: "http://www.w3.org/2000/svg"
  },
  /* @__PURE__ */ $.createElement("title", null, "Close"),
  /* @__PURE__ */ $.createElement(
    "path",
    {
      d: "M2.13388 0.366117C1.64573 -0.122039 0.854272 -0.122039 0.366117 0.366117C-0.122039 0.854272 -0.122039 1.64573 0.366117 2.13388L3.98223 5.75L0.366117 9.36612C-0.122039 9.85427 -0.122039 10.6457 0.366117 11.1339C0.854272 11.622 1.64573 11.622 2.13388 11.1339L5.75 7.51777L9.36612 11.1339C9.85427 11.622 10.6457 11.622 11.1339 11.1339C11.622 10.6457 11.622 9.85427 11.1339 9.36612L7.51777 5.75L11.1339 2.13388C11.622 1.64573 11.622 0.854272 11.1339 0.366117C10.6457 -0.122039 9.85427 -0.122039 9.36612 0.366117L5.75 3.98223L2.13388 0.366117Z",
      fill: "currentColor"
    }
  )
) : /* @__PURE__ */ $.createElement(
  "svg",
  {
    "aria-hidden": !0,
    fill: "none",
    height: "10",
    viewBox: "0 0 10 10",
    width: "10",
    xmlns: "http://www.w3.org/2000/svg"
  },
  /* @__PURE__ */ $.createElement("title", null, "Close"),
  /* @__PURE__ */ $.createElement(
    "path",
    {
      d: "M1.70711 0.292893C1.31658 -0.0976311 0.683417 -0.0976311 0.292893 0.292893C-0.0976311 0.683417 -0.0976311 1.31658 0.292893 1.70711L3.58579 5L0.292893 8.29289C-0.0976311 8.68342 -0.0976311 9.31658 0.292893 9.70711C0.683417 10.0976 1.31658 10.0976 1.70711 9.70711L5 6.41421L8.29289 9.70711C8.68342 10.0976 9.31658 10.0976 9.70711 9.70711C10.0976 9.31658 10.0976 8.68342 9.70711 8.29289L6.41421 5L9.70711 1.70711C10.0976 1.31658 10.0976 0.683417 9.70711 0.292893C9.31658 -0.0976311 8.68342 -0.0976311 8.29289 0.292893L5 3.58579L1.70711 0.292893Z",
      fill: "currentColor"
    }
  )
), ey = ({
  "aria-label": e = "Close",
  onClose: t
}) => {
  const n = aa();
  return /* @__PURE__ */ $.createElement(
    ge,
    {
      alignItems: "center",
      "aria-label": e,
      as: "button",
      background: "closeButtonBackground",
      borderColor: "actionButtonBorder",
      borderRadius: "full",
      borderStyle: "solid",
      borderWidth: n ? "0" : "1",
      className: ao({ active: "shrinkSm", hover: "growLg" }),
      color: "closeButton",
      display: "flex",
      height: n ? "30" : "28",
      justifyContent: "center",
      onClick: t,
      style: { willChange: "transform" },
      transition: "default",
      type: "button",
      width: n ? "30" : "28"
    },
    /* @__PURE__ */ $.createElement(rxe, null)
  );
}, AG = async () => (await import("./sign-A7IJEUT5-BQQmgNRT.js")).default;
function ixe({
  onClose: e,
  onCloseModal: t
}) {
  const { i18n: n } = k.useContext(fo), [{ status: r, ...i }, o] = $.useState({ status: "idle" }), s = G1e(), c = k.useCallback(async () => {
    try {
      const C = await s.getNonce();
      o((x) => ({ ...x, nonce: C }));
    } catch {
      o((C) => ({
        ...C,
        errorMessage: n.t("sign_in.message.preparing_error"),
        status: "idle"
      }));
    }
  }, [s, n.t]), u = k.useRef(!1);
  $.useEffect(() => {
    u.current || (u.current = !0, c());
  }, [c]);
  const f = aa(), { address: p, chain: y } = os(), { signMessageAsync: v } = sW(), w = async () => {
    try {
      const C = y == null ? void 0 : y.id, { nonce: x } = i;
      if (!p || !C || !x)
        return;
      o((I) => ({
        ...I,
        errorMessage: void 0,
        status: "signing"
      }));
      const A = s.createMessage({ address: p, chainId: C, nonce: x });
      let R;
      try {
        R = await v({
          message: s.getMessageBody({ message: A })
        });
      } catch (I) {
        return I instanceof li ? o((D) => ({
          ...D,
          status: "idle"
        })) : o((D) => ({
          ...D,
          errorMessage: n.t("sign_in.signature.signing_error"),
          status: "idle"
        }));
      }
      o((I) => ({ ...I, status: "verifying" }));
      try {
        if (await s.verify({ message: A, signature: R })) {
          t();
          return;
        }
        throw new Error();
      } catch {
        return o((I) => ({
          ...I,
          errorMessage: n.t("sign_in.signature.verifying_error"),
          status: "idle"
        }));
      }
    } catch {
      o({
        errorMessage: n.t("sign_in.signature.oops_error"),
        status: "idle"
      });
    }
  };
  return /* @__PURE__ */ $.createElement(ge, { position: "relative" }, /* @__PURE__ */ $.createElement(
    ge,
    {
      display: "flex",
      paddingRight: "16",
      paddingTop: "16",
      position: "absolute",
      right: "0"
    },
    /* @__PURE__ */ $.createElement(ey, { onClose: e })
  ), /* @__PURE__ */ $.createElement(
    ge,
    {
      alignItems: "center",
      display: "flex",
      flexDirection: "column",
      gap: f ? "32" : "24",
      padding: "24",
      paddingX: "18",
      style: { paddingTop: f ? "60px" : "36px" }
    },
    /* @__PURE__ */ $.createElement(
      ge,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        gap: f ? "6" : "4",
        style: { maxWidth: f ? 320 : 280 }
      },
      /* @__PURE__ */ $.createElement(
        ge,
        {
          alignItems: "center",
          display: "flex",
          flexDirection: "column",
          gap: f ? "32" : "16"
        },
        /* @__PURE__ */ $.createElement(_o, { height: 40, src: AG, width: 40 }),
        /* @__PURE__ */ $.createElement(
          Yt,
          {
            color: "modalText",
            size: f ? "20" : "18",
            textAlign: "center",
            weight: "heavy"
          },
          n.t("sign_in.label")
        )
      ),
      /* @__PURE__ */ $.createElement(
        ge,
        {
          alignItems: "center",
          display: "flex",
          flexDirection: "column",
          gap: f ? "16" : "12"
        },
        /* @__PURE__ */ $.createElement(
          Yt,
          {
            color: "modalTextSecondary",
            size: f ? "16" : "14",
            textAlign: "center"
          },
          n.t("sign_in.description")
        ),
        r === "idle" && i.errorMessage ? /* @__PURE__ */ $.createElement(
          Yt,
          {
            color: "error",
            size: f ? "16" : "14",
            textAlign: "center",
            weight: "bold"
          },
          i.errorMessage
        ) : null
      )
    ),
    /* @__PURE__ */ $.createElement(
      ge,
      {
        alignItems: f ? void 0 : "center",
        display: "flex",
        flexDirection: "column",
        gap: "8",
        width: "full"
      },
      /* @__PURE__ */ $.createElement(
        is,
        {
          disabled: !i.nonce || r === "signing" || r === "verifying",
          label: i.nonce ? r === "signing" ? n.t("sign_in.signature.waiting") : r === "verifying" ? n.t("sign_in.signature.verifying") : n.t("sign_in.message.send") : n.t("sign_in.message.preparing"),
          onClick: w,
          size: f ? "large" : "medium",
          testId: "auth-message-button"
        }
      ),
      f ? /* @__PURE__ */ $.createElement(
        is,
        {
          label: "Cancel",
          onClick: e,
          size: "large",
          type: "secondary"
        }
      ) : /* @__PURE__ */ $.createElement(
        ge,
        {
          as: "button",
          borderRadius: "full",
          className: ao({ active: "shrink", hover: "grow" }),
          display: "block",
          onClick: e,
          paddingX: "10",
          paddingY: "5",
          rel: "noreferrer",
          style: { willChange: "transform" },
          target: "_blank",
          transition: "default"
        },
        /* @__PURE__ */ $.createElement(
          Yt,
          {
            color: "closeButton",
            size: f ? "16" : "14",
            weight: "bold"
          },
          n.t("sign_in.message.cancel")
        )
      )
    )
  ));
}
function oxe() {
  const e = uy(), t = sA(), n = iA() === "unauthenticated", r = k.useCallback(() => {
    zu(
      ...t.map((i) => i.iconUrl),
      ...e.map((i) => i.iconUrl).filter(uG)
    ), aa() || (JCe(), exe()), n && zu(AG);
  }, [t, e, n]);
  k.useEffect(() => {
    r();
  }, [r]);
}
var TG = "WALLETCONNECT_DEEPLINK_CHOICE";
function axe({
  mobileUri: e,
  name: t
}) {
  localStorage.setItem(
    TG,
    JSON.stringify({
      href: e.split("?")[0],
      name: t
    })
  );
}
function sxe() {
  localStorage.removeItem(TG);
}
var _G = k.createContext(void 0), J5 = "data-rk", RG = (e) => ({ [J5]: e || "" }), lxe = (e) => {
  if (e && !/^[a-zA-Z0-9_]+$/.test(e))
    throw new Error(`Invalid ID: ${e}`);
  return e ? `[${J5}="${e}"]` : `[${J5}]`;
}, cxe = () => {
  const e = k.useContext(_G);
  return RG(e);
}, uxe = fM();
function dxe({
  appInfo: e,
  avatar: t,
  disabledChains: n,
  onDisabledChainClick: r,
  children: i,
  coolMode: o = !1,
  id: s,
  initialChain: c,
  locale: u,
  modalSize: f = nx.WIDE,
  showRecentTransactions: p = !1,
  theme: y = uxe,
  dialogRoot: v,
  hideDisconnect: w,
  chainIdsToUse: C
}) {
  if (oxe(), BCe(), tW({ onDisconnect: sxe }), typeof y == "function")
    throw new Error(
      'A theme function was provided to the "theme" prop instead of a theme object. You must execute this function to get the resulting theme object.'
    );
  const x = lxe(s), A = {
    ...gG,
    ...e
  }, R = t ?? lG;
  return /* @__PURE__ */ $.createElement(
    mCe,
    {
      chainIdsToUse: C,
      disabledChains: n,
      initialChain: c,
      onDisabledChainClick: r
    },
    /* @__PURE__ */ $.createElement(DCe, null, /* @__PURE__ */ $.createElement(uCe, { locale: u }, /* @__PURE__ */ $.createElement(bG.Provider, { value: o }, /* @__PURE__ */ $.createElement(MCe, { modalSize: f }, /* @__PURE__ */ $.createElement(
      cP.Provider,
      {
        value: p
      },
      /* @__PURE__ */ $.createElement(RCe, null, /* @__PURE__ */ $.createElement(sP.Provider, { value: R }, /* @__PURE__ */ $.createElement(ex.Provider, { value: A }, /* @__PURE__ */ $.createElement(_G.Provider, { value: s }, /* @__PURE__ */ $.createElement(wCe, null, /* @__PURE__ */ $.createElement(
        _Ee,
        {
          dialogRoot: v,
          hideDisconnect: w
        },
        y ? /* @__PURE__ */ $.createElement("div", { ...RG(s) }, /* @__PURE__ */ $.createElement(
          "style",
          {
            dangerouslySetInnerHTML: {
              // Selectors are sanitized to only contain alphanumeric
              // and underscore characters. Theme values generated by
              // cssStringFromTheme are sanitized, removing
              // characters that terminate values / HTML tags.
              __html: [
                `${x}{${OU(
                  "lightMode" in y ? y.lightMode : y
                )}}`,
                "darkMode" in y ? `@media(prefers-color-scheme:dark){${x}{${OU(
                  y.darkMode,
                  { extends: y.lightMode }
                )}}}` : null
              ].join("")
            }
          }
        ), i) : i
      ))))))
    )))))
  );
}
var fxe = "kzuco17 in5bvia in5bvi15 in5bvi8r", hxe = "kzuco15 in5bvi9h in5bvib3", pxe = "kzuco13 in5bvia in5bvi2q in5bvi8q", DU = (e, t) => {
  const n = e.querySelectorAll(
    "button:not(:disabled), a[href]"
  );
  n.length !== 0 && n[t === "end" ? n.length - 1 : 0].focus();
};
function mxe(e) {
  const t = k.useRef(null);
  return k.useEffect(() => {
    const n = document.activeElement;
    return () => {
      var r;
      (r = n.focus) == null || r.call(n);
    };
  }, []), k.useEffect(() => {
    if (t.current) {
      const n = t.current.querySelector("[data-auto-focus]");
      n ? n.focus() : t.current.focus();
    }
  }, []), /* @__PURE__ */ $.createElement($.Fragment, null, /* @__PURE__ */ $.createElement(
    "div",
    {
      onFocus: k.useCallback(
        () => t.current && DU(t.current, "end"),
        []
      ),
      tabIndex: 0
    }
  ), /* @__PURE__ */ $.createElement(
    "div",
    {
      ref: t,
      style: { outline: "none" },
      tabIndex: -1,
      ...e
    }
  ), /* @__PURE__ */ $.createElement(
    "div",
    {
      onFocus: k.useCallback(
        () => t.current && DU(t.current, "start"),
        []
      ),
      tabIndex: 0
    }
  ));
}
var yxe = (e) => e.stopPropagation();
function q4({
  children: e,
  onClose: t,
  open: n,
  titleId: r,
  dialogRoot: i
}) {
  k.useEffect(() => {
    const p = (y) => n && y.key === "Escape" && t();
    return document.addEventListener("keydown", p), () => document.removeEventListener("keydown", p);
  }, [n, t]);
  const [o, s] = k.useState(!0);
  k.useEffect(() => {
    s(
      getComputedStyle(window.document.body).overflow !== "hidden"
    );
  }, []);
  const c = k.useCallback(() => t(), [t]), u = cxe(), f = aa();
  return /* @__PURE__ */ $.createElement($.Fragment, null, n ? Wu.createPortal(
    /* @__PURE__ */ $.createElement(J8, { enabled: o }, /* @__PURE__ */ $.createElement(ge, { ...u }, /* @__PURE__ */ $.createElement(
      ge,
      {
        ...u,
        alignItems: f ? "flex-end" : "center",
        "aria-labelledby": r,
        "aria-modal": !0,
        className: pxe,
        onClick: c,
        position: "fixed",
        role: "dialog"
      },
      /* @__PURE__ */ $.createElement(ge, { className: hxe }),
      /* @__PURE__ */ $.createElement(
        mxe,
        {
          className: fxe,
          onClick: yxe,
          role: "document"
        },
        e
      )
    ))),
    i ?? document.body
  ) : null);
}
var vxe = "_1t0jwgf7", gxe = "_1t0jwgf1 in5bvib6 in5bvidr in5bvip in5bvit in5bviv in5bviel in5bvia in5bvi15 in5bvi6c in5bvi8r", bxe = "_1t0jwgf4 _1t0jwgf1 in5bvib6 in5bvidr in5bvip in5bvit in5bviv in5bviel in5bvia in5bvi15 in5bvi6c in5bvi8r", wxe = "_1t0jwgf6 in5bviq", Cxe = "_1t0jwgf3 _1t0jwgf1 in5bvib6 in5bvidr in5bvip in5bvit in5bviv in5bviel in5bvia in5bvi15 in5bvi6c in5bvi8r", xxe = "_1t0jwgf2 _1t0jwgf1 in5bvib6 in5bvidr in5bvip in5bvit in5bviv in5bviel in5bvia in5bvi15 in5bvi6c in5bvi8r";
function W4({
  bottomSheetOnMobile: e = !1,
  children: t,
  marginTop: n,
  padding: r = "16",
  paddingBottom: i,
  wide: o = !1
}) {
  const s = aa(), u = k.useContext(aA) === nx.COMPACT;
  return /* @__PURE__ */ $.createElement(ge, { marginTop: n }, /* @__PURE__ */ $.createElement(
    ge,
    {
      className: [
        o ? s ? xxe : u ? bxe : Cxe : gxe,
        s ? wxe : null,
        s && e ? vxe : null
      ].join(" ")
    },
    /* @__PURE__ */ $.createElement(ge, { padding: r, paddingBottom: i ?? r }, t)
  ));
}
function OG(e) {
  return e.length < 8 ? e : `${e.substring(0, 4)}${e.substring(
    e.length - 4
  )}`;
}
function IG(e) {
  if (!e)
    return "";
  const t = e.split("."), n = t.pop();
  return t.join(".").length > 24 ? `${t.join(".").substring(0, 24)}...` : `${t.join(".")}.${n}`;
}
var Exe = () => /* @__PURE__ */ $.createElement(
  "svg",
  {
    fill: "none",
    height: "13",
    viewBox: "0 0 13 13",
    width: "13",
    xmlns: "http://www.w3.org/2000/svg"
  },
  /* @__PURE__ */ $.createElement("title", null, "Copied"),
  /* @__PURE__ */ $.createElement(
    "path",
    {
      d: "M4.94568 12.2646C5.41052 12.2646 5.77283 12.0869 6.01892 11.7109L12.39 1.96973C12.5677 1.69629 12.6429 1.44336 12.6429 1.2041C12.6429 0.561523 12.1644 0.0966797 11.5082 0.0966797C11.057 0.0966797 10.7767 0.260742 10.5033 0.691406L4.9115 9.50977L2.07458 5.98926C1.82166 5.68848 1.54822 5.55176 1.16541 5.55176C0.502319 5.55176 0.0238037 6.02344 0.0238037 6.66602C0.0238037 6.95312 0.112671 7.20605 0.358765 7.48633L3.88611 11.7588C4.18005 12.1074 4.50818 12.2646 4.94568 12.2646Z",
      fill: "currentColor"
    }
  )
), Sxe = () => /* @__PURE__ */ $.createElement(
  "svg",
  {
    fill: "none",
    height: "16",
    viewBox: "0 0 17 16",
    width: "17",
    xmlns: "http://www.w3.org/2000/svg"
  },
  /* @__PURE__ */ $.createElement("title", null, "Copy"),
  /* @__PURE__ */ $.createElement(
    "path",
    {
      d: "M3.04236 12.3027H4.18396V13.3008C4.18396 14.8525 5.03845 15.7002 6.59705 15.7002H13.6244C15.183 15.7002 16.0375 14.8525 16.0375 13.3008V6.24609C16.0375 4.69434 15.183 3.84668 13.6244 3.84668H12.4828V2.8418C12.4828 1.29688 11.6283 0.442383 10.0697 0.442383H3.04236C1.48376 0.442383 0.629272 1.29004 0.629272 2.8418V9.90332C0.629272 11.4551 1.48376 12.3027 3.04236 12.3027ZM3.23376 10.5391C2.68689 10.5391 2.39294 10.2656 2.39294 9.68457V3.06055C2.39294 2.47949 2.68689 2.21289 3.23376 2.21289H9.8783C10.4252 2.21289 10.7191 2.47949 10.7191 3.06055V3.84668H6.59705C5.03845 3.84668 4.18396 4.69434 4.18396 6.24609V10.5391H3.23376ZM6.78845 13.9365C6.24158 13.9365 5.94763 13.6699 5.94763 13.0889V6.45801C5.94763 5.87695 6.24158 5.61035 6.78845 5.61035H13.433C13.9799 5.61035 14.2738 5.87695 14.2738 6.45801V13.0889C14.2738 13.6699 13.9799 13.9365 13.433 13.9365H6.78845Z",
      fill: "currentColor"
    }
  )
), kxe = () => /* @__PURE__ */ $.createElement(
  "svg",
  {
    fill: "none",
    height: "16",
    viewBox: "0 0 18 16",
    width: "18",
    xmlns: "http://www.w3.org/2000/svg"
  },
  /* @__PURE__ */ $.createElement("title", null, "Disconnect"),
  /* @__PURE__ */ $.createElement(
    "path",
    {
      d: "M2.67834 15.5908H9.99963C11.5514 15.5908 12.399 14.7432 12.399 13.1777V10.2656H10.6354V12.9863C10.6354 13.5332 10.3688 13.8271 9.78772 13.8271H2.89026C2.3092 13.8271 2.0426 13.5332 2.0426 12.9863V3.15625C2.0426 2.60254 2.3092 2.30859 2.89026 2.30859H9.78772C10.3688 2.30859 10.6354 2.60254 10.6354 3.15625V5.89746H12.399V2.95801C12.399 1.39941 11.5514 0.544922 9.99963 0.544922H2.67834C1.12659 0.544922 0.278931 1.39941 0.278931 2.95801V13.1777C0.278931 14.7432 1.12659 15.5908 2.67834 15.5908ZM7.43616 8.85059H14.0875L15.0924 8.78906L14.566 9.14453L13.6842 9.96484C13.5406 10.1016 13.4586 10.2861 13.4586 10.4844C13.4586 10.8398 13.7321 11.168 14.1217 11.168C14.3199 11.168 14.4635 11.0928 14.6002 10.9561L16.7809 8.68652C16.986 8.48145 17.0543 8.27637 17.0543 8.06445C17.0543 7.85254 16.986 7.64746 16.7809 7.43555L14.6002 5.17285C14.4635 5.03613 14.3199 4.9541 14.1217 4.9541C13.7321 4.9541 13.4586 5.27539 13.4586 5.6377C13.4586 5.83594 13.5406 6.02734 13.6842 6.15723L14.566 6.98438L15.0924 7.33984L14.0875 7.27148H7.43616C7.01917 7.27148 6.65686 7.62012 6.65686 8.06445C6.65686 8.50195 7.01917 8.85059 7.43616 8.85059Z",
      fill: "currentColor"
    }
  )
), Axe = "_1mfzuhu0", lA = $.forwardRef(
  ({
    children: e,
    currentlySelected: t = !1,
    onClick: n,
    testId: r,
    ...i
  }, o) => {
    const s = aa();
    return /* @__PURE__ */ $.createElement(
      ge,
      {
        as: "button",
        borderRadius: "menuButton",
        disabled: t,
        display: "flex",
        onClick: n,
        ref: o,
        testId: r,
        type: "button"
      },
      /* @__PURE__ */ $.createElement(
        ge,
        {
          borderRadius: "menuButton",
          className: [
            s ? Axe : void 0,
            !t && ao({ active: "shrink" })
          ],
          padding: s ? "8" : "6",
          transition: "default",
          width: "full",
          ...t ? {
            background: "accentColor",
            borderColor: "selectedOptionBorder",
            borderStyle: "solid",
            borderWidth: "1",
            boxShadow: "selectedOption",
            color: "accentColorForeground"
          } : {
            background: { hover: "menuItemBackground" },
            color: "modalText",
            transition: "default"
          },
          ...i
        },
        e
      )
    );
  }
);
lA.displayName = "MenuButton";
function Txe() {
  const e = yG(), { address: t } = os(), n = lP();
  return k.useCallback(() => {
    if (!t || !n)
      throw new Error("No address or chain ID found");
    e.clearTransactions(t, n);
  }, [e, t, n]);
}
var DG = (e) => {
  var t, n;
  return (n = (t = e == null ? void 0 : e.blockExplorers) == null ? void 0 : t.default) == null ? void 0 : n.url;
}, MG = () => /* @__PURE__ */ $.createElement(
  "svg",
  {
    fill: "none",
    height: "19",
    viewBox: "0 0 20 19",
    width: "20",
    xmlns: "http://www.w3.org/2000/svg"
  },
  /* @__PURE__ */ $.createElement("title", null, "Link"),
  /* @__PURE__ */ $.createElement(
    "path",
    {
      d: "M10 18.9443C15.0977 18.9443 19.2812 14.752 19.2812 9.6543C19.2812 4.56543 15.0889 0.373047 10 0.373047C4.90234 0.373047 0.71875 4.56543 0.71875 9.6543C0.71875 14.752 4.91113 18.9443 10 18.9443ZM10 16.6328C6.1416 16.6328 3.03906 13.5215 3.03906 9.6543C3.03906 5.7959 6.13281 2.68457 10 2.68457C13.8584 2.68457 16.9697 5.7959 16.9697 9.6543C16.9785 13.5215 13.8672 16.6328 10 16.6328ZM12.7158 12.1416C13.2432 12.1416 13.5684 11.7549 13.5684 11.1836V7.19336C13.5684 6.44629 13.1377 6.05957 12.417 6.05957H8.40918C7.8291 6.05957 7.45117 6.38477 7.45117 6.91211C7.45117 7.43945 7.8291 7.77344 8.40918 7.77344H9.69238L10.7207 7.63281L9.53418 8.67871L6.73047 11.4912C6.53711 11.6758 6.41406 11.9395 6.41406 12.2031C6.41406 12.7832 6.85352 13.1699 7.39844 13.1699C7.68848 13.1699 7.92578 13.0732 8.1543 12.8623L10.9316 10.0762L11.9775 8.89844L11.8545 9.98828V11.1836C11.8545 11.7725 12.1885 12.1416 12.7158 12.1416Z",
      fill: "currentColor"
    }
  )
), _xe = () => /* @__PURE__ */ $.createElement(
  "svg",
  {
    fill: "none",
    height: "19",
    viewBox: "0 0 20 19",
    width: "20",
    xmlns: "http://www.w3.org/2000/svg"
  },
  /* @__PURE__ */ $.createElement("title", null, "Cancel"),
  /* @__PURE__ */ $.createElement(
    "path",
    {
      d: "M10 18.9443C15.0977 18.9443 19.2812 14.752 19.2812 9.6543C19.2812 4.56543 15.0889 0.373047 10 0.373047C4.90234 0.373047 0.71875 4.56543 0.71875 9.6543C0.71875 14.752 4.91113 18.9443 10 18.9443ZM10 16.6328C6.1416 16.6328 3.03906 13.5215 3.03906 9.6543C3.03906 5.7959 6.13281 2.68457 10 2.68457C13.8584 2.68457 16.9697 5.7959 16.9697 9.6543C16.9785 13.5215 13.8672 16.6328 10 16.6328ZM7.29297 13.3018C7.58301 13.3018 7.81152 13.2139 7.99609 13.0205L10 11.0166L12.0127 13.0205C12.1973 13.2051 12.4258 13.3018 12.707 13.3018C13.2432 13.3018 13.6562 12.8887 13.6562 12.3525C13.6562 12.0977 13.5508 11.8691 13.3662 11.6934L11.3535 9.67188L13.375 7.6416C13.5596 7.44824 13.6562 7.22852 13.6562 6.98242C13.6562 6.44629 13.2432 6.0332 12.7158 6.0332C12.4346 6.0332 12.2148 6.12109 12.0215 6.31445L10 8.32715L7.9873 6.32324C7.80273 6.12988 7.58301 6.04199 7.29297 6.04199C6.76562 6.04199 6.35254 6.45508 6.35254 6.99121C6.35254 7.2373 6.44922 7.46582 6.63379 7.6416L8.65527 9.67188L6.63379 11.6934C6.44922 11.8691 6.35254 12.1064 6.35254 12.3525C6.35254 12.8887 6.76562 13.3018 7.29297 13.3018Z",
      fill: "currentColor"
    }
  )
), Rxe = () => /* @__PURE__ */ $.createElement(
  "svg",
  {
    fill: "none",
    height: "20",
    viewBox: "0 0 20 20",
    width: "20",
    xmlns: "http://www.w3.org/2000/svg"
  },
  /* @__PURE__ */ $.createElement("title", null, "Success"),
  /* @__PURE__ */ $.createElement(
    "path",
    {
      d: "M10 19.4443C15.0977 19.4443 19.2812 15.252 19.2812 10.1543C19.2812 5.06543 15.0889 0.873047 10 0.873047C4.90234 0.873047 0.71875 5.06543 0.71875 10.1543C0.71875 15.252 4.91113 19.4443 10 19.4443ZM10 17.1328C6.1416 17.1328 3.03906 14.0215 3.03906 10.1543C3.03906 6.2959 6.13281 3.18457 10 3.18457C13.8584 3.18457 16.9697 6.2959 16.9697 10.1543C16.9785 14.0215 13.8672 17.1328 10 17.1328ZM9.07715 14.3379C9.4375 14.3379 9.7627 14.1533 9.97363 13.8369L13.7441 8.00977C13.8848 7.79883 13.9814 7.5791 13.9814 7.36816C13.9814 6.84961 13.5244 6.48926 13.0322 6.48926C12.707 6.48926 12.4258 6.66504 12.2148 7.0166L9.05957 12.0967L7.5918 10.2949C7.37207 10.0225 7.13477 9.9082 6.84473 9.9082C6.33496 9.9082 5.92188 10.3125 5.92188 10.8223C5.92188 11.0684 6.00098 11.2793 6.18555 11.5078L8.1543 13.8545C8.40918 14.1709 8.70801 14.3379 9.07715 14.3379Z",
      fill: "currentColor"
    }
  )
), Oxe = (e) => {
  switch (e) {
    case "pending":
      return fC;
    case "confirmed":
      return Rxe;
    case "failed":
      return _xe;
    default:
      return fC;
  }
};
function Ixe({ tx: e }) {
  const t = aa(), n = Oxe(e.status), r = e.status === "failed" ? "error" : "accentColor", { chain: i } = os(), o = e.status === "confirmed" ? "Confirmed" : e.status === "failed" ? "Failed" : "Pending", s = DG(i);
  return /* @__PURE__ */ $.createElement($.Fragment, null, /* @__PURE__ */ $.createElement(
    ge,
    {
      ...s ? {
        as: "a",
        background: { hover: "profileForeground" },
        borderRadius: "menuButton",
        className: ao({ active: "shrink" }),
        href: `${s}/tx/${e.hash}`,
        rel: "noreferrer noopener",
        target: "_blank",
        transition: "default"
      } : {},
      color: "modalText",
      display: "flex",
      flexDirection: "row",
      justifyContent: "space-between",
      padding: "8",
      width: "full"
    },
    /* @__PURE__ */ $.createElement(
      ge,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "row",
        gap: t ? "16" : "14"
      },
      /* @__PURE__ */ $.createElement(ge, { color: r }, /* @__PURE__ */ $.createElement(n, null)),
      /* @__PURE__ */ $.createElement(ge, { display: "flex", flexDirection: "column", gap: t ? "3" : "1" }, /* @__PURE__ */ $.createElement(ge, null, /* @__PURE__ */ $.createElement(
        Yt,
        {
          color: "modalText",
          font: "body",
          size: t ? "16" : "14",
          weight: "bold"
        },
        e == null ? void 0 : e.description
      )), /* @__PURE__ */ $.createElement(ge, null, /* @__PURE__ */ $.createElement(
        Yt,
        {
          color: e.status === "pending" ? "modalTextSecondary" : r,
          font: "body",
          size: "14",
          weight: t ? "medium" : "regular"
        },
        o
      )))
    ),
    s && /* @__PURE__ */ $.createElement(ge, { alignItems: "center", color: "modalTextDim", display: "flex" }, /* @__PURE__ */ $.createElement(MG, null))
  ));
}
var Dxe = 3;
function Mxe({ address: e }) {
  const t = vG(), n = Txe(), { chain: r } = os(), i = DG(r), o = t.slice(0, Dxe), s = o.length > 0, c = aa(), { appName: u } = k.useContext(ex), { i18n: f } = k.useContext(fo);
  return /* @__PURE__ */ $.createElement($.Fragment, null, /* @__PURE__ */ $.createElement(
    ge,
    {
      display: "flex",
      flexDirection: "column",
      gap: "10",
      paddingBottom: "2",
      paddingTop: "16",
      paddingX: c ? "8" : "18"
    },
    s && /* @__PURE__ */ $.createElement(
      ge,
      {
        paddingBottom: c ? "4" : "0",
        paddingTop: "8",
        paddingX: c ? "12" : "6"
      },
      /* @__PURE__ */ $.createElement(ge, { display: "flex", justifyContent: "space-between" }, /* @__PURE__ */ $.createElement(
        Yt,
        {
          color: "modalTextSecondary",
          size: c ? "16" : "14",
          weight: "semibold"
        },
        f.t("profile.transactions.recent.title")
      ), /* @__PURE__ */ $.createElement(
        ge,
        {
          style: {
            marginBottom: -6,
            marginLeft: -10,
            marginRight: -10,
            marginTop: -6
          }
        },
        /* @__PURE__ */ $.createElement(
          ge,
          {
            as: "button",
            background: {
              hover: "profileForeground"
            },
            borderRadius: "actionButton",
            className: ao({ active: "shrink" }),
            onClick: n,
            paddingX: c ? "8" : "12",
            paddingY: c ? "4" : "5",
            transition: "default",
            type: "button"
          },
          /* @__PURE__ */ $.createElement(
            Yt,
            {
              color: "modalTextSecondary",
              size: c ? "16" : "14",
              weight: "semibold"
            },
            f.t("profile.transactions.clear.label")
          )
        )
      ))
    ),
    /* @__PURE__ */ $.createElement(ge, { display: "flex", flexDirection: "column", gap: "4" }, s ? o.map((p) => /* @__PURE__ */ $.createElement(Ixe, { key: p.hash, tx: p })) : /* @__PURE__ */ $.createElement($.Fragment, null, /* @__PURE__ */ $.createElement(ge, { padding: c ? "12" : "8" }, /* @__PURE__ */ $.createElement(
      Yt,
      {
        color: "modalTextDim",
        size: c ? "16" : "14",
        weight: c ? "medium" : "bold"
      },
      u ? f.t("profile.transactions.description", {
        appName: u
      }) : f.t("profile.transactions.description_fallback")
    )), c && /* @__PURE__ */ $.createElement(
      ge,
      {
        background: "generalBorderDim",
        height: "1",
        marginX: "12",
        marginY: "8"
      }
    )))
  ), i && /* @__PURE__ */ $.createElement(ge, { paddingBottom: "18", paddingX: c ? "8" : "18" }, /* @__PURE__ */ $.createElement(
    ge,
    {
      alignItems: "center",
      as: "a",
      background: { hover: "profileForeground" },
      borderRadius: "menuButton",
      className: ao({ active: "shrink" }),
      color: "modalTextDim",
      display: "flex",
      flexDirection: "row",
      href: `${i}/address/${e}`,
      justifyContent: "space-between",
      paddingX: "8",
      paddingY: "12",
      rel: "noreferrer noopener",
      style: { willChange: "transform" },
      target: "_blank",
      transition: "default",
      width: "full",
      ...c ? { paddingLeft: "12" } : {}
    },
    /* @__PURE__ */ $.createElement(
      Yt,
      {
        color: "modalText",
        font: "body",
        size: c ? "16" : "14",
        weight: c ? "semibold" : "bold"
      },
      f.t("profile.explorer.label")
    ),
    /* @__PURE__ */ $.createElement(MG, null)
  )));
}
function MU({
  action: e,
  icon: t,
  label: n,
  testId: r,
  url: i
}) {
  const o = aa();
  return /* @__PURE__ */ $.createElement(
    ge,
    {
      ...i ? { as: "a", href: i, rel: "noreferrer noopener", target: "_blank" } : { as: "button", type: "button" },
      background: {
        base: "profileAction",
        ...o ? {} : { hover: "profileActionHover" }
      },
      borderRadius: "menuButton",
      boxShadow: "profileDetailsAction",
      className: ao({
        active: "shrinkSm",
        hover: o ? void 0 : "grow"
      }),
      display: "flex",
      onClick: e,
      padding: o ? "6" : "8",
      style: { willChange: "transform" },
      testId: r,
      transition: "default",
      width: "full"
    },
    /* @__PURE__ */ $.createElement(
      ge,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        gap: "1",
        justifyContent: "center",
        paddingTop: "2",
        width: "full"
      },
      /* @__PURE__ */ $.createElement(ge, { color: "modalText", height: "max" }, t),
      /* @__PURE__ */ $.createElement(ge, null, /* @__PURE__ */ $.createElement(Yt, { color: "modalText", size: o ? "12" : "13", weight: "semibold" }, n))
    )
  );
}
function Pxe({
  accountExtraInfo: e,
  address: t,
  ensAvatar: n,
  ensName: r,
  onClose: i,
  onDisconnect: o,
  hideDisconnect: s
}) {
  const c = k.useContext(cP), [u, f] = k.useState(!1), p = k.useCallback(() => {
    t && (navigator.clipboard.writeText(t), f(!0));
  }, [t]);
  if (k.useEffect(() => {
    if (u) {
      const x = setTimeout(() => {
        f(!1);
      }, 1500);
      return () => clearTimeout(x);
    }
  }, [u]), !t)
    return null;
  const y = r ? IG(r) : OG(t), v = "rk_profile_title", w = aa(), { i18n: C } = k.useContext(fo);
  return /* @__PURE__ */ $.createElement($.Fragment, null, /* @__PURE__ */ $.createElement(ge, { display: "flex", flexDirection: "column" }, /* @__PURE__ */ $.createElement(ge, { background: "profileForeground", padding: "16" }, /* @__PURE__ */ $.createElement(
    ge,
    {
      alignItems: "center",
      display: "flex",
      flexDirection: "column",
      gap: w ? "16" : "12",
      justifyContent: "center",
      margin: "8",
      style: { textAlign: "center" }
    },
    /* @__PURE__ */ $.createElement(
      ge,
      {
        style: {
          position: "absolute",
          right: 16,
          top: 16,
          willChange: "transform"
        }
      },
      /* @__PURE__ */ $.createElement(ey, { onClose: i })
    ),
    " ",
    /* @__PURE__ */ $.createElement(ge, { marginTop: w ? "24" : "0" }, /* @__PURE__ */ $.createElement(
      cG,
      {
        address: t,
        imageUrl: n,
        size: w ? 82 : 74
      }
    )),
    /* @__PURE__ */ $.createElement(
      ge,
      {
        display: "flex",
        flexDirection: "column",
        gap: w ? "4" : "0",
        textAlign: "center"
      },
      /* @__PURE__ */ $.createElement(ge, { textAlign: "center" }, /* @__PURE__ */ $.createElement(
        Yt,
        {
          as: "h1",
          color: "modalText",
          id: v,
          size: w ? "20" : "18",
          weight: "heavy"
        },
        y
      ))
    ),
    e == null ? void 0 : e.otherAddresses.map((x) => /* @__PURE__ */ $.createElement(
      lA,
      {
        currentlySelected: !1,
        key: x,
        onClick: () => {
          e.onOtherAddressClick(x), i();
        }
      },
      /* @__PURE__ */ $.createElement(
        ge,
        {
          display: "flex",
          flexDirection: "column",
          gap: w ? "4" : "0",
          textAlign: "center"
        },
        /* @__PURE__ */ $.createElement(ge, { textAlign: "center" }, /* @__PURE__ */ $.createElement(
          Yt,
          {
            as: "h1",
            color: "modalText",
            id: v,
            size: w ? "20" : "18",
            weight: "heavy"
          },
          x
        ))
      )
    ))
  ), /* @__PURE__ */ $.createElement(
    ge,
    {
      display: "flex",
      flexDirection: "row",
      gap: "8",
      margin: "2",
      marginTop: "16"
    },
    /* @__PURE__ */ $.createElement(
      MU,
      {
        action: p,
        icon: u ? /* @__PURE__ */ $.createElement(Exe, null) : /* @__PURE__ */ $.createElement(Sxe, null),
        label: u ? C.t("profile.copy_address.copied") : C.t("profile.copy_address.label")
      }
    ),
    !s && /* @__PURE__ */ $.createElement(
      MU,
      {
        action: o,
        icon: /* @__PURE__ */ $.createElement(kxe, null),
        label: C.t("profile.disconnect.label"),
        testId: "disconnect-button"
      }
    )
  )), c && /* @__PURE__ */ $.createElement($.Fragment, null, /* @__PURE__ */ $.createElement(ge, { background: "generalBorder", height: "1", marginTop: "-1" }), /* @__PURE__ */ $.createElement(ge, null, /* @__PURE__ */ $.createElement(Mxe, { address: t })))));
}
var PG = k.createContext(void 0), Nxe = () => k.useContext(PG);
function Bxe({
  onClose: e,
  open: t,
  dialogRoot: n,
  hideDisconnect: r
}) {
  const { address: i } = os(), { ensAvatar: o, ensName: s } = hG({
    address: i
  }), { disconnect: c } = Y8(), u = Nxe();
  return i ? /* @__PURE__ */ $.createElement($.Fragment, null, i && /* @__PURE__ */ $.createElement(
    q4,
    {
      dialogRoot: n,
      onClose: e,
      open: t,
      titleId: "rk_account_modal_title"
    },
    /* @__PURE__ */ $.createElement(W4, { bottomSheetOnMobile: !0, padding: "0" }, /* @__PURE__ */ $.createElement(
      Pxe,
      {
        accountExtraInfo: u,
        address: i,
        ensAvatar: o,
        ensName: s,
        onClose: e,
        onDisconnect: c,
        hideDisconnect: r
      }
    ))
  )) : null;
}
var Lxe = ({ size: e }) => /* @__PURE__ */ $.createElement(
  "svg",
  {
    fill: "none",
    height: e,
    viewBox: "0 0 28 28",
    width: e,
    xmlns: "http://www.w3.org/2000/svg"
  },
  /* @__PURE__ */ $.createElement("title", null, "Disconnect"),
  /* @__PURE__ */ $.createElement(
    "path",
    {
      d: "M6.742 22.195h8.367c1.774 0 2.743-.968 2.743-2.758V16.11h-2.016v3.11c0 .625-.305.96-.969.96H6.984c-.664 0-.968-.335-.968-.96V7.984c0-.632.304-.968.968-.968h7.883c.664 0 .969.336.969.968v3.133h2.016v-3.36c0-1.78-.97-2.757-2.743-2.757H6.742C4.97 5 4 5.977 4 7.758v11.68c0 1.789.969 2.757 2.742 2.757Zm5.438-7.703h7.601l1.149-.07-.602.406-1.008.938a.816.816 0 0 0-.258.593c0 .407.313.782.758.782.227 0 .39-.086.547-.243l2.492-2.593c.235-.235.313-.47.313-.711 0-.242-.078-.477-.313-.719l-2.492-2.586c-.156-.156-.32-.25-.547-.25-.445 0-.758.367-.758.781 0 .227.094.446.258.594l1.008.945.602.407-1.149-.079H12.18a.904.904 0 0 0 0 1.805Z",
      fill: "currentColor"
    }
  )
), jxe = ({
  chainId: e,
  currentChainId: t,
  switchChain: n,
  chainIconSize: r,
  isLoading: i,
  src: o,
  name: s,
  iconBackground: c,
  idx: u,
  enabled: f,
  onDiabledChainClick: p,
  switchError: y,
  chain: v
}) => {
  const w = aa(), { i18n: C } = k.useContext(fo), x = uy(), A = t === e;
  return /* @__PURE__ */ $.createElement(k.Fragment, null, /* @__PURE__ */ $.createElement(
    lA,
    {
      currentlySelected: A,
      onClick: A ? void 0 : f ? () => n({ chainId: e }) : () => p(),
      testId: `chain-option-${e}`
    },
    /* @__PURE__ */ $.createElement(
      ge,
      {
        fontFamily: "body",
        fontSize: "16",
        fontWeight: "bold",
        style: { opacity: f ? 1 : 0.4 }
      },
      /* @__PURE__ */ $.createElement(
        ge,
        {
          alignItems: "center",
          display: "flex",
          flexDirection: "row",
          justifyContent: "space-between"
        },
        /* @__PURE__ */ $.createElement(
          ge,
          {
            alignItems: "center",
            display: "flex",
            flexDirection: "row",
            gap: "4",
            height: r
          },
          o && /* @__PURE__ */ $.createElement(ge, { height: "full", marginRight: "8" }, /* @__PURE__ */ $.createElement(
            _o,
            {
              alt: s,
              background: c,
              borderRadius: "full",
              height: r,
              src: o,
              width: r,
              testId: `chain-option-${e}-icon`
            }
          )),
          /* @__PURE__ */ $.createElement("div", null, s ?? s)
        ),
        A ? /* @__PURE__ */ $.createElement(
          ge,
          {
            alignItems: "center",
            display: "flex",
            flexDirection: "row",
            marginRight: "6"
          },
          /* @__PURE__ */ $.createElement(Yt, { color: "accentColorForeground", size: "14", weight: "medium" }, C.t("chains.connected")),
          /* @__PURE__ */ $.createElement(
            ge,
            {
              background: "connectionIndicator",
              borderColor: "selectedOptionBorder",
              borderRadius: "full",
              borderStyle: "solid",
              borderWidth: "1",
              height: "8",
              marginLeft: "8",
              width: "8"
            }
          )
        ) : i ? /* @__PURE__ */ $.createElement(
          ge,
          {
            alignItems: "center",
            display: "flex",
            flexDirection: "row",
            marginRight: "6"
          },
          /* @__PURE__ */ $.createElement(Yt, { color: "modalText", size: "14", weight: "medium" }, y ? C.t("chains.confirm_error") : C.t("chains.confirm")),
          /* @__PURE__ */ $.createElement(
            ge,
            {
              background: y ? "error" : "standby",
              borderRadius: "full",
              height: "8",
              marginLeft: "8",
              width: "8"
            }
          )
        ) : !v.enabled && v.info ? /* @__PURE__ */ $.createElement(
          ge,
          {
            alignItems: "center",
            display: "flex",
            flexDirection: "row",
            marginRight: "6"
          },
          /* @__PURE__ */ $.createElement(Yt, { color: "modalText", size: "14", weight: "medium" }, v.info)
        ) : null
      )
    )
  ), w && u < x.length - 1 && /* @__PURE__ */ $.createElement(ge, { background: "generalBorderDim", height: "1", marginX: "8" }));
}, Fxe = jxe, Uxe = "dwg2bm0", zxe = "dwg2bm1";
function Vxe({ onClose: e, open: t, dialogRoot: n }) {
  const { chainId: r } = os(), { chains: i } = Ho(), [o, s] = k.useState(null), { switchChain: c, reset: u, isError: f } = Ybe({
    mutation: {
      onMutate: ({ chainId: F }) => {
        s(F);
      },
      onSuccess: () => {
        o && s(null), p();
      }
      // onError: () => {
      //   if (pendingChainId) setPendingChainId(null);
      // },
      // onSettled: () => {
      //   _onClose();
      // },
    }
  }), p = () => {
    u(), e();
  }, y = k.useMemo(() => new Map(i.map((F) => [F.id, F])), [i]), { i18n: v } = k.useContext(fo), { disconnect: w } = Y8(), C = "rk_chain_modal_title", x = aa(), A = r && y.has(r), R = x ? "36" : "28", I = uy(), D = yCe(), M = vCe(), L = k.useMemo(
    () => new Map(D.map((F) => [F.id, F])),
    [D]
  ), j = k.useMemo(
    () => [
      ...I.reduce(
        (F, O) => {
          const z = y.get(O.id);
          return !z || L.has(z.id) || F.push({ ...O, ...z, enabled: !0 }), F;
        },
        []
      ),
      ...D.map((F) => ({
        ...F,
        enabled: !1
      }))
    ],
    [I, D, y]
  );
  return r ? /* @__PURE__ */ $.createElement(
    q4,
    {
      onClose: e,
      open: t,
      titleId: C,
      dialogRoot: n
    },
    /* @__PURE__ */ $.createElement(W4, { bottomSheetOnMobile: !0, paddingBottom: "0" }, /* @__PURE__ */ $.createElement(ge, { display: "flex", flexDirection: "column", gap: "14" }, /* @__PURE__ */ $.createElement(
      ge,
      {
        display: "flex",
        flexDirection: "row",
        justifyContent: "space-between"
      },
      x && /* @__PURE__ */ $.createElement(ge, { width: "30" }),
      /* @__PURE__ */ $.createElement(ge, { paddingBottom: "0", paddingLeft: "8", paddingTop: "4" }, /* @__PURE__ */ $.createElement(
        Yt,
        {
          as: "h1",
          color: "modalText",
          id: C,
          size: x ? "20" : "18",
          weight: "heavy"
        },
        v.t("chains.title")
      )),
      /* @__PURE__ */ $.createElement(ey, { onClose: e })
    ), !A && /* @__PURE__ */ $.createElement(ge, { marginX: "8", textAlign: x ? "center" : "left" }, /* @__PURE__ */ $.createElement(Yt, { color: "modalTextSecondary", size: "14", weight: "medium" }, v.t("chains.wrong_network"))), /* @__PURE__ */ $.createElement(
      ge,
      {
        className: x ? zxe : Uxe,
        display: "flex",
        flexDirection: "column",
        gap: "4",
        padding: "2",
        paddingBottom: "16"
      },
      j.map((F, O) => {
        const { iconBackground: z, iconUrl: H, id: Q, name: Y, enabled: ee } = F;
        return /* @__PURE__ */ $.createElement(
          Fxe,
          {
            key: Q,
            chainId: Q,
            currentChainId: r,
            switchChain: c,
            chainIconSize: R,
            isLoading: o === Q,
            src: H,
            name: Y,
            iconBackground: z,
            idx: O,
            enabled: ee,
            onDiabledChainClick: () => M == null ? void 0 : M(F),
            switchError: f,
            chain: F
          }
        );
      }),
      !A && /* @__PURE__ */ $.createElement($.Fragment, null, /* @__PURE__ */ $.createElement(ge, { background: "generalBorderDim", height: "1", marginX: "8" }), /* @__PURE__ */ $.createElement(
        lA,
        {
          onClick: () => w(),
          testId: "chain-option-disconnect"
        },
        /* @__PURE__ */ $.createElement(
          ge,
          {
            color: "error",
            fontFamily: "body",
            fontSize: "16",
            fontWeight: "bold"
          },
          /* @__PURE__ */ $.createElement(
            ge,
            {
              alignItems: "center",
              display: "flex",
              flexDirection: "row",
              justifyContent: "space-between"
            },
            /* @__PURE__ */ $.createElement(
              ge,
              {
                alignItems: "center",
                display: "flex",
                flexDirection: "row",
                gap: "4",
                height: R
              },
              /* @__PURE__ */ $.createElement(
                ge,
                {
                  alignItems: "center",
                  color: "error",
                  height: R,
                  justifyContent: "center",
                  marginRight: "8"
                },
                /* @__PURE__ */ $.createElement(Lxe, { size: Number(R) })
              ),
              /* @__PURE__ */ $.createElement("div", null, v.t("chains.disconnect"))
            )
          )
        )
      ))
    )))
  ) : null;
}
function $xe(e, t) {
  const n = {};
  for (const r of e) {
    const i = t(r);
    i && (n[i] || (n[i] = []), n[i].push(r));
  }
  return n;
}
var pP = ({
  children: e,
  href: t
}) => /* @__PURE__ */ $.createElement(
  ge,
  {
    as: "a",
    color: "accentColor",
    href: t,
    rel: "noreferrer",
    target: "_blank"
  },
  e
), mP = ({ children: e }) => /* @__PURE__ */ $.createElement(Yt, { color: "modalTextSecondary", size: "12", weight: "medium" }, e);
function PU({
  compactModeEnabled: e = !1,
  getWallet: t
}) {
  const { disclaimer: n, learnMoreUrl: r } = k.useContext(ex), { i18n: i } = k.useContext(fo);
  return /* @__PURE__ */ $.createElement($.Fragment, null, /* @__PURE__ */ $.createElement(
    ge,
    {
      alignItems: "center",
      color: "accentColor",
      display: "flex",
      flexDirection: "column",
      height: "full",
      justifyContent: "space-around"
    },
    /* @__PURE__ */ $.createElement(ge, { marginBottom: "10" }, !e && /* @__PURE__ */ $.createElement(Yt, { color: "modalText", size: "18", weight: "heavy" }, i.t("intro.title"))),
    /* @__PURE__ */ $.createElement(
      ge,
      {
        display: "flex",
        flexDirection: "column",
        gap: "32",
        justifyContent: "center",
        marginY: "20",
        style: { maxWidth: 312 }
      },
      /* @__PURE__ */ $.createElement(ge, { alignItems: "center", display: "flex", flexDirection: "row", gap: "16" }, /* @__PURE__ */ $.createElement(ge, { borderRadius: "6", height: "48", minWidth: "48", width: "48" }, /* @__PURE__ */ $.createElement(ZCe, null)), /* @__PURE__ */ $.createElement(ge, { display: "flex", flexDirection: "column", gap: "4" }, /* @__PURE__ */ $.createElement(Yt, { color: "modalText", size: "14", weight: "bold" }, i.t("intro.digital_asset.title")), /* @__PURE__ */ $.createElement(Yt, { color: "modalTextSecondary", size: "14", weight: "medium" }, i.t("intro.digital_asset.description")))),
      /* @__PURE__ */ $.createElement(ge, { alignItems: "center", display: "flex", flexDirection: "row", gap: "16" }, /* @__PURE__ */ $.createElement(ge, { borderRadius: "6", height: "48", minWidth: "48", width: "48" }, /* @__PURE__ */ $.createElement(txe, null)), /* @__PURE__ */ $.createElement(ge, { display: "flex", flexDirection: "column", gap: "4" }, /* @__PURE__ */ $.createElement(Yt, { color: "modalText", size: "14", weight: "bold" }, i.t("intro.login.title")), /* @__PURE__ */ $.createElement(Yt, { color: "modalTextSecondary", size: "14", weight: "medium" }, i.t("intro.login.description"))))
    ),
    /* @__PURE__ */ $.createElement(
      ge,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        gap: "12",
        justifyContent: "center",
        margin: "10"
      },
      /* @__PURE__ */ $.createElement(is, { label: i.t("intro.get.label"), onClick: t }),
      /* @__PURE__ */ $.createElement(
        ge,
        {
          as: "a",
          className: ao({ active: "shrink", hover: "grow" }),
          display: "block",
          href: r,
          paddingX: "12",
          paddingY: "4",
          rel: "noreferrer",
          style: { willChange: "transform" },
          target: "_blank",
          transition: "default"
        },
        /* @__PURE__ */ $.createElement(Yt, { color: "accentColor", size: "14", weight: "bold" }, i.t("intro.learn_more.label"))
      )
    ),
    n && !e && /* @__PURE__ */ $.createElement(ge, { marginBottom: "8", marginTop: "12", textAlign: "center" }, /* @__PURE__ */ $.createElement(n, { Link: pP, Text: mP }))
  ));
}
var NG = () => /* @__PURE__ */ $.createElement(
  "svg",
  {
    fill: "none",
    height: "17",
    viewBox: "0 0 11 17",
    width: "11",
    xmlns: "http://www.w3.org/2000/svg"
  },
  /* @__PURE__ */ $.createElement("title", null, "Back"),
  /* @__PURE__ */ $.createElement(
    "path",
    {
      d: "M0.99707 8.6543C0.99707 9.08496 1.15527 9.44531 1.51562 9.79688L8.16016 16.3096C8.43262 16.5732 8.74902 16.7051 9.13574 16.7051C9.90918 16.7051 10.5508 16.0811 10.5508 15.3076C10.5508 14.9121 10.3838 14.5605 10.0938 14.2705L4.30176 8.64551L10.0938 3.0293C10.3838 2.74805 10.5508 2.3877 10.5508 2.00098C10.5508 1.23633 9.90918 0.603516 9.13574 0.603516C8.74902 0.603516 8.43262 0.735352 8.16016 0.999023L1.51562 7.51172C1.15527 7.85449 1.00586 8.21484 0.99707 8.6543Z",
      fill: "currentColor"
    }
  )
), Hxe = () => /* @__PURE__ */ $.createElement(
  "svg",
  {
    fill: "none",
    height: "12",
    viewBox: "0 0 8 12",
    width: "8",
    xmlns: "http://www.w3.org/2000/svg"
  },
  /* @__PURE__ */ $.createElement("title", null, "Info"),
  /* @__PURE__ */ $.createElement(
    "path",
    {
      d: "M3.64258 7.99609C4.19336 7.99609 4.5625 7.73828 4.68555 7.24609C4.69141 7.21094 4.70312 7.16406 4.70898 7.13477C4.80859 6.60742 5.05469 6.35547 6.04492 5.76367C7.14648 5.10156 7.67969 4.3457 7.67969 3.24414C7.67969 1.39844 6.17383 0.255859 3.95898 0.255859C2.32422 0.255859 1.05859 0.894531 0.548828 1.86719C0.396484 2.14844 0.320312 2.44727 0.320312 2.74023C0.314453 3.37305 0.742188 3.79492 1.42188 3.79492C1.91406 3.79492 2.33594 3.54883 2.53516 3.11523C2.78711 2.47656 3.23242 2.21289 3.83594 2.21289C4.55664 2.21289 5.10742 2.65234 5.10742 3.29102C5.10742 3.9707 4.7793 4.29883 3.81836 4.87891C3.02148 5.36523 2.50586 5.92773 2.50586 6.76562V6.90039C2.50586 7.55664 2.96289 7.99609 3.64258 7.99609ZM3.67188 11.4473C4.42773 11.4473 5.04297 10.8672 5.04297 10.1406C5.04297 9.41406 4.42773 8.83984 3.67188 8.83984C2.91602 8.83984 2.30664 9.41406 2.30664 10.1406C2.30664 10.8672 2.91602 11.4473 3.67188 11.4473Z",
      fill: "currentColor"
    }
  )
), qxe = ({
  "aria-label": e = "Info",
  onClick: t
}) => {
  const n = aa();
  return /* @__PURE__ */ $.createElement(
    ge,
    {
      alignItems: "center",
      "aria-label": e,
      as: "button",
      background: "closeButtonBackground",
      borderColor: "actionButtonBorder",
      borderRadius: "full",
      borderStyle: "solid",
      borderWidth: n ? "0" : "1",
      className: ao({ active: "shrinkSm", hover: "growLg" }),
      color: "closeButton",
      display: "flex",
      height: n ? "30" : "28",
      justifyContent: "center",
      onClick: t,
      style: { willChange: "transform" },
      transition: "default",
      type: "button",
      width: n ? "30" : "28"
    },
    /* @__PURE__ */ $.createElement(Hxe, null)
  );
}, BG = (e) => {
  const t = k.useRef(null), n = k.useContext(bG), r = aP(e);
  return k.useEffect(() => {
    if (n && t.current && r)
      return Gxe(t.current, r);
  }, [n, r]), t;
}, Wxe = () => {
  const e = "_rk_coolMode", t = document.getElementById(e);
  if (t)
    return t;
  const n = document.createElement("div");
  return n.setAttribute("id", e), n.setAttribute(
    "style",
    [
      "overflow:hidden",
      "position:fixed",
      "height:100%",
      "top:0",
      "left:0",
      "right:0",
      "bottom:0",
      "pointer-events:none",
      "z-index:2147483647"
    ].join(";")
  ), document.body.appendChild(n), n;
}, NU = 0;
function Gxe(e, t) {
  NU++;
  const n = [15, 20, 25, 35, 45], r = 35;
  let i = [], o = !1, s = 0, c = 0;
  const u = Wxe();
  function f() {
    const M = n[Math.floor(Math.random() * n.length)], L = Math.random() * 10, j = Math.random() * 25, F = Math.random() * 360, O = Math.random() * 35 * (Math.random() <= 0.5 ? -1 : 1), z = c - M / 2, H = s - M / 2, Q = Math.random() <= 0.5 ? -1 : 1, Y = document.createElement("div");
    Y.innerHTML = `<img src="${t}" width="${M}" height="${M}" style="border-radius: 25%">`, Y.setAttribute(
      "style",
      [
        "position:absolute",
        "will-change:transform",
        `top:${z}px`,
        `left:${H}px`,
        `transform:rotate(${F}deg)`
      ].join(";")
    ), u.appendChild(Y), i.push({
      direction: Q,
      element: Y,
      left: H,
      size: M,
      speedHorz: L,
      speedUp: j,
      spinSpeed: O,
      spinVal: F,
      top: z
    });
  }
  function p() {
    for (const M of i)
      M.left = M.left - M.speedHorz * M.direction, M.top = M.top - M.speedUp, M.speedUp = Math.min(M.size, M.speedUp - 1), M.spinVal = M.spinVal + M.spinSpeed, M.top >= Math.max(window.innerHeight, document.body.clientHeight) + M.size && (i = i.filter((L) => L !== M), M.element.remove()), M.element.setAttribute(
        "style",
        [
          "position:absolute",
          "will-change:transform",
          `top:${M.top}px`,
          `left:${M.left}px`,
          `transform:rotate(${M.spinVal}deg)`
        ].join(";")
      );
  }
  let y;
  function v() {
    o && i.length < r && f(), p(), y = requestAnimationFrame(v);
  }
  v();
  const w = "ontouchstart" in window || // @ts-expect-error
  navigator.msMaxTouchPoints, C = w ? "touchstart" : "mousedown", x = w ? "touchend" : "mouseup", A = w ? "touchmove" : "mousemove", R = (M) => {
    var L, j;
    "touches" in M ? (s = (L = M.touches) == null ? void 0 : L[0].clientX, c = (j = M.touches) == null ? void 0 : j[0].clientY) : (s = M.clientX, c = M.clientY);
  }, I = (M) => {
    R(M), o = !0;
  }, D = () => {
    o = !1;
  };
  return e.addEventListener(A, R, { passive: !1 }), e.addEventListener(C, I), e.addEventListener(x, D), e.addEventListener("mouseleave", D), () => {
    e.removeEventListener(A, R), e.removeEventListener(C, I), e.removeEventListener(x, D), e.removeEventListener("mouseleave", D);
    const M = setInterval(() => {
      y && i.length === 0 && (cancelAnimationFrame(y), clearInterval(M), --NU === 0 && u.remove());
    }, 500);
  };
}
var Kxe = "ywp5x60", LG = ({
  as: e = "button",
  currentlySelected: t = !1,
  iconBackground: n,
  iconUrl: r,
  name: i,
  onClick: o,
  ready: s,
  recent: c,
  testId: u,
  isRainbowKitConnector: f,
  ...p
}) => {
  const y = BG(r), [v, w] = k.useState(!1), { i18n: C } = k.useContext(fo);
  return /* @__PURE__ */ $.createElement(
    ge,
    {
      display: "flex",
      flexDirection: "column",
      onMouseEnter: () => w(!0),
      onMouseLeave: () => w(!1),
      ref: y
    },
    /* @__PURE__ */ $.createElement(
      ge,
      {
        as: e,
        borderRadius: "menuButton",
        borderStyle: "solid",
        borderWidth: "1",
        className: t ? void 0 : [
          Kxe,
          ao({
            active: "shrink"
          })
        ],
        disabled: t,
        onClick: o,
        padding: "5",
        style: { willChange: "transform" },
        testId: u,
        transition: "default",
        width: "full",
        ...t ? {
          background: "accentColor",
          borderColor: "selectedOptionBorder",
          boxShadow: "selectedWallet"
        } : {
          background: { hover: "menuItemBackground" }
        },
        ...p
      },
      /* @__PURE__ */ $.createElement(
        ge,
        {
          color: t ? "accentColorForeground" : "modalText",
          disabled: !s,
          fontFamily: "body",
          fontSize: "16",
          fontWeight: "bold",
          transition: "default"
        },
        /* @__PURE__ */ $.createElement(ge, { alignItems: "center", display: "flex", flexDirection: "row", gap: "12" }, /* @__PURE__ */ $.createElement(
          _o,
          {
            background: n,
            ...!v && f ? { borderColor: "actionButtonBorder" } : {},
            useAsImage: !f,
            borderRadius: "6",
            height: "28",
            src: r,
            width: "28"
          }
        ), /* @__PURE__ */ $.createElement(ge, null, /* @__PURE__ */ $.createElement(
          ge,
          {
            style: { marginTop: c ? -2 : void 0 },
            maxWidth: "200"
          },
          i
        ), c && /* @__PURE__ */ $.createElement(
          Yt,
          {
            color: t ? "accentColorForeground" : "accentColor",
            size: "12",
            style: { lineHeight: 1, marginTop: -1 },
            weight: "medium"
          },
          C.t("connect.recent")
        )))
      )
    )
  );
};
LG.displayName = "ModalSelection";
var Yxe = "rk-latest-id";
function Qxe(e) {
  localStorage.setItem(Yxe, e);
}
var OO = (e, t = 1) => {
  let n = e.replace("#", "");
  n.length === 3 && (n = `${n[0]}${n[0]}${n[1]}${n[1]}${n[2]}${n[2]}`);
  const r = parseInt(n.substring(0, 2), 16), i = parseInt(n.substring(2, 4), 16), o = parseInt(n.substring(4, 6), 16);
  return t > 1 && t <= 100 && (t = t / 100), `rgba(${r},${i},${o},${t})`;
}, Xxe = (e) => e ? [
  OO(e, 0.2),
  OO(e, 0.14),
  OO(e, 0.1)
] : null, Jxe = (e) => /^#([0-9a-f]{3}){1,2}$/i.test(e), jG = async () => (await import("./connect-MR6XDLIE-C7NpR-Px.js")).default, Zxe = () => zu(jG), eEe = () => /* @__PURE__ */ $.createElement(
  _o,
  {
    background: "#515a70",
    borderColor: "generalBorder",
    borderRadius: "10",
    height: "48",
    src: jG,
    width: "48"
  }
), FG = async () => (await import("./create-X4WFHLCW-oW90TXsK.js")).default, UG = () => zu(FG), tEe = () => /* @__PURE__ */ $.createElement(
  _o,
  {
    background: "#e3a5e8",
    borderColor: "generalBorder",
    borderRadius: "10",
    height: "48",
    src: FG,
    width: "48"
  }
), zG = async () => (await import("./refresh-HJGJRASX-BCWLCZM4.js")).default, nEe = () => zu(zG), rEe = () => /* @__PURE__ */ $.createElement(
  _o,
  {
    background: "#515a70",
    borderColor: "generalBorder",
    borderRadius: "10",
    height: "48",
    src: zG,
    width: "48"
  }
), VG = async () => (await import("./scan-DEOT2M37-Cpw61h20.js")).default, $G = () => zu(VG), iEe = () => /* @__PURE__ */ $.createElement(
  _o,
  {
    background: "#515a70",
    borderColor: "generalBorder",
    borderRadius: "10",
    height: "48",
    src: VG,
    width: "48"
  }
), oEe = "_1ud5su60", aEe = "_1ud5su62 in5bvi7a in5bvi7v", sEe = "_1ud5su63", lEe = "_1ud5su64", cEe = (e, t) => {
  const n = Array.prototype.slice.call(
    XC.create(e, { errorCorrectionLevel: t }).modules.data,
    0
  ), r = Math.sqrt(n.length);
  return n.reduce(
    (i, o, s) => (s % r === 0 ? i.push([o]) : i[i.length - 1].push(o)) && i,
    []
  );
};
function HG({
  ecl: e = "M",
  logoBackground: t,
  logoMargin: n = 10,
  logoSize: r = 50,
  logoUrl: i,
  size: o = 200,
  uri: s
}) {
  const c = "20", u = o - parseInt(c, 10) * 2, f = k.useMemo(() => {
    const v = [], w = cEe(s, e), C = u / w.length;
    [
      { x: 0, y: 0 },
      { x: 1, y: 0 },
      { x: 0, y: 1 }
    ].forEach(({ x: D, y: M }) => {
      const L = (w.length - 7) * C * D, j = (w.length - 7) * C * M;
      for (let F = 0; F < 3; F++)
        v.push(
          /* @__PURE__ */ $.createElement(
            "rect",
            {
              fill: F % 2 !== 0 ? "white" : "black",
              height: C * (7 - F * 2),
              key: `${F}-${D}-${M}`,
              rx: (F - 2) * -5 + (F === 0 ? 2 : 0),
              ry: (F - 2) * -5 + (F === 0 ? 2 : 0),
              width: C * (7 - F * 2),
              x: L + C * F,
              y: j + C * F
            }
          )
        );
    });
    const A = Math.floor((r + 25) / C), R = w.length / 2 - A / 2, I = w.length / 2 + A / 2 - 1;
    return w.forEach((D, M) => {
      D.forEach((L, j) => {
        w[M][j] && (M < 7 && j < 7 || M > w.length - 8 && j < 7 || M < 7 && j > w.length - 8 || M > R && M < I && j > R && j < I || v.push(
          /* @__PURE__ */ $.createElement(
            "circle",
            {
              cx: M * C + C / 2,
              cy: j * C + C / 2,
              fill: "black",
              key: `circle-${M}-${j}`,
              r: C / 3
            }
          )
        ));
      });
    }), v;
  }, [e, r, u, s]), p = u / 2 - r / 2, y = r + n * 2;
  return /* @__PURE__ */ $.createElement(
    ge,
    {
      borderColor: "generalBorder",
      borderRadius: "menuButton",
      borderStyle: "solid",
      borderWidth: "1",
      className: oEe,
      padding: c,
      width: "max"
    },
    /* @__PURE__ */ $.createElement(
      ge,
      {
        style: {
          height: u,
          userSelect: "none",
          width: u
        },
        userSelect: "none"
      },
      /* @__PURE__ */ $.createElement(
        ge,
        {
          display: "flex",
          justifyContent: "center",
          position: "relative",
          style: {
            height: 0,
            top: p,
            width: u
          },
          width: "full"
        },
        /* @__PURE__ */ $.createElement(
          _o,
          {
            background: t,
            borderColor: { custom: "rgba(0, 0, 0, 0.06)" },
            borderRadius: "13",
            height: r,
            src: i,
            width: r
          }
        )
      ),
      /* @__PURE__ */ $.createElement("svg", { height: u, style: { all: "revert" }, width: u }, /* @__PURE__ */ $.createElement("title", null, "QR Code"), /* @__PURE__ */ $.createElement("defs", null, /* @__PURE__ */ $.createElement("clipPath", { id: "clip-wrapper" }, /* @__PURE__ */ $.createElement("rect", { height: y, width: y })), /* @__PURE__ */ $.createElement("clipPath", { id: "clip-logo" }, /* @__PURE__ */ $.createElement("rect", { height: r, width: r }))), /* @__PURE__ */ $.createElement("rect", { fill: "transparent", height: u, width: u }), f)
    )
  );
}
var qG = async () => {
  switch (dP()) {
    case "Arc":
      return (await import("./Arc-R3PUWRPJ-CzlFC3D9.js")).default;
    case "Brave":
      return (await import("./Brave-24BM36UM-bPiVSPZ4.js")).default;
    case "Chrome":
      return (await import("./Chrome-TLI42HDP-5Yy7ks3E.js")).default;
    case "Edge":
      return (await import("./Edge-AZ34LAFM-DB7uOto4.js")).default;
    case "Firefox":
      return (await import("./Firefox-ZDK7RHKK-DL7f6FOf.js")).default;
    case "Opera":
      return (await import("./Opera-BKMCKUXC-YnRFnGED.js")).default;
    case "Safari":
      return (await import("./Safari-PXQIVS6N-IggR6rL6.js")).default;
    default:
      return (await import("./Browser-4R4QKTV2-B2zEsSyl.js")).default;
  }
}, uEe = () => zu(qG), WG = async () => {
  switch (hP()) {
    case "Windows":
      return (await import("./Windows-GTAT3OTE-Bhzq4JtM.js")).default;
    case "macOS":
      return (await import("./Macos-5QL4JBJE-YtzYR2og.js")).default;
    case "Linux":
      return (await import("./Linux-VYP66PDO-DXr-DaP_.js")).default;
    default:
      return (await import("./Linux-VYP66PDO-DXr-DaP_.js")).default;
  }
}, dEe = () => zu(WG);
function fEe({
  getWalletDownload: e,
  compactModeEnabled: t
}) {
  const r = sA().filter(
    (o) => o.isRainbowKitConnector
  ).splice(0, 5), { i18n: i } = k.useContext(fo);
  return /* @__PURE__ */ $.createElement(
    ge,
    {
      alignItems: "center",
      display: "flex",
      flexDirection: "column",
      height: "full",
      marginTop: "18",
      width: "full"
    },
    /* @__PURE__ */ $.createElement(
      ge,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        gap: "28",
        height: "full",
        width: "full"
      },
      r == null ? void 0 : r.filter(
        (o) => {
          var s;
          return o.extensionDownloadUrl || o.desktopDownloadUrl || o.qrCode && ((s = o.downloadUrls) == null ? void 0 : s.qrCode);
        }
      ).map((o) => {
        const { downloadUrls: s, iconBackground: c, iconUrl: u, id: f, name: p, qrCode: y } = o, v = (s == null ? void 0 : s.qrCode) && y, w = !!o.extensionDownloadUrl, C = (s == null ? void 0 : s.qrCode) && w, x = (s == null ? void 0 : s.qrCode) && !!o.desktopDownloadUrl;
        return /* @__PURE__ */ $.createElement(
          ge,
          {
            alignItems: "center",
            display: "flex",
            gap: "16",
            justifyContent: "space-between",
            key: o.id,
            width: "full"
          },
          /* @__PURE__ */ $.createElement(
            ge,
            {
              alignItems: "center",
              display: "flex",
              flexDirection: "row",
              gap: "16"
            },
            /* @__PURE__ */ $.createElement(
              _o,
              {
                background: c,
                borderColor: "actionButtonBorder",
                borderRadius: "10",
                height: "48",
                src: u,
                width: "48"
              }
            ),
            /* @__PURE__ */ $.createElement(ge, { display: "flex", flexDirection: "column", gap: "2" }, /* @__PURE__ */ $.createElement(Yt, { color: "modalText", size: "14", weight: "bold" }, p), /* @__PURE__ */ $.createElement(Yt, { color: "modalTextSecondary", size: "14", weight: "medium" }, C ? i.t("get.mobile_and_extension.description") : x ? i.t("get.mobile_and_desktop.description") : v ? i.t("get.mobile.description") : w ? i.t("get.extension.description") : null))
          ),
          /* @__PURE__ */ $.createElement(ge, { display: "flex", flexDirection: "column", gap: "4" }, /* @__PURE__ */ $.createElement(
            is,
            {
              label: i.t("get.action.label"),
              onClick: () => e(f),
              type: "secondary"
            }
          ))
        );
      })
    ),
    /* @__PURE__ */ $.createElement(
      ge,
      {
        alignItems: "center",
        borderRadius: "10",
        display: "flex",
        flexDirection: "column",
        gap: "8",
        justifyContent: "space-between",
        marginBottom: "4",
        paddingY: "8",
        style: { maxWidth: 275, textAlign: "center" }
      },
      /* @__PURE__ */ $.createElement(Yt, { color: "modalText", size: "14", weight: "bold" }, i.t("get.looking_for.title")),
      /* @__PURE__ */ $.createElement(Yt, { color: "modalTextSecondary", size: "14", weight: "medium" }, t ? i.t("get.looking_for.desktop.compact_description") : i.t("get.looking_for.desktop.wide_description"))
    )
  );
}
var IO = "44";
function hEe({
  changeWalletStep: e,
  compactModeEnabled: t,
  connectionError: n,
  onClose: r,
  qrCodeUri: i,
  reconnect: o,
  wallet: s
}) {
  const {
    downloadUrls: c,
    iconBackground: u,
    iconUrl: f,
    name: p,
    qrCode: y,
    ready: v,
    showWalletConnectModal: w,
    getDesktopUri: C
  } = s, x = !!C, A = uP(), { i18n: R } = k.useContext(fo), I = !!s.extensionDownloadUrl, D = (c == null ? void 0 : c.qrCode) && I, M = (c == null ? void 0 : c.qrCode) && !!s.desktopDownloadUrl, L = y && i, j = async () => {
    const H = await (C == null ? void 0 : C());
    window.open(H, A ? "_blank" : "_self");
  }, F = w ? {
    description: t ? R.t("connect.walletconnect.description.compact") : R.t("connect.walletconnect.description.full"),
    label: R.t("connect.walletconnect.open.label"),
    onClick: () => {
      r(), w();
    }
  } : L ? {
    description: R.t("connect.secondary_action.get.description", {
      wallet: p
    }),
    label: R.t("connect.secondary_action.get.label"),
    onClick: () => e(
      D || M ? "DOWNLOAD_OPTIONS" : "DOWNLOAD"
      /* Download */
    )
  } : null, { width: O } = wG(), z = O && O < 768;
  return k.useEffect(() => {
    uEe(), dEe();
  }, []), /* @__PURE__ */ $.createElement(ge, { display: "flex", flexDirection: "column", height: "full", width: "full" }, L ? /* @__PURE__ */ $.createElement(
    ge,
    {
      alignItems: "center",
      display: "flex",
      height: "full",
      justifyContent: "center"
    },
    /* @__PURE__ */ $.createElement(
      HG,
      {
        logoBackground: u,
        logoSize: t ? 60 : 72,
        logoUrl: f,
        size: t ? 318 : z ? Math.max(280, Math.min(O - 308, 382)) : 382,
        uri: i
      }
    )
  ) : /* @__PURE__ */ $.createElement(
    ge,
    {
      alignItems: "center",
      display: "flex",
      justifyContent: "center",
      style: { flexGrow: 1 }
    },
    /* @__PURE__ */ $.createElement(
      ge,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        gap: "8"
      },
      /* @__PURE__ */ $.createElement(ge, { borderRadius: "10", height: IO, overflow: "hidden" }, /* @__PURE__ */ $.createElement(
        _o,
        {
          useAsImage: !s.isRainbowKitConnector,
          height: IO,
          src: f,
          width: IO
        }
      )),
      /* @__PURE__ */ $.createElement(
        ge,
        {
          alignItems: "center",
          display: "flex",
          flexDirection: "column",
          gap: "4",
          paddingX: "32",
          style: { textAlign: "center" }
        },
        /* @__PURE__ */ $.createElement(Yt, { color: "modalText", size: "18", weight: "bold" }, v ? R.t("connect.status.opening", {
          wallet: p
        }) : I ? R.t("connect.status.not_installed", {
          wallet: p
        }) : R.t("connect.status.not_available", {
          wallet: p
        })),
        !v && I ? /* @__PURE__ */ $.createElement(ge, { paddingTop: "20" }, /* @__PURE__ */ $.createElement(
          is,
          {
            href: s.extensionDownloadUrl,
            label: R.t("connect.secondary_action.install.label"),
            type: "secondary"
          }
        )) : null,
        v && !L && /* @__PURE__ */ $.createElement($.Fragment, null, /* @__PURE__ */ $.createElement(
          ge,
          {
            alignItems: "center",
            display: "flex",
            flexDirection: "column",
            justifyContent: "center"
          },
          /* @__PURE__ */ $.createElement(
            Yt,
            {
              color: "modalTextSecondary",
              size: "14",
              textAlign: "center",
              weight: "medium"
            },
            R.t("connect.status.confirm")
          )
        ), /* @__PURE__ */ $.createElement(
          ge,
          {
            alignItems: "center",
            color: "modalText",
            display: "flex",
            flexDirection: "row",
            height: "32",
            marginTop: "8"
          },
          n ? /* @__PURE__ */ $.createElement(
            is,
            {
              label: R.t("connect.secondary_action.retry.label"),
              onClick: async () => {
                x && j(), o(s);
              }
            }
          ) : /* @__PURE__ */ $.createElement(ge, { color: "modalTextSecondary" }, /* @__PURE__ */ $.createElement(fC, null))
        ))
      )
    )
  ), /* @__PURE__ */ $.createElement(
    ge,
    {
      alignItems: "center",
      borderRadius: "10",
      display: "flex",
      flexDirection: "row",
      gap: "8",
      height: "28",
      justifyContent: "space-between",
      marginTop: "12"
    },
    v && F && /* @__PURE__ */ $.createElement($.Fragment, null, /* @__PURE__ */ $.createElement(Yt, { color: "modalTextSecondary", size: "14", weight: "medium" }, F.description), /* @__PURE__ */ $.createElement(
      is,
      {
        label: F.label,
        onClick: F.onClick,
        type: "secondary"
      }
    ))
  ));
}
var DO = ({
  actionLabel: e,
  description: t,
  iconAccent: n,
  iconBackground: r,
  iconUrl: i,
  isCompact: o,
  onAction: s,
  title: c,
  url: u,
  variant: f
}) => {
  const p = f === "browser", y = !p && n && Xxe(n);
  return /* @__PURE__ */ $.createElement(
    ge,
    {
      alignItems: "center",
      borderRadius: "13",
      display: "flex",
      justifyContent: "center",
      overflow: "hidden",
      paddingX: o ? "18" : "44",
      position: "relative",
      style: { flex: 1, isolation: "isolate" },
      width: "full"
    },
    /* @__PURE__ */ $.createElement(
      ge,
      {
        borderColor: "actionButtonBorder",
        borderRadius: "13",
        borderStyle: "solid",
        borderWidth: "1",
        style: {
          bottom: "0",
          left: "0",
          position: "absolute",
          right: "0",
          top: "0",
          zIndex: 1
        }
      }
    ),
    p && /* @__PURE__ */ $.createElement(
      ge,
      {
        background: "downloadTopCardBackground",
        height: "full",
        position: "absolute",
        style: {
          zIndex: 0
        },
        width: "full"
      },
      /* @__PURE__ */ $.createElement(
        ge,
        {
          display: "flex",
          flexDirection: "row",
          justifyContent: "space-between",
          style: {
            bottom: "0",
            filter: "blur(20px)",
            left: "0",
            position: "absolute",
            right: "0",
            top: "0",
            transform: "translate3d(0, 0, 0)"
          }
        },
        /* @__PURE__ */ $.createElement(
          ge,
          {
            style: {
              filter: "blur(100px)",
              marginLeft: -27,
              marginTop: -20,
              opacity: 0.6,
              transform: "translate3d(0, 0, 0)"
            }
          },
          /* @__PURE__ */ $.createElement(
            _o,
            {
              borderRadius: "full",
              height: "200",
              src: i,
              width: "200"
            }
          )
        ),
        /* @__PURE__ */ $.createElement(
          ge,
          {
            style: {
              filter: "blur(100px)",
              marginRight: 0,
              marginTop: 105,
              opacity: 0.6,
              overflow: "auto",
              transform: "translate3d(0, 0, 0)"
            }
          },
          /* @__PURE__ */ $.createElement(
            _o,
            {
              borderRadius: "full",
              height: "200",
              src: i,
              width: "200"
            }
          )
        )
      )
    ),
    !p && y && /* @__PURE__ */ $.createElement(
      ge,
      {
        background: "downloadBottomCardBackground",
        style: {
          bottom: "0",
          left: "0",
          position: "absolute",
          right: "0",
          top: "0"
        }
      },
      /* @__PURE__ */ $.createElement(
        ge,
        {
          position: "absolute",
          style: {
            background: `radial-gradient(50% 50% at 50% 50%, ${y[0]} 0%, ${y[1]} 25%, rgba(0,0,0,0) 100%)`,
            height: 564,
            left: -215,
            top: -197,
            transform: "translate3d(0, 0, 0)",
            width: 564
          }
        }
      ),
      /* @__PURE__ */ $.createElement(
        ge,
        {
          position: "absolute",
          style: {
            background: `radial-gradient(50% 50% at 50% 50%, ${y[2]} 0%, rgba(0, 0, 0, 0) 100%)`,
            height: 564,
            left: -1,
            top: -76,
            transform: "translate3d(0, 0, 0)",
            width: 564
          }
        }
      )
    ),
    /* @__PURE__ */ $.createElement(
      ge,
      {
        alignItems: "flex-start",
        display: "flex",
        flexDirection: "row",
        gap: "24",
        height: "max",
        justifyContent: "center",
        style: { zIndex: 1 }
      },
      /* @__PURE__ */ $.createElement(ge, null, /* @__PURE__ */ $.createElement(
        _o,
        {
          height: "60",
          src: i,
          width: "60",
          ...r ? {
            background: r,
            borderColor: "generalBorder",
            borderRadius: "10"
          } : null
        }
      )),
      /* @__PURE__ */ $.createElement(
        ge,
        {
          display: "flex",
          flexDirection: "column",
          gap: "4",
          style: { flex: 1 },
          width: "full"
        },
        /* @__PURE__ */ $.createElement(Yt, { color: "modalText", size: "14", weight: "bold" }, c),
        /* @__PURE__ */ $.createElement(Yt, { color: "modalTextSecondary", size: "14", weight: "medium" }, t),
        /* @__PURE__ */ $.createElement(ge, { marginTop: "14", width: "max" }, /* @__PURE__ */ $.createElement(
          is,
          {
            href: u,
            label: e,
            onClick: s,
            size: "medium"
          }
        ))
      )
    )
  );
};
function pEe({
  changeWalletStep: e,
  wallet: t
}) {
  const n = dP(), r = hP(), o = k.useContext(aA) === "compact", {
    desktop: s,
    desktopDownloadUrl: c,
    extension: u,
    extensionDownloadUrl: f,
    mobileDownloadUrl: p
  } = t, { i18n: y } = k.useContext(fo);
  return k.useEffect(() => {
    UG(), $G(), nEe(), Zxe();
  }, []), /* @__PURE__ */ $.createElement(
    ge,
    {
      alignItems: "center",
      display: "flex",
      flexDirection: "column",
      gap: "24",
      height: "full",
      marginBottom: "8",
      marginTop: "4",
      width: "full"
    },
    /* @__PURE__ */ $.createElement(
      ge,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        gap: "8",
        height: "full",
        justifyContent: "center",
        width: "full"
      },
      f && /* @__PURE__ */ $.createElement(
        DO,
        {
          actionLabel: y.t("get_options.extension.download.label", {
            browser: n
          }),
          description: y.t("get_options.extension.description"),
          iconUrl: qG,
          isCompact: o,
          onAction: () => e(
            u != null && u.instructions ? "INSTRUCTIONS_EXTENSION" : "CONNECT"
            /* Connect */
          ),
          title: y.t("get_options.extension.title", {
            wallet: t.name,
            browser: n
          }),
          url: f,
          variant: "browser"
        }
      ),
      c && /* @__PURE__ */ $.createElement(
        DO,
        {
          actionLabel: y.t("get_options.desktop.download.label", {
            platform: r
          }),
          description: y.t("get_options.desktop.description"),
          iconUrl: WG,
          isCompact: o,
          onAction: () => e(
            s != null && s.instructions ? "INSTRUCTIONS_DESKTOP" : "CONNECT"
            /* Connect */
          ),
          title: y.t("get_options.desktop.title", {
            wallet: t.name,
            platform: r
          }),
          url: c,
          variant: "desktop"
        }
      ),
      p && /* @__PURE__ */ $.createElement(
        DO,
        {
          actionLabel: y.t("get_options.mobile.download.label", {
            wallet: t.name
          }),
          description: y.t("get_options.mobile.description"),
          iconAccent: t.iconAccent,
          iconBackground: t.iconBackground,
          iconUrl: t.iconUrl,
          isCompact: o,
          onAction: () => {
            e(
              "DOWNLOAD"
              /* Download */
            );
          },
          title: y.t("get_options.mobile.title", { wallet: t.name }),
          variant: "app"
        }
      )
    )
  );
}
function mEe({
  changeWalletStep: e,
  wallet: t
}) {
  const { downloadUrls: n, qrCode: r } = t, { i18n: i } = k.useContext(fo);
  return k.useEffect(() => {
    UG(), $G();
  }, []), /* @__PURE__ */ $.createElement(
    ge,
    {
      alignItems: "center",
      display: "flex",
      flexDirection: "column",
      gap: "24",
      height: "full",
      width: "full"
    },
    /* @__PURE__ */ $.createElement(ge, { style: { maxWidth: 220, textAlign: "center" } }, /* @__PURE__ */ $.createElement(Yt, { color: "modalTextSecondary", size: "14", weight: "semibold" }, i.t("get_mobile.description"))),
    /* @__PURE__ */ $.createElement(ge, { height: "full" }, n != null && n.qrCode ? /* @__PURE__ */ $.createElement(HG, { logoSize: 0, size: 268, uri: n.qrCode }) : null),
    /* @__PURE__ */ $.createElement(
      ge,
      {
        alignItems: "center",
        borderRadius: "10",
        display: "flex",
        flexDirection: "row",
        gap: "8",
        height: "34",
        justifyContent: "space-between",
        marginBottom: "12",
        paddingY: "8"
      },
      /* @__PURE__ */ $.createElement(
        is,
        {
          label: i.t("get_mobile.continue.label"),
          onClick: () => e(
            r != null && r.instructions ? "INSTRUCTIONS_MOBILE" : "CONNECT"
            /* Connect */
          )
        }
      )
    )
  );
}
var qd = {
  connect: () => /* @__PURE__ */ $.createElement(eEe, null),
  create: () => /* @__PURE__ */ $.createElement(tEe, null),
  install: (e) => /* @__PURE__ */ $.createElement(
    _o,
    {
      background: e.iconBackground,
      borderColor: "generalBorder",
      borderRadius: "10",
      height: "48",
      src: e.iconUrl,
      width: "48"
    }
  ),
  refresh: () => /* @__PURE__ */ $.createElement(rEe, null),
  scan: () => /* @__PURE__ */ $.createElement(iEe, null)
};
function yEe({
  connectWallet: e,
  wallet: t
}) {
  var r, i, o, s;
  const { i18n: n } = k.useContext(fo);
  return /* @__PURE__ */ $.createElement(
    ge,
    {
      alignItems: "center",
      display: "flex",
      flexDirection: "column",
      height: "full",
      width: "full"
    },
    /* @__PURE__ */ $.createElement(
      ge,
      {
        display: "flex",
        flexDirection: "column",
        gap: "28",
        height: "full",
        justifyContent: "center",
        paddingY: "32",
        style: { maxWidth: 320 }
      },
      (i = (r = t == null ? void 0 : t.qrCode) == null ? void 0 : r.instructions) == null ? void 0 : i.steps.map((c, u) => {
        var f;
        return /* @__PURE__ */ $.createElement(
          ge,
          {
            alignItems: "center",
            display: "flex",
            flexDirection: "row",
            gap: "16",
            key: u
          },
          /* @__PURE__ */ $.createElement(
            ge,
            {
              borderRadius: "10",
              height: "48",
              minWidth: "48",
              overflow: "hidden",
              position: "relative",
              width: "48"
            },
            (f = qd[c.step]) == null ? void 0 : f.call(qd, t)
          ),
          /* @__PURE__ */ $.createElement(ge, { display: "flex", flexDirection: "column", gap: "4" }, /* @__PURE__ */ $.createElement(Yt, { color: "modalText", size: "14", weight: "bold" }, n.t(c.title, void 0, {
            rawKeyIfTranslationMissing: !0
          })), /* @__PURE__ */ $.createElement(Yt, { color: "modalTextSecondary", size: "14", weight: "medium" }, n.t(c.description, void 0, {
            rawKeyIfTranslationMissing: !0
          })))
        );
      })
    ),
    /* @__PURE__ */ $.createElement(
      ge,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        gap: "12",
        justifyContent: "center",
        marginBottom: "16"
      },
      /* @__PURE__ */ $.createElement(
        is,
        {
          label: n.t("get_instructions.mobile.connect.label"),
          onClick: () => e(t)
        }
      ),
      /* @__PURE__ */ $.createElement(
        ge,
        {
          as: "a",
          className: ao({ active: "shrink", hover: "grow" }),
          display: "block",
          href: (s = (o = t == null ? void 0 : t.qrCode) == null ? void 0 : o.instructions) == null ? void 0 : s.learnMoreUrl,
          paddingX: "12",
          paddingY: "4",
          rel: "noreferrer",
          style: { willChange: "transform" },
          target: "_blank",
          transition: "default"
        },
        /* @__PURE__ */ $.createElement(Yt, { color: "accentColor", size: "14", weight: "bold" }, n.t("get_instructions.mobile.learn_more.label"))
      )
    )
  );
}
function vEe({
  wallet: e
}) {
  var n, r, i, o;
  const { i18n: t } = k.useContext(fo);
  return /* @__PURE__ */ $.createElement(
    ge,
    {
      alignItems: "center",
      display: "flex",
      flexDirection: "column",
      height: "full",
      width: "full"
    },
    /* @__PURE__ */ $.createElement(
      ge,
      {
        display: "flex",
        flexDirection: "column",
        gap: "28",
        height: "full",
        justifyContent: "center",
        paddingY: "32",
        style: { maxWidth: 320 }
      },
      (r = (n = e == null ? void 0 : e.extension) == null ? void 0 : n.instructions) == null ? void 0 : r.steps.map((s, c) => {
        var u;
        return /* @__PURE__ */ $.createElement(
          ge,
          {
            alignItems: "center",
            display: "flex",
            flexDirection: "row",
            gap: "16",
            key: c
          },
          /* @__PURE__ */ $.createElement(
            ge,
            {
              borderRadius: "10",
              height: "48",
              minWidth: "48",
              overflow: "hidden",
              position: "relative",
              width: "48"
            },
            (u = qd[s.step]) == null ? void 0 : u.call(qd, e)
          ),
          /* @__PURE__ */ $.createElement(ge, { display: "flex", flexDirection: "column", gap: "4" }, /* @__PURE__ */ $.createElement(Yt, { color: "modalText", size: "14", weight: "bold" }, t.t(s.title, void 0, {
            rawKeyIfTranslationMissing: !0
          })), /* @__PURE__ */ $.createElement(Yt, { color: "modalTextSecondary", size: "14", weight: "medium" }, t.t(s.description, void 0, {
            rawKeyIfTranslationMissing: !0
          })))
        );
      })
    ),
    /* @__PURE__ */ $.createElement(
      ge,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        gap: "12",
        justifyContent: "center",
        marginBottom: "16"
      },
      /* @__PURE__ */ $.createElement(
        is,
        {
          label: t.t("get_instructions.extension.refresh.label"),
          onClick: window.location.reload.bind(window.location)
        }
      ),
      /* @__PURE__ */ $.createElement(
        ge,
        {
          as: "a",
          className: ao({ active: "shrink", hover: "grow" }),
          display: "block",
          href: (o = (i = e == null ? void 0 : e.extension) == null ? void 0 : i.instructions) == null ? void 0 : o.learnMoreUrl,
          paddingX: "12",
          paddingY: "4",
          rel: "noreferrer",
          style: { willChange: "transform" },
          target: "_blank",
          transition: "default"
        },
        /* @__PURE__ */ $.createElement(Yt, { color: "accentColor", size: "14", weight: "bold" }, t.t("get_instructions.extension.learn_more.label"))
      )
    )
  );
}
function gEe({
  connectWallet: e,
  wallet: t
}) {
  var r, i, o, s;
  const { i18n: n } = k.useContext(fo);
  return /* @__PURE__ */ $.createElement(
    ge,
    {
      alignItems: "center",
      display: "flex",
      flexDirection: "column",
      height: "full",
      width: "full"
    },
    /* @__PURE__ */ $.createElement(
      ge,
      {
        display: "flex",
        flexDirection: "column",
        gap: "28",
        height: "full",
        justifyContent: "center",
        paddingY: "32",
        style: { maxWidth: 320 }
      },
      (i = (r = t == null ? void 0 : t.desktop) == null ? void 0 : r.instructions) == null ? void 0 : i.steps.map((c, u) => {
        var f;
        return /* @__PURE__ */ $.createElement(
          ge,
          {
            alignItems: "center",
            display: "flex",
            flexDirection: "row",
            gap: "16",
            key: u
          },
          /* @__PURE__ */ $.createElement(
            ge,
            {
              borderRadius: "10",
              height: "48",
              minWidth: "48",
              overflow: "hidden",
              position: "relative",
              width: "48"
            },
            (f = qd[c.step]) == null ? void 0 : f.call(qd, t)
          ),
          /* @__PURE__ */ $.createElement(ge, { display: "flex", flexDirection: "column", gap: "4" }, /* @__PURE__ */ $.createElement(Yt, { color: "modalText", size: "14", weight: "bold" }, n.t(c.title, void 0, {
            rawKeyIfTranslationMissing: !0
          })), /* @__PURE__ */ $.createElement(Yt, { color: "modalTextSecondary", size: "14", weight: "medium" }, n.t(c.description, void 0, {
            rawKeyIfTranslationMissing: !0
          })))
        );
      })
    ),
    /* @__PURE__ */ $.createElement(
      ge,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        gap: "12",
        justifyContent: "center",
        marginBottom: "16"
      },
      /* @__PURE__ */ $.createElement(
        is,
        {
          label: n.t("get_instructions.desktop.connect.label"),
          onClick: () => e(t)
        }
      ),
      /* @__PURE__ */ $.createElement(
        ge,
        {
          as: "a",
          className: ao({ active: "shrink", hover: "grow" }),
          display: "block",
          href: (s = (o = t == null ? void 0 : t.desktop) == null ? void 0 : o.instructions) == null ? void 0 : s.learnMoreUrl,
          paddingX: "12",
          paddingY: "4",
          rel: "noreferrer",
          style: { willChange: "transform" },
          target: "_blank",
          transition: "default"
        },
        /* @__PURE__ */ $.createElement(Yt, { color: "accentColor", size: "14", weight: "bold" }, n.t("get_instructions.desktop.learn_more.label"))
      )
    )
  );
}
function bEe({ onClose: e }) {
  const t = "rk_connect_title", [n, r] = k.useState(), [i, o] = k.useState(), [s, c] = k.useState(), u = !!(i != null && i.qrCode) && s, [f, p] = k.useState(!1), v = k.useContext(aA) === nx.COMPACT, { disclaimer: w } = k.useContext(ex), { i18n: C } = k.useContext(fo), x = uP(), A = k.useRef(!1), { connector: R } = k.useContext(tx), D = sA(!R).filter((Ee) => Ee.ready || !!Ee.extensionDownloadUrl).sort((Ee, Se) => Ee.groupIndex - Se.groupIndex), M = $xe(D, (Ee) => Ee.groupName), L = [
    "Recommended",
    "Other",
    "Popular",
    "More",
    "Others",
    "Installed"
  ];
  k.useEffect(() => {
    R && !A.current && (Y(
      "CONNECT"
      /* Connect */
    ), z(R), A.current = !0);
  }, [R]);
  const j = (Ee) => {
    var Se, Me;
    p(!1), Ee.ready && ((Me = (Se = Ee == null ? void 0 : Ee.connect) == null ? void 0 : Se.call(Ee)) == null || Me.catch(() => {
      p(!0);
    }));
  }, F = async (Ee) => {
    const Se = D.find((Me) => Ee.id === Me.id);
    Se != null && Se.getDesktopUri && setTimeout(async () => {
      var Fe;
      const Me = await ((Fe = Se == null ? void 0 : Se.getDesktopUri) == null ? void 0 : Fe.call(Se));
      Me && window.open(Me, x ? "_blank" : "_self");
    }, 0);
  }, O = async (Ee) => {
    var Fe;
    const Se = D.find((st) => Ee.id === st.id), Me = await ((Fe = Se == null ? void 0 : Se.getQrCodeUri) == null ? void 0 : Fe.call(Se));
    c(Me), setTimeout(
      () => {
        o(Se), Y(
          "CONNECT"
          /* Connect */
        );
      },
      Me ? 0 : 50
    );
  }, z = async (Ee) => {
    Qxe(Ee.id), Ee.ready && (O(Ee), F(Ee)), j(Ee), r(Ee.id), Ee.ready || (o(Ee), Y(
      Ee != null && Ee.extensionDownloadUrl ? "DOWNLOAD_OPTIONS" : "CONNECT"
      /* Connect */
    ));
  }, H = (Ee) => {
    var mt;
    r(Ee);
    const Se = D.find((yt) => Ee === yt.id), Me = (mt = Se == null ? void 0 : Se.downloadUrls) == null ? void 0 : mt.qrCode, Fe = !!(Se != null && Se.desktopDownloadUrl), st = !!(Se != null && Se.extensionDownloadUrl);
    o(Se), Y(
      Me && (st || Fe) ? "DOWNLOAD_OPTIONS" : Me ? "DOWNLOAD" : Fe ? "INSTRUCTIONS_DESKTOP" : "INSTRUCTIONS_EXTENSION"
      /* DownloadOptions */
    );
  }, Q = () => {
    r(void 0), o(void 0), c(void 0);
  }, Y = (Ee, Se = !1) => {
    Se && Ee === "GET" && ee === "GET" ? Q() : !Se && Ee === "GET" ? ie(
      "GET"
      /* Get */
    ) : !Se && Ee === "CONNECT" && ie(
      "CONNECT"
      /* Connect */
    ), Z(Ee);
  }, [ee, ie] = k.useState(
    "NONE"
    /* None */
  ), [X, Z] = k.useState(
    "NONE"
    /* None */
  );
  let J = null, K = null, oe = null, be;
  k.useEffect(() => {
    p(!1);
  }, [X, i]);
  const pe = !!(!!(i != null && i.extensionDownloadUrl) && (i != null && i.mobileDownloadUrl));
  switch (X) {
    case "NONE":
      J = /* @__PURE__ */ $.createElement(PU, { getWallet: () => Y(
        "GET"
        /* Get */
      ) });
      break;
    case "LEARN_COMPACT":
      J = /* @__PURE__ */ $.createElement(
        PU,
        {
          compactModeEnabled: v,
          getWallet: () => Y(
            "GET"
            /* Get */
          )
        }
      ), K = C.t("intro.title"), oe = "NONE";
      break;
    case "GET":
      J = /* @__PURE__ */ $.createElement(
        fEe,
        {
          getWalletDownload: H,
          compactModeEnabled: v
        }
      ), K = C.t("get.title"), oe = v ? "LEARN_COMPACT" : "NONE";
      break;
    case "CONNECT":
      J = i && /* @__PURE__ */ $.createElement(
        hEe,
        {
          changeWalletStep: Y,
          compactModeEnabled: v,
          connectionError: f,
          onClose: e,
          qrCodeUri: s,
          reconnect: j,
          wallet: i
        }
      ), K = u && (i.name === "WalletConnect" ? C.t("connect_scan.fallback_title") : C.t("connect_scan.title", {
        wallet: i.name
      })), oe = v ? R ? null : "NONE" : null, be = v ? R ? () => {
      } : Q : () => {
      };
      break;
    case "DOWNLOAD_OPTIONS":
      J = i && /* @__PURE__ */ $.createElement(
        pEe,
        {
          changeWalletStep: Y,
          wallet: i
        }
      ), K = i && C.t("get_options.short_title", { wallet: i.name }), oe = R ? "CONNECT" : v ? "NONE" : null;
      break;
    case "DOWNLOAD":
      J = i && /* @__PURE__ */ $.createElement(
        mEe,
        {
          changeWalletStep: Y,
          wallet: i
        }
      ), K = i && C.t("get_mobile.title", { wallet: i.name }), oe = pe ? "DOWNLOAD_OPTIONS" : ee;
      break;
    case "INSTRUCTIONS_MOBILE":
      J = i && /* @__PURE__ */ $.createElement(
        yEe,
        {
          connectWallet: z,
          wallet: i
        }
      ), K = i && C.t("get_options.title", {
        wallet: v && i.shortName || i.name
      }), oe = "DOWNLOAD";
      break;
    case "INSTRUCTIONS_EXTENSION":
      J = i && /* @__PURE__ */ $.createElement(vEe, { wallet: i }), K = i && C.t("get_options.title", {
        wallet: v && i.shortName || i.name
      }), oe = "DOWNLOAD_OPTIONS";
      break;
    case "INSTRUCTIONS_DESKTOP":
      J = i && /* @__PURE__ */ $.createElement(
        gEe,
        {
          connectWallet: z,
          wallet: i
        }
      ), K = i && C.t("get_options.title", {
        wallet: v && i.shortName || i.name
      }), oe = "DOWNLOAD_OPTIONS";
      break;
  }
  return /* @__PURE__ */ $.createElement(
    ge,
    {
      display: "flex",
      flexDirection: "row",
      style: { maxHeight: v ? 468 : 504 }
    },
    (v ? X === "NONE" : !0) && /* @__PURE__ */ $.createElement(
      ge,
      {
        className: v ? lEe : sEe,
        display: "flex",
        flexDirection: "column",
        marginTop: "16"
      },
      /* @__PURE__ */ $.createElement(ge, { display: "flex", justifyContent: "space-between" }, v && w && /* @__PURE__ */ $.createElement(ge, { marginLeft: "16", width: "28" }, /* @__PURE__ */ $.createElement(
        qxe,
        {
          onClick: () => Y(
            "LEARN_COMPACT"
            /* LearnCompact */
          )
        }
      )), v && !w && /* @__PURE__ */ $.createElement(ge, { marginLeft: "16", width: "28" }), /* @__PURE__ */ $.createElement(
        ge,
        {
          marginLeft: v ? "0" : "6",
          paddingBottom: "8",
          paddingTop: "2",
          paddingX: "18"
        },
        /* @__PURE__ */ $.createElement(
          Yt,
          {
            as: "h1",
            color: "modalText",
            id: t,
            size: "18",
            weight: "heavy",
            testId: "connect-header-label"
          },
          C.t("connect.title")
        )
      ), v && /* @__PURE__ */ $.createElement(ge, { marginRight: "16" }, /* @__PURE__ */ $.createElement(ey, { onClose: e }))),
      /* @__PURE__ */ $.createElement(ge, { className: aEe, paddingBottom: "18" }, Object.entries(M).map(
        ([Ee, Se], Me) => Se.length > 0 && /* @__PURE__ */ $.createElement(k.Fragment, { key: Me }, Ee ? /* @__PURE__ */ $.createElement(ge, { marginBottom: "8", marginTop: "16", marginX: "6" }, /* @__PURE__ */ $.createElement(
          Yt,
          {
            color: Ee === "Installed" ? "accentColor" : "modalTextSecondary",
            size: "14",
            weight: "bold"
          },
          L.includes(Ee) ? C.t(
            `connector_group.${Ee.toLowerCase()}`
          ) : Ee
        )) : null, /* @__PURE__ */ $.createElement(ge, { display: "flex", flexDirection: "column", gap: "4" }, Se.map((Fe) => /* @__PURE__ */ $.createElement(
          LG,
          {
            currentlySelected: Fe.id === n,
            iconBackground: Fe.iconBackground,
            iconUrl: Fe.iconUrl,
            key: Fe.id,
            name: Fe.name,
            onClick: () => z(Fe),
            ready: Fe.ready,
            recent: Fe.recent,
            testId: `wallet-option-${Fe.id}`,
            isRainbowKitConnector: Fe.isRainbowKitConnector
          }
        ))))
      )),
      v && /* @__PURE__ */ $.createElement($.Fragment, null, /* @__PURE__ */ $.createElement(ge, { background: "generalBorder", height: "1", marginTop: "-1" }), w ? /* @__PURE__ */ $.createElement(ge, { paddingX: "24", paddingY: "16", textAlign: "center" }, /* @__PURE__ */ $.createElement(w, { Link: pP, Text: mP })) : /* @__PURE__ */ $.createElement(
        ge,
        {
          alignItems: "center",
          display: "flex",
          justifyContent: "space-between",
          paddingX: "24",
          paddingY: "16"
        },
        /* @__PURE__ */ $.createElement(ge, { paddingY: "4" }, /* @__PURE__ */ $.createElement(Yt, { color: "modalTextSecondary", size: "14", weight: "medium" }, C.t("connect.new_to_ethereum.description"))),
        /* @__PURE__ */ $.createElement(
          ge,
          {
            alignItems: "center",
            display: "flex",
            flexDirection: "row",
            gap: "4",
            justifyContent: "center"
          },
          /* @__PURE__ */ $.createElement(
            ge,
            {
              className: ao({
                active: "shrink",
                hover: "grow"
              }),
              cursor: "pointer",
              onClick: () => Y(
                "LEARN_COMPACT"
                /* LearnCompact */
              ),
              paddingY: "4",
              style: { willChange: "transform" },
              transition: "default"
            },
            /* @__PURE__ */ $.createElement(Yt, { color: "accentColor", size: "14", weight: "bold" }, C.t("connect.new_to_ethereum.learn_more.label"))
          )
        )
      ))
    ),
    (v ? X !== "NONE" : !0) && /* @__PURE__ */ $.createElement($.Fragment, null, !v && /* @__PURE__ */ $.createElement(ge, { background: "generalBorder", minWidth: "1", width: "1" }), /* @__PURE__ */ $.createElement(
      ge,
      {
        display: "flex",
        flexDirection: "column",
        margin: "16",
        style: { flexGrow: 1 }
      },
      /* @__PURE__ */ $.createElement(
        ge,
        {
          alignItems: "center",
          display: "flex",
          justifyContent: "space-between",
          marginBottom: "12"
        },
        /* @__PURE__ */ $.createElement(ge, { width: "28" }, oe && /* @__PURE__ */ $.createElement(
          ge,
          {
            as: "button",
            className: ao({
              active: "shrinkSm",
              hover: "growLg"
            }),
            color: "accentColor",
            onClick: () => {
              oe && Y(oe, !0), be == null || be();
            },
            paddingX: "8",
            paddingY: "4",
            style: {
              boxSizing: "content-box",
              height: 17,
              willChange: "transform"
            },
            transition: "default",
            type: "button"
          },
          /* @__PURE__ */ $.createElement(NG, null)
        )),
        /* @__PURE__ */ $.createElement(
          ge,
          {
            display: "flex",
            justifyContent: "center",
            style: { flexGrow: 1 }
          },
          K && /* @__PURE__ */ $.createElement(
            Yt,
            {
              color: "modalText",
              size: "18",
              textAlign: "center",
              weight: "heavy"
            },
            K
          )
        ),
        /* @__PURE__ */ $.createElement(ey, { onClose: e })
      ),
      /* @__PURE__ */ $.createElement(
        ge,
        {
          display: "flex",
          flexDirection: "column",
          style: { minHeight: v ? 396 : 432 }
        },
        /* @__PURE__ */ $.createElement(
          ge,
          {
            alignItems: "center",
            display: "flex",
            flexDirection: "column",
            gap: "6",
            height: "full",
            justifyContent: "center",
            marginX: "8"
          },
          J
        )
      )
    ))
  );
}
var wEe = "_1fcvq812", CEe = "_1fcvq810", xEe = "_1fcvq813", EEe = ({ wallet: e }) => /* @__PURE__ */ $.createElement("svg", { className: xEe, viewBox: "0 0 86 86", width: "86", height: "86" }, /* @__PURE__ */ $.createElement("title", null, "Loading"), /* @__PURE__ */ $.createElement(
  "rect",
  {
    x: "3",
    y: "3",
    width: 80,
    height: 80,
    rx: 20,
    ry: 20,
    strokeDasharray: `${160 / 3} ${2 * 160 / 3}`,
    strokeDashoffset: 160,
    className: wEe,
    style: {
      // Prop style passing works only in `@vanilla-extract/recipes`.
      // Instead downloading packages we can do this
      // manually without passing props
      stroke: (e == null ? void 0 : e.iconAccent) || "#0D3887"
    }
  }
));
function GG({
  onClose: e,
  wallet: t,
  connecting: n
}) {
  const {
    connect: r,
    iconBackground: i,
    iconUrl: o,
    id: s,
    name: c,
    getMobileUri: u,
    ready: f,
    shortName: p,
    showWalletConnectModal: y
  } = t, v = BG(o), w = k.useRef(!1), { i18n: C } = k.useContext(fo), x = k.useCallback(async () => {
    if (s !== "walletConnect" && (async () => {
      const R = await (u == null ? void 0 : u());
      if (R)
        if (R && axe({ mobileUri: R, name: c }), R.startsWith("http")) {
          const I = document.createElement("a");
          I.href = R, I.target = "_blank", I.rel = "noreferrer noopener", I.click();
        } else
          window.location.href = R;
    })(), y) {
      y(), e == null || e();
      return;
    }
    r == null || r();
  }, [r, u, y, e, c, s]);
  return k.useEffect(() => {
    n && !w.current && (x(), w.current = !0);
  }, [n, x]), /* @__PURE__ */ $.createElement(
    ge,
    {
      as: "button",
      color: f ? "modalText" : "modalTextSecondary",
      disabled: !f,
      fontFamily: "body",
      key: s,
      onClick: x,
      ref: v,
      style: { overflow: "visible", textAlign: "center" },
      testId: `wallet-option-${s}`,
      type: "button",
      width: "full"
    },
    /* @__PURE__ */ $.createElement(
      ge,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        justifyContent: "center"
      },
      /* @__PURE__ */ $.createElement(
        ge,
        {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          paddingBottom: "8",
          paddingTop: "10",
          position: "relative"
        },
        n ? /* @__PURE__ */ $.createElement(EEe, { wallet: t }) : null,
        /* @__PURE__ */ $.createElement(
          _o,
          {
            background: i,
            borderRadius: "13",
            boxShadow: "walletLogo",
            height: "60",
            src: o,
            width: "60"
          }
        )
      ),
      n ? null : /* @__PURE__ */ $.createElement(ge, { display: "flex", flexDirection: "column", textAlign: "center" }, /* @__PURE__ */ $.createElement(
        Yt,
        {
          as: "h2",
          color: t.ready ? "modalText" : "modalTextSecondary",
          size: "13",
          weight: "medium"
        },
        /* @__PURE__ */ $.createElement(ge, { as: "span", position: "relative" }, p ?? c, !t.ready && " (unsupported)")
      ), t.recent && /* @__PURE__ */ $.createElement(Yt, { color: "accentColor", size: "12", weight: "medium" }, C.t("connect.recent")))
    )
  );
}
function SEe({ onClose: e }) {
  var w;
  const t = "rk_connect_title", n = sA().filter(
    (C) => C.isRainbowKitConnector
  ), { disclaimer: r, learnMoreUrl: i } = k.useContext(ex);
  let o = null, s = null, c = !1, u = null;
  const [f, p] = k.useState(
    "CONNECT"
    /* Connect */
  ), { i18n: y } = k.useContext(fo), v = oA();
  switch (f) {
    case "CONNECT": {
      o = y.t("connect.title"), c = !0, s = /* @__PURE__ */ $.createElement(ge, null, /* @__PURE__ */ $.createElement(
        ge,
        {
          background: "profileForeground",
          className: CEe,
          display: "flex",
          paddingBottom: "20",
          paddingTop: "6"
        },
        /* @__PURE__ */ $.createElement(ge, { display: "flex", style: { margin: "0 auto" } }, n.filter((C) => C.ready).map((C) => /* @__PURE__ */ $.createElement(ge, { key: C.id, paddingX: "20" }, /* @__PURE__ */ $.createElement(ge, { width: "60" }, /* @__PURE__ */ $.createElement(GG, { onClose: e, wallet: C })))))
      ), /* @__PURE__ */ $.createElement(
        ge,
        {
          background: "generalBorder",
          height: "1",
          marginBottom: "32",
          marginTop: "-1"
        }
      ), /* @__PURE__ */ $.createElement(
        ge,
        {
          alignItems: "center",
          display: "flex",
          flexDirection: "column",
          gap: "32",
          paddingX: "32",
          style: { textAlign: "center" }
        },
        /* @__PURE__ */ $.createElement(
          ge,
          {
            display: "flex",
            flexDirection: "column",
            gap: "8",
            textAlign: "center"
          },
          /* @__PURE__ */ $.createElement(Yt, { color: "modalText", size: "16", weight: "bold" }, y.t("intro.title")),
          /* @__PURE__ */ $.createElement(Yt, { color: "modalTextSecondary", size: "16" }, y.t("intro.description"))
        )
      ), /* @__PURE__ */ $.createElement(ge, { paddingTop: "32", paddingX: "20" }, /* @__PURE__ */ $.createElement(ge, { display: "flex", gap: "14", justifyContent: "center" }, /* @__PURE__ */ $.createElement(
        is,
        {
          label: y.t("intro.get.label"),
          onClick: () => p(
            "GET"
            /* Get */
          ),
          size: "large",
          type: "secondary"
        }
      ), /* @__PURE__ */ $.createElement(
        is,
        {
          href: i,
          label: y.t("intro.learn_more.label"),
          size: "large",
          type: "secondary"
        }
      ))), r && /* @__PURE__ */ $.createElement(ge, { marginTop: "28", marginX: "32", textAlign: "center" }, /* @__PURE__ */ $.createElement(r, { Link: pP, Text: mP })));
      break;
    }
    case "GET": {
      o = y.t("get.title"), u = "CONNECT";
      const C = (w = n == null ? void 0 : n.filter(
        (x) => {
          var A, R, I;
          return ((A = x.downloadUrls) == null ? void 0 : A.ios) || ((R = x.downloadUrls) == null ? void 0 : R.android) || ((I = x.downloadUrls) == null ? void 0 : I.mobile);
        }
      )) == null ? void 0 : w.splice(0, 3);
      s = /* @__PURE__ */ $.createElement(ge, null, /* @__PURE__ */ $.createElement(
        ge,
        {
          alignItems: "center",
          display: "flex",
          flexDirection: "column",
          height: "full",
          marginBottom: "36",
          marginTop: "5",
          paddingTop: "12",
          width: "full"
        },
        C.map((x, A) => {
          const { downloadUrls: R, iconBackground: I, iconUrl: D, name: M } = x;
          return !(R != null && R.ios) && !(R != null && R.android) && !(R != null && R.mobile) ? null : /* @__PURE__ */ $.createElement(
            ge,
            {
              display: "flex",
              gap: "16",
              key: x.id,
              paddingX: "20",
              width: "full"
            },
            /* @__PURE__ */ $.createElement(ge, { style: { minHeight: 48, minWidth: 48 } }, /* @__PURE__ */ $.createElement(
              _o,
              {
                background: I,
                borderColor: "generalBorder",
                borderRadius: "10",
                height: "48",
                src: D,
                width: "48"
              }
            )),
            /* @__PURE__ */ $.createElement(ge, { display: "flex", flexDirection: "column", width: "full" }, /* @__PURE__ */ $.createElement(ge, { alignItems: "center", display: "flex", height: "48" }, /* @__PURE__ */ $.createElement(ge, { width: "full" }, /* @__PURE__ */ $.createElement(Yt, { color: "modalText", size: "18", weight: "bold" }, M)), /* @__PURE__ */ $.createElement(
              is,
              {
                href: (v ? R == null ? void 0 : R.ios : R == null ? void 0 : R.android) || (R == null ? void 0 : R.mobile),
                label: y.t("get.action.label"),
                size: "small",
                type: "secondary"
              }
            )), A < C.length - 1 && /* @__PURE__ */ $.createElement(
              ge,
              {
                background: "generalBorderDim",
                height: "1",
                marginY: "10",
                width: "full"
              }
            ))
          );
        })
      ), /* @__PURE__ */ $.createElement(ge, { style: { marginBottom: "42px" } }), /* @__PURE__ */ $.createElement(
        ge,
        {
          alignItems: "center",
          display: "flex",
          flexDirection: "column",
          gap: "36",
          paddingX: "36",
          style: { textAlign: "center" }
        },
        /* @__PURE__ */ $.createElement(
          ge,
          {
            display: "flex",
            flexDirection: "column",
            gap: "12",
            textAlign: "center"
          },
          /* @__PURE__ */ $.createElement(Yt, { color: "modalText", size: "16", weight: "bold" }, y.t("get.looking_for.title")),
          /* @__PURE__ */ $.createElement(Yt, { color: "modalTextSecondary", size: "16" }, y.t("get.looking_for.mobile.description"))
        )
      ));
      break;
    }
  }
  return /* @__PURE__ */ $.createElement(ge, { display: "flex", flexDirection: "column", paddingBottom: "36" }, /* @__PURE__ */ $.createElement(
    ge,
    {
      background: c ? "profileForeground" : "modalBackground",
      display: "flex",
      flexDirection: "column",
      paddingBottom: "4",
      paddingTop: "14"
    },
    /* @__PURE__ */ $.createElement(
      ge,
      {
        display: "flex",
        justifyContent: "center",
        paddingBottom: "6",
        paddingX: "20",
        position: "relative"
      },
      u && /* @__PURE__ */ $.createElement(
        ge,
        {
          display: "flex",
          position: "absolute",
          style: {
            left: 0,
            marginBottom: -20,
            marginTop: -20
          }
        },
        /* @__PURE__ */ $.createElement(
          ge,
          {
            alignItems: "center",
            as: "button",
            className: ao({
              active: "shrinkSm",
              hover: "growLg"
            }),
            color: "accentColor",
            display: "flex",
            marginLeft: "4",
            marginTop: "20",
            onClick: () => p(u),
            padding: "16",
            style: { height: 17, willChange: "transform" },
            transition: "default",
            type: "button"
          },
          /* @__PURE__ */ $.createElement(NG, null)
        )
      ),
      /* @__PURE__ */ $.createElement(ge, { marginTop: "4", textAlign: "center", width: "full" }, /* @__PURE__ */ $.createElement(
        Yt,
        {
          as: "h1",
          color: "modalText",
          id: t,
          size: "20",
          weight: "bold"
        },
        o
      )),
      /* @__PURE__ */ $.createElement(
        ge,
        {
          alignItems: "center",
          display: "flex",
          height: "32",
          paddingRight: "14",
          position: "absolute",
          right: "0"
        },
        /* @__PURE__ */ $.createElement(
          ge,
          {
            style: { marginBottom: -20, marginTop: -20 }
          },
          /* @__PURE__ */ $.createElement(ey, { onClose: e })
        )
      )
    )
  ), /* @__PURE__ */ $.createElement(ge, { display: "flex", flexDirection: "column" }, s));
}
var kEe = ({ onClose: e }) => {
  const { connector: t } = k.useContext(tx), { i18n: n } = k.useContext(fo), r = (t == null ? void 0 : t.name) || "";
  return /* @__PURE__ */ $.createElement(ge, null, /* @__PURE__ */ $.createElement(
    ge,
    {
      display: "flex",
      paddingBottom: "32",
      justifyContent: "center",
      alignItems: "center",
      background: "profileForeground",
      flexDirection: "column"
    },
    /* @__PURE__ */ $.createElement(
      ge,
      {
        width: "full",
        display: "flex",
        justifyContent: "flex-end",
        marginTop: "18",
        marginRight: "24"
      },
      /* @__PURE__ */ $.createElement(ey, { onClose: e })
    ),
    /* @__PURE__ */ $.createElement(ge, { width: "60" }, /* @__PURE__ */ $.createElement(GG, { onClose: e, wallet: t, connecting: !0 })),
    /* @__PURE__ */ $.createElement(ge, { marginTop: "20" }, /* @__PURE__ */ $.createElement(
      Yt,
      {
        textAlign: "center",
        color: "modalText",
        size: "18",
        weight: "semibold"
      },
      n.t("connect.status.connect_mobile", {
        wallet: r
      })
    )),
    /* @__PURE__ */ $.createElement(ge, { maxWidth: "full", marginTop: "8" }, /* @__PURE__ */ $.createElement(Yt, { textAlign: "center", color: "modalText", size: "16", weight: "medium" }, n.t("connect.status.confirm_mobile", {
      wallet: r
    })))
  ));
};
function AEe({ onClose: e }) {
  const { connector: t } = k.useContext(tx);
  return aa() ? t ? /* @__PURE__ */ $.createElement(kEe, { onClose: e }) : /* @__PURE__ */ $.createElement(SEe, { onClose: e }) : /* @__PURE__ */ $.createElement(bEe, { onClose: e });
}
function TEe({ onClose: e, open: t, dialogRoot: n }) {
  const r = "rk_connect_title", i = oP(), { disconnect: o } = Y8(), { isConnecting: s } = os(), c = $.useCallback(() => {
    e(), o();
  }, [e, o]), u = $.useCallback(() => {
    s && o(), e();
  }, [e, o, s]);
  return i === "disconnected" ? /* @__PURE__ */ $.createElement(
    q4,
    {
      dialogRoot: n,
      onClose: u,
      open: t,
      titleId: r
    },
    /* @__PURE__ */ $.createElement(W4, { bottomSheetOnMobile: !0, padding: "0", wide: !0 }, /* @__PURE__ */ $.createElement(AEe, { onClose: u }))
  ) : i === "unauthenticated" ? /* @__PURE__ */ $.createElement(
    q4,
    {
      dialogRoot: n,
      onClose: c,
      open: t,
      titleId: r
    },
    /* @__PURE__ */ $.createElement(W4, { bottomSheetOnMobile: !0, padding: "0" }, /* @__PURE__ */ $.createElement(ixe, { onClose: c, onCloseModal: e }))
  ) : null;
}
function MO() {
  const [e, t] = k.useState(!1);
  return {
    closeModal: k.useCallback(() => t(!1), []),
    isModalOpen: e,
    openModal: k.useCallback(() => t(!0), [])
  };
}
var zb = k.createContext({
  accountModalOpen: !1,
  chainModalOpen: !1,
  connectModalOpen: !1,
  closeAccountModal: () => {
  },
  closeChainModal: () => {
  },
  closeConnectModal: () => {
  },
  isWalletConnectModalOpen: !1,
  setIsWalletConnectModalOpen: () => {
  }
});
function _Ee({
  children: e,
  dialogRoot: t,
  hideDisconnect: n
}) {
  const {
    closeModal: r,
    isModalOpen: i,
    openModal: o
  } = MO(), {
    closeModal: s,
    isModalOpen: c,
    openModal: u
  } = MO(), {
    closeModal: f,
    isModalOpen: p,
    openModal: y
  } = MO(), [v, w] = k.useState(!1), C = oP(), { chainId: x } = os(), { chains: A } = Ho(), R = A.some((M) => M.id === x);
  function I({
    keepConnectModalOpen: M = !1
  } = {}) {
    M || r(), s(), f();
  }
  const D = iA() === "unauthenticated";
  return tW({
    onConnect: () => I({ keepConnectModalOpen: D }),
    onDisconnect: () => I()
  }), k.useEffect(() => {
    D && I();
  }, [D]), /* @__PURE__ */ $.createElement(
    zb.Provider,
    {
      value: k.useMemo(
        () => ({
          accountModalOpen: c,
          chainModalOpen: p,
          connectModalOpen: i,
          closeConnectModal: r,
          closeAccountModal: s,
          closeChainModal: f,
          isWalletConnectModalOpen: v,
          openAccountModal: R && C === "connected" ? u : void 0,
          openChainModal: C === "connected" ? y : void 0,
          openConnectModal: C === "disconnected" || C === "unauthenticated" ? o : void 0,
          setIsWalletConnectModalOpen: w
        }),
        [
          C,
          c,
          p,
          i,
          u,
          y,
          o,
          r,
          s,
          f,
          R,
          v
        ]
      )
    },
    e,
    /* @__PURE__ */ $.createElement(
      TEe,
      {
        dialogRoot: t,
        onClose: r,
        open: i
      }
    ),
    /* @__PURE__ */ $.createElement(
      Bxe,
      {
        dialogRoot: t,
        onClose: s,
        open: c,
        hideDisconnect: n
      }
    ),
    /* @__PURE__ */ $.createElement(
      Vxe,
      {
        dialogRoot: t,
        onClose: f,
        open: p
      }
    )
  );
}
function REe() {
  const { accountModalOpen: e, chainModalOpen: t, connectModalOpen: n } = k.useContext(zb);
  return {
    accountModalOpen: e,
    chainModalOpen: t,
    connectModalOpen: n
  };
}
function OEe() {
  const { accountModalOpen: e, openAccountModal: t, closeAccountModal: n } = k.useContext(zb);
  return { accountModalOpen: e, openAccountModal: t, closeAccountModal: n };
}
function KG() {
  const { chainModalOpen: e, openChainModal: t, closeChainModal: n } = k.useContext(zb);
  return { chainModalOpen: e, openChainModal: t, closeChainModal: n };
}
function YG() {
  const { isWalletConnectModalOpen: e, setIsWalletConnectModalOpen: t } = k.useContext(zb);
  return { isWalletConnectModalOpen: e, setIsWalletConnectModalOpen: t };
}
function cA() {
  const { connectModalOpen: e, openConnectModal: t, closeConnectModal: n } = k.useContext(zb), { isWalletConnectModalOpen: r } = YG();
  return {
    connectModalOpen: e || r,
    openConnectModal: t,
    closeConnectModal: n
  };
}
var PO = () => {
};
function yP({
  children: e
}) {
  const t = xCe(), { address: n } = os(), { chainId: r } = os(), { chains: i } = Ho(), o = i.some(
    (F) => F.id === r
  ), s = bCe(), c = iA() ?? void 0, u = r ? s[r] : void 0, f = (u == null ? void 0 : u.name) ?? void 0, p = (u == null ? void 0 : u.iconUrl) ?? void 0, y = (u == null ? void 0 : u.iconBackground) ?? void 0, v = aP(p), w = k.useContext(cP), C = vG().some(({ status: F }) => F === "pending") && w, { ensAvatar: x, ensName: A } = hG({
    address: n
  }), { openConnectModal: R } = cA(), { openChainModal: I } = KG(), { openAccountModal: D } = OEe(), { accountModalOpen: M, chainModalOpen: L, connectModalOpen: j } = REe();
  return /* @__PURE__ */ $.createElement($.Fragment, null, e({
    account: n ? {
      address: n,
      displayName: A ? IG(A) : OG(n),
      ensAvatar: x ?? void 0,
      ensName: A ?? void 0,
      hasPendingTransactions: C
    } : void 0,
    accountModalOpen: M,
    authenticationStatus: c,
    chain: r ? {
      hasIcon: !!p,
      iconBackground: y,
      iconUrl: v,
      id: r,
      name: f,
      unsupported: !o
    } : void 0,
    chainModalOpen: L,
    connectModalOpen: j,
    mounted: t(),
    openAccountModal: D ?? PO,
    openChainModal: I ?? PO,
    openConnectModal: R ?? PO
  }));
}
yP.displayName = "ConnectButton.Custom";
var S1 = {
  accountStatus: "full",
  chainStatus: { largeScreen: "full", smallScreen: "icon" },
  label: "Connect Wallet",
  showBalance: { largeScreen: !0, smallScreen: !1 }
};
function rx({
  accountStatus: e = S1.accountStatus,
  chainStatus: t = S1.chainStatus,
  label: n = S1.label,
  showBalance: r = S1.showBalance
}) {
  const i = uy(), o = oP(), { setShowBalance: s } = CCe(), [c, u] = k.useState(!1), { i18n: f } = k.useContext(fo);
  return k.useEffect(() => {
    s(r), c || u(!0);
  }, [r, s]), c ? /* @__PURE__ */ $.createElement(yP, null, ({
    account: p,
    chain: y,
    mounted: v,
    openAccountModal: w,
    openChainModal: C,
    openConnectModal: x
  }) => {
    const A = v && o !== "loading", R = (y == null ? void 0 : y.unsupported) ?? !1;
    return /* @__PURE__ */ $.createElement(
      ge,
      {
        display: "flex",
        gap: "12",
        ...!A && {
          "aria-hidden": !0,
          style: {
            opacity: 0,
            pointerEvents: "none",
            userSelect: "none"
          }
        }
      },
      A && p && o === "connected" ? /* @__PURE__ */ $.createElement($.Fragment, null, y && (i.length > 1 || R) && /* @__PURE__ */ $.createElement(
        ge,
        {
          alignItems: "center",
          "aria-label": "Chain Selector",
          as: "button",
          background: R ? "connectButtonBackgroundError" : "connectButtonBackground",
          borderRadius: "connectButton",
          boxShadow: "connectButton",
          className: ao({
            active: "shrink",
            hover: "grow"
          }),
          color: R ? "connectButtonTextError" : "connectButtonText",
          display: sg(
            t,
            (I) => I === "none" ? "none" : "flex"
          ),
          fontFamily: "body",
          fontWeight: "bold",
          gap: "6",
          key: (
            // Force re-mount to prevent CSS transition
            R ? "unsupported" : "supported"
          ),
          onClick: C,
          paddingX: "10",
          paddingY: "8",
          testId: R ? "wrong-network-button" : "chain-button",
          transition: "default",
          type: "button"
        },
        R ? /* @__PURE__ */ $.createElement(
          ge,
          {
            alignItems: "center",
            display: "flex",
            height: "24",
            paddingX: "4"
          },
          f.t("connect_wallet.wrong_network.label")
        ) : /* @__PURE__ */ $.createElement(ge, { alignItems: "center", display: "flex", gap: "6" }, y.hasIcon ? /* @__PURE__ */ $.createElement(
          ge,
          {
            display: sg(
              t,
              (I) => I === "full" || I === "icon" ? "block" : "none"
            ),
            height: "24",
            width: "24"
          },
          /* @__PURE__ */ $.createElement(
            _o,
            {
              alt: y.name ?? "Chain icon",
              background: y.iconBackground,
              borderRadius: "full",
              height: "24",
              src: y.iconUrl,
              width: "24"
            }
          )
        ) : null, /* @__PURE__ */ $.createElement(
          ge,
          {
            display: sg(t, (I) => I === "icon" && !y.iconUrl || I === "full" || I === "name" ? "block" : "none")
          },
          y.name ?? y.id
        )),
        /* @__PURE__ */ $.createElement(hU, null)
      ), !R && /* @__PURE__ */ $.createElement(
        ge,
        {
          alignItems: "center",
          as: "button",
          background: "connectButtonBackground",
          borderRadius: "connectButton",
          boxShadow: "connectButton",
          className: ao({
            active: "shrink",
            hover: "grow"
          }),
          color: "connectButtonText",
          display: "flex",
          fontFamily: "body",
          fontWeight: "bold",
          onClick: w,
          testId: "account-button",
          transition: "default",
          type: "button"
        },
        p.displayBalance && /* @__PURE__ */ $.createElement(
          ge,
          {
            display: sg(
              r,
              (I) => I ? "block" : "none"
            ),
            padding: "8",
            paddingLeft: "12"
          },
          p.displayBalance
        ),
        /* @__PURE__ */ $.createElement(
          ge,
          {
            background: $1e(r)[aa() ? "smallScreen" : "largeScreen"] ? "connectButtonInnerBackground" : "connectButtonBackground",
            borderColor: "connectButtonBackground",
            borderRadius: "connectButton",
            borderStyle: "solid",
            borderWidth: "2",
            color: "connectButtonText",
            fontFamily: "body",
            fontWeight: "bold",
            paddingX: "8",
            paddingY: "6",
            transition: "default"
          },
          /* @__PURE__ */ $.createElement(
            ge,
            {
              alignItems: "center",
              display: "flex",
              gap: "6",
              height: "24"
            },
            /* @__PURE__ */ $.createElement(
              ge,
              {
                display: sg(
                  e,
                  (I) => I === "full" || I === "avatar" ? "block" : "none"
                )
              },
              /* @__PURE__ */ $.createElement(
                cG,
                {
                  address: p.address,
                  imageUrl: p.ensAvatar,
                  loading: p.hasPendingTransactions,
                  size: 24
                }
              )
            ),
            /* @__PURE__ */ $.createElement(ge, { alignItems: "center", display: "flex", gap: "6" }, /* @__PURE__ */ $.createElement(
              ge,
              {
                display: sg(
                  e,
                  (I) => I === "full" || I === "address" ? "block" : "none"
                )
              },
              p.displayName
            ), /* @__PURE__ */ $.createElement(hU, null))
          )
        )
      )) : /* @__PURE__ */ $.createElement(
        ge,
        {
          as: "button",
          background: "accentColor",
          borderRadius: "connectButton",
          boxShadow: "connectButton",
          className: ao({
            active: "shrink",
            hover: "grow"
          }),
          color: "accentColorForeground",
          fontFamily: "body",
          fontWeight: "bold",
          height: "40",
          key: "connect",
          onClick: x,
          paddingX: "14",
          testId: "connect-button",
          transition: "default",
          type: "button"
        },
        v && n === "Connect Wallet" ? f.t("connect_wallet.label") : n
      )
    );
  }) : /* @__PURE__ */ $.createElement($.Fragment, null);
}
rx.__defaultProps = S1;
rx.Custom = yP;
var IEe = ({
  appName: e,
  appDescription: t,
  appUrl: n,
  appIcon: r
}) => ({
  name: e,
  description: t ?? e,
  url: n ?? (typeof window < "u" ? window.location.href : ""),
  icons: [...r ? [r] : []]
});
function DEe(e) {
  return Object.fromEntries(
    //@ts-ignore
    Object.entries(e).filter(([t, n]) => n !== void 0)
  );
}
function MEe(e, t) {
  const n = [];
  for (const r of e)
    n.some((i) => i[t] === r[t]) || n.push(r);
  return n;
}
var PEe = (e, {
  projectId: t,
  walletConnectParameters: n,
  appName: r,
  appDescription: i,
  appUrl: o,
  appIcon: s
}) => {
  if (!e.length)
    throw new Error("No wallet list was provided");
  for (const { wallets: w, groupName: C } of e)
    if (!w.length)
      throw new Error(`No wallets provided for group: ${C}`);
  let c = -1;
  const u = [], f = [], p = [], y = IEe({
    appName: r,
    appDescription: i,
    appUrl: o,
    appIcon: s
  });
  e.forEach(({ groupName: w, wallets: C }, x) => {
    C.forEach((A) => {
      c++;
      const R = A({
        projectId: t,
        appName: r,
        appIcon: s,
        // `option` is being used only for `walletConnectWallet` wallet
        options: {
          metadata: y,
          ...n
        },
        // Every other wallet that supports walletConnect flow and is not
        // `walletConnectWallet` wallet will have `walletConnectParameters` property
        walletConnectParameters: {
          metadata: y,
          ...n
        }
      });
      if (R != null && R.iconAccent && !Jxe(R == null ? void 0 : R.iconAccent))
        throw new Error(
          `Property \`iconAccent\` is not a hex value for wallet: ${R.name}`
        );
      const I = {
        ...R,
        groupIndex: x + 1,
        groupName: w,
        index: c
      };
      typeof R.hidden == "function" ? p.push(I) : f.push(I);
    });
  });
  const v = MEe(
    [...f, ...p],
    "id"
  );
  for (const {
    createConnector: w,
    groupIndex: C,
    groupName: x,
    hidden: A,
    ...R
  } of v) {
    if (typeof A == "function" && A())
      continue;
    const I = (L) => ({
      rkDetails: DEe({
        ...R,
        groupIndex: C,
        groupName: x,
        isRainbowKitConnector: !0,
        // These additional params will be used in rainbowkit react tree to
        // merge `walletConnectWallet` and `walletConnect` connector from wagmi with
        // showQrModal: true. This way we can let the user choose if they want to
        // connect via QR code or open the official walletConnect modal instead
        ...L || {}
      })
    });
    R.id === "walletConnect" && u.push(
      w(
        I({
          isWalletConnectModalConnector: !0,
          showQrModal: !0
        })
      )
    );
    const M = w(I());
    u.push(M);
  }
  return u;
};
const tf = Ro.map(
  () => k.useLayoutEffect
).orDefault(k.useEffect), NEe = () => Ro.map((e) => {
  const t = e.matchMedia("(prefers-color-scheme: dark)"), n = e.matchMedia("(prefers-color-scheme: light)");
  return t.matches ? "dark" : n.matches ? "light" : "no-preference";
}).orDefault("no-preference"), BEe = () => {
  const [e, t] = k.useState(() => ({ force: !1, theme: NEe() }));
  return tf(() => {
    if (e.force) return;
    const n = Ro.extractNullable();
    if (!n) return;
    const r = n.matchMedia("(prefers-color-scheme: dark)"), i = n.matchMedia("(prefers-color-scheme: light)");
    if (typeof i.addEventListener != "function") return;
    const o = ({ matches: c }) => {
      c && t({ theme: "dark", force: !1 });
    }, s = ({ matches: c }) => {
      c && t({ theme: "light", force: !1 });
    };
    return r.addEventListener("change", o), i.addEventListener("change", s), () => {
      r.removeEventListener("change", o), i.removeEventListener("change", s);
    };
  }, [e]), e.theme;
}, uA = {
  lightMode: fM(),
  darkMode: K$()
}, LEe = {
  white: "#fff",
  black: "#000",
  transparent: "transparent",
  primary: "#fff",
  accent: "#000",
  disabled: "#E0E0E0",
  text: "#373737",
  textMuted: "#999999",
  textDanger: "#FF1515",
  background: "#fff",
  backgroundMuted: "#F6F7F9",
  tokenSelectBackground: "#F6F7F9",
  tokenSelectHoverBackground: "#EEF0F2",
  tokenSelect: "#373737",
  tabBorder: "#000000",
  skeletonLoaderBase: "#F6F7F9",
  skeletonLoaderHighlight: "#fff",
  warningBoxBackground: "#F6F7F9",
  stakeSectionBackground: "#F6F7F9",
  dropdownBackground: "#F6F7F9",
  selectValidatorMultiSelectedBackground: "#2DC969",
  selectValidatorMultiDefaultBackground: "#fff",
  positionsSectionBackgroundColor: "#FFFFFF",
  positionsSectionBorderColor: "#373737",
  positionsSectionDividerColor: "#F6F7F9",
  positionsClaimRewardsBackground: "#45D65C",
  positionsActionRequiredBackground: "#FA6878",
  positionsPendingBackground: "#FFAA07",
  modalOverlayBackground: "rgba(0, 0, 0, 0.5)",
  modalBodyBackground: "#FFFFFF",
  tooltipBackground: "#000000",
  primaryButtonColor: "#FFFFFF",
  primaryButtonBackground: "#000000",
  primaryButtonOutline: "#000000",
  primaryButtonHoverColor: "#FFFFFF",
  primaryButtonHoverBackground: "#1A1A1A",
  primaryButtonHoverOutline: "#1A1A1A",
  primaryButtonActiveColor: "#FFFFFF",
  primaryButtonActiveBackground: "#000000",
  primaryButtonActiveOutline: "#000000",
  secondaryButtonColor: "#373737",
  secondaryButtonBackground: "#FFFFFF",
  secondaryButtonOutline: "#000000",
  secondaryButtonHoverColor: "#373737",
  secondaryButtonHoverBackground: "#F6F7F9",
  secondaryButtonHoverOutline: "#000000",
  secondaryButtonActiveColor: "#373737",
  secondaryButtonActiveBackground: "#F6F7F9",
  secondaryButtonActiveOutline: "#000000",
  smallButtonColor: "#373737",
  smallButtonBackground: "#FFFFFF",
  smallButtonOutline: "#000000",
  smallButtonHoverColor: "#373737",
  smallButtonHoverBackground: "#F6F7F9",
  smallButtonHoverOutline: "#000000",
  smallButtonActiveColor: "#373737",
  smallButtonActiveBackground: "#F6F7F9",
  smallButtonActiveOutline: "#000000",
  smallLightButtonColor: "#373737",
  smallLightButtonBackground: "#F6F7F9",
  smallLightButtonOutline: "#F6F7F9",
  smallLightButtonHoverColor: "#373737",
  smallLightButtonHoverBackground: "#eaedf1",
  smallLightButtonHoverOutline: "#eaedf1",
  smallLightButtonActiveColor: "#373737",
  smallLightButtonActiveBackground: "#eaedf1",
  smallLightButtonActiveOutline: "#eaedf1",
  disabledButtonColor: "#FFFFFF",
  disabledButtonBackground: "#E0E0E0",
  disabledButtonOutline: "#E0E0E0",
  disabledButtonHoverColor: "#FFFFFF",
  disabledButtonHoverBackground: "#E6E6E6",
  disabledButtonHoverOutline: "#E0E0E0",
  disabledButtonActiveColor: "#FFFFFF",
  disabledButtonActiveBackground: "#E0E0E0",
  disabledButtonActiveOutline: "#E0E0E0",
  connectKit: {
    ...uA.lightMode.colors,
    modalBackground: "#FFFFFF",
    profileForeground: "#FFFFFF",
    profileAction: "#F6F7F9",
    profileActionHover: "#E0E0E0",
    modalBackdrop: "rgba(0, 0, 0, 0.5)"
  }
}, jEe = {
  white: "#fff",
  black: "#000",
  transparent: "transparent",
  primary: "#2B2B2B",
  accent: "#3B6CEC",
  disabled: "#E0E0E0",
  text: "#FFFFFF",
  textMuted: "#999999",
  textDanger: "#FF1515",
  background: "#2B2B2B",
  backgroundMuted: "#363636",
  tokenSelectBackground: "#363636",
  tokenSelectHoverBackground: "#444444",
  tokenSelect: "#FFFFFF",
  tabBorder: "#FFFFFF",
  skeletonLoaderBase: "#363636",
  skeletonLoaderHighlight: "#2B2B2B",
  warningBoxBackground: "#363636",
  stakeSectionBackground: "#363636",
  dropdownBackground: "#363636",
  selectValidatorMultiSelectedBackground: "#2DC969",
  selectValidatorMultiDefaultBackground: "#2B2B2B",
  positionsSectionBackgroundColor: "#2B2B2B",
  positionsSectionBorderColor: "#2B2B2B",
  positionsSectionDividerColor: "#363636",
  positionsClaimRewardsBackground: "#45D65C",
  positionsActionRequiredBackground: "#FA6878",
  positionsPendingBackground: "#FFAA07",
  modalOverlayBackground: "rgba(0, 0, 0, 0.5)",
  modalBodyBackground: "#2B2B2B",
  tooltipBackground: "#000000",
  primaryButtonColor: "#000000",
  primaryButtonBackground: "#FFFFFF",
  primaryButtonOutline: "#FFFFFF",
  primaryButtonHoverColor: "#373737",
  primaryButtonHoverBackground: "#E6E6E6",
  primaryButtonHoverOutline: "#E6E6E6",
  primaryButtonActiveColor: "#000000",
  primaryButtonActiveBackground: "#FFFFFF",
  primaryButtonActiveOutline: "#000000",
  secondaryButtonColor: "#FFFFFF",
  secondaryButtonBackground: "#2B2B2B",
  secondaryButtonOutline: "#FFFFFF",
  secondaryButtonHoverColor: "#FFFFFF",
  secondaryButtonHoverBackground: "#212121",
  secondaryButtonHoverOutline: "#FFFFFF",
  secondaryButtonActiveColor: "#FFFFFF",
  secondaryButtonActiveBackground: "#212121",
  secondaryButtonActiveOutline: "#FFFFFF",
  smallButtonColor: "#FFFFFF",
  smallButtonBackground: "#2B2B2B",
  smallButtonOutline: "#2B2B2B",
  smallButtonHoverColor: "#FFFFFF",
  smallButtonHoverBackground: "#212121",
  smallButtonHoverOutline: "#212121",
  smallButtonActiveColor: "#FFFFFF",
  smallButtonActiveBackground: "#212121",
  smallButtonActiveOutline: "#212121",
  smallLightButtonColor: "#FFFFFF",
  smallLightButtonBackground: "#363636",
  smallLightButtonOutline: "#363636",
  smallLightButtonHoverColor: "#FFFFFF",
  smallLightButtonHoverBackground: "#434343",
  smallLightButtonHoverOutline: "#434343",
  smallLightButtonActiveColor: "#FFFFFF",
  smallLightButtonActiveBackground: "#434343",
  smallLightButtonActiveOutline: "#434343",
  disabledButtonColor: "#000000",
  disabledButtonBackground: "#E0E0E0",
  disabledButtonOutline: "#FFFFFF",
  disabledButtonHoverColor: "#000000",
  disabledButtonHoverBackground: "#E6E6E6",
  disabledButtonHoverOutline: "#F6F7F9",
  disabledButtonActiveColor: "#000000",
  disabledButtonActiveBackground: "#E0E0E0",
  disabledButtonActiveOutline: "#FFFFFF",
  connectKit: {
    ...uA.darkMode.colors,
    modalBackground: "#2B2B2B",
    profileForeground: "#2B2B2B",
    profileAction: "#363636",
    profileActionHover: "#444444",
    modalBackdrop: "rgba(0, 0, 0, 0.5)"
  }
}, FEe = {
  body: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif'
};
var ti = { color: { white: "var(--sk-color-white)", black: "var(--sk-color-black)", transparent: "var(--sk-color-transparent)", primary: "var(--sk-color-primary)", accent: "var(--sk-color-accent)", disabled: "var(--sk-color-disabled)", text: "var(--sk-color-text)", textMuted: "var(--sk-color-text-muted)", textDanger: "var(--sk-color-text-danger)", background: "var(--sk-color-background)", backgroundMuted: "var(--sk-color-background-muted)", tokenSelectBackground: "var(--sk-color-token-select-background)", tokenSelectHoverBackground: "var(--sk-color-token-select-hover-background)", tokenSelect: "var(--sk-color-token-select)", skeletonLoaderBase: "var(--sk-color-skeleton-loader-base)", skeletonLoaderHighlight: "var(--sk-color-skeleton-loader-highlight)", tabBorder: "var(--sk-color-tab-border)", stakeSectionBackground: "var(--sk-color-stake-section-background)", dropdownBackground: "var(--sk-color-dropdown-background)", selectValidatorMultiSelectedBackground: "var(--sk-color-select-validator-multi-selected-background)", selectValidatorMultiDefaultBackground: "var(--sk-color-select-validator-multi-default-background)", warningBoxBackground: "var(--sk-color-warning-box-background)", positionsSectionBackgroundColor: "var(--sk-color-positions-section-background-color)", positionsSectionBorderColor: "var(--sk-color-positions-section-border-color)", positionsSectionDividerColor: "var(--sk-color-positions-section-divider-color)", positionsClaimRewardsBackground: "var(--sk-color-positions-claim-rewards-background)", positionsActionRequiredBackground: "var(--sk-color-positions-action-required-background)", positionsPendingBackground: "var(--sk-color-positions-pending-background)", modalOverlayBackground: "var(--sk-color-modal-overlay-background)", modalBodyBackground: "var(--sk-color-modal-body-background)", tooltipBackground: "var(--sk-color-tooltip-background)", primaryButtonColor: "var(--sk-color-primary-button-color)", primaryButtonBackground: "var(--sk-color-primary-button-background)", primaryButtonOutline: "var(--sk-color-primary-button-outline)", primaryButtonHoverColor: "var(--sk-color-primary-button-hover-color)", primaryButtonHoverBackground: "var(--sk-color-primary-button-hover-background)", primaryButtonHoverOutline: "var(--sk-color-primary-button-hover-outline)", primaryButtonActiveColor: "var(--sk-color-primary-button-active-color)", primaryButtonActiveBackground: "var(--sk-color-primary-button-active-background)", primaryButtonActiveOutline: "var(--sk-color-primary-button-active-outline)", secondaryButtonColor: "var(--sk-color-secondary-button-color)", secondaryButtonBackground: "var(--sk-color-secondary-button-background)", secondaryButtonOutline: "var(--sk-color-secondary-button-outline)", secondaryButtonHoverColor: "var(--sk-color-secondary-button-hover-color)", secondaryButtonHoverBackground: "var(--sk-color-secondary-button-hover-background)", secondaryButtonHoverOutline: "var(--sk-color-secondary-button-hover-outline)", secondaryButtonActiveColor: "var(--sk-color-secondary-button-active-color)", secondaryButtonActiveBackground: "var(--sk-color-secondary-button-active-background)", secondaryButtonActiveOutline: "var(--sk-color-secondary-button-active-outline)", smallButtonColor: "var(--sk-color-small-button-color)", smallButtonBackground: "var(--sk-color-small-button-background)", smallButtonOutline: "var(--sk-color-small-button-outline)", smallButtonHoverColor: "var(--sk-color-small-button-hover-color)", smallButtonHoverBackground: "var(--sk-color-small-button-hover-background)", smallButtonHoverOutline: "var(--sk-color-small-button-hover-outline)", smallButtonActiveColor: "var(--sk-color-small-button-active-color)", smallButtonActiveBackground: "var(--sk-color-small-button-active-background)", smallButtonActiveOutline: "var(--sk-color-small-button-active-outline)", smallLightButtonColor: "var(--sk-color-small-light-button-color)", smallLightButtonBackground: "var(--sk-color-small-light-button-background)", smallLightButtonOutline: "var(--sk-color-small-light-button-outline)", smallLightButtonHoverColor: "var(--sk-color-small-light-button-hover-color)", smallLightButtonHoverBackground: "var(--sk-color-small-light-button-hover-background)", smallLightButtonHoverOutline: "var(--sk-color-small-light-button-hover-outline)", smallLightButtonActiveColor: "var(--sk-color-small-light-button-active-color)", smallLightButtonActiveBackground: "var(--sk-color-small-light-button-active-background)", smallLightButtonActiveOutline: "var(--sk-color-small-light-button-active-outline)", disabledButtonColor: "var(--sk-color-disabled-button-color)", disabledButtonBackground: "var(--sk-color-disabled-button-background)", disabledButtonOutline: "var(--sk-color-disabled-button-outline)", disabledButtonHoverColor: "var(--sk-color-disabled-button-hover-color)", disabledButtonHoverBackground: "var(--sk-color-disabled-button-hover-background)", disabledButtonHoverOutline: "var(--sk-color-disabled-button-hover-outline)", disabledButtonActiveColor: "var(--sk-color-disabled-button-active-color)", disabledButtonActiveBackground: "var(--sk-color-disabled-button-active-background)", disabledButtonActiveOutline: "var(--sk-color-disabled-button-active-outline)", connectKit: { accentColor: "var(--sk-color-connect-kit-accent-color)", accentColorForeground: "var(--sk-color-connect-kit-accent-color-foreground)", actionButtonBorder: "var(--sk-color-connect-kit-action-button-border)", actionButtonBorderMobile: "var(--sk-color-connect-kit-action-button-border-mobile)", actionButtonSecondaryBackground: "var(--sk-color-connect-kit-action-button-secondary-background)", closeButton: "var(--sk-color-connect-kit-close-button)", closeButtonBackground: "var(--sk-color-connect-kit-close-button-background)", connectButtonBackground: "var(--sk-color-connect-kit-connect-button-background)", connectButtonBackgroundError: "var(--sk-color-connect-kit-connect-button-background-error)", connectButtonInnerBackground: "var(--sk-color-connect-kit-connect-button-inner-background)", connectButtonText: "var(--sk-color-connect-kit-connect-button-text)", connectButtonTextError: "var(--sk-color-connect-kit-connect-button-text-error)", connectionIndicator: "var(--sk-color-connect-kit-connection-indicator)", downloadBottomCardBackground: "var(--sk-color-connect-kit-download-bottom-card-background)", downloadTopCardBackground: "var(--sk-color-connect-kit-download-top-card-background)", error: "var(--sk-color-connect-kit-error)", generalBorder: "var(--sk-color-connect-kit-general-border)", generalBorderDim: "var(--sk-color-connect-kit-general-border-dim)", menuItemBackground: "var(--sk-color-connect-kit-menu-item-background)", modalBackdrop: "var(--sk-color-connect-kit-modal-backdrop)", modalBackground: "var(--sk-color-connect-kit-modal-background)", modalBorder: "var(--sk-color-connect-kit-modal-border)", modalText: "var(--sk-color-connect-kit-modal-text)", modalTextDim: "var(--sk-color-connect-kit-modal-text-dim)", modalTextSecondary: "var(--sk-color-connect-kit-modal-text-secondary)", profileAction: "var(--sk-color-connect-kit-profile-action)", profileActionHover: "var(--sk-color-connect-kit-profile-action-hover)", profileForeground: "var(--sk-color-connect-kit-profile-foreground)", selectedOptionBorder: "var(--sk-color-connect-kit-selected-option-border)", standby: "var(--sk-color-connect-kit-standby)" } }, fontSize: { xs: "var(--sk-font-size-xs)", sm: "var(--sk-font-size-sm)", md: "var(--sk-font-size-md)", lg: "var(--sk-font-size-lg)", lgx: "var(--sk-font-size-lgx)", xl: "var(--sk-font-size-xl)", "2xl": "var(--sk-font-size-2xl)", "3xl": "var(--sk-font-size-3xl)", "4xl": "var(--sk-font-size-4xl)", "5xl": "var(--sk-font-size-5xl)", "6xl": "var(--sk-font-size-6xl)" }, letterSpacing: { tighter: "var(--sk-letter-spacing-tighter)", tight: "var(--sk-letter-spacing-tight)", normal: "var(--sk-letter-spacing-normal)", wide: "var(--sk-letter-spacing-wide)", wider: "var(--sk-letter-spacing-wider)", widest: "var(--sk-letter-spacing-widest)" }, lineHeight: { none: "var(--sk-line-height-none)", shorter: "var(--sk-line-height-shorter)", short: "var(--sk-line-height-short)", base: "var(--sk-line-height-base)", tall: "var(--sk-line-height-tall)", taller: "var(--sk-line-height-taller)", xs: "var(--sk-line-height-xs)", sm: "var(--sk-line-height-sm)", md: "var(--sk-line-height-md)", lg: "var(--sk-line-height-lg)", xl: "var(--sk-line-height-xl)", "2xl": "var(--sk-line-height-2xl)", "3xl": "var(--sk-line-height-3xl)", "4xl": "var(--sk-line-height-4xl)", "5xl": "var(--sk-line-height-5xl)", "6xl": "var(--sk-line-height-6xl)" }, fontWeight: { normal: "var(--sk-font-weight-normal)", medium: "var(--sk-font-weight-medium)", semibold: "var(--sk-font-weight-semibold)", bold: "var(--sk-font-weight-bold)", extrabold: "var(--sk-font-weight-extrabold)", modalHeading: "var(--sk-font-weight-modal-heading)", tokenSelect: "var(--sk-font-weight-token-select)", primaryButton: "var(--sk-font-weight-primary-button)", secondaryButton: "var(--sk-font-weight-secondary-button)" }, borderRadius: { baseContract: { none: "var(--sk-border-radius-base-contract-none)", sm: "var(--sk-border-radius-base-contract-sm)", base: "var(--sk-border-radius-base-contract-base)", md: "var(--sk-border-radius-base-contract-md)", lg: "var(--sk-border-radius-base-contract-lg)", xl: "var(--sk-border-radius-base-contract-xl)", "2xl": "var(--sk-border-radius-base-contract-2xl)", "3xl": "var(--sk-border-radius-base-contract-3xl)", full: "var(--sk-border-radius-base-contract-full)", half: "var(--sk-border-radius-base-contract-half)", widgetBorderRadius: "var(--sk-border-radius-base-contract-widget-border-radius)", primaryButton: "var(--sk-border-radius-base-contract-primary-button)", secondaryButton: "var(--sk-border-radius-base-contract-secondary-button)", smallButton: "var(--sk-border-radius-base-contract-small-button)" }, connectKit: { actionButton: "var(--sk-border-radius-connect-kit-action-button)", connectButton: "var(--sk-border-radius-connect-kit-connect-button)", menuButton: "var(--sk-border-radius-connect-kit-menu-button)", modal: "var(--sk-border-radius-connect-kit-modal)", modalMobile: "var(--sk-border-radius-connect-kit-modal-mobile)" } }, space: { 0: "var(--sk-space-0)", 1: "var(--sk-space-1)", 2: "var(--sk-space-2)", 3: "var(--sk-space-3)", 4: "var(--sk-space-4)", 5: "var(--sk-space-5)", 6: "var(--sk-space-6)", 7: "var(--sk-space-7)", 8: "var(--sk-space-8)", 9: "var(--sk-space-9)", 10: "var(--sk-space-10)", 12: "var(--sk-space-12)", 14: "var(--sk-space-14)", 16: "var(--sk-space-16)", 20: "var(--sk-space-20)", 24: "var(--sk-space-24)", 28: "var(--sk-space-28)", 32: "var(--sk-space-32)", 36: "var(--sk-space-36)", 40: "var(--sk-space-40)", 44: "var(--sk-space-44)", 48: "var(--sk-space-48)", full: "var(--sk-space-full)", unset: "var(--sk-space-unset)", auto: "var(--sk-space-auto)", px: "var(--sk-space-px)", buttonMinHeight: "var(--sk-space-button-min-height)" }, heading: { h1: { mobile: { fontSize: "var(--sk-heading-h1-mobile-font-size)" }, tablet: { fontSize: "var(--sk-heading-h1-tablet-font-size)" } }, h2: { mobile: { fontSize: "var(--sk-heading-h2-mobile-font-size)" }, tablet: { fontSize: "var(--sk-heading-h2-tablet-font-size)" } }, h3: { mobile: { fontSize: "var(--sk-heading-h3-mobile-font-size)" }, tablet: { fontSize: "var(--sk-heading-h3-tablet-font-size)" } }, h4: { mobile: { fontSize: "var(--sk-heading-h4-mobile-font-size)" }, tablet: { fontSize: "var(--sk-heading-h4-tablet-font-size)" } } }, text: { large: { mobile: { fontSize: "var(--sk-text-large-mobile-font-size)" }, tablet: { fontSize: "var(--sk-text-large-tablet-font-size)" } }, medium: { mobile: { fontSize: "var(--sk-text-medium-mobile-font-size)" }, tablet: { fontSize: "var(--sk-text-medium-tablet-font-size)" } }, small: { mobile: { fontSize: "var(--sk-text-small-mobile-font-size)" }, tablet: { fontSize: "var(--sk-text-small-tablet-font-size)" } } }, zIndices: { hide: "var(--sk-z-indices-hide)", auto: "var(--sk-z-indices-auto)", simple: "var(--sk-z-indices-simple)", base: "var(--sk-z-indices-base)", docked: "var(--sk-z-indices-docked)", dropdown: "var(--sk-z-indices-dropdown)", sticky: "var(--sk-z-indices-sticky)", banner: "var(--sk-z-indices-banner)", overlay: "var(--sk-z-indices-overlay)", modal: "var(--sk-z-indices-modal)", skipLink: "var(--sk-z-indices-skip-link)" }, font: { body: "var(--sk-font-body)" } };
function UEe(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function zEe(e) {
  var t = UEe(e, "string");
  return typeof t == "symbol" ? t : String(t);
}
function VEe(e, t, n) {
  return t = zEe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function BU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function NO(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? BU(Object(n), !0).forEach(function(r) {
      VEe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : BU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $Ee = (e) => function() {
  for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
    n[r] = arguments[r];
  var i = Object.assign({}, ...n.map((u) => u.styles)), o = Object.keys(i), s = o.filter((u) => "mappings" in i[u]), c = (u) => {
    var f = [], p = {}, y = NO({}, u), v = !1;
    for (var w of s) {
      var C = u[w];
      if (C != null) {
        var x = i[w];
        v = !0;
        for (var A of x.mappings)
          p[A] = C, y[A] == null && delete y[A];
      }
    }
    var R = v ? NO(NO({}, p), y) : u, I = function() {
      var L = R[D], j = i[D];
      try {
        if (j.mappings)
          return 1;
        if (typeof L == "string" || typeof L == "number") {
          if (ct.env.NODE_ENV !== "production" && !j.values[L].defaultClass)
            throw new Error();
          f.push(j.values[L].defaultClass);
        } else if (Array.isArray(L))
          for (var F = 0; F < L.length; F++) {
            var O = L[F];
            if (O != null) {
              var z = j.responsiveArray[F];
              if (ct.env.NODE_ENV !== "production" && !j.values[O].conditions[z])
                throw new Error();
              f.push(j.values[O].conditions[z]);
            }
          }
        else
          for (var H in L) {
            var Q = L[H];
            if (Q != null) {
              if (ct.env.NODE_ENV !== "production" && !j.values[Q].conditions[H])
                throw new Error();
              f.push(j.values[Q].conditions[H]);
            }
          }
      } catch (K) {
        if (ct.env.NODE_ENV !== "production") {
          class oe extends Error {
            constructor(ce) {
              super(ce), this.name = "SprinklesError";
            }
          }
          var Y = (be) => typeof be == "string" ? '"'.concat(be, '"') : be, ee = (be, ce, pe) => {
            throw new oe('"'.concat(be, '" has no value ').concat(Y(ce), ". Possible values are ").concat(Object.keys(pe).map(Y).join(", ")));
          };
          if (!j)
            throw new oe('"'.concat(D, '" is not a valid sprinkle'));
          if ((typeof L == "string" || typeof L == "number") && (L in j.values || ee(D, L, j.values), !j.values[L].defaultClass))
            throw new oe('"'.concat(D, '" has no default condition. You must specify which conditions to target explicitly. Possible options are ').concat(Object.keys(j.values[L].conditions).map(Y).join(", ")));
          if (typeof L == "object") {
            if (!("conditions" in j.values[Object.keys(j.values)[0]]))
              throw new oe('"'.concat(D, '" is not a conditional property'));
            if (Array.isArray(L)) {
              if (!("responsiveArray" in j))
                throw new oe('"'.concat(D, '" does not support responsive arrays'));
              var ie = j.responsiveArray.length;
              if (ie < L.length)
                throw new oe('"'.concat(D, '" only supports up to ').concat(ie, " breakpoints. You passed ").concat(L.length));
              for (var X of L)
                j.values[X] || ee(D, X, j.values);
            } else
              for (var Z in L) {
                var J = L[Z];
                if (J != null && (j.values[J] || ee(D, J, j.values), !j.values[J].conditions[Z]))
                  throw new oe('"'.concat(D, '" has no condition named ').concat(Y(Z), ". Possible values are ").concat(Object.keys(j.values[J].conditions).map(Y).join(", ")));
              }
          }
        }
        throw K;
      }
    };
    for (var D in R)
      I();
    return e(f.join(" "));
  };
  return Object.assign(c, {
    properties: new Set(o)
  });
}, HEe = (e) => e, qEe = function() {
  return $Ee(HEe)(...arguments);
}, LU = qEe({ conditions: void 0, styles: { position: { values: { relative: { defaultClass: "yv8y4r0" }, absolute: { defaultClass: "yv8y4r1" }, sticky: { defaultClass: "yv8y4r2" } } }, opacity: { values: { 0: { defaultClass: "yv8y4r3" }, 1: { defaultClass: "yv8y4r6" }, "0.1": { defaultClass: "yv8y4r4" }, "0.5": { defaultClass: "yv8y4r5" } } }, zIndex: { values: { hide: { defaultClass: "yv8y4r7" }, auto: { defaultClass: "yv8y4r8" }, simple: { defaultClass: "yv8y4r9" }, base: { defaultClass: "yv8y4ra" }, docked: { defaultClass: "yv8y4rb" }, dropdown: { defaultClass: "yv8y4rc" }, sticky: { defaultClass: "yv8y4rd" }, banner: { defaultClass: "yv8y4re" }, overlay: { defaultClass: "yv8y4rf" }, modal: { defaultClass: "yv8y4rg" }, skipLink: { defaultClass: "yv8y4rh" } } }, fontWeight: { values: { normal: { defaultClass: "yv8y4ri" }, medium: { defaultClass: "yv8y4rj" }, semibold: { defaultClass: "yv8y4rk" }, bold: { defaultClass: "yv8y4rl" }, extrabold: { defaultClass: "yv8y4rm" }, modalHeading: { defaultClass: "yv8y4rn" }, tokenSelect: { defaultClass: "yv8y4ro" }, primaryButton: { defaultClass: "yv8y4rp" }, secondaryButton: { defaultClass: "yv8y4rq" } } }, border: { values: { none: { defaultClass: "yv8y4rr" } } }, borderRadius: { values: { none: { defaultClass: "yv8y4rs" }, sm: { defaultClass: "yv8y4rt" }, base: { defaultClass: "yv8y4ru" }, md: { defaultClass: "yv8y4rv" }, lg: { defaultClass: "yv8y4rw" }, xl: { defaultClass: "yv8y4rx" }, "2xl": { defaultClass: "yv8y4ry" }, "3xl": { defaultClass: "yv8y4rz" }, full: { defaultClass: "yv8y4r10" }, half: { defaultClass: "yv8y4r11" }, widgetBorderRadius: { defaultClass: "yv8y4r12" }, primaryButton: { defaultClass: "yv8y4r13" }, secondaryButton: { defaultClass: "yv8y4r14" }, smallButton: { defaultClass: "yv8y4r15" } } }, textAlign: { values: { left: { defaultClass: "yv8y4r16" }, center: { defaultClass: "yv8y4r17" }, right: { defaultClass: "yv8y4r18" }, end: { defaultClass: "yv8y4r19" } } }, flex: { values: { 1: { defaultClass: "yv8y4r1a" }, 2: { defaultClass: "yv8y4r1b" }, 3: { defaultClass: "yv8y4r1c" }, 4: { defaultClass: "yv8y4r1d" }, 5: { defaultClass: "yv8y4r1e" } } }, flexGrow: { values: { 0: { defaultClass: "yv8y4r1f" }, 1: { defaultClass: "yv8y4r1g" }, 2: { defaultClass: "yv8y4r1h" }, 3: { defaultClass: "yv8y4r1i" } } }, flexShrink: { values: { 0: { defaultClass: "yv8y4r1j" }, 1: { defaultClass: "yv8y4r1k" }, 2: { defaultClass: "yv8y4r1l" }, 3: { defaultClass: "yv8y4r1m" } } }, lineHeight: { values: { none: { defaultClass: "yv8y4r1n" }, shorter: { defaultClass: "yv8y4r1o" }, short: { defaultClass: "yv8y4r1p" }, base: { defaultClass: "yv8y4r1q" }, tall: { defaultClass: "yv8y4r1r" }, taller: { defaultClass: "yv8y4r1s" }, xs: { defaultClass: "yv8y4r1t" }, sm: { defaultClass: "yv8y4r1u" }, md: { defaultClass: "yv8y4r1v" }, lg: { defaultClass: "yv8y4r1w" }, xl: { defaultClass: "yv8y4r1x" }, "2xl": { defaultClass: "yv8y4r1y" }, "3xl": { defaultClass: "yv8y4r1z" }, "4xl": { defaultClass: "yv8y4r20" }, "5xl": { defaultClass: "yv8y4r21" }, "6xl": { defaultClass: "yv8y4r22" } } }, letterSpacing: { values: { tighter: { defaultClass: "yv8y4r23" }, tight: { defaultClass: "yv8y4r24" }, normal: { defaultClass: "yv8y4r25" }, wide: { defaultClass: "yv8y4r26" }, wider: { defaultClass: "yv8y4r27" }, widest: { defaultClass: "yv8y4r28" } } }, borderWidth: { values: { 1: { defaultClass: "yv8y4r2a" }, 2: { defaultClass: "yv8y4r2b" }, 3: { defaultClass: "yv8y4r2c" }, "0.5": { defaultClass: "yv8y4r29" } } }, borderStyle: { values: { solid: { defaultClass: "yv8y4r2d" } } }, overflowWrap: { values: { normal: { defaultClass: "yv8y4r2e" }, "break-word": { defaultClass: "yv8y4r2f" }, anywhere: { defaultClass: "yv8y4r2g" } } } } }, { conditions: { defaultCondition: "mobile", conditionNames: ["mobile", "tablet"], responsiveArray: void 0 }, styles: { px: { mappings: ["paddingLeft", "paddingRight"] }, py: { mappings: ["paddingTop", "paddingBottom"] }, mx: { mappings: ["marginLeft", "marginRight"] }, my: { mappings: ["marginTop", "marginBottom"] }, hw: { mappings: ["height", "width"] }, display: { values: { block: { conditions: { mobile: "yv8y4r2h", tablet: "yv8y4r2i" }, defaultClass: "yv8y4r2h" }, inline: { conditions: { mobile: "yv8y4r2j", tablet: "yv8y4r2k" }, defaultClass: "yv8y4r2j" }, "inline-block": { conditions: { mobile: "yv8y4r2l", tablet: "yv8y4r2m" }, defaultClass: "yv8y4r2l" }, flex: { conditions: { mobile: "yv8y4r2n", tablet: "yv8y4r2o" }, defaultClass: "yv8y4r2n" }, "inline-flex": { conditions: { mobile: "yv8y4r2p", tablet: "yv8y4r2q" }, defaultClass: "yv8y4r2p" }, none: { conditions: { mobile: "yv8y4r2r", tablet: "yv8y4r2s" }, defaultClass: "yv8y4r2r" } } }, fontSize: { values: { xs: { conditions: { mobile: "yv8y4r2t", tablet: "yv8y4r2u" }, defaultClass: "yv8y4r2t" }, sm: { conditions: { mobile: "yv8y4r2v", tablet: "yv8y4r2w" }, defaultClass: "yv8y4r2v" }, md: { conditions: { mobile: "yv8y4r2x", tablet: "yv8y4r2y" }, defaultClass: "yv8y4r2x" }, lg: { conditions: { mobile: "yv8y4r2z", tablet: "yv8y4r30" }, defaultClass: "yv8y4r2z" }, lgx: { conditions: { mobile: "yv8y4r31", tablet: "yv8y4r32" }, defaultClass: "yv8y4r31" }, xl: { conditions: { mobile: "yv8y4r33", tablet: "yv8y4r34" }, defaultClass: "yv8y4r33" }, "2xl": { conditions: { mobile: "yv8y4r35", tablet: "yv8y4r36" }, defaultClass: "yv8y4r35" }, "3xl": { conditions: { mobile: "yv8y4r37", tablet: "yv8y4r38" }, defaultClass: "yv8y4r37" }, "4xl": { conditions: { mobile: "yv8y4r39", tablet: "yv8y4r3a" }, defaultClass: "yv8y4r39" }, "5xl": { conditions: { mobile: "yv8y4r3b", tablet: "yv8y4r3c" }, defaultClass: "yv8y4r3b" }, "6xl": { conditions: { mobile: "yv8y4r3d", tablet: "yv8y4r3e" }, defaultClass: "yv8y4r3d" } } }, marginTop: { values: { 0: { conditions: { mobile: "yv8y4r3f", tablet: "yv8y4r3g" }, defaultClass: "yv8y4r3f" }, 1: { conditions: { mobile: "yv8y4r3h", tablet: "yv8y4r3i" }, defaultClass: "yv8y4r3h" }, 2: { conditions: { mobile: "yv8y4r3j", tablet: "yv8y4r3k" }, defaultClass: "yv8y4r3j" }, 3: { conditions: { mobile: "yv8y4r3l", tablet: "yv8y4r3m" }, defaultClass: "yv8y4r3l" }, 4: { conditions: { mobile: "yv8y4r3n", tablet: "yv8y4r3o" }, defaultClass: "yv8y4r3n" }, 5: { conditions: { mobile: "yv8y4r3p", tablet: "yv8y4r3q" }, defaultClass: "yv8y4r3p" }, 6: { conditions: { mobile: "yv8y4r3r", tablet: "yv8y4r3s" }, defaultClass: "yv8y4r3r" }, 7: { conditions: { mobile: "yv8y4r3t", tablet: "yv8y4r3u" }, defaultClass: "yv8y4r3t" }, 8: { conditions: { mobile: "yv8y4r3v", tablet: "yv8y4r3w" }, defaultClass: "yv8y4r3v" }, 9: { conditions: { mobile: "yv8y4r3x", tablet: "yv8y4r3y" }, defaultClass: "yv8y4r3x" }, 10: { conditions: { mobile: "yv8y4r3z", tablet: "yv8y4r40" }, defaultClass: "yv8y4r3z" }, 12: { conditions: { mobile: "yv8y4r41", tablet: "yv8y4r42" }, defaultClass: "yv8y4r41" }, 14: { conditions: { mobile: "yv8y4r43", tablet: "yv8y4r44" }, defaultClass: "yv8y4r43" }, 16: { conditions: { mobile: "yv8y4r45", tablet: "yv8y4r46" }, defaultClass: "yv8y4r45" }, 20: { conditions: { mobile: "yv8y4r47", tablet: "yv8y4r48" }, defaultClass: "yv8y4r47" }, 24: { conditions: { mobile: "yv8y4r49", tablet: "yv8y4r4a" }, defaultClass: "yv8y4r49" }, 28: { conditions: { mobile: "yv8y4r4b", tablet: "yv8y4r4c" }, defaultClass: "yv8y4r4b" }, 32: { conditions: { mobile: "yv8y4r4d", tablet: "yv8y4r4e" }, defaultClass: "yv8y4r4d" }, 36: { conditions: { mobile: "yv8y4r4f", tablet: "yv8y4r4g" }, defaultClass: "yv8y4r4f" }, 40: { conditions: { mobile: "yv8y4r4h", tablet: "yv8y4r4i" }, defaultClass: "yv8y4r4h" }, 44: { conditions: { mobile: "yv8y4r4j", tablet: "yv8y4r4k" }, defaultClass: "yv8y4r4j" }, 48: { conditions: { mobile: "yv8y4r4l", tablet: "yv8y4r4m" }, defaultClass: "yv8y4r4l" }, full: { conditions: { mobile: "yv8y4r4n", tablet: "yv8y4r4o" }, defaultClass: "yv8y4r4n" }, unset: { conditions: { mobile: "yv8y4r4p", tablet: "yv8y4r4q" }, defaultClass: "yv8y4r4p" }, auto: { conditions: { mobile: "yv8y4r4r", tablet: "yv8y4r4s" }, defaultClass: "yv8y4r4r" }, px: { conditions: { mobile: "yv8y4r4t", tablet: "yv8y4r4u" }, defaultClass: "yv8y4r4t" }, buttonMinHeight: { conditions: { mobile: "yv8y4r4v", tablet: "yv8y4r4w" }, defaultClass: "yv8y4r4v" } } }, marginBottom: { values: { 0: { conditions: { mobile: "yv8y4r4x", tablet: "yv8y4r4y" }, defaultClass: "yv8y4r4x" }, 1: { conditions: { mobile: "yv8y4r4z", tablet: "yv8y4r50" }, defaultClass: "yv8y4r4z" }, 2: { conditions: { mobile: "yv8y4r51", tablet: "yv8y4r52" }, defaultClass: "yv8y4r51" }, 3: { conditions: { mobile: "yv8y4r53", tablet: "yv8y4r54" }, defaultClass: "yv8y4r53" }, 4: { conditions: { mobile: "yv8y4r55", tablet: "yv8y4r56" }, defaultClass: "yv8y4r55" }, 5: { conditions: { mobile: "yv8y4r57", tablet: "yv8y4r58" }, defaultClass: "yv8y4r57" }, 6: { conditions: { mobile: "yv8y4r59", tablet: "yv8y4r5a" }, defaultClass: "yv8y4r59" }, 7: { conditions: { mobile: "yv8y4r5b", tablet: "yv8y4r5c" }, defaultClass: "yv8y4r5b" }, 8: { conditions: { mobile: "yv8y4r5d", tablet: "yv8y4r5e" }, defaultClass: "yv8y4r5d" }, 9: { conditions: { mobile: "yv8y4r5f", tablet: "yv8y4r5g" }, defaultClass: "yv8y4r5f" }, 10: { conditions: { mobile: "yv8y4r5h", tablet: "yv8y4r5i" }, defaultClass: "yv8y4r5h" }, 12: { conditions: { mobile: "yv8y4r5j", tablet: "yv8y4r5k" }, defaultClass: "yv8y4r5j" }, 14: { conditions: { mobile: "yv8y4r5l", tablet: "yv8y4r5m" }, defaultClass: "yv8y4r5l" }, 16: { conditions: { mobile: "yv8y4r5n", tablet: "yv8y4r5o" }, defaultClass: "yv8y4r5n" }, 20: { conditions: { mobile: "yv8y4r5p", tablet: "yv8y4r5q" }, defaultClass: "yv8y4r5p" }, 24: { conditions: { mobile: "yv8y4r5r", tablet: "yv8y4r5s" }, defaultClass: "yv8y4r5r" }, 28: { conditions: { mobile: "yv8y4r5t", tablet: "yv8y4r5u" }, defaultClass: "yv8y4r5t" }, 32: { conditions: { mobile: "yv8y4r5v", tablet: "yv8y4r5w" }, defaultClass: "yv8y4r5v" }, 36: { conditions: { mobile: "yv8y4r5x", tablet: "yv8y4r5y" }, defaultClass: "yv8y4r5x" }, 40: { conditions: { mobile: "yv8y4r5z", tablet: "yv8y4r60" }, defaultClass: "yv8y4r5z" }, 44: { conditions: { mobile: "yv8y4r61", tablet: "yv8y4r62" }, defaultClass: "yv8y4r61" }, 48: { conditions: { mobile: "yv8y4r63", tablet: "yv8y4r64" }, defaultClass: "yv8y4r63" }, full: { conditions: { mobile: "yv8y4r65", tablet: "yv8y4r66" }, defaultClass: "yv8y4r65" }, unset: { conditions: { mobile: "yv8y4r67", tablet: "yv8y4r68" }, defaultClass: "yv8y4r67" }, auto: { conditions: { mobile: "yv8y4r69", tablet: "yv8y4r6a" }, defaultClass: "yv8y4r69" }, px: { conditions: { mobile: "yv8y4r6b", tablet: "yv8y4r6c" }, defaultClass: "yv8y4r6b" }, buttonMinHeight: { conditions: { mobile: "yv8y4r6d", tablet: "yv8y4r6e" }, defaultClass: "yv8y4r6d" } } }, marginRight: { values: { 0: { conditions: { mobile: "yv8y4r6f", tablet: "yv8y4r6g" }, defaultClass: "yv8y4r6f" }, 1: { conditions: { mobile: "yv8y4r6h", tablet: "yv8y4r6i" }, defaultClass: "yv8y4r6h" }, 2: { conditions: { mobile: "yv8y4r6j", tablet: "yv8y4r6k" }, defaultClass: "yv8y4r6j" }, 3: { conditions: { mobile: "yv8y4r6l", tablet: "yv8y4r6m" }, defaultClass: "yv8y4r6l" }, 4: { conditions: { mobile: "yv8y4r6n", tablet: "yv8y4r6o" }, defaultClass: "yv8y4r6n" }, 5: { conditions: { mobile: "yv8y4r6p", tablet: "yv8y4r6q" }, defaultClass: "yv8y4r6p" }, 6: { conditions: { mobile: "yv8y4r6r", tablet: "yv8y4r6s" }, defaultClass: "yv8y4r6r" }, 7: { conditions: { mobile: "yv8y4r6t", tablet: "yv8y4r6u" }, defaultClass: "yv8y4r6t" }, 8: { conditions: { mobile: "yv8y4r6v", tablet: "yv8y4r6w" }, defaultClass: "yv8y4r6v" }, 9: { conditions: { mobile: "yv8y4r6x", tablet: "yv8y4r6y" }, defaultClass: "yv8y4r6x" }, 10: { conditions: { mobile: "yv8y4r6z", tablet: "yv8y4r70" }, defaultClass: "yv8y4r6z" }, 12: { conditions: { mobile: "yv8y4r71", tablet: "yv8y4r72" }, defaultClass: "yv8y4r71" }, 14: { conditions: { mobile: "yv8y4r73", tablet: "yv8y4r74" }, defaultClass: "yv8y4r73" }, 16: { conditions: { mobile: "yv8y4r75", tablet: "yv8y4r76" }, defaultClass: "yv8y4r75" }, 20: { conditions: { mobile: "yv8y4r77", tablet: "yv8y4r78" }, defaultClass: "yv8y4r77" }, 24: { conditions: { mobile: "yv8y4r79", tablet: "yv8y4r7a" }, defaultClass: "yv8y4r79" }, 28: { conditions: { mobile: "yv8y4r7b", tablet: "yv8y4r7c" }, defaultClass: "yv8y4r7b" }, 32: { conditions: { mobile: "yv8y4r7d", tablet: "yv8y4r7e" }, defaultClass: "yv8y4r7d" }, 36: { conditions: { mobile: "yv8y4r7f", tablet: "yv8y4r7g" }, defaultClass: "yv8y4r7f" }, 40: { conditions: { mobile: "yv8y4r7h", tablet: "yv8y4r7i" }, defaultClass: "yv8y4r7h" }, 44: { conditions: { mobile: "yv8y4r7j", tablet: "yv8y4r7k" }, defaultClass: "yv8y4r7j" }, 48: { conditions: { mobile: "yv8y4r7l", tablet: "yv8y4r7m" }, defaultClass: "yv8y4r7l" }, full: { conditions: { mobile: "yv8y4r7n", tablet: "yv8y4r7o" }, defaultClass: "yv8y4r7n" }, unset: { conditions: { mobile: "yv8y4r7p", tablet: "yv8y4r7q" }, defaultClass: "yv8y4r7p" }, auto: { conditions: { mobile: "yv8y4r7r", tablet: "yv8y4r7s" }, defaultClass: "yv8y4r7r" }, px: { conditions: { mobile: "yv8y4r7t", tablet: "yv8y4r7u" }, defaultClass: "yv8y4r7t" }, buttonMinHeight: { conditions: { mobile: "yv8y4r7v", tablet: "yv8y4r7w" }, defaultClass: "yv8y4r7v" } } }, marginLeft: { values: { 0: { conditions: { mobile: "yv8y4r7x", tablet: "yv8y4r7y" }, defaultClass: "yv8y4r7x" }, 1: { conditions: { mobile: "yv8y4r7z", tablet: "yv8y4r80" }, defaultClass: "yv8y4r7z" }, 2: { conditions: { mobile: "yv8y4r81", tablet: "yv8y4r82" }, defaultClass: "yv8y4r81" }, 3: { conditions: { mobile: "yv8y4r83", tablet: "yv8y4r84" }, defaultClass: "yv8y4r83" }, 4: { conditions: { mobile: "yv8y4r85", tablet: "yv8y4r86" }, defaultClass: "yv8y4r85" }, 5: { conditions: { mobile: "yv8y4r87", tablet: "yv8y4r88" }, defaultClass: "yv8y4r87" }, 6: { conditions: { mobile: "yv8y4r89", tablet: "yv8y4r8a" }, defaultClass: "yv8y4r89" }, 7: { conditions: { mobile: "yv8y4r8b", tablet: "yv8y4r8c" }, defaultClass: "yv8y4r8b" }, 8: { conditions: { mobile: "yv8y4r8d", tablet: "yv8y4r8e" }, defaultClass: "yv8y4r8d" }, 9: { conditions: { mobile: "yv8y4r8f", tablet: "yv8y4r8g" }, defaultClass: "yv8y4r8f" }, 10: { conditions: { mobile: "yv8y4r8h", tablet: "yv8y4r8i" }, defaultClass: "yv8y4r8h" }, 12: { conditions: { mobile: "yv8y4r8j", tablet: "yv8y4r8k" }, defaultClass: "yv8y4r8j" }, 14: { conditions: { mobile: "yv8y4r8l", tablet: "yv8y4r8m" }, defaultClass: "yv8y4r8l" }, 16: { conditions: { mobile: "yv8y4r8n", tablet: "yv8y4r8o" }, defaultClass: "yv8y4r8n" }, 20: { conditions: { mobile: "yv8y4r8p", tablet: "yv8y4r8q" }, defaultClass: "yv8y4r8p" }, 24: { conditions: { mobile: "yv8y4r8r", tablet: "yv8y4r8s" }, defaultClass: "yv8y4r8r" }, 28: { conditions: { mobile: "yv8y4r8t", tablet: "yv8y4r8u" }, defaultClass: "yv8y4r8t" }, 32: { conditions: { mobile: "yv8y4r8v", tablet: "yv8y4r8w" }, defaultClass: "yv8y4r8v" }, 36: { conditions: { mobile: "yv8y4r8x", tablet: "yv8y4r8y" }, defaultClass: "yv8y4r8x" }, 40: { conditions: { mobile: "yv8y4r8z", tablet: "yv8y4r90" }, defaultClass: "yv8y4r8z" }, 44: { conditions: { mobile: "yv8y4r91", tablet: "yv8y4r92" }, defaultClass: "yv8y4r91" }, 48: { conditions: { mobile: "yv8y4r93", tablet: "yv8y4r94" }, defaultClass: "yv8y4r93" }, full: { conditions: { mobile: "yv8y4r95", tablet: "yv8y4r96" }, defaultClass: "yv8y4r95" }, unset: { conditions: { mobile: "yv8y4r97", tablet: "yv8y4r98" }, defaultClass: "yv8y4r97" }, auto: { conditions: { mobile: "yv8y4r99", tablet: "yv8y4r9a" }, defaultClass: "yv8y4r99" }, px: { conditions: { mobile: "yv8y4r9b", tablet: "yv8y4r9c" }, defaultClass: "yv8y4r9b" }, buttonMinHeight: { conditions: { mobile: "yv8y4r9d", tablet: "yv8y4r9e" }, defaultClass: "yv8y4r9d" } } }, paddingTop: { values: { 0: { conditions: { mobile: "yv8y4r9f", tablet: "yv8y4r9g" }, defaultClass: "yv8y4r9f" }, 1: { conditions: { mobile: "yv8y4r9h", tablet: "yv8y4r9i" }, defaultClass: "yv8y4r9h" }, 2: { conditions: { mobile: "yv8y4r9j", tablet: "yv8y4r9k" }, defaultClass: "yv8y4r9j" }, 3: { conditions: { mobile: "yv8y4r9l", tablet: "yv8y4r9m" }, defaultClass: "yv8y4r9l" }, 4: { conditions: { mobile: "yv8y4r9n", tablet: "yv8y4r9o" }, defaultClass: "yv8y4r9n" }, 5: { conditions: { mobile: "yv8y4r9p", tablet: "yv8y4r9q" }, defaultClass: "yv8y4r9p" }, 6: { conditions: { mobile: "yv8y4r9r", tablet: "yv8y4r9s" }, defaultClass: "yv8y4r9r" }, 7: { conditions: { mobile: "yv8y4r9t", tablet: "yv8y4r9u" }, defaultClass: "yv8y4r9t" }, 8: { conditions: { mobile: "yv8y4r9v", tablet: "yv8y4r9w" }, defaultClass: "yv8y4r9v" }, 9: { conditions: { mobile: "yv8y4r9x", tablet: "yv8y4r9y" }, defaultClass: "yv8y4r9x" }, 10: { conditions: { mobile: "yv8y4r9z", tablet: "yv8y4ra0" }, defaultClass: "yv8y4r9z" }, 12: { conditions: { mobile: "yv8y4ra1", tablet: "yv8y4ra2" }, defaultClass: "yv8y4ra1" }, 14: { conditions: { mobile: "yv8y4ra3", tablet: "yv8y4ra4" }, defaultClass: "yv8y4ra3" }, 16: { conditions: { mobile: "yv8y4ra5", tablet: "yv8y4ra6" }, defaultClass: "yv8y4ra5" }, 20: { conditions: { mobile: "yv8y4ra7", tablet: "yv8y4ra8" }, defaultClass: "yv8y4ra7" }, 24: { conditions: { mobile: "yv8y4ra9", tablet: "yv8y4raa" }, defaultClass: "yv8y4ra9" }, 28: { conditions: { mobile: "yv8y4rab", tablet: "yv8y4rac" }, defaultClass: "yv8y4rab" }, 32: { conditions: { mobile: "yv8y4rad", tablet: "yv8y4rae" }, defaultClass: "yv8y4rad" }, 36: { conditions: { mobile: "yv8y4raf", tablet: "yv8y4rag" }, defaultClass: "yv8y4raf" }, 40: { conditions: { mobile: "yv8y4rah", tablet: "yv8y4rai" }, defaultClass: "yv8y4rah" }, 44: { conditions: { mobile: "yv8y4raj", tablet: "yv8y4rak" }, defaultClass: "yv8y4raj" }, 48: { conditions: { mobile: "yv8y4ral", tablet: "yv8y4ram" }, defaultClass: "yv8y4ral" }, full: { conditions: { mobile: "yv8y4ran", tablet: "yv8y4rao" }, defaultClass: "yv8y4ran" }, unset: { conditions: { mobile: "yv8y4rap", tablet: "yv8y4raq" }, defaultClass: "yv8y4rap" }, auto: { conditions: { mobile: "yv8y4rar", tablet: "yv8y4ras" }, defaultClass: "yv8y4rar" }, px: { conditions: { mobile: "yv8y4rat", tablet: "yv8y4rau" }, defaultClass: "yv8y4rat" }, buttonMinHeight: { conditions: { mobile: "yv8y4rav", tablet: "yv8y4raw" }, defaultClass: "yv8y4rav" } } }, paddingBottom: { values: { 0: { conditions: { mobile: "yv8y4rax", tablet: "yv8y4ray" }, defaultClass: "yv8y4rax" }, 1: { conditions: { mobile: "yv8y4raz", tablet: "yv8y4rb0" }, defaultClass: "yv8y4raz" }, 2: { conditions: { mobile: "yv8y4rb1", tablet: "yv8y4rb2" }, defaultClass: "yv8y4rb1" }, 3: { conditions: { mobile: "yv8y4rb3", tablet: "yv8y4rb4" }, defaultClass: "yv8y4rb3" }, 4: { conditions: { mobile: "yv8y4rb5", tablet: "yv8y4rb6" }, defaultClass: "yv8y4rb5" }, 5: { conditions: { mobile: "yv8y4rb7", tablet: "yv8y4rb8" }, defaultClass: "yv8y4rb7" }, 6: { conditions: { mobile: "yv8y4rb9", tablet: "yv8y4rba" }, defaultClass: "yv8y4rb9" }, 7: { conditions: { mobile: "yv8y4rbb", tablet: "yv8y4rbc" }, defaultClass: "yv8y4rbb" }, 8: { conditions: { mobile: "yv8y4rbd", tablet: "yv8y4rbe" }, defaultClass: "yv8y4rbd" }, 9: { conditions: { mobile: "yv8y4rbf", tablet: "yv8y4rbg" }, defaultClass: "yv8y4rbf" }, 10: { conditions: { mobile: "yv8y4rbh", tablet: "yv8y4rbi" }, defaultClass: "yv8y4rbh" }, 12: { conditions: { mobile: "yv8y4rbj", tablet: "yv8y4rbk" }, defaultClass: "yv8y4rbj" }, 14: { conditions: { mobile: "yv8y4rbl", tablet: "yv8y4rbm" }, defaultClass: "yv8y4rbl" }, 16: { conditions: { mobile: "yv8y4rbn", tablet: "yv8y4rbo" }, defaultClass: "yv8y4rbn" }, 20: { conditions: { mobile: "yv8y4rbp", tablet: "yv8y4rbq" }, defaultClass: "yv8y4rbp" }, 24: { conditions: { mobile: "yv8y4rbr", tablet: "yv8y4rbs" }, defaultClass: "yv8y4rbr" }, 28: { conditions: { mobile: "yv8y4rbt", tablet: "yv8y4rbu" }, defaultClass: "yv8y4rbt" }, 32: { conditions: { mobile: "yv8y4rbv", tablet: "yv8y4rbw" }, defaultClass: "yv8y4rbv" }, 36: { conditions: { mobile: "yv8y4rbx", tablet: "yv8y4rby" }, defaultClass: "yv8y4rbx" }, 40: { conditions: { mobile: "yv8y4rbz", tablet: "yv8y4rc0" }, defaultClass: "yv8y4rbz" }, 44: { conditions: { mobile: "yv8y4rc1", tablet: "yv8y4rc2" }, defaultClass: "yv8y4rc1" }, 48: { conditions: { mobile: "yv8y4rc3", tablet: "yv8y4rc4" }, defaultClass: "yv8y4rc3" }, full: { conditions: { mobile: "yv8y4rc5", tablet: "yv8y4rc6" }, defaultClass: "yv8y4rc5" }, unset: { conditions: { mobile: "yv8y4rc7", tablet: "yv8y4rc8" }, defaultClass: "yv8y4rc7" }, auto: { conditions: { mobile: "yv8y4rc9", tablet: "yv8y4rca" }, defaultClass: "yv8y4rc9" }, px: { conditions: { mobile: "yv8y4rcb", tablet: "yv8y4rcc" }, defaultClass: "yv8y4rcb" }, buttonMinHeight: { conditions: { mobile: "yv8y4rcd", tablet: "yv8y4rce" }, defaultClass: "yv8y4rcd" } } }, paddingRight: { values: { 0: { conditions: { mobile: "yv8y4rcf", tablet: "yv8y4rcg" }, defaultClass: "yv8y4rcf" }, 1: { conditions: { mobile: "yv8y4rch", tablet: "yv8y4rci" }, defaultClass: "yv8y4rch" }, 2: { conditions: { mobile: "yv8y4rcj", tablet: "yv8y4rck" }, defaultClass: "yv8y4rcj" }, 3: { conditions: { mobile: "yv8y4rcl", tablet: "yv8y4rcm" }, defaultClass: "yv8y4rcl" }, 4: { conditions: { mobile: "yv8y4rcn", tablet: "yv8y4rco" }, defaultClass: "yv8y4rcn" }, 5: { conditions: { mobile: "yv8y4rcp", tablet: "yv8y4rcq" }, defaultClass: "yv8y4rcp" }, 6: { conditions: { mobile: "yv8y4rcr", tablet: "yv8y4rcs" }, defaultClass: "yv8y4rcr" }, 7: { conditions: { mobile: "yv8y4rct", tablet: "yv8y4rcu" }, defaultClass: "yv8y4rct" }, 8: { conditions: { mobile: "yv8y4rcv", tablet: "yv8y4rcw" }, defaultClass: "yv8y4rcv" }, 9: { conditions: { mobile: "yv8y4rcx", tablet: "yv8y4rcy" }, defaultClass: "yv8y4rcx" }, 10: { conditions: { mobile: "yv8y4rcz", tablet: "yv8y4rd0" }, defaultClass: "yv8y4rcz" }, 12: { conditions: { mobile: "yv8y4rd1", tablet: "yv8y4rd2" }, defaultClass: "yv8y4rd1" }, 14: { conditions: { mobile: "yv8y4rd3", tablet: "yv8y4rd4" }, defaultClass: "yv8y4rd3" }, 16: { conditions: { mobile: "yv8y4rd5", tablet: "yv8y4rd6" }, defaultClass: "yv8y4rd5" }, 20: { conditions: { mobile: "yv8y4rd7", tablet: "yv8y4rd8" }, defaultClass: "yv8y4rd7" }, 24: { conditions: { mobile: "yv8y4rd9", tablet: "yv8y4rda" }, defaultClass: "yv8y4rd9" }, 28: { conditions: { mobile: "yv8y4rdb", tablet: "yv8y4rdc" }, defaultClass: "yv8y4rdb" }, 32: { conditions: { mobile: "yv8y4rdd", tablet: "yv8y4rde" }, defaultClass: "yv8y4rdd" }, 36: { conditions: { mobile: "yv8y4rdf", tablet: "yv8y4rdg" }, defaultClass: "yv8y4rdf" }, 40: { conditions: { mobile: "yv8y4rdh", tablet: "yv8y4rdi" }, defaultClass: "yv8y4rdh" }, 44: { conditions: { mobile: "yv8y4rdj", tablet: "yv8y4rdk" }, defaultClass: "yv8y4rdj" }, 48: { conditions: { mobile: "yv8y4rdl", tablet: "yv8y4rdm" }, defaultClass: "yv8y4rdl" }, full: { conditions: { mobile: "yv8y4rdn", tablet: "yv8y4rdo" }, defaultClass: "yv8y4rdn" }, unset: { conditions: { mobile: "yv8y4rdp", tablet: "yv8y4rdq" }, defaultClass: "yv8y4rdp" }, auto: { conditions: { mobile: "yv8y4rdr", tablet: "yv8y4rds" }, defaultClass: "yv8y4rdr" }, px: { conditions: { mobile: "yv8y4rdt", tablet: "yv8y4rdu" }, defaultClass: "yv8y4rdt" }, buttonMinHeight: { conditions: { mobile: "yv8y4rdv", tablet: "yv8y4rdw" }, defaultClass: "yv8y4rdv" } } }, paddingLeft: { values: { 0: { conditions: { mobile: "yv8y4rdx", tablet: "yv8y4rdy" }, defaultClass: "yv8y4rdx" }, 1: { conditions: { mobile: "yv8y4rdz", tablet: "yv8y4re0" }, defaultClass: "yv8y4rdz" }, 2: { conditions: { mobile: "yv8y4re1", tablet: "yv8y4re2" }, defaultClass: "yv8y4re1" }, 3: { conditions: { mobile: "yv8y4re3", tablet: "yv8y4re4" }, defaultClass: "yv8y4re3" }, 4: { conditions: { mobile: "yv8y4re5", tablet: "yv8y4re6" }, defaultClass: "yv8y4re5" }, 5: { conditions: { mobile: "yv8y4re7", tablet: "yv8y4re8" }, defaultClass: "yv8y4re7" }, 6: { conditions: { mobile: "yv8y4re9", tablet: "yv8y4rea" }, defaultClass: "yv8y4re9" }, 7: { conditions: { mobile: "yv8y4reb", tablet: "yv8y4rec" }, defaultClass: "yv8y4reb" }, 8: { conditions: { mobile: "yv8y4red", tablet: "yv8y4ree" }, defaultClass: "yv8y4red" }, 9: { conditions: { mobile: "yv8y4ref", tablet: "yv8y4reg" }, defaultClass: "yv8y4ref" }, 10: { conditions: { mobile: "yv8y4reh", tablet: "yv8y4rei" }, defaultClass: "yv8y4reh" }, 12: { conditions: { mobile: "yv8y4rej", tablet: "yv8y4rek" }, defaultClass: "yv8y4rej" }, 14: { conditions: { mobile: "yv8y4rel", tablet: "yv8y4rem" }, defaultClass: "yv8y4rel" }, 16: { conditions: { mobile: "yv8y4ren", tablet: "yv8y4reo" }, defaultClass: "yv8y4ren" }, 20: { conditions: { mobile: "yv8y4rep", tablet: "yv8y4req" }, defaultClass: "yv8y4rep" }, 24: { conditions: { mobile: "yv8y4rer", tablet: "yv8y4res" }, defaultClass: "yv8y4rer" }, 28: { conditions: { mobile: "yv8y4ret", tablet: "yv8y4reu" }, defaultClass: "yv8y4ret" }, 32: { conditions: { mobile: "yv8y4rev", tablet: "yv8y4rew" }, defaultClass: "yv8y4rev" }, 36: { conditions: { mobile: "yv8y4rex", tablet: "yv8y4rey" }, defaultClass: "yv8y4rex" }, 40: { conditions: { mobile: "yv8y4rez", tablet: "yv8y4rf0" }, defaultClass: "yv8y4rez" }, 44: { conditions: { mobile: "yv8y4rf1", tablet: "yv8y4rf2" }, defaultClass: "yv8y4rf1" }, 48: { conditions: { mobile: "yv8y4rf3", tablet: "yv8y4rf4" }, defaultClass: "yv8y4rf3" }, full: { conditions: { mobile: "yv8y4rf5", tablet: "yv8y4rf6" }, defaultClass: "yv8y4rf5" }, unset: { conditions: { mobile: "yv8y4rf7", tablet: "yv8y4rf8" }, defaultClass: "yv8y4rf7" }, auto: { conditions: { mobile: "yv8y4rf9", tablet: "yv8y4rfa" }, defaultClass: "yv8y4rf9" }, px: { conditions: { mobile: "yv8y4rfb", tablet: "yv8y4rfc" }, defaultClass: "yv8y4rfb" }, buttonMinHeight: { conditions: { mobile: "yv8y4rfd", tablet: "yv8y4rfe" }, defaultClass: "yv8y4rfd" } } }, alignItems: { values: { "flex-start": { conditions: { mobile: "yv8y4rff", tablet: "yv8y4rfg" }, defaultClass: "yv8y4rff" }, "flex-end": { conditions: { mobile: "yv8y4rfh", tablet: "yv8y4rfi" }, defaultClass: "yv8y4rfh" }, center: { conditions: { mobile: "yv8y4rfj", tablet: "yv8y4rfk" }, defaultClass: "yv8y4rfj" }, stretch: { conditions: { mobile: "yv8y4rfl", tablet: "yv8y4rfm" }, defaultClass: "yv8y4rfl" } } }, alignSelf: { values: { auto: { conditions: { mobile: "yv8y4rfn", tablet: "yv8y4rfo" }, defaultClass: "yv8y4rfn" }, "flex-start": { conditions: { mobile: "yv8y4rfp", tablet: "yv8y4rfq" }, defaultClass: "yv8y4rfp" }, "flex-end": { conditions: { mobile: "yv8y4rfr", tablet: "yv8y4rfs" }, defaultClass: "yv8y4rfr" }, center: { conditions: { mobile: "yv8y4rft", tablet: "yv8y4rfu" }, defaultClass: "yv8y4rft" }, stretch: { conditions: { mobile: "yv8y4rfv", tablet: "yv8y4rfw" }, defaultClass: "yv8y4rfv" } } }, justifyContent: { values: { "flex-start": { conditions: { mobile: "yv8y4rfx", tablet: "yv8y4rfy" }, defaultClass: "yv8y4rfx" }, "flex-end": { conditions: { mobile: "yv8y4rfz", tablet: "yv8y4rg0" }, defaultClass: "yv8y4rfz" }, center: { conditions: { mobile: "yv8y4rg1", tablet: "yv8y4rg2" }, defaultClass: "yv8y4rg1" }, "space-between": { conditions: { mobile: "yv8y4rg3", tablet: "yv8y4rg4" }, defaultClass: "yv8y4rg3" } } }, flexDirection: { values: { row: { conditions: { mobile: "yv8y4rg5", tablet: "yv8y4rg6" }, defaultClass: "yv8y4rg5" }, column: { conditions: { mobile: "yv8y4rg7", tablet: "yv8y4rg8" }, defaultClass: "yv8y4rg7" }, "row-reverse": { conditions: { mobile: "yv8y4rg9", tablet: "yv8y4rga" }, defaultClass: "yv8y4rg9" }, "column-reverse": { conditions: { mobile: "yv8y4rgb", tablet: "yv8y4rgc" }, defaultClass: "yv8y4rgb" } } }, flexWrap: { values: { wrap: { conditions: { mobile: "yv8y4rgd", tablet: "yv8y4rge" }, defaultClass: "yv8y4rgd" }, nowrap: { conditions: { mobile: "yv8y4rgf", tablet: "yv8y4rgg" }, defaultClass: "yv8y4rgf" } } }, height: { values: { 0: { conditions: { mobile: "yv8y4rgh", tablet: "yv8y4rgi" }, defaultClass: "yv8y4rgh" }, 1: { conditions: { mobile: "yv8y4rgj", tablet: "yv8y4rgk" }, defaultClass: "yv8y4rgj" }, 2: { conditions: { mobile: "yv8y4rgl", tablet: "yv8y4rgm" }, defaultClass: "yv8y4rgl" }, 3: { conditions: { mobile: "yv8y4rgn", tablet: "yv8y4rgo" }, defaultClass: "yv8y4rgn" }, 4: { conditions: { mobile: "yv8y4rgp", tablet: "yv8y4rgq" }, defaultClass: "yv8y4rgp" }, 5: { conditions: { mobile: "yv8y4rgr", tablet: "yv8y4rgs" }, defaultClass: "yv8y4rgr" }, 6: { conditions: { mobile: "yv8y4rgt", tablet: "yv8y4rgu" }, defaultClass: "yv8y4rgt" }, 7: { conditions: { mobile: "yv8y4rgv", tablet: "yv8y4rgw" }, defaultClass: "yv8y4rgv" }, 8: { conditions: { mobile: "yv8y4rgx", tablet: "yv8y4rgy" }, defaultClass: "yv8y4rgx" }, 9: { conditions: { mobile: "yv8y4rgz", tablet: "yv8y4rh0" }, defaultClass: "yv8y4rgz" }, 10: { conditions: { mobile: "yv8y4rh1", tablet: "yv8y4rh2" }, defaultClass: "yv8y4rh1" }, 12: { conditions: { mobile: "yv8y4rh3", tablet: "yv8y4rh4" }, defaultClass: "yv8y4rh3" }, 14: { conditions: { mobile: "yv8y4rh5", tablet: "yv8y4rh6" }, defaultClass: "yv8y4rh5" }, 16: { conditions: { mobile: "yv8y4rh7", tablet: "yv8y4rh8" }, defaultClass: "yv8y4rh7" }, 20: { conditions: { mobile: "yv8y4rh9", tablet: "yv8y4rha" }, defaultClass: "yv8y4rh9" }, 24: { conditions: { mobile: "yv8y4rhb", tablet: "yv8y4rhc" }, defaultClass: "yv8y4rhb" }, 28: { conditions: { mobile: "yv8y4rhd", tablet: "yv8y4rhe" }, defaultClass: "yv8y4rhd" }, 32: { conditions: { mobile: "yv8y4rhf", tablet: "yv8y4rhg" }, defaultClass: "yv8y4rhf" }, 36: { conditions: { mobile: "yv8y4rhh", tablet: "yv8y4rhi" }, defaultClass: "yv8y4rhh" }, 40: { conditions: { mobile: "yv8y4rhj", tablet: "yv8y4rhk" }, defaultClass: "yv8y4rhj" }, 44: { conditions: { mobile: "yv8y4rhl", tablet: "yv8y4rhm" }, defaultClass: "yv8y4rhl" }, 48: { conditions: { mobile: "yv8y4rhn", tablet: "yv8y4rho" }, defaultClass: "yv8y4rhn" }, full: { conditions: { mobile: "yv8y4rhp", tablet: "yv8y4rhq" }, defaultClass: "yv8y4rhp" }, unset: { conditions: { mobile: "yv8y4rhr", tablet: "yv8y4rhs" }, defaultClass: "yv8y4rhr" }, auto: { conditions: { mobile: "yv8y4rht", tablet: "yv8y4rhu" }, defaultClass: "yv8y4rht" }, px: { conditions: { mobile: "yv8y4rhv", tablet: "yv8y4rhw" }, defaultClass: "yv8y4rhv" }, buttonMinHeight: { conditions: { mobile: "yv8y4rhx", tablet: "yv8y4rhy" }, defaultClass: "yv8y4rhx" } } }, width: { values: { 0: { conditions: { mobile: "yv8y4rhz", tablet: "yv8y4ri0" }, defaultClass: "yv8y4rhz" }, 1: { conditions: { mobile: "yv8y4ri1", tablet: "yv8y4ri2" }, defaultClass: "yv8y4ri1" }, 2: { conditions: { mobile: "yv8y4ri3", tablet: "yv8y4ri4" }, defaultClass: "yv8y4ri3" }, 3: { conditions: { mobile: "yv8y4ri5", tablet: "yv8y4ri6" }, defaultClass: "yv8y4ri5" }, 4: { conditions: { mobile: "yv8y4ri7", tablet: "yv8y4ri8" }, defaultClass: "yv8y4ri7" }, 5: { conditions: { mobile: "yv8y4ri9", tablet: "yv8y4ria" }, defaultClass: "yv8y4ri9" }, 6: { conditions: { mobile: "yv8y4rib", tablet: "yv8y4ric" }, defaultClass: "yv8y4rib" }, 7: { conditions: { mobile: "yv8y4rid", tablet: "yv8y4rie" }, defaultClass: "yv8y4rid" }, 8: { conditions: { mobile: "yv8y4rif", tablet: "yv8y4rig" }, defaultClass: "yv8y4rif" }, 9: { conditions: { mobile: "yv8y4rih", tablet: "yv8y4rii" }, defaultClass: "yv8y4rih" }, 10: { conditions: { mobile: "yv8y4rij", tablet: "yv8y4rik" }, defaultClass: "yv8y4rij" }, 12: { conditions: { mobile: "yv8y4ril", tablet: "yv8y4rim" }, defaultClass: "yv8y4ril" }, 14: { conditions: { mobile: "yv8y4rin", tablet: "yv8y4rio" }, defaultClass: "yv8y4rin" }, 16: { conditions: { mobile: "yv8y4rip", tablet: "yv8y4riq" }, defaultClass: "yv8y4rip" }, 20: { conditions: { mobile: "yv8y4rir", tablet: "yv8y4ris" }, defaultClass: "yv8y4rir" }, 24: { conditions: { mobile: "yv8y4rit", tablet: "yv8y4riu" }, defaultClass: "yv8y4rit" }, 28: { conditions: { mobile: "yv8y4riv", tablet: "yv8y4riw" }, defaultClass: "yv8y4riv" }, 32: { conditions: { mobile: "yv8y4rix", tablet: "yv8y4riy" }, defaultClass: "yv8y4rix" }, 36: { conditions: { mobile: "yv8y4riz", tablet: "yv8y4rj0" }, defaultClass: "yv8y4riz" }, 40: { conditions: { mobile: "yv8y4rj1", tablet: "yv8y4rj2" }, defaultClass: "yv8y4rj1" }, 44: { conditions: { mobile: "yv8y4rj3", tablet: "yv8y4rj4" }, defaultClass: "yv8y4rj3" }, 48: { conditions: { mobile: "yv8y4rj5", tablet: "yv8y4rj6" }, defaultClass: "yv8y4rj5" }, full: { conditions: { mobile: "yv8y4rj7", tablet: "yv8y4rj8" }, defaultClass: "yv8y4rj7" }, unset: { conditions: { mobile: "yv8y4rj9", tablet: "yv8y4rja" }, defaultClass: "yv8y4rj9" }, auto: { conditions: { mobile: "yv8y4rjb", tablet: "yv8y4rjc" }, defaultClass: "yv8y4rjb" }, px: { conditions: { mobile: "yv8y4rjd", tablet: "yv8y4rje" }, defaultClass: "yv8y4rjd" }, buttonMinHeight: { conditions: { mobile: "yv8y4rjf", tablet: "yv8y4rjg" }, defaultClass: "yv8y4rjf" } } }, minWidth: { values: { 0: { conditions: { mobile: "yv8y4rjh", tablet: "yv8y4rji" }, defaultClass: "yv8y4rjh" }, 1: { conditions: { mobile: "yv8y4rjj", tablet: "yv8y4rjk" }, defaultClass: "yv8y4rjj" }, 2: { conditions: { mobile: "yv8y4rjl", tablet: "yv8y4rjm" }, defaultClass: "yv8y4rjl" }, 3: { conditions: { mobile: "yv8y4rjn", tablet: "yv8y4rjo" }, defaultClass: "yv8y4rjn" }, 4: { conditions: { mobile: "yv8y4rjp", tablet: "yv8y4rjq" }, defaultClass: "yv8y4rjp" }, 5: { conditions: { mobile: "yv8y4rjr", tablet: "yv8y4rjs" }, defaultClass: "yv8y4rjr" }, 6: { conditions: { mobile: "yv8y4rjt", tablet: "yv8y4rju" }, defaultClass: "yv8y4rjt" }, 7: { conditions: { mobile: "yv8y4rjv", tablet: "yv8y4rjw" }, defaultClass: "yv8y4rjv" }, 8: { conditions: { mobile: "yv8y4rjx", tablet: "yv8y4rjy" }, defaultClass: "yv8y4rjx" }, 9: { conditions: { mobile: "yv8y4rjz", tablet: "yv8y4rk0" }, defaultClass: "yv8y4rjz" }, 10: { conditions: { mobile: "yv8y4rk1", tablet: "yv8y4rk2" }, defaultClass: "yv8y4rk1" }, 12: { conditions: { mobile: "yv8y4rk3", tablet: "yv8y4rk4" }, defaultClass: "yv8y4rk3" }, 14: { conditions: { mobile: "yv8y4rk5", tablet: "yv8y4rk6" }, defaultClass: "yv8y4rk5" }, 16: { conditions: { mobile: "yv8y4rk7", tablet: "yv8y4rk8" }, defaultClass: "yv8y4rk7" }, 20: { conditions: { mobile: "yv8y4rk9", tablet: "yv8y4rka" }, defaultClass: "yv8y4rk9" }, 24: { conditions: { mobile: "yv8y4rkb", tablet: "yv8y4rkc" }, defaultClass: "yv8y4rkb" }, 28: { conditions: { mobile: "yv8y4rkd", tablet: "yv8y4rke" }, defaultClass: "yv8y4rkd" }, 32: { conditions: { mobile: "yv8y4rkf", tablet: "yv8y4rkg" }, defaultClass: "yv8y4rkf" }, 36: { conditions: { mobile: "yv8y4rkh", tablet: "yv8y4rki" }, defaultClass: "yv8y4rkh" }, 40: { conditions: { mobile: "yv8y4rkj", tablet: "yv8y4rkk" }, defaultClass: "yv8y4rkj" }, 44: { conditions: { mobile: "yv8y4rkl", tablet: "yv8y4rkm" }, defaultClass: "yv8y4rkl" }, 48: { conditions: { mobile: "yv8y4rkn", tablet: "yv8y4rko" }, defaultClass: "yv8y4rkn" }, full: { conditions: { mobile: "yv8y4rkp", tablet: "yv8y4rkq" }, defaultClass: "yv8y4rkp" }, unset: { conditions: { mobile: "yv8y4rkr", tablet: "yv8y4rks" }, defaultClass: "yv8y4rkr" }, auto: { conditions: { mobile: "yv8y4rkt", tablet: "yv8y4rku" }, defaultClass: "yv8y4rkt" }, px: { conditions: { mobile: "yv8y4rkv", tablet: "yv8y4rkw" }, defaultClass: "yv8y4rkv" }, buttonMinHeight: { conditions: { mobile: "yv8y4rkx", tablet: "yv8y4rky" }, defaultClass: "yv8y4rkx" } } }, minHeight: { values: { 0: { conditions: { mobile: "yv8y4rkz", tablet: "yv8y4rl0" }, defaultClass: "yv8y4rkz" }, 1: { conditions: { mobile: "yv8y4rl1", tablet: "yv8y4rl2" }, defaultClass: "yv8y4rl1" }, 2: { conditions: { mobile: "yv8y4rl3", tablet: "yv8y4rl4" }, defaultClass: "yv8y4rl3" }, 3: { conditions: { mobile: "yv8y4rl5", tablet: "yv8y4rl6" }, defaultClass: "yv8y4rl5" }, 4: { conditions: { mobile: "yv8y4rl7", tablet: "yv8y4rl8" }, defaultClass: "yv8y4rl7" }, 5: { conditions: { mobile: "yv8y4rl9", tablet: "yv8y4rla" }, defaultClass: "yv8y4rl9" }, 6: { conditions: { mobile: "yv8y4rlb", tablet: "yv8y4rlc" }, defaultClass: "yv8y4rlb" }, 7: { conditions: { mobile: "yv8y4rld", tablet: "yv8y4rle" }, defaultClass: "yv8y4rld" }, 8: { conditions: { mobile: "yv8y4rlf", tablet: "yv8y4rlg" }, defaultClass: "yv8y4rlf" }, 9: { conditions: { mobile: "yv8y4rlh", tablet: "yv8y4rli" }, defaultClass: "yv8y4rlh" }, 10: { conditions: { mobile: "yv8y4rlj", tablet: "yv8y4rlk" }, defaultClass: "yv8y4rlj" }, 12: { conditions: { mobile: "yv8y4rll", tablet: "yv8y4rlm" }, defaultClass: "yv8y4rll" }, 14: { conditions: { mobile: "yv8y4rln", tablet: "yv8y4rlo" }, defaultClass: "yv8y4rln" }, 16: { conditions: { mobile: "yv8y4rlp", tablet: "yv8y4rlq" }, defaultClass: "yv8y4rlp" }, 20: { conditions: { mobile: "yv8y4rlr", tablet: "yv8y4rls" }, defaultClass: "yv8y4rlr" }, 24: { conditions: { mobile: "yv8y4rlt", tablet: "yv8y4rlu" }, defaultClass: "yv8y4rlt" }, 28: { conditions: { mobile: "yv8y4rlv", tablet: "yv8y4rlw" }, defaultClass: "yv8y4rlv" }, 32: { conditions: { mobile: "yv8y4rlx", tablet: "yv8y4rly" }, defaultClass: "yv8y4rlx" }, 36: { conditions: { mobile: "yv8y4rlz", tablet: "yv8y4rm0" }, defaultClass: "yv8y4rlz" }, 40: { conditions: { mobile: "yv8y4rm1", tablet: "yv8y4rm2" }, defaultClass: "yv8y4rm1" }, 44: { conditions: { mobile: "yv8y4rm3", tablet: "yv8y4rm4" }, defaultClass: "yv8y4rm3" }, 48: { conditions: { mobile: "yv8y4rm5", tablet: "yv8y4rm6" }, defaultClass: "yv8y4rm5" }, full: { conditions: { mobile: "yv8y4rm7", tablet: "yv8y4rm8" }, defaultClass: "yv8y4rm7" }, unset: { conditions: { mobile: "yv8y4rm9", tablet: "yv8y4rma" }, defaultClass: "yv8y4rm9" }, auto: { conditions: { mobile: "yv8y4rmb", tablet: "yv8y4rmc" }, defaultClass: "yv8y4rmb" }, px: { conditions: { mobile: "yv8y4rmd", tablet: "yv8y4rme" }, defaultClass: "yv8y4rmd" }, buttonMinHeight: { conditions: { mobile: "yv8y4rmf", tablet: "yv8y4rmg" }, defaultClass: "yv8y4rmf" } } }, maxWidth: { values: { 0: { conditions: { mobile: "yv8y4rmh", tablet: "yv8y4rmi" }, defaultClass: "yv8y4rmh" }, 1: { conditions: { mobile: "yv8y4rmj", tablet: "yv8y4rmk" }, defaultClass: "yv8y4rmj" }, 2: { conditions: { mobile: "yv8y4rml", tablet: "yv8y4rmm" }, defaultClass: "yv8y4rml" }, 3: { conditions: { mobile: "yv8y4rmn", tablet: "yv8y4rmo" }, defaultClass: "yv8y4rmn" }, 4: { conditions: { mobile: "yv8y4rmp", tablet: "yv8y4rmq" }, defaultClass: "yv8y4rmp" }, 5: { conditions: { mobile: "yv8y4rmr", tablet: "yv8y4rms" }, defaultClass: "yv8y4rmr" }, 6: { conditions: { mobile: "yv8y4rmt", tablet: "yv8y4rmu" }, defaultClass: "yv8y4rmt" }, 7: { conditions: { mobile: "yv8y4rmv", tablet: "yv8y4rmw" }, defaultClass: "yv8y4rmv" }, 8: { conditions: { mobile: "yv8y4rmx", tablet: "yv8y4rmy" }, defaultClass: "yv8y4rmx" }, 9: { conditions: { mobile: "yv8y4rmz", tablet: "yv8y4rn0" }, defaultClass: "yv8y4rmz" }, 10: { conditions: { mobile: "yv8y4rn1", tablet: "yv8y4rn2" }, defaultClass: "yv8y4rn1" }, 12: { conditions: { mobile: "yv8y4rn3", tablet: "yv8y4rn4" }, defaultClass: "yv8y4rn3" }, 14: { conditions: { mobile: "yv8y4rn5", tablet: "yv8y4rn6" }, defaultClass: "yv8y4rn5" }, 16: { conditions: { mobile: "yv8y4rn7", tablet: "yv8y4rn8" }, defaultClass: "yv8y4rn7" }, 20: { conditions: { mobile: "yv8y4rn9", tablet: "yv8y4rna" }, defaultClass: "yv8y4rn9" }, 24: { conditions: { mobile: "yv8y4rnb", tablet: "yv8y4rnc" }, defaultClass: "yv8y4rnb" }, 28: { conditions: { mobile: "yv8y4rnd", tablet: "yv8y4rne" }, defaultClass: "yv8y4rnd" }, 32: { conditions: { mobile: "yv8y4rnf", tablet: "yv8y4rng" }, defaultClass: "yv8y4rnf" }, 36: { conditions: { mobile: "yv8y4rnh", tablet: "yv8y4rni" }, defaultClass: "yv8y4rnh" }, 40: { conditions: { mobile: "yv8y4rnj", tablet: "yv8y4rnk" }, defaultClass: "yv8y4rnj" }, 44: { conditions: { mobile: "yv8y4rnl", tablet: "yv8y4rnm" }, defaultClass: "yv8y4rnl" }, 48: { conditions: { mobile: "yv8y4rnn", tablet: "yv8y4rno" }, defaultClass: "yv8y4rnn" }, full: { conditions: { mobile: "yv8y4rnp", tablet: "yv8y4rnq" }, defaultClass: "yv8y4rnp" }, unset: { conditions: { mobile: "yv8y4rnr", tablet: "yv8y4rns" }, defaultClass: "yv8y4rnr" }, auto: { conditions: { mobile: "yv8y4rnt", tablet: "yv8y4rnu" }, defaultClass: "yv8y4rnt" }, px: { conditions: { mobile: "yv8y4rnv", tablet: "yv8y4rnw" }, defaultClass: "yv8y4rnv" }, buttonMinHeight: { conditions: { mobile: "yv8y4rnx", tablet: "yv8y4rny" }, defaultClass: "yv8y4rnx" } } }, maxHeight: { values: { 0: { conditions: { mobile: "yv8y4rnz", tablet: "yv8y4ro0" }, defaultClass: "yv8y4rnz" }, 1: { conditions: { mobile: "yv8y4ro1", tablet: "yv8y4ro2" }, defaultClass: "yv8y4ro1" }, 2: { conditions: { mobile: "yv8y4ro3", tablet: "yv8y4ro4" }, defaultClass: "yv8y4ro3" }, 3: { conditions: { mobile: "yv8y4ro5", tablet: "yv8y4ro6" }, defaultClass: "yv8y4ro5" }, 4: { conditions: { mobile: "yv8y4ro7", tablet: "yv8y4ro8" }, defaultClass: "yv8y4ro7" }, 5: { conditions: { mobile: "yv8y4ro9", tablet: "yv8y4roa" }, defaultClass: "yv8y4ro9" }, 6: { conditions: { mobile: "yv8y4rob", tablet: "yv8y4roc" }, defaultClass: "yv8y4rob" }, 7: { conditions: { mobile: "yv8y4rod", tablet: "yv8y4roe" }, defaultClass: "yv8y4rod" }, 8: { conditions: { mobile: "yv8y4rof", tablet: "yv8y4rog" }, defaultClass: "yv8y4rof" }, 9: { conditions: { mobile: "yv8y4roh", tablet: "yv8y4roi" }, defaultClass: "yv8y4roh" }, 10: { conditions: { mobile: "yv8y4roj", tablet: "yv8y4rok" }, defaultClass: "yv8y4roj" }, 12: { conditions: { mobile: "yv8y4rol", tablet: "yv8y4rom" }, defaultClass: "yv8y4rol" }, 14: { conditions: { mobile: "yv8y4ron", tablet: "yv8y4roo" }, defaultClass: "yv8y4ron" }, 16: { conditions: { mobile: "yv8y4rop", tablet: "yv8y4roq" }, defaultClass: "yv8y4rop" }, 20: { conditions: { mobile: "yv8y4ror", tablet: "yv8y4ros" }, defaultClass: "yv8y4ror" }, 24: { conditions: { mobile: "yv8y4rot", tablet: "yv8y4rou" }, defaultClass: "yv8y4rot" }, 28: { conditions: { mobile: "yv8y4rov", tablet: "yv8y4row" }, defaultClass: "yv8y4rov" }, 32: { conditions: { mobile: "yv8y4rox", tablet: "yv8y4roy" }, defaultClass: "yv8y4rox" }, 36: { conditions: { mobile: "yv8y4roz", tablet: "yv8y4rp0" }, defaultClass: "yv8y4roz" }, 40: { conditions: { mobile: "yv8y4rp1", tablet: "yv8y4rp2" }, defaultClass: "yv8y4rp1" }, 44: { conditions: { mobile: "yv8y4rp3", tablet: "yv8y4rp4" }, defaultClass: "yv8y4rp3" }, 48: { conditions: { mobile: "yv8y4rp5", tablet: "yv8y4rp6" }, defaultClass: "yv8y4rp5" }, full: { conditions: { mobile: "yv8y4rp7", tablet: "yv8y4rp8" }, defaultClass: "yv8y4rp7" }, unset: { conditions: { mobile: "yv8y4rp9", tablet: "yv8y4rpa" }, defaultClass: "yv8y4rp9" }, auto: { conditions: { mobile: "yv8y4rpb", tablet: "yv8y4rpc" }, defaultClass: "yv8y4rpb" }, px: { conditions: { mobile: "yv8y4rpd", tablet: "yv8y4rpe" }, defaultClass: "yv8y4rpd" }, buttonMinHeight: { conditions: { mobile: "yv8y4rpf", tablet: "yv8y4rpg" }, defaultClass: "yv8y4rpf" } } }, gap: { values: { 0: { conditions: { mobile: "yv8y4rph", tablet: "yv8y4rpi" }, defaultClass: "yv8y4rph" }, 1: { conditions: { mobile: "yv8y4rpj", tablet: "yv8y4rpk" }, defaultClass: "yv8y4rpj" }, 2: { conditions: { mobile: "yv8y4rpl", tablet: "yv8y4rpm" }, defaultClass: "yv8y4rpl" }, 3: { conditions: { mobile: "yv8y4rpn", tablet: "yv8y4rpo" }, defaultClass: "yv8y4rpn" }, 4: { conditions: { mobile: "yv8y4rpp", tablet: "yv8y4rpq" }, defaultClass: "yv8y4rpp" }, 5: { conditions: { mobile: "yv8y4rpr", tablet: "yv8y4rps" }, defaultClass: "yv8y4rpr" }, 6: { conditions: { mobile: "yv8y4rpt", tablet: "yv8y4rpu" }, defaultClass: "yv8y4rpt" }, 7: { conditions: { mobile: "yv8y4rpv", tablet: "yv8y4rpw" }, defaultClass: "yv8y4rpv" }, 8: { conditions: { mobile: "yv8y4rpx", tablet: "yv8y4rpy" }, defaultClass: "yv8y4rpx" }, 9: { conditions: { mobile: "yv8y4rpz", tablet: "yv8y4rq0" }, defaultClass: "yv8y4rpz" }, 10: { conditions: { mobile: "yv8y4rq1", tablet: "yv8y4rq2" }, defaultClass: "yv8y4rq1" }, 12: { conditions: { mobile: "yv8y4rq3", tablet: "yv8y4rq4" }, defaultClass: "yv8y4rq3" }, 14: { conditions: { mobile: "yv8y4rq5", tablet: "yv8y4rq6" }, defaultClass: "yv8y4rq5" }, 16: { conditions: { mobile: "yv8y4rq7", tablet: "yv8y4rq8" }, defaultClass: "yv8y4rq7" }, 20: { conditions: { mobile: "yv8y4rq9", tablet: "yv8y4rqa" }, defaultClass: "yv8y4rq9" }, 24: { conditions: { mobile: "yv8y4rqb", tablet: "yv8y4rqc" }, defaultClass: "yv8y4rqb" }, 28: { conditions: { mobile: "yv8y4rqd", tablet: "yv8y4rqe" }, defaultClass: "yv8y4rqd" }, 32: { conditions: { mobile: "yv8y4rqf", tablet: "yv8y4rqg" }, defaultClass: "yv8y4rqf" }, 36: { conditions: { mobile: "yv8y4rqh", tablet: "yv8y4rqi" }, defaultClass: "yv8y4rqh" }, 40: { conditions: { mobile: "yv8y4rqj", tablet: "yv8y4rqk" }, defaultClass: "yv8y4rqj" }, 44: { conditions: { mobile: "yv8y4rql", tablet: "yv8y4rqm" }, defaultClass: "yv8y4rql" }, 48: { conditions: { mobile: "yv8y4rqn", tablet: "yv8y4rqo" }, defaultClass: "yv8y4rqn" }, full: { conditions: { mobile: "yv8y4rqp", tablet: "yv8y4rqq" }, defaultClass: "yv8y4rqp" }, unset: { conditions: { mobile: "yv8y4rqr", tablet: "yv8y4rqs" }, defaultClass: "yv8y4rqr" }, auto: { conditions: { mobile: "yv8y4rqt", tablet: "yv8y4rqu" }, defaultClass: "yv8y4rqt" }, px: { conditions: { mobile: "yv8y4rqv", tablet: "yv8y4rqw" }, defaultClass: "yv8y4rqv" }, buttonMinHeight: { conditions: { mobile: "yv8y4rqx", tablet: "yv8y4rqy" }, defaultClass: "yv8y4rqx" } } } } }, { conditions: { defaultCondition: ["dark", "light"], conditionNames: ["light", "dark"], responsiveArray: void 0 }, styles: { color: { values: { white: { conditions: { light: "yv8y4rqz", dark: "yv8y4rr0" }, defaultClass: "yv8y4rqz yv8y4rr0" }, black: { conditions: { light: "yv8y4rr1", dark: "yv8y4rr2" }, defaultClass: "yv8y4rr1 yv8y4rr2" }, transparent: { conditions: { light: "yv8y4rr3", dark: "yv8y4rr4" }, defaultClass: "yv8y4rr3 yv8y4rr4" }, primary: { conditions: { light: "yv8y4rr5", dark: "yv8y4rr6" }, defaultClass: "yv8y4rr5 yv8y4rr6" }, accent: { conditions: { light: "yv8y4rr7", dark: "yv8y4rr8" }, defaultClass: "yv8y4rr7 yv8y4rr8" }, disabled: { conditions: { light: "yv8y4rr9", dark: "yv8y4rra" }, defaultClass: "yv8y4rr9 yv8y4rra" }, text: { conditions: { light: "yv8y4rrb", dark: "yv8y4rrc" }, defaultClass: "yv8y4rrb yv8y4rrc" }, textMuted: { conditions: { light: "yv8y4rrd", dark: "yv8y4rre" }, defaultClass: "yv8y4rrd yv8y4rre" }, textDanger: { conditions: { light: "yv8y4rrf", dark: "yv8y4rrg" }, defaultClass: "yv8y4rrf yv8y4rrg" }, background: { conditions: { light: "yv8y4rrh", dark: "yv8y4rri" }, defaultClass: "yv8y4rrh yv8y4rri" }, backgroundMuted: { conditions: { light: "yv8y4rrj", dark: "yv8y4rrk" }, defaultClass: "yv8y4rrj yv8y4rrk" }, tokenSelectBackground: { conditions: { light: "yv8y4rrl", dark: "yv8y4rrm" }, defaultClass: "yv8y4rrl yv8y4rrm" }, tokenSelectHoverBackground: { conditions: { light: "yv8y4rrn", dark: "yv8y4rro" }, defaultClass: "yv8y4rrn yv8y4rro" }, tokenSelect: { conditions: { light: "yv8y4rrp", dark: "yv8y4rrq" }, defaultClass: "yv8y4rrp yv8y4rrq" }, skeletonLoaderBase: { conditions: { light: "yv8y4rrr", dark: "yv8y4rrs" }, defaultClass: "yv8y4rrr yv8y4rrs" }, skeletonLoaderHighlight: { conditions: { light: "yv8y4rrt", dark: "yv8y4rru" }, defaultClass: "yv8y4rrt yv8y4rru" }, tabBorder: { conditions: { light: "yv8y4rrv", dark: "yv8y4rrw" }, defaultClass: "yv8y4rrv yv8y4rrw" }, stakeSectionBackground: { conditions: { light: "yv8y4rrx", dark: "yv8y4rry" }, defaultClass: "yv8y4rrx yv8y4rry" }, dropdownBackground: { conditions: { light: "yv8y4rrz", dark: "yv8y4rs0" }, defaultClass: "yv8y4rrz yv8y4rs0" }, selectValidatorMultiSelectedBackground: { conditions: { light: "yv8y4rs1", dark: "yv8y4rs2" }, defaultClass: "yv8y4rs1 yv8y4rs2" }, selectValidatorMultiDefaultBackground: { conditions: { light: "yv8y4rs3", dark: "yv8y4rs4" }, defaultClass: "yv8y4rs3 yv8y4rs4" }, warningBoxBackground: { conditions: { light: "yv8y4rs5", dark: "yv8y4rs6" }, defaultClass: "yv8y4rs5 yv8y4rs6" }, positionsSectionBackgroundColor: { conditions: { light: "yv8y4rs7", dark: "yv8y4rs8" }, defaultClass: "yv8y4rs7 yv8y4rs8" }, positionsSectionBorderColor: { conditions: { light: "yv8y4rs9", dark: "yv8y4rsa" }, defaultClass: "yv8y4rs9 yv8y4rsa" }, positionsSectionDividerColor: { conditions: { light: "yv8y4rsb", dark: "yv8y4rsc" }, defaultClass: "yv8y4rsb yv8y4rsc" }, positionsClaimRewardsBackground: { conditions: { light: "yv8y4rsd", dark: "yv8y4rse" }, defaultClass: "yv8y4rsd yv8y4rse" }, positionsActionRequiredBackground: { conditions: { light: "yv8y4rsf", dark: "yv8y4rsg" }, defaultClass: "yv8y4rsf yv8y4rsg" }, positionsPendingBackground: { conditions: { light: "yv8y4rsh", dark: "yv8y4rsi" }, defaultClass: "yv8y4rsh yv8y4rsi" }, modalOverlayBackground: { conditions: { light: "yv8y4rsj", dark: "yv8y4rsk" }, defaultClass: "yv8y4rsj yv8y4rsk" }, modalBodyBackground: { conditions: { light: "yv8y4rsl", dark: "yv8y4rsm" }, defaultClass: "yv8y4rsl yv8y4rsm" }, tooltipBackground: { conditions: { light: "yv8y4rsn", dark: "yv8y4rso" }, defaultClass: "yv8y4rsn yv8y4rso" }, primaryButtonColor: { conditions: { light: "yv8y4rsp", dark: "yv8y4rsq" }, defaultClass: "yv8y4rsp yv8y4rsq" }, primaryButtonBackground: { conditions: { light: "yv8y4rsr", dark: "yv8y4rss" }, defaultClass: "yv8y4rsr yv8y4rss" }, primaryButtonOutline: { conditions: { light: "yv8y4rst", dark: "yv8y4rsu" }, defaultClass: "yv8y4rst yv8y4rsu" }, primaryButtonHoverColor: { conditions: { light: "yv8y4rsv", dark: "yv8y4rsw" }, defaultClass: "yv8y4rsv yv8y4rsw" }, primaryButtonHoverBackground: { conditions: { light: "yv8y4rsx", dark: "yv8y4rsy" }, defaultClass: "yv8y4rsx yv8y4rsy" }, primaryButtonHoverOutline: { conditions: { light: "yv8y4rsz", dark: "yv8y4rt0" }, defaultClass: "yv8y4rsz yv8y4rt0" }, primaryButtonActiveColor: { conditions: { light: "yv8y4rt1", dark: "yv8y4rt2" }, defaultClass: "yv8y4rt1 yv8y4rt2" }, primaryButtonActiveBackground: { conditions: { light: "yv8y4rt3", dark: "yv8y4rt4" }, defaultClass: "yv8y4rt3 yv8y4rt4" }, primaryButtonActiveOutline: { conditions: { light: "yv8y4rt5", dark: "yv8y4rt6" }, defaultClass: "yv8y4rt5 yv8y4rt6" }, secondaryButtonColor: { conditions: { light: "yv8y4rt7", dark: "yv8y4rt8" }, defaultClass: "yv8y4rt7 yv8y4rt8" }, secondaryButtonBackground: { conditions: { light: "yv8y4rt9", dark: "yv8y4rta" }, defaultClass: "yv8y4rt9 yv8y4rta" }, secondaryButtonOutline: { conditions: { light: "yv8y4rtb", dark: "yv8y4rtc" }, defaultClass: "yv8y4rtb yv8y4rtc" }, secondaryButtonHoverColor: { conditions: { light: "yv8y4rtd", dark: "yv8y4rte" }, defaultClass: "yv8y4rtd yv8y4rte" }, secondaryButtonHoverBackground: { conditions: { light: "yv8y4rtf", dark: "yv8y4rtg" }, defaultClass: "yv8y4rtf yv8y4rtg" }, secondaryButtonHoverOutline: { conditions: { light: "yv8y4rth", dark: "yv8y4rti" }, defaultClass: "yv8y4rth yv8y4rti" }, secondaryButtonActiveColor: { conditions: { light: "yv8y4rtj", dark: "yv8y4rtk" }, defaultClass: "yv8y4rtj yv8y4rtk" }, secondaryButtonActiveBackground: { conditions: { light: "yv8y4rtl", dark: "yv8y4rtm" }, defaultClass: "yv8y4rtl yv8y4rtm" }, secondaryButtonActiveOutline: { conditions: { light: "yv8y4rtn", dark: "yv8y4rto" }, defaultClass: "yv8y4rtn yv8y4rto" }, smallButtonColor: { conditions: { light: "yv8y4rtp", dark: "yv8y4rtq" }, defaultClass: "yv8y4rtp yv8y4rtq" }, smallButtonBackground: { conditions: { light: "yv8y4rtr", dark: "yv8y4rts" }, defaultClass: "yv8y4rtr yv8y4rts" }, smallButtonOutline: { conditions: { light: "yv8y4rtt", dark: "yv8y4rtu" }, defaultClass: "yv8y4rtt yv8y4rtu" }, smallButtonHoverColor: { conditions: { light: "yv8y4rtv", dark: "yv8y4rtw" }, defaultClass: "yv8y4rtv yv8y4rtw" }, smallButtonHoverBackground: { conditions: { light: "yv8y4rtx", dark: "yv8y4rty" }, defaultClass: "yv8y4rtx yv8y4rty" }, smallButtonHoverOutline: { conditions: { light: "yv8y4rtz", dark: "yv8y4ru0" }, defaultClass: "yv8y4rtz yv8y4ru0" }, smallButtonActiveColor: { conditions: { light: "yv8y4ru1", dark: "yv8y4ru2" }, defaultClass: "yv8y4ru1 yv8y4ru2" }, smallButtonActiveBackground: { conditions: { light: "yv8y4ru3", dark: "yv8y4ru4" }, defaultClass: "yv8y4ru3 yv8y4ru4" }, smallButtonActiveOutline: { conditions: { light: "yv8y4ru5", dark: "yv8y4ru6" }, defaultClass: "yv8y4ru5 yv8y4ru6" }, smallLightButtonColor: { conditions: { light: "yv8y4ru7", dark: "yv8y4ru8" }, defaultClass: "yv8y4ru7 yv8y4ru8" }, smallLightButtonBackground: { conditions: { light: "yv8y4ru9", dark: "yv8y4rua" }, defaultClass: "yv8y4ru9 yv8y4rua" }, smallLightButtonOutline: { conditions: { light: "yv8y4rub", dark: "yv8y4ruc" }, defaultClass: "yv8y4rub yv8y4ruc" }, smallLightButtonHoverColor: { conditions: { light: "yv8y4rud", dark: "yv8y4rue" }, defaultClass: "yv8y4rud yv8y4rue" }, smallLightButtonHoverBackground: { conditions: { light: "yv8y4ruf", dark: "yv8y4rug" }, defaultClass: "yv8y4ruf yv8y4rug" }, smallLightButtonHoverOutline: { conditions: { light: "yv8y4ruh", dark: "yv8y4rui" }, defaultClass: "yv8y4ruh yv8y4rui" }, smallLightButtonActiveColor: { conditions: { light: "yv8y4ruj", dark: "yv8y4ruk" }, defaultClass: "yv8y4ruj yv8y4ruk" }, smallLightButtonActiveBackground: { conditions: { light: "yv8y4rul", dark: "yv8y4rum" }, defaultClass: "yv8y4rul yv8y4rum" }, smallLightButtonActiveOutline: { conditions: { light: "yv8y4run", dark: "yv8y4ruo" }, defaultClass: "yv8y4run yv8y4ruo" }, disabledButtonColor: { conditions: { light: "yv8y4rup", dark: "yv8y4ruq" }, defaultClass: "yv8y4rup yv8y4ruq" }, disabledButtonBackground: { conditions: { light: "yv8y4rur", dark: "yv8y4rus" }, defaultClass: "yv8y4rur yv8y4rus" }, disabledButtonOutline: { conditions: { light: "yv8y4rut", dark: "yv8y4ruu" }, defaultClass: "yv8y4rut yv8y4ruu" }, disabledButtonHoverColor: { conditions: { light: "yv8y4ruv", dark: "yv8y4ruw" }, defaultClass: "yv8y4ruv yv8y4ruw" }, disabledButtonHoverBackground: { conditions: { light: "yv8y4rux", dark: "yv8y4ruy" }, defaultClass: "yv8y4rux yv8y4ruy" }, disabledButtonHoverOutline: { conditions: { light: "yv8y4ruz", dark: "yv8y4rv0" }, defaultClass: "yv8y4ruz yv8y4rv0" }, disabledButtonActiveColor: { conditions: { light: "yv8y4rv1", dark: "yv8y4rv2" }, defaultClass: "yv8y4rv1 yv8y4rv2" }, disabledButtonActiveBackground: { conditions: { light: "yv8y4rv3", dark: "yv8y4rv4" }, defaultClass: "yv8y4rv3 yv8y4rv4" }, disabledButtonActiveOutline: { conditions: { light: "yv8y4rv5", dark: "yv8y4rv6" }, defaultClass: "yv8y4rv5 yv8y4rv6" }, connectKit: { conditions: { light: "yv8y4rv7", dark: "yv8y4rv8" }, defaultClass: "yv8y4rv7 yv8y4rv8" } } }, background: { values: { white: { conditions: { light: "yv8y4rv9", dark: "yv8y4rva" }, defaultClass: "yv8y4rv9 yv8y4rva" }, black: { conditions: { light: "yv8y4rvb", dark: "yv8y4rvc" }, defaultClass: "yv8y4rvb yv8y4rvc" }, transparent: { conditions: { light: "yv8y4rvd", dark: "yv8y4rve" }, defaultClass: "yv8y4rvd yv8y4rve" }, primary: { conditions: { light: "yv8y4rvf", dark: "yv8y4rvg" }, defaultClass: "yv8y4rvf yv8y4rvg" }, accent: { conditions: { light: "yv8y4rvh", dark: "yv8y4rvi" }, defaultClass: "yv8y4rvh yv8y4rvi" }, disabled: { conditions: { light: "yv8y4rvj", dark: "yv8y4rvk" }, defaultClass: "yv8y4rvj yv8y4rvk" }, text: { conditions: { light: "yv8y4rvl", dark: "yv8y4rvm" }, defaultClass: "yv8y4rvl yv8y4rvm" }, textMuted: { conditions: { light: "yv8y4rvn", dark: "yv8y4rvo" }, defaultClass: "yv8y4rvn yv8y4rvo" }, textDanger: { conditions: { light: "yv8y4rvp", dark: "yv8y4rvq" }, defaultClass: "yv8y4rvp yv8y4rvq" }, background: { conditions: { light: "yv8y4rvr", dark: "yv8y4rvs" }, defaultClass: "yv8y4rvr yv8y4rvs" }, backgroundMuted: { conditions: { light: "yv8y4rvt", dark: "yv8y4rvu" }, defaultClass: "yv8y4rvt yv8y4rvu" }, tokenSelectBackground: { conditions: { light: "yv8y4rvv", dark: "yv8y4rvw" }, defaultClass: "yv8y4rvv yv8y4rvw" }, tokenSelectHoverBackground: { conditions: { light: "yv8y4rvx", dark: "yv8y4rvy" }, defaultClass: "yv8y4rvx yv8y4rvy" }, tokenSelect: { conditions: { light: "yv8y4rvz", dark: "yv8y4rw0" }, defaultClass: "yv8y4rvz yv8y4rw0" }, skeletonLoaderBase: { conditions: { light: "yv8y4rw1", dark: "yv8y4rw2" }, defaultClass: "yv8y4rw1 yv8y4rw2" }, skeletonLoaderHighlight: { conditions: { light: "yv8y4rw3", dark: "yv8y4rw4" }, defaultClass: "yv8y4rw3 yv8y4rw4" }, tabBorder: { conditions: { light: "yv8y4rw5", dark: "yv8y4rw6" }, defaultClass: "yv8y4rw5 yv8y4rw6" }, stakeSectionBackground: { conditions: { light: "yv8y4rw7", dark: "yv8y4rw8" }, defaultClass: "yv8y4rw7 yv8y4rw8" }, dropdownBackground: { conditions: { light: "yv8y4rw9", dark: "yv8y4rwa" }, defaultClass: "yv8y4rw9 yv8y4rwa" }, selectValidatorMultiSelectedBackground: { conditions: { light: "yv8y4rwb", dark: "yv8y4rwc" }, defaultClass: "yv8y4rwb yv8y4rwc" }, selectValidatorMultiDefaultBackground: { conditions: { light: "yv8y4rwd", dark: "yv8y4rwe" }, defaultClass: "yv8y4rwd yv8y4rwe" }, warningBoxBackground: { conditions: { light: "yv8y4rwf", dark: "yv8y4rwg" }, defaultClass: "yv8y4rwf yv8y4rwg" }, positionsSectionBackgroundColor: { conditions: { light: "yv8y4rwh", dark: "yv8y4rwi" }, defaultClass: "yv8y4rwh yv8y4rwi" }, positionsSectionBorderColor: { conditions: { light: "yv8y4rwj", dark: "yv8y4rwk" }, defaultClass: "yv8y4rwj yv8y4rwk" }, positionsSectionDividerColor: { conditions: { light: "yv8y4rwl", dark: "yv8y4rwm" }, defaultClass: "yv8y4rwl yv8y4rwm" }, positionsClaimRewardsBackground: { conditions: { light: "yv8y4rwn", dark: "yv8y4rwo" }, defaultClass: "yv8y4rwn yv8y4rwo" }, positionsActionRequiredBackground: { conditions: { light: "yv8y4rwp", dark: "yv8y4rwq" }, defaultClass: "yv8y4rwp yv8y4rwq" }, positionsPendingBackground: { conditions: { light: "yv8y4rwr", dark: "yv8y4rws" }, defaultClass: "yv8y4rwr yv8y4rws" }, modalOverlayBackground: { conditions: { light: "yv8y4rwt", dark: "yv8y4rwu" }, defaultClass: "yv8y4rwt yv8y4rwu" }, modalBodyBackground: { conditions: { light: "yv8y4rwv", dark: "yv8y4rww" }, defaultClass: "yv8y4rwv yv8y4rww" }, tooltipBackground: { conditions: { light: "yv8y4rwx", dark: "yv8y4rwy" }, defaultClass: "yv8y4rwx yv8y4rwy" }, primaryButtonColor: { conditions: { light: "yv8y4rwz", dark: "yv8y4rx0" }, defaultClass: "yv8y4rwz yv8y4rx0" }, primaryButtonBackground: { conditions: { light: "yv8y4rx1", dark: "yv8y4rx2" }, defaultClass: "yv8y4rx1 yv8y4rx2" }, primaryButtonOutline: { conditions: { light: "yv8y4rx3", dark: "yv8y4rx4" }, defaultClass: "yv8y4rx3 yv8y4rx4" }, primaryButtonHoverColor: { conditions: { light: "yv8y4rx5", dark: "yv8y4rx6" }, defaultClass: "yv8y4rx5 yv8y4rx6" }, primaryButtonHoverBackground: { conditions: { light: "yv8y4rx7", dark: "yv8y4rx8" }, defaultClass: "yv8y4rx7 yv8y4rx8" }, primaryButtonHoverOutline: { conditions: { light: "yv8y4rx9", dark: "yv8y4rxa" }, defaultClass: "yv8y4rx9 yv8y4rxa" }, primaryButtonActiveColor: { conditions: { light: "yv8y4rxb", dark: "yv8y4rxc" }, defaultClass: "yv8y4rxb yv8y4rxc" }, primaryButtonActiveBackground: { conditions: { light: "yv8y4rxd", dark: "yv8y4rxe" }, defaultClass: "yv8y4rxd yv8y4rxe" }, primaryButtonActiveOutline: { conditions: { light: "yv8y4rxf", dark: "yv8y4rxg" }, defaultClass: "yv8y4rxf yv8y4rxg" }, secondaryButtonColor: { conditions: { light: "yv8y4rxh", dark: "yv8y4rxi" }, defaultClass: "yv8y4rxh yv8y4rxi" }, secondaryButtonBackground: { conditions: { light: "yv8y4rxj", dark: "yv8y4rxk" }, defaultClass: "yv8y4rxj yv8y4rxk" }, secondaryButtonOutline: { conditions: { light: "yv8y4rxl", dark: "yv8y4rxm" }, defaultClass: "yv8y4rxl yv8y4rxm" }, secondaryButtonHoverColor: { conditions: { light: "yv8y4rxn", dark: "yv8y4rxo" }, defaultClass: "yv8y4rxn yv8y4rxo" }, secondaryButtonHoverBackground: { conditions: { light: "yv8y4rxp", dark: "yv8y4rxq" }, defaultClass: "yv8y4rxp yv8y4rxq" }, secondaryButtonHoverOutline: { conditions: { light: "yv8y4rxr", dark: "yv8y4rxs" }, defaultClass: "yv8y4rxr yv8y4rxs" }, secondaryButtonActiveColor: { conditions: { light: "yv8y4rxt", dark: "yv8y4rxu" }, defaultClass: "yv8y4rxt yv8y4rxu" }, secondaryButtonActiveBackground: { conditions: { light: "yv8y4rxv", dark: "yv8y4rxw" }, defaultClass: "yv8y4rxv yv8y4rxw" }, secondaryButtonActiveOutline: { conditions: { light: "yv8y4rxx", dark: "yv8y4rxy" }, defaultClass: "yv8y4rxx yv8y4rxy" }, smallButtonColor: { conditions: { light: "yv8y4rxz", dark: "yv8y4ry0" }, defaultClass: "yv8y4rxz yv8y4ry0" }, smallButtonBackground: { conditions: { light: "yv8y4ry1", dark: "yv8y4ry2" }, defaultClass: "yv8y4ry1 yv8y4ry2" }, smallButtonOutline: { conditions: { light: "yv8y4ry3", dark: "yv8y4ry4" }, defaultClass: "yv8y4ry3 yv8y4ry4" }, smallButtonHoverColor: { conditions: { light: "yv8y4ry5", dark: "yv8y4ry6" }, defaultClass: "yv8y4ry5 yv8y4ry6" }, smallButtonHoverBackground: { conditions: { light: "yv8y4ry7", dark: "yv8y4ry8" }, defaultClass: "yv8y4ry7 yv8y4ry8" }, smallButtonHoverOutline: { conditions: { light: "yv8y4ry9", dark: "yv8y4rya" }, defaultClass: "yv8y4ry9 yv8y4rya" }, smallButtonActiveColor: { conditions: { light: "yv8y4ryb", dark: "yv8y4ryc" }, defaultClass: "yv8y4ryb yv8y4ryc" }, smallButtonActiveBackground: { conditions: { light: "yv8y4ryd", dark: "yv8y4rye" }, defaultClass: "yv8y4ryd yv8y4rye" }, smallButtonActiveOutline: { conditions: { light: "yv8y4ryf", dark: "yv8y4ryg" }, defaultClass: "yv8y4ryf yv8y4ryg" }, smallLightButtonColor: { conditions: { light: "yv8y4ryh", dark: "yv8y4ryi" }, defaultClass: "yv8y4ryh yv8y4ryi" }, smallLightButtonBackground: { conditions: { light: "yv8y4ryj", dark: "yv8y4ryk" }, defaultClass: "yv8y4ryj yv8y4ryk" }, smallLightButtonOutline: { conditions: { light: "yv8y4ryl", dark: "yv8y4rym" }, defaultClass: "yv8y4ryl yv8y4rym" }, smallLightButtonHoverColor: { conditions: { light: "yv8y4ryn", dark: "yv8y4ryo" }, defaultClass: "yv8y4ryn yv8y4ryo" }, smallLightButtonHoverBackground: { conditions: { light: "yv8y4ryp", dark: "yv8y4ryq" }, defaultClass: "yv8y4ryp yv8y4ryq" }, smallLightButtonHoverOutline: { conditions: { light: "yv8y4ryr", dark: "yv8y4rys" }, defaultClass: "yv8y4ryr yv8y4rys" }, smallLightButtonActiveColor: { conditions: { light: "yv8y4ryt", dark: "yv8y4ryu" }, defaultClass: "yv8y4ryt yv8y4ryu" }, smallLightButtonActiveBackground: { conditions: { light: "yv8y4ryv", dark: "yv8y4ryw" }, defaultClass: "yv8y4ryv yv8y4ryw" }, smallLightButtonActiveOutline: { conditions: { light: "yv8y4ryx", dark: "yv8y4ryy" }, defaultClass: "yv8y4ryx yv8y4ryy" }, disabledButtonColor: { conditions: { light: "yv8y4ryz", dark: "yv8y4rz0" }, defaultClass: "yv8y4ryz yv8y4rz0" }, disabledButtonBackground: { conditions: { light: "yv8y4rz1", dark: "yv8y4rz2" }, defaultClass: "yv8y4rz1 yv8y4rz2" }, disabledButtonOutline: { conditions: { light: "yv8y4rz3", dark: "yv8y4rz4" }, defaultClass: "yv8y4rz3 yv8y4rz4" }, disabledButtonHoverColor: { conditions: { light: "yv8y4rz5", dark: "yv8y4rz6" }, defaultClass: "yv8y4rz5 yv8y4rz6" }, disabledButtonHoverBackground: { conditions: { light: "yv8y4rz7", dark: "yv8y4rz8" }, defaultClass: "yv8y4rz7 yv8y4rz8" }, disabledButtonHoverOutline: { conditions: { light: "yv8y4rz9", dark: "yv8y4rza" }, defaultClass: "yv8y4rz9 yv8y4rza" }, disabledButtonActiveColor: { conditions: { light: "yv8y4rzb", dark: "yv8y4rzc" }, defaultClass: "yv8y4rzb yv8y4rzc" }, disabledButtonActiveBackground: { conditions: { light: "yv8y4rzd", dark: "yv8y4rze" }, defaultClass: "yv8y4rzd yv8y4rze" }, disabledButtonActiveOutline: { conditions: { light: "yv8y4rzf", dark: "yv8y4rzg" }, defaultClass: "yv8y4rzf yv8y4rzg" }, connectKit: { conditions: { light: "yv8y4rzh", dark: "yv8y4rzi" }, defaultClass: "yv8y4rzh yv8y4rzi" } } }, borderColor: { values: { white: { conditions: { light: "yv8y4rzj", dark: "yv8y4rzk" }, defaultClass: "yv8y4rzj yv8y4rzk" }, black: { conditions: { light: "yv8y4rzl", dark: "yv8y4rzm" }, defaultClass: "yv8y4rzl yv8y4rzm" }, transparent: { conditions: { light: "yv8y4rzn", dark: "yv8y4rzo" }, defaultClass: "yv8y4rzn yv8y4rzo" }, primary: { conditions: { light: "yv8y4rzp", dark: "yv8y4rzq" }, defaultClass: "yv8y4rzp yv8y4rzq" }, accent: { conditions: { light: "yv8y4rzr", dark: "yv8y4rzs" }, defaultClass: "yv8y4rzr yv8y4rzs" }, disabled: { conditions: { light: "yv8y4rzt", dark: "yv8y4rzu" }, defaultClass: "yv8y4rzt yv8y4rzu" }, text: { conditions: { light: "yv8y4rzv", dark: "yv8y4rzw" }, defaultClass: "yv8y4rzv yv8y4rzw" }, textMuted: { conditions: { light: "yv8y4rzx", dark: "yv8y4rzy" }, defaultClass: "yv8y4rzx yv8y4rzy" }, textDanger: { conditions: { light: "yv8y4rzz", dark: "yv8y4r100" }, defaultClass: "yv8y4rzz yv8y4r100" }, background: { conditions: { light: "yv8y4r101", dark: "yv8y4r102" }, defaultClass: "yv8y4r101 yv8y4r102" }, backgroundMuted: { conditions: { light: "yv8y4r103", dark: "yv8y4r104" }, defaultClass: "yv8y4r103 yv8y4r104" }, tokenSelectBackground: { conditions: { light: "yv8y4r105", dark: "yv8y4r106" }, defaultClass: "yv8y4r105 yv8y4r106" }, tokenSelectHoverBackground: { conditions: { light: "yv8y4r107", dark: "yv8y4r108" }, defaultClass: "yv8y4r107 yv8y4r108" }, tokenSelect: { conditions: { light: "yv8y4r109", dark: "yv8y4r10a" }, defaultClass: "yv8y4r109 yv8y4r10a" }, skeletonLoaderBase: { conditions: { light: "yv8y4r10b", dark: "yv8y4r10c" }, defaultClass: "yv8y4r10b yv8y4r10c" }, skeletonLoaderHighlight: { conditions: { light: "yv8y4r10d", dark: "yv8y4r10e" }, defaultClass: "yv8y4r10d yv8y4r10e" }, tabBorder: { conditions: { light: "yv8y4r10f", dark: "yv8y4r10g" }, defaultClass: "yv8y4r10f yv8y4r10g" }, stakeSectionBackground: { conditions: { light: "yv8y4r10h", dark: "yv8y4r10i" }, defaultClass: "yv8y4r10h yv8y4r10i" }, dropdownBackground: { conditions: { light: "yv8y4r10j", dark: "yv8y4r10k" }, defaultClass: "yv8y4r10j yv8y4r10k" }, selectValidatorMultiSelectedBackground: { conditions: { light: "yv8y4r10l", dark: "yv8y4r10m" }, defaultClass: "yv8y4r10l yv8y4r10m" }, selectValidatorMultiDefaultBackground: { conditions: { light: "yv8y4r10n", dark: "yv8y4r10o" }, defaultClass: "yv8y4r10n yv8y4r10o" }, warningBoxBackground: { conditions: { light: "yv8y4r10p", dark: "yv8y4r10q" }, defaultClass: "yv8y4r10p yv8y4r10q" }, positionsSectionBackgroundColor: { conditions: { light: "yv8y4r10r", dark: "yv8y4r10s" }, defaultClass: "yv8y4r10r yv8y4r10s" }, positionsSectionBorderColor: { conditions: { light: "yv8y4r10t", dark: "yv8y4r10u" }, defaultClass: "yv8y4r10t yv8y4r10u" }, positionsSectionDividerColor: { conditions: { light: "yv8y4r10v", dark: "yv8y4r10w" }, defaultClass: "yv8y4r10v yv8y4r10w" }, positionsClaimRewardsBackground: { conditions: { light: "yv8y4r10x", dark: "yv8y4r10y" }, defaultClass: "yv8y4r10x yv8y4r10y" }, positionsActionRequiredBackground: { conditions: { light: "yv8y4r10z", dark: "yv8y4r110" }, defaultClass: "yv8y4r10z yv8y4r110" }, positionsPendingBackground: { conditions: { light: "yv8y4r111", dark: "yv8y4r112" }, defaultClass: "yv8y4r111 yv8y4r112" }, modalOverlayBackground: { conditions: { light: "yv8y4r113", dark: "yv8y4r114" }, defaultClass: "yv8y4r113 yv8y4r114" }, modalBodyBackground: { conditions: { light: "yv8y4r115", dark: "yv8y4r116" }, defaultClass: "yv8y4r115 yv8y4r116" }, tooltipBackground: { conditions: { light: "yv8y4r117", dark: "yv8y4r118" }, defaultClass: "yv8y4r117 yv8y4r118" }, primaryButtonColor: { conditions: { light: "yv8y4r119", dark: "yv8y4r11a" }, defaultClass: "yv8y4r119 yv8y4r11a" }, primaryButtonBackground: { conditions: { light: "yv8y4r11b", dark: "yv8y4r11c" }, defaultClass: "yv8y4r11b yv8y4r11c" }, primaryButtonOutline: { conditions: { light: "yv8y4r11d", dark: "yv8y4r11e" }, defaultClass: "yv8y4r11d yv8y4r11e" }, primaryButtonHoverColor: { conditions: { light: "yv8y4r11f", dark: "yv8y4r11g" }, defaultClass: "yv8y4r11f yv8y4r11g" }, primaryButtonHoverBackground: { conditions: { light: "yv8y4r11h", dark: "yv8y4r11i" }, defaultClass: "yv8y4r11h yv8y4r11i" }, primaryButtonHoverOutline: { conditions: { light: "yv8y4r11j", dark: "yv8y4r11k" }, defaultClass: "yv8y4r11j yv8y4r11k" }, primaryButtonActiveColor: { conditions: { light: "yv8y4r11l", dark: "yv8y4r11m" }, defaultClass: "yv8y4r11l yv8y4r11m" }, primaryButtonActiveBackground: { conditions: { light: "yv8y4r11n", dark: "yv8y4r11o" }, defaultClass: "yv8y4r11n yv8y4r11o" }, primaryButtonActiveOutline: { conditions: { light: "yv8y4r11p", dark: "yv8y4r11q" }, defaultClass: "yv8y4r11p yv8y4r11q" }, secondaryButtonColor: { conditions: { light: "yv8y4r11r", dark: "yv8y4r11s" }, defaultClass: "yv8y4r11r yv8y4r11s" }, secondaryButtonBackground: { conditions: { light: "yv8y4r11t", dark: "yv8y4r11u" }, defaultClass: "yv8y4r11t yv8y4r11u" }, secondaryButtonOutline: { conditions: { light: "yv8y4r11v", dark: "yv8y4r11w" }, defaultClass: "yv8y4r11v yv8y4r11w" }, secondaryButtonHoverColor: { conditions: { light: "yv8y4r11x", dark: "yv8y4r11y" }, defaultClass: "yv8y4r11x yv8y4r11y" }, secondaryButtonHoverBackground: { conditions: { light: "yv8y4r11z", dark: "yv8y4r120" }, defaultClass: "yv8y4r11z yv8y4r120" }, secondaryButtonHoverOutline: { conditions: { light: "yv8y4r121", dark: "yv8y4r122" }, defaultClass: "yv8y4r121 yv8y4r122" }, secondaryButtonActiveColor: { conditions: { light: "yv8y4r123", dark: "yv8y4r124" }, defaultClass: "yv8y4r123 yv8y4r124" }, secondaryButtonActiveBackground: { conditions: { light: "yv8y4r125", dark: "yv8y4r126" }, defaultClass: "yv8y4r125 yv8y4r126" }, secondaryButtonActiveOutline: { conditions: { light: "yv8y4r127", dark: "yv8y4r128" }, defaultClass: "yv8y4r127 yv8y4r128" }, smallButtonColor: { conditions: { light: "yv8y4r129", dark: "yv8y4r12a" }, defaultClass: "yv8y4r129 yv8y4r12a" }, smallButtonBackground: { conditions: { light: "yv8y4r12b", dark: "yv8y4r12c" }, defaultClass: "yv8y4r12b yv8y4r12c" }, smallButtonOutline: { conditions: { light: "yv8y4r12d", dark: "yv8y4r12e" }, defaultClass: "yv8y4r12d yv8y4r12e" }, smallButtonHoverColor: { conditions: { light: "yv8y4r12f", dark: "yv8y4r12g" }, defaultClass: "yv8y4r12f yv8y4r12g" }, smallButtonHoverBackground: { conditions: { light: "yv8y4r12h", dark: "yv8y4r12i" }, defaultClass: "yv8y4r12h yv8y4r12i" }, smallButtonHoverOutline: { conditions: { light: "yv8y4r12j", dark: "yv8y4r12k" }, defaultClass: "yv8y4r12j yv8y4r12k" }, smallButtonActiveColor: { conditions: { light: "yv8y4r12l", dark: "yv8y4r12m" }, defaultClass: "yv8y4r12l yv8y4r12m" }, smallButtonActiveBackground: { conditions: { light: "yv8y4r12n", dark: "yv8y4r12o" }, defaultClass: "yv8y4r12n yv8y4r12o" }, smallButtonActiveOutline: { conditions: { light: "yv8y4r12p", dark: "yv8y4r12q" }, defaultClass: "yv8y4r12p yv8y4r12q" }, smallLightButtonColor: { conditions: { light: "yv8y4r12r", dark: "yv8y4r12s" }, defaultClass: "yv8y4r12r yv8y4r12s" }, smallLightButtonBackground: { conditions: { light: "yv8y4r12t", dark: "yv8y4r12u" }, defaultClass: "yv8y4r12t yv8y4r12u" }, smallLightButtonOutline: { conditions: { light: "yv8y4r12v", dark: "yv8y4r12w" }, defaultClass: "yv8y4r12v yv8y4r12w" }, smallLightButtonHoverColor: { conditions: { light: "yv8y4r12x", dark: "yv8y4r12y" }, defaultClass: "yv8y4r12x yv8y4r12y" }, smallLightButtonHoverBackground: { conditions: { light: "yv8y4r12z", dark: "yv8y4r130" }, defaultClass: "yv8y4r12z yv8y4r130" }, smallLightButtonHoverOutline: { conditions: { light: "yv8y4r131", dark: "yv8y4r132" }, defaultClass: "yv8y4r131 yv8y4r132" }, smallLightButtonActiveColor: { conditions: { light: "yv8y4r133", dark: "yv8y4r134" }, defaultClass: "yv8y4r133 yv8y4r134" }, smallLightButtonActiveBackground: { conditions: { light: "yv8y4r135", dark: "yv8y4r136" }, defaultClass: "yv8y4r135 yv8y4r136" }, smallLightButtonActiveOutline: { conditions: { light: "yv8y4r137", dark: "yv8y4r138" }, defaultClass: "yv8y4r137 yv8y4r138" }, disabledButtonColor: { conditions: { light: "yv8y4r139", dark: "yv8y4r13a" }, defaultClass: "yv8y4r139 yv8y4r13a" }, disabledButtonBackground: { conditions: { light: "yv8y4r13b", dark: "yv8y4r13c" }, defaultClass: "yv8y4r13b yv8y4r13c" }, disabledButtonOutline: { conditions: { light: "yv8y4r13d", dark: "yv8y4r13e" }, defaultClass: "yv8y4r13d yv8y4r13e" }, disabledButtonHoverColor: { conditions: { light: "yv8y4r13f", dark: "yv8y4r13g" }, defaultClass: "yv8y4r13f yv8y4r13g" }, disabledButtonHoverBackground: { conditions: { light: "yv8y4r13h", dark: "yv8y4r13i" }, defaultClass: "yv8y4r13h yv8y4r13i" }, disabledButtonHoverOutline: { conditions: { light: "yv8y4r13j", dark: "yv8y4r13k" }, defaultClass: "yv8y4r13j yv8y4r13k" }, disabledButtonActiveColor: { conditions: { light: "yv8y4r13l", dark: "yv8y4r13m" }, defaultClass: "yv8y4r13l yv8y4r13m" }, disabledButtonActiveBackground: { conditions: { light: "yv8y4r13n", dark: "yv8y4r13o" }, defaultClass: "yv8y4r13n yv8y4r13o" }, disabledButtonActiveOutline: { conditions: { light: "yv8y4r13p", dark: "yv8y4r13q" }, defaultClass: "yv8y4r13p yv8y4r13q" }, connectKit: { conditions: { light: "yv8y4r13r", dark: "yv8y4r13s" }, defaultClass: "yv8y4r13r yv8y4r13s" } } } } });
const WEe = {
  baseContract: {
    none: "0",
    sm: "2px",
    base: "4px",
    md: "6px",
    lg: "8px",
    xl: "12px",
    "2xl": "16px",
    "3xl": "24px",
    full: "9999px",
    half: "50%",
    widgetBorderRadius: "0",
    primaryButton: "16px",
    secondaryButton: "16px",
    smallButton: "7.38px"
  },
  connectKit: {
    ...uA.lightMode.radii,
    actionButton: ti.borderRadius.baseContract["2xl"]
  }
}, GEe = {
  full: "100%",
  unset: "unset",
  auto: "auto",
  0: "0",
  1: "4px",
  2: "8px",
  3: "12px",
  4: "16px",
  5: "20px",
  6: "24px",
  7: "28px",
  8: "32px",
  9: "36px",
  10: "40px",
  12: "48px",
  14: "56px",
  16: "64px",
  20: "80px",
  24: "96px",
  28: "112px",
  32: "128px",
  36: "144px",
  40: "160px",
  44: "176px",
  48: "192px",
  px: "1px",
  buttonMinHeight: "64px"
}, KEe = {
  tighter: "-0.05em",
  tight: "-0.025em",
  normal: "0",
  wide: "0.025em",
  wider: "0.05em",
  widest: "0.1em"
}, YEe = {
  none: "1",
  shorter: "1.25",
  short: "1.375",
  base: "1.5",
  tall: "1.625",
  taller: "2",
  xs: "1rem",
  sm: "1.25rem",
  md: "1.5rem",
  lg: "1.75rem",
  xl: "1.75rem",
  "2xl": "2.25rem",
  "3xl": "2.5rem",
  "4xl": "1",
  "5xl": "1",
  "6xl": "1"
}, QEe = {
  normal: "400",
  medium: "500",
  semibold: "600",
  bold: "700",
  extrabold: "800",
  modalHeading: "600",
  tokenSelect: "700",
  primaryButton: "700",
  secondaryButton: "700"
}, ns = {
  xs: "0.615rem",
  sm: "0.717rem",
  md: "0.85rem",
  lg: "1rem",
  lgx: "1.125rem",
  xl: "1.3125rem",
  "2xl": "1.563rem",
  "3xl": "1.953rem",
  "4xl": "2.441rem",
  "5xl": "3.052rem",
  "6xl": "3.815rem"
}, XEe = {
  h1: {
    mobile: { fontSize: ns["3xl"] },
    tablet: { fontSize: ns["4xl"] }
  },
  h2: {
    mobile: { fontSize: ns["2xl"] },
    tablet: { fontSize: ns["3xl"] }
  },
  h3: {
    mobile: { fontSize: ns.xl },
    tablet: { fontSize: ns["2xl"] }
  },
  h4: {
    mobile: { fontSize: ns.lgx },
    tablet: { fontSize: ns.lgx }
  }
}, JEe = {
  large: {
    mobile: { fontSize: ns.lg },
    tablet: { fontSize: ns.lg }
  },
  medium: {
    mobile: { fontSize: ns.md },
    tablet: { fontSize: ns.md }
  },
  small: {
    mobile: { fontSize: ns.sm },
    tablet: { fontSize: ns.sm }
  }
}, ZEe = {
  hide: "-1",
  auto: "auto",
  simple: "1",
  base: "0",
  docked: "10",
  dropdown: "1000",
  sticky: "1100",
  banner: "1200",
  overlay: "1300",
  modal: "1400",
  skipLink: "1600"
}, xh = {
  light: "light-theme",
  lightOverrides: "light-theme-overrides",
  dark: "dark-theme",
  darkOverrides: "dark-theme-overrides"
}, QG = {
  fontSize: ns,
  letterSpacing: KEe,
  lineHeight: YEe,
  fontWeight: QEe,
  borderRadius: WEe,
  space: GEe,
  heading: XEe,
  text: JEe,
  zIndices: ZEe,
  font: FEe
}, Pk = {
  ...QG,
  color: LEe
}, eSe = {
  ...QG,
  color: jEe
}, fb = Ro.chainNullable((e) => e.document), tSe = () => {
  const e = BEe();
  tf(() => {
    e === "dark" ? fb.ifJust((t) => {
      t.body.classList.remove(xh.light), t.body.classList.remove(xh.lightOverrides), t.body.classList.add(xh.dark), t.body.classList.add(xh.darkOverrides);
    }) : fb.ifJust((t) => {
      t.body.classList.add(xh.light), t.body.classList.add(xh.lightOverrides), t.body.classList.remove(xh.dark), t.body.classList.remove(xh.darkOverrides);
    });
  }, [e]);
}, Pr = (e) => {
  const t = k.useRef(e);
  return k.useEffect(() => {
    t.current = e;
  }), t;
}, nSe = () => {
  const { disconnect: e } = fr();
  return ec({
    mutationFn: async () => (await Ye(e).chain(() => Ye(() => indexedDB.databases())).ifRight(
      (t) => t.forEach((n) => n.name && indexedDB.deleteDatabase(n.name))
    ), null)
  });
}, as = (e) => {
  var t;
  return `${e.network}-${(t = e.address) == null ? void 0 : t.toLowerCase()}`;
}, dA = (e, t) => as(e) === as(t), Vb = ({
  token: e,
  baseToken: t,
  amount: n,
  prices: r,
  pricePerShare: i
}) => {
  const o = Nt(n);
  if (i && t) {
    const c = new Nt(
      r.getByToken(t).chainNullable((f) => f.price).orDefault(0)
    ), u = Nt(i);
    return o.times(c).times(u);
  }
  const s = new Nt(
    r.getByToken(e).chainNullable((c) => c.price).orDefault(0)
  );
  return o.times(s);
}, rSe = ({
  stakeToken: e,
  yieldDto: t
}) => dA(e, XG(t)), iSe = ({
  availableAmount: e,
  gasEstimateTotal: t,
  integrationMaxLimit: n
}) => Nt.max(
  Nt.min(n, e.minus(t)),
  new Nt(0)
), oSe = (e) => e.metadata.token, XG = (e) => e.metadata.gasFeeToken, vP = (e) => {
  const t = {
    ...e,
    transactions: e.transactions.filter(
      (n) => n.status !== "SKIPPED"
    )
  };
  return t.transactions.some((n) => JG(n.status)) ? Rn(new Error("Transaction failed")) : Pt(t);
}, JG = (e) => e === "FAILED" || e === "BLOCKED", Z5 = (e) => {
  var t, n, r;
  return !!((r = (n = (t = e.args) == null ? void 0 : t.args) == null ? void 0 : n.validatorAddresses) != null && r.required);
}, eD = (e) => {
  var t, n, r;
  return !!((r = (n = (t = e.args) == null ? void 0 : t.args) == null ? void 0 : n.validatorAddress) != null && r.required);
}, ZG = /* @__PURE__ */ new Set([
  "P2P_NODE_REQUEST",
  "LUGANODES_PROVISION",
  "LUGANODES_EXIT_REQUEST"
]), aSe = (e) => e.filter((t) => !ZG.has(t.type)), sSe = (e) => {
  const t = Cbe(e);
  return Number.isNaN(t) ? e : t;
}, ix = (e) => k.useMemo(() => e.map((t) => oSe(t)), [e]), lSe = (e) => k.useMemo(() => e.map((t) => XG(t)), [e]);
var cSe = (e, t, n) => {
  if (t.length === 1 && t[0] === n) {
    let r = !1;
    try {
      const i = {};
      e(i) === i && (r = !0);
    } catch {
    }
    if (r) {
      let i;
      try {
        throw new Error();
      } catch (o) {
        ({ stack: i } = o);
      }
    }
  }
}, uSe = (e, t, n) => {
  const { memoize: r, memoizeOptions: i } = t, { inputSelectorResults: o, inputSelectorResultsCopy: s } = e, c = r(() => ({}), ...i);
  if (!(c.apply(null, o) === c.apply(null, s))) {
    let f;
    try {
      throw new Error();
    } catch (p) {
      ({ stack: f } = p);
    }
  }
}, dSe = {
  inputStabilityCheck: "once",
  identityFunctionCheck: "once"
};
function fSe(e, t = `expected a function, instead received ${typeof e}`) {
  if (typeof e != "function")
    throw new TypeError(t);
}
function hSe(e, t = `expected an object, instead received ${typeof e}`) {
  if (typeof e != "object")
    throw new TypeError(t);
}
function pSe(e, t = "expected all items to be functions, instead received the following types: ") {
  if (!e.every((n) => typeof n == "function")) {
    const n = e.map(
      (r) => typeof r == "function" ? `function ${r.name || "unnamed"}()` : typeof r
    ).join(", ");
    throw new TypeError(`${t}[${n}]`);
  }
}
var jU = (e) => Array.isArray(e) ? e : [e];
function mSe(e) {
  const t = Array.isArray(e[0]) ? e[0] : e;
  return pSe(
    t,
    "createSelector expects all input-selectors to be functions, but received the following types: "
  ), t;
}
function FU(e, t) {
  const n = [], { length: r } = e;
  for (let i = 0; i < r; i++)
    n.push(e[i].apply(null, t));
  return n;
}
var ySe = (e, t) => {
  const { identityFunctionCheck: n, inputStabilityCheck: r } = {
    ...dSe,
    ...t
  };
  return {
    identityFunctionCheck: {
      shouldRun: n === "always" || n === "once" && e,
      run: cSe
    },
    inputStabilityCheck: {
      shouldRun: r === "always" || r === "once" && e,
      run: uSe
    }
  };
}, vSe = class {
  constructor(e) {
    this.value = e;
  }
  deref() {
    return this.value;
  }
}, gSe = typeof WeakRef < "u" ? WeakRef : vSe, bSe = 0, UU = 1;
function Nk() {
  return {
    s: bSe,
    v: void 0,
    o: null,
    p: null
  };
}
function eK(e, t = {}) {
  let n = Nk();
  const { resultEqualityCheck: r } = t;
  let i, o = 0;
  function s() {
    var y;
    let c = n;
    const { length: u } = arguments;
    for (let v = 0, w = u; v < w; v++) {
      const C = arguments[v];
      if (typeof C == "function" || typeof C == "object" && C !== null) {
        let x = c.o;
        x === null && (c.o = x = /* @__PURE__ */ new WeakMap());
        const A = x.get(C);
        A === void 0 ? (c = Nk(), x.set(C, c)) : c = A;
      } else {
        let x = c.p;
        x === null && (c.p = x = /* @__PURE__ */ new Map());
        const A = x.get(C);
        A === void 0 ? (c = Nk(), x.set(C, c)) : c = A;
      }
    }
    const f = c;
    let p;
    if (c.s === UU)
      p = c.v;
    else if (p = e.apply(null, arguments), o++, r) {
      const v = ((y = i == null ? void 0 : i.deref) == null ? void 0 : y.call(i)) ?? i;
      v != null && r(v, p) && (p = v, o !== 0 && o--), i = typeof p == "object" && p !== null || typeof p == "function" ? new gSe(p) : p;
    }
    return f.s = UU, f.v = p, p;
  }
  return s.clearCache = () => {
    n = Nk(), s.resetResultsCount();
  }, s.resultsCount = () => o, s.resetResultsCount = () => {
    o = 0;
  }, s;
}
function wSe(e, ...t) {
  const n = typeof e == "function" ? {
    memoize: e,
    memoizeOptions: t
  } : e, r = (...i) => {
    let o = 0, s = 0, c, u = {}, f = i.pop();
    typeof f == "object" && (u = f, f = i.pop()), fSe(
      f,
      `createSelector expects an output function after the inputs, but received: [${typeof f}]`
    );
    const p = {
      ...n,
      ...u
    }, {
      memoize: y,
      memoizeOptions: v = [],
      argsMemoize: w = eK,
      argsMemoizeOptions: C = [],
      devModeChecks: x = {}
    } = p, A = jU(v), R = jU(C), I = mSe(i), D = y(function() {
      return o++, f.apply(
        null,
        arguments
      );
    }, ...A);
    let M = !0;
    const L = w(function() {
      s++;
      const F = FU(
        I,
        arguments
      );
      if (c = D.apply(null, F), ct.env.NODE_ENV !== "production") {
        const { identityFunctionCheck: O, inputStabilityCheck: z } = ySe(M, x);
        if (O.shouldRun && O.run(
          f,
          F,
          c
        ), z.shouldRun) {
          const H = FU(
            I,
            arguments
          );
          z.run(
            { inputSelectorResults: F, inputSelectorResultsCopy: H },
            { memoize: y, memoizeOptions: A },
            arguments
          );
        }
        M && (M = !1);
      }
      return c;
    }, ...R);
    return Object.assign(L, {
      resultFunc: f,
      memoizedResultFunc: D,
      dependencies: I,
      dependencyRecomputations: () => s,
      resetDependencyRecomputations: () => {
        s = 0;
      },
      lastResult: () => c,
      recomputations: () => o,
      resetRecomputations: () => {
        o = 0;
      },
      memoize: y,
      argsMemoize: w
    });
  };
  return Object.assign(r, {
    withTypes: () => r
  }), r;
}
var $b = /* @__PURE__ */ wSe(eK), CSe = Object.assign(
  (e, t = $b) => {
    hSe(
      e,
      `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof e}`
    );
    const n = Object.keys(e), r = n.map(
      (o) => e[o]
    );
    return t(
      r,
      (...o) => o.reduce((s, c, u) => (s[n[u]] = c, s), {})
    );
  },
  { withTypes: () => CSe }
);
class gP {
  constructor(t) {
    this.value = t;
  }
  getByToken(t) {
    return he.fromNullable(this.value.get(as(t)));
  }
}
const tK = (e) => bP(e) ? "native_staking" : iK(e) ? "pooled_staking" : e.metadata.type, nK = (e, t) => {
  const n = {
    staking: {
      type: "staking",
      title: t("yield_types.staking.title"),
      review: t("yield_types.staking.review"),
      cta: t("yield_types.staking.cta")
    },
    "liquid-staking": {
      type: "liquid-staking",
      title: t("yield_types.liquid-staking.title"),
      review: t("yield_types.liquid-staking.review"),
      cta: t("yield_types.liquid-staking.cta")
    },
    vault: {
      type: "vault",
      title: t("yield_types.vault.title"),
      review: t("yield_types.vault.review"),
      cta: t("yield_types.vault.cta")
    },
    lending: {
      type: "lending",
      title: t("yield_types.lending.title"),
      review: t("yield_types.lending.review"),
      cta: t("yield_types.lending.cta")
    },
    restaking: {
      type: "restaking",
      title: t("yield_types.restaking.title"),
      review: t("yield_types.restaking.review"),
      cta: t("yield_types.restaking.cta")
    },
    native_staking: {
      type: "native_staking",
      title: t("yield_types.native_staking.title"),
      review: t("yield_types.native_staking.review"),
      cta: t("yield_types.native_staking.cta")
    },
    pooled_staking: {
      type: "pooled_staking",
      title: t("yield_types.pooled_staking.title"),
      review: t("yield_types.pooled_staking.review"),
      cta: t("yield_types.pooled_staking.cta")
    }
  };
  return bP(e) ? n.native_staking : iK(e) ? n.pooled_staking : n[e.metadata.type];
}, xSe = {
  staking: 1,
  native_staking: 2,
  pooled_staking: 3,
  "liquid-staking": 4,
  vault: 5,
  lending: 6,
  restaking: 7
}, zU = (e) => xSe[tK(e)], rK = (e) => e.metadata.type === "staking" && e.token.network === sn.Ethereum && e.token.symbol === "ETH", bP = (e) => he.fromFalsy(rK(e)).chain(
  () => {
    var t, n;
    return he.fromFalsy((n = (t = e.args.enter.args) == null ? void 0 : t.amount) == null ? void 0 : n.required).chain(
      () => {
        var r, i;
        return he.fromNullable((i = (r = e.args.enter.args) == null ? void 0 : r.amount) == null ? void 0 : i.minimum);
      }
    );
  }
).map(Nt).filter((t) => t.isEqualTo(32)).isJust(), iK = (e) => rK(e) && !bP(e), ESe = /* @__PURE__ */ new Set([
  "polkadot-dot-validator-staking"
]), SSe = (e, t) => ESe.has(e) ? he.fromNullable(t.get("polkadot-dot-validator-staking")).map((n) => [...n.balanceData.values()]).map((n) => n.some((r) => r.balances.some((i) => i.type === "staked"))).orDefault(!1) : !1, kSe = (e) => ({
  price: e.price,
  price24H: e.price_24_h
}), ASe = (e) => new gP(
  Object.keys(e).reduce((t, n) => (t.set(n, kSe(e[n])), t), /* @__PURE__ */ new Map())
), TSe = {
  currency: "USD",
  tokenList: [
    { network: "ethereum", name: "Ethereum", symbol: "ETH", decimals: 18 }
  ]
}, _Se = $b(
  (e) => e,
  (e) => ASe(e)
), oK = (e) => dde(e ?? TSe, {
  query: { enabled: !!e, select: _Se }
}), fA = ({
  token: e,
  yieldDto: t
}) => {
  const n = ix(t), r = lSe(t), i = k.useMemo(
    () => he.fromRecord({ baseToken: n, gasFeeToken: r, token: e }).map((o) => ({
      currency: ni.currency,
      tokenList: [o.token, o.baseToken, o.gasFeeToken]
    })).extractNullable(),
    [n, r, e]
  );
  return oK(i);
}, hA = ({
  queryClient: e,
  yieldGetMyNetworks: t
}) => Ye(
  () => e.fetchQuery({
    staleTime: Number.POSITIVE_INFINITY,
    queryKey: [ni.appPrefix, "enabled-networks"],
    queryFn: async () => (await Ye(() => t()).map(
      (n) => new Set(n)
    )).unsafeCoerce()
  })
).mapLeft(() => new Error("Could not get enabled networks")), RSe = (e) => {
  var t, n, r, i;
  return {
    id: e.chain_id,
    iconUrl: _n(e.chain_id).map((o) => {
      var s, c;
      return o === "osmosis-1" ? Bh(fn.Osmosis) : o === "mars-1" ? ay("mars") : ((s = e.logo_URIs) == null ? void 0 : s.png) ?? ((c = e.logo_URIs) == null ? void 0 : c.svg) ?? Bh(e.chain_name);
    }).unsafeCoerce(),
    name: e.wagmiName,
    cosmosChainName: e.chain_name,
    // TODO: change this
    nativeCurrency: Ub.nativeCurrency,
    rpcUrls: {
      default: {
        http: ((n = (t = e.apis) == null ? void 0 : t.rpc) == null ? void 0 : n.map((o) => o.address)) ?? [""]
      },
      public: {
        http: ((i = (r = e.apis) == null ? void 0 : r.rpc) == null ? void 0 : i.map((o) => o.address)) ?? [""]
      }
    }
  };
}, OSe = [ni.appPrefix, "cosmos-config"], ISe = Number.POSITIVE_INFINITY, DSe = async ({
  queryClient: e,
  forceWalletConnectOnly: t,
  yieldGetMyNetworks: n
}) => hA({ queryClient: e, yieldGetMyNetworks: n }).chain((r) => {
  const i = z$.filter(
    (o) => r.has(o)
  );
  return i.length ? Ye(() => import("./chain-registry-C3Z3k4oT.js")).mapLeft(() => new Error("Could not import cosmos chain registry")).map((o) => {
    const s = new Set(i), c = E8(
      S8(
        o.cosmosRegistryChains.reduce((u, f) => {
          const p = o.registryIdsToSKCosmosNetworks[f.chain_id];
          return !p || !s.has(p) ? u : {
            // biome-ignore lint/performance/noAccumulatingSpread: <explanation>
            ...u,
            [p]: {
              type: "cosmos",
              skChainName: p,
              chain: f,
              wagmiChain: RSe(f)
            }
          };
        }, {})
      ).filter(([u, f]) => r.has(f.skChainName))
    );
    return {
      cosmosChainsMap: c,
      cosmosWagmiChains: Object.values(c).map(
        (u) => u.wagmiChain
      )
    };
  }).chain(
    ({ cosmosChainsMap: o, cosmosWagmiChains: s }) => Ye(() => import("./wallet-manager-CHh0V-QY.js").then((c) => c.x)).mapLeft(() => new Error("Could not import cosmos wallet manager")).map(
      (c) => c.getWalletManager({ cosmosChainsMap: o, forceWalletConnectOnly: t })
    ).map((c) => ({ ...c, cosmosWagmiChains: s, cosmosChainsMap: o }))
  ).chain(
    (o) => Ye(() => o.walletManager.onMounted()).chainLeft(
      () => Ye(() => cosmosWalletManager._restoreAccounts().catch(() => {
      }))
    ).mapLeft((s) => new Error("cosmosWalletManager onMounted failed")).map(() => ({
      cosmosChainsMap: o.cosmosChainsMap,
      cosmosWagmiChains: o.cosmosWagmiChains,
      connector: he.fromPredicate(
        () => !!o.cosmosWagmiChains.length,
        o.connector
      )
    }))
  ) : Ye.liftEither(
    Pt({
      cosmosChainsMap: {},
      cosmosWagmiChains: [],
      connector: he.empty()
    })
  );
}).caseOf({
  Right: (r) => Promise.resolve(r),
  Left: (r) => Promise.reject(r)
}), MSe = (e) => Ye(
  () => e.queryClient.fetchQuery({
    staleTime: ISe,
    queryKey: OSe,
    queryFn: () => DSe(e)
  })
).mapLeft((t) => new Error("Could not get cosmos config"));
function aK(e) {
  const t = typeof window < "u" ? window : void 0;
  if (typeof t > "u" || typeof t.ethereum > "u")
    return;
  const n = t.ethereum.providers;
  return n ? n.find((r) => r[e]) : t.ethereum[e] ? t.ethereum : void 0;
}
function sK(e) {
  const t = (n, r) => {
    const [i, ...o] = r.split("."), s = n[i];
    if (s)
      return o.length === 0 ? s : t(s, o.join("."));
  };
  if (typeof window < "u")
    return t(window, e);
}
function lK({
  flag: e,
  namespace: t
}) {
  return !!(t && typeof sK(t) < "u" || e && typeof aK(e) < "u");
}
function PSe({
  flag: e,
  namespace: t
}) {
  var i;
  const n = typeof window < "u" ? window : void 0;
  if (typeof n > "u")
    return;
  if (t) {
    const o = sK(t);
    if (o)
      return o;
  }
  const r = (i = n.ethereum) == null ? void 0 : i.providers;
  if (e) {
    const o = aK(e);
    if (o)
      return o;
  }
  return typeof r < "u" && r.length > 0 ? r[0] : n.ethereum;
}
function NSe(e) {
  return (t) => {
    const n = e ? {
      target: () => ({
        id: t.rkDetails.id,
        name: t.rkDetails.name,
        provider: e
      })
    } : {};
    return (r) => ({
      // Spread the injectedConfig object, which may be empty or contain the target function
      ...K8(n)(r),
      ...t
    });
  };
}
function wP({
  flag: e,
  namespace: t,
  target: n
}) {
  const r = n || PSe({ flag: e, namespace: t });
  return NSe(r);
}
function cK() {
  return typeof navigator < "u" && /android/i.test(navigator.userAgent);
}
function BSe() {
  return typeof navigator < "u" && /iPhone|iPod/.test(navigator.userAgent);
}
function LSe() {
  return typeof navigator < "u" && (/iPad/.test(navigator.userAgent) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
}
function CP() {
  return BSe() || LSe();
}
var VU = /* @__PURE__ */ new Map(), jSe = ({
  projectId: e,
  walletConnectParameters: t,
  rkDetailsShowQrModal: n
}) => {
  let r = {
    ...t || {},
    projectId: e,
    showQrModal: !1
    // Required. Otherwise WalletConnect modal (Web3Modal) will popup during time of connection for a wallet
  };
  n && (r = { ...r, showQrModal: !0 });
  const i = JSON.stringify(r), o = VU.get(i);
  if (o)
    return o;
  const s = iP(r);
  return VU.set(i, s), s;
};
function FSe({
  projectId: e,
  walletDetails: t,
  walletConnectParameters: n
}) {
  return (r) => ({
    ...jSe({
      projectId: e,
      walletConnectParameters: n,
      // Used in `connectorsForWallets` to add another
      // walletConnect wallet into rainbowkit with modal popup option
      rkDetailsShowQrModal: t.rkDetails.showQrModal
    })(r),
    ...t
  });
}
function xP({
  projectId: e,
  walletConnectParameters: t
}) {
  const n = "21fef48091f12692cad574a6f7753643";
  if (!e || e === "")
    throw new Error(
      "No projectId found. Every dApp must now provide a WalletConnect Cloud projectId to enable WalletConnect v2 https://www.rainbowkit.com/docs/installation#configure"
    );
  return e === "YOUR_PROJECT_ID" && (e = n), (r) => FSe({
    projectId: e,
    walletDetails: r,
    walletConnectParameters: t
  });
}
var $U = ({
  projectId: e,
  options: t
}) => ({
  id: "walletConnect",
  name: "WalletConnect",
  installed: void 0,
  iconUrl: async () => (await import("./walletConnectWallet-FNSU4KNU-CEwTcgxF.js")).default,
  iconBackground: "#3b99fc",
  qrCode: { getUri: (r) => r },
  createConnector: xP({
    projectId: e,
    walletConnectParameters: t
  })
}), USe = ({
  projectId: e,
  walletConnectParameters: t
}) => {
  const n = lK({ flag: "isRainbow" }), r = !n, i = (o) => cK() ? o : CP() ? `rainbow://wc?uri=${encodeURIComponent(o)}&connector=rainbowkit` : `https://rnbwapp.com/wc?uri=${encodeURIComponent(
    o
  )}&connector=rainbowkit`;
  return {
    id: "rainbow",
    name: "Rainbow",
    rdns: "me.rainbow",
    iconUrl: async () => (await import("./rainbowWallet-2SR6TVBF-BdFRQlw6.js")).default,
    iconBackground: "#0c2f78",
    installed: r ? void 0 : n,
    downloadUrls: {
      android: "https://play.google.com/store/apps/details?id=me.rainbow&referrer=utm_source%3Drainbowkit&utm_source=rainbowkit",
      ios: "https://apps.apple.com/app/apple-store/id1457119021?pt=119997837&ct=rainbowkit&mt=8",
      mobile: "https://rainbow.download?utm_source=rainbowkit",
      qrCode: "https://rainbow.download?utm_source=rainbowkit&utm_medium=qrcode",
      browserExtension: "https://rainbow.me/extension?utm_source=rainbowkit"
    },
    mobile: { getUri: r ? i : void 0 },
    qrCode: r ? {
      getUri: i,
      instructions: {
        learnMoreUrl: "https://learn.rainbow.me/connect-to-a-website-or-app?utm_source=rainbowkit&utm_medium=connector&utm_campaign=learnmore",
        steps: [
          {
            description: "wallet_connectors.rainbow.qr_code.step1.description",
            step: "install",
            title: "wallet_connectors.rainbow.qr_code.step1.title"
          },
          {
            description: "wallet_connectors.rainbow.qr_code.step2.description",
            step: "create",
            title: "wallet_connectors.rainbow.qr_code.step2.title"
          },
          {
            description: "wallet_connectors.rainbow.qr_code.step3.description",
            step: "scan",
            title: "wallet_connectors.rainbow.qr_code.step3.title"
          }
        ]
      }
    } : void 0,
    createConnector: r ? xP({
      projectId: e,
      walletConnectParameters: t
    }) : wP({ flag: "isRainbow" })
  };
};
function zSe(e) {
  return !(!(e != null && e.isMetaMask) || e.isBraveWallet && !e._events && !e._state || e.isApexWallet || e.isAvalanche || e.isBackpack || e.isBifrost || e.isBitKeep || e.isBitski || e.isBlockWallet || e.isCoinbaseWallet || e.isDawn || e.isEnkrypt || e.isExodus || e.isFrame || e.isFrontier || e.isGamestop || e.isHyperPay || e.isImToken || e.isKuCoinWallet || e.isMathWallet || e.isNestWallet || e.isOkxWallet || e.isOKExWallet || e.isOneInchIOSWallet || e.isOneInchAndroidWallet || e.isOpera || e.isPhantom || e.isPortal || e.isRabby || e.isRainbow || e.isStatus || e.isTalisman || e.isTally || e.isTokenPocket || e.isTokenary || e.isTrust || e.isTrustWallet || e.isXDEFI || e.isZeal || e.isZerion || e.__seif);
}
var VSe = ({
  projectId: e,
  walletConnectParameters: t
}) => {
  var o, s;
  const n = lK({ flag: "isMetaMask" }), r = !n, i = (c) => cK() ? c : CP() ? (
    // currently broken in MetaMask v6.5.0 https://github.com/MetaMask/metamask-mobile/issues/6457
    `metamask://wc?uri=${encodeURIComponent(c)}`
  ) : `https://metamask.app.link/wc?uri=${encodeURIComponent(c)}`;
  return {
    id: "metaMask",
    name: "MetaMask",
    rdns: "io.metamask",
    iconUrl: async () => (await import("./metaMaskWallet-YFHEHW7V-CaVugHft.js")).default,
    iconAccent: "#f6851a",
    iconBackground: "#fff",
    installed: r ? void 0 : n,
    downloadUrls: {
      android: "https://play.google.com/store/apps/details?id=io.metamask",
      ios: "https://apps.apple.com/us/app/metamask/id1438144202",
      mobile: "https://metamask.io/download",
      qrCode: "https://metamask.io/download",
      chrome: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn",
      edge: "https://microsoftedge.microsoft.com/addons/detail/metamask/ejbalbakoplchlghecdalmeeeajnimhm",
      firefox: "https://addons.mozilla.org/firefox/addon/ether-metamask",
      opera: "https://addons.opera.com/extensions/details/metamask-10",
      browserExtension: "https://metamask.io/download"
    },
    mobile: {
      getUri: r ? i : void 0
    },
    qrCode: r ? {
      getUri: i,
      instructions: {
        learnMoreUrl: "https://metamask.io/faqs/",
        steps: [
          {
            description: "wallet_connectors.metamask.qr_code.step1.description",
            step: "install",
            title: "wallet_connectors.metamask.qr_code.step1.title"
          },
          {
            description: "wallet_connectors.metamask.qr_code.step2.description",
            step: "create",
            title: "wallet_connectors.metamask.qr_code.step2.title"
          },
          {
            description: "wallet_connectors.metamask.qr_code.step3.description",
            step: "refresh",
            title: "wallet_connectors.metamask.qr_code.step3.title"
          }
        ]
      }
    } : void 0,
    extension: {
      instructions: {
        learnMoreUrl: "https://metamask.io/faqs/",
        steps: [
          {
            description: "wallet_connectors.metamask.extension.step1.description",
            step: "install",
            title: "wallet_connectors.metamask.extension.step1.title"
          },
          {
            description: "wallet_connectors.metamask.extension.step2.description",
            step: "create",
            title: "wallet_connectors.metamask.extension.step2.title"
          },
          {
            description: "wallet_connectors.metamask.extension.step3.description",
            step: "refresh",
            title: "wallet_connectors.metamask.extension.step3.title"
          }
        ]
      }
    },
    createConnector: r ? xP({
      projectId: e,
      walletConnectParameters: t
    }) : wP({
      target: typeof window < "u" ? ((s = (o = window.ethereum) == null ? void 0 : o.providers) == null ? void 0 : s.find(
        zSe
      )) ?? window.ethereum : void 0
    })
  };
}, $Se = () => ({
  id: "injected",
  name: "Browser Wallet",
  iconUrl: async () => (await import("./injectedWallet-H7LYKTQS-o2YrfzY_.js")).default,
  iconBackground: "#fff",
  createConnector: wP({})
}), uK = ({ appName: e, appIcon: t }) => {
  const n = (i) => i, r = CP();
  return {
    id: "coinbase",
    name: "Coinbase Wallet",
    shortName: "Coinbase",
    rdns: "com.coinbase.wallet",
    iconUrl: async () => (await import("./coinbaseWallet-WWX6LF36-fWs_tBKw.js")).default,
    iconAccent: "#2c5ff6",
    iconBackground: "#2c5ff6",
    // If the coinbase wallet browser extension is not installed, a popup will appear
    // prompting the user to connect or create a wallet via passkey. This means if you either have
    // or don't have the coinbase wallet browser extension installed it'll do some action anyways
    installed: !0,
    downloadUrls: {
      android: "https://play.google.com/store/apps/details?id=org.toshi",
      ios: "https://apps.apple.com/us/app/coinbase-wallet-store-crypto/id1278383455",
      mobile: "https://coinbase.com/wallet/downloads",
      qrCode: "https://coinbase-wallet.onelink.me/q5Sx/fdb9b250",
      chrome: "https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad",
      browserExtension: "https://coinbase.com/wallet"
    },
    ...r ? {} : {
      qrCode: {
        getUri: n,
        instructions: {
          learnMoreUrl: "https://coinbase.com/wallet/articles/getting-started-mobile",
          steps: [
            {
              description: "wallet_connectors.coinbase.qr_code.step1.description",
              step: "install",
              title: "wallet_connectors.coinbase.qr_code.step1.title"
            },
            {
              description: "wallet_connectors.coinbase.qr_code.step2.description",
              step: "create",
              title: "wallet_connectors.coinbase.qr_code.step2.title"
            },
            {
              description: "wallet_connectors.coinbase.qr_code.step3.description",
              step: "scan",
              title: "wallet_connectors.coinbase.qr_code.step3.title"
            }
          ]
        }
      },
      extension: {
        instructions: {
          learnMoreUrl: "https://coinbase.com/wallet/articles/getting-started-extension",
          steps: [
            {
              description: "wallet_connectors.coinbase.extension.step1.description",
              step: "install",
              title: "wallet_connectors.coinbase.extension.step1.title"
            },
            {
              description: "wallet_connectors.coinbase.extension.step2.description",
              step: "create",
              title: "wallet_connectors.coinbase.extension.step2.title"
            },
            {
              description: "wallet_connectors.coinbase.extension.step3.description",
              step: "refresh",
              title: "wallet_connectors.coinbase.extension.step3.title"
            }
          ]
        }
      }
    },
    createConnector: (i) => {
      const o = rA({
        appName: e,
        appLogoUrl: t,
        preference: uK.preference
      });
      return (s) => ({
        ...o(s),
        ...i
      });
    }
  };
};
const HSe = {
  id: 88,
  name: "Viction",
  iconUrl: ay("vic"),
  nativeCurrency: {
    decimals: 18,
    name: "Viction",
    symbol: "VIC"
  },
  rpcUrls: {
    public: { http: ["https://rpc.tomochain.com"] },
    default: { http: ["https://rpc.tomochain.com"] }
  }
}, qSe = async ({
  queryClient: e,
  forceWalletConnectOnly: t,
  yieldGetMyNetworks: n
}) => hA({ queryClient: e, yieldGetMyNetworks: n }).caseOf({
  Right: (r) => {
    const i = E8(
      S8({
        [sn.Ethereum]: {
          type: "evm",
          skChainName: sn.Ethereum,
          wagmiChain: Ub
        },
        [sn.Polygon]: {
          type: "evm",
          skChainName: sn.Polygon,
          wagmiChain: cwe
        },
        [sn.Optimism]: {
          type: "evm",
          skChainName: sn.Optimism,
          wagmiChain: lwe
        },
        [sn.Arbitrum]: {
          type: "evm",
          skChainName: sn.Arbitrum,
          wagmiChain: F0e
        },
        [sn.AvalancheC]: {
          type: "evm",
          skChainName: sn.AvalancheC,
          wagmiChain: U0e
        },
        [sn.Celo]: {
          type: "evm",
          skChainName: sn.Celo,
          wagmiChain: {
            ...ewe,
            iconUrl: Bh(sn.Celo)
          }
        },
        [sn.Harmony]: {
          type: "evm",
          skChainName: sn.Harmony,
          wagmiChain: {
            ...rwe,
            iconUrl: Bh(sn.Harmony)
          }
        },
        [sn.Viction]: {
          type: "evm",
          skChainName: sn.Viction,
          wagmiChain: HSe
        },
        [sn.Binance]: {
          type: "evm",
          skChainName: sn.Binance,
          wagmiChain: V0e
        },
        [sn.Base]: {
          type: "evm",
          skChainName: sn.Base,
          wagmiChain: z0e
        },
        [sn.Linea]: {
          type: "evm",
          skChainName: sn.Linea,
          wagmiChain: {
            ...swe,
            iconUrl: Bh(sn.Linea)
          }
        },
        [sn.Core]: {
          type: "evm",
          skChainName: sn.Core,
          wagmiChain: {
            ...twe,
            name: "Core",
            iconUrl: Bh(sn.Core)
          }
        },
        [sn.EthereumHolesky]: {
          type: "evm",
          skChainName: sn.EthereumHolesky,
          wagmiChain: iwe
        },
        [sn.EthereumGoerli]: {
          type: "evm",
          skChainName: sn.EthereumGoerli,
          wagmiChain: nwe
        }
      }).filter(([c, u]) => r.has(u.skChainName))
    ), o = Object.values(i).map(
      (c) => c.wagmiChain
    ), s = {
      groupName: "Ethereum",
      wallets: t ? [$U] : [
        VSe,
        $Se,
        $U,
        USe,
        uK
      ]
    };
    return Promise.resolve({
      evmChainsMap: i,
      evmChains: o,
      connector: he.fromPredicate(() => !!o.length, s)
    });
  },
  Left: (r) => Promise.reject(r)
}), WSe = (e) => Ye(
  () => e.queryClient.fetchQuery({
    staleTime: Number.POSITIVE_INFINITY,
    queryKey: [ni.appPrefix, "evm-config"],
    queryFn: () => qSe(e)
  })
).mapLeft((t) => new Error("Could not get evm config"));
class GSe {
  constructor(t) {
    this.variantProvider = t;
  }
  invalidProviderType() {
    return Ye.liftEither(Rn(new Error("Invalid provider type")));
  }
  sendTransaction(t) {
    const n = this.variantProvider.current.provider.sendTransaction;
    return n ? Ye(() => n(t)).mapLeft((r) => new Error("Failed to send transaction")) : this.invalidProviderType();
  }
  switchChain({ chainId: t }) {
    return Ye(
      () => this.variantProvider.current.provider.switchChain(t)
    ).mapLeft((n) => new Error("Failed to switch chain"));
  }
  signMessage(t) {
    return Ye(
      () => this.variantProvider.current.provider.signMessage(t)
    ).mapLeft((n) => new Error("Failed to sign message"));
  }
}
const mg = {
  id: "externalProviderConnector",
  name: "External Provider",
  type: "externalProvider"
}, hC = (e) => e.id === mg.id, KSe = (e) => ({
  groupName: "External Providers",
  wallets: [
    () => ({
      id: mg.id,
      name: mg.name,
      iconUrl: ni.appIcon,
      iconBackground: "#fff",
      createConnector: () => (t) => {
        const n = new ly(
          he.fromNullable(e.current.supportedChainIds).map((x) => new Set(x)).mapOrDefault(
            (x) => t.chains.filter((A) => x.has(A.id)),
            t.chains
          )
        ), r = new GSe(e), i = async () => [e.current.currentAddress], o = async () => n.getValue()[0].id, s = async () => {
          t.emitter.emit("message", { type: "connecting" });
          const [x, A] = await Promise.all([
            i(),
            o()
          ]);
          return { accounts: x, chainId: A };
        }, c = async ({ chainId: x }) => (await Ye.liftEither(
          Wn.find(
            (A) => A.id === x,
            t.chains
          ).toEither(new Error("Chain not found"))
        ).chain(
          (A) => r.switchChain({ chainId: `0x${x.toString(16)}` }).map(() => A)
        ).ifRight((A) => v(A.id.toString()))).unsafeCoerce(), u = async () => {
        }, f = async () => ({}), p = async () => !0, y = () => {
          t.emitter.emit("disconnect");
        }, v = (x) => {
          t.emitter.emit("change", {
            chainId: sSe(x)
          });
        }, w = (x) => {
          t.emitter.emit("change", {
            accounts: x.filter((A) => !!A).map((A) => Ma(A))
          });
        }, C = ({ currentChainId: x, supportedChainIds: A }) => {
          n.next(
            he.fromFalsy(!!A.length).map(() => new Set(A)).mapOrDefault(
              (R) => t.chains.filter((I) => R.has(I.id)),
              t.chains
            )
          ), n.getValue().every((R) => R.id !== x) && o().then(
            (R) => v(R.toString())
          );
        };
        return {
          id: mg.id,
          name: mg.name,
          type: mg.type,
          getAccounts: i,
          getChainId: o,
          connect: s,
          disconnect: u,
          getProvider: f,
          isAuthorized: p,
          onDisconnect: y,
          onChainChanged: v,
          onAccountsChanged: w,
          switchChain: c,
          sendTransaction: r.sendTransaction.bind(r),
          signMessage: r.signMessage.bind(r),
          $filteredChains: n.asObservable(),
          onSupportedChainsChanged: C
        };
      }
    })
  ]
}), YSe = [ni.appPrefix, "ledger-live-config"], QSe = Number.POSITIVE_INFINITY, XSe = async ({
  enabledChainsMap: e,
  queryParams: t
}) => Ye.liftEither(
  he.fromFalsy(BC()).toEither(null)
).chain(
  () => Ye(() => import("./ledger-connector-DCndvRS9.js")).mapLeft(() => new Error("Could not import ledger-connector")).map((n) => n.ledgerLiveConnector({ enabledChainsMap: e, queryParams: t }))
).chainLeft((n) => Ye.liftEither(n ? Rn(n) : Pt(null))).caseOf({
  Right: (n) => Promise.resolve(n),
  Left: (n) => Promise.reject(n)
}), JSe = (e) => Ye(
  () => e.queryClient.fetchQuery({
    staleTime: QSe,
    queryKey: YSe,
    queryFn: () => XSe(e)
  })
).mapLeft((t) => new Error("Could not get ledger live config")), ZSe = {
  id: 397,
  name: "NEAR Protocol",
  iconUrl: ay("near"),
  nativeCurrency: {
    decimals: 24,
    name: "Near",
    symbol: "NEAR"
  },
  rpcUrls: {
    public: { http: ["https://rpc.mainnet.near.org"] },
    default: { http: ["https://rpc.mainnet.near.org"] }
  }
}, eke = {
  id: 1729,
  name: "Tezos",
  iconUrl: ay("xtz"),
  nativeCurrency: {
    decimals: 6,
    name: "Tezos",
    symbol: "XTZ"
  },
  rpcUrls: {
    public: { http: ["https://rpc.tzbeta.net/"] },
    default: { http: ["https://rpc.tzbeta.net/"] }
  }
}, tke = {
  id: 501,
  name: "Solana",
  iconUrl: ay("sol"),
  nativeCurrency: {
    decimals: 9,
    name: "Solana",
    symbol: "SOL"
  },
  rpcUrls: {
    public: { http: ["https://api.mainnet-beta.solana.com/"] },
    default: { http: ["https://api.mainnet-beta.solana.com/"] }
  }
}, nke = {
  id: 79,
  name: "Tron",
  iconUrl: ay("trx"),
  nativeCurrency: {
    decimals: 6,
    name: "Tron",
    symbol: "TRX"
  },
  rpcUrls: {
    public: { http: ["https://api.trongrid.io"] },
    default: { http: ["https://api.trongrid.io"] }
  }
}, rke = {
  id: 3412,
  name: "Ton",
  iconUrl: ay("ton"),
  nativeCurrency: {
    decimals: 9,
    name: "Toncoin",
    symbol: "TON"
  },
  rpcUrls: {
    public: { http: ["https://ton.nownodes.io"] },
    default: { http: ["https://ton.nownodes.io"] }
  }
}, ike = [ni.appPrefix, "misc-config"], oke = Number.POSITIVE_INFINITY, ake = async ({
  enabledNetworks: e,
  forceWalletConnectOnly: t
}) => {
  const n = S8({
    [yi.Near]: {
      type: "misc",
      skChainName: yi.Near,
      wagmiChain: ZSe
    },
    [yi.Tezos]: {
      type: "misc",
      skChainName: yi.Tezos,
      wagmiChain: eke
    },
    [yi.Solana]: {
      type: "misc",
      skChainName: yi.Solana,
      wagmiChain: tke
    },
    [yi.Tron]: {
      type: "misc",
      skChainName: yi.Tron,
      wagmiChain: nke
    },
    [yi.Ton]: {
      type: "misc",
      skChainName: yi.Ton,
      wagmiChain: rke
    }
  }).filter(([o, s]) => e.has(s.skChainName)), r = E8(n), i = Object.values(r).map((o) => o.wagmiChain);
  return Promise.all([
    ra.liftMaybe(he.fromFalsy(r.tron)).chain(
      () => ra(() => import("./tron-connector-BEAC20Pu.js").then((o) => o.t)).map(
        (o) => o.getTronConnectors({ forceWalletConnectOnly: t })
      )
    )
  ]).then((o) => ({
    miscChainsMap: r,
    miscChains: i,
    connectors: o
  }));
}, ske = (e) => Ye(
  () => e.queryClient.fetchQuery({
    staleTime: oke,
    queryKey: ike,
    queryFn: () => ake(e)
  })
).mapLeft((t) => new Error("Could not get misc config")), lke = [ni.appPrefix, "safe-config"], cke = Number.POSITIVE_INFINITY, uke = async () => Ye(() => import("./safe-connector-Bb1voBdF.js")).mapLeft(() => new Error("Could not import safe-connector")).map((e) => e.safeConnector()).chainLeft((e) => Ye.liftEither(e ? Rn(e) : Pt(null))).caseOf({
  Right: (e) => Promise.resolve(e),
  Left: (e) => Promise.reject(e)
}), dke = (e) => Ye(
  () => e.queryClient.fetchQuery({
    staleTime: cke,
    queryKey: lke,
    queryFn: () => uke()
  })
).mapLeft((t) => new Error("Could not get safe config")), fke = {
  id: 9999,
  name: "Polkadot",
  iconUrl: Bh(de.Polkadot),
  nativeCurrency: {
    decimals: 10,
    name: "Polkadot",
    symbol: "DOT"
  },
  rpcUrls: {
    public: {
      http: [
        "https://rpc.polkadot.io",
        "https://flashy-side-arrow.dot-mainnet.quiknode.pro/97d5006f66e37488fb9dc1575ef8960e3870dd0f/"
      ],
      webSocket: ["wss://rpc.polkadot.io"]
    },
    default: {
      http: [
        "https://rpc.polkadot.io",
        "https://flashy-side-arrow.dot-mainnet.quiknode.pro/97d5006f66e37488fb9dc1575ef8960e3870dd0f/"
      ],
      webSocket: ["wss://rpc.polkadot.io"]
    }
  }
}, hke = [ni.appPrefix, "substrate-config"], pke = Number.POSITIVE_INFINITY, mke = async ({
  queryClient: e,
  yieldGetMyNetworks: t
}) => hA({ queryClient: e, yieldGetMyNetworks: t }).caseOf({
  Right: (n) => {
    const r = E8(
      S8({
        [Ym.Polkadot]: {
          type: "substrate",
          skChainName: Ym.Polkadot,
          wagmiChain: fke
        }
      }).filter(([o, s]) => n.has(s.skChainName))
    ), i = BC() ? Object.values(r).map((o) => o.wagmiChain) : [];
    return Promise.resolve({ substrateChainsMap: r, substrateChains: i });
  },
  Left: (n) => Promise.reject(n)
}), yke = (e) => Ye(
  () => e.queryClient.fetchQuery({
    staleTime: pke,
    queryKey: hke,
    queryFn: () => mke(e)
  })
).mapLeft((t) => new Error("Could not get substrate config")), vke = async (e) => hA({
  queryClient: e.queryClient,
  yieldGetMyNetworks: e.yieldGetMyNetworks
}).chain(
  (t) => Ye.fromPromise(
    () => {
      var n;
      return Promise.all([
        WSe({
          forceWalletConnectOnly: e.forceWalletConnectOnly,
          queryClient: e.queryClient,
          yieldGetMyNetworks: e.yieldGetMyNetworks
        }),
        MSe({
          forceWalletConnectOnly: e.forceWalletConnectOnly,
          queryClient: e.queryClient,
          yieldGetMyNetworks: e.yieldGetMyNetworks
        }),
        ske({
          enabledNetworks: t,
          queryClient: e.queryClient,
          forceWalletConnectOnly: e.forceWalletConnectOnly
        }),
        yke({
          queryClient: e.queryClient,
          yieldGetMyNetworks: e.yieldGetMyNetworks
        }),
        gA({
          isLedgerLive: e.isLedgerLive,
          queryClient: e.queryClient,
          yieldYieldOpportunity: e.yieldYieldOpportunity,
          externalProviders: (n = e.externalProviders) == null ? void 0 : n.current
        })
      ]).then(
        ([r, i, o, s, c]) => r.chain(
          (u) => i.chain(
            (f) => o.chain(
              (p) => s.chain(
                (y) => c.map((v) => ({
                  evmConfig: u,
                  cosmosConfig: f,
                  miscConfig: p,
                  substrateConfig: y,
                  queryParams: v
                }))
              )
            )
          )
        )
      );
    }
  )
).chain(
  (t) => JSe({
    enabledChainsMap: {
      evm: t.evmConfig.evmChainsMap,
      cosmos: t.cosmosConfig.cosmosChainsMap,
      misc: t.miscConfig.miscChainsMap,
      substrate: t.substrateConfig.substrateChainsMap
    },
    queryClient: e.queryClient,
    queryParams: t.queryParams
  }).map((n) => ({ ...t, ledgerLiveConnector: n }))
).chain(
  (t) => Ye.liftEither(he.fromFalsy(e.isSafe).toEither(null)).chain(() => dke({ queryClient: e.queryClient })).chainLeft((n) => Ye.liftEither(n ? Rn(n) : Pt(null))).map((n) => ({ ...t, safeConnector: n }))
).map((t) => {
  const {
    evmConfig: n,
    cosmosConfig: r,
    miscConfig: i,
    substrateConfig: o,
    ledgerLiveConnector: s
  } = t, c = [
    ...n.evmChains,
    ...r.cosmosWagmiChains,
    ...i.miscChains,
    ...o.substrateChains
  ], u = !e.disableInjectedProviderDiscovery && !e.externalProviders && !t.ledgerLiveConnector && !t.safeConnector, f = (e.externalProviders ? [KSe(e.externalProviders)] : t.safeConnector ? [t.safeConnector] : s ? [s] : e.customConnectors ? e.customConnectors(c) : he.catMaybes([
    n.connector,
    r.connector,
    ...i.connectors
  ])).map((y) => ({
    ...y,
    wallets: y.wallets.map((v) => (w) => {
      const C = v(w);
      return e.mapWalletFn ? {
        ...C,
        ...e.mapWalletFn({
          iconBackground: C.iconBackground,
          iconUrl: C.iconUrl,
          id: C.id,
          name: C.name
        })
      } : C;
    })
  })), p = he.fromNullable(t.queryParams.network).chainNullable(
    (y) => t.evmConfig.evmChainsMap[y] ?? t.cosmosConfig.cosmosChainsMap[y] ?? t.miscConfig.miscChainsMap[y] ?? t.substrateConfig.substrateChainsMap[y]
  ).map((y) => y.wagmiChain.id).extract();
  return {
    ...t,
    wagmiConfig: Xq({
      chains: c,
      client: ({ chain: y }) => G8({ chain: y, transport: qq() }),
      multiInjectedProviderDiscovery: u,
      connectors: PEe(f, {
        appName: ni.appName,
        appIcon: ni.appIcon,
        projectId: ni.walletConnectV2.projectId
      })
    }),
    queryParamsInitChainId: p
  };
}).caseOf({
  Right: async (t) => t,
  Left: (t) => Promise.reject(t)
}), gke = [ni.appPrefix, "wagmi-config"], bke = Number.POSITIVE_INFINITY, ox = () => {
  const {
    wagmi: e,
    externalProviders: t,
    isSafe: n,
    disableInjectedProviderDiscovery: r,
    mapWalletFn: i
  } = dr(), o = tc(), s = yde(), c = ap(), u = Pr(t);
  return Qr({
    staleTime: bke,
    queryKey: gke,
    queryFn: () => vke({
      mapWalletFn: i,
      disableInjectedProviderDiscovery: !!r,
      forceWalletConnectOnly: !!(e != null && e.forceWalletConnectOnly),
      customConnectors: e == null ? void 0 : e.__customConnectors__,
      queryClient: o,
      isLedgerLive: BC(),
      isSafe: !!n,
      yieldGetMyNetworks: s,
      yieldYieldOpportunity: c,
      ...u.current && {
        externalProviders: u
      }
    })
  });
}, wke = Xq({
  chains: [Ub],
  client: ({ chain: e }) => G8({
    chain: e,
    transport: qq(e.rpcUrls.default.http.find((t) => !!t))
  })
}), Cke = () => {
  const e = ox(), { externalProviders: t } = dr();
  return Qr({
    staleTime: Number.POSITIVE_INFINITY,
    enabled: !!e.data,
    queryKey: ["wagmi-config-init"],
    queryFn: () => {
      var i, o;
      const n = (i = e.data) == null ? void 0 : i.wagmiConfig, r = (o = e.data) == null ? void 0 : o.queryParamsInitChainId;
      if (n)
        return Ye(() => Kge(n)).chainLeft(async () => Pt(null)).chain(async (s) => t || s != null && s.length || BC() || !Eue() ? Pt(null) : Ye.liftEither(
          Wn.find(
            (c) => c.id === "injected" || c.id === q$.id,
            n.connectors
          ).toEither(new Error("Could not find injected connector"))
        ).chain(
          (c) => Ye(
            () => Vq(n, {
              connector: c,
              chainId: r
            })
          )
        ).chainLeft(async () => Pt(null))).chain(() => r && n.state.chainId !== r ? Ye(
          () => Gq(n, { chainId: r })
        ).chainLeft(async () => Pt(null)) : Ye.liftEither(Pt(null))).run().then((s) => s.unsafeCoerce());
    }
  });
}, xke = () => {
  const { variant: e, tracking: t } = dr(), n = Qr({
    queryKey: ["tracking", e],
    staleTime: Number.POSITIVE_INFINITY,
    queryFn: async () => e !== "zerion" ? null : (await Ye(() => import("./tracking-variants-DCUjci5E.js")).ifRight((r) => (r.initMixpanel(ni[e].tracking), r.tracking)).map((r) => r.tracking)).unsafeCoerce()
  });
  return { tracking: t, variantTracking: n.data ?? void 0 };
}, HU = {
  earn: "Earn",
  positions: "Positions",
  activity: "Activity",
  positionDetails: "Position details",
  stakeReview: "Stake review",
  unstakeReview: "Unstake review",
  pendingActionReview: "Pending action review",
  stakingSteps: "Staking steps",
  unstakeSteps: "Unstake steps",
  activitySteps: "Activity steps",
  pendingActionSteps: "Pending action steps",
  stakeComplete: "Stake complete",
  activityComplete: "Activity complete",
  unstakeComplete: "Unstake complete",
  pendingActionCompelete: "Pending action complete"
}, qU = {
  tabClicked: "Tab clicked",
  connectWalletClicked: "Connect wallet clicked",
  addLedgerAccountClicked: "Add ledger account clicked",
  selectTokenModalOpened: "Select token modal opened",
  tokenSelected: "Token selected",
  selectYieldModalOpened: "Select yield modal opened",
  yieldSelected: "Yield selected",
  selectValidatorModalOpened: "Select validator modal opened",
  selectValidatorModalClosed: "Select validator modal closed",
  selectValidatorViewMoreClicked: "Select validator view more clicked",
  validatorSelected: "Validator selected",
  validatorRemoved: "Validator removed",
  widgetDisconnectClicked: "Widget disconnect clicked",
  backClicked: "Back clicked",
  helpModalOpened: "Help modal opened",
  earnPageMaxClicked: "Earn page max clicked",
  connectedWallet: "Connected wallet",
  importValidatorModalOpened: "Import validator modal opened",
  chainModalOpened: "Chain modal opened",
  accountModalOpened: "Account modal opened",
  termsClicked: "Terms clicked",
  txSigned: "Transaction signed",
  txSubmitted: "Transaction submitted",
  txNotConfirmed: "Transaction not confirmed",
  positionDetailsPageMaxClicked: "Position details page max clicked",
  unstakeClicked: "Unstake clicked",
  pendingActionClicked: "Pending action clicked",
  validatorsSubmitted: "Validators submitted",
  validatorImported: "Validator imported",
  viewTxClicked: "View transaction clicked"
}, EP = k.createContext(
  void 0
), Eke = ({
  children: e,
  tracking: t,
  variantTracking: n
}) => {
  const r = k.useCallback(
    (s, c) => {
      t == null || t.trackEvent(qU[s], ...c ? [c] : []), n == null || n.trackEvent(
        qU[s],
        ...c ? [c] : []
      );
    },
    [t, n]
  ), i = k.useCallback(
    (s, c) => {
      t == null || t.trackPageView(HU[s], ...c ? [c] : []), n == null || n.trackPageView(
        HU[s],
        ...c ? [c] : []
      );
    },
    [t, n]
  ), o = k.useMemo(
    () => ({ trackEvent: r, trackPageView: i }),
    [r, i]
  );
  return /* @__PURE__ */ S.jsx(EP.Provider, { value: o, children: e });
}, dK = () => {
  const e = k.useContext(EP);
  if (e === void 0)
    throw new Error("useTracking must be used within a TrackingContext");
  return e;
}, Ske = ({
  children: e
}) => /* @__PURE__ */ S.jsx(Eke, { ...xke(), children: e }), Bi = () => dK().trackEvent;
class kke extends Error {
  constructor() {
    super(...arguments);
    Ms(this, "name", "SendTransactionError");
  }
}
class Ake extends Error {
  constructor() {
    super(...arguments);
    Ms(this, "name", "NotSupportedFlowError");
  }
}
class WU extends Error {
  constructor({ network: n, txId: r }) {
    super();
    Ms(this, "txId");
    Ms(this, "network");
    Ms(this, "name", "SignError");
    this.txId = r, this.network = n;
  }
}
class u1 extends Error {
  constructor() {
    super(...arguments);
    Ms(this, "name", "TransactionConstructError");
  }
}
class Tke extends Error {
  constructor() {
    super(...arguments);
    Ms(this, "name", "TXCheckError");
  }
}
class Bk extends Error {
  constructor() {
    super(...arguments);
    Ms(this, "name", "TransactionDecodeError");
  }
}
class _ke extends Error {
  constructor() {
    super(...arguments);
    Ms(this, "name", "SubmitHashError");
  }
}
class Rke extends Error {
  constructor() {
    super(...arguments);
    Ms(this, "name", "SubmitError");
  }
}
const Oke = { type: "cosmosProvider" }, pA = (e) => e.type === Oke.type, Ike = {
  id: "ledgerLive",
  name: "Ledger Live",
  type: "ledgerLive"
}, zd = (e) => e.id === Ike.id, Dke = {
  tronLink: {
    id: "tronLink",
    name: "TronLink",
    type: "tronLinkProvider"
  },
  tronWc: {
    id: "tronWc",
    name: "Wallet Connect",
    type: "tronWcProvider"
  },
  tronBg: {
    id: "tronBg",
    name: "Bitget",
    type: "tronBgProvider"
  },
  tronLedger: {
    id: "tronLedger",
    name: "Ledger",
    type: "tronLedgerProvider"
  }
}, Mke = (e) => Object.values(Dke).some((t) => t.id === e.id), jh = (e) => `${ni.appPrefix}@1//${e}`, Pke = {
  [jh("skPubKeys")]: UR(rs, rs),
  [jh("customValidators")]: UR(
    rs,
    UR(
      rs,
      Bj(
        uo.interface({
          integrationId: rs,
          validatorAddresses: Bj(rs)
        })
      )
    )
  ),
  [jh("referralCode")]: rs,
  [jh("shimDisconnect/tron")]: fue
}, mA = (e) => {
  const t = Ro.extractNullable();
  if (!t) return Pt(null);
  const n = t.localStorage.getItem(e);
  return n ? Oa.encase(() => JSON.parse(n)).chainLeft(() => Pt(n)).chain(
    (r) => Pke[e].decode(r).map((i) => i).mapLeft((i) => new Error(i))
  ) : Pt(null);
}, G4 = (e, t) => {
  const n = Ro.extractNullable();
  return Oa.encase(
    () => n == null ? void 0 : n.localStorage.setItem(e, JSON.stringify(t))
  ).ifRight(() => Bke(e));
}, tD = {
  [jh("customValidators")]: /* @__PURE__ */ new Map(),
  [jh("skPubKeys")]: /* @__PURE__ */ new Map(),
  [jh("referralCode")]: /* @__PURE__ */ new Map(),
  [jh("shimDisconnect/tron")]: /* @__PURE__ */ new Map()
}, Nke = (e, t) => (tD[e].set(t, t), () => tD[e].delete(t)), Bke = (e) => {
  mA(e).ifRight(
    (t) => tD[e].forEach((n) => {
      n(t);
    })
  );
}, fK = (e) => {
  const [t] = k.useState(
    () => new ly(null)
  ), n = k.useCallback(
    (o) => {
      if (!e || !pA(e))
        return () => {
        };
      const s = e.$chainWallet.subscribe((c) => {
        t.next(c), o();
      });
      return () => s.unsubscribe();
    },
    [e, t]
  ), r = k.useCallback(() => t.value, [t]), i = k.useCallback(() => t.value, [t.value]);
  return k.useSyncExternalStore(n, r, i);
}, Lke = ({
  connector: e,
  address: t,
  isConnected: n
}) => {
  const r = fK(e);
  return Qr({
    queryKey: [
      "additional-addresses",
      e == null ? void 0 : e.id,
      r == null ? void 0 : r.chainId,
      t,
      n
    ],
    enabled: !!(e && t && n),
    queryFn: async () => r && e && pA(e) ? (await jke({ connector: e, chainWallet: r })).unsafeCoerce() : Promise.resolve(null)
  });
}, jke = (e) => pA(e.connector) ? Fke(e).map(
  (t) => ({
    cosmosPubKey: t
  })
) : Ye.liftEither(Pt(null)), Fke = (e) => Ye.liftEither(mA("sk-widget@1//skPubKeys")).chain((t) => t ? Ye(() => e.connector.getAccounts()).chain(
  (n) => Ye.liftEither(
    Wn.head(n).toEither(new Error("no account"))
  )
).chain((n) => {
  const r = t[n];
  return r ? Ye.liftEither(Pt(r)) : Ye.liftEither(Rn(null));
}) : Ye.liftEither(Rn(null))).chainLeft(
  () => Ye(
    () => e.chainWallet.client.getAccount(e.chainWallet.chainId)
  ).mapLeft((t) => new Error("missing account")).map((t) => e.connector.toBase64(t.pubkey))
), GU = (e) => !!e.$filteredChains, hK = (e) => !hC(e) && !zd(e) && !dM(e), Uke = (e) => dM(e), zke = ({
  wagmiConfig: e,
  connector: t
}) => {
  const [n] = k.useState(() => new ly([])), r = k.useCallback(
    (s) => {
      if (!t || !GU(t))
        return () => {
        };
      const c = t.$filteredChains.subscribe((u) => {
        n.next(u), s();
      });
      return () => c.unsubscribe();
    },
    [t, n]
  ), i = k.useCallback(() => !t || !GU(t) ? (e == null ? void 0 : e.evmConfig.evmChains) ?? Vke : n.value, [t, n.value, e == null ? void 0 : e.evmConfig.evmChains]), o = k.useCallback(() => n.value, [n.value]);
  return k.useSyncExternalStore(r, i, o);
}, Vke = [], $ke = (e) => {
  const [t] = k.useState(() => new ly([])), n = k.useCallback(
    (o) => {
      if (!e || !zd(e))
        return () => {
        };
      const s = e.$accountsOnCurrentChain.subscribe((c) => {
        t.next(c), o();
      });
      return () => s.unsubscribe();
    },
    [e, t]
  ), r = k.useCallback(() => t.value, [t]), i = k.useCallback(() => t.value, [t.value]);
  return k.useSyncExternalStore(n, r, i);
}, Hke = (e) => {
  const [t] = k.useState(
    () => new ly(void 0)
  ), n = k.useCallback(
    (o) => {
      if (!e || !zd(e))
        return () => {
        };
      const s = e.$currentAccountId.subscribe((c) => {
        t.next(c), o();
      });
      return () => s.unsubscribe();
    },
    [e, t]
  ), r = k.useCallback(() => t.value, [t]), i = k.useCallback(() => t.value, [t.value]);
  return k.useSyncExternalStore(n, r, i);
}, pK = () => {
  const e = k.useRef(!0);
  return k.useEffect(() => {
    e.current && (e.current = !1);
  }, []), e.current;
}, qke = (e, t) => {
  const n = pK();
  k.useEffect(() => {
    if (!n)
      return e();
  }, t);
}, Wke = ({
  address: e,
  chain: t,
  isConnected: n,
  isConnecting: r
}) => {
  const { externalProviders: i } = dr(), { connect: o } = aW(), s = oW(), c = k.useMemo(
    () => Wn.find(
      (y) => hC(y),
      s
    ).filter(hC),
    [s]
  ), u = Pr(o), f = Pr(c), p = Pr(t);
  k.useEffect(() => {
    n || r || !(i != null && i.currentAddress) || c.ifJust(
      (y) => u.current({ connector: y })
    );
  }, [
    n,
    r,
    i == null ? void 0 : i.currentAddress,
    c,
    u
  ]), qke(() => {
    f.current.chain(
      (y) => he.fromNullable(p.current).map((v) => ({ c: v, conn: y }))
    ).ifJust((y) => {
      y.conn.onSupportedChainsChanged({
        supportedChainIds: (i == null ? void 0 : i.supportedChainIds) ?? [],
        currentChainId: y.c.id
      });
    });
  }, [i == null ? void 0 : i.supportedChainIds, f, p]), k.useEffect(() => {
    he.fromRecord({
      externalProviderConnector: c,
      address: he.fromNullable(e),
      chain: he.fromNullable(t)
    }).filter((y) => !!(y.address && y.chain && n)).ifJust((y) => {
      const v = i == null ? void 0 : i.currentAddress, w = i == null ? void 0 : i.currentChain;
      v !== y.address && y.externalProviderConnector.onAccountsChanged([
        v ?? ""
      ]), w && w !== y.chain.id && y.externalProviderConnector.onChainChanged(w.toString());
    });
  }, [
    e,
    t,
    c,
    i == null ? void 0 : i.currentAddress,
    i == null ? void 0 : i.currentChain,
    n
  ]);
};
var nD = /* @__PURE__ */ ((e) => (e.Legacy = "0x1", e.EIP1559 = "0x2", e))(nD || {});
const Gke = ({
  chain: e,
  cosmosChainsMap: t,
  evmChainsMap: n,
  miscChainsMap: r,
  substrateChainsMap: i
}) => {
  var o;
  return ((o = Object.values({
    ...n,
    ...t,
    ...r,
    ...i
  }).find((s) => s.wagmiChain.id === e.id)) == null ? void 0 : o.skChainName) ?? null;
}, KU = ({
  address: e,
  decodedTx: t
}) => ({
  to: t.to,
  from: e,
  data: t.data,
  value: t.value ? en(t.value) : void 0,
  nonce: en(t.nonce),
  gas: en(t.gasLimit),
  chainId: en(t.chainId),
  ...t.maxFeePerGas ? {
    type: nD.EIP1559,
    maxFeePerGas: en(t.maxFeePerGas),
    maxPriorityFeePerGas: t.maxPriorityFeePerGas ? en(t.maxPriorityFeePerGas) : void 0
  } : { type: nD.Legacy }
}), Lk = uo.custom({
  decode: (e) => {
    if (typeof e != "string" && typeof e != "number")
      return Rn("Invalid value type");
    const t = BigInt(e);
    return Pt(t);
  },
  encode: (e) => e.toString()
}), Kke = uo.custom({
  decode: (e) => typeof e == "string" && e.startsWith("0x") ? Pt(e) : Rn("Invalid hex string"),
  encode: (e) => e
}), YU = uo.custom({
  decode: (e) => typeof e == "string" && e.startsWith("0x") ? Pt(e) : Rn("Invalid address"),
  encode: (e) => e
}), BO = uo.interface({
  data: Kke,
  to: YU,
  gasLimit: Lk,
  from: YU,
  value: FR(Lk),
  nonce: D1,
  type: D1,
  maxFeePerGas: FR(Lk),
  maxPriorityFeePerGas: FR(Lk),
  chainId: D1
}), Yke = uo.custom({
  decode(e) {
    const t = e;
    return t.raw_data && t.raw_data_hex && t.txID && "visible" in t ? Pt(t) : Rn("Invalid Tron transaction");
  },
  encode(e) {
    return e;
  }
}), mK = k.createContext(void 0), Qke = ({ children: e }) => {
  const {
    isReconnecting: t,
    isConnected: n,
    isConnecting: r,
    address: i,
    connector: o,
    chain: s
  } = os(), c = i, u = the(), { isLoading: f } = Cke(), p = o != null && o.connect && o.emitter ? o : void 0, { disconnectAsync: y } = Y8(), { sendTransactionAsync: v } = Kbe(), { signMessageAsync: w } = sW(), C = $ke(p), x = Hke(p), A = fK(p), R = ox(), I = zke({
    wagmiConfig: R.data,
    connector: p
  }), D = k.useMemo(
    () => he.fromRecord({
      chain: he.fromNullable(s),
      wagmiConfig: he.fromNullable(R.data)
    }).map(
      (ie) => Gke({
        chain: ie.chain,
        evmChainsMap: ie.wagmiConfig.evmConfig.evmChainsMap,
        cosmosChainsMap: ie.wagmiConfig.cosmosConfig.cosmosChainsMap,
        miscChainsMap: ie.wagmiConfig.miscConfig.miscChainsMap,
        substrateChainsMap: ie.wagmiConfig.substrateConfig.substrateChainsMap
      })
    ).extractNullable(),
    [s, R.data]
  ), M = n && !!c && !!p && !!D, L = Lke({
    address: c,
    connector: p,
    isConnected: M
  }), j = f || r || t || R.isLoading || L.isLoading, F = Bi();
  k.useEffect(() => {
    M && F("connectedWallet", { address: c, network: D });
  }, [c, M, D, F]), Wke({
    address: c,
    chain: s,
    isConnected: M,
    isConnecting: j
  }), tf(() => {
    !j && n && !M && y();
  }, [n, y, M]);
  const O = k.useMemo(
    () => Ye.liftEither(
      !M || !D || !p || !c ? Rn(new Error("No wallet connected")) : Pt({
        conn: p,
        network: D,
        address: c
      })
    ),
    [p, M, D, c]
  ), z = k.useCallback(
    ({ tx: ie, ledgerHwAppId: X }) => O.chain(({ conn: Z, address: J }) => zd(Z) ? Ye.liftEither(
      he.fromNullable(x).toEither(
        new Error("currentAccountId missing")
      )
    ).chain(
      (K) => Ye.liftEither(
        Oa.encase(() => JSON.parse(ie)).mapLeft(() => new Error("JSON.parse failed")).chain(
          (oe) => Oa.encase(
            () => Z.deserializeTransaction(oe)
          ).mapLeft(() => new Error("deserializeTransaction failed"))
        )
      ).map((oe) => ({
        accountId: K,
        deserializedTransaction: oe
      }))
    ).chain(
      ({ accountId: K, deserializedTransaction: oe }) => Ye(
        () => Z.walletApiClient.transaction.signAndBroadcast(
          K,
          oe,
          he.fromNullable(X).map((be) => ({ hwAppId: be })).extract()
        )
      ).mapLeft((be) => new Error("sign failed"))
    ).map((K) => ({ signedTx: K, broadcasted: !0 })) : pA(Z) ? Ye.liftEither(
      he.fromNullable(A).toEither(new Error("cosmosCW missing"))
    ).chain(
      (K) => (
        // We need to sign + broadcast as `walletconnect` cosmos client does not support `sendTx`
        Z.signTransaction({ cw: K, tx: ie }).map((oe) => ({ signedTx: oe, broadcasted: !1 }))
      )
    ) : Mke(Z) ? Ye.liftEither(
      Oa.encase(() => JSON.parse(ie)).chain((K) => Yke.decode(K)).mapLeft((K) => new Bk())
    ).chain(
      (K) => Ye(() => Z.signTransaction(K)).mapLeft((oe) => new Error("sign failed"))
    ).map((K) => ({
      signedTx: JSON.stringify(K),
      broadcasted: !1
    })) : hC(Z) ? Ye.liftEither(
      Oa.encase(() => JSON.parse(ie)).chain((K) => BO.decode(K)).mapLeft((K) => new Bk())
    ).chain(
      (K) => Z.sendTransaction(KU({ address: J, decodedTx: K }))
    ).map((K) => ({ signedTx: K, broadcasted: !0 })) : Ye.liftEither(
      Oa.encase(() => JSON.parse(ie)).chain((K) => BO.decode(K)).mapLeft((K) => new Bk())
    ).chain(
      (K) => Ye(
        () => (
          /**
           * Params need to be in strict format, don't spread the object(val)!
           */
          v({
            data: K.data,
            to: K.to,
            value: K.value,
            nonce: K.nonce,
            maxFeePerGas: K.maxFeePerGas,
            maxPriorityFeePerGas: K.maxPriorityFeePerGas,
            chainId: K.chainId,
            gas: K.gasLimit,
            type: K.maxFeePerGas ? "eip1559" : "legacy"
          })
        )
      ).mapLeft(() => new kke()).map((oe) => ({ signedTx: oe, broadcasted: !0 }))
    )),
    [O, A, x, v]
  ), H = k.useCallback(
    ({ txs: ie }) => O.chain(({ conn: X, address: Z }) => dM(X) ? Ye.liftEither(
      Oa.sequence(
        ie.map(
          (J) => Oa.encase(() => JSON.parse(J)).chain((K) => BO.decode(K)).map((K) => KU({ address: Z, decodedTx: K })).mapLeft(() => new Bk())
        )
      )
    ).chain(
      (J) => X.sendTransactions({
        txs: J.map((K) => ({
          data: K.data,
          to: K.to,
          value: K.value ?? "0"
        }))
      }).map((K) => K.safeTxHash)
    ).chain(
      (J) => Ia({
        fn: () => X.getTxStatus(J).chain(
          (K) => !K.txHash || K.txStatus !== X.txStatus.SUCCESS ? Ye.liftEither(
            Rn(
              new nhe(
                K.txStatus === X.txStatus.FAILED || K.txStatus === X.txStatus.CANCELLED ? "FAILED" : "NOT_READY"
              )
            )
          ) : Ye.liftEither(Pt(K.txHash))
        ).run().then((K) => K.unsafeCoerce()),
        shouldRetry: (K, oe) => he.fromNullable(K).chainNullable(
          (be) => be._tag === "SafeFailedError" ? be : null
        ).filter((be) => be.type !== "FAILED" && !u()).map(() => oe < 120).orDefault(!1),
        retryWaitForMs: () => 7e3
      })
    ).mapLeft(() => new Error("sendTransactions failed")).map((J) => ({ signedTx: J, broadcasted: !0 })) : Ye.liftEither(Rn(new Ake()))),
    [O, u]
  ), Q = k.useCallback(
    (ie) => O.chain(({ conn: X }) => hC(X) ? X.signMessage(ie) : Ye(() => w({ message: ie }))).mapLeft((X) => new Error("sign failed")),
    [O, w]
  ), Y = k.useCallback(
    (ie) => {
      p && zd(p) && p.switchAccount(ie);
    },
    [p]
  ), ee = k.useMemo(() => {
    const ie = BC() || !!(p && zd(p)), X = {
      disconnect: y,
      signTransaction: z,
      signMultipleTransactions: H,
      signMessage: Q,
      connectorChains: I,
      isLedgerLive: ie
    };
    return M && s && !j ? {
      ...X,
      network: D,
      address: c,
      chain: s,
      isConnected: !0,
      isConnecting: !1,
      additionalAddresses: L.data ?? null,
      ledgerAccounts: C,
      onLedgerAccountChange: Y,
      connector: p,
      isLedgerLiveAccountPlaceholder: p && zd(p) && c === p.noAccountPlaceholder
    } : {
      ...X,
      network: null,
      address: null,
      chain: null,
      isConnected: !1,
      isConnecting: j,
      additionalAddresses: null,
      ledgerAccounts: null,
      onLedgerAccountChange: null,
      connector: null,
      isLedgerLiveAccountPlaceholder: !1
    };
  }, [
    I,
    L.data,
    c,
    s,
    p,
    y,
    M,
    j,
    C,
    D,
    Y,
    z,
    H,
    Q
  ]);
  return /* @__PURE__ */ S.jsx(mK.Provider, { value: ee, children: e });
}, fr = () => {
  const e = k.useContext(mK);
  if (e === void 0)
    throw new Error("useSKWallet must be used within a SKWalletProvider");
  return e;
}, yK = 1e3 * 60 * 2, SP = (e) => [
  "yield-opportunity",
  e.yieldId,
  e.isLedgerLive
], yA = (e) => {
  const { isLedgerLive: t } = fr(), n = e ?? "", r = ap();
  return Qr({
    queryKey: SP({ yieldId: n, isLedgerLive: t }),
    enabled: !!e,
    staleTime: yK,
    queryFn: ({ signal: i }) => vK({ yieldId: n, isLedgerLive: t, yieldYieldOpportunity: r, signal: i })
  });
}, vA = (e) => Ye(
  () => e.queryClient.fetchQuery({
    queryKey: SP(e),
    staleTime: yK,
    queryFn: ({ signal: t }) => vK({ ...e, signal: t })
  })
).mapLeft((t) => new Error("Could not get yield opportunity")), vK = async (e) => (await Xke(e)).unsafeCoerce(), Xke = ({
  isLedgerLive: e,
  yieldId: t,
  yieldYieldOpportunity: n,
  signal: r
}) => Ia({
  fn: () => n(
    t,
    {
      ledgerWalletAPICompatible: e
    },
    r
  )
}).mapLeft((i) => new Error("Could not get yield opportunity")), Jke = ({
  yieldDto: e,
  isLedgerLive: t,
  queryClient: n
}) => {
  n.setQueryData(
    SP({ isLedgerLive: t, yieldId: e.id }),
    e
  );
}, gK = ["init-params"], bK = 0, wK = 0, pC = (e) => {
  const { isLedgerLive: t } = fr(), { externalProviders: n } = dr(), r = tc(), i = ap();
  return Qr({
    queryKey: gK,
    staleTime: bK,
    gcTime: wK,
    queryFn: () => CK({
      isLedgerLive: t,
      queryClient: r,
      yieldYieldOpportunity: i,
      externalProviders: n
    }),
    select: e == null ? void 0 : e.select
  });
}, gA = (e) => Ye(
  () => e.queryClient.fetchQuery({
    queryKey: gK,
    staleTime: bK,
    gcTime: wK,
    queryFn: () => CK(e)
  })
).mapLeft((t) => new Error("could not get init query params")), CK = async (e) => (await Zke(e)).unsafeCoerce(), Zke = ({
  isLedgerLive: e,
  queryClient: t,
  yieldYieldOpportunity: n,
  externalProviders: r
}) => Ye.liftEither(
  $$({
    externalProviderInitToken: r == null ? void 0 : r.initToken
  }).toEither(new Error("missing query params"))
).chain((i) => {
  const o = i.yieldId;
  return o ? vA({
    isLedgerLive: e,
    yieldId: o,
    queryClient: t,
    yieldYieldOpportunity: n
  }).map((s) => ({
    ...i,
    network: s.token.network,
    token: s.token.symbol,
    yieldData: s
  })).chainLeft(async () => Pt({ ...i, yieldData: null })) : Ye.liftEither(Pt({ ...i, yieldData: null }));
}), e4e = () => {
  const { data: e, error: t } = Lue({
    query: { refetchInterval: 3e4 }
  });
  return !!((t == null ? void 0 : t.status) === 500 || e != null && e.db && e.db !== "OK");
}, t4e = ({
  language: e,
  countryCode: t
}) => new Intl.DisplayNames([e], { type: "region" }).of(t), Hh = (e) => {
  const { rewardRate: t, rewardType: n } = e;
  return n === "variable" || !t ? "- %" : `${e5(t)}%`;
}, xK = (e) => {
  switch (e) {
    case "apr":
      return "APR";
    case "apy":
      return "APY";
    default:
      return "";
  }
}, kP = ({
  yieldDto: e,
  gas: t,
  prices: n
}) => he.fromRecord({
  yieldDto: e,
  gas: t
}).map((r) => ({
  ...r,
  gasFeeInUSD: Vb({
    amount: r.gas.toString(),
    prices: n.orDefault(new gP(/* @__PURE__ */ new Map())),
    token: r.yieldDto.metadata.gasFeeToken,
    pricePerShare: null,
    baseToken: null
  })
})).mapOrDefault(
  (r) => `${To(r.gas, 10)} ${r.yieldDto.metadata.gasFeeToken.symbol} ${r.gasFeeInUSD.isGreaterThan(0) ? ` ($${Na(r.gasFeeInUSD)})` : ""}`,
  ""
), n4e = ({
  amount: e,
  prices: t,
  token: n
}) => he.fromRecord({ token: n, amount: e }).map((r) => ({
  ...r,
  feeInUSD: Vb({
    amount: r.amount,
    prices: t.orDefault(new gP(/* @__PURE__ */ new Map())),
    token: r.token,
    pricePerShare: null,
    baseToken: null
  })
})).mapOrDefault(
  (r) => `${To(r.amount, 10)} ${r.token.symbol} ${r.feeInUSD.isGreaterThan(0) ? ` ($${Na(r.feeInUSD)})` : ""}`,
  ""
), K4 = (e) => he.fromNullable(e).map(
  (t) => t.split(" ").map(
    (n) => n.charAt(0).toUpperCase() + n.slice(1).toLowerCase()
  ).join(" ")
).orDefault(""), QU = ({
  integrationData: e,
  validatorAddress: t
}) => {
  const n = e.chain(
    (r) => he.fromNullable(r.metadata.provider).map((i) => ({
      logo: i.logoURI,
      name: i.name,
      rewardRateFormatted: Hh({
        rewardRate: r.rewardRate,
        rewardType: r.rewardType
      }),
      rewardRate: r.rewardRate,
      rewardType: r.rewardType,
      website: i.externalLink
    })).altLazy(
      () => he.of({
        logo: r.metadata.logoURI,
        name: r.metadata.name,
        rewardRateFormatted: Hh({
          rewardRate: r.rewardRate,
          rewardType: r.rewardType
        }),
        rewardRate: r.rewardRate,
        rewardType: r.rewardType
      })
    )
  );
  return e.chain(
    (r) => t.chain(
      (i) => Wn.find(
        (o) => o.address === i || o.providerId === i,
        r.validators
      ).map((o) => ({
        logo: o.image,
        name: o.name ?? o.address,
        rewardRateFormatted: Hh({
          rewardRate: o.apr,
          rewardType: r.rewardType
        }),
        rewardRate: o.apr,
        rewardType: r.rewardType,
        address: o.address,
        stakedBalance: o.stakedBalance,
        votingPower: o.votingPower,
        commission: o.commission,
        status: o.status,
        website: o.website,
        preferred: o.preferred
      }))
    ).altLazy(() => n)
  );
}, cf = ({
  integrationData: e,
  validatorsAddresses: t
}) => k.useMemo(
  () => t.chain(
    (n) => he.sequence(
      (n instanceof Map ? [...n.values()].map((r) => r.address) : n).map(
        (r) => QU({
          integrationData: e,
          validatorAddress: he.of(r)
        })
      )
    ).chain(
      (r) => r.length ? he.of(r) : QU({
        integrationData: e,
        validatorAddress: he.empty()
      }).map((i) => [i])
    )
  ),
  [e, t]
), Xh = (e) => {
  const { t } = ln();
  return e.chainNullable((n) => nK(n, t));
}, XU = /* @__PURE__ */ new Set();
function bA(e, t, n) {
  e || XU.has(t) || XU.add(t);
}
function r4e(e) {
  if (typeof Proxy > "u")
    return e;
  const t = /* @__PURE__ */ new Map(), n = (...r) => (ct.env.NODE_ENV !== "production" && bA(!1, "motion() is deprecated. Use motion.create() instead."), e(...r));
  return new Proxy(n, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (r, i) => i === "create" ? e : (t.has(i) || t.set(i, e(i)), t.get(i))
  });
}
function mC(e) {
  return e !== null && typeof e == "object" && typeof e.start == "function";
}
const rD = (e) => Array.isArray(e);
function EK(e, t) {
  if (!Array.isArray(t))
    return !1;
  const n = t.length;
  if (n !== e.length)
    return !1;
  for (let r = 0; r < n; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
function yC(e) {
  return typeof e == "string" || Array.isArray(e);
}
function JU(e) {
  const t = [{}, {}];
  return e == null || e.values.forEach((n, r) => {
    t[0][r] = n.get(), t[1][r] = n.getVelocity();
  }), t;
}
function AP(e, t, n, r) {
  if (typeof t == "function") {
    const [i, o] = JU(r);
    t = t(n !== void 0 ? n : e.custom, i, o);
  }
  if (typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function") {
    const [i, o] = JU(r);
    t = t(n !== void 0 ? n : e.custom, i, o);
  }
  return t;
}
function wA(e, t, n) {
  const r = e.getProps();
  return AP(r, t, n !== void 0 ? n : r.custom, e);
}
const TP = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], _P = ["initial", ...TP], ax = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], cp = new Set(ax), Uc = (e) => e * 1e3, Bu = (e) => e / 1e3, i4e = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, o4e = (e) => ({
  type: "spring",
  stiffness: 550,
  damping: e === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), a4e = {
  type: "keyframes",
  duration: 0.8
}, s4e = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, l4e = (e, { keyframes: t }) => t.length > 2 ? a4e : cp.has(e) ? e.startsWith("scale") ? o4e(t[1]) : i4e : s4e;
function c4e({ when: e, delay: t, delayChildren: n, staggerChildren: r, staggerDirection: i, repeat: o, repeatType: s, repeatDelay: c, from: u, elapsed: f, ...p }) {
  return !!Object.keys(p).length;
}
function RP(e, t) {
  return e[t] || e.default || e;
}
const u4e = {
  skipAnimations: !1,
  useManualTiming: !1
}, d4e = (e) => e !== null;
function CA(e, { repeat: t, repeatType: n = "loop" }, r) {
  const i = e.filter(d4e), o = t && n !== "loop" && t % 2 === 1 ? 0 : i.length - 1;
  return !o || r === void 0 ? i[o] : r;
}
const oa = (e) => e;
function f4e(e) {
  let t = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set(), r = !1, i = !1;
  const o = /* @__PURE__ */ new WeakSet();
  let s = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function c(f) {
    o.has(f) && (u.schedule(f), e()), f(s);
  }
  const u = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (f, p = !1, y = !1) => {
      const w = y && r ? t : n;
      return p && o.add(f), w.has(f) || w.add(f), f;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (f) => {
      n.delete(f), o.delete(f);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (f) => {
      if (s = f, r) {
        i = !0;
        return;
      }
      r = !0, [t, n] = [n, t], n.clear(), t.forEach(c), r = !1, i && (i = !1, u.process(f));
    }
  };
  return u;
}
const jk = [
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
], h4e = 40;
function SK(e, t) {
  let n = !1, r = !0;
  const i = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, o = () => n = !0, s = jk.reduce((R, I) => (R[I] = f4e(o), R), {}), { read: c, resolveKeyframes: u, update: f, preRender: p, render: y, postRender: v } = s, w = () => {
    const R = performance.now();
    n = !1, i.delta = r ? 1e3 / 60 : Math.max(Math.min(R - i.timestamp, h4e), 1), i.timestamp = R, i.isProcessing = !0, c.process(i), u.process(i), f.process(i), p.process(i), y.process(i), v.process(i), i.isProcessing = !1, n && t && (r = !1, e(w));
  }, C = () => {
    n = !0, r = !0, i.isProcessing || e(w);
  };
  return { schedule: jk.reduce((R, I) => {
    const D = s[I];
    return R[I] = (M, L = !1, j = !1) => (n || C(), D.schedule(M, L, j)), R;
  }, {}), cancel: (R) => {
    for (let I = 0; I < jk.length; I++)
      s[jk[I]].cancel(R);
  }, state: i, steps: s };
}
const { schedule: Or, cancel: Vu, state: ia, steps: LO } = SK(typeof requestAnimationFrame < "u" ? requestAnimationFrame : oa, !0), kK = (e) => /^0[^.\s]+$/u.test(e);
function p4e(e) {
  return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || kK(e) : !0;
}
let Hb = oa, dl = oa;
ct.env.NODE_ENV !== "production" && (Hb = (e, t) => {
}, dl = (e, t) => {
  if (!e)
    throw new Error(t);
});
const AK = (e) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e), TK = (e) => (t) => typeof t == "string" && t.startsWith(e), _K = TK("--"), m4e = TK("var(--"), OP = (e) => m4e(e) ? y4e.test(e.split("/*")[0].trim()) : !1, y4e = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, v4e = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function g4e(e) {
  const t = v4e.exec(e);
  if (!t)
    return [,];
  const [, n, r, i] = t;
  return [`--${n ?? r}`, i];
}
const b4e = 4;
function RK(e, t, n = 1) {
  dl(n <= b4e, `Max CSS variable fallback depth detected in property "${e}". This may indicate a circular fallback dependency.`);
  const [r, i] = g4e(e);
  if (!r)
    return;
  const o = window.getComputedStyle(t).getPropertyValue(r);
  if (o) {
    const s = o.trim();
    return AK(s) ? parseFloat(s) : s;
  }
  return OP(i) ? RK(i, t, n + 1) : i;
}
const Jh = (e, t, n) => n > t ? t : n < e ? e : n, qb = {
  test: (e) => typeof e == "number",
  parse: parseFloat,
  transform: (e) => e
}, B1 = {
  ...qb,
  transform: (e) => Jh(0, 1, e)
}, Fk = {
  ...qb,
  default: 1
}, L1 = (e) => Math.round(e * 1e5) / 1e5, IP = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu, w4e = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu, C4e = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;
function sx(e) {
  return typeof e == "string";
}
function x4e(e) {
  return e == null;
}
const lx = (e) => ({
  test: (t) => sx(t) && t.endsWith(e) && t.split(" ").length === 1,
  parse: parseFloat,
  transform: (t) => `${t}${e}`
}), Sh = /* @__PURE__ */ lx("deg"), Lu = /* @__PURE__ */ lx("%"), Tn = /* @__PURE__ */ lx("px"), E4e = /* @__PURE__ */ lx("vh"), S4e = /* @__PURE__ */ lx("vw"), ZU = {
  ...Lu,
  parse: (e) => Lu.parse(e) / 100,
  transform: (e) => Lu.transform(e * 100)
}, k4e = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y",
  "translateX",
  "translateY"
]), e7 = (e) => e === qb || e === Tn, t7 = (e, t) => parseFloat(e.split(", ")[t]), n7 = (e, t) => (n, { transform: r }) => {
  if (r === "none" || !r)
    return 0;
  const i = r.match(/^matrix3d\((.+)\)$/u);
  if (i)
    return t7(i[1], t);
  {
    const o = r.match(/^matrix\((.+)\)$/u);
    return o ? t7(o[1], e) : 0;
  }
}, A4e = /* @__PURE__ */ new Set(["x", "y", "z"]), T4e = ax.filter((e) => !A4e.has(e));
function _4e(e) {
  const t = [];
  return T4e.forEach((n) => {
    const r = e.getValue(n);
    r !== void 0 && (t.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0));
  }), t;
}
const hb = {
  // Dimensions
  width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  top: (e, { top: t }) => parseFloat(t),
  left: (e, { left: t }) => parseFloat(t),
  bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min),
  right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min),
  // Transform
  x: n7(4, 13),
  y: n7(5, 14)
};
hb.translateX = hb.x;
hb.translateY = hb.y;
const OK = (e) => (t) => t.test(e), R4e = {
  test: (e) => e === "auto",
  parse: (e) => e
}, IK = [qb, Tn, Lu, Sh, S4e, E4e, R4e], r7 = (e) => IK.find(OK(e)), $m = /* @__PURE__ */ new Set();
let iD = !1, oD = !1;
function DK() {
  if (oD) {
    const e = Array.from($m).filter((r) => r.needsMeasurement), t = new Set(e.map((r) => r.element)), n = /* @__PURE__ */ new Map();
    t.forEach((r) => {
      const i = _4e(r);
      i.length && (n.set(r, i), r.render());
    }), e.forEach((r) => r.measureInitialState()), t.forEach((r) => {
      r.render();
      const i = n.get(r);
      i && i.forEach(([o, s]) => {
        var c;
        (c = r.getValue(o)) === null || c === void 0 || c.set(s);
      });
    }), e.forEach((r) => r.measureEndState()), e.forEach((r) => {
      r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY);
    });
  }
  oD = !1, iD = !1, $m.forEach((e) => e.complete()), $m.clear();
}
function MK() {
  $m.forEach((e) => {
    e.readKeyframes(), e.needsMeasurement && (oD = !0);
  });
}
function O4e() {
  MK(), DK();
}
class DP {
  constructor(t, n, r, i, o, s = !1) {
    this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...t], this.onComplete = n, this.name = r, this.motionValue = i, this.element = o, this.isAsync = s;
  }
  scheduleResolve() {
    this.isScheduled = !0, this.isAsync ? ($m.add(this), iD || (iD = !0, Or.read(MK), Or.resolveKeyframes(DK))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, name: n, element: r, motionValue: i } = this;
    for (let o = 0; o < t.length; o++)
      if (t[o] === null)
        if (o === 0) {
          const s = i == null ? void 0 : i.get(), c = t[t.length - 1];
          if (s !== void 0)
            t[0] = s;
          else if (r && n) {
            const u = r.readValue(n, c);
            u != null && (t[0] = u);
          }
          t[0] === void 0 && (t[0] = c), i && s === void 0 && i.set(t[0]);
        } else
          t[o] = t[o - 1];
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete() {
    this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), $m.delete(this);
  }
  cancel() {
    this.isComplete || (this.isScheduled = !1, $m.delete(this));
  }
  resume() {
    this.isComplete || this.scheduleResolve();
  }
}
const MP = (e, t) => (n) => !!(sx(n) && C4e.test(n) && n.startsWith(e) || t && !x4e(n) && Object.prototype.hasOwnProperty.call(n, t)), PK = (e, t, n) => (r) => {
  if (!sx(r))
    return r;
  const [i, o, s, c] = r.match(IP);
  return {
    [e]: parseFloat(i),
    [t]: parseFloat(o),
    [n]: parseFloat(s),
    alpha: c !== void 0 ? parseFloat(c) : 1
  };
}, I4e = (e) => Jh(0, 255, e), jO = {
  ...qb,
  transform: (e) => Math.round(I4e(e))
}, Om = {
  test: /* @__PURE__ */ MP("rgb", "red"),
  parse: /* @__PURE__ */ PK("red", "green", "blue"),
  transform: ({ red: e, green: t, blue: n, alpha: r = 1 }) => "rgba(" + jO.transform(e) + ", " + jO.transform(t) + ", " + jO.transform(n) + ", " + L1(B1.transform(r)) + ")"
};
function D4e(e) {
  let t = "", n = "", r = "", i = "";
  return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), r = e.substring(5, 7), i = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), r = e.substring(3, 4), i = e.substring(4, 5), t += t, n += n, r += r, i += i), {
    red: parseInt(t, 16),
    green: parseInt(n, 16),
    blue: parseInt(r, 16),
    alpha: i ? parseInt(i, 16) / 255 : 1
  };
}
const aD = {
  test: /* @__PURE__ */ MP("#"),
  parse: D4e,
  transform: Om.transform
}, Cg = {
  test: /* @__PURE__ */ MP("hsl", "hue"),
  parse: /* @__PURE__ */ PK("hue", "saturation", "lightness"),
  transform: ({ hue: e, saturation: t, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(e) + ", " + Lu.transform(L1(t)) + ", " + Lu.transform(L1(n)) + ", " + L1(B1.transform(r)) + ")"
}, Ta = {
  test: (e) => Om.test(e) || aD.test(e) || Cg.test(e),
  parse: (e) => Om.test(e) ? Om.parse(e) : Cg.test(e) ? Cg.parse(e) : aD.parse(e),
  transform: (e) => sx(e) ? e : e.hasOwnProperty("red") ? Om.transform(e) : Cg.transform(e)
};
function M4e(e) {
  var t, n;
  return isNaN(e) && sx(e) && (((t = e.match(IP)) === null || t === void 0 ? void 0 : t.length) || 0) + (((n = e.match(w4e)) === null || n === void 0 ? void 0 : n.length) || 0) > 0;
}
const NK = "number", BK = "color", P4e = "var", N4e = "var(", i7 = "${}", B4e = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function vC(e) {
  const t = e.toString(), n = [], r = {
    color: [],
    number: [],
    var: []
  }, i = [];
  let o = 0;
  const c = t.replace(B4e, (u) => (Ta.test(u) ? (r.color.push(o), i.push(BK), n.push(Ta.parse(u))) : u.startsWith(N4e) ? (r.var.push(o), i.push(P4e), n.push(u)) : (r.number.push(o), i.push(NK), n.push(parseFloat(u))), ++o, i7)).split(i7);
  return { values: n, split: c, indexes: r, types: i };
}
function LK(e) {
  return vC(e).values;
}
function jK(e) {
  const { split: t, types: n } = vC(e), r = t.length;
  return (i) => {
    let o = "";
    for (let s = 0; s < r; s++)
      if (o += t[s], i[s] !== void 0) {
        const c = n[s];
        c === NK ? o += L1(i[s]) : c === BK ? o += Ta.transform(i[s]) : o += i[s];
      }
    return o;
  };
}
const L4e = (e) => typeof e == "number" ? 0 : e;
function j4e(e) {
  const t = LK(e);
  return jK(e)(t.map(L4e));
}
const Zh = {
  test: M4e,
  parse: LK,
  createTransformer: jK,
  getAnimatableNone: j4e
}, F4e = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function U4e(e) {
  const [t, n] = e.slice(0, -1).split("(");
  if (t === "drop-shadow")
    return e;
  const [r] = n.match(IP) || [];
  if (!r)
    return e;
  const i = n.replace(r, "");
  let o = F4e.has(t) ? 1 : 0;
  return r !== n && (o *= 100), t + "(" + o + i + ")";
}
const z4e = /\b([a-z-]*)\(.*?\)/gu, sD = {
  ...Zh,
  getAnimatableNone: (e) => {
    const t = e.match(z4e);
    return t ? t.map(U4e).join(" ") : e;
  }
}, o7 = {
  ...qb,
  transform: Math.round
}, PP = {
  // Border props
  borderWidth: Tn,
  borderTopWidth: Tn,
  borderRightWidth: Tn,
  borderBottomWidth: Tn,
  borderLeftWidth: Tn,
  borderRadius: Tn,
  radius: Tn,
  borderTopLeftRadius: Tn,
  borderTopRightRadius: Tn,
  borderBottomRightRadius: Tn,
  borderBottomLeftRadius: Tn,
  // Positioning props
  width: Tn,
  maxWidth: Tn,
  height: Tn,
  maxHeight: Tn,
  size: Tn,
  top: Tn,
  right: Tn,
  bottom: Tn,
  left: Tn,
  // Spacing props
  padding: Tn,
  paddingTop: Tn,
  paddingRight: Tn,
  paddingBottom: Tn,
  paddingLeft: Tn,
  margin: Tn,
  marginTop: Tn,
  marginRight: Tn,
  marginBottom: Tn,
  marginLeft: Tn,
  // Transform props
  rotate: Sh,
  rotateX: Sh,
  rotateY: Sh,
  rotateZ: Sh,
  scale: Fk,
  scaleX: Fk,
  scaleY: Fk,
  scaleZ: Fk,
  skew: Sh,
  skewX: Sh,
  skewY: Sh,
  distance: Tn,
  translateX: Tn,
  translateY: Tn,
  translateZ: Tn,
  x: Tn,
  y: Tn,
  z: Tn,
  perspective: Tn,
  transformPerspective: Tn,
  opacity: B1,
  originX: ZU,
  originY: ZU,
  originZ: Tn,
  // Misc
  zIndex: o7,
  backgroundPositionX: Tn,
  backgroundPositionY: Tn,
  // SVG
  fillOpacity: B1,
  strokeOpacity: B1,
  numOctaves: o7
}, V4e = {
  ...PP,
  // Color props
  color: Ta,
  backgroundColor: Ta,
  outlineColor: Ta,
  fill: Ta,
  stroke: Ta,
  // Border props
  borderColor: Ta,
  borderTopColor: Ta,
  borderRightColor: Ta,
  borderBottomColor: Ta,
  borderLeftColor: Ta,
  filter: sD,
  WebkitFilter: sD
}, NP = (e) => V4e[e];
function FK(e, t) {
  let n = NP(e);
  return n !== sD && (n = Zh), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0;
}
const $4e = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function H4e(e, t, n) {
  let r = 0, i;
  for (; r < e.length && !i; ) {
    const o = e[r];
    typeof o == "string" && !$4e.has(o) && vC(o).values.length && (i = e[r]), r++;
  }
  if (i && n)
    for (const o of t)
      e[o] = FK(n, i);
}
class UK extends DP {
  constructor(t, n, r, i, o) {
    super(t, n, r, i, o, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, element: n, name: r } = this;
    if (!n || !n.current)
      return;
    super.readKeyframes();
    for (let u = 0; u < t.length; u++) {
      let f = t[u];
      if (typeof f == "string" && (f = f.trim(), OP(f))) {
        const p = RK(f, n.current);
        p !== void 0 && (t[u] = p), u === t.length - 1 && (this.finalKeyframe = f);
      }
    }
    if (this.resolveNoneKeyframes(), !k4e.has(r) || t.length !== 2)
      return;
    const [i, o] = t, s = r7(i), c = r7(o);
    if (s !== c)
      if (e7(s) && e7(c))
        for (let u = 0; u < t.length; u++) {
          const f = t[u];
          typeof f == "string" && (t[u] = parseFloat(f));
        }
      else
        this.needsMeasurement = !0;
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: t, name: n } = this, r = [];
    for (let i = 0; i < t.length; i++)
      p4e(t[i]) && r.push(i);
    r.length && H4e(t, r, n);
  }
  measureInitialState() {
    const { element: t, unresolvedKeyframes: n, name: r } = this;
    if (!t || !t.current)
      return;
    r === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = hb[r](t.measureViewportBox(), window.getComputedStyle(t.current)), n[0] = this.measuredOrigin;
    const i = n[n.length - 1];
    i !== void 0 && t.getValue(r, i).jump(i, !1);
  }
  measureEndState() {
    var t;
    const { element: n, name: r, unresolvedKeyframes: i } = this;
    if (!n || !n.current)
      return;
    const o = n.getValue(r);
    o && o.jump(this.measuredOrigin, !1);
    const s = i.length - 1, c = i[s];
    i[s] = hb[r](n.measureViewportBox(), window.getComputedStyle(n.current)), c !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = c), !((t = this.removedTransforms) === null || t === void 0) && t.length && this.removedTransforms.forEach(([u, f]) => {
      n.getValue(u).set(f);
    }), this.resolveNoneKeyframes();
  }
}
function zK(e) {
  let t;
  return () => (t === void 0 && (t = e()), t);
}
let h4;
function q4e() {
  h4 = void 0;
}
const Wd = {
  now: () => (h4 === void 0 && Wd.set(ia.isProcessing || u4e.useManualTiming ? ia.timestamp : performance.now()), h4),
  set: (e) => {
    h4 = e, queueMicrotask(q4e);
  }
}, a7 = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && // It's animatable if we have a string
(Zh.test(e) || e === "0") && // And it contains numbers and/or colors
!e.startsWith("url("));
function W4e(e) {
  const t = e[0];
  if (e.length === 1)
    return !0;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t)
      return !0;
}
function G4e(e, t, n, r) {
  const i = e[0];
  if (i === null)
    return !1;
  if (t === "display" || t === "visibility")
    return !0;
  const o = e[e.length - 1], s = a7(i, t), c = a7(o, t);
  return Hb(s === c, `You are trying to animate ${t} from "${i}" to "${o}". ${i} is not an animatable value - to enable this animation set ${i} to a value animatable to ${o} via the \`style\` property.`), !s || !c ? !1 : W4e(e) || n === "spring" && r;
}
const K4e = 40;
class VK {
  constructor({ autoplay: t = !0, delay: n = 0, type: r = "keyframes", repeat: i = 0, repeatDelay: o = 0, repeatType: s = "loop", ...c }) {
    this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = Wd.now(), this.options = {
      autoplay: t,
      delay: n,
      type: r,
      repeat: i,
      repeatDelay: o,
      repeatType: s,
      ...c
    }, this.updateFinishedPromise();
  }
  /**
   * This method uses the createdAt and resolvedAt to calculate the
   * animation startTime. *Ideally*, we would use the createdAt time as t=0
   * as the following frame would then be the first frame of the animation in
   * progress, which would feel snappier.
   *
   * However, if there's a delay (main thread work) between the creation of
   * the animation and the first commited frame, we prefer to use resolvedAt
   * to avoid a sudden jump into the animation.
   */
  calcStartTime() {
    return this.resolvedAt ? this.resolvedAt - this.createdAt > K4e ? this.resolvedAt : this.createdAt : this.createdAt;
  }
  /**
   * A getter for resolved data. If keyframes are not yet resolved, accessing
   * this.resolved will synchronously flush all pending keyframe resolvers.
   * This is a deoptimisation, but at its worst still batches read/writes.
   */
  get resolved() {
    return !this._resolved && !this.hasAttemptedResolve && O4e(), this._resolved;
  }
  /**
   * A method to be called when the keyframes resolver completes. This method
   * will check if its possible to run the animation and, if not, skip it.
   * Otherwise, it will call initPlayback on the implementing class.
   */
  onKeyframesResolved(t, n) {
    this.resolvedAt = Wd.now(), this.hasAttemptedResolve = !0;
    const { name: r, type: i, velocity: o, delay: s, onComplete: c, onUpdate: u, isGenerator: f } = this.options;
    if (!f && !G4e(t, r, i, o))
      if (s)
        this.options.duration = 0;
      else {
        u == null || u(CA(t, this.options, n)), c == null || c(), this.resolveFinishedPromise();
        return;
      }
    const p = this.initPlayback(t, n);
    p !== !1 && (this._resolved = {
      keyframes: t,
      finalKeyframe: n,
      ...p
    }, this.onPostResolved());
  }
  onPostResolved() {
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(t, n) {
    return this.currentFinishedPromise.then(t, n);
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise((t) => {
      this.resolveFinishedPromise = t;
    });
  }
}
function $K(e, t) {
  return t ? e * (1e3 / t) : 0;
}
const Y4e = 5;
function HK(e, t, n) {
  const r = Math.max(t - Y4e, 0);
  return $K(n - e(r), t - r);
}
const FO = 1e-3, Q4e = 0.01, s7 = 10, X4e = 0.05, J4e = 1;
function Z4e({ duration: e = 800, bounce: t = 0.25, velocity: n = 0, mass: r = 1 }) {
  let i, o;
  Hb(e <= Uc(s7), "Spring duration must be 10 seconds or less");
  let s = 1 - t;
  s = Jh(X4e, J4e, s), e = Jh(Q4e, s7, Bu(e)), s < 1 ? (i = (f) => {
    const p = f * s, y = p * e, v = p - n, w = lD(f, s), C = Math.exp(-y);
    return FO - v / w * C;
  }, o = (f) => {
    const y = f * s * e, v = y * n + n, w = Math.pow(s, 2) * Math.pow(f, 2) * e, C = Math.exp(-y), x = lD(Math.pow(f, 2), s);
    return (-i(f) + FO > 0 ? -1 : 1) * ((v - w) * C) / x;
  }) : (i = (f) => {
    const p = Math.exp(-f * e), y = (f - n) * e + 1;
    return -FO + p * y;
  }, o = (f) => {
    const p = Math.exp(-f * e), y = (n - f) * (e * e);
    return p * y;
  });
  const c = 5 / e, u = t8e(i, o, c);
  if (e = Uc(e), isNaN(u))
    return {
      stiffness: 100,
      damping: 10,
      duration: e
    };
  {
    const f = Math.pow(u, 2) * r;
    return {
      stiffness: f,
      damping: s * 2 * Math.sqrt(r * f),
      duration: e
    };
  }
}
const e8e = 12;
function t8e(e, t, n) {
  let r = n;
  for (let i = 1; i < e8e; i++)
    r = r - e(r) / t(r);
  return r;
}
function lD(e, t) {
  return e * Math.sqrt(1 - t * t);
}
const n8e = ["duration", "bounce"], r8e = ["stiffness", "damping", "mass"];
function l7(e, t) {
  return t.some((n) => e[n] !== void 0);
}
function i8e(e) {
  let t = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...e
  };
  if (!l7(e, r8e) && l7(e, n8e)) {
    const n = Z4e(e);
    t = {
      ...t,
      ...n,
      mass: 1
    }, t.isResolvedFromDuration = !0;
  }
  return t;
}
function BP({ keyframes: e, restDelta: t, restSpeed: n, ...r }) {
  const i = e[0], o = e[e.length - 1], s = { done: !1, value: i }, { stiffness: c, damping: u, mass: f, duration: p, velocity: y, isResolvedFromDuration: v } = i8e({
    ...r,
    velocity: -Bu(r.velocity || 0)
  }), w = y || 0, C = u / (2 * Math.sqrt(c * f)), x = o - i, A = Bu(Math.sqrt(c / f)), R = Math.abs(x) < 5;
  n || (n = R ? 0.01 : 2), t || (t = R ? 5e-3 : 0.5);
  let I;
  if (C < 1) {
    const D = lD(A, C);
    I = (M) => {
      const L = Math.exp(-C * A * M);
      return o - L * ((w + C * A * x) / D * Math.sin(D * M) + x * Math.cos(D * M));
    };
  } else if (C === 1)
    I = (D) => o - Math.exp(-A * D) * (x + (w + A * x) * D);
  else {
    const D = A * Math.sqrt(C * C - 1);
    I = (M) => {
      const L = Math.exp(-C * A * M), j = Math.min(D * M, 300);
      return o - L * ((w + C * A * x) * Math.sinh(j) + D * x * Math.cosh(j)) / D;
    };
  }
  return {
    calculatedDuration: v && p || null,
    next: (D) => {
      const M = I(D);
      if (v)
        s.done = D >= p;
      else {
        let L = 0;
        C < 1 && (L = D === 0 ? Uc(w) : HK(I, D, M));
        const j = Math.abs(L) <= n, F = Math.abs(o - M) <= t;
        s.done = j && F;
      }
      return s.value = s.done ? o : M, s;
    }
  };
}
function c7({ keyframes: e, velocity: t = 0, power: n = 0.8, timeConstant: r = 325, bounceDamping: i = 10, bounceStiffness: o = 500, modifyTarget: s, min: c, max: u, restDelta: f = 0.5, restSpeed: p }) {
  const y = e[0], v = {
    done: !1,
    value: y
  }, w = (O) => c !== void 0 && O < c || u !== void 0 && O > u, C = (O) => c === void 0 ? u : u === void 0 || Math.abs(c - O) < Math.abs(u - O) ? c : u;
  let x = n * t;
  const A = y + x, R = s === void 0 ? A : s(A);
  R !== A && (x = R - y);
  const I = (O) => -x * Math.exp(-O / r), D = (O) => R + I(O), M = (O) => {
    const z = I(O), H = D(O);
    v.done = Math.abs(z) <= f, v.value = v.done ? R : H;
  };
  let L, j;
  const F = (O) => {
    w(v.value) && (L = O, j = BP({
      keyframes: [v.value, C(v.value)],
      velocity: HK(D, O, v.value),
      // TODO: This should be passing * 1000
      damping: i,
      stiffness: o,
      restDelta: f,
      restSpeed: p
    }));
  };
  return F(0), {
    calculatedDuration: null,
    next: (O) => {
      let z = !1;
      return !j && L === void 0 && (z = !0, M(O), F(O)), L !== void 0 && O >= L ? j.next(O - L) : (!z && M(O), v);
    }
  };
}
const qK = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, o8e = 1e-7, a8e = 12;
function s8e(e, t, n, r, i) {
  let o, s, c = 0;
  do
    s = t + (n - t) / 2, o = qK(s, r, i) - e, o > 0 ? n = s : t = s;
  while (Math.abs(o) > o8e && ++c < a8e);
  return s;
}
function cx(e, t, n, r) {
  if (e === t && n === r)
    return oa;
  const i = (o) => s8e(o, 0, 1, e, n);
  return (o) => o === 0 || o === 1 ? o : qK(i(o), t, r);
}
const l8e = /* @__PURE__ */ cx(0.42, 0, 1, 1), c8e = /* @__PURE__ */ cx(0, 0, 0.58, 1), WK = /* @__PURE__ */ cx(0.42, 0, 0.58, 1), GK = (e) => Array.isArray(e) && typeof e[0] != "number", KK = (e) => (t) => t <= 0.5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, YK = (e) => (t) => 1 - e(1 - t), LP = (e) => 1 - Math.sin(Math.acos(e)), QK = YK(LP), u8e = KK(LP), XK = /* @__PURE__ */ cx(0.33, 1.53, 0.69, 0.99), jP = /* @__PURE__ */ YK(XK), d8e = /* @__PURE__ */ KK(jP), f8e = (e) => (e *= 2) < 1 ? 0.5 * jP(e) : 0.5 * (2 - Math.pow(2, -10 * (e - 1))), u7 = {
  linear: oa,
  easeIn: l8e,
  easeInOut: WK,
  easeOut: c8e,
  circIn: LP,
  circInOut: u8e,
  circOut: QK,
  backIn: jP,
  backInOut: d8e,
  backOut: XK,
  anticipate: f8e
}, d7 = (e) => {
  if (Array.isArray(e)) {
    dl(e.length === 4, "Cubic bezier arrays must contain four numerical values.");
    const [t, n, r, i] = e;
    return cx(t, n, r, i);
  } else if (typeof e == "string")
    return dl(u7[e] !== void 0, `Invalid easing type '${e}'`), u7[e];
  return e;
}, h8e = (e, t) => (n) => t(e(n)), Gd = (...e) => e.reduce(h8e), pb = (e, t, n) => {
  const r = t - e;
  return r === 0 ? 1 : (n - e) / r;
}, vi = (e, t, n) => e + (t - e) * n;
function UO(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function p8e({ hue: e, saturation: t, lightness: n, alpha: r }) {
  e /= 360, t /= 100, n /= 100;
  let i = 0, o = 0, s = 0;
  if (!t)
    i = o = s = n;
  else {
    const c = n < 0.5 ? n * (1 + t) : n + t - n * t, u = 2 * n - c;
    i = UO(u, c, e + 1 / 3), o = UO(u, c, e), s = UO(u, c, e - 1 / 3);
  }
  return {
    red: Math.round(i * 255),
    green: Math.round(o * 255),
    blue: Math.round(s * 255),
    alpha: r
  };
}
function Y4(e, t) {
  return (n) => n > 0 ? t : e;
}
const zO = (e, t, n) => {
  const r = e * e, i = n * (t * t - r) + r;
  return i < 0 ? 0 : Math.sqrt(i);
}, m8e = [aD, Om, Cg], y8e = (e) => m8e.find((t) => t.test(e));
function f7(e) {
  const t = y8e(e);
  if (Hb(!!t, `'${e}' is not an animatable color. Use the equivalent color code instead.`), !t)
    return !1;
  let n = t.parse(e);
  return t === Cg && (n = p8e(n)), n;
}
const h7 = (e, t) => {
  const n = f7(e), r = f7(t);
  if (!n || !r)
    return Y4(e, t);
  const i = { ...n };
  return (o) => (i.red = zO(n.red, r.red, o), i.green = zO(n.green, r.green, o), i.blue = zO(n.blue, r.blue, o), i.alpha = vi(n.alpha, r.alpha, o), Om.transform(i));
}, cD = /* @__PURE__ */ new Set(["none", "hidden"]);
function v8e(e, t) {
  return cD.has(e) ? (n) => n <= 0 ? e : t : (n) => n >= 1 ? t : e;
}
function g8e(e, t) {
  return (n) => vi(e, t, n);
}
function FP(e) {
  return typeof e == "number" ? g8e : typeof e == "string" ? OP(e) ? Y4 : Ta.test(e) ? h7 : C8e : Array.isArray(e) ? JK : typeof e == "object" ? Ta.test(e) ? h7 : b8e : Y4;
}
function JK(e, t) {
  const n = [...e], r = n.length, i = e.map((o, s) => FP(o)(o, t[s]));
  return (o) => {
    for (let s = 0; s < r; s++)
      n[s] = i[s](o);
    return n;
  };
}
function b8e(e, t) {
  const n = { ...e, ...t }, r = {};
  for (const i in n)
    e[i] !== void 0 && t[i] !== void 0 && (r[i] = FP(e[i])(e[i], t[i]));
  return (i) => {
    for (const o in r)
      n[o] = r[o](i);
    return n;
  };
}
function w8e(e, t) {
  var n;
  const r = [], i = { color: 0, var: 0, number: 0 };
  for (let o = 0; o < t.values.length; o++) {
    const s = t.types[o], c = e.indexes[s][i[s]], u = (n = e.values[c]) !== null && n !== void 0 ? n : 0;
    r[o] = u, i[s]++;
  }
  return r;
}
const C8e = (e, t) => {
  const n = Zh.createTransformer(t), r = vC(e), i = vC(t);
  return r.indexes.var.length === i.indexes.var.length && r.indexes.color.length === i.indexes.color.length && r.indexes.number.length >= i.indexes.number.length ? cD.has(e) && !i.values.length || cD.has(t) && !r.values.length ? v8e(e, t) : Gd(JK(w8e(r, i), i.values), n) : (Hb(!0, `Complex values '${e}' and '${t}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), Y4(e, t));
};
function ZK(e, t, n) {
  return typeof e == "number" && typeof t == "number" && typeof n == "number" ? vi(e, t, n) : FP(e)(e, t);
}
function x8e(e, t, n) {
  const r = [], i = n || ZK, o = e.length - 1;
  for (let s = 0; s < o; s++) {
    let c = i(e[s], e[s + 1]);
    if (t) {
      const u = Array.isArray(t) ? t[s] || oa : t;
      c = Gd(u, c);
    }
    r.push(c);
  }
  return r;
}
function eY(e, t, { clamp: n = !0, ease: r, mixer: i } = {}) {
  const o = e.length;
  if (dl(o === t.length, "Both input and output ranges must be the same length"), o === 1)
    return () => t[0];
  if (o === 2 && e[0] === e[1])
    return () => t[1];
  e[0] > e[o - 1] && (e = [...e].reverse(), t = [...t].reverse());
  const s = x8e(t, r, i), c = s.length, u = (f) => {
    let p = 0;
    if (c > 1)
      for (; p < e.length - 2 && !(f < e[p + 1]); p++)
        ;
    const y = pb(e[p], e[p + 1], f);
    return s[p](y);
  };
  return n ? (f) => u(Jh(e[0], e[o - 1], f)) : u;
}
function tY(e, t) {
  const n = e[e.length - 1];
  for (let r = 1; r <= t; r++) {
    const i = pb(0, t, r);
    e.push(vi(n, 1, i));
  }
}
function nY(e) {
  const t = [0];
  return tY(t, e.length - 1), t;
}
function E8e(e, t) {
  return e.map((n) => n * t);
}
function S8e(e, t) {
  return e.map(() => t || WK).splice(0, e.length - 1);
}
function Q4({ duration: e = 300, keyframes: t, times: n, ease: r = "easeInOut" }) {
  const i = GK(r) ? r.map(d7) : d7(r), o = {
    done: !1,
    value: t[0]
  }, s = E8e(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    n && n.length === t.length ? n : nY(t),
    e
  ), c = eY(s, t, {
    ease: Array.isArray(i) ? i : S8e(t, i)
  });
  return {
    calculatedDuration: e,
    next: (u) => (o.value = c(u), o.done = u >= e, o)
  };
}
const uD = 2e4;
function rY(e) {
  let t = 0;
  const n = 50;
  let r = e.next(t);
  for (; !r.done && t < uD; )
    t += n, r = e.next(t);
  return t >= uD ? 1 / 0 : t;
}
const k8e = (e) => {
  const t = ({ timestamp: n }) => e(n);
  return {
    start: () => Or.update(t, !0),
    stop: () => Vu(t),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => ia.isProcessing ? ia.timestamp : Wd.now()
  };
}, A8e = {
  decay: c7,
  inertia: c7,
  tween: Q4,
  keyframes: Q4,
  spring: BP
}, T8e = (e) => e / 100;
class UP extends VK {
  constructor(t) {
    super(t), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => {
      if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
        return;
      this.teardown();
      const { onStop: u } = this.options;
      u && u();
    };
    const { name: n, motionValue: r, element: i, keyframes: o } = this.options, s = (i == null ? void 0 : i.KeyframeResolver) || DP, c = (u, f) => this.onKeyframesResolved(u, f);
    this.resolver = new s(o, c, n, r, i), this.resolver.scheduleResolve();
  }
  initPlayback(t) {
    const { type: n = "keyframes", repeat: r = 0, repeatDelay: i = 0, repeatType: o, velocity: s = 0 } = this.options, c = A8e[n] || Q4;
    let u, f;
    c !== Q4 && typeof t[0] != "number" && (ct.env.NODE_ENV !== "production" && dl(t.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${t}`), u = Gd(T8e, ZK(t[0], t[1])), t = [0, 100]);
    const p = c({ ...this.options, keyframes: t });
    o === "mirror" && (f = c({
      ...this.options,
      keyframes: [...t].reverse(),
      velocity: -s
    })), p.calculatedDuration === null && (p.calculatedDuration = rY(p));
    const { calculatedDuration: y } = p, v = y + i, w = v * (r + 1) - i;
    return {
      generator: p,
      mirroredGenerator: f,
      mapPercentToKeyframes: u,
      calculatedDuration: y,
      resolvedDuration: v,
      totalDuration: w
    };
  }
  onPostResolved() {
    const { autoplay: t = !0 } = this.options;
    this.play(), this.pendingPlayState === "paused" || !t ? this.pause() : this.state = this.pendingPlayState;
  }
  tick(t, n = !1) {
    const { resolved: r } = this;
    if (!r) {
      const { keyframes: O } = this.options;
      return { done: !0, value: O[O.length - 1] };
    }
    const { finalKeyframe: i, generator: o, mirroredGenerator: s, mapPercentToKeyframes: c, keyframes: u, calculatedDuration: f, totalDuration: p, resolvedDuration: y } = r;
    if (this.startTime === null)
      return o.next(0);
    const { delay: v, repeat: w, repeatType: C, repeatDelay: x, onUpdate: A } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - p / this.speed, this.startTime)), n ? this.currentTime = t : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(t - this.startTime) * this.speed;
    const R = this.currentTime - v * (this.speed >= 0 ? 1 : -1), I = this.speed >= 0 ? R < 0 : R > p;
    this.currentTime = Math.max(R, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = p);
    let D = this.currentTime, M = o;
    if (w) {
      const O = Math.min(this.currentTime, p) / y;
      let z = Math.floor(O), H = O % 1;
      !H && O >= 1 && (H = 1), H === 1 && z--, z = Math.min(z, w + 1), !!(z % 2) && (C === "reverse" ? (H = 1 - H, x && (H -= x / y)) : C === "mirror" && (M = s)), D = Jh(0, 1, H) * y;
    }
    const L = I ? { done: !1, value: u[0] } : M.next(D);
    c && (L.value = c(L.value));
    let { done: j } = L;
    !I && f !== null && (j = this.speed >= 0 ? this.currentTime >= p : this.currentTime <= 0);
    const F = this.holdTime === null && (this.state === "finished" || this.state === "running" && j);
    return F && i !== void 0 && (L.value = CA(u, this.options, i)), A && A(L.value), F && this.finish(), L;
  }
  get duration() {
    const { resolved: t } = this;
    return t ? Bu(t.calculatedDuration) : 0;
  }
  get time() {
    return Bu(this.currentTime);
  }
  set time(t) {
    t = Uc(t), this.currentTime = t, this.holdTime !== null || this.speed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.speed);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(t) {
    const n = this.playbackSpeed !== t;
    this.playbackSpeed = t, n && (this.time = Bu(this.currentTime));
  }
  play() {
    if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) {
      this.pendingPlayState = "running";
      return;
    }
    if (this.isStopped)
      return;
    const { driver: t = k8e, onPlay: n, startTime: r } = this.options;
    this.driver || (this.driver = t((o) => this.tick(o))), n && n();
    const i = this.driver.now();
    this.holdTime !== null ? this.startTime = i - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = i) : this.startTime = r ?? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    var t;
    if (!this._resolved) {
      this.pendingPlayState = "paused";
      return;
    }
    this.state = "paused", this.holdTime = (t = this.currentTime) !== null && t !== void 0 ? t : 0;
  }
  complete() {
    this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null;
  }
  finish() {
    this.teardown(), this.state = "finished";
    const { onComplete: t } = this.options;
    t && t();
  }
  cancel() {
    this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise();
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel();
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(t) {
    return this.startTime = 0, this.tick(t, !0);
  }
}
const iY = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved
  // or until we implement support for linear() easing.
  // "background-color"
]), oY = (e) => Array.isArray(e) && typeof e[0] == "number";
function aY(e) {
  return !!(!e || typeof e == "string" && e in zP || oY(e) || Array.isArray(e) && e.every(aY));
}
const k1 = ([e, t, n, r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`, zP = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ k1([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ k1([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ k1([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ k1([0.33, 1.53, 0.69, 0.99])
};
function _8e(e) {
  return sY(e) || zP.easeOut;
}
function sY(e) {
  if (e)
    return oY(e) ? k1(e) : Array.isArray(e) ? e.map(_8e) : zP[e];
}
function R8e(e, t, n, { delay: r = 0, duration: i = 300, repeat: o = 0, repeatType: s = "loop", ease: c, times: u } = {}) {
  const f = { [t]: n };
  u && (f.offset = u);
  const p = sY(c);
  return Array.isArray(p) && (f.easing = p), e.animate(f, {
    delay: r,
    duration: i,
    easing: Array.isArray(p) ? "linear" : p,
    fill: "both",
    iterations: o + 1,
    direction: s === "reverse" ? "alternate" : "normal"
  });
}
const O8e = /* @__PURE__ */ zK(() => Object.hasOwnProperty.call(Element.prototype, "animate")), X4 = 10, I8e = 2e4;
function D8e(e) {
  return e.type === "spring" || !aY(e.ease);
}
function M8e(e, t) {
  const n = new UP({
    ...t,
    keyframes: e,
    repeat: 0,
    delay: 0,
    isGenerator: !0
  });
  let r = { done: !1, value: e[0] };
  const i = [];
  let o = 0;
  for (; !r.done && o < I8e; )
    r = n.sample(o), i.push(r.value), o += X4;
  return {
    times: void 0,
    keyframes: i,
    duration: o - X4,
    ease: "linear"
  };
}
class p7 extends VK {
  constructor(t) {
    super(t);
    const { name: n, motionValue: r, element: i, keyframes: o } = this.options;
    this.resolver = new UK(o, (s, c) => this.onKeyframesResolved(s, c), n, r, i), this.resolver.scheduleResolve();
  }
  initPlayback(t, n) {
    var r;
    let { duration: i = 300, times: o, ease: s, type: c, motionValue: u, name: f, startTime: p } = this.options;
    if (!(!((r = u.owner) === null || r === void 0) && r.current))
      return !1;
    if (D8e(this.options)) {
      const { onComplete: v, onUpdate: w, motionValue: C, element: x, ...A } = this.options, R = M8e(t, A);
      t = R.keyframes, t.length === 1 && (t[1] = t[0]), i = R.duration, o = R.times, s = R.ease, c = "keyframes";
    }
    const y = R8e(u.owner.current, f, t, { ...this.options, duration: i, times: o, ease: s });
    return y.startTime = p ?? this.calcStartTime(), this.pendingTimeline ? (y.timeline = this.pendingTimeline, this.pendingTimeline = void 0) : y.onfinish = () => {
      const { onComplete: v } = this.options;
      u.set(CA(t, this.options, n)), v && v(), this.cancel(), this.resolveFinishedPromise();
    }, {
      animation: y,
      duration: i,
      times: o,
      type: c,
      ease: s,
      keyframes: t
    };
  }
  get duration() {
    const { resolved: t } = this;
    if (!t)
      return 0;
    const { duration: n } = t;
    return Bu(n);
  }
  get time() {
    const { resolved: t } = this;
    if (!t)
      return 0;
    const { animation: n } = t;
    return Bu(n.currentTime || 0);
  }
  set time(t) {
    const { resolved: n } = this;
    if (!n)
      return;
    const { animation: r } = n;
    r.currentTime = Uc(t);
  }
  get speed() {
    const { resolved: t } = this;
    if (!t)
      return 1;
    const { animation: n } = t;
    return n.playbackRate;
  }
  set speed(t) {
    const { resolved: n } = this;
    if (!n)
      return;
    const { animation: r } = n;
    r.playbackRate = t;
  }
  get state() {
    const { resolved: t } = this;
    if (!t)
      return "idle";
    const { animation: n } = t;
    return n.playState;
  }
  get startTime() {
    const { resolved: t } = this;
    if (!t)
      return null;
    const { animation: n } = t;
    return n.startTime;
  }
  /**
   * Replace the default DocumentTimeline with another AnimationTimeline.
   * Currently used for scroll animations.
   */
  attachTimeline(t) {
    if (!this._resolved)
      this.pendingTimeline = t;
    else {
      const { resolved: n } = this;
      if (!n)
        return oa;
      const { animation: r } = n;
      r.timeline = t, r.onfinish = null;
    }
    return oa;
  }
  play() {
    if (this.isStopped)
      return;
    const { resolved: t } = this;
    if (!t)
      return;
    const { animation: n } = t;
    n.playState === "finished" && this.updateFinishedPromise(), n.play();
  }
  pause() {
    const { resolved: t } = this;
    if (!t)
      return;
    const { animation: n } = t;
    n.pause();
  }
  stop() {
    if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
      return;
    this.resolveFinishedPromise(), this.updateFinishedPromise();
    const { resolved: t } = this;
    if (!t)
      return;
    const { animation: n, keyframes: r, duration: i, type: o, ease: s, times: c } = t;
    if (n.playState === "idle" || n.playState === "finished")
      return;
    if (this.time) {
      const { motionValue: f, onUpdate: p, onComplete: y, element: v, ...w } = this.options, C = new UP({
        ...w,
        keyframes: r,
        duration: i,
        type: o,
        ease: s,
        times: c,
        isGenerator: !0
      }), x = Uc(this.time);
      f.setWithVelocity(C.sample(x - X4).value, C.sample(x).value, X4);
    }
    const { onStop: u } = this.options;
    u && u(), this.cancel();
  }
  complete() {
    const { resolved: t } = this;
    t && t.animation.finish();
  }
  cancel() {
    const { resolved: t } = this;
    t && t.animation.cancel();
  }
  static supports(t) {
    const { motionValue: n, name: r, repeatDelay: i, repeatType: o, damping: s, type: c } = t;
    return O8e() && r && iY.has(r) && n && n.owner && n.owner.current instanceof HTMLElement && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !n.owner.getProps().onUpdate && !i && o !== "mirror" && s !== 0 && c !== "inertia";
  }
}
function P8e(e, t) {
  let n;
  const r = () => {
    const { currentTime: i } = t, s = (i === null ? 0 : i.value) / 100;
    n !== s && e(s), n = s;
  };
  return Or.update(r, !0), () => Vu(r);
}
const N8e = zK(() => window.ScrollTimeline !== void 0);
class VP {
  constructor(t) {
    this.stop = () => this.runAll("stop"), this.animations = t.filter(Boolean);
  }
  then(t, n) {
    return Promise.all(this.animations).then(t).catch(n);
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(t) {
    return this.animations[0][t];
  }
  setAll(t, n) {
    for (let r = 0; r < this.animations.length; r++)
      this.animations[r][t] = n;
  }
  attachTimeline(t) {
    const n = this.animations.map((r) => {
      if (N8e() && r.attachTimeline)
        r.attachTimeline(t);
      else
        return r.pause(), P8e((i) => {
          r.time = r.duration * i;
        }, t);
    });
    return () => {
      n.forEach((r, i) => {
        r && r(), this.animations[i].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(t) {
    this.setAll("time", t);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(t) {
    this.setAll("speed", t);
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    let t = 0;
    for (let n = 0; n < this.animations.length; n++)
      t = Math.max(t, this.animations[n].duration);
    return t;
  }
  runAll(t) {
    this.animations.forEach((n) => n[t]());
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
const $P = (e, t, n, r = {}, i, o, s) => (c) => {
  const u = RP(r, e) || {}, f = u.delay || r.delay || 0;
  let { elapsed: p = 0 } = r;
  p = p - Uc(f);
  let y = {
    keyframes: Array.isArray(n) ? n : [null, n],
    ease: "easeOut",
    velocity: t.getVelocity(),
    ...u,
    delay: -p,
    onUpdate: (w) => {
      t.set(w), u.onUpdate && u.onUpdate(w);
    },
    onComplete: () => {
      c(), u.onComplete && u.onComplete(), s && s();
    },
    onStop: s,
    name: e,
    motionValue: t,
    element: o ? void 0 : i
  };
  c4e(u) || (y = {
    ...y,
    ...l4e(e, y)
  }), y.duration && (y.duration = Uc(y.duration)), y.repeatDelay && (y.repeatDelay = Uc(y.repeatDelay)), y.from !== void 0 && (y.keyframes[0] = y.from);
  let v = !1;
  if ((y.type === !1 || y.duration === 0 && !y.repeatDelay) && (y.duration = 0, y.delay === 0 && (v = !0)), v && !o && t.get() !== void 0) {
    const w = CA(y.keyframes, u);
    if (w !== void 0)
      return Or.update(() => {
        y.onUpdate(w), y.onComplete();
      }), new VP([]);
  }
  return !o && p7.supports(y) ? new p7(y) : new UP(y);
}, B8e = (e) => !!(e && typeof e == "object" && e.mix && e.toValue), L8e = (e) => rD(e) ? e[e.length - 1] || 0 : e;
function xA(e, t) {
  e.indexOf(t) === -1 && e.push(t);
}
function ux(e, t) {
  const n = e.indexOf(t);
  n > -1 && e.splice(n, 1);
}
class HP {
  constructor() {
    this.subscriptions = [];
  }
  add(t) {
    return xA(this.subscriptions, t), () => ux(this.subscriptions, t);
  }
  notify(t, n, r) {
    const i = this.subscriptions.length;
    if (i)
      if (i === 1)
        this.subscriptions[0](t, n, r);
      else
        for (let o = 0; o < i; o++) {
          const s = this.subscriptions[o];
          s && s(t, n, r);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const m7 = 30, j8e = (e) => !isNaN(parseFloat(e)), j1 = {
  current: void 0
};
class lY {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(t, n = {}) {
    this.version = "11.5.4", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (r, i = !0) => {
      const o = Wd.now();
      this.updatedAt !== o && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(r), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), i && this.events.renderRequest && this.events.renderRequest.notify(this.current);
    }, this.hasAnimated = !1, this.setCurrent(t), this.owner = n.owner;
  }
  setCurrent(t) {
    this.current = t, this.updatedAt = Wd.now(), this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = j8e(this.current));
  }
  setPrevFrameValue(t = this.current) {
    this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(t) {
    return ct.env.NODE_ENV !== "production" && bA(!1, 'value.onChange(callback) is deprecated. Switch to value.on("change", callback).'), this.on("change", t);
  }
  on(t, n) {
    this.events[t] || (this.events[t] = new HP());
    const r = this.events[t].add(n);
    return t === "change" ? () => {
      r(), Or.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : r;
  }
  clearListeners() {
    for (const t in this.events)
      this.events[t].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(t, n) {
    this.passiveEffect = t, this.stopPassiveEffect = n;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(t, n = !0) {
    !n || !this.passiveEffect ? this.updateAndNotify(t, n) : this.passiveEffect(t, this.updateAndNotify);
  }
  setWithVelocity(t, n, r) {
    this.set(n), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - r;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(t, n = !0) {
    this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return j1.current && j1.current.push(this), this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const t = Wd.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > m7)
      return 0;
    const n = Math.min(this.updatedAt - this.prevUpdatedAt, m7);
    return $K(parseFloat(this.current) - parseFloat(this.prevFrameValue), n);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(t) {
    return this.stop(), new Promise((n) => {
      this.hasAnimated = !0, this.animation = t(n), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function mb(e, t) {
  return new lY(e, t);
}
function F8e(e, t, n) {
  e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, mb(n));
}
function qP(e, t) {
  const n = wA(e, t);
  let { transitionEnd: r = {}, transition: i = {}, ...o } = n || {};
  o = { ...o, ...r };
  for (const s in o) {
    const c = L8e(o[s]);
    F8e(e, s, c);
  }
}
const EA = (e) => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), U8e = "framerAppearId", cY = "data-" + EA(U8e);
function uY(e) {
  return e.props[cY];
}
function dY(e) {
  if (cp.has(e))
    return "transform";
  if (iY.has(e))
    return EA(e);
}
class z8e extends lY {
  constructor() {
    super(...arguments), this.output = [], this.counts = /* @__PURE__ */ new Map();
  }
  add(t) {
    const n = dY(t);
    if (!n)
      return;
    const r = this.counts.get(n) || 0;
    this.counts.set(n, r + 1), r === 0 && (this.output.push(n), this.update());
    let i = !1;
    return () => {
      if (i)
        return;
      i = !0;
      const o = this.counts.get(n) - 1;
      this.counts.set(n, o), o === 0 && (ux(this.output, n), this.update());
    };
  }
  update() {
    this.set(this.output.length ? this.output.join(", ") : "auto");
  }
}
const $o = (e) => !!(e && e.getVelocity);
function V8e(e) {
  return !!($o(e) && e.add);
}
function dD(e, t) {
  var n;
  if (!e.applyWillChange)
    return;
  let r = e.getValue("willChange");
  if (!r && !(!((n = e.props.style) === null || n === void 0) && n.willChange) && (r = new z8e("auto"), e.addValue("willChange", r)), V8e(r))
    return r.add(t);
}
function $8e({ protectedKeys: e, needsAnimating: t }, n) {
  const r = e.hasOwnProperty(n) && t[n] !== !0;
  return t[n] = !1, r;
}
function WP(e, t, { delay: n = 0, transitionOverride: r, type: i } = {}) {
  var o;
  let { transition: s = e.getDefaultTransition(), transitionEnd: c, ...u } = t;
  r && (s = r);
  const f = [], p = i && e.animationState && e.animationState.getState()[i];
  for (const y in u) {
    const v = e.getValue(y, (o = e.latestValues[y]) !== null && o !== void 0 ? o : null), w = u[y];
    if (w === void 0 || p && $8e(p, y))
      continue;
    const C = {
      delay: n,
      ...RP(s || {}, y)
    };
    let x = !1;
    if (window.MotionHandoffAnimation) {
      const R = uY(e);
      if (R) {
        const I = window.MotionHandoffAnimation(R, y, Or);
        I !== null && (C.startTime = I, x = !0);
      }
    }
    v.start($P(y, v, w, e.shouldReduceMotion && cp.has(y) ? { type: !1 } : C, e, x, dD(e, y)));
    const A = v.animation;
    A && f.push(A);
  }
  return c && Promise.all(f).then(() => {
    Or.update(() => {
      c && qP(e, c);
    });
  }), f;
}
function fD(e, t, n = {}) {
  var r;
  const i = wA(e, t, n.type === "exit" ? (r = e.presenceContext) === null || r === void 0 ? void 0 : r.custom : void 0);
  let { transition: o = e.getDefaultTransition() || {} } = i || {};
  n.transitionOverride && (o = n.transitionOverride);
  const s = i ? () => Promise.all(WP(e, i, n)) : () => Promise.resolve(), c = e.variantChildren && e.variantChildren.size ? (f = 0) => {
    const { delayChildren: p = 0, staggerChildren: y, staggerDirection: v } = o;
    return H8e(e, t, p + f, y, v, n);
  } : () => Promise.resolve(), { when: u } = o;
  if (u) {
    const [f, p] = u === "beforeChildren" ? [s, c] : [c, s];
    return f().then(() => p());
  } else
    return Promise.all([s(), c(n.delay)]);
}
function H8e(e, t, n = 0, r = 0, i = 1, o) {
  const s = [], c = (e.variantChildren.size - 1) * r, u = i === 1 ? (f = 0) => f * r : (f = 0) => c - f * r;
  return Array.from(e.variantChildren).sort(q8e).forEach((f, p) => {
    f.notify("AnimationStart", t), s.push(fD(f, t, {
      ...o,
      delay: n + u(p)
    }).then(() => f.notify("AnimationComplete", t)));
  }), Promise.all(s);
}
function q8e(e, t) {
  return e.sortNodePosition(t);
}
function fY(e, t, n = {}) {
  e.notify("AnimationStart", t);
  let r;
  if (Array.isArray(t)) {
    const i = t.map((o) => fD(e, o, n));
    r = Promise.all(i);
  } else if (typeof t == "string")
    r = fD(e, t, n);
  else {
    const i = typeof t == "function" ? wA(e, t, n.custom) : t;
    r = Promise.all(WP(e, i, n));
  }
  return r.then(() => {
    e.notify("AnimationComplete", t);
  });
}
const W8e = [...TP].reverse(), G8e = TP.length;
function K8e(e) {
  return (t) => Promise.all(t.map(({ animation: n, options: r }) => fY(e, n, r)));
}
function Y8e(e) {
  let t = K8e(e), n = y7(), r = !0;
  const i = (u) => (f, p) => {
    var y;
    const v = wA(e, p, u === "exit" ? (y = e.presenceContext) === null || y === void 0 ? void 0 : y.custom : void 0);
    if (v) {
      const { transition: w, transitionEnd: C, ...x } = v;
      f = { ...f, ...x, ...C };
    }
    return f;
  };
  function o(u) {
    t = u(e);
  }
  function s(u) {
    const f = e.getProps(), p = e.getVariantContext(!0) || {}, y = [], v = /* @__PURE__ */ new Set();
    let w = {}, C = 1 / 0;
    for (let A = 0; A < G8e; A++) {
      const R = W8e[A], I = n[R], D = f[R] !== void 0 ? f[R] : p[R], M = yC(D), L = R === u ? I.isActive : null;
      L === !1 && (C = A);
      let j = D === p[R] && D !== f[R] && M;
      if (j && r && e.manuallyAnimateOnMount && (j = !1), I.protectedKeys = { ...w }, // If it isn't active and hasn't *just* been set as inactive
      !I.isActive && L === null || // If we didn't and don't have any defined prop for this animation type
      !D && !I.prevProp || // Or if the prop doesn't define an animation
      mC(D) || typeof D == "boolean")
        continue;
      let O = Q8e(I.prevProp, D) || // If we're making this variant active, we want to always make it active
      R === u && I.isActive && !j && M || // If we removed a higher-priority variant (i is in reverse order)
      A > C && M, z = !1;
      const H = Array.isArray(D) ? D : [D];
      let Q = H.reduce(i(R), {});
      L === !1 && (Q = {});
      const { prevResolvedValues: Y = {} } = I, ee = {
        ...Y,
        ...Q
      }, ie = (X) => {
        O = !0, v.has(X) && (z = !0, v.delete(X)), I.needsAnimating[X] = !0;
        const Z = e.getValue(X);
        Z && (Z.liveStyle = !1);
      };
      for (const X in ee) {
        const Z = Q[X], J = Y[X];
        if (w.hasOwnProperty(X))
          continue;
        let K = !1;
        rD(Z) && rD(J) ? K = !EK(Z, J) : K = Z !== J, K ? Z != null ? ie(X) : v.add(X) : Z !== void 0 && v.has(X) ? ie(X) : I.protectedKeys[X] = !0;
      }
      I.prevProp = D, I.prevResolvedValues = Q, I.isActive && (w = { ...w, ...Q }), r && e.blockInitialAnimation && (O = !1), O && (!j || z) && y.push(...H.map((X) => ({
        animation: X,
        options: { type: R }
      })));
    }
    if (v.size) {
      const A = {};
      v.forEach((R) => {
        const I = e.getBaseTarget(R), D = e.getValue(R);
        D && (D.liveStyle = !0), A[R] = I ?? null;
      }), y.push({ animation: A });
    }
    let x = !!y.length;
    return r && (f.initial === !1 || f.initial === f.animate) && !e.manuallyAnimateOnMount && (x = !1), r = !1, x ? t(y) : Promise.resolve();
  }
  function c(u, f) {
    var p;
    if (n[u].isActive === f)
      return Promise.resolve();
    (p = e.variantChildren) === null || p === void 0 || p.forEach((v) => {
      var w;
      return (w = v.animationState) === null || w === void 0 ? void 0 : w.setActive(u, f);
    }), n[u].isActive = f;
    const y = s(u);
    for (const v in n)
      n[v].protectedKeys = {};
    return y;
  }
  return {
    animateChanges: s,
    setActive: c,
    setAnimateFunction: o,
    getState: () => n,
    reset: () => {
      n = y7(), r = !0;
    }
  };
}
function Q8e(e, t) {
  return typeof t == "string" ? t !== e : Array.isArray(t) ? !EK(t, e) : !1;
}
function gm(e = !1) {
  return {
    isActive: e,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function y7() {
  return {
    animate: gm(!0),
    whileInView: gm(),
    whileHover: gm(),
    whileTap: gm(),
    whileDrag: gm(),
    whileFocus: gm(),
    exit: gm()
  };
}
class up {
  constructor(t) {
    this.isMounted = !1, this.node = t;
  }
  update() {
  }
}
class X8e extends up {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(t) {
    super(t), t.animationState || (t.animationState = Y8e(t));
  }
  updateAnimationControlsSubscription() {
    const { animate: t } = this.node.getProps();
    mC(t) && (this.unmountControls = t.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: t } = this.node.getProps(), { animate: n } = this.node.prevProps || {};
    t !== n && this.updateAnimationControlsSubscription();
  }
  unmount() {
    var t;
    this.node.animationState.reset(), (t = this.unmountControls) === null || t === void 0 || t.call(this);
  }
}
let J8e = 0;
class Z8e extends up {
  constructor() {
    super(...arguments), this.id = J8e++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: t, onExitComplete: n } = this.node.presenceContext, { isPresent: r } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || t === r)
      return;
    const i = this.node.animationState.setActive("exit", !t);
    n && !t && i.then(() => n(this.id));
  }
  mount() {
    const { register: t } = this.node.presenceContext || {};
    t && (this.unmount = t(this.id));
  }
  unmount() {
  }
}
const eAe = {
  animation: {
    Feature: X8e
  },
  exit: {
    Feature: Z8e
  }
}, hY = (e) => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1;
function SA(e, t = "page") {
  return {
    point: {
      x: e[`${t}X`],
      y: e[`${t}Y`]
    }
  };
}
const tAe = (e) => (t) => hY(t) && e(t, SA(t));
function Vd(e, t, n, r = { passive: !0 }) {
  return e.addEventListener(t, n, r), () => e.removeEventListener(t, n);
}
function Kd(e, t, n, r) {
  return Vd(e, t, tAe(n), r);
}
const v7 = (e, t) => Math.abs(e - t);
function nAe(e, t) {
  const n = v7(e.x, t.x), r = v7(e.y, t.y);
  return Math.sqrt(n ** 2 + r ** 2);
}
class pY {
  constructor(t, n, { transformPagePoint: r, contextWindow: i, dragSnapToOrigin: o = !1 } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const y = $O(this.lastMoveEventInfo, this.history), v = this.startEvent !== null, w = nAe(y.offset, { x: 0, y: 0 }) >= 3;
      if (!v && !w)
        return;
      const { point: C } = y, { timestamp: x } = ia;
      this.history.push({ ...C, timestamp: x });
      const { onStart: A, onMove: R } = this.handlers;
      v || (A && A(this.lastMoveEvent, y), this.startEvent = this.lastMoveEvent), R && R(this.lastMoveEvent, y);
    }, this.handlePointerMove = (y, v) => {
      this.lastMoveEvent = y, this.lastMoveEventInfo = VO(v, this.transformPagePoint), Or.update(this.updatePoint, !0);
    }, this.handlePointerUp = (y, v) => {
      this.end();
      const { onEnd: w, onSessionEnd: C, resumeAnimation: x } = this.handlers;
      if (this.dragSnapToOrigin && x && x(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const A = $O(y.type === "pointercancel" ? this.lastMoveEventInfo : VO(v, this.transformPagePoint), this.history);
      this.startEvent && w && w(y, A), C && C(y, A);
    }, !hY(t))
      return;
    this.dragSnapToOrigin = o, this.handlers = n, this.transformPagePoint = r, this.contextWindow = i || window;
    const s = SA(t), c = VO(s, this.transformPagePoint), { point: u } = c, { timestamp: f } = ia;
    this.history = [{ ...u, timestamp: f }];
    const { onSessionStart: p } = n;
    p && p(t, $O(c, this.history)), this.removeListeners = Gd(Kd(this.contextWindow, "pointermove", this.handlePointerMove), Kd(this.contextWindow, "pointerup", this.handlePointerUp), Kd(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(t) {
    this.handlers = t;
  }
  end() {
    this.removeListeners && this.removeListeners(), Vu(this.updatePoint);
  }
}
function VO(e, t) {
  return t ? { point: t(e.point) } : e;
}
function g7(e, t) {
  return { x: e.x - t.x, y: e.y - t.y };
}
function $O({ point: e }, t) {
  return {
    point: e,
    delta: g7(e, mY(t)),
    offset: g7(e, rAe(t)),
    velocity: iAe(t, 0.1)
  };
}
function rAe(e) {
  return e[0];
}
function mY(e) {
  return e[e.length - 1];
}
function iAe(e, t) {
  if (e.length < 2)
    return { x: 0, y: 0 };
  let n = e.length - 1, r = null;
  const i = mY(e);
  for (; n >= 0 && (r = e[n], !(i.timestamp - r.timestamp > Uc(t))); )
    n--;
  if (!r)
    return { x: 0, y: 0 };
  const o = Bu(i.timestamp - r.timestamp);
  if (o === 0)
    return { x: 0, y: 0 };
  const s = {
    x: (i.x - r.x) / o,
    y: (i.y - r.y) / o
  };
  return s.x === 1 / 0 && (s.x = 0), s.y === 1 / 0 && (s.y = 0), s;
}
function yY(e) {
  let t = null;
  return () => {
    const n = () => {
      t = null;
    };
    return t === null ? (t = e, n) : !1;
  };
}
const b7 = yY("dragHorizontal"), w7 = yY("dragVertical");
function vY(e) {
  let t = !1;
  if (e === "y")
    t = w7();
  else if (e === "x")
    t = b7();
  else {
    const n = b7(), r = w7();
    n && r ? t = () => {
      n(), r();
    } : (n && n(), r && r());
  }
  return t;
}
function gY() {
  const e = vY(!0);
  return e ? (e(), !1) : !0;
}
function xg(e) {
  return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current");
}
const bY = 1e-4, oAe = 1 - bY, aAe = 1 + bY, wY = 0.01, sAe = 0 - wY, lAe = 0 + wY;
function fl(e) {
  return e.max - e.min;
}
function cAe(e, t, n) {
  return Math.abs(e - t) <= n;
}
function C7(e, t, n, r = 0.5) {
  e.origin = r, e.originPoint = vi(t.min, t.max, e.origin), e.scale = fl(n) / fl(t), e.translate = vi(n.min, n.max, e.origin) - e.originPoint, (e.scale >= oAe && e.scale <= aAe || isNaN(e.scale)) && (e.scale = 1), (e.translate >= sAe && e.translate <= lAe || isNaN(e.translate)) && (e.translate = 0);
}
function F1(e, t, n, r) {
  C7(e.x, t.x, n.x, r ? r.originX : void 0), C7(e.y, t.y, n.y, r ? r.originY : void 0);
}
function x7(e, t, n) {
  e.min = n.min + t.min, e.max = e.min + fl(t);
}
function uAe(e, t, n) {
  x7(e.x, t.x, n.x), x7(e.y, t.y, n.y);
}
function E7(e, t, n) {
  e.min = t.min - n.min, e.max = e.min + fl(t);
}
function U1(e, t, n) {
  E7(e.x, t.x, n.x), E7(e.y, t.y, n.y);
}
function dAe(e, { min: t, max: n }, r) {
  return t !== void 0 && e < t ? e = r ? vi(t, e, r.min) : Math.max(e, t) : n !== void 0 && e > n && (e = r ? vi(n, e, r.max) : Math.min(e, n)), e;
}
function S7(e, t, n) {
  return {
    min: t !== void 0 ? e.min + t : void 0,
    max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0
  };
}
function fAe(e, { top: t, left: n, bottom: r, right: i }) {
  return {
    x: S7(e.x, n, i),
    y: S7(e.y, t, r)
  };
}
function k7(e, t) {
  let n = t.min - e.min, r = t.max - e.max;
  return t.max - t.min < e.max - e.min && ([n, r] = [r, n]), { min: n, max: r };
}
function hAe(e, t) {
  return {
    x: k7(e.x, t.x),
    y: k7(e.y, t.y)
  };
}
function pAe(e, t) {
  let n = 0.5;
  const r = fl(e), i = fl(t);
  return i > r ? n = pb(t.min, t.max - r, e.min) : r > i && (n = pb(e.min, e.max - i, t.min)), Jh(0, 1, n);
}
function mAe(e, t) {
  const n = {};
  return t.min !== void 0 && (n.min = t.min - e.min), t.max !== void 0 && (n.max = t.max - e.min), n;
}
const hD = 0.35;
function yAe(e = hD) {
  return e === !1 ? e = 0 : e === !0 && (e = hD), {
    x: A7(e, "left", "right"),
    y: A7(e, "top", "bottom")
  };
}
function A7(e, t, n) {
  return {
    min: T7(e, t),
    max: T7(e, n)
  };
}
function T7(e, t) {
  return typeof e == "number" ? e : e[t] || 0;
}
const _7 = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), Eg = () => ({
  x: _7(),
  y: _7()
}), R7 = () => ({ min: 0, max: 0 }), Wi = () => ({
  x: R7(),
  y: R7()
});
function jl(e) {
  return [e("x"), e("y")];
}
function CY({ top: e, left: t, right: n, bottom: r }) {
  return {
    x: { min: t, max: n },
    y: { min: e, max: r }
  };
}
function vAe({ x: e, y: t }) {
  return { top: t.min, right: e.max, bottom: t.max, left: e.min };
}
function gAe(e, t) {
  if (!t)
    return e;
  const n = t({ x: e.left, y: e.top }), r = t({ x: e.right, y: e.bottom });
  return {
    top: n.y,
    left: n.x,
    bottom: r.y,
    right: r.x
  };
}
function HO(e) {
  return e === void 0 || e === 1;
}
function pD({ scale: e, scaleX: t, scaleY: n }) {
  return !HO(e) || !HO(t) || !HO(n);
}
function bm(e) {
  return pD(e) || xY(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY;
}
function xY(e) {
  return O7(e.x) || O7(e.y);
}
function O7(e) {
  return e && e !== "0%";
}
function J4(e, t, n) {
  const r = e - n, i = t * r;
  return n + i;
}
function I7(e, t, n, r, i) {
  return i !== void 0 && (e = J4(e, i, r)), J4(e, n, r) + t;
}
function mD(e, t = 0, n = 1, r, i) {
  e.min = I7(e.min, t, n, r, i), e.max = I7(e.max, t, n, r, i);
}
function EY(e, { x: t, y: n }) {
  mD(e.x, t.translate, t.scale, t.originPoint), mD(e.y, n.translate, n.scale, n.originPoint);
}
const D7 = 0.999999999999, M7 = 1.0000000000001;
function bAe(e, t, n, r = !1) {
  const i = n.length;
  if (!i)
    return;
  t.x = t.y = 1;
  let o, s;
  for (let c = 0; c < i; c++) {
    o = n[c], s = o.projectionDelta;
    const { visualElement: u } = o.options;
    u && u.props.style && u.props.style.display === "contents" || (r && o.options.layoutScroll && o.scroll && o !== o.root && kg(e, {
      x: -o.scroll.offset.x,
      y: -o.scroll.offset.y
    }), s && (t.x *= s.x.scale, t.y *= s.y.scale, EY(e, s)), r && bm(o.latestValues) && kg(e, o.latestValues));
  }
  t.x < M7 && t.x > D7 && (t.x = 1), t.y < M7 && t.y > D7 && (t.y = 1);
}
function Sg(e, t) {
  e.min = e.min + t, e.max = e.max + t;
}
function P7(e, t, n, r, i = 0.5) {
  const o = vi(e.min, e.max, i);
  mD(e, t, n, o, r);
}
function kg(e, t) {
  P7(e.x, t.x, t.scaleX, t.scale, t.originX), P7(e.y, t.y, t.scaleY, t.scale, t.originY);
}
function SY(e, t) {
  return CY(gAe(e.getBoundingClientRect(), t));
}
function wAe(e, t, n) {
  const r = SY(e, n), { scroll: i } = t;
  return i && (Sg(r.x, i.offset.x), Sg(r.y, i.offset.y)), r;
}
const kY = ({ current: e }) => e ? e.ownerDocument.defaultView : null, CAe = /* @__PURE__ */ new WeakMap();
class xAe {
  constructor(t) {
    this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = Wi(), this.visualElement = t;
  }
  start(t, { snapToCursor: n = !1 } = {}) {
    const { presenceContext: r } = this.visualElement;
    if (r && r.isPresent === !1)
      return;
    const i = (p) => {
      const { dragSnapToOrigin: y } = this.getProps();
      y ? this.pauseAnimation() : this.stopAnimation(), n && this.snapToCursor(SA(p, "page").point);
    }, o = (p, y) => {
      var v;
      const { drag: w, dragPropagation: C, onDragStart: x } = this.getProps();
      if (w && !C && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = vY(w), !this.openGlobalLock))
        return;
      this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), jl((R) => {
        let I = this.getAxisMotionValue(R).get() || 0;
        if (Lu.test(I)) {
          const { projection: D } = this.visualElement;
          if (D && D.layout) {
            const M = D.layout.layoutBox[R];
            M && (I = fl(M) * (parseFloat(I) / 100));
          }
        }
        this.originPoint[R] = I;
      }), x && Or.postRender(() => x(p, y)), (v = this.removeWillChange) === null || v === void 0 || v.call(this), this.removeWillChange = dD(this.visualElement, "transform");
      const { animationState: A } = this.visualElement;
      A && A.setActive("whileDrag", !0);
    }, s = (p, y) => {
      const { dragPropagation: v, dragDirectionLock: w, onDirectionLock: C, onDrag: x } = this.getProps();
      if (!v && !this.openGlobalLock)
        return;
      const { offset: A } = y;
      if (w && this.currentDirection === null) {
        this.currentDirection = EAe(A), this.currentDirection !== null && C && C(this.currentDirection);
        return;
      }
      this.updateAxis("x", y.point, A), this.updateAxis("y", y.point, A), this.visualElement.render(), x && x(p, y);
    }, c = (p, y) => this.stop(p, y), u = () => jl((p) => {
      var y;
      return this.getAnimationState(p) === "paused" && ((y = this.getAxisMotionValue(p).animation) === null || y === void 0 ? void 0 : y.play());
    }), { dragSnapToOrigin: f } = this.getProps();
    this.panSession = new pY(t, {
      onSessionStart: i,
      onStart: o,
      onMove: s,
      onSessionEnd: c,
      resumeAnimation: u
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin: f,
      contextWindow: kY(this.visualElement)
    });
  }
  stop(t, n) {
    var r;
    (r = this.removeWillChange) === null || r === void 0 || r.call(this);
    const i = this.isDragging;
    if (this.cancel(), !i)
      return;
    const { velocity: o } = n;
    this.startAnimation(o);
    const { onDragEnd: s } = this.getProps();
    s && Or.postRender(() => s(t, n));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: t, animationState: n } = this.visualElement;
    t && (t.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation: r } = this.getProps();
    !r && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), n && n.setActive("whileDrag", !1);
  }
  updateAxis(t, n, r) {
    const { drag: i } = this.getProps();
    if (!r || !Uk(t, i, this.currentDirection))
      return;
    const o = this.getAxisMotionValue(t);
    let s = this.originPoint[t] + r[t];
    this.constraints && this.constraints[t] && (s = dAe(s, this.constraints[t], this.elastic[t])), o.set(s);
  }
  resolveConstraints() {
    var t;
    const { dragConstraints: n, dragElastic: r } = this.getProps(), i = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (t = this.visualElement.projection) === null || t === void 0 ? void 0 : t.layout, o = this.constraints;
    n && xg(n) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : n && i ? this.constraints = fAe(i.layoutBox, n) : this.constraints = !1, this.elastic = yAe(r), o !== this.constraints && i && this.constraints && !this.hasMutatedConstraints && jl((s) => {
      this.constraints !== !1 && this.getAxisMotionValue(s) && (this.constraints[s] = mAe(i.layoutBox[s], this.constraints[s]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: t, onMeasureDragConstraints: n } = this.getProps();
    if (!t || !xg(t))
      return !1;
    const r = t.current;
    dl(r !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection: i } = this.visualElement;
    if (!i || !i.layout)
      return !1;
    const o = wAe(r, i.root, this.visualElement.getTransformPagePoint());
    let s = hAe(i.layout.layoutBox, o);
    if (n) {
      const c = n(vAe(s));
      this.hasMutatedConstraints = !!c, c && (s = CY(c));
    }
    return s;
  }
  startAnimation(t) {
    const { drag: n, dragMomentum: r, dragElastic: i, dragTransition: o, dragSnapToOrigin: s, onDragTransitionEnd: c } = this.getProps(), u = this.constraints || {}, f = jl((p) => {
      if (!Uk(p, n, this.currentDirection))
        return;
      let y = u && u[p] || {};
      s && (y = { min: 0, max: 0 });
      const v = i ? 200 : 1e6, w = i ? 40 : 1e7, C = {
        type: "inertia",
        velocity: r ? t[p] : 0,
        bounceStiffness: v,
        bounceDamping: w,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...o,
        ...y
      };
      return this.startAxisValueAnimation(p, C);
    });
    return Promise.all(f).then(c);
  }
  startAxisValueAnimation(t, n) {
    const r = this.getAxisMotionValue(t);
    return r.start($P(t, r, 0, n, this.visualElement, !1, dD(this.visualElement, t)));
  }
  stopAnimation() {
    jl((t) => this.getAxisMotionValue(t).stop());
  }
  pauseAnimation() {
    jl((t) => {
      var n;
      return (n = this.getAxisMotionValue(t).animation) === null || n === void 0 ? void 0 : n.pause();
    });
  }
  getAnimationState(t) {
    var n;
    return (n = this.getAxisMotionValue(t).animation) === null || n === void 0 ? void 0 : n.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(t) {
    const n = `_drag${t.toUpperCase()}`, r = this.visualElement.getProps(), i = r[n];
    return i || this.visualElement.getValue(t, (r.initial ? r.initial[t] : void 0) || 0);
  }
  snapToCursor(t) {
    jl((n) => {
      const { drag: r } = this.getProps();
      if (!Uk(n, r, this.currentDirection))
        return;
      const { projection: i } = this.visualElement, o = this.getAxisMotionValue(n);
      if (i && i.layout) {
        const { min: s, max: c } = i.layout.layoutBox[n];
        o.set(t[n] - vi(s, c, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: t, dragConstraints: n } = this.getProps(), { projection: r } = this.visualElement;
    if (!xg(n) || !r || !this.constraints)
      return;
    this.stopAnimation();
    const i = { x: 0, y: 0 };
    jl((s) => {
      const c = this.getAxisMotionValue(s);
      if (c && this.constraints !== !1) {
        const u = c.get();
        i[s] = pAe({ min: u, max: u }, this.constraints[s]);
      }
    });
    const { transformTemplate: o } = this.visualElement.getProps();
    this.visualElement.current.style.transform = o ? o({}, "") : "none", r.root && r.root.updateScroll(), r.updateLayout(), this.resolveConstraints(), jl((s) => {
      if (!Uk(s, t, null))
        return;
      const c = this.getAxisMotionValue(s), { min: u, max: f } = this.constraints[s];
      c.set(vi(u, f, i[s]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    CAe.set(this.visualElement, this);
    const t = this.visualElement.current, n = Kd(t, "pointerdown", (u) => {
      const { drag: f, dragListener: p = !0 } = this.getProps();
      f && p && this.start(u);
    }), r = () => {
      const { dragConstraints: u } = this.getProps();
      xg(u) && u.current && (this.constraints = this.resolveRefConstraints());
    }, { projection: i } = this.visualElement, o = i.addEventListener("measure", r);
    i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), Or.read(r);
    const s = Vd(window, "resize", () => this.scalePositionWithinConstraints()), c = i.addEventListener("didUpdate", ({ delta: u, hasLayoutChanged: f }) => {
      this.isDragging && f && (jl((p) => {
        const y = this.getAxisMotionValue(p);
        y && (this.originPoint[p] += u[p].translate, y.set(y.get() + u[p].translate));
      }), this.visualElement.render());
    });
    return () => {
      s(), n(), o(), c && c();
    };
  }
  getProps() {
    const t = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: r = !1, dragPropagation: i = !1, dragConstraints: o = !1, dragElastic: s = hD, dragMomentum: c = !0 } = t;
    return {
      ...t,
      drag: n,
      dragDirectionLock: r,
      dragPropagation: i,
      dragConstraints: o,
      dragElastic: s,
      dragMomentum: c
    };
  }
}
function Uk(e, t, n) {
  return (t === !0 || t === e) && (n === null || n === e);
}
function EAe(e, t = 10) {
  let n = null;
  return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"), n;
}
class SAe extends up {
  constructor(t) {
    super(t), this.removeGroupControls = oa, this.removeListeners = oa, this.controls = new xAe(t);
  }
  mount() {
    const { dragControls: t } = this.node.getProps();
    t && (this.removeGroupControls = t.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || oa;
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const N7 = (e) => (t, n) => {
  e && Or.postRender(() => e(t, n));
};
class kAe extends up {
  constructor() {
    super(...arguments), this.removePointerDownListener = oa;
  }
  onPointerDown(t) {
    this.session = new pY(t, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: kY(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart: t, onPanStart: n, onPan: r, onPanEnd: i } = this.node.getProps();
    return {
      onSessionStart: N7(t),
      onStart: N7(n),
      onMove: r,
      onEnd: (o, s) => {
        delete this.session, i && Or.postRender(() => i(o, s));
      }
    };
  }
  mount() {
    this.removePointerDownListener = Kd(this.node.current, "pointerdown", (t) => this.onPointerDown(t));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
const dx = k.createContext(null);
function AY() {
  const e = k.useContext(dx);
  if (e === null)
    return [!0, null];
  const { isPresent: t, onExitComplete: n, register: r } = e, i = k.useId();
  k.useEffect(() => r(i), []);
  const o = k.useCallback(() => n && n(i), [i, n]);
  return !t && n ? [!1, o] : [!0];
}
function AAe() {
  return TAe(k.useContext(dx));
}
function TAe(e) {
  return e === null ? !0 : e.isPresent;
}
const gC = k.createContext({}), TY = k.createContext({}), p4 = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
};
function B7(e, t) {
  return t.max === t.min ? 0 : e / (t.max - t.min) * 100;
}
const d1 = {
  correct: (e, t) => {
    if (!t.target)
      return e;
    if (typeof e == "string")
      if (Tn.test(e))
        e = parseFloat(e);
      else
        return e;
    const n = B7(e, t.target.x), r = B7(e, t.target.y);
    return `${n}% ${r}%`;
  }
}, _Ae = {
  correct: (e, { treeScale: t, projectionDelta: n }) => {
    const r = e, i = Zh.parse(e);
    if (i.length > 5)
      return r;
    const o = Zh.createTransformer(e), s = typeof i[0] != "number" ? 1 : 0, c = n.x.scale * t.x, u = n.y.scale * t.y;
    i[0 + s] /= c, i[1 + s] /= u;
    const f = vi(c, u, 0.5);
    return typeof i[2 + s] == "number" && (i[2 + s] /= f), typeof i[3 + s] == "number" && (i[3 + s] /= f), o(i);
  }
}, Z4 = {};
function RAe(e) {
  Object.assign(Z4, e);
}
const { schedule: GP, cancel: Pje } = SK(queueMicrotask, !1);
class OAe extends k.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: r, layoutId: i } = this.props, { projection: o } = t;
    RAe(IAe), o && (n.group && n.group.add(o), r && r.register && i && r.register(o), o.root.didUpdate(), o.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), o.setOptions({
      ...o.options,
      onExitComplete: () => this.safeToRemove()
    })), p4.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(t) {
    const { layoutDependency: n, visualElement: r, drag: i, isPresent: o } = this.props, s = r.projection;
    return s && (s.isPresent = o, i || t.layoutDependency !== n || n === void 0 ? s.willUpdate() : this.safeToRemove(), t.isPresent !== o && (o ? s.promote() : s.relegate() || Or.postRender(() => {
      const c = s.getStack();
      (!c || !c.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: t } = this.props.visualElement;
    t && (t.root.didUpdate(), GP.postRender(() => {
      !t.currentAnimation && t.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: r } = this.props, { projection: i } = t;
    i && (i.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(i), r && r.deregister && r.deregister(i));
  }
  safeToRemove() {
    const { safeToRemove: t } = this.props;
    t && t();
  }
  render() {
    return null;
  }
}
function _Y(e) {
  const [t, n] = AY(), r = k.useContext(gC);
  return S.jsx(OAe, { ...e, layoutGroup: r, switchLayoutGroup: k.useContext(TY), isPresent: t, safeToRemove: n });
}
const IAe = {
  borderRadius: {
    ...d1,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: d1,
  borderTopRightRadius: d1,
  borderBottomLeftRadius: d1,
  borderBottomRightRadius: d1,
  boxShadow: _Ae
}, RY = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], DAe = RY.length, L7 = (e) => typeof e == "string" ? parseFloat(e) : e, j7 = (e) => typeof e == "number" || Tn.test(e);
function MAe(e, t, n, r, i, o) {
  i ? (e.opacity = vi(
    0,
    // TODO Reinstate this if only child
    n.opacity !== void 0 ? n.opacity : 1,
    PAe(r)
  ), e.opacityExit = vi(t.opacity !== void 0 ? t.opacity : 1, 0, NAe(r))) : o && (e.opacity = vi(t.opacity !== void 0 ? t.opacity : 1, n.opacity !== void 0 ? n.opacity : 1, r));
  for (let s = 0; s < DAe; s++) {
    const c = `border${RY[s]}Radius`;
    let u = F7(t, c), f = F7(n, c);
    if (u === void 0 && f === void 0)
      continue;
    u || (u = 0), f || (f = 0), u === 0 || f === 0 || j7(u) === j7(f) ? (e[c] = Math.max(vi(L7(u), L7(f), r), 0), (Lu.test(f) || Lu.test(u)) && (e[c] += "%")) : e[c] = f;
  }
  (t.rotate || n.rotate) && (e.rotate = vi(t.rotate || 0, n.rotate || 0, r));
}
function F7(e, t) {
  return e[t] !== void 0 ? e[t] : e.borderRadius;
}
const PAe = /* @__PURE__ */ OY(0, 0.5, QK), NAe = /* @__PURE__ */ OY(0.5, 0.95, oa);
function OY(e, t, n) {
  return (r) => r < e ? 0 : r > t ? 1 : n(pb(e, t, r));
}
function U7(e, t) {
  e.min = t.min, e.max = t.max;
}
function Pl(e, t) {
  U7(e.x, t.x), U7(e.y, t.y);
}
function z7(e, t) {
  e.translate = t.translate, e.scale = t.scale, e.originPoint = t.originPoint, e.origin = t.origin;
}
function V7(e, t, n, r, i) {
  return e -= t, e = J4(e, 1 / n, r), i !== void 0 && (e = J4(e, 1 / i, r)), e;
}
function BAe(e, t = 0, n = 1, r = 0.5, i, o = e, s = e) {
  if (Lu.test(t) && (t = parseFloat(t), t = vi(s.min, s.max, t / 100) - s.min), typeof t != "number")
    return;
  let c = vi(o.min, o.max, r);
  e === o && (c -= t), e.min = V7(e.min, t, n, c, i), e.max = V7(e.max, t, n, c, i);
}
function $7(e, t, [n, r, i], o, s) {
  BAe(e, t[n], t[r], t[i], t.scale, o, s);
}
const LAe = ["x", "scaleX", "originX"], jAe = ["y", "scaleY", "originY"];
function H7(e, t, n, r) {
  $7(e.x, t, LAe, n ? n.x : void 0, r ? r.x : void 0), $7(e.y, t, jAe, n ? n.y : void 0, r ? r.y : void 0);
}
function q7(e) {
  return e.translate === 0 && e.scale === 1;
}
function IY(e) {
  return q7(e.x) && q7(e.y);
}
function W7(e, t) {
  return e.min === t.min && e.max === t.max;
}
function FAe(e, t) {
  return W7(e.x, t.x) && W7(e.y, t.y);
}
function G7(e, t) {
  return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max);
}
function DY(e, t) {
  return G7(e.x, t.x) && G7(e.y, t.y);
}
function K7(e) {
  return fl(e.x) / fl(e.y);
}
function Y7(e, t) {
  return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint;
}
class UAe {
  constructor() {
    this.members = [];
  }
  add(t) {
    xA(this.members, t), t.scheduleRender();
  }
  remove(t) {
    if (ux(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) {
      const n = this.members[this.members.length - 1];
      n && this.promote(n);
    }
  }
  relegate(t) {
    const n = this.members.findIndex((i) => t === i);
    if (n === 0)
      return !1;
    let r;
    for (let i = n; i >= 0; i--) {
      const o = this.members[i];
      if (o.isPresent !== !1) {
        r = o;
        break;
      }
    }
    return r ? (this.promote(r), !0) : !1;
  }
  promote(t, n) {
    const r = this.lead;
    if (t !== r && (this.prevLead = r, this.lead = t, t.show(), r)) {
      r.instance && r.scheduleRender(), t.scheduleRender(), t.resumeFrom = r, n && (t.resumeFrom.preserveOpacity = !0), r.snapshot && (t.snapshot = r.snapshot, t.snapshot.latestValues = r.animationValues || r.latestValues), t.root && t.root.isUpdating && (t.isLayoutDirty = !0);
      const { crossfade: i } = t.options;
      i === !1 && r.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((t) => {
      const { options: n, resumingFrom: r } = t;
      n.onExitComplete && n.onExitComplete(), r && r.options.onExitComplete && r.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((t) => {
      t.instance && t.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function zAe(e, t, n) {
  let r = "";
  const i = e.x.translate / t.x, o = e.y.translate / t.y, s = (n == null ? void 0 : n.z) || 0;
  if ((i || o || s) && (r = `translate3d(${i}px, ${o}px, ${s}px) `), (t.x !== 1 || t.y !== 1) && (r += `scale(${1 / t.x}, ${1 / t.y}) `), n) {
    const { transformPerspective: f, rotate: p, rotateX: y, rotateY: v, skewX: w, skewY: C } = n;
    f && (r = `perspective(${f}px) ${r}`), p && (r += `rotate(${p}deg) `), y && (r += `rotateX(${y}deg) `), v && (r += `rotateY(${v}deg) `), w && (r += `skewX(${w}deg) `), C && (r += `skewY(${C}deg) `);
  }
  const c = e.x.scale * t.x, u = e.y.scale * t.y;
  return (c !== 1 || u !== 1) && (r += `scale(${c}, ${u})`), r || "none";
}
const VAe = (e, t) => e.depth - t.depth;
class $Ae {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(t) {
    xA(this.children, t), this.isDirty = !0;
  }
  remove(t) {
    ux(this.children, t), this.isDirty = !0;
  }
  forEach(t) {
    this.isDirty && this.children.sort(VAe), this.isDirty = !1, this.children.forEach(t);
  }
}
function m4(e) {
  const t = $o(e) ? e.get() : e;
  return B8e(t) ? t.toValue() : t;
}
function HAe(e, t) {
  const n = Wd.now(), r = ({ timestamp: i }) => {
    const o = i - n;
    o >= t && (Vu(r), e(o - t));
  };
  return Or.read(r, !0), () => Vu(r);
}
function MY(e) {
  return e instanceof SVGElement && e.tagName !== "svg";
}
function KP(e, t, n) {
  const r = $o(e) ? e : mb(e);
  return r.start($P("", r, t, n)), r.animation;
}
const wm = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
}, A1 = typeof window < "u" && window.MotionDebug !== void 0, qO = ["", "X", "Y", "Z"], qAe = { visibility: "hidden" }, Q7 = 1e3;
let WAe = 0;
function WO(e, t, n, r) {
  const { latestValues: i } = t;
  i[e] && (n[e] = i[e], t.setStaticValue(e, 0), r && (r[e] = 0));
}
function PY(e) {
  if (e.hasCheckedOptimisedAppear = !0, e.root === e)
    return;
  const { visualElement: t } = e.options;
  if (!t)
    return;
  const n = uY(t);
  if (window.MotionHasOptimisedAnimation(n, "transform")) {
    const { layout: i, layoutId: o } = e.options;
    window.MotionCancelOptimisedAnimation(n, "transform", Or, !(i || o));
  }
  const { parent: r } = e;
  r && !r.hasCheckedOptimisedAppear && PY(r);
}
function NY({ attachResizeListener: e, defaultParent: t, measureScroll: n, checkIsScrollRoot: r, resetTransform: i }) {
  return class {
    constructor(s = {}, c = t == null ? void 0 : t()) {
      this.id = WAe++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, A1 && (wm.totalNodes = wm.resolvedTargetDeltas = wm.recalculatedProjection = 0), this.nodes.forEach(YAe), this.nodes.forEach(eTe), this.nodes.forEach(tTe), this.nodes.forEach(QAe), A1 && window.MotionDebug.record(wm);
      }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = s, this.root = c ? c.root || c : this, this.path = c ? [...c.path, c] : [], this.parent = c, this.depth = c ? c.depth + 1 : 0;
      for (let u = 0; u < this.path.length; u++)
        this.path[u].shouldResetTransform = !0;
      this.root === this && (this.nodes = new $Ae());
    }
    addEventListener(s, c) {
      return this.eventHandlers.has(s) || this.eventHandlers.set(s, new HP()), this.eventHandlers.get(s).add(c);
    }
    notifyListeners(s, ...c) {
      const u = this.eventHandlers.get(s);
      u && u.notify(...c);
    }
    hasListeners(s) {
      return this.eventHandlers.has(s);
    }
    /**
     * Lifecycles
     */
    mount(s, c = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = MY(s), this.instance = s;
      const { layoutId: u, layout: f, visualElement: p } = this.options;
      if (p && !p.current && p.mount(s), this.root.nodes.add(this), this.parent && this.parent.children.add(this), c && (f || u) && (this.isLayoutDirty = !0), e) {
        let y;
        const v = () => this.root.updateBlockedByResize = !1;
        e(s, () => {
          this.root.updateBlockedByResize = !0, y && y(), y = HAe(v, 250), p4.hasAnimatedSinceResize && (p4.hasAnimatedSinceResize = !1, this.nodes.forEach(J7));
        });
      }
      u && this.root.registerSharedNode(u, this), this.options.animate !== !1 && p && (u || f) && this.addEventListener("didUpdate", ({ delta: y, hasLayoutChanged: v, hasRelativeTargetChanged: w, layout: C }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const x = this.options.transition || p.getDefaultTransition() || aTe, { onLayoutAnimationStart: A, onLayoutAnimationComplete: R } = p.getProps(), I = !this.targetLayout || !DY(this.targetLayout, C) || w, D = !v && w;
        if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || D || v && (I || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(y, D);
          const M = {
            ...RP(x, "layout"),
            onPlay: A,
            onComplete: R
          };
          (p.shouldReduceMotion || this.options.layoutRoot) && (M.delay = 0, M.type = !1), this.startAnimation(M);
        } else
          v || J7(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = C;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const s = this.getStack();
      s && s.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, Vu(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(nTe), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: s } = this.options;
      return s && s.getProps().transformTemplate;
    }
    willUpdate(s = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && PY(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let p = 0; p < this.path.length; p++) {
        const y = this.path[p];
        y.shouldResetTransform = !0, y.updateScroll("snapshot"), y.options.layoutRoot && y.willUpdate(!1);
      }
      const { layoutId: c, layout: u } = this.options;
      if (c === void 0 && !u)
        return;
      const f = this.getTransformTemplate();
      this.prevTransformTemplateValue = f ? f(this.latestValues, "") : void 0, this.updateSnapshot(), s && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(X7);
        return;
      }
      this.isUpdating || this.nodes.forEach(JAe), this.isUpdating = !1, this.nodes.forEach(ZAe), this.nodes.forEach(GAe), this.nodes.forEach(KAe), this.clearAllSnapshots();
      const c = Wd.now();
      ia.delta = Jh(0, 1e3 / 60, c - ia.timestamp), ia.timestamp = c, ia.isProcessing = !0, LO.update.process(ia), LO.preRender.process(ia), LO.render.process(ia), ia.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, GP.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(XAe), this.sharedNodes.forEach(rTe);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Or.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      Or.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let u = 0; u < this.path.length; u++)
          this.path[u].updateScroll();
      const s = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = Wi(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: c } = this.options;
      c && c.notify("LayoutMeasure", this.layout.layoutBox, s ? s.layoutBox : void 0);
    }
    updateScroll(s = "measure") {
      let c = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === s && (c = !1), c) {
        const u = r(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: s,
          isRoot: u,
          offset: n(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : u
        };
      }
    }
    resetTransform() {
      if (!i)
        return;
      const s = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, c = this.projectionDelta && !IY(this.projectionDelta), u = this.getTransformTemplate(), f = u ? u(this.latestValues, "") : void 0, p = f !== this.prevTransformTemplateValue;
      s && (c || bm(this.latestValues) || p) && (i(this.instance, f), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(s = !0) {
      const c = this.measurePageBox();
      let u = this.removeElementScroll(c);
      return s && (u = this.removeTransform(u)), sTe(u), {
        animationId: this.root.animationId,
        measuredBox: c,
        layoutBox: u,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      var s;
      const { visualElement: c } = this.options;
      if (!c)
        return Wi();
      const u = c.measureViewportBox();
      if (!(((s = this.scroll) === null || s === void 0 ? void 0 : s.wasRoot) || this.path.some(lTe))) {
        const { scroll: p } = this.root;
        p && (Sg(u.x, p.offset.x), Sg(u.y, p.offset.y));
      }
      return u;
    }
    removeElementScroll(s) {
      var c;
      const u = Wi();
      if (Pl(u, s), !((c = this.scroll) === null || c === void 0) && c.wasRoot)
        return u;
      for (let f = 0; f < this.path.length; f++) {
        const p = this.path[f], { scroll: y, options: v } = p;
        p !== this.root && y && v.layoutScroll && (y.wasRoot && Pl(u, s), Sg(u.x, y.offset.x), Sg(u.y, y.offset.y));
      }
      return u;
    }
    applyTransform(s, c = !1) {
      const u = Wi();
      Pl(u, s);
      for (let f = 0; f < this.path.length; f++) {
        const p = this.path[f];
        !c && p.options.layoutScroll && p.scroll && p !== p.root && kg(u, {
          x: -p.scroll.offset.x,
          y: -p.scroll.offset.y
        }), bm(p.latestValues) && kg(u, p.latestValues);
      }
      return bm(this.latestValues) && kg(u, this.latestValues), u;
    }
    removeTransform(s) {
      const c = Wi();
      Pl(c, s);
      for (let u = 0; u < this.path.length; u++) {
        const f = this.path[u];
        if (!f.instance || !bm(f.latestValues))
          continue;
        pD(f.latestValues) && f.updateSnapshot();
        const p = Wi(), y = f.measurePageBox();
        Pl(p, y), H7(c, f.latestValues, f.snapshot ? f.snapshot.layoutBox : void 0, p);
      }
      return bm(this.latestValues) && H7(c, this.latestValues), c;
    }
    setTargetDelta(s) {
      this.targetDelta = s, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(s) {
      this.options = {
        ...this.options,
        ...s,
        crossfade: s.crossfade !== void 0 ? s.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== ia.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(s = !1) {
      var c;
      const u = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = u.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = u.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = u.isSharedProjectionDirty);
      const f = !!this.resumingFrom || this !== u;
      if (!(s || f && this.isSharedProjectionDirty || this.isProjectionDirty || !((c = this.parent) === null || c === void 0) && c.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: y, layoutId: v } = this.options;
      if (!(!this.layout || !(y || v))) {
        if (this.resolvedRelativeTargetAt = ia.timestamp, !this.targetDelta && !this.relativeTarget) {
          const w = this.getClosestProjectingParent();
          w && w.layout && this.animationProgress !== 1 ? (this.relativeParent = w, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Wi(), this.relativeTargetOrigin = Wi(), U1(this.relativeTargetOrigin, this.layout.layoutBox, w.layout.layoutBox), Pl(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (this.target || (this.target = Wi(), this.targetWithTransforms = Wi()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), uAe(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Pl(this.target, this.layout.layoutBox), EY(this.target, this.targetDelta)) : Pl(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
            this.attemptToResolveRelativeTarget = !1;
            const w = this.getClosestProjectingParent();
            w && !!w.resumingFrom == !!this.resumingFrom && !w.options.layoutScroll && w.target && this.animationProgress !== 1 ? (this.relativeParent = w, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Wi(), this.relativeTargetOrigin = Wi(), U1(this.relativeTargetOrigin, this.target, w.target), Pl(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
          }
          A1 && wm.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || pD(this.parent.latestValues) || xY(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var s;
      const c = this.getLead(), u = !!this.resumingFrom || this !== c;
      let f = !0;
      if ((this.isProjectionDirty || !((s = this.parent) === null || s === void 0) && s.isProjectionDirty) && (f = !1), u && (this.isSharedProjectionDirty || this.isTransformDirty) && (f = !1), this.resolvedRelativeTargetAt === ia.timestamp && (f = !1), f)
        return;
      const { layout: p, layoutId: y } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(p || y))
        return;
      Pl(this.layoutCorrected, this.layout.layoutBox);
      const v = this.treeScale.x, w = this.treeScale.y;
      bAe(this.layoutCorrected, this.treeScale, this.path, u), c.layout && !c.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (c.target = c.layout.layoutBox, c.targetWithTransforms = Wi());
      const { target: C } = c;
      if (!C) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (z7(this.prevProjectionDelta.x, this.projectionDelta.x), z7(this.prevProjectionDelta.y, this.projectionDelta.y)), F1(this.projectionDelta, this.layoutCorrected, C, this.latestValues), (this.treeScale.x !== v || this.treeScale.y !== w || !Y7(this.projectionDelta.x, this.prevProjectionDelta.x) || !Y7(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", C)), A1 && wm.recalculatedProjection++;
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(s = !0) {
      var c;
      if ((c = this.options.visualElement) === null || c === void 0 || c.scheduleRender(), s) {
        const u = this.getStack();
        u && u.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = Eg(), this.projectionDelta = Eg(), this.projectionDeltaWithTransform = Eg();
    }
    setAnimationOrigin(s, c = !1) {
      const u = this.snapshot, f = u ? u.latestValues : {}, p = { ...this.latestValues }, y = Eg();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !c;
      const v = Wi(), w = u ? u.source : void 0, C = this.layout ? this.layout.source : void 0, x = w !== C, A = this.getStack(), R = !A || A.members.length <= 1, I = !!(x && !R && this.options.crossfade === !0 && !this.path.some(oTe));
      this.animationProgress = 0;
      let D;
      this.mixTargetDelta = (M) => {
        const L = M / 1e3;
        Z7(y.x, s.x, L), Z7(y.y, s.y, L), this.setTargetDelta(y), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (U1(v, this.layout.layoutBox, this.relativeParent.layout.layoutBox), iTe(this.relativeTarget, this.relativeTargetOrigin, v, L), D && FAe(this.relativeTarget, D) && (this.isProjectionDirty = !1), D || (D = Wi()), Pl(D, this.relativeTarget)), x && (this.animationValues = p, MAe(p, f, this.latestValues, L, I, R)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = L;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(s) {
      this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (Vu(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Or.update(() => {
        p4.hasAnimatedSinceResize = !0, this.currentAnimation = KP(0, Q7, {
          ...s,
          onUpdate: (c) => {
            this.mixTargetDelta(c), s.onUpdate && s.onUpdate(c);
          },
          onComplete: () => {
            s.onComplete && s.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const s = this.getStack();
      s && s.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(Q7), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const s = this.getLead();
      let { targetWithTransforms: c, target: u, layout: f, latestValues: p } = s;
      if (!(!c || !u || !f)) {
        if (this !== s && this.layout && f && BY(this.options.animationType, this.layout.layoutBox, f.layoutBox)) {
          u = this.target || Wi();
          const y = fl(this.layout.layoutBox.x);
          u.x.min = s.target.x.min, u.x.max = u.x.min + y;
          const v = fl(this.layout.layoutBox.y);
          u.y.min = s.target.y.min, u.y.max = u.y.min + v;
        }
        Pl(c, u), kg(c, p), F1(this.projectionDeltaWithTransform, this.layoutCorrected, c, p);
      }
    }
    registerSharedNode(s, c) {
      this.sharedNodes.has(s) || this.sharedNodes.set(s, new UAe()), this.sharedNodes.get(s).add(c);
      const f = c.options.initialPromotionConfig;
      c.promote({
        transition: f ? f.transition : void 0,
        preserveFollowOpacity: f && f.shouldPreserveFollowOpacity ? f.shouldPreserveFollowOpacity(c) : void 0
      });
    }
    isLead() {
      const s = this.getStack();
      return s ? s.lead === this : !0;
    }
    getLead() {
      var s;
      const { layoutId: c } = this.options;
      return c ? ((s = this.getStack()) === null || s === void 0 ? void 0 : s.lead) || this : this;
    }
    getPrevLead() {
      var s;
      const { layoutId: c } = this.options;
      return c ? (s = this.getStack()) === null || s === void 0 ? void 0 : s.prevLead : void 0;
    }
    getStack() {
      const { layoutId: s } = this.options;
      if (s)
        return this.root.sharedNodes.get(s);
    }
    promote({ needsReset: s, transition: c, preserveFollowOpacity: u } = {}) {
      const f = this.getStack();
      f && f.promote(this, u), s && (this.projectionDelta = void 0, this.needsReset = !0), c && this.setOptions({ transition: c });
    }
    relegate() {
      const s = this.getStack();
      return s ? s.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: s } = this.options;
      if (!s)
        return;
      let c = !1;
      const { latestValues: u } = s;
      if ((u.z || u.rotate || u.rotateX || u.rotateY || u.rotateZ || u.skewX || u.skewY) && (c = !0), !c)
        return;
      const f = {};
      u.z && WO("z", s, f, this.animationValues);
      for (let p = 0; p < qO.length; p++)
        WO(`rotate${qO[p]}`, s, f, this.animationValues), WO(`skew${qO[p]}`, s, f, this.animationValues);
      s.render();
      for (const p in f)
        s.setStaticValue(p, f[p]), this.animationValues && (this.animationValues[p] = f[p]);
      s.scheduleRender();
    }
    getProjectionStyles(s) {
      var c, u;
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible)
        return qAe;
      const f = {
        visibility: ""
      }, p = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = !1, f.opacity = "", f.pointerEvents = m4(s == null ? void 0 : s.pointerEvents) || "", f.transform = p ? p(this.latestValues, "") : "none", f;
      const y = this.getLead();
      if (!this.projectionDelta || !this.layout || !y.target) {
        const x = {};
        return this.options.layoutId && (x.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, x.pointerEvents = m4(s == null ? void 0 : s.pointerEvents) || ""), this.hasProjected && !bm(this.latestValues) && (x.transform = p ? p({}, "") : "none", this.hasProjected = !1), x;
      }
      const v = y.animationValues || y.latestValues;
      this.applyTransformsToTarget(), f.transform = zAe(this.projectionDeltaWithTransform, this.treeScale, v), p && (f.transform = p(v, f.transform));
      const { x: w, y: C } = this.projectionDelta;
      f.transformOrigin = `${w.origin * 100}% ${C.origin * 100}% 0`, y.animationValues ? f.opacity = y === this ? (u = (c = v.opacity) !== null && c !== void 0 ? c : this.latestValues.opacity) !== null && u !== void 0 ? u : 1 : this.preserveOpacity ? this.latestValues.opacity : v.opacityExit : f.opacity = y === this ? v.opacity !== void 0 ? v.opacity : "" : v.opacityExit !== void 0 ? v.opacityExit : 0;
      for (const x in Z4) {
        if (v[x] === void 0)
          continue;
        const { correct: A, applyTo: R } = Z4[x], I = f.transform === "none" ? v[x] : A(v[x], y);
        if (R) {
          const D = R.length;
          for (let M = 0; M < D; M++)
            f[R[M]] = I;
        } else
          f[x] = I;
      }
      return this.options.layoutId && (f.pointerEvents = y === this ? m4(s == null ? void 0 : s.pointerEvents) || "" : "none"), f;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((s) => {
        var c;
        return (c = s.currentAnimation) === null || c === void 0 ? void 0 : c.stop();
      }), this.root.nodes.forEach(X7), this.root.sharedNodes.clear();
    }
  };
}
function GAe(e) {
  e.updateLayout();
}
function KAe(e) {
  var t;
  const n = ((t = e.resumeFrom) === null || t === void 0 ? void 0 : t.snapshot) || e.snapshot;
  if (e.isLead() && e.layout && n && e.hasListeners("didUpdate")) {
    const { layoutBox: r, measuredBox: i } = e.layout, { animationType: o } = e.options, s = n.source !== e.layout.source;
    o === "size" ? jl((y) => {
      const v = s ? n.measuredBox[y] : n.layoutBox[y], w = fl(v);
      v.min = r[y].min, v.max = v.min + w;
    }) : BY(o, n.layoutBox, r) && jl((y) => {
      const v = s ? n.measuredBox[y] : n.layoutBox[y], w = fl(r[y]);
      v.max = v.min + w, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[y].max = e.relativeTarget[y].min + w);
    });
    const c = Eg();
    F1(c, r, n.layoutBox);
    const u = Eg();
    s ? F1(u, e.applyTransform(i, !0), n.measuredBox) : F1(u, r, n.layoutBox);
    const f = !IY(c);
    let p = !1;
    if (!e.resumeFrom) {
      const y = e.getClosestProjectingParent();
      if (y && !y.resumeFrom) {
        const { snapshot: v, layout: w } = y;
        if (v && w) {
          const C = Wi();
          U1(C, n.layoutBox, v.layoutBox);
          const x = Wi();
          U1(x, r, w.layoutBox), DY(C, x) || (p = !0), y.options.layoutRoot && (e.relativeTarget = x, e.relativeTargetOrigin = C, e.relativeParent = y);
        }
      }
    }
    e.notifyListeners("didUpdate", {
      layout: r,
      snapshot: n,
      delta: u,
      layoutDelta: c,
      hasLayoutChanged: f,
      hasRelativeTargetChanged: p
    });
  } else if (e.isLead()) {
    const { onExitComplete: r } = e.options;
    r && r();
  }
  e.options.transition = void 0;
}
function YAe(e) {
  A1 && wm.totalNodes++, e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty));
}
function QAe(e) {
  e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1;
}
function XAe(e) {
  e.clearSnapshot();
}
function X7(e) {
  e.clearMeasurements();
}
function JAe(e) {
  e.isLayoutDirty = !1;
}
function ZAe(e) {
  const { visualElement: t } = e.options;
  t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform();
}
function J7(e) {
  e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0;
}
function eTe(e) {
  e.resolveTargetDelta();
}
function tTe(e) {
  e.calcProjection();
}
function nTe(e) {
  e.resetSkewAndRotation();
}
function rTe(e) {
  e.removeLeadSnapshot();
}
function Z7(e, t, n) {
  e.translate = vi(t.translate, 0, n), e.scale = vi(t.scale, 1, n), e.origin = t.origin, e.originPoint = t.originPoint;
}
function e9(e, t, n, r) {
  e.min = vi(t.min, n.min, r), e.max = vi(t.max, n.max, r);
}
function iTe(e, t, n, r) {
  e9(e.x, t.x, n.x, r), e9(e.y, t.y, n.y, r);
}
function oTe(e) {
  return e.animationValues && e.animationValues.opacityExit !== void 0;
}
const aTe = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, t9 = (e) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e), n9 = t9("applewebkit/") && !t9("chrome/") ? Math.round : oa;
function r9(e) {
  e.min = n9(e.min), e.max = n9(e.max);
}
function sTe(e) {
  r9(e.x), r9(e.y);
}
function BY(e, t, n) {
  return e === "position" || e === "preserve-aspect" && !cAe(K7(t), K7(n), 0.2);
}
function lTe(e) {
  var t;
  return e !== e.root && ((t = e.scroll) === null || t === void 0 ? void 0 : t.wasRoot);
}
const cTe = NY({
  attachResizeListener: (e, t) => Vd(e, "resize", t),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), GO = {
  current: void 0
}, LY = NY({
  measureScroll: (e) => ({
    x: e.scrollLeft,
    y: e.scrollTop
  }),
  defaultParent: () => {
    if (!GO.current) {
      const e = new cTe({});
      e.mount(window), e.setOptions({ layoutScroll: !0 }), GO.current = e;
    }
    return GO.current;
  },
  resetTransform: (e, t) => {
    e.style.transform = t !== void 0 ? t : "none";
  },
  checkIsScrollRoot: (e) => window.getComputedStyle(e).position === "fixed"
}), uTe = {
  pan: {
    Feature: kAe
  },
  drag: {
    Feature: SAe,
    ProjectionNode: LY,
    MeasureLayout: _Y
  }
};
function i9(e, t) {
  const n = t ? "pointerenter" : "pointerleave", r = t ? "onHoverStart" : "onHoverEnd", i = (o, s) => {
    if (o.pointerType === "touch" || gY())
      return;
    const c = e.getProps();
    e.animationState && c.whileHover && e.animationState.setActive("whileHover", t);
    const u = c[r];
    u && Or.postRender(() => u(o, s));
  };
  return Kd(e.current, n, i, {
    passive: !e.getProps()[r]
  });
}
class dTe extends up {
  mount() {
    this.unmount = Gd(i9(this.node, !0), i9(this.node, !1));
  }
  unmount() {
  }
}
class fTe extends up {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let t = !1;
    try {
      t = this.node.current.matches(":focus-visible");
    } catch {
      t = !0;
    }
    !t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = Gd(Vd(this.node.current, "focus", () => this.onFocus()), Vd(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
const jY = (e, t) => t ? e === t ? !0 : jY(e, t.parentElement) : !1;
function KO(e, t) {
  if (!t)
    return;
  const n = new PointerEvent("pointer" + e);
  t(n, SA(n));
}
class hTe extends up {
  constructor() {
    super(...arguments), this.removeStartListeners = oa, this.removeEndListeners = oa, this.removeAccessibleListeners = oa, this.startPointerPress = (t, n) => {
      if (this.isPressing)
        return;
      this.removeEndListeners();
      const r = this.node.getProps(), o = Kd(window, "pointerup", (c, u) => {
        if (!this.checkPressEnd())
          return;
        const { onTap: f, onTapCancel: p, globalTapTarget: y } = this.node.getProps(), v = !y && !jY(this.node.current, c.target) ? p : f;
        v && Or.update(() => v(c, u));
      }, {
        passive: !(r.onTap || r.onPointerUp)
      }), s = Kd(window, "pointercancel", (c, u) => this.cancelPress(c, u), {
        passive: !(r.onTapCancel || r.onPointerCancel)
      });
      this.removeEndListeners = Gd(o, s), this.startPress(t, n);
    }, this.startAccessiblePress = () => {
      const t = (o) => {
        if (o.key !== "Enter" || this.isPressing)
          return;
        const s = (c) => {
          c.key !== "Enter" || !this.checkPressEnd() || KO("up", (u, f) => {
            const { onTap: p } = this.node.getProps();
            p && Or.postRender(() => p(u, f));
          });
        };
        this.removeEndListeners(), this.removeEndListeners = Vd(this.node.current, "keyup", s), KO("down", (c, u) => {
          this.startPress(c, u);
        });
      }, n = Vd(this.node.current, "keydown", t), r = () => {
        this.isPressing && KO("cancel", (o, s) => this.cancelPress(o, s));
      }, i = Vd(this.node.current, "blur", r);
      this.removeAccessibleListeners = Gd(n, i);
    };
  }
  startPress(t, n) {
    this.isPressing = !0;
    const { onTapStart: r, whileTap: i } = this.node.getProps();
    i && this.node.animationState && this.node.animationState.setActive("whileTap", !0), r && Or.postRender(() => r(t, n));
  }
  checkPressEnd() {
    return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !gY();
  }
  cancelPress(t, n) {
    if (!this.checkPressEnd())
      return;
    const { onTapCancel: r } = this.node.getProps();
    r && Or.postRender(() => r(t, n));
  }
  mount() {
    const t = this.node.getProps(), n = Kd(t.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
      passive: !(t.onTapStart || t.onPointerStart)
    }), r = Vd(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = Gd(n, r);
  }
  unmount() {
    this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners();
  }
}
const yD = /* @__PURE__ */ new WeakMap(), YO = /* @__PURE__ */ new WeakMap(), pTe = (e) => {
  const t = yD.get(e.target);
  t && t(e);
}, mTe = (e) => {
  e.forEach(pTe);
};
function yTe({ root: e, ...t }) {
  const n = e || document;
  YO.has(n) || YO.set(n, {});
  const r = YO.get(n), i = JSON.stringify(t);
  return r[i] || (r[i] = new IntersectionObserver(mTe, { root: e, ...t })), r[i];
}
function vTe(e, t, n) {
  const r = yTe(t);
  return yD.set(e, n), r.observe(e), () => {
    yD.delete(e), r.unobserve(e);
  };
}
const gTe = {
  some: 0,
  all: 1
};
class bTe extends up {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: t = {} } = this.node.getProps(), { root: n, margin: r, amount: i = "some", once: o } = t, s = {
      root: n ? n.current : void 0,
      rootMargin: r,
      threshold: typeof i == "number" ? i : gTe[i]
    }, c = (u) => {
      const { isIntersecting: f } = u;
      if (this.isInView === f || (this.isInView = f, o && !f && this.hasEnteredView))
        return;
      f && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", f);
      const { onViewportEnter: p, onViewportLeave: y } = this.node.getProps(), v = f ? p : y;
      v && v(u);
    };
    return vTe(this.node.current, s, c);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: t, prevProps: n } = this.node;
    ["amount", "margin", "root"].some(wTe(t, n)) && this.startObserver();
  }
  unmount() {
  }
}
function wTe({ viewport: e = {} }, { viewport: t = {} } = {}) {
  return (n) => e[n] !== t[n];
}
const CTe = {
  inView: {
    Feature: bTe
  },
  tap: {
    Feature: hTe
  },
  focus: {
    Feature: fTe
  },
  hover: {
    Feature: dTe
  }
}, xTe = {
  layout: {
    ProjectionNode: LY,
    MeasureLayout: _Y
  }
}, kA = k.createContext({
  transformPagePoint: (e) => e,
  isStatic: !1,
  reducedMotion: "never"
}), AA = k.createContext({}), YP = typeof window < "u", fx = YP ? k.useLayoutEffect : k.useEffect, FY = k.createContext({ strict: !1 });
let o9 = !1;
function ETe(e, t, n, r, i) {
  var o;
  const { visualElement: s } = k.useContext(AA), c = k.useContext(FY), u = k.useContext(dx), f = k.useContext(kA).reducedMotion, p = k.useRef();
  r = r || c.renderer, !p.current && r && (p.current = r(e, {
    visualState: t,
    parent: s,
    props: n,
    presenceContext: u,
    blockInitialAnimation: u ? u.initial === !1 : !1,
    reducedMotionConfig: f
  }));
  const y = p.current, v = k.useContext(TY);
  y && !y.projection && i && (y.type === "html" || y.type === "svg") && kTe(p.current, n, i, v), k.useInsertionEffect(() => {
    y && y.update(n, u);
  });
  const w = n[cY], C = k.useRef(!!w && !window.MotionHandoffIsComplete && ((o = window.MotionHasOptimisedAnimation) === null || o === void 0 ? void 0 : o.call(window, w)));
  return fx(() => {
    y && (y.updateFeatures(), GP.render(y.render), C.current && y.animationState && y.animationState.animateChanges());
  }), k.useEffect(() => {
    y && (!C.current && y.animationState && y.animationState.animateChanges(), C.current = !1, o9 || (o9 = !0, queueMicrotask(STe)));
  }), y;
}
function STe() {
  window.MotionHandoffIsComplete = !0;
}
function kTe(e, t, n, r) {
  const { layoutId: i, layout: o, drag: s, dragConstraints: c, layoutScroll: u, layoutRoot: f } = t;
  e.projection = new n(e.latestValues, t["data-framer-portal-id"] ? void 0 : UY(e.parent)), e.projection.setOptions({
    layoutId: i,
    layout: o,
    alwaysMeasureLayout: !!s || c && xg(c),
    visualElement: e,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof o == "string" ? o : "both",
    initialPromotionConfig: r,
    layoutScroll: u,
    layoutRoot: f
  });
}
function UY(e) {
  if (e)
    return e.options.allowProjection !== !1 ? e.projection : UY(e.parent);
}
function ATe(e, t, n) {
  return k.useCallback(
    (r) => {
      r && e.mount && e.mount(r), t && (r ? t.mount(r) : t.unmount()), n && (typeof n == "function" ? n(r) : xg(n) && (n.current = r));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [t]
  );
}
function TA(e) {
  return mC(e.animate) || _P.some((t) => yC(e[t]));
}
function zY(e) {
  return !!(TA(e) || e.variants);
}
function TTe(e, t) {
  if (TA(e)) {
    const { initial: n, animate: r } = e;
    return {
      initial: n === !1 || yC(n) ? n : void 0,
      animate: yC(r) ? r : void 0
    };
  }
  return e.inherit !== !1 ? t : {};
}
function _Te(e) {
  const { initial: t, animate: n } = TTe(e, k.useContext(AA));
  return k.useMemo(() => ({ initial: t, animate: n }), [a9(t), a9(n)]);
}
function a9(e) {
  return Array.isArray(e) ? e.join(" ") : e;
}
const s9 = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, yb = {};
for (const e in s9)
  yb[e] = {
    isEnabled: (t) => s9[e].some((n) => !!t[n])
  };
function RTe(e) {
  for (const t in e)
    yb[t] = {
      ...yb[t],
      ...e[t]
    };
}
const OTe = Symbol.for("motionComponentSymbol");
function ITe({ preloadedFeatures: e, createVisualElement: t, useRender: n, useVisualState: r, Component: i }) {
  e && RTe(e);
  function o(c, u) {
    let f;
    const p = {
      ...k.useContext(kA),
      ...c,
      layoutId: DTe(c)
    }, { isStatic: y } = p, v = _Te(c), w = r(c, y);
    if (!y && YP) {
      MTe(p, e);
      const C = PTe(p);
      f = C.MeasureLayout, v.visualElement = ETe(i, w, p, t, C.ProjectionNode);
    }
    return S.jsxs(AA.Provider, { value: v, children: [f && v.visualElement ? S.jsx(f, { visualElement: v.visualElement, ...p }) : null, n(i, c, ATe(w, v.visualElement, u), w, y, v.visualElement)] });
  }
  const s = k.forwardRef(o);
  return s[OTe] = i, s;
}
function DTe({ layoutId: e }) {
  const t = k.useContext(gC).id;
  return t && e !== void 0 ? t + "-" + e : e;
}
function MTe(e, t) {
  const n = k.useContext(FY).strict;
  if (ct.env.NODE_ENV !== "production" && t && n) {
    const r = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
    e.ignoreStrict ? Hb(!1, r) : dl(!1, r);
  }
}
function PTe(e) {
  const { drag: t, layout: n } = yb;
  if (!t && !n)
    return {};
  const r = { ...t, ...n };
  return {
    MeasureLayout: t != null && t.isEnabled(e) || n != null && n.isEnabled(e) ? r.MeasureLayout : void 0,
    ProjectionNode: r.ProjectionNode
  };
}
const NTe = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function QP(e) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof e != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    e.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(NTe.indexOf(e) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(e))
    )
  );
}
function VY(e, { style: t, vars: n }, r, i) {
  Object.assign(e.style, t, i && i.getProjectionStyles(r));
  for (const o in n)
    e.style.setProperty(o, n[o]);
}
const $Y = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function HY(e, t, n, r) {
  VY(e, t, void 0, r);
  for (const i in t.attrs)
    e.setAttribute($Y.has(i) ? i : EA(i), t.attrs[i]);
}
function qY(e, { layout: t, layoutId: n }) {
  return cp.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!Z4[e] || e === "opacity");
}
function XP(e, t, n) {
  var r;
  const { style: i } = e, o = {};
  for (const s in i)
    ($o(i[s]) || t.style && $o(t.style[s]) || qY(s, e) || ((r = n == null ? void 0 : n.getValue(s)) === null || r === void 0 ? void 0 : r.liveStyle) !== void 0) && (o[s] = i[s]);
  return n && i && typeof i.willChange == "string" && (n.applyWillChange = !1), o;
}
function WY(e, t, n) {
  const r = XP(e, t, n);
  for (const i in e)
    if ($o(e[i]) || $o(t[i])) {
      const o = ax.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i;
      r[o] = e[i];
    }
  return r;
}
function ep(e) {
  const t = k.useRef(null);
  return t.current === null && (t.current = e()), t.current;
}
function BTe({ applyWillChange: e = !1, scrapeMotionValuesFromProps: t, createRenderState: n, onMount: r }, i, o, s, c) {
  const u = {
    latestValues: jTe(i, o, s, c ? !1 : e, t),
    renderState: n()
  };
  return r && (u.mount = (f) => r(i, f, u)), u;
}
const GY = (e) => (t, n) => {
  const r = k.useContext(AA), i = k.useContext(dx), o = () => BTe(e, t, r, i, n);
  return n ? o() : ep(o);
};
function LTe(e, t) {
  const n = dY(t);
  n && xA(e, n);
}
function l9(e, t, n) {
  const r = Array.isArray(t) ? t : [t];
  for (let i = 0; i < r.length; i++) {
    const o = AP(e, r[i]);
    if (o) {
      const { transitionEnd: s, transition: c, ...u } = o;
      n(u, s);
    }
  }
}
function jTe(e, t, n, r, i) {
  var o;
  const s = {}, c = [], u = r && ((o = e.style) === null || o === void 0 ? void 0 : o.willChange) === void 0, f = i(e, {});
  for (const A in f)
    s[A] = m4(f[A]);
  let { initial: p, animate: y } = e;
  const v = TA(e), w = zY(e);
  t && w && !v && e.inherit !== !1 && (p === void 0 && (p = t.initial), y === void 0 && (y = t.animate));
  let C = n ? n.initial === !1 : !1;
  C = C || p === !1;
  const x = C ? y : p;
  return x && typeof x != "boolean" && !mC(x) && l9(e, x, (A, R) => {
    for (const I in A) {
      let D = A[I];
      if (Array.isArray(D)) {
        const M = C ? D.length - 1 : 0;
        D = D[M];
      }
      D !== null && (s[I] = D);
    }
    for (const I in R)
      s[I] = R[I];
  }), u && (y && p !== !1 && !mC(y) && l9(e, y, (A) => {
    for (const R in A)
      LTe(c, R);
  }), c.length && (s.willChange = c.join(","))), s;
}
const JP = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
}), KY = () => ({
  ...JP(),
  attrs: {}
}), YY = (e, t) => t && typeof e == "number" ? t.transform(e) : e, FTe = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, UTe = ax.length;
function zTe(e, t, n) {
  let r = "", i = !0;
  for (let o = 0; o < UTe; o++) {
    const s = ax[o], c = e[s];
    if (c === void 0)
      continue;
    let u = !0;
    if (typeof c == "number" ? u = c === (s.startsWith("scale") ? 1 : 0) : u = parseFloat(c) === 0, !u || n) {
      const f = YY(c, PP[s]);
      if (!u) {
        i = !1;
        const p = FTe[s] || s;
        r += `${p}(${f}) `;
      }
      n && (t[s] = f);
    }
  }
  return r = r.trim(), n ? r = n(t, i ? "" : r) : i && (r = "none"), r;
}
function ZP(e, t, n) {
  const { style: r, vars: i, transformOrigin: o } = e;
  let s = !1, c = !1;
  for (const u in t) {
    const f = t[u];
    if (cp.has(u)) {
      s = !0;
      continue;
    } else if (_K(u)) {
      i[u] = f;
      continue;
    } else {
      const p = YY(f, PP[u]);
      u.startsWith("origin") ? (c = !0, o[u] = p) : r[u] = p;
    }
  }
  if (t.transform || (s || n ? r.transform = zTe(t, e.transform, n) : r.transform && (r.transform = "none")), c) {
    const { originX: u = "50%", originY: f = "50%", originZ: p = 0 } = o;
    r.transformOrigin = `${u} ${f} ${p}`;
  }
}
function c9(e, t, n) {
  return typeof e == "string" ? e : Tn.transform(t + n * e);
}
function VTe(e, t, n) {
  const r = c9(t, e.x, e.width), i = c9(n, e.y, e.height);
  return `${r} ${i}`;
}
const $Te = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, HTe = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function qTe(e, t, n = 1, r = 0, i = !0) {
  e.pathLength = 1;
  const o = i ? $Te : HTe;
  e[o.offset] = Tn.transform(-r);
  const s = Tn.transform(t), c = Tn.transform(n);
  e[o.array] = `${s} ${c}`;
}
function eN(e, {
  attrX: t,
  attrY: n,
  attrScale: r,
  originX: i,
  originY: o,
  pathLength: s,
  pathSpacing: c = 1,
  pathOffset: u = 0,
  // This is object creation, which we try to avoid per-frame.
  ...f
}, p, y) {
  if (ZP(e, f, y), p) {
    e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
    return;
  }
  e.attrs = e.style, e.style = {};
  const { attrs: v, style: w, dimensions: C } = e;
  v.transform && (C && (w.transform = v.transform), delete v.transform), C && (i !== void 0 || o !== void 0 || w.transform) && (w.transformOrigin = VTe(C, i !== void 0 ? i : 0.5, o !== void 0 ? o : 0.5)), t !== void 0 && (v.x = t), n !== void 0 && (v.y = n), r !== void 0 && (v.scale = r), s !== void 0 && qTe(v, s, c, u, !1);
}
const tN = (e) => typeof e == "string" && e.toLowerCase() === "svg", WTe = {
  useVisualState: GY({
    scrapeMotionValuesFromProps: WY,
    createRenderState: KY,
    onMount: (e, t, { renderState: n, latestValues: r }) => {
      Or.read(() => {
        try {
          n.dimensions = typeof t.getBBox == "function" ? t.getBBox() : t.getBoundingClientRect();
        } catch {
          n.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
      }), Or.render(() => {
        eN(n, r, tN(t.tagName), e.transformTemplate), HY(t, n);
      });
    }
  })
}, GTe = {
  useVisualState: GY({
    applyWillChange: !0,
    scrapeMotionValuesFromProps: XP,
    createRenderState: JP
  })
};
function QY(e, t, n) {
  for (const r in t)
    !$o(t[r]) && !qY(r, n) && (e[r] = t[r]);
}
function KTe({ transformTemplate: e }, t) {
  return k.useMemo(() => {
    const n = JP();
    return ZP(n, t, e), Object.assign({}, n.vars, n.style);
  }, [t]);
}
function YTe(e, t) {
  const n = e.style || {}, r = {};
  return QY(r, n, e), Object.assign(r, KTe(e, t)), r;
}
function QTe(e, t) {
  const n = {}, r = YTe(e, t);
  return e.drag && e.dragListener !== !1 && (n.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0), n.style = r, n;
}
const XTe = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function e8(e) {
  return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || XTe.has(e);
}
let XY = (e) => !e8(e);
function JTe(e) {
  e && (XY = (t) => t.startsWith("on") ? !e8(t) : e(t));
}
try {
  JTe(require("@emotion/is-prop-valid").default);
} catch {
}
function ZTe(e, t, n) {
  const r = {};
  for (const i in e)
    i === "values" && typeof e.values == "object" || (XY(i) || n === !0 && e8(i) || !t && !e8(i) || // If trying to use native HTML drag events, forward drag listeners
    e.draggable && i.startsWith("onDrag")) && (r[i] = e[i]);
  return r;
}
function e2e(e, t, n, r) {
  const i = k.useMemo(() => {
    const o = KY();
    return eN(o, t, tN(r), e.transformTemplate), {
      ...o.attrs,
      style: { ...o.style }
    };
  }, [t]);
  if (e.style) {
    const o = {};
    QY(o, e.style, e), i.style = { ...o, ...i.style };
  }
  return i;
}
function t2e(e = !1) {
  return (n, r, i, { latestValues: o }, s) => {
    const u = (QP(n) ? e2e : QTe)(r, o, s, n), f = ZTe(r, typeof n == "string", e), p = n !== k.Fragment ? { ...f, ...u, ref: i } : {}, { children: y } = r, v = k.useMemo(() => $o(y) ? y.get() : y, [y]);
    return k.createElement(n, {
      ...p,
      children: v
    });
  };
}
function n2e(e, t) {
  return function(r, { forwardMotionProps: i } = { forwardMotionProps: !1 }) {
    const s = {
      ...QP(r) ? WTe : GTe,
      preloadedFeatures: e,
      useRender: t2e(i),
      createVisualElement: t,
      Component: r
    };
    return ITe(s);
  };
}
const vD = { current: null }, JY = { current: !1 };
function r2e() {
  if (JY.current = !0, !!YP)
    if (window.matchMedia) {
      const e = window.matchMedia("(prefers-reduced-motion)"), t = () => vD.current = e.matches;
      e.addListener(t), t();
    } else
      vD.current = !1;
}
function i2e(e, t, n) {
  for (const r in t) {
    const i = t[r], o = n[r];
    if ($o(i))
      e.addValue(r, i), ct.env.NODE_ENV === "development" && bA(i.version === "11.5.4", `Attempting to mix Framer Motion versions ${i.version} with 11.5.4 may not work as expected.`);
    else if ($o(o))
      e.addValue(r, mb(i, { owner: e }));
    else if (o !== i)
      if (e.hasValue(r)) {
        const s = e.getValue(r);
        s.liveStyle === !0 ? s.jump(i) : s.hasAnimated || s.set(i);
      } else {
        const s = e.getStaticValue(r);
        e.addValue(r, mb(s !== void 0 ? s : i, { owner: e }));
      }
  }
  for (const r in n)
    t[r] === void 0 && e.removeValue(r);
  return t;
}
const bC = /* @__PURE__ */ new WeakMap(), o2e = [...IK, Ta, Zh], a2e = (e) => o2e.find(OK(e)), u9 = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
], s2e = _P.length;
class l2e {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(t, n, r) {
    return {};
  }
  constructor({ parent: t, props: n, presenceContext: r, reducedMotionConfig: i, blockInitialAnimation: o, visualState: s }, c = {}) {
    this.applyWillChange = !1, this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = DP, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.isRenderScheduled = !1, this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.isRenderScheduled = !1, this.scheduleRender = () => {
      this.isRenderScheduled || (this.isRenderScheduled = !0, Or.render(this.render, !1, !0));
    };
    const { latestValues: u, renderState: f } = s;
    this.latestValues = u, this.baseTarget = { ...u }, this.initialValues = n.initial ? { ...u } : {}, this.renderState = f, this.parent = t, this.props = n, this.presenceContext = r, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = i, this.options = c, this.blockInitialAnimation = !!o, this.isControllingVariants = TA(n), this.isVariantNode = zY(n), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(t && t.current);
    const { willChange: p, ...y } = this.scrapeMotionValuesFromProps(n, {}, this);
    for (const v in y) {
      const w = y[v];
      u[v] !== void 0 && $o(w) && w.set(u[v], !1);
    }
  }
  mount(t) {
    this.current = t, bC.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, r) => this.bindToMotionValue(r, n)), JY.current || r2e(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : vD.current, ct.env.NODE_ENV !== "production" && bA(this.shouldReduceMotion !== !0, "You have Reduced Motion enabled on your device. Animations may not appear as expected."), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    bC.delete(this.current), this.projection && this.projection.unmount(), Vu(this.notifyUpdate), Vu(this.render), this.valueSubscriptions.forEach((t) => t()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
    for (const t in this.events)
      this.events[t].clear();
    for (const t in this.features) {
      const n = this.features[t];
      n && (n.unmount(), n.isMounted = !1);
    }
    this.current = null;
  }
  bindToMotionValue(t, n) {
    this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)();
    const r = cp.has(t), i = n.on("change", (c) => {
      this.latestValues[t] = c, this.props.onUpdate && Or.preRender(this.notifyUpdate), r && this.projection && (this.projection.isTransformDirty = !0);
    }), o = n.on("renderRequest", this.scheduleRender);
    let s;
    window.MotionCheckAppearSync && (s = window.MotionCheckAppearSync(this, t, n)), this.valueSubscriptions.set(t, () => {
      i(), o(), s && s(), n.owner && n.stop();
    });
  }
  sortNodePosition(t) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current);
  }
  updateFeatures() {
    let t = "animation";
    for (t in yb) {
      const n = yb[t];
      if (!n)
        continue;
      const { isEnabled: r, Feature: i } = n;
      if (!this.features[t] && i && r(this.props) && (this.features[t] = new i(this)), this.features[t]) {
        const o = this.features[t];
        o.isMounted ? o.update() : (o.mount(), o.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Wi();
  }
  getStaticValue(t) {
    return this.latestValues[t];
  }
  setStaticValue(t, n) {
    this.latestValues[t] = n;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(t, n) {
    (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = n;
    for (let r = 0; r < u9.length; r++) {
      const i = u9[r];
      this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]);
      const o = "on" + i, s = t[o];
      s && (this.propEventSubscriptions[i] = this.on(i, s));
    }
    this.prevMotionValues = i2e(this, this.scrapeMotionValuesFromProps(t, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(t) {
    return this.props.variants ? this.props.variants[t] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  getVariantContext(t = !1) {
    if (t)
      return this.parent ? this.parent.getVariantContext() : void 0;
    if (!this.isControllingVariants) {
      const r = this.parent ? this.parent.getVariantContext() || {} : {};
      return this.props.initial !== void 0 && (r.initial = this.props.initial), r;
    }
    const n = {};
    for (let r = 0; r < s2e; r++) {
      const i = _P[r], o = this.props[i];
      (yC(o) || o === !1) && (n[i] = o);
    }
    return n;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(t) {
    const n = this.getClosestVariantNode();
    if (n)
      return n.variantChildren && n.variantChildren.add(t), () => n.variantChildren.delete(t);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(t, n) {
    const r = this.values.get(t);
    n !== r && (r && this.removeValue(t), this.bindToMotionValue(t, n), this.values.set(t, n), this.latestValues[t] = n.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(t) {
    this.values.delete(t);
    const n = this.valueSubscriptions.get(t);
    n && (n(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(t) {
    return this.values.has(t);
  }
  getValue(t, n) {
    if (this.props.values && this.props.values[t])
      return this.props.values[t];
    let r = this.values.get(t);
    return r === void 0 && n !== void 0 && (r = mb(n === null ? void 0 : n, { owner: this }), this.addValue(t, r)), r;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(t, n) {
    var r;
    let i = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : (r = this.getBaseTargetFromProps(this.props, t)) !== null && r !== void 0 ? r : this.readValueFromInstance(this.current, t, this.options);
    return i != null && (typeof i == "string" && (AK(i) || kK(i)) ? i = parseFloat(i) : !a2e(i) && Zh.test(n) && (i = FK(t, n)), this.setBaseTarget(t, $o(i) ? i.get() : i)), $o(i) ? i.get() : i;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(t, n) {
    this.baseTarget[t] = n;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(t) {
    var n;
    const { initial: r } = this.props;
    let i;
    if (typeof r == "string" || typeof r == "object") {
      const s = AP(this.props, r, (n = this.presenceContext) === null || n === void 0 ? void 0 : n.custom);
      s && (i = s[t]);
    }
    if (r && i !== void 0)
      return i;
    const o = this.getBaseTargetFromProps(this.props, t);
    return o !== void 0 && !$o(o) ? o : this.initialValues[t] !== void 0 && i === void 0 ? void 0 : this.baseTarget[t];
  }
  on(t, n) {
    return this.events[t] || (this.events[t] = new HP()), this.events[t].add(n);
  }
  notify(t, ...n) {
    this.events[t] && this.events[t].notify(...n);
  }
}
class ZY extends l2e {
  constructor() {
    super(...arguments), this.KeyframeResolver = UK;
  }
  sortInstanceNodePosition(t, n) {
    return t.compareDocumentPosition(n) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(t, n) {
    return t.style ? t.style[n] : void 0;
  }
  removeValueFromRenderState(t, { vars: n, style: r }) {
    delete n[t], delete r[t];
  }
}
function c2e(e) {
  return window.getComputedStyle(e);
}
class eQ extends ZY {
  constructor() {
    super(...arguments), this.type = "html", this.applyWillChange = !0, this.renderInstance = VY;
  }
  readValueFromInstance(t, n) {
    if (cp.has(n)) {
      const r = NP(n);
      return r && r.default || 0;
    } else {
      const r = c2e(t), i = (_K(n) ? r.getPropertyValue(n) : r[n]) || 0;
      return typeof i == "string" ? i.trim() : i;
    }
  }
  measureInstanceViewportBox(t, { transformPagePoint: n }) {
    return SY(t, n);
  }
  build(t, n, r) {
    ZP(t, n, r.transformTemplate);
  }
  scrapeMotionValuesFromProps(t, n, r) {
    return XP(t, n, r);
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: t } = this.props;
    $o(t) && (this.childSubscription = t.on("change", (n) => {
      this.current && (this.current.textContent = `${n}`);
    }));
  }
}
class tQ extends ZY {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = Wi;
  }
  getBaseTargetFromProps(t, n) {
    return t[n];
  }
  readValueFromInstance(t, n) {
    if (cp.has(n)) {
      const r = NP(n);
      return r && r.default || 0;
    }
    return n = $Y.has(n) ? n : EA(n), t.getAttribute(n);
  }
  scrapeMotionValuesFromProps(t, n, r) {
    return WY(t, n, r);
  }
  build(t, n, r) {
    eN(t, n, this.isSVGTag, r.transformTemplate);
  }
  renderInstance(t, n, r, i) {
    HY(t, n, r, i);
  }
  mount(t) {
    this.isSVGTag = tN(t.tagName), super.mount(t);
  }
}
const u2e = (e, t) => QP(e) ? new tQ(t) : new eQ(t, {
  allowProjection: e !== k.Fragment
}), d2e = /* @__PURE__ */ n2e({
  ...eAe,
  ...CTe,
  ...uTe,
  ...xTe
}, u2e), gi = /* @__PURE__ */ r4e(d2e);
class f2e extends k.Component {
  getSnapshotBeforeUpdate(t) {
    const n = this.props.childRef.current;
    if (n && t.isPresent && !this.props.isPresent) {
      const r = this.props.sizeRef.current;
      r.height = n.offsetHeight || 0, r.width = n.offsetWidth || 0, r.top = n.offsetTop, r.left = n.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function h2e({ children: e, isPresent: t }) {
  const n = k.useId(), r = k.useRef(null), i = k.useRef({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  }), { nonce: o } = k.useContext(kA);
  return k.useInsertionEffect(() => {
    const { width: s, height: c, top: u, left: f } = i.current;
    if (t || !r.current || !s || !c)
      return;
    r.current.dataset.motionPopId = n;
    const p = document.createElement("style");
    return o && (p.nonce = o), document.head.appendChild(p), p.sheet && p.sheet.insertRule(`
          [data-motion-pop-id="${n}"] {
            position: absolute !important;
            width: ${s}px !important;
            height: ${c}px !important;
            top: ${u}px !important;
            left: ${f}px !important;
          }
        `), () => {
      document.head.removeChild(p);
    };
  }, [t]), S.jsx(f2e, { isPresent: t, childRef: r, sizeRef: i, children: k.cloneElement(e, { ref: r }) });
}
const p2e = ({ children: e, initial: t, isPresent: n, onExitComplete: r, custom: i, presenceAffectsLayout: o, mode: s }) => {
  const c = ep(m2e), u = k.useId(), f = k.useMemo(
    () => ({
      id: u,
      initial: t,
      isPresent: n,
      custom: i,
      onExitComplete: (p) => {
        c.set(p, !0);
        for (const y of c.values())
          if (!y)
            return;
        r && r();
      },
      register: (p) => (c.set(p, !1), () => c.delete(p))
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    o ? [Math.random()] : [n]
  );
  return k.useMemo(() => {
    c.forEach((p, y) => c.set(y, !1));
  }, [n]), k.useEffect(() => {
    !n && !c.size && r && r();
  }, [n]), s === "popLayout" && (e = S.jsx(h2e, { isPresent: n, children: e })), S.jsx(dx.Provider, { value: f, children: e });
};
function m2e() {
  return /* @__PURE__ */ new Map();
}
const zk = (e) => e.key || "";
function d9(e) {
  const t = [];
  return k.Children.forEach(e, (n) => {
    k.isValidElement(n) && t.push(n);
  }), t;
}
const _A = ({ children: e, exitBeforeEnter: t, custom: n, initial: r = !0, onExitComplete: i, presenceAffectsLayout: o = !0, mode: s = "sync" }) => {
  dl(!t, "Replace exitBeforeEnter with mode='wait'");
  const c = k.useMemo(() => d9(e), [e]), u = c.map(zk), f = k.useRef(!0), p = k.useRef(c), y = ep(() => /* @__PURE__ */ new Map()), [v, w] = k.useState(c), [C, x] = k.useState(c);
  fx(() => {
    f.current = !1, p.current = c;
    for (let I = 0; I < C.length; I++) {
      const D = zk(C[I]);
      u.includes(D) ? y.delete(D) : y.get(D) !== !0 && y.set(D, !1);
    }
  }, [C, u.length, u.join("-")]);
  const A = [];
  if (c !== v) {
    let I = [...c];
    for (let D = 0; D < C.length; D++) {
      const M = C[D], L = zk(M);
      u.includes(L) || (I.splice(D, 0, M), A.push(M));
    }
    s === "wait" && A.length && (I = A), x(d9(I)), w(c);
    return;
  }
  ct.env.NODE_ENV !== "production" && s === "wait" && C.length > 1;
  const { forceRender: R } = k.useContext(gC);
  return S.jsx(S.Fragment, { children: C.map((I) => {
    const D = zk(I), M = c === C || u.includes(D), L = () => {
      if (y.has(D))
        y.set(D, !0);
      else
        return;
      let j = !0;
      y.forEach((F) => {
        F || (j = !1);
      }), j && (R == null || R(), x(p.current), i && i());
    };
    return S.jsx(p2e, { isPresent: M, initial: !f.current || r ? void 0 : !1, custom: M ? void 0 : n, presenceAffectsLayout: o, mode: s, onExitComplete: M ? void 0 : L, children: I }, D);
  }) });
}, y2e = k.createContext(null);
function v2e() {
  const e = k.useRef(!1);
  return fx(() => (e.current = !0, () => {
    e.current = !1;
  }), []), e;
}
function g2e() {
  const e = v2e(), [t, n] = k.useState(0), r = k.useCallback(() => {
    e.current && n(t + 1);
  }, [t]);
  return [k.useCallback(() => Or.postRender(r), [r]), t];
}
const b2e = (e) => !e.isLayoutDirty && e.willUpdate(!1);
function f9() {
  const e = /* @__PURE__ */ new Set(), t = /* @__PURE__ */ new WeakMap(), n = () => e.forEach(b2e);
  return {
    add: (r) => {
      e.add(r), t.set(r, r.addEventListener("willUpdate", n));
    },
    remove: (r) => {
      e.delete(r);
      const i = t.get(r);
      i && (i(), t.delete(r)), n();
    },
    dirty: n
  };
}
const nQ = (e) => e === !0, w2e = (e) => nQ(e === !0) || e === "id", C2e = ({ children: e, id: t, inherit: n = !0 }) => {
  const r = k.useContext(gC), i = k.useContext(y2e), [o, s] = g2e(), c = k.useRef(null), u = r.id || i;
  c.current === null && (w2e(n) && u && (t = t ? u + "-" + t : u), c.current = {
    id: t,
    group: nQ(n) && r.group || f9()
  });
  const f = k.useMemo(() => ({ ...c.current, forceRender: o }), [s]);
  return S.jsx(gC.Provider, { value: f, children: e });
};
function rQ(e) {
  const t = ep(() => mb(e)), { isStatic: n } = k.useContext(kA);
  if (n) {
    const [, r] = k.useState(e);
    k.useEffect(() => t.on("change", r), []);
  }
  return t;
}
function iQ(e, t) {
  const n = rQ(t()), r = () => n.set(t());
  return r(), fx(() => {
    const i = () => Or.preRender(r, !1, !0), o = e.map((s) => s.on("change", i));
    return () => {
      o.forEach((s) => s()), Vu(r);
    };
  }), n;
}
const x2e = (e) => e && typeof e == "object" && e.mix, E2e = (e) => x2e(e) ? e.mix : void 0;
function S2e(...e) {
  const t = !Array.isArray(e[0]), n = t ? 0 : -1, r = e[0 + n], i = e[1 + n], o = e[2 + n], s = e[3 + n], c = eY(i, o, {
    mixer: E2e(o[0]),
    ...s
  });
  return t ? c(r) : c;
}
function k2e(e) {
  j1.current = [], e();
  const t = iQ(j1.current, e);
  return j1.current = void 0, t;
}
function A2e(e, t, n, r) {
  if (typeof e == "function")
    return k2e(e);
  const i = typeof t == "function" ? t : S2e(t, n, r);
  return Array.isArray(e) ? h9(e, i) : h9([e], ([o]) => i(o));
}
function h9(e, t) {
  const n = ep(() => []);
  return iQ(e, () => {
    n.length = 0;
    const r = e.length;
    for (let i = 0; i < r; i++)
      n[i] = e[i].get();
    return t(n);
  });
}
function oQ(e, t, n) {
  var r;
  if (typeof e == "string") {
    let i = document;
    t && (dl(!!t.current, "Scope provided, but no element detected."), i = t.current), n ? ((r = n[e]) !== null && r !== void 0 || (n[e] = i.querySelectorAll(e)), e = n[e]) : e = i.querySelectorAll(e);
  } else e instanceof Element && (e = [e]);
  return Array.from(e || []);
}
function T2e(e) {
  e.values.forEach((t) => t.stop());
}
function gD(e, t) {
  [...t].reverse().forEach((r) => {
    const i = e.getVariant(r);
    i && qP(e, i), e.variantChildren && e.variantChildren.forEach((o) => {
      gD(o, t);
    });
  });
}
function _2e(e, t) {
  if (Array.isArray(t))
    return gD(e, t);
  if (typeof t == "string")
    return gD(e, [t]);
  qP(e, t);
}
function R2e() {
  let e = !1;
  const t = /* @__PURE__ */ new Set(), n = {
    subscribe(r) {
      return t.add(r), () => void t.delete(r);
    },
    start(r, i) {
      dl(e, "controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.");
      const o = [];
      return t.forEach((s) => {
        o.push(fY(s, r, {
          transitionOverride: i
        }));
      }), Promise.all(o);
    },
    set(r) {
      return dl(e, "controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook."), t.forEach((i) => {
        _2e(i, r);
      });
    },
    stop() {
      t.forEach((r) => {
        T2e(r);
      });
    },
    mount() {
      return e = !0, () => {
        e = !1, n.stop();
      };
    }
  };
  return n;
}
function O2e(e) {
  return k.useEffect(() => () => e(), []);
}
function I2e(e) {
  return typeof e == "object" && !Array.isArray(e);
}
function D2e(e) {
  const t = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        transform: {},
        transformOrigin: {},
        style: {},
        vars: {},
        attrs: {}
      },
      latestValues: {}
    }
  }, n = MY(e) ? new tQ(t) : new eQ(t);
  n.mount(e), bC.set(e, n);
}
function M2e(e, t = 100) {
  const n = BP({ keyframes: [0, t], ...e }), r = Math.min(rY(n), uD);
  return {
    type: "keyframes",
    ease: (i) => n.next(r * i).value / t,
    duration: Bu(r)
  };
}
function p9(e, t, n, r) {
  var i;
  return typeof t == "number" ? t : t.startsWith("-") || t.startsWith("+") ? Math.max(0, e + parseFloat(t)) : t === "<" ? n : (i = r.get(t)) !== null && i !== void 0 ? i : e;
}
const P2e = (e, t, n) => {
  const r = t - e;
  return ((n - e) % r + r) % r + e;
};
function N2e(e, t) {
  return GK(e) ? e[P2e(0, e.length, t)] : e;
}
function B2e(e, t, n) {
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    i.at > t && i.at < n && (ux(e, i), r--);
  }
}
function L2e(e, t, n, r, i, o) {
  B2e(e, i, o);
  for (let s = 0; s < t.length; s++)
    e.push({
      value: t[s],
      at: vi(i, o, r[s]),
      easing: N2e(n, s)
    });
}
function j2e(e, t) {
  return e.at === t.at ? e.value === null ? 1 : t.value === null ? -1 : 0 : e.at - t.at;
}
const F2e = "easeInOut";
function U2e(e, { defaultTransition: t = {}, ...n } = {}, r) {
  const i = t.duration || 0.3, o = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), c = {}, u = /* @__PURE__ */ new Map();
  let f = 0, p = 0, y = 0;
  for (let v = 0; v < e.length; v++) {
    const w = e[v];
    if (typeof w == "string") {
      u.set(w, p);
      continue;
    } else if (!Array.isArray(w)) {
      u.set(w.name, p9(p, w.at, f, u));
      continue;
    }
    let [C, x, A = {}] = w;
    A.at !== void 0 && (p = p9(p, A.at, f, u));
    let R = 0;
    const I = (D, M, L, j = 0, F = 0) => {
      const O = z2e(D), { delay: z = 0, times: H = nY(O), type: Q = "keyframes", ...Y } = M;
      let { ease: ee = t.ease || "easeOut", duration: ie } = M;
      const X = typeof z == "function" ? z(j, F) : z, Z = O.length;
      if (Z <= 2 && Q === "spring") {
        let be = 100;
        if (Z === 2 && H2e(O)) {
          const Ee = O[1] - O[0];
          be = Math.abs(Ee);
        }
        const ce = { ...Y };
        ie !== void 0 && (ce.duration = Uc(ie));
        const pe = M2e(ce, be);
        ee = pe.ease, ie = pe.duration;
      }
      ie ?? (ie = i);
      const J = p + X, K = J + ie;
      H.length === 1 && H[0] === 0 && (H[1] = 1);
      const oe = H.length - O.length;
      oe > 0 && tY(H, oe), O.length === 1 && O.unshift(null), L2e(L, O, ee, H, J, K), R = Math.max(X + ie, R), y = Math.max(K, y);
    };
    if ($o(C)) {
      const D = m9(C, s);
      I(x, A, y9("default", D));
    } else {
      const D = oQ(C, r, c), M = D.length;
      for (let L = 0; L < M; L++) {
        x = x, A = A;
        const j = D[L], F = m9(j, s);
        for (const O in x)
          I(x[O], V2e(A, O), y9(O, F), L, M);
      }
    }
    f = p, p += R;
  }
  return s.forEach((v, w) => {
    for (const C in v) {
      const x = v[C];
      x.sort(j2e);
      const A = [], R = [], I = [];
      for (let M = 0; M < x.length; M++) {
        const { at: L, value: j, easing: F } = x[M];
        A.push(j), R.push(pb(0, y, L)), I.push(F || "easeOut");
      }
      R[0] !== 0 && (R.unshift(0), A.unshift(A[0]), I.unshift(F2e)), R[R.length - 1] !== 1 && (R.push(1), A.push(null)), o.has(w) || o.set(w, {
        keyframes: {},
        transition: {}
      });
      const D = o.get(w);
      D.keyframes[C] = A, D.transition[C] = {
        ...t,
        duration: y,
        ease: I,
        times: R,
        ...n
      };
    }
  }), o;
}
function m9(e, t) {
  return !t.has(e) && t.set(e, {}), t.get(e);
}
function y9(e, t) {
  return t[e] || (t[e] = []), t[e];
}
function z2e(e) {
  return Array.isArray(e) ? e : [e];
}
function V2e(e, t) {
  return e[t] ? {
    ...e,
    ...e[t]
  } : { ...e };
}
const $2e = (e) => typeof e == "number", H2e = (e) => e.every($2e);
function aQ(e, t, n, r) {
  const i = oQ(e, r), o = i.length;
  dl(!!o, "No valid element provided.");
  const s = [];
  for (let c = 0; c < o; c++) {
    const u = i[c];
    bC.has(u) || D2e(u);
    const f = bC.get(u), p = { ...n };
    typeof p.delay == "function" && (p.delay = p.delay(c, o)), s.push(...WP(f, { ...t, transition: p }, {}));
  }
  return new VP(s);
}
const q2e = (e) => Array.isArray(e) && Array.isArray(e[0]);
function W2e(e, t, n) {
  const r = [];
  return U2e(e, t, n).forEach(({ keyframes: o, transition: s }, c) => {
    let u;
    $o(c) ? u = KP(c, o.default, s.default) : u = aQ(c, o, s), r.push(u);
  }), new VP(r);
}
const sQ = (e) => {
  function t(n, r, i) {
    let o;
    return q2e(n) ? o = W2e(n, r, e) : I2e(r) ? o = aQ(n, r, i, e) : o = KP(n, r, i), e && e.animations.push(o), o;
  }
  return t;
}, G2e = sQ();
function K2e() {
  const e = ep(() => ({
    current: null,
    // Will be hydrated by React
    animations: []
  })), t = ep(() => sQ(e));
  return O2e(() => {
    e.animations.forEach((n) => n.stop());
  }), [e, t];
}
function Y2e() {
  const e = ep(R2e);
  return fx(e.mount, []), e;
}
const Q2e = Y2e;
function lQ(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var i = e.length;
    for (t = 0; t < i; t++) e[t] && (n = lQ(e[t])) && (r && (r += " "), r += n);
  } else for (n in e) e[n] && (r && (r += " "), r += n);
  return r;
}
function zs() {
  for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++) (e = arguments[n]) && (t = lQ(e)) && (r && (r += " "), r += t);
  return r;
}
const ae = k.forwardRef(
  ({ children: e, as: t = "div", className: n, ...r }, i) => {
    const o = {}, s = {};
    return Object.entries(r).forEach(([c, u]) => {
      LU.properties.has(c) ? o[c] = u : s[c] = u;
    }), k.createElement(t, {
      className: zs([LU(o), n]),
      children: e,
      ref: i,
      ...s
    });
  }
);
function X2e(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function J2e(e) {
  var t = X2e(e, "string");
  return typeof t == "symbol" ? t : String(t);
}
function Z2e(e, t, n) {
  return t = J2e(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function v9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function g9(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? v9(Object(n), !0).forEach(function(r) {
      Z2e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : v9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function b9(e, t) {
  var n = {};
  for (var r in e)
    n[r] = t(e[r], r);
  return n;
}
var e_e = (e, t, n) => {
  for (var r of Object.keys(e)) {
    var i;
    if (e[r] !== ((i = t[r]) !== null && i !== void 0 ? i : n[r]))
      return !1;
  }
  return !0;
}, Wb = (e) => {
  var t = (n) => {
    var r = e.defaultClassName, i = g9(g9({}, e.defaultVariants), n);
    for (var o in i) {
      var s, c = (s = i[o]) !== null && s !== void 0 ? s : e.defaultVariants[o];
      if (c != null) {
        var u = c;
        typeof u == "boolean" && (u = u === !0 ? "true" : "false");
        var f = (
          // @ts-expect-error
          e.variantClassNames[o][u]
        );
        f && (r += " " + f);
      }
    }
    for (var [p, y] of e.compoundVariants)
      e_e(p, i, e.defaultVariants) && (r += " " + y);
    return r;
  };
  return t.variants = () => Object.keys(e.variantClassNames), t.classNames = {
    get base() {
      return e.defaultClassName.split(" ")[0];
    },
    get variants() {
      return b9(e.variantClassNames, (n) => b9(n, (r) => r.split(" ")[0]));
    }
  }, t;
}, t_e = Wb({ defaultClassName: "_2epb0q4", variantClassNames: { size: { regular: "_2epb0q5", small: "_2epb0q6" }, color: { regular: "_2epb0q7 _2epb0q2 yv8y4rzr yv8y4rzs yv8y4rr7 yv8y4rr8", inverted: "_2epb0q8 _2epb0q3 yv8y4rzj yv8y4rzk yv8y4rrh yv8y4rri" } }, defaultVariants: { size: "regular", color: "regular" }, compoundVariants: [] });
const Wl = ({
  variant: e
}) => /* @__PURE__ */ S.jsx("span", { className: t_e(e) });
var RA = "_15z228e0", n_e = Wb({ defaultClassName: "_15z228ec _15z228e1 yv8y4r24 yv8y4r2n yv8y4rg1 yv8y4rfj yv8y4rpl yv8y4rj7 yv8y4rr yv8y4r2z yv8y4rp yv8y4r13", variantClassNames: { color: { primary: "_15z228ed _15z228e2 yv8y4rx1 yv8y4rx2 yv8y4rsp yv8y4rsq yv8y4r11d yv8y4r11e yv8y4r13 yv8y4rp", secondary: "_15z228ee _15z228e3 yv8y4rxj yv8y4rxk yv8y4rt7 yv8y4rt8 yv8y4r11v yv8y4r11w yv8y4r14 yv8y4rq", disabled: "_15z228ef _15z228e4 yv8y4rz1 yv8y4rz2 yv8y4rup yv8y4ruq yv8y4r13d yv8y4r13e", smallButton: "_15z228eg _15z228e5 yv8y4ry1 yv8y4ry2 yv8y4rtp yv8y4rtq yv8y4r12d yv8y4r12e yv8y4r14 yv8y4rq", smallButtonLight: "_15z228eh _15z228e6 yv8y4ryj yv8y4ryk yv8y4ru7 yv8y4ru8 yv8y4r12v yv8y4r12w yv8y4r14 yv8y4rq" }, animation: { none: "_15z228ei", press: "_15z228ej _15z228e0" }, height: { small: "_15z228ek _15z228e7 yv8y4rll" }, border: { regular: "_15z228el _15z228e8 yv8y4r2a" }, size: { regular: "_15z228em _15z228e9 yv8y4rmf", small: "_15z228en _15z228ea _15z228eb yv8y4re9 yv8y4rcr yv8y4r9l yv8y4rb3 yv8y4rmb yv8y4r15" } }, defaultVariants: { color: "primary", animation: "press", border: "regular", size: "regular" }, compoundVariants: [] });
const Jl = ({ children: e, variant: t, isLoading: n, ...r }) => /* @__PURE__ */ S.jsxs("button", { className: n_e(t), ...r, children: [
  n && /* @__PURE__ */ S.jsx(Wl, {}),
  e
] }), Gl = (e) => /* @__PURE__ */ S.jsx(ae, { height: "px", width: "full", background: "backgroundMuted", ...e });
/**
 * @remix-run/router v1.19.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function Pi() {
  return Pi = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Pi.apply(this, arguments);
}
var Gi;
(function(e) {
  e.Pop = "POP", e.Push = "PUSH", e.Replace = "REPLACE";
})(Gi || (Gi = {}));
function r_e(e) {
  e === void 0 && (e = {});
  let {
    initialEntries: t = ["/"],
    initialIndex: n,
    v5Compat: r = !1
  } = e, i;
  i = t.map((w, C) => p(w, typeof w == "string" ? null : w.state, C === 0 ? "default" : void 0));
  let o = u(n ?? i.length - 1), s = Gi.Pop, c = null;
  function u(w) {
    return Math.min(Math.max(w, 0), i.length - 1);
  }
  function f() {
    return i[o];
  }
  function p(w, C, x) {
    C === void 0 && (C = null);
    let A = bD(i ? f().pathname : "/", w, C, x);
    return so(A.pathname.charAt(0) === "/", "relative pathnames are not supported in memory history: " + JSON.stringify(w)), A;
  }
  function y(w) {
    return typeof w == "string" ? w : ty(w);
  }
  return {
    get index() {
      return o;
    },
    get action() {
      return s;
    },
    get location() {
      return f();
    },
    createHref: y,
    createURL(w) {
      return new URL(y(w), "http://localhost");
    },
    encodeLocation(w) {
      let C = typeof w == "string" ? Ku(w) : w;
      return {
        pathname: C.pathname || "",
        search: C.search || "",
        hash: C.hash || ""
      };
    },
    push(w, C) {
      s = Gi.Push;
      let x = p(w, C);
      o += 1, i.splice(o, i.length, x), r && c && c({
        action: s,
        location: x,
        delta: 1
      });
    },
    replace(w, C) {
      s = Gi.Replace;
      let x = p(w, C);
      i[o] = x, r && c && c({
        action: s,
        location: x,
        delta: 0
      });
    },
    go(w) {
      s = Gi.Pop;
      let C = u(o + w), x = i[C];
      o = C, c && c({
        action: s,
        location: x,
        delta: w
      });
    },
    listen(w) {
      return c = w, () => {
        c = null;
      };
    }
  };
}
function $t(e, t) {
  if (e === !1 || e === null || typeof e > "u")
    throw new Error(t);
}
function so(e, t) {
  if (!e)
    try {
      throw new Error(t);
    } catch {
    }
}
function i_e() {
  return Math.random().toString(36).substr(2, 8);
}
function bD(e, t, n, r) {
  return n === void 0 && (n = null), Pi({
    pathname: typeof e == "string" ? e : e.pathname,
    search: "",
    hash: ""
  }, typeof t == "string" ? Ku(t) : t, {
    state: n,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: t && t.key || r || i_e()
  });
}
function ty(e) {
  let {
    pathname: t = "/",
    search: n = "",
    hash: r = ""
  } = e;
  return n && n !== "?" && (t += n.charAt(0) === "?" ? n : "?" + n), r && r !== "#" && (t += r.charAt(0) === "#" ? r : "#" + r), t;
}
function Ku(e) {
  let t = {};
  if (e) {
    let n = e.indexOf("#");
    n >= 0 && (t.hash = e.substr(n), e = e.substr(0, n));
    let r = e.indexOf("?");
    r >= 0 && (t.search = e.substr(r), e = e.substr(0, r)), e && (t.pathname = e);
  }
  return t;
}
var $r;
(function(e) {
  e.data = "data", e.deferred = "deferred", e.redirect = "redirect", e.error = "error";
})($r || ($r = {}));
const o_e = /* @__PURE__ */ new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
function a_e(e) {
  return e.index === !0;
}
function wC(e, t, n, r) {
  return n === void 0 && (n = []), r === void 0 && (r = {}), e.map((i, o) => {
    let s = [...n, String(o)], c = typeof i.id == "string" ? i.id : s.join("-");
    if ($t(i.index !== !0 || !i.children, "Cannot specify children on an index route"), $t(!r[c], 'Found a route id collision on id "' + c + `".  Route id's must be globally unique within Data Router usages`), a_e(i)) {
      let u = Pi({}, i, t(i), {
        id: c
      });
      return r[c] = u, u;
    } else {
      let u = Pi({}, i, t(i), {
        id: c,
        children: void 0
      });
      return r[c] = u, i.children && (u.children = wC(i.children, t, s, r)), u;
    }
  });
}
function Em(e, t, n) {
  return n === void 0 && (n = "/"), y4(e, t, n, !1);
}
function y4(e, t, n, r) {
  let i = typeof t == "string" ? Ku(t) : t, o = Vc(i.pathname || "/", n);
  if (o == null)
    return null;
  let s = cQ(e);
  l_e(s);
  let c = null;
  for (let u = 0; c == null && u < s.length; ++u) {
    let f = dQ(o);
    c = v_e(s[u], f, r);
  }
  return c;
}
function s_e(e, t) {
  let {
    route: n,
    pathname: r,
    params: i
  } = e;
  return {
    id: n.id,
    pathname: r,
    params: i,
    data: t[n.id],
    handle: n.handle
  };
}
function cQ(e, t, n, r) {
  t === void 0 && (t = []), n === void 0 && (n = []), r === void 0 && (r = "");
  let i = (o, s, c) => {
    let u = {
      relativePath: c === void 0 ? o.path || "" : c,
      caseSensitive: o.caseSensitive === !0,
      childrenIndex: s,
      route: o
    };
    u.relativePath.startsWith("/") && ($t(u.relativePath.startsWith(r), 'Absolute route path "' + u.relativePath + '" nested under path ' + ('"' + r + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), u.relativePath = u.relativePath.slice(r.length));
    let f = ju([r, u.relativePath]), p = n.concat(u);
    o.children && o.children.length > 0 && ($t(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      o.index !== !0,
      "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + f + '".')
    ), cQ(o.children, t, p, f)), !(o.path == null && !o.index) && t.push({
      path: f,
      score: m_e(f, o.index),
      routesMeta: p
    });
  };
  return e.forEach((o, s) => {
    var c;
    if (o.path === "" || !((c = o.path) != null && c.includes("?")))
      i(o, s);
    else
      for (let u of uQ(o.path))
        i(o, s, u);
  }), t;
}
function uQ(e) {
  let t = e.split("/");
  if (t.length === 0) return [];
  let [n, ...r] = t, i = n.endsWith("?"), o = n.replace(/\?$/, "");
  if (r.length === 0)
    return i ? [o, ""] : [o];
  let s = uQ(r.join("/")), c = [];
  return c.push(...s.map((u) => u === "" ? o : [o, u].join("/"))), i && c.push(...s), c.map((u) => e.startsWith("/") && u === "" ? "/" : u);
}
function l_e(e) {
  e.sort((t, n) => t.score !== n.score ? n.score - t.score : y_e(t.routesMeta.map((r) => r.childrenIndex), n.routesMeta.map((r) => r.childrenIndex)));
}
const c_e = /^:[\w-]+$/, u_e = 3, d_e = 2, f_e = 1, h_e = 10, p_e = -2, w9 = (e) => e === "*";
function m_e(e, t) {
  let n = e.split("/"), r = n.length;
  return n.some(w9) && (r += p_e), t && (r += d_e), n.filter((i) => !w9(i)).reduce((i, o) => i + (c_e.test(o) ? u_e : o === "" ? f_e : h_e), r);
}
function y_e(e, t) {
  return e.length === t.length && e.slice(0, -1).every((r, i) => r === t[i]) ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    e[e.length - 1] - t[t.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function v_e(e, t, n) {
  n === void 0 && (n = !1);
  let {
    routesMeta: r
  } = e, i = {}, o = "/", s = [];
  for (let c = 0; c < r.length; ++c) {
    let u = r[c], f = c === r.length - 1, p = o === "/" ? t : t.slice(o.length) || "/", y = CC({
      path: u.relativePath,
      caseSensitive: u.caseSensitive,
      end: f
    }, p), v = u.route;
    if (!y && f && n && !r[r.length - 1].route.index && (y = CC({
      path: u.relativePath,
      caseSensitive: u.caseSensitive,
      end: !1
    }, p)), !y)
      return null;
    Object.assign(i, y.params), s.push({
      // TODO: Can this as be avoided?
      params: i,
      pathname: ju([o, y.pathname]),
      pathnameBase: C_e(ju([o, y.pathnameBase])),
      route: v
    }), y.pathnameBase !== "/" && (o = ju([o, y.pathnameBase]));
  }
  return s;
}
function CC(e, t) {
  typeof e == "string" && (e = {
    path: e,
    caseSensitive: !1,
    end: !0
  });
  let [n, r] = g_e(e.path, e.caseSensitive, e.end), i = t.match(n);
  if (!i) return null;
  let o = i[0], s = o.replace(/(.)\/+$/, "$1"), c = i.slice(1);
  return {
    params: r.reduce((f, p, y) => {
      let {
        paramName: v,
        isOptional: w
      } = p;
      if (v === "*") {
        let x = c[y] || "";
        s = o.slice(0, o.length - x.length).replace(/(.)\/+$/, "$1");
      }
      const C = c[y];
      return w && !C ? f[v] = void 0 : f[v] = (C || "").replace(/%2F/g, "/"), f;
    }, {}),
    pathname: o,
    pathnameBase: s,
    pattern: e
  };
}
function g_e(e, t, n) {
  t === void 0 && (t = !1), n === void 0 && (n = !0), so(e === "*" || !e.endsWith("*") || e.endsWith("/*"), 'Route path "' + e + '" will be treated as if it were ' + ('"' + e.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + e.replace(/\*$/, "/*") + '".'));
  let r = [], i = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (s, c, u) => (r.push({
    paramName: c,
    isOptional: u != null
  }), u ? "/?([^\\/]+)?" : "/([^\\/]+)"));
  return e.endsWith("*") ? (r.push({
    paramName: "*"
  }), i += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : e !== "" && e !== "/" && (i += "(?:(?=\\/|$))"), [new RegExp(i, t ? void 0 : "i"), r];
}
function dQ(e) {
  try {
    return e.split("/").map((t) => decodeURIComponent(t).replace(/\//g, "%2F")).join("/");
  } catch (t) {
    return so(!1, 'The URL path "' + e + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + t + ").")), e;
  }
}
function Vc(e, t) {
  if (t === "/") return e;
  if (!e.toLowerCase().startsWith(t.toLowerCase()))
    return null;
  let n = t.endsWith("/") ? t.length - 1 : t.length, r = e.charAt(n);
  return r && r !== "/" ? null : e.slice(n) || "/";
}
function b_e(e, t) {
  t === void 0 && (t = "/");
  let {
    pathname: n,
    search: r = "",
    hash: i = ""
  } = typeof e == "string" ? Ku(e) : e;
  return {
    pathname: n ? n.startsWith("/") ? n : w_e(n, t) : t,
    search: x_e(r),
    hash: E_e(i)
  };
}
function w_e(e, t) {
  let n = t.replace(/\/+$/, "").split("/");
  return e.split("/").forEach((i) => {
    i === ".." ? n.length > 1 && n.pop() : i !== "." && n.push(i);
  }), n.length > 1 ? n.join("/") : "/";
}
function QO(e, t, n, r) {
  return "Cannot include a '" + e + "' character in a manually specified " + ("`to." + t + "` field [" + JSON.stringify(r) + "].  Please separate it out to the ") + ("`to." + n + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function fQ(e) {
  return e.filter((t, n) => n === 0 || t.route.path && t.route.path.length > 0);
}
function OA(e, t) {
  let n = fQ(e);
  return t ? n.map((r, i) => i === n.length - 1 ? r.pathname : r.pathnameBase) : n.map((r) => r.pathnameBase);
}
function IA(e, t, n, r) {
  r === void 0 && (r = !1);
  let i;
  typeof e == "string" ? i = Ku(e) : (i = Pi({}, e), $t(!i.pathname || !i.pathname.includes("?"), QO("?", "pathname", "search", i)), $t(!i.pathname || !i.pathname.includes("#"), QO("#", "pathname", "hash", i)), $t(!i.search || !i.search.includes("#"), QO("#", "search", "hash", i)));
  let o = e === "" || i.pathname === "", s = o ? "/" : i.pathname, c;
  if (s == null)
    c = n;
  else {
    let y = t.length - 1;
    if (!r && s.startsWith("..")) {
      let v = s.split("/");
      for (; v[0] === ".."; )
        v.shift(), y -= 1;
      i.pathname = v.join("/");
    }
    c = y >= 0 ? t[y] : "/";
  }
  let u = b_e(i, c), f = s && s !== "/" && s.endsWith("/"), p = (o || s === ".") && n.endsWith("/");
  return !u.pathname.endsWith("/") && (f || p) && (u.pathname += "/"), u;
}
const ju = (e) => e.join("/").replace(/\/\/+/g, "/"), C_e = (e) => e.replace(/\/+$/, "").replace(/^\/*/, "/"), x_e = (e) => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e, E_e = (e) => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e;
class wD {
  constructor(t, n, r, i) {
    i === void 0 && (i = !1), this.status = t, this.statusText = n || "", this.internal = i, r instanceof Error ? (this.data = r.toString(), this.error = r) : this.data = r;
  }
}
function DA(e) {
  return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data" in e;
}
const hQ = ["post", "put", "patch", "delete"], S_e = new Set(hQ), k_e = ["get", ...hQ], A_e = new Set(k_e), T_e = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]), __e = /* @__PURE__ */ new Set([307, 308]), XO = {
  state: "idle",
  location: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
}, R_e = {
  state: "idle",
  data: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
}, f1 = {
  state: "unblocked",
  proceed: void 0,
  reset: void 0,
  location: void 0
}, nN = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, O_e = (e) => ({
  hasErrorBoundary: !!e.hasErrorBoundary
}), pQ = "remix-router-transitions";
function I_e(e) {
  const t = e.window ? e.window : typeof window < "u" ? window : void 0, n = typeof t < "u" && typeof t.document < "u" && typeof t.document.createElement < "u", r = !n;
  $t(e.routes.length > 0, "You must provide a non-empty routes array to createRouter");
  let i;
  if (e.mapRouteProperties)
    i = e.mapRouteProperties;
  else if (e.detectErrorBoundary) {
    let we = e.detectErrorBoundary;
    i = (Ae) => ({
      hasErrorBoundary: we(Ae)
    });
  } else
    i = O_e;
  let o = {}, s = wC(e.routes, i, void 0, o), c, u = e.basename || "/", f = e.unstable_dataStrategy || L_e, p = e.unstable_patchRoutesOnNavigation, y = Pi({
    v7_fetcherPersist: !1,
    v7_normalizeFormMethod: !1,
    v7_partialHydration: !1,
    v7_prependBasename: !1,
    v7_relativeSplatPath: !1,
    v7_skipActionErrorRevalidation: !1
  }, e.future), v = null, w = /* @__PURE__ */ new Set(), C = 1e3, x = /* @__PURE__ */ new Set(), A = null, R = null, I = null, D = e.hydrationData != null, M = Em(s, e.history.location, u), L = null;
  if (M == null && !p) {
    let we = es(404, {
      pathname: e.history.location.pathname
    }), {
      matches: Ae,
      route: ye
    } = R9(s);
    M = Ae, L = {
      [ye.id]: we
    };
  }
  M && !e.hydrationData && ui(M, s, e.history.location.pathname).active && (M = null);
  let j;
  if (M)
    if (M.some((we) => we.route.lazy))
      j = !1;
    else if (!M.some((we) => we.route.loader))
      j = !0;
    else if (y.v7_partialHydration) {
      let we = e.hydrationData ? e.hydrationData.loaderData : null, Ae = e.hydrationData ? e.hydrationData.errors : null, ye = (re) => re.route.loader ? typeof re.route.loader == "function" && re.route.loader.hydrate === !0 ? !1 : we && we[re.route.id] !== void 0 || Ae && Ae[re.route.id] !== void 0 : !0;
      if (Ae) {
        let re = M.findIndex((_e) => Ae[_e.route.id] !== void 0);
        j = M.slice(0, re + 1).every(ye);
      } else
        j = M.every(ye);
    } else
      j = e.hydrationData != null;
  else if (j = !1, M = [], y.v7_partialHydration) {
    let we = ui(null, s, e.history.location.pathname);
    we.active && we.matches && (M = we.matches);
  }
  let F, O = {
    historyAction: e.history.action,
    location: e.history.location,
    matches: M,
    initialized: j,
    navigation: XO,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: e.hydrationData != null ? !1 : null,
    preventScrollReset: !1,
    revalidation: "idle",
    loaderData: e.hydrationData && e.hydrationData.loaderData || {},
    actionData: e.hydrationData && e.hydrationData.actionData || null,
    errors: e.hydrationData && e.hydrationData.errors || L,
    fetchers: /* @__PURE__ */ new Map(),
    blockers: /* @__PURE__ */ new Map()
  }, z = Gi.Pop, H = !1, Q, Y = !1, ee = /* @__PURE__ */ new Map(), ie = null, X = !1, Z = !1, J = [], K = /* @__PURE__ */ new Set(), oe = /* @__PURE__ */ new Map(), be = 0, ce = -1, pe = /* @__PURE__ */ new Map(), Ee = /* @__PURE__ */ new Set(), Se = /* @__PURE__ */ new Map(), Me = /* @__PURE__ */ new Map(), Fe = /* @__PURE__ */ new Set(), st = /* @__PURE__ */ new Map(), mt = /* @__PURE__ */ new Map(), yt = /* @__PURE__ */ new Map(), Ut;
  function hn() {
    if (v = e.history.listen((we) => {
      let {
        action: Ae,
        location: ye,
        delta: re
      } = we;
      if (Ut) {
        Ut(), Ut = void 0;
        return;
      }
      so(mt.size === 0 || re != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
      let _e = Qn({
        currentLocation: O.location,
        nextLocation: ye,
        historyAction: Ae
      });
      if (_e && re != null) {
        let Pe = new Promise((Qe) => {
          Ut = Qe;
        });
        e.history.go(re * -1), St(_e, {
          state: "blocked",
          location: ye,
          proceed() {
            St(_e, {
              state: "proceeding",
              proceed: void 0,
              reset: void 0,
              location: ye
            }), Pe.then(() => e.history.go(re));
          },
          reset() {
            let Qe = new Map(O.blockers);
            Qe.set(_e, f1), xt({
              blockers: Qe
            });
          }
        });
        return;
      }
      return tr(Ae, ye);
    }), n) {
      J_e(t, ee);
      let we = () => Z_e(t, ee);
      t.addEventListener("pagehide", we), ie = () => t.removeEventListener("pagehide", we);
    }
    return O.initialized || tr(Gi.Pop, O.location, {
      initialHydration: !0
    }), F;
  }
  function wn() {
    v && v(), ie && ie(), w.clear(), Q && Q.abort(), O.fetchers.forEach((we, Ae) => le(Ae)), O.blockers.forEach((we, Ae) => xn(Ae));
  }
  function Ot(we) {
    return w.add(we), () => w.delete(we);
  }
  function xt(we, Ae) {
    Ae === void 0 && (Ae = {}), O = Pi({}, O, we);
    let ye = [], re = [];
    y.v7_fetcherPersist && O.fetchers.forEach((_e, Pe) => {
      _e.state === "idle" && (Fe.has(Pe) ? re.push(Pe) : ye.push(Pe));
    }), [...w].forEach((_e) => _e(O, {
      deletedFetchers: re,
      unstable_viewTransitionOpts: Ae.viewTransitionOpts,
      unstable_flushSync: Ae.flushSync === !0
    })), y.v7_fetcherPersist && (ye.forEach((_e) => O.fetchers.delete(_e)), re.forEach((_e) => le(_e)));
  }
  function zt(we, Ae, ye) {
    var re, _e;
    let {
      flushSync: Pe
    } = ye === void 0 ? {} : ye, Qe = O.actionData != null && O.navigation.formMethod != null && Bc(O.navigation.formMethod) && O.navigation.state === "loading" && ((re = we.state) == null ? void 0 : re._isRedirect) !== !0, Ke;
    Ae.actionData ? Object.keys(Ae.actionData).length > 0 ? Ke = Ae.actionData : Ke = null : Qe ? Ke = O.actionData : Ke = null;
    let lt = Ae.loaderData ? T9(O.loaderData, Ae.loaderData, Ae.matches || [], Ae.errors) : O.loaderData, tt = O.blockers;
    tt.size > 0 && (tt = new Map(tt), tt.forEach((Qt, on) => tt.set(on, f1)));
    let ot = H === !0 || O.navigation.formMethod != null && Bc(O.navigation.formMethod) && ((_e = we.state) == null ? void 0 : _e._isRedirect) !== !0;
    c && (s = c, c = void 0), X || z === Gi.Pop || (z === Gi.Push ? e.history.push(we, we.state) : z === Gi.Replace && e.history.replace(we, we.state));
    let cn;
    if (z === Gi.Pop) {
      let Qt = ee.get(O.location.pathname);
      Qt && Qt.has(we.pathname) ? cn = {
        currentLocation: O.location,
        nextLocation: we
      } : ee.has(we.pathname) && (cn = {
        currentLocation: we,
        nextLocation: O.location
      });
    } else if (Y) {
      let Qt = ee.get(O.location.pathname);
      Qt ? Qt.add(we.pathname) : (Qt = /* @__PURE__ */ new Set([we.pathname]), ee.set(O.location.pathname, Qt)), cn = {
        currentLocation: O.location,
        nextLocation: we
      };
    }
    xt(Pi({}, Ae, {
      actionData: Ke,
      loaderData: lt,
      historyAction: z,
      location: we,
      initialized: !0,
      navigation: XO,
      revalidation: "idle",
      restoreScrollPosition: ri(we, Ae.matches || O.matches),
      preventScrollReset: ot,
      blockers: tt
    }), {
      viewTransitionOpts: cn,
      flushSync: Pe === !0
    }), z = Gi.Pop, H = !1, Y = !1, X = !1, Z = !1, J = [];
  }
  async function Pn(we, Ae) {
    if (typeof we == "number") {
      e.history.go(we);
      return;
    }
    let ye = CD(O.location, O.matches, u, y.v7_prependBasename, we, y.v7_relativeSplatPath, Ae == null ? void 0 : Ae.fromRouteId, Ae == null ? void 0 : Ae.relative), {
      path: re,
      submission: _e,
      error: Pe
    } = C9(y.v7_normalizeFormMethod, !1, ye, Ae), Qe = O.location, Ke = bD(O.location, re, Ae && Ae.state);
    Ke = Pi({}, Ke, e.history.encodeLocation(Ke));
    let lt = Ae && Ae.replace != null ? Ae.replace : void 0, tt = Gi.Push;
    lt === !0 ? tt = Gi.Replace : lt === !1 || _e != null && Bc(_e.formMethod) && _e.formAction === O.location.pathname + O.location.search && (tt = Gi.Replace);
    let ot = Ae && "preventScrollReset" in Ae ? Ae.preventScrollReset === !0 : void 0, cn = (Ae && Ae.unstable_flushSync) === !0, Qt = Qn({
      currentLocation: Qe,
      nextLocation: Ke,
      historyAction: tt
    });
    if (Qt) {
      St(Qt, {
        state: "blocked",
        location: Ke,
        proceed() {
          St(Qt, {
            state: "proceeding",
            proceed: void 0,
            reset: void 0,
            location: Ke
          }), Pn(we, Ae);
        },
        reset() {
          let on = new Map(O.blockers);
          on.set(Qt, f1), xt({
            blockers: on
          });
        }
      });
      return;
    }
    return await tr(tt, Ke, {
      submission: _e,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: Pe,
      preventScrollReset: ot,
      replace: Ae && Ae.replace,
      enableViewTransition: Ae && Ae.unstable_viewTransition,
      flushSync: cn
    });
  }
  function Fn() {
    if (br(), xt({
      revalidation: "loading"
    }), O.navigation.state !== "submitting") {
      if (O.navigation.state === "idle") {
        tr(O.historyAction, O.location, {
          startUninterruptedRevalidation: !0
        });
        return;
      }
      tr(z || O.historyAction, O.navigation.location, {
        overrideNavigation: O.navigation,
        // Proxy through any rending view transition
        enableViewTransition: Y === !0
      });
    }
  }
  async function tr(we, Ae, ye) {
    Q && Q.abort(), Q = null, z = we, X = (ye && ye.startUninterruptedRevalidation) === !0, Mo(O.location, O.matches), H = (ye && ye.preventScrollReset) === !0, Y = (ye && ye.enableViewTransition) === !0;
    let re = c || s, _e = ye && ye.overrideNavigation, Pe = Em(re, Ae, u), Qe = (ye && ye.flushSync) === !0, Ke = ui(Pe, re, Ae.pathname);
    if (Ke.active && Ke.matches && (Pe = Ke.matches), !Pe) {
      let {
        error: pn,
        notFoundMatches: sr,
        route: tn
      } = Nr(Ae.pathname);
      zt(Ae, {
        matches: sr,
        loaderData: {},
        errors: {
          [tn.id]: pn
        }
      }, {
        flushSync: Qe
      });
      return;
    }
    if (O.initialized && !Z && $_e(O.location, Ae) && !(ye && ye.submission && Bc(ye.submission.formMethod))) {
      zt(Ae, {
        matches: Pe
      }, {
        flushSync: Qe
      });
      return;
    }
    Q = new AbortController();
    let lt = lg(e.history, Ae, Q.signal, ye && ye.submission), tt;
    if (ye && ye.pendingError)
      tt = [Ag(Pe).route.id, {
        type: $r.error,
        error: ye.pendingError
      }];
    else if (ye && ye.submission && Bc(ye.submission.formMethod)) {
      let pn = await or(lt, Ae, ye.submission, Pe, Ke.active, {
        replace: ye.replace,
        flushSync: Qe
      });
      if (pn.shortCircuited)
        return;
      if (pn.pendingActionResult) {
        let [sr, tn] = pn.pendingActionResult;
        if (sl(tn) && DA(tn.error) && tn.error.status === 404) {
          Q = null, zt(Ae, {
            matches: pn.matches,
            loaderData: {},
            errors: {
              [sr]: tn.error
            }
          });
          return;
        }
      }
      Pe = pn.matches || Pe, tt = pn.pendingActionResult, _e = JO(Ae, ye.submission), Qe = !1, Ke.active = !1, lt = lg(e.history, lt.url, lt.signal);
    }
    let {
      shortCircuited: ot,
      matches: cn,
      loaderData: Qt,
      errors: on
    } = await ar(lt, Ae, Pe, Ke.active, _e, ye && ye.submission, ye && ye.fetcherSubmission, ye && ye.replace, ye && ye.initialHydration === !0, Qe, tt);
    ot || (Q = null, zt(Ae, Pi({
      matches: cn || Pe
    }, _9(tt), {
      loaderData: Qt,
      errors: on
    })));
  }
  async function or(we, Ae, ye, re, _e, Pe) {
    Pe === void 0 && (Pe = {}), br();
    let Qe = Q_e(Ae, ye);
    if (xt({
      navigation: Qe
    }, {
      flushSync: Pe.flushSync === !0
    }), _e) {
      let tt = await ji(re, Ae.pathname, we.signal);
      if (tt.type === "aborted")
        return {
          shortCircuited: !0
        };
      if (tt.type === "error") {
        let {
          boundaryId: ot,
          error: cn
        } = bi(Ae.pathname, tt);
        return {
          matches: tt.partialMatches,
          pendingActionResult: [ot, {
            type: $r.error,
            error: cn
          }]
        };
      } else if (tt.matches)
        re = tt.matches;
      else {
        let {
          notFoundMatches: ot,
          error: cn,
          route: Qt
        } = Nr(Ae.pathname);
        return {
          matches: ot,
          pendingActionResult: [Qt.id, {
            type: $r.error,
            error: cn
          }]
        };
      }
    }
    let Ke, lt = T1(re, Ae);
    if (!lt.route.action && !lt.route.lazy)
      Ke = {
        type: $r.error,
        error: es(405, {
          method: we.method,
          pathname: Ae.pathname,
          routeId: lt.route.id
        })
      };
    else if (Ke = (await gt("action", O, we, [lt], re, null))[lt.route.id], we.signal.aborted)
      return {
        shortCircuited: !0
      };
    if (Im(Ke)) {
      let tt;
      return Pe && Pe.replace != null ? tt = Pe.replace : tt = S9(Ke.response.headers.get("Location"), new URL(we.url), u) === O.location.pathname + O.location.search, await qt(we, Ke, !0, {
        submission: ye,
        replace: tt
      }), {
        shortCircuited: !0
      };
    }
    if (Fh(Ke))
      throw es(400, {
        type: "defer-action"
      });
    if (sl(Ke)) {
      let tt = Ag(re, lt.route.id);
      return (Pe && Pe.replace) !== !0 && (z = Gi.Push), {
        matches: re,
        pendingActionResult: [tt.route.id, Ke]
      };
    }
    return {
      matches: re,
      pendingActionResult: [lt.route.id, Ke]
    };
  }
  async function ar(we, Ae, ye, re, _e, Pe, Qe, Ke, lt, tt, ot) {
    let cn = _e || JO(Ae, Pe), Qt = Pe || Qe || I9(cn), on = !X && (!y.v7_partialHydration || !lt);
    if (re) {
      if (on) {
        let Er = Cr(ot);
        xt(Pi({
          navigation: cn
        }, Er !== void 0 ? {
          actionData: Er
        } : {}), {
          flushSync: tt
        });
      }
      let Zt = await ji(ye, Ae.pathname, we.signal);
      if (Zt.type === "aborted")
        return {
          shortCircuited: !0
        };
      if (Zt.type === "error") {
        let {
          boundaryId: Er,
          error: xi
        } = bi(Ae.pathname, Zt);
        return {
          matches: Zt.partialMatches,
          loaderData: {},
          errors: {
            [Er]: xi
          }
        };
      } else if (Zt.matches)
        ye = Zt.matches;
      else {
        let {
          error: Er,
          notFoundMatches: xi,
          route: _r
        } = Nr(Ae.pathname);
        return {
          matches: xi,
          loaderData: {},
          errors: {
            [_r.id]: Er
          }
        };
      }
    }
    let pn = c || s, [sr, tn] = x9(e.history, O, ye, Qt, Ae, y.v7_partialHydration && lt === !0, y.v7_skipActionErrorRevalidation, Z, J, K, Fe, Se, Ee, pn, u, ot);
    if (Do((Zt) => !(ye && ye.some((Er) => Er.route.id === Zt)) || sr && sr.some((Er) => Er.route.id === Zt)), ce = ++be, sr.length === 0 && tn.length === 0) {
      let Zt = kt();
      return zt(Ae, Pi({
        matches: ye,
        loaderData: {},
        // Commit pending error if we're short circuiting
        errors: ot && sl(ot[1]) ? {
          [ot[0]]: ot[1].error
        } : null
      }, _9(ot), Zt ? {
        fetchers: new Map(O.fetchers)
      } : {}), {
        flushSync: tt
      }), {
        shortCircuited: !0
      };
    }
    if (on) {
      let Zt = {};
      if (!re) {
        Zt.navigation = cn;
        let Er = Cr(ot);
        Er !== void 0 && (Zt.actionData = Er);
      }
      tn.length > 0 && (Zt.fetchers = Un(tn)), xt(Zt, {
        flushSync: tt
      });
    }
    tn.forEach((Zt) => {
      oe.has(Zt.key) && Te(Zt.key), Zt.controller && oe.set(Zt.key, Zt.controller);
    });
    let Ur = () => tn.forEach((Zt) => Te(Zt.key));
    Q && Q.signal.addEventListener("abort", Ur);
    let {
      loaderResults: xr,
      fetcherResults: vn
    } = await Ht(O, ye, sr, tn, we);
    if (we.signal.aborted)
      return {
        shortCircuited: !0
      };
    Q && Q.signal.removeEventListener("abort", Ur), tn.forEach((Zt) => oe.delete(Zt.key));
    let ii = Vk(xr);
    if (ii)
      return await qt(we, ii.result, !0, {
        replace: Ke
      }), {
        shortCircuited: !0
      };
    if (ii = Vk(vn), ii)
      return Ee.add(ii.key), await qt(we, ii.result, !0, {
        replace: Ke
      }), {
        shortCircuited: !0
      };
    let {
      loaderData: qo,
      errors: Xi
    } = A9(O, ye, sr, xr, ot, tn, vn, st);
    st.forEach((Zt, Er) => {
      Zt.subscribe((xi) => {
        (xi || Zt.done) && st.delete(Er);
      });
    }), y.v7_partialHydration && lt && O.errors && Object.entries(O.errors).filter((Zt) => {
      let [Er] = Zt;
      return !sr.some((xi) => xi.route.id === Er);
    }).forEach((Zt) => {
      let [Er, xi] = Zt;
      Xi = Object.assign(Xi || {}, {
        [Er]: xi
      });
    });
    let Po = kt(), Ci = bn(ce), cs = Po || Ci || tn.length > 0;
    return Pi({
      matches: ye,
      loaderData: qo,
      errors: Xi
    }, cs ? {
      fetchers: new Map(O.fetchers)
    } : {});
  }
  function Cr(we) {
    if (we && !sl(we[1]))
      return {
        [we[0]]: we[1].data
      };
    if (O.actionData)
      return Object.keys(O.actionData).length === 0 ? null : O.actionData;
  }
  function Un(we) {
    return we.forEach((Ae) => {
      let ye = O.fetchers.get(Ae.key), re = h1(void 0, ye ? ye.data : void 0);
      O.fetchers.set(Ae.key, re);
    }), new Map(O.fetchers);
  }
  function $n(we, Ae, ye, re) {
    if (r)
      throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
    oe.has(we) && Te(we);
    let _e = (re && re.unstable_flushSync) === !0, Pe = c || s, Qe = CD(O.location, O.matches, u, y.v7_prependBasename, ye, y.v7_relativeSplatPath, Ae, re == null ? void 0 : re.relative), Ke = Em(Pe, Qe, u), lt = ui(Ke, Pe, Qe);
    if (lt.active && lt.matches && (Ke = lt.matches), !Ke) {
      N(we, Ae, es(404, {
        pathname: Qe
      }), {
        flushSync: _e
      });
      return;
    }
    let {
      path: tt,
      submission: ot,
      error: cn
    } = C9(y.v7_normalizeFormMethod, !0, Qe, re);
    if (cn) {
      N(we, Ae, cn, {
        flushSync: _e
      });
      return;
    }
    let Qt = T1(Ke, tt);
    if (H = (re && re.preventScrollReset) === !0, ot && Bc(ot.formMethod)) {
      gr(we, Ae, tt, Qt, Ke, lt.active, _e, ot);
      return;
    }
    Se.set(we, {
      routeId: Ae,
      path: tt
    }), Tt(we, Ae, tt, Qt, Ke, lt.active, _e, ot);
  }
  async function gr(we, Ae, ye, re, _e, Pe, Qe, Ke) {
    br(), Se.delete(we);
    function lt(_r) {
      if (!_r.route.action && !_r.route.lazy) {
        let Ji = es(405, {
          method: Ke.formMethod,
          pathname: ye,
          routeId: Ae
        });
        return N(we, Ae, Ji, {
          flushSync: Qe
        }), !0;
      }
      return !1;
    }
    if (!Pe && lt(re))
      return;
    let tt = O.fetchers.get(we);
    ne(we, X_e(Ke, tt), {
      flushSync: Qe
    });
    let ot = new AbortController(), cn = lg(e.history, ye, ot.signal, Ke);
    if (Pe) {
      let _r = await ji(_e, ye, cn.signal);
      if (_r.type === "aborted")
        return;
      if (_r.type === "error") {
        let {
          error: Ji
        } = bi(ye, _r);
        N(we, Ae, Ji, {
          flushSync: Qe
        });
        return;
      } else if (_r.matches) {
        if (_e = _r.matches, re = T1(_e, ye), lt(re))
          return;
      } else {
        N(we, Ae, es(404, {
          pathname: ye
        }), {
          flushSync: Qe
        });
        return;
      }
    }
    oe.set(we, ot);
    let Qt = be, pn = (await gt("action", O, cn, [re], _e, we))[re.route.id];
    if (cn.signal.aborted) {
      oe.get(we) === ot && oe.delete(we);
      return;
    }
    if (y.v7_fetcherPersist && Fe.has(we)) {
      if (Im(pn) || sl(pn)) {
        ne(we, kh(void 0));
        return;
      }
    } else {
      if (Im(pn))
        if (oe.delete(we), ce > Qt) {
          ne(we, kh(void 0));
          return;
        } else
          return Ee.add(we), ne(we, h1(Ke)), qt(cn, pn, !1, {
            fetcherSubmission: Ke
          });
      if (sl(pn)) {
        N(we, Ae, pn.error);
        return;
      }
    }
    if (Fh(pn))
      throw es(400, {
        type: "defer-action"
      });
    let sr = O.navigation.location || O.location, tn = lg(e.history, sr, ot.signal), Ur = c || s, xr = O.navigation.state !== "idle" ? Em(Ur, O.navigation.location, u) : O.matches;
    $t(xr, "Didn't find any matches after fetcher action");
    let vn = ++be;
    pe.set(we, vn);
    let ii = h1(Ke, pn.data);
    O.fetchers.set(we, ii);
    let [qo, Xi] = x9(e.history, O, xr, Ke, sr, !1, y.v7_skipActionErrorRevalidation, Z, J, K, Fe, Se, Ee, Ur, u, [re.route.id, pn]);
    Xi.filter((_r) => _r.key !== we).forEach((_r) => {
      let Ji = _r.key, Fa = O.fetchers.get(Ji), Wo = h1(void 0, Fa ? Fa.data : void 0);
      O.fetchers.set(Ji, Wo), oe.has(Ji) && Te(Ji), _r.controller && oe.set(Ji, _r.controller);
    }), xt({
      fetchers: new Map(O.fetchers)
    });
    let Po = () => Xi.forEach((_r) => Te(_r.key));
    ot.signal.addEventListener("abort", Po);
    let {
      loaderResults: Ci,
      fetcherResults: cs
    } = await Ht(O, xr, qo, Xi, tn);
    if (ot.signal.aborted)
      return;
    ot.signal.removeEventListener("abort", Po), pe.delete(we), oe.delete(we), Xi.forEach((_r) => oe.delete(_r.key));
    let Zt = Vk(Ci);
    if (Zt)
      return qt(tn, Zt.result, !1);
    if (Zt = Vk(cs), Zt)
      return Ee.add(Zt.key), qt(tn, Zt.result, !1);
    let {
      loaderData: Er,
      errors: xi
    } = A9(O, xr, qo, Ci, void 0, Xi, cs, st);
    if (O.fetchers.has(we)) {
      let _r = kh(pn.data);
      O.fetchers.set(we, _r);
    }
    bn(vn), O.navigation.state === "loading" && vn > ce ? ($t(z, "Expected pending action"), Q && Q.abort(), zt(O.navigation.location, {
      matches: xr,
      loaderData: Er,
      errors: xi,
      fetchers: new Map(O.fetchers)
    })) : (xt({
      errors: xi,
      loaderData: T9(O.loaderData, Er, xr, xi),
      fetchers: new Map(O.fetchers)
    }), Z = !1);
  }
  async function Tt(we, Ae, ye, re, _e, Pe, Qe, Ke) {
    let lt = O.fetchers.get(we);
    ne(we, h1(Ke, lt ? lt.data : void 0), {
      flushSync: Qe
    });
    let tt = new AbortController(), ot = lg(e.history, ye, tt.signal);
    if (Pe) {
      let pn = await ji(_e, ye, ot.signal);
      if (pn.type === "aborted")
        return;
      if (pn.type === "error") {
        let {
          error: sr
        } = bi(ye, pn);
        N(we, Ae, sr, {
          flushSync: Qe
        });
        return;
      } else if (pn.matches)
        _e = pn.matches, re = T1(_e, ye);
      else {
        N(we, Ae, es(404, {
          pathname: ye
        }), {
          flushSync: Qe
        });
        return;
      }
    }
    oe.set(we, tt);
    let cn = be, on = (await gt("loader", O, ot, [re], _e, we))[re.route.id];
    if (Fh(on) && (on = await rN(on, ot.signal, !0) || on), oe.get(we) === tt && oe.delete(we), !ot.signal.aborted) {
      if (Fe.has(we)) {
        ne(we, kh(void 0));
        return;
      }
      if (Im(on))
        if (ce > cn) {
          ne(we, kh(void 0));
          return;
        } else {
          Ee.add(we), await qt(ot, on, !1);
          return;
        }
      if (sl(on)) {
        N(we, Ae, on.error);
        return;
      }
      $t(!Fh(on), "Unhandled fetcher deferred data"), ne(we, kh(on.data));
    }
  }
  async function qt(we, Ae, ye, re) {
    let {
      submission: _e,
      fetcherSubmission: Pe,
      replace: Qe
    } = re === void 0 ? {} : re;
    Ae.response.headers.has("X-Remix-Revalidate") && (Z = !0);
    let Ke = Ae.response.headers.get("Location");
    $t(Ke, "Expected a Location header on the redirect Response"), Ke = S9(Ke, new URL(we.url), u);
    let lt = bD(O.location, Ke, {
      _isRedirect: !0
    });
    if (n) {
      let pn = !1;
      if (Ae.response.headers.has("X-Remix-Reload-Document"))
        pn = !0;
      else if (nN.test(Ke)) {
        const sr = e.history.createURL(Ke);
        pn = // Hard reload if it's an absolute URL to a new origin
        sr.origin !== t.location.origin || // Hard reload if it's an absolute URL that does not match our basename
        Vc(sr.pathname, u) == null;
      }
      if (pn) {
        Qe ? t.location.replace(Ke) : t.location.assign(Ke);
        return;
      }
    }
    Q = null;
    let tt = Qe === !0 || Ae.response.headers.has("X-Remix-Replace") ? Gi.Replace : Gi.Push, {
      formMethod: ot,
      formAction: cn,
      formEncType: Qt
    } = O.navigation;
    !_e && !Pe && ot && cn && Qt && (_e = I9(O.navigation));
    let on = _e || Pe;
    if (__e.has(Ae.response.status) && on && Bc(on.formMethod))
      await tr(tt, lt, {
        submission: Pi({}, on, {
          formAction: Ke
        }),
        // Preserve these flags across redirects
        preventScrollReset: H,
        enableViewTransition: ye ? Y : void 0
      });
    else {
      let pn = JO(lt, _e);
      await tr(tt, lt, {
        overrideNavigation: pn,
        // Send fetcher submissions through for shouldRevalidate
        fetcherSubmission: Pe,
        // Preserve these flags across redirects
        preventScrollReset: H,
        enableViewTransition: ye ? Y : void 0
      });
    }
  }
  async function gt(we, Ae, ye, re, _e, Pe) {
    let Qe, Ke = {};
    try {
      Qe = await j_e(f, we, Ae, ye, re, _e, Pe, o, i);
    } catch (lt) {
      return re.forEach((tt) => {
        Ke[tt.route.id] = {
          type: $r.error,
          error: lt
        };
      }), Ke;
    }
    for (let [lt, tt] of Object.entries(Qe))
      if (q_e(tt)) {
        let ot = tt.result;
        Ke[lt] = {
          type: $r.redirect,
          response: z_e(ot, ye, lt, _e, u, y.v7_relativeSplatPath)
        };
      } else
        Ke[lt] = await U_e(tt);
    return Ke;
  }
  async function Ht(we, Ae, ye, re, _e) {
    let Pe = we.matches, Qe = gt("loader", we, _e, ye, Ae, null), Ke = Promise.all(re.map(async (ot) => {
      if (ot.matches && ot.match && ot.controller) {
        let Qt = (await gt("loader", we, lg(e.history, ot.path, ot.controller.signal), [ot.match], ot.matches, ot.key))[ot.match.route.id];
        return {
          [ot.key]: Qt
        };
      } else
        return Promise.resolve({
          [ot.key]: {
            type: $r.error,
            error: es(404, {
              pathname: ot.path
            })
          }
        });
    })), lt = await Qe, tt = (await Ke).reduce((ot, cn) => Object.assign(ot, cn), {});
    return await Promise.all([K_e(Ae, lt, _e.signal, Pe, we.loaderData), Y_e(Ae, tt, re)]), {
      loaderResults: lt,
      fetcherResults: tt
    };
  }
  function br() {
    Z = !0, J.push(...Do()), Se.forEach((we, Ae) => {
      oe.has(Ae) && (K.add(Ae), Te(Ae));
    });
  }
  function ne(we, Ae, ye) {
    ye === void 0 && (ye = {}), O.fetchers.set(we, Ae), xt({
      fetchers: new Map(O.fetchers)
    }, {
      flushSync: (ye && ye.flushSync) === !0
    });
  }
  function N(we, Ae, ye, re) {
    re === void 0 && (re = {});
    let _e = Ag(O.matches, Ae);
    le(we), xt({
      errors: {
        [_e.route.id]: ye
      },
      fetchers: new Map(O.fetchers)
    }, {
      flushSync: (re && re.flushSync) === !0
    });
  }
  function U(we) {
    return y.v7_fetcherPersist && (Me.set(we, (Me.get(we) || 0) + 1), Fe.has(we) && Fe.delete(we)), O.fetchers.get(we) || R_e;
  }
  function le(we) {
    let Ae = O.fetchers.get(we);
    oe.has(we) && !(Ae && Ae.state === "loading" && pe.has(we)) && Te(we), Se.delete(we), pe.delete(we), Ee.delete(we), Fe.delete(we), K.delete(we), O.fetchers.delete(we);
  }
  function Ce(we) {
    if (y.v7_fetcherPersist) {
      let Ae = (Me.get(we) || 0) - 1;
      Ae <= 0 ? (Me.delete(we), Fe.add(we)) : Me.set(we, Ae);
    } else
      le(we);
    xt({
      fetchers: new Map(O.fetchers)
    });
  }
  function Te(we) {
    let Ae = oe.get(we);
    $t(Ae, "Expected fetch controller: " + we), Ae.abort(), oe.delete(we);
  }
  function Ve(we) {
    for (let Ae of we) {
      let ye = U(Ae), re = kh(ye.data);
      O.fetchers.set(Ae, re);
    }
  }
  function kt() {
    let we = [], Ae = !1;
    for (let ye of Ee) {
      let re = O.fetchers.get(ye);
      $t(re, "Expected fetcher: " + ye), re.state === "loading" && (Ee.delete(ye), we.push(ye), Ae = !0);
    }
    return Ve(we), Ae;
  }
  function bn(we) {
    let Ae = [];
    for (let [ye, re] of pe)
      if (re < we) {
        let _e = O.fetchers.get(ye);
        $t(_e, "Expected fetcher: " + ye), _e.state === "loading" && (Te(ye), pe.delete(ye), Ae.push(ye));
      }
    return Ve(Ae), Ae.length > 0;
  }
  function Wt(we, Ae) {
    let ye = O.blockers.get(we) || f1;
    return mt.get(we) !== Ae && mt.set(we, Ae), ye;
  }
  function xn(we) {
    O.blockers.delete(we), mt.delete(we);
  }
  function St(we, Ae) {
    let ye = O.blockers.get(we) || f1;
    $t(ye.state === "unblocked" && Ae.state === "blocked" || ye.state === "blocked" && Ae.state === "blocked" || ye.state === "blocked" && Ae.state === "proceeding" || ye.state === "blocked" && Ae.state === "unblocked" || ye.state === "proceeding" && Ae.state === "unblocked", "Invalid blocker state transition: " + ye.state + " -> " + Ae.state);
    let re = new Map(O.blockers);
    re.set(we, Ae), xt({
      blockers: re
    });
  }
  function Qn(we) {
    let {
      currentLocation: Ae,
      nextLocation: ye,
      historyAction: re
    } = we;
    if (mt.size === 0)
      return;
    mt.size > 1 && so(!1, "A router only supports one blocker at a time");
    let _e = Array.from(mt.entries()), [Pe, Qe] = _e[_e.length - 1], Ke = O.blockers.get(Pe);
    if (!(Ke && Ke.state === "proceeding") && Qe({
      currentLocation: Ae,
      nextLocation: ye,
      historyAction: re
    }))
      return Pe;
  }
  function Nr(we) {
    let Ae = es(404, {
      pathname: we
    }), ye = c || s, {
      matches: re,
      route: _e
    } = R9(ye);
    return Do(), {
      notFoundMatches: re,
      route: _e,
      error: Ae
    };
  }
  function bi(we, Ae) {
    return {
      boundaryId: Ag(Ae.partialMatches).route.id,
      error: es(400, {
        type: "route-discovery",
        pathname: we,
        message: Ae.error != null && "message" in Ae.error ? Ae.error : String(Ae.error)
      })
    };
  }
  function Do(we) {
    let Ae = [];
    return st.forEach((ye, re) => {
      (!we || we(re)) && (ye.cancel(), Ae.push(re), st.delete(re));
    }), Ae;
  }
  function la(we, Ae, ye) {
    if (A = we, I = Ae, R = ye || null, !D && O.navigation === XO) {
      D = !0;
      let re = ri(O.location, O.matches);
      re != null && xt({
        restoreScrollPosition: re
      });
    }
    return () => {
      A = null, I = null, R = null;
    };
  }
  function ja(we, Ae) {
    return R && R(we, Ae.map((re) => s_e(re, O.loaderData))) || we.key;
  }
  function Mo(we, Ae) {
    if (A && I) {
      let ye = ja(we, Ae);
      A[ye] = I();
    }
  }
  function ri(we, Ae) {
    if (A) {
      let ye = ja(we, Ae), re = A[ye];
      if (typeof re == "number")
        return re;
    }
    return null;
  }
  function ui(we, Ae, ye) {
    if (p) {
      if (x.has(ye))
        return {
          active: !1,
          matches: we
        };
      if (we) {
        if (Object.keys(we[0].params).length > 0)
          return {
            active: !0,
            matches: y4(Ae, ye, u, !0)
          };
      } else
        return {
          active: !0,
          matches: y4(Ae, ye, u, !0) || []
        };
    }
    return {
      active: !1,
      matches: null
    };
  }
  async function ji(we, Ae, ye) {
    let re = we;
    for (; ; ) {
      let _e = c == null, Pe = c || s;
      try {
        await N_e(p, Ae, re, Pe, o, i, yt, ye);
      } catch (lt) {
        return {
          type: "error",
          error: lt,
          partialMatches: re
        };
      } finally {
        _e && (s = [...s]);
      }
      if (ye.aborted)
        return {
          type: "aborted"
        };
      let Qe = Em(Pe, Ae, u);
      if (Qe)
        return _i(Ae, x), {
          type: "success",
          matches: Qe
        };
      let Ke = y4(Pe, Ae, u, !0);
      if (!Ke || re.length === Ke.length && re.every((lt, tt) => lt.route.id === Ke[tt].route.id))
        return _i(Ae, x), {
          type: "success",
          matches: null
        };
      re = Ke;
    }
  }
  function _i(we, Ae) {
    if (Ae.size >= C) {
      let ye = Ae.values().next().value;
      Ae.delete(ye);
    }
    Ae.add(we);
  }
  function ho(we) {
    o = {}, c = wC(we, i, void 0, o);
  }
  function wi(we, Ae) {
    let ye = c == null;
    yQ(we, Ae, c || s, o, i), ye && (s = [...s], xt({}));
  }
  return F = {
    get basename() {
      return u;
    },
    get future() {
      return y;
    },
    get state() {
      return O;
    },
    get routes() {
      return s;
    },
    get window() {
      return t;
    },
    initialize: hn,
    subscribe: Ot,
    enableScrollRestoration: la,
    navigate: Pn,
    fetch: $n,
    revalidate: Fn,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: (we) => e.history.createHref(we),
    encodeLocation: (we) => e.history.encodeLocation(we),
    getFetcher: U,
    deleteFetcher: Ce,
    dispose: wn,
    getBlocker: Wt,
    deleteBlocker: xn,
    patchRoutes: wi,
    _internalFetchControllers: oe,
    _internalActiveDeferreds: st,
    // TODO: Remove setRoutes, it's temporary to avoid dealing with
    // updating the tree while validating the update algorithm.
    _internalSetRoutes: ho
  }, F;
}
function D_e(e) {
  return e != null && ("formData" in e && e.formData != null || "body" in e && e.body !== void 0);
}
function CD(e, t, n, r, i, o, s, c) {
  let u, f;
  if (s) {
    u = [];
    for (let y of t)
      if (u.push(y), y.route.id === s) {
        f = y;
        break;
      }
  } else
    u = t, f = t[t.length - 1];
  let p = IA(i || ".", OA(u, o), Vc(e.pathname, n) || e.pathname, c === "path");
  return i == null && (p.search = e.search, p.hash = e.hash), (i == null || i === "" || i === ".") && f && f.route.index && !iN(p.search) && (p.search = p.search ? p.search.replace(/^\?/, "?index&") : "?index"), r && n !== "/" && (p.pathname = p.pathname === "/" ? n : ju([n, p.pathname])), ty(p);
}
function C9(e, t, n, r) {
  if (!r || !D_e(r))
    return {
      path: n
    };
  if (r.formMethod && !G_e(r.formMethod))
    return {
      path: n,
      error: es(405, {
        method: r.formMethod
      })
    };
  let i = () => ({
    path: n,
    error: es(400, {
      type: "invalid-body"
    })
  }), o = r.formMethod || "get", s = e ? o.toUpperCase() : o.toLowerCase(), c = vQ(n);
  if (r.body !== void 0) {
    if (r.formEncType === "text/plain") {
      if (!Bc(s))
        return i();
      let v = typeof r.body == "string" ? r.body : r.body instanceof FormData || r.body instanceof URLSearchParams ? (
        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
        Array.from(r.body.entries()).reduce((w, C) => {
          let [x, A] = C;
          return "" + w + x + "=" + A + `
`;
        }, "")
      ) : String(r.body);
      return {
        path: n,
        submission: {
          formMethod: s,
          formAction: c,
          formEncType: r.formEncType,
          formData: void 0,
          json: void 0,
          text: v
        }
      };
    } else if (r.formEncType === "application/json") {
      if (!Bc(s))
        return i();
      try {
        let v = typeof r.body == "string" ? JSON.parse(r.body) : r.body;
        return {
          path: n,
          submission: {
            formMethod: s,
            formAction: c,
            formEncType: r.formEncType,
            formData: void 0,
            json: v,
            text: void 0
          }
        };
      } catch {
        return i();
      }
    }
  }
  $t(typeof FormData == "function", "FormData is not available in this environment");
  let u, f;
  if (r.formData)
    u = xD(r.formData), f = r.formData;
  else if (r.body instanceof FormData)
    u = xD(r.body), f = r.body;
  else if (r.body instanceof URLSearchParams)
    u = r.body, f = k9(u);
  else if (r.body == null)
    u = new URLSearchParams(), f = new FormData();
  else
    try {
      u = new URLSearchParams(r.body), f = k9(u);
    } catch {
      return i();
    }
  let p = {
    formMethod: s,
    formAction: c,
    formEncType: r && r.formEncType || "application/x-www-form-urlencoded",
    formData: f,
    json: void 0,
    text: void 0
  };
  if (Bc(p.formMethod))
    return {
      path: n,
      submission: p
    };
  let y = Ku(n);
  return t && y.search && iN(y.search) && u.append("index", ""), y.search = "?" + u, {
    path: ty(y),
    submission: p
  };
}
function M_e(e, t) {
  let n = e;
  if (t) {
    let r = e.findIndex((i) => i.route.id === t);
    r >= 0 && (n = e.slice(0, r));
  }
  return n;
}
function x9(e, t, n, r, i, o, s, c, u, f, p, y, v, w, C, x) {
  let A = x ? sl(x[1]) ? x[1].error : x[1].data : void 0, R = e.createURL(t.location), I = e.createURL(i), D = x && sl(x[1]) ? x[0] : void 0, M = D ? M_e(n, D) : n, L = x ? x[1].statusCode : void 0, j = s && L && L >= 400, F = M.filter((z, H) => {
    let {
      route: Q
    } = z;
    if (Q.lazy)
      return !0;
    if (Q.loader == null)
      return !1;
    if (o)
      return typeof Q.loader != "function" || Q.loader.hydrate ? !0 : t.loaderData[Q.id] === void 0 && // Don't re-run if the loader ran and threw an error
      (!t.errors || t.errors[Q.id] === void 0);
    if (P_e(t.loaderData, t.matches[H], z) || u.some((ie) => ie === z.route.id))
      return !0;
    let Y = t.matches[H], ee = z;
    return E9(z, Pi({
      currentUrl: R,
      currentParams: Y.params,
      nextUrl: I,
      nextParams: ee.params
    }, r, {
      actionResult: A,
      actionStatus: L,
      defaultShouldRevalidate: j ? !1 : (
        // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
        c || R.pathname + R.search === I.pathname + I.search || // Search params affect all loaders
        R.search !== I.search || mQ(Y, ee)
      )
    }));
  }), O = [];
  return y.forEach((z, H) => {
    if (o || !n.some((X) => X.route.id === z.routeId) || p.has(H))
      return;
    let Q = Em(w, z.path, C);
    if (!Q) {
      O.push({
        key: H,
        routeId: z.routeId,
        path: z.path,
        matches: null,
        match: null,
        controller: null
      });
      return;
    }
    let Y = t.fetchers.get(H), ee = T1(Q, z.path), ie = !1;
    v.has(H) ? ie = !1 : f.has(H) ? (f.delete(H), ie = !0) : Y && Y.state !== "idle" && Y.data === void 0 ? ie = c : ie = E9(ee, Pi({
      currentUrl: R,
      currentParams: t.matches[t.matches.length - 1].params,
      nextUrl: I,
      nextParams: n[n.length - 1].params
    }, r, {
      actionResult: A,
      actionStatus: L,
      defaultShouldRevalidate: j ? !1 : c
    })), ie && O.push({
      key: H,
      routeId: z.routeId,
      path: z.path,
      matches: Q,
      match: ee,
      controller: new AbortController()
    });
  }), [F, O];
}
function P_e(e, t, n) {
  let r = (
    // [a] -> [a, b]
    !t || // [a, b] -> [a, c]
    n.route.id !== t.route.id
  ), i = e[n.route.id] === void 0;
  return r || i;
}
function mQ(e, t) {
  let n = e.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    e.pathname !== t.pathname || // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    n != null && n.endsWith("*") && e.params["*"] !== t.params["*"]
  );
}
function E9(e, t) {
  if (e.route.shouldRevalidate) {
    let n = e.route.shouldRevalidate(t);
    if (typeof n == "boolean")
      return n;
  }
  return t.defaultShouldRevalidate;
}
async function N_e(e, t, n, r, i, o, s, c) {
  let u = [t, ...n.map((f) => f.route.id)].join("-");
  try {
    let f = s.get(u);
    f || (f = e({
      path: t,
      matches: n,
      patch: (p, y) => {
        c.aborted || yQ(p, y, r, i, o);
      }
    }), s.set(u, f)), f && H_e(f) && await f;
  } finally {
    s.delete(u);
  }
}
function yQ(e, t, n, r, i) {
  if (e) {
    var o;
    let s = r[e];
    $t(s, "No route found to patch children into: routeId = " + e);
    let c = wC(t, i, [e, "patch", String(((o = s.children) == null ? void 0 : o.length) || "0")], r);
    s.children ? s.children.push(...c) : s.children = c;
  } else {
    let s = wC(t, i, ["patch", String(n.length || "0")], r);
    n.push(...s);
  }
}
async function B_e(e, t, n) {
  if (!e.lazy)
    return;
  let r = await e.lazy();
  if (!e.lazy)
    return;
  let i = n[e.id];
  $t(i, "No route found in manifest");
  let o = {};
  for (let s in r) {
    let u = i[s] !== void 0 && // This property isn't static since it should always be updated based
    // on the route updates
    s !== "hasErrorBoundary";
    so(!u, 'Route "' + i.id + '" has a static property "' + s + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + s + '" will be ignored.')), !u && !o_e.has(s) && (o[s] = r[s]);
  }
  Object.assign(i, o), Object.assign(i, Pi({}, t(i), {
    lazy: void 0
  }));
}
async function L_e(e) {
  let {
    matches: t
  } = e, n = t.filter((i) => i.shouldLoad);
  return (await Promise.all(n.map((i) => i.resolve()))).reduce((i, o, s) => Object.assign(i, {
    [n[s].route.id]: o
  }), {});
}
async function j_e(e, t, n, r, i, o, s, c, u, f) {
  let p = o.map((w) => w.route.lazy ? B_e(w.route, u, c) : void 0), y = o.map((w, C) => {
    let x = p[C], A = i.some((I) => I.route.id === w.route.id);
    return Pi({}, w, {
      shouldLoad: A,
      resolve: async (I) => (I && r.method === "GET" && (w.route.lazy || w.route.loader) && (A = !0), A ? F_e(t, r, w, x, I, f) : Promise.resolve({
        type: $r.data,
        result: void 0
      }))
    });
  }), v = await e({
    matches: y,
    request: r,
    params: o[0].params,
    fetcherKey: s,
    context: f
  });
  try {
    await Promise.all(p);
  } catch {
  }
  return v;
}
async function F_e(e, t, n, r, i, o) {
  let s, c, u = (f) => {
    let p, y = new Promise((C, x) => p = x);
    c = () => p(), t.signal.addEventListener("abort", c);
    let v = (C) => typeof f != "function" ? Promise.reject(new Error("You cannot call the handler for a route which defines a boolean " + ('"' + e + '" [routeId: ' + n.route.id + "]"))) : f({
      request: t,
      params: n.params,
      context: o
    }, ...C !== void 0 ? [C] : []), w = (async () => {
      try {
        return {
          type: "data",
          result: await (i ? i((x) => v(x)) : v())
        };
      } catch (C) {
        return {
          type: "error",
          result: C
        };
      }
    })();
    return Promise.race([w, y]);
  };
  try {
    let f = n.route[e];
    if (r)
      if (f) {
        let p, [y] = await Promise.all([
          // If the handler throws, don't let it immediately bubble out,
          // since we need to let the lazy() execution finish so we know if this
          // route has a boundary that can handle the error
          u(f).catch((v) => {
            p = v;
          }),
          r
        ]);
        if (p !== void 0)
          throw p;
        s = y;
      } else if (await r, f = n.route[e], f)
        s = await u(f);
      else if (e === "action") {
        let p = new URL(t.url), y = p.pathname + p.search;
        throw es(405, {
          method: t.method,
          pathname: y,
          routeId: n.route.id
        });
      } else
        return {
          type: $r.data,
          result: void 0
        };
    else if (f)
      s = await u(f);
    else {
      let p = new URL(t.url), y = p.pathname + p.search;
      throw es(404, {
        pathname: y
      });
    }
    $t(s.result !== void 0, "You defined " + (e === "action" ? "an action" : "a loader") + " for route " + ('"' + n.route.id + "\" but didn't return anything from your `" + e + "` ") + "function. Please return a value or `null`.");
  } catch (f) {
    return {
      type: $r.error,
      result: f
    };
  } finally {
    c && t.signal.removeEventListener("abort", c);
  }
  return s;
}
async function U_e(e) {
  let {
    result: t,
    type: n
  } = e;
  if (gQ(t)) {
    let f;
    try {
      let p = t.headers.get("Content-Type");
      p && /\bapplication\/json\b/.test(p) ? t.body == null ? f = null : f = await t.json() : f = await t.text();
    } catch (p) {
      return {
        type: $r.error,
        error: p
      };
    }
    return n === $r.error ? {
      type: $r.error,
      error: new wD(t.status, t.statusText, f),
      statusCode: t.status,
      headers: t.headers
    } : {
      type: $r.data,
      data: f,
      statusCode: t.status,
      headers: t.headers
    };
  }
  if (n === $r.error) {
    if (O9(t)) {
      var r;
      if (t.data instanceof Error) {
        var i;
        return {
          type: $r.error,
          error: t.data,
          statusCode: (i = t.init) == null ? void 0 : i.status
        };
      }
      t = new wD(((r = t.init) == null ? void 0 : r.status) || 500, void 0, t.data);
    }
    return {
      type: $r.error,
      error: t,
      statusCode: DA(t) ? t.status : void 0
    };
  }
  if (W_e(t)) {
    var o, s;
    return {
      type: $r.deferred,
      deferredData: t,
      statusCode: (o = t.init) == null ? void 0 : o.status,
      headers: ((s = t.init) == null ? void 0 : s.headers) && new Headers(t.init.headers)
    };
  }
  if (O9(t)) {
    var c, u;
    return {
      type: $r.data,
      data: t.data,
      statusCode: (c = t.init) == null ? void 0 : c.status,
      headers: (u = t.init) != null && u.headers ? new Headers(t.init.headers) : void 0
    };
  }
  return {
    type: $r.data,
    data: t
  };
}
function z_e(e, t, n, r, i, o) {
  let s = e.headers.get("Location");
  if ($t(s, "Redirects returned/thrown from loaders/actions must have a Location header"), !nN.test(s)) {
    let c = r.slice(0, r.findIndex((u) => u.route.id === n) + 1);
    s = CD(new URL(t.url), c, i, !0, s, o), e.headers.set("Location", s);
  }
  return e;
}
function S9(e, t, n) {
  if (nN.test(e)) {
    let r = e, i = r.startsWith("//") ? new URL(t.protocol + r) : new URL(r), o = Vc(i.pathname, n) != null;
    if (i.origin === t.origin && o)
      return i.pathname + i.search + i.hash;
  }
  return e;
}
function lg(e, t, n, r) {
  let i = e.createURL(vQ(t)).toString(), o = {
    signal: n
  };
  if (r && Bc(r.formMethod)) {
    let {
      formMethod: s,
      formEncType: c
    } = r;
    o.method = s.toUpperCase(), c === "application/json" ? (o.headers = new Headers({
      "Content-Type": c
    }), o.body = JSON.stringify(r.json)) : c === "text/plain" ? o.body = r.text : c === "application/x-www-form-urlencoded" && r.formData ? o.body = xD(r.formData) : o.body = r.formData;
  }
  return new Request(i, o);
}
function xD(e) {
  let t = new URLSearchParams();
  for (let [n, r] of e.entries())
    t.append(n, typeof r == "string" ? r : r.name);
  return t;
}
function k9(e) {
  let t = new FormData();
  for (let [n, r] of e.entries())
    t.append(n, r);
  return t;
}
function V_e(e, t, n, r, i) {
  let o = {}, s = null, c, u = !1, f = {}, p = n && sl(n[1]) ? n[1].error : void 0;
  return e.forEach((y) => {
    if (!(y.route.id in t))
      return;
    let v = y.route.id, w = t[v];
    if ($t(!Im(w), "Cannot handle redirect results in processLoaderData"), sl(w)) {
      let C = w.error;
      p !== void 0 && (C = p, p = void 0), s = s || {};
      {
        let x = Ag(e, v);
        s[x.route.id] == null && (s[x.route.id] = C);
      }
      o[v] = void 0, u || (u = !0, c = DA(w.error) ? w.error.status : 500), w.headers && (f[v] = w.headers);
    } else
      Fh(w) ? (r.set(v, w.deferredData), o[v] = w.deferredData.data, w.statusCode != null && w.statusCode !== 200 && !u && (c = w.statusCode), w.headers && (f[v] = w.headers)) : (o[v] = w.data, w.statusCode && w.statusCode !== 200 && !u && (c = w.statusCode), w.headers && (f[v] = w.headers));
  }), p !== void 0 && n && (s = {
    [n[0]]: p
  }, o[n[0]] = void 0), {
    loaderData: o,
    errors: s,
    statusCode: c || 200,
    loaderHeaders: f
  };
}
function A9(e, t, n, r, i, o, s, c) {
  let {
    loaderData: u,
    errors: f
  } = V_e(t, r, i, c);
  return o.forEach((p) => {
    let {
      key: y,
      match: v,
      controller: w
    } = p, C = s[y];
    if ($t(C, "Did not find corresponding fetcher result"), !(w && w.signal.aborted))
      if (sl(C)) {
        let x = Ag(e.matches, v == null ? void 0 : v.route.id);
        f && f[x.route.id] || (f = Pi({}, f, {
          [x.route.id]: C.error
        })), e.fetchers.delete(y);
      } else if (Im(C))
        $t(!1, "Unhandled fetcher revalidation redirect");
      else if (Fh(C))
        $t(!1, "Unhandled fetcher deferred data");
      else {
        let x = kh(C.data);
        e.fetchers.set(y, x);
      }
  }), {
    loaderData: u,
    errors: f
  };
}
function T9(e, t, n, r) {
  let i = Pi({}, t);
  for (let o of n) {
    let s = o.route.id;
    if (t.hasOwnProperty(s) ? t[s] !== void 0 && (i[s] = t[s]) : e[s] !== void 0 && o.route.loader && (i[s] = e[s]), r && r.hasOwnProperty(s))
      break;
  }
  return i;
}
function _9(e) {
  return e ? sl(e[1]) ? {
    // Clear out prior actionData on errors
    actionData: {}
  } : {
    actionData: {
      [e[0]]: e[1].data
    }
  } : {};
}
function Ag(e, t) {
  return (t ? e.slice(0, e.findIndex((r) => r.route.id === t) + 1) : [...e]).reverse().find((r) => r.route.hasErrorBoundary === !0) || e[0];
}
function R9(e) {
  let t = e.length === 1 ? e[0] : e.find((n) => n.index || !n.path || n.path === "/") || {
    id: "__shim-error-route__"
  };
  return {
    matches: [{
      params: {},
      pathname: "",
      pathnameBase: "",
      route: t
    }],
    route: t
  };
}
function es(e, t) {
  let {
    pathname: n,
    routeId: r,
    method: i,
    type: o,
    message: s
  } = t === void 0 ? {} : t, c = "Unknown Server Error", u = "Unknown @remix-run/router error";
  return e === 400 ? (c = "Bad Request", o === "route-discovery" ? u = 'Unable to match URL "' + n + '" - the `unstable_patchRoutesOnNavigation()` ' + (`function threw the following error:
` + s) : i && n && r ? u = "You made a " + i + ' request to "' + n + '" but ' + ('did not provide a `loader` for route "' + r + '", ') + "so there is no way to handle the request." : o === "defer-action" ? u = "defer() is not supported in actions" : o === "invalid-body" && (u = "Unable to encode submission body")) : e === 403 ? (c = "Forbidden", u = 'Route "' + r + '" does not match URL "' + n + '"') : e === 404 ? (c = "Not Found", u = 'No route matches URL "' + n + '"') : e === 405 && (c = "Method Not Allowed", i && n && r ? u = "You made a " + i.toUpperCase() + ' request to "' + n + '" but ' + ('did not provide an `action` for route "' + r + '", ') + "so there is no way to handle the request." : i && (u = 'Invalid request method "' + i.toUpperCase() + '"')), new wD(e || 500, c, new Error(u), !0);
}
function Vk(e) {
  let t = Object.entries(e);
  for (let n = t.length - 1; n >= 0; n--) {
    let [r, i] = t[n];
    if (Im(i))
      return {
        key: r,
        result: i
      };
  }
}
function vQ(e) {
  let t = typeof e == "string" ? Ku(e) : e;
  return ty(Pi({}, t, {
    hash: ""
  }));
}
function $_e(e, t) {
  return e.pathname !== t.pathname || e.search !== t.search ? !1 : e.hash === "" ? t.hash !== "" : e.hash === t.hash ? !0 : t.hash !== "";
}
function H_e(e) {
  return typeof e == "object" && e != null && "then" in e;
}
function q_e(e) {
  return gQ(e.result) && T_e.has(e.result.status);
}
function Fh(e) {
  return e.type === $r.deferred;
}
function sl(e) {
  return e.type === $r.error;
}
function Im(e) {
  return (e && e.type) === $r.redirect;
}
function O9(e) {
  return typeof e == "object" && e != null && "type" in e && "data" in e && "init" in e && e.type === "DataWithResponseInit";
}
function W_e(e) {
  let t = e;
  return t && typeof t == "object" && typeof t.data == "object" && typeof t.subscribe == "function" && typeof t.cancel == "function" && typeof t.resolveData == "function";
}
function gQ(e) {
  return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.headers == "object" && typeof e.body < "u";
}
function G_e(e) {
  return A_e.has(e.toLowerCase());
}
function Bc(e) {
  return S_e.has(e.toLowerCase());
}
async function K_e(e, t, n, r, i) {
  let o = Object.entries(t);
  for (let s = 0; s < o.length; s++) {
    let [c, u] = o[s], f = e.find((v) => (v == null ? void 0 : v.route.id) === c);
    if (!f)
      continue;
    let p = r.find((v) => v.route.id === f.route.id), y = p != null && !mQ(p, f) && (i && i[f.route.id]) !== void 0;
    Fh(u) && y && await rN(u, n, !1).then((v) => {
      v && (t[c] = v);
    });
  }
}
async function Y_e(e, t, n) {
  for (let r = 0; r < n.length; r++) {
    let {
      key: i,
      routeId: o,
      controller: s
    } = n[r], c = t[i];
    e.find((f) => (f == null ? void 0 : f.route.id) === o) && Fh(c) && ($t(s, "Expected an AbortController for revalidating fetcher deferred result"), await rN(c, s.signal, !0).then((f) => {
      f && (t[i] = f);
    }));
  }
}
async function rN(e, t, n) {
  if (n === void 0 && (n = !1), !await e.deferredData.resolveData(t)) {
    if (n)
      try {
        return {
          type: $r.data,
          data: e.deferredData.unwrappedData
        };
      } catch (i) {
        return {
          type: $r.error,
          error: i
        };
      }
    return {
      type: $r.data,
      data: e.deferredData.data
    };
  }
}
function iN(e) {
  return new URLSearchParams(e).getAll("index").some((t) => t === "");
}
function T1(e, t) {
  let n = typeof t == "string" ? Ku(t).search : t.search;
  if (e[e.length - 1].route.index && iN(n || ""))
    return e[e.length - 1];
  let r = fQ(e);
  return r[r.length - 1];
}
function I9(e) {
  let {
    formMethod: t,
    formAction: n,
    formEncType: r,
    text: i,
    formData: o,
    json: s
  } = e;
  if (!(!t || !n || !r)) {
    if (i != null)
      return {
        formMethod: t,
        formAction: n,
        formEncType: r,
        formData: void 0,
        json: void 0,
        text: i
      };
    if (o != null)
      return {
        formMethod: t,
        formAction: n,
        formEncType: r,
        formData: o,
        json: void 0,
        text: void 0
      };
    if (s !== void 0)
      return {
        formMethod: t,
        formAction: n,
        formEncType: r,
        formData: void 0,
        json: s,
        text: void 0
      };
  }
}
function JO(e, t) {
  return t ? {
    state: "loading",
    location: e,
    formMethod: t.formMethod,
    formAction: t.formAction,
    formEncType: t.formEncType,
    formData: t.formData,
    json: t.json,
    text: t.text
  } : {
    state: "loading",
    location: e,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
  };
}
function Q_e(e, t) {
  return {
    state: "submitting",
    location: e,
    formMethod: t.formMethod,
    formAction: t.formAction,
    formEncType: t.formEncType,
    formData: t.formData,
    json: t.json,
    text: t.text
  };
}
function h1(e, t) {
  return e ? {
    state: "loading",
    formMethod: e.formMethod,
    formAction: e.formAction,
    formEncType: e.formEncType,
    formData: e.formData,
    json: e.json,
    text: e.text,
    data: t
  } : {
    state: "loading",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data: t
  };
}
function X_e(e, t) {
  return {
    state: "submitting",
    formMethod: e.formMethod,
    formAction: e.formAction,
    formEncType: e.formEncType,
    formData: e.formData,
    json: e.json,
    text: e.text,
    data: t ? t.data : void 0
  };
}
function kh(e) {
  return {
    state: "idle",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data: e
  };
}
function J_e(e, t) {
  try {
    let n = e.sessionStorage.getItem(pQ);
    if (n) {
      let r = JSON.parse(n);
      for (let [i, o] of Object.entries(r || {}))
        o && Array.isArray(o) && t.set(i, new Set(o || []));
    }
  } catch {
  }
}
function Z_e(e, t) {
  if (t.size > 0) {
    let n = {};
    for (let [r, i] of t)
      n[r] = [...i];
    try {
      e.sessionStorage.setItem(pQ, JSON.stringify(n));
    } catch (r) {
      so(!1, "Failed to save applied view transitions in sessionStorage (" + r + ").");
    }
  }
}
function vb() {
  return vb = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, vb.apply(this, arguments);
}
const Gb = /* @__PURE__ */ k.createContext(null);
ct.env.NODE_ENV !== "production" && (Gb.displayName = "DataRouter");
const MA = /* @__PURE__ */ k.createContext(null);
ct.env.NODE_ENV !== "production" && (MA.displayName = "DataRouterState");
const eRe = /* @__PURE__ */ k.createContext(null);
ct.env.NODE_ENV !== "production" && (eRe.displayName = "Await");
const ic = /* @__PURE__ */ k.createContext(null);
ct.env.NODE_ENV !== "production" && (ic.displayName = "Navigation");
const hx = /* @__PURE__ */ k.createContext(null);
ct.env.NODE_ENV !== "production" && (hx.displayName = "Location");
const Gc = /* @__PURE__ */ k.createContext({
  outlet: null,
  matches: [],
  isDataRoute: !1
});
ct.env.NODE_ENV !== "production" && (Gc.displayName = "Route");
const oN = /* @__PURE__ */ k.createContext(null);
ct.env.NODE_ENV !== "production" && (oN.displayName = "RouteError");
function tRe(e, t) {
  let {
    relative: n
  } = t === void 0 ? {} : t;
  dy() || (ct.env.NODE_ENV !== "production" ? $t(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component."
  ) : $t(!1));
  let {
    basename: r,
    navigator: i
  } = k.useContext(ic), {
    hash: o,
    pathname: s,
    search: c
  } = px(e, {
    relative: n
  }), u = s;
  return r !== "/" && (u = s === "/" ? r : ju([r, s])), i.createHref({
    pathname: u,
    search: c,
    hash: o
  });
}
function dy() {
  return k.useContext(hx) != null;
}
function Kc() {
  return dy() || (ct.env.NODE_ENV !== "production" ? $t(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ) : $t(!1)), k.useContext(hx).location;
}
function Kl(e) {
  dy() || (ct.env.NODE_ENV !== "production" ? $t(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useMatch() may be used only in the context of a <Router> component."
  ) : $t(!1));
  let {
    pathname: t
  } = Kc();
  return k.useMemo(() => CC(e, dQ(t)), [t, e]);
}
const bQ = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function wQ(e) {
  k.useContext(ic).static || k.useLayoutEffect(e);
}
function La() {
  let {
    isDataRoute: e
  } = k.useContext(Gc);
  return e ? yRe() : nRe();
}
function nRe() {
  dy() || (ct.env.NODE_ENV !== "production" ? $t(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  ) : $t(!1));
  let e = k.useContext(Gb), {
    basename: t,
    future: n,
    navigator: r
  } = k.useContext(ic), {
    matches: i
  } = k.useContext(Gc), {
    pathname: o
  } = Kc(), s = JSON.stringify(OA(i, n.v7_relativeSplatPath)), c = k.useRef(!1);
  return wQ(() => {
    c.current = !0;
  }), k.useCallback(function(f, p) {
    if (p === void 0 && (p = {}), ct.env.NODE_ENV !== "production" && so(c.current, bQ), !c.current) return;
    if (typeof f == "number") {
      r.go(f);
      return;
    }
    let y = IA(f, JSON.parse(s), o, p.relative === "path");
    e == null && t !== "/" && (y.pathname = y.pathname === "/" ? t : ju([t, y.pathname])), (p.replace ? r.replace : r.push)(y, p.state, p);
  }, [t, r, s, o, e]);
}
const rRe = /* @__PURE__ */ k.createContext(null);
function iRe(e) {
  let t = k.useContext(Gc).outlet;
  return t && /* @__PURE__ */ k.createElement(rRe.Provider, {
    value: e
  }, t);
}
function px(e, t) {
  let {
    relative: n
  } = t === void 0 ? {} : t, {
    future: r
  } = k.useContext(ic), {
    matches: i
  } = k.useContext(Gc), {
    pathname: o
  } = Kc(), s = JSON.stringify(OA(i, r.v7_relativeSplatPath));
  return k.useMemo(() => IA(e, JSON.parse(s), o, n === "path"), [e, s, o, n]);
}
function oRe(e, t) {
  return CQ(e, t);
}
function CQ(e, t, n, r) {
  dy() || (ct.env.NODE_ENV !== "production" ? $t(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useRoutes() may be used only in the context of a <Router> component."
  ) : $t(!1));
  let {
    navigator: i
  } = k.useContext(ic), {
    matches: o
  } = k.useContext(Gc), s = o[o.length - 1], c = s ? s.params : {}, u = s ? s.pathname : "/", f = s ? s.pathnameBase : "/", p = s && s.route;
  if (ct.env.NODE_ENV !== "production") {
    let I = p && p.path || "";
    EQ(u, !p || I.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + u + '" (under <Route path="' + I + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + I + '"> to <Route ') + ('path="' + (I === "/" ? "*" : I + "/*") + '">.'));
  }
  let y = Kc(), v;
  if (t) {
    var w;
    let I = typeof t == "string" ? Ku(t) : t;
    f === "/" || (w = I.pathname) != null && w.startsWith(f) || (ct.env.NODE_ENV !== "production" ? $t(!1, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was " + ('matched by all parent routes. The current pathname base is "' + f + '" ') + ('but pathname "' + I.pathname + '" was given in the `location` prop.')) : $t(!1)), v = I;
  } else
    v = y;
  let C = v.pathname || "/", x = C;
  if (f !== "/") {
    let I = f.replace(/^\//, "").split("/");
    x = "/" + C.replace(/^\//, "").split("/").slice(I.length).join("/");
  }
  let A = Em(e, {
    pathname: x
  });
  ct.env.NODE_ENV !== "production" && (ct.env.NODE_ENV !== "production" && so(p || A != null, 'No routes matched location "' + v.pathname + v.search + v.hash + '" '), ct.env.NODE_ENV !== "production" && so(A == null || A[A.length - 1].route.element !== void 0 || A[A.length - 1].route.Component !== void 0 || A[A.length - 1].route.lazy !== void 0, 'Matched leaf route at location "' + v.pathname + v.search + v.hash + '" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.'));
  let R = uRe(A && A.map((I) => Object.assign({}, I, {
    params: Object.assign({}, c, I.params),
    pathname: ju([
      f,
      // Re-encode pathnames that were decoded inside matchRoutes
      i.encodeLocation ? i.encodeLocation(I.pathname).pathname : I.pathname
    ]),
    pathnameBase: I.pathnameBase === "/" ? f : ju([
      f,
      // Re-encode pathnames that were decoded inside matchRoutes
      i.encodeLocation ? i.encodeLocation(I.pathnameBase).pathname : I.pathnameBase
    ])
  })), o, n, r);
  return t && R ? /* @__PURE__ */ k.createElement(hx.Provider, {
    value: {
      location: vb({
        pathname: "/",
        search: "",
        hash: "",
        state: null,
        key: "default"
      }, v),
      navigationType: Gi.Pop
    }
  }, R) : R;
}
function aRe() {
  let e = mRe(), t = DA(e) ? e.status + " " + e.statusText : e instanceof Error ? e.message : JSON.stringify(e), n = e instanceof Error ? e.stack : null, r = "rgba(200,200,200, 0.5)", i = {
    padding: "0.5rem",
    backgroundColor: r
  }, o = {
    padding: "2px 4px",
    backgroundColor: r
  }, s = null;
  return ct.env.NODE_ENV !== "production" && (s = /* @__PURE__ */ k.createElement(k.Fragment, null, /* @__PURE__ */ k.createElement("p", null, " Hey developer "), /* @__PURE__ */ k.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ k.createElement("code", {
    style: o
  }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ k.createElement("code", {
    style: o
  }, "errorElement"), " prop on your route."))), /* @__PURE__ */ k.createElement(k.Fragment, null, /* @__PURE__ */ k.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ k.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, t), n ? /* @__PURE__ */ k.createElement("pre", {
    style: i
  }, n) : null, s);
}
const sRe = /* @__PURE__ */ k.createElement(aRe, null);
class lRe extends k.Component {
  constructor(t) {
    super(t), this.state = {
      location: t.location,
      revalidation: t.revalidation,
      error: t.error
    };
  }
  static getDerivedStateFromError(t) {
    return {
      error: t
    };
  }
  static getDerivedStateFromProps(t, n) {
    return n.location !== t.location || n.revalidation !== "idle" && t.revalidation === "idle" ? {
      error: t.error,
      location: t.location,
      revalidation: t.revalidation
    } : {
      error: t.error !== void 0 ? t.error : n.error,
      location: n.location,
      revalidation: t.revalidation || n.revalidation
    };
  }
  componentDidCatch(t, n) {
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ k.createElement(Gc.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ k.createElement(oN.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function cRe(e) {
  let {
    routeContext: t,
    match: n,
    children: r
  } = e, i = k.useContext(Gb);
  return i && i.static && i.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (i.staticContext._deepestRenderedBoundaryId = n.route.id), /* @__PURE__ */ k.createElement(Gc.Provider, {
    value: t
  }, r);
}
function uRe(e, t, n, r) {
  var i;
  if (t === void 0 && (t = []), n === void 0 && (n = null), r === void 0 && (r = null), e == null) {
    var o;
    if (!n)
      return null;
    if (n.errors)
      e = n.matches;
    else if ((o = r) != null && o.v7_partialHydration && t.length === 0 && !n.initialized && n.matches.length > 0)
      e = n.matches;
    else
      return null;
  }
  let s = e, c = (i = n) == null ? void 0 : i.errors;
  if (c != null) {
    let p = s.findIndex((y) => y.route.id && (c == null ? void 0 : c[y.route.id]) !== void 0);
    p >= 0 || (ct.env.NODE_ENV !== "production" ? $t(!1, "Could not find a matching route for errors on route IDs: " + Object.keys(c).join(",")) : $t(!1)), s = s.slice(0, Math.min(s.length, p + 1));
  }
  let u = !1, f = -1;
  if (n && r && r.v7_partialHydration)
    for (let p = 0; p < s.length; p++) {
      let y = s[p];
      if ((y.route.HydrateFallback || y.route.hydrateFallbackElement) && (f = p), y.route.id) {
        let {
          loaderData: v,
          errors: w
        } = n, C = y.route.loader && v[y.route.id] === void 0 && (!w || w[y.route.id] === void 0);
        if (y.route.lazy || C) {
          u = !0, f >= 0 ? s = s.slice(0, f + 1) : s = [s[0]];
          break;
        }
      }
    }
  return s.reduceRight((p, y, v) => {
    let w, C = !1, x = null, A = null;
    n && (w = c && y.route.id ? c[y.route.id] : void 0, x = y.route.errorElement || sRe, u && (f < 0 && v === 0 ? (EQ("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"), C = !0, A = null) : f === v && (C = !0, A = y.route.hydrateFallbackElement || null)));
    let R = t.concat(s.slice(0, v + 1)), I = () => {
      let D;
      return w ? D = x : C ? D = A : y.route.Component ? D = /* @__PURE__ */ k.createElement(y.route.Component, null) : y.route.element ? D = y.route.element : D = p, /* @__PURE__ */ k.createElement(cRe, {
        match: y,
        routeContext: {
          outlet: p,
          matches: R,
          isDataRoute: n != null
        },
        children: D
      });
    };
    return n && (y.route.ErrorBoundary || y.route.errorElement || v === 0) ? /* @__PURE__ */ k.createElement(lRe, {
      location: n.location,
      revalidation: n.revalidation,
      component: x,
      error: w,
      children: I(),
      routeContext: {
        outlet: null,
        matches: R,
        isDataRoute: !0
      }
    }) : I();
  }, null);
}
var xQ = /* @__PURE__ */ function(e) {
  return e.UseBlocker = "useBlocker", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e;
}(xQ || {}), xC = /* @__PURE__ */ function(e) {
  return e.UseBlocker = "useBlocker", e.UseLoaderData = "useLoaderData", e.UseActionData = "useActionData", e.UseRouteError = "useRouteError", e.UseNavigation = "useNavigation", e.UseRouteLoaderData = "useRouteLoaderData", e.UseMatches = "useMatches", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e.UseRouteId = "useRouteId", e;
}(xC || {});
function aN(e) {
  return e + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function dRe(e) {
  let t = k.useContext(Gb);
  return t || (ct.env.NODE_ENV !== "production" ? $t(!1, aN(e)) : $t(!1)), t;
}
function fRe(e) {
  let t = k.useContext(MA);
  return t || (ct.env.NODE_ENV !== "production" ? $t(!1, aN(e)) : $t(!1)), t;
}
function hRe(e) {
  let t = k.useContext(Gc);
  return t || (ct.env.NODE_ENV !== "production" ? $t(!1, aN(e)) : $t(!1)), t;
}
function sN(e) {
  let t = hRe(e), n = t.matches[t.matches.length - 1];
  return n.route.id || (ct.env.NODE_ENV !== "production" ? $t(!1, e + ' can only be used on routes that contain a unique "id"') : $t(!1)), n.route.id;
}
function pRe() {
  return sN(xC.UseRouteId);
}
function mRe() {
  var e;
  let t = k.useContext(oN), n = fRe(xC.UseRouteError), r = sN(xC.UseRouteError);
  return t !== void 0 ? t : (e = n.errors) == null ? void 0 : e[r];
}
function yRe() {
  let {
    router: e
  } = dRe(xQ.UseNavigateStable), t = sN(xC.UseNavigateStable), n = k.useRef(!1);
  return wQ(() => {
    n.current = !0;
  }), k.useCallback(function(i, o) {
    o === void 0 && (o = {}), ct.env.NODE_ENV !== "production" && so(n.current, bQ), n.current && (typeof i == "number" ? e.navigate(i) : e.navigate(i, vb({
      fromRouteId: t
    }, o)));
  }, [e, t]);
}
const D9 = {};
function EQ(e, t, n) {
  !t && !D9[e] && (D9[e] = !0, ct.env.NODE_ENV !== "production" && so(!1, n));
}
function SQ(e) {
  let {
    to: t,
    replace: n,
    state: r,
    relative: i
  } = e;
  dy() || (ct.env.NODE_ENV !== "production" ? $t(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of
    // the router loaded. We can help them understand how to avoid that.
    "<Navigate> may be used only in the context of a <Router> component."
  ) : $t(!1));
  let {
    future: o,
    static: s
  } = k.useContext(ic);
  ct.env.NODE_ENV !== "production" && so(!s, "<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.");
  let {
    matches: c
  } = k.useContext(Gc), {
    pathname: u
  } = Kc(), f = La(), p = IA(t, OA(c, o.v7_relativeSplatPath), u, i === "path"), y = JSON.stringify(p);
  return k.useEffect(() => f(JSON.parse(y), {
    replace: n,
    state: r,
    relative: i
  }), [f, y, i, n, r]), null;
}
function lN(e) {
  return iRe(e.context);
}
function Yr(e) {
  ct.env.NODE_ENV !== "production" ? $t(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.") : $t(!1);
}
function vRe(e) {
  let {
    basename: t = "/",
    children: n = null,
    location: r,
    navigationType: i = Gi.Pop,
    navigator: o,
    static: s = !1,
    future: c
  } = e;
  dy() && (ct.env.NODE_ENV !== "production" ? $t(!1, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : $t(!1));
  let u = t.replace(/^\/*/, "/"), f = k.useMemo(() => ({
    basename: u,
    navigator: o,
    static: s,
    future: vb({
      v7_relativeSplatPath: !1
    }, c)
  }), [u, c, o, s]);
  typeof r == "string" && (r = Ku(r));
  let {
    pathname: p = "/",
    search: y = "",
    hash: v = "",
    state: w = null,
    key: C = "default"
  } = r, x = k.useMemo(() => {
    let A = Vc(p, u);
    return A == null ? null : {
      location: {
        pathname: A,
        search: y,
        hash: v,
        state: w,
        key: C
      },
      navigationType: i
    };
  }, [u, p, y, v, w, C, i]);
  return ct.env.NODE_ENV !== "production" && so(x != null, '<Router basename="' + u + '"> is not able to match the URL ' + ('"' + p + y + v + '" because it does not start with the ') + "basename, so the <Router> won't render anything."), x == null ? null : /* @__PURE__ */ k.createElement(ic.Provider, {
    value: f
  }, /* @__PURE__ */ k.createElement(hx.Provider, {
    children: n,
    value: x
  }));
}
function gRe(e) {
  let {
    children: t,
    location: n
  } = e;
  return oRe(ED(t), n);
}
new Promise(() => {
});
function ED(e, t) {
  t === void 0 && (t = []);
  let n = [];
  return k.Children.forEach(e, (r, i) => {
    if (!/* @__PURE__ */ k.isValidElement(r))
      return;
    let o = [...t, i];
    if (r.type === k.Fragment) {
      n.push.apply(n, ED(r.props.children, o));
      return;
    }
    r.type !== Yr && (ct.env.NODE_ENV !== "production" ? $t(!1, "[" + (typeof r.type == "string" ? r.type : r.type.name) + "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>") : $t(!1)), !r.props.index || !r.props.children || (ct.env.NODE_ENV !== "production" ? $t(!1, "An index route cannot have child routes.") : $t(!1));
    let s = {
      id: r.props.id || o.join("-"),
      caseSensitive: r.props.caseSensitive,
      element: r.props.element,
      Component: r.props.Component,
      index: r.props.index,
      path: r.props.path,
      loader: r.props.loader,
      action: r.props.action,
      errorElement: r.props.errorElement,
      ErrorBoundary: r.props.ErrorBoundary,
      hasErrorBoundary: r.props.ErrorBoundary != null || r.props.errorElement != null,
      shouldRevalidate: r.props.shouldRevalidate,
      handle: r.props.handle,
      lazy: r.props.lazy
    };
    r.props.children && (s.children = ED(r.props.children, o)), n.push(s);
  }), n;
}
function bRe(e) {
  let t = {
    // Note: this check also occurs in createRoutesFromChildren so update
    // there if you change this -- please and thank you!
    hasErrorBoundary: e.ErrorBoundary != null || e.errorElement != null
  };
  return e.Component && (ct.env.NODE_ENV !== "production" && e.element && ct.env.NODE_ENV !== "production" && so(!1, "You should not include both `Component` and `element` on your route - `Component` will be used."), Object.assign(t, {
    element: /* @__PURE__ */ k.createElement(e.Component),
    Component: void 0
  })), e.HydrateFallback && (ct.env.NODE_ENV !== "production" && e.hydrateFallbackElement && ct.env.NODE_ENV !== "production" && so(!1, "You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used."), Object.assign(t, {
    hydrateFallbackElement: /* @__PURE__ */ k.createElement(e.HydrateFallback),
    HydrateFallback: void 0
  })), e.ErrorBoundary && (ct.env.NODE_ENV !== "production" && e.errorElement && ct.env.NODE_ENV !== "production" && so(!1, "You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used."), Object.assign(t, {
    errorElement: /* @__PURE__ */ k.createElement(e.ErrorBoundary),
    ErrorBoundary: void 0
  })), t;
}
function wRe(e, t) {
  return I_e({
    basename: void 0,
    future: vb({}, void 0, {
      v7_prependBasename: !0
    }),
    history: r_e({
      initialEntries: void 0,
      initialIndex: void 0
    }),
    hydrationData: void 0,
    routes: e,
    mapRouteProperties: bRe,
    unstable_dataStrategy: void 0,
    unstable_patchRoutesOnNavigation: void 0
  }).initialize();
}
function gb() {
  return gb = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, gb.apply(this, arguments);
}
function cN(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
const v4 = "get", g4 = "application/x-www-form-urlencoded";
function PA(e) {
  return e != null && typeof e.tagName == "string";
}
function CRe(e) {
  return PA(e) && e.tagName.toLowerCase() === "button";
}
function xRe(e) {
  return PA(e) && e.tagName.toLowerCase() === "form";
}
function ERe(e) {
  return PA(e) && e.tagName.toLowerCase() === "input";
}
function SRe(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
function kRe(e, t) {
  return e.button === 0 && // Ignore everything but left clicks
  (!t || t === "_self") && // Let browser handle "target=_blank" etc.
  !SRe(e);
}
let $k = null;
function ARe() {
  if ($k === null)
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      ), $k = !1;
    } catch {
      $k = !0;
    }
  return $k;
}
const TRe = /* @__PURE__ */ new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function ZO(e) {
  return e != null && !TRe.has(e) ? (ct.env.NODE_ENV !== "production" && so(!1, '"' + e + '" is not a valid `encType` for `<Form>`/`<fetcher.Form>` ' + ('and will default to "' + g4 + '"')), null) : e;
}
function _Re(e, t) {
  let n, r, i, o, s;
  if (xRe(e)) {
    let c = e.getAttribute("action");
    r = c ? Vc(c, t) : null, n = e.getAttribute("method") || v4, i = ZO(e.getAttribute("enctype")) || g4, o = new FormData(e);
  } else if (CRe(e) || ERe(e) && (e.type === "submit" || e.type === "image")) {
    let c = e.form;
    if (c == null)
      throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
    let u = e.getAttribute("formaction") || c.getAttribute("action");
    if (r = u ? Vc(u, t) : null, n = e.getAttribute("formmethod") || c.getAttribute("method") || v4, i = ZO(e.getAttribute("formenctype")) || ZO(c.getAttribute("enctype")) || g4, o = new FormData(c, e), !ARe()) {
      let {
        name: f,
        type: p,
        value: y
      } = e;
      if (p === "image") {
        let v = f ? f + "." : "";
        o.append(v + "x", "0"), o.append(v + "y", "0");
      } else f && o.append(f, y);
    }
  } else {
    if (PA(e))
      throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
    n = v4, r = null, i = g4, s = e;
  }
  return o && i === "text/plain" && (s = o, o = void 0), {
    action: r,
    method: n.toLowerCase(),
    encType: i,
    formData: o,
    body: s
  };
}
const RRe = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"], ORe = ["aria-current", "caseSensitive", "className", "end", "style", "to", "unstable_viewTransition", "children"], IRe = ["fetcherKey", "navigate", "reloadDocument", "replace", "state", "method", "action", "onSubmit", "relative", "preventScrollReset", "unstable_viewTransition"], DRe = "6";
try {
  window.__reactRouterVersion = DRe;
} catch {
}
const uN = /* @__PURE__ */ k.createContext({
  isTransitioning: !1
});
ct.env.NODE_ENV !== "production" && (uN.displayName = "ViewTransition");
const kQ = /* @__PURE__ */ k.createContext(/* @__PURE__ */ new Map());
ct.env.NODE_ENV !== "production" && (kQ.displayName = "Fetchers");
const MRe = "startTransition", M9 = Qz[MRe], PRe = "flushSync", P9 = pwe[PRe];
function NRe(e) {
  M9 ? M9(e) : e();
}
function p1(e) {
  P9 ? P9(e) : e();
}
class BRe {
  constructor() {
    this.status = "pending", this.promise = new Promise((t, n) => {
      this.resolve = (r) => {
        this.status === "pending" && (this.status = "resolved", t(r));
      }, this.reject = (r) => {
        this.status === "pending" && (this.status = "rejected", n(r));
      };
    });
  }
}
function LRe(e) {
  let {
    fallbackElement: t,
    router: n,
    future: r
  } = e, [i, o] = k.useState(n.state), [s, c] = k.useState(), [u, f] = k.useState({
    isTransitioning: !1
  }), [p, y] = k.useState(), [v, w] = k.useState(), [C, x] = k.useState(), A = k.useRef(/* @__PURE__ */ new Map()), {
    v7_startTransition: R
  } = r || {}, I = k.useCallback((O) => {
    R ? NRe(O) : O();
  }, [R]), D = k.useCallback((O, z) => {
    let {
      deletedFetchers: H,
      unstable_flushSync: Q,
      unstable_viewTransitionOpts: Y
    } = z;
    H.forEach((ie) => A.current.delete(ie)), O.fetchers.forEach((ie, X) => {
      ie.data !== void 0 && A.current.set(X, ie.data);
    });
    let ee = n.window == null || n.window.document == null || typeof n.window.document.startViewTransition != "function";
    if (!Y || ee) {
      Q ? p1(() => o(O)) : I(() => o(O));
      return;
    }
    if (Q) {
      p1(() => {
        v && (p && p.resolve(), v.skipTransition()), f({
          isTransitioning: !0,
          flushSync: !0,
          currentLocation: Y.currentLocation,
          nextLocation: Y.nextLocation
        });
      });
      let ie = n.window.document.startViewTransition(() => {
        p1(() => o(O));
      });
      ie.finished.finally(() => {
        p1(() => {
          y(void 0), w(void 0), c(void 0), f({
            isTransitioning: !1
          });
        });
      }), p1(() => w(ie));
      return;
    }
    v ? (p && p.resolve(), v.skipTransition(), x({
      state: O,
      currentLocation: Y.currentLocation,
      nextLocation: Y.nextLocation
    })) : (c(O), f({
      isTransitioning: !0,
      flushSync: !1,
      currentLocation: Y.currentLocation,
      nextLocation: Y.nextLocation
    }));
  }, [n.window, v, p, A, I]);
  k.useLayoutEffect(() => n.subscribe(D), [n, D]), k.useEffect(() => {
    u.isTransitioning && !u.flushSync && y(new BRe());
  }, [u]), k.useEffect(() => {
    if (p && s && n.window) {
      let O = s, z = p.promise, H = n.window.document.startViewTransition(async () => {
        I(() => o(O)), await z;
      });
      H.finished.finally(() => {
        y(void 0), w(void 0), c(void 0), f({
          isTransitioning: !1
        });
      }), w(H);
    }
  }, [I, s, p, n.window]), k.useEffect(() => {
    p && s && i.location.key === s.location.key && p.resolve();
  }, [p, v, i.location, s]), k.useEffect(() => {
    !u.isTransitioning && C && (c(C.state), f({
      isTransitioning: !0,
      flushSync: !1,
      currentLocation: C.currentLocation,
      nextLocation: C.nextLocation
    }), x(void 0));
  }, [u.isTransitioning, C]), k.useEffect(() => {
    ct.env.NODE_ENV !== "production" && so(t == null || !n.future.v7_partialHydration, "`<RouterProvider fallbackElement>` is deprecated when using `v7_partialHydration`, use a `HydrateFallback` component instead");
  }, []);
  let M = k.useMemo(() => ({
    createHref: n.createHref,
    encodeLocation: n.encodeLocation,
    go: (O) => n.navigate(O),
    push: (O, z, H) => n.navigate(O, {
      state: z,
      preventScrollReset: H == null ? void 0 : H.preventScrollReset
    }),
    replace: (O, z, H) => n.navigate(O, {
      replace: !0,
      state: z,
      preventScrollReset: H == null ? void 0 : H.preventScrollReset
    })
  }), [n]), L = n.basename || "/", j = k.useMemo(() => ({
    router: n,
    navigator: M,
    static: !1,
    basename: L
  }), [n, M, L]), F = k.useMemo(() => ({
    v7_relativeSplatPath: n.future.v7_relativeSplatPath
  }), [n.future.v7_relativeSplatPath]);
  return /* @__PURE__ */ k.createElement(k.Fragment, null, /* @__PURE__ */ k.createElement(Gb.Provider, {
    value: j
  }, /* @__PURE__ */ k.createElement(MA.Provider, {
    value: i
  }, /* @__PURE__ */ k.createElement(kQ.Provider, {
    value: A.current
  }, /* @__PURE__ */ k.createElement(uN.Provider, {
    value: u
  }, /* @__PURE__ */ k.createElement(vRe, {
    basename: L,
    location: i.location,
    navigationType: i.historyAction,
    navigator: M,
    future: F
  }, i.initialized || n.future.v7_partialHydration ? /* @__PURE__ */ k.createElement(jRe, {
    routes: n.routes,
    future: n.future,
    state: i
  }) : t))))), null);
}
const jRe = /* @__PURE__ */ k.memo(FRe);
function FRe(e) {
  let {
    routes: t,
    future: n,
    state: r
  } = e;
  return CQ(t, void 0, r, n);
}
ct.env.NODE_ENV;
const URe = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", zRe = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, dN = /* @__PURE__ */ k.forwardRef(function(t, n) {
  let {
    onClick: r,
    relative: i,
    reloadDocument: o,
    replace: s,
    state: c,
    target: u,
    to: f,
    preventScrollReset: p,
    unstable_viewTransition: y
  } = t, v = cN(t, RRe), {
    basename: w
  } = k.useContext(ic), C, x = !1;
  if (typeof f == "string" && zRe.test(f) && (C = f, URe))
    try {
      let D = new URL(window.location.href), M = f.startsWith("//") ? new URL(D.protocol + f) : new URL(f), L = Vc(M.pathname, w);
      M.origin === D.origin && L != null ? f = L + M.search + M.hash : x = !0;
    } catch {
      ct.env.NODE_ENV !== "production" && so(!1, '<Link to="' + f + '"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.');
    }
  let A = tRe(f, {
    relative: i
  }), R = qRe(f, {
    replace: s,
    state: c,
    target: u,
    preventScrollReset: p,
    relative: i,
    unstable_viewTransition: y
  });
  function I(D) {
    r && r(D), D.defaultPrevented || R(D);
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ k.createElement("a", gb({}, v, {
      href: C || A,
      onClick: x || o ? r : I,
      ref: n,
      target: u
    }))
  );
});
ct.env.NODE_ENV !== "production" && (dN.displayName = "Link");
const VRe = /* @__PURE__ */ k.forwardRef(function(t, n) {
  let {
    "aria-current": r = "page",
    caseSensitive: i = !1,
    className: o = "",
    end: s = !1,
    style: c,
    to: u,
    unstable_viewTransition: f,
    children: p
  } = t, y = cN(t, ORe), v = px(u, {
    relative: y.relative
  }), w = Kc(), C = k.useContext(MA), {
    navigator: x,
    basename: A
  } = k.useContext(ic), R = C != null && // Conditional usage is OK here because the usage of a data router is static
  // eslint-disable-next-line react-hooks/rules-of-hooks
  XRe(v) && f === !0, I = x.encodeLocation ? x.encodeLocation(v).pathname : v.pathname, D = w.pathname, M = C && C.navigation && C.navigation.location ? C.navigation.location.pathname : null;
  i || (D = D.toLowerCase(), M = M ? M.toLowerCase() : null, I = I.toLowerCase()), M && A && (M = Vc(M, A) || M);
  const L = I !== "/" && I.endsWith("/") ? I.length - 1 : I.length;
  let j = D === I || !s && D.startsWith(I) && D.charAt(L) === "/", F = M != null && (M === I || !s && M.startsWith(I) && M.charAt(I.length) === "/"), O = {
    isActive: j,
    isPending: F,
    isTransitioning: R
  }, z = j ? r : void 0, H;
  typeof o == "function" ? H = o(O) : H = [o, j ? "active" : null, F ? "pending" : null, R ? "transitioning" : null].filter(Boolean).join(" ");
  let Q = typeof c == "function" ? c(O) : c;
  return /* @__PURE__ */ k.createElement(dN, gb({}, y, {
    "aria-current": z,
    className: H,
    ref: n,
    style: Q,
    to: u,
    unstable_viewTransition: f
  }), typeof p == "function" ? p(O) : p);
});
ct.env.NODE_ENV !== "production" && (VRe.displayName = "NavLink");
const $Re = /* @__PURE__ */ k.forwardRef((e, t) => {
  let {
    fetcherKey: n,
    navigate: r,
    reloadDocument: i,
    replace: o,
    state: s,
    method: c = v4,
    action: u,
    onSubmit: f,
    relative: p,
    preventScrollReset: y,
    unstable_viewTransition: v
  } = e, w = cN(e, IRe), C = YRe(), x = QRe(u, {
    relative: p
  }), A = c.toLowerCase() === "get" ? "get" : "post", R = (I) => {
    if (f && f(I), I.defaultPrevented) return;
    I.preventDefault();
    let D = I.nativeEvent.submitter, M = (D == null ? void 0 : D.getAttribute("formmethod")) || c;
    C(D || I.currentTarget, {
      fetcherKey: n,
      method: M,
      navigate: r,
      replace: o,
      state: s,
      relative: p,
      preventScrollReset: y,
      unstable_viewTransition: v
    });
  };
  return /* @__PURE__ */ k.createElement("form", gb({
    ref: t,
    method: A,
    action: x,
    onSubmit: i ? f : R
  }, w));
});
ct.env.NODE_ENV !== "production" && ($Re.displayName = "Form");
ct.env.NODE_ENV;
var t8;
(function(e) {
  e.UseScrollRestoration = "useScrollRestoration", e.UseSubmit = "useSubmit", e.UseSubmitFetcher = "useSubmitFetcher", e.UseFetcher = "useFetcher", e.useViewTransitionState = "useViewTransitionState";
})(t8 || (t8 = {}));
var N9;
(function(e) {
  e.UseFetcher = "useFetcher", e.UseFetchers = "useFetchers", e.UseScrollRestoration = "useScrollRestoration";
})(N9 || (N9 = {}));
function HRe(e) {
  return e + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function AQ(e) {
  let t = k.useContext(Gb);
  return t || (ct.env.NODE_ENV !== "production" ? $t(!1, HRe(e)) : $t(!1)), t;
}
function qRe(e, t) {
  let {
    target: n,
    replace: r,
    state: i,
    preventScrollReset: o,
    relative: s,
    unstable_viewTransition: c
  } = t === void 0 ? {} : t, u = La(), f = Kc(), p = px(e, {
    relative: s
  });
  return k.useCallback((y) => {
    if (kRe(y, n)) {
      y.preventDefault();
      let v = r !== void 0 ? r : ty(f) === ty(p);
      u(e, {
        replace: v,
        state: i,
        preventScrollReset: o,
        relative: s,
        unstable_viewTransition: c
      });
    }
  }, [f, u, p, r, i, n, e, o, s, c]);
}
function WRe() {
  if (typeof document > "u")
    throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
}
let GRe = 0, KRe = () => "__" + String(++GRe) + "__";
function YRe() {
  let {
    router: e
  } = AQ(t8.UseSubmit), {
    basename: t
  } = k.useContext(ic), n = pRe();
  return k.useCallback(function(r, i) {
    i === void 0 && (i = {}), WRe();
    let {
      action: o,
      method: s,
      encType: c,
      formData: u,
      body: f
    } = _Re(r, t);
    if (i.navigate === !1) {
      let p = i.fetcherKey || KRe();
      e.fetch(p, n, i.action || o, {
        preventScrollReset: i.preventScrollReset,
        formData: u,
        body: f,
        formMethod: i.method || s,
        formEncType: i.encType || c,
        unstable_flushSync: i.unstable_flushSync
      });
    } else
      e.navigate(i.action || o, {
        preventScrollReset: i.preventScrollReset,
        formData: u,
        body: f,
        formMethod: i.method || s,
        formEncType: i.encType || c,
        replace: i.replace,
        state: i.state,
        fromRouteId: n,
        unstable_flushSync: i.unstable_flushSync,
        unstable_viewTransition: i.unstable_viewTransition
      });
  }, [e, t, n]);
}
function QRe(e, t) {
  let {
    relative: n
  } = t === void 0 ? {} : t, {
    basename: r
  } = k.useContext(ic), i = k.useContext(Gc);
  i || (ct.env.NODE_ENV !== "production" ? $t(!1, "useFormAction must be used inside a RouteContext") : $t(!1));
  let [o] = i.matches.slice(-1), s = gb({}, px(e || ".", {
    relative: n
  })), c = Kc();
  if (e == null) {
    s.search = c.search;
    let u = new URLSearchParams(s.search);
    u.has("index") && u.get("index") === "" && (u.delete("index"), s.search = u.toString() ? "?" + u.toString() : "");
  }
  return (!e || e === ".") && o.route.index && (s.search = s.search ? s.search.replace(/^\?/, "?index&") : "?index"), r !== "/" && (s.pathname = s.pathname === "/" ? r : ju([r, s.pathname])), ty(s);
}
function XRe(e, t) {
  t === void 0 && (t = {});
  let n = k.useContext(uN);
  n == null && (ct.env.NODE_ENV !== "production" ? $t(!1, "`unstable_useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?") : $t(!1));
  let {
    basename: r
  } = AQ(t8.useViewTransitionState), i = px(e, {
    relative: t.relative
  });
  if (!n.isTransitioning)
    return !1;
  let o = Vc(n.currentLocation.pathname, r) || n.currentLocation.pathname, s = Vc(n.nextLocation.pathname, r) || n.nextLocation.pathname;
  return CC(i.pathname, s) != null || CC(i.pathname, o) != null;
}
const TQ = () => {
  const e = Kl("/"), t = Kl("/positions"), n = Kl("/activity");
  return e || t || n;
}, JRe = () => /* @__PURE__ */ S.jsx("svg", { width: 16, height: 16, fill: "none", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ S.jsx(
  "path",
  {
    d: "m11 9 2 2-2 2M3 11h10M5 7 3 5l2-2M13 5H3",
    stroke: "#999",
    strokeWidth: 1.5,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
) }), ZRe = () => /* @__PURE__ */ S.jsx("svg", { width: 24, height: 24, fill: "none", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ S.jsx(
  "path",
  {
    d: "M15 19.5 7.5 12 15 4.5",
    stroke: "#999",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
) }), eOe = () => /* @__PURE__ */ S.jsxs("svg", { width: 16, height: 16, fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
  /* @__PURE__ */ S.jsx(
    "path",
    {
      d: "M8 5v3M10.6 9.5 8 8M11.513 6.231h2.5v-2.5",
      stroke: "#999",
      strokeWidth: 1.5,
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }
  ),
  /* @__PURE__ */ S.jsx(
    "path",
    {
      d: "M11.888 11.887a5.5 5.5 0 1 1 0-7.775l2.125 2.12",
      stroke: "#999",
      strokeWidth: 1.5,
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }
  )
] }), tOe = () => /* @__PURE__ */ S.jsx("svg", { width: 16, height: 16, fill: "none", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ S.jsx(
  "path",
  {
    d: "M13.5 5h-11a.5.5 0 0 0-.5.5v2a.5.5 0 0 0 .5.5h11a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 0-.5-.5ZM13 8v4.5a.5.5 0 0 1-.5.5h-9a.5.5 0 0 1-.5-.5V8M8 5v8M10.831 4.294C10.12 5 8 5 8 5s0-2.119.706-2.831a1.503 1.503 0 0 1 2.125 2.125ZM5.169 4.294C5.88 5 7.999 5 7.999 5s0-2.119-.705-2.831a1.503 1.503 0 0 0-2.125 2.125Z",
    stroke: "#999",
    strokeWidth: 1.5,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
) }), nOe = () => /* @__PURE__ */ S.jsxs("svg", { width: 32, height: 32, fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
  /* @__PURE__ */ S.jsx(
    "path",
    {
      d: "M16 25a9 9 0 1 0 0-18 9 9 0 0 0 0 18Z",
      stroke: "#999",
      strokeWidth: 2,
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }
  ),
  /* @__PURE__ */ S.jsx(
    "path",
    {
      d: "M16 22a1.125 1.125 0 1 0 0-2.25A1.125 1.125 0 0 0 16 22Z",
      fill: "#999"
    }
  ),
  /* @__PURE__ */ S.jsx(
    "path",
    {
      d: "M16 17.5v-.75a2.625 2.625 0 1 0-2.625-2.625",
      stroke: "#999",
      strokeWidth: 2,
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }
  )
] }), Pg = (e) => /* @__PURE__ */ S.jsx(
  "svg",
  {
    viewBox: "0 0 24 24",
    width: e.hw ?? 24,
    height: e.hw ?? 24,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: /* @__PURE__ */ S.jsx(
      "path",
      {
        d: "m18.75 5.25-13.5 13.5M18.75 18.75 5.25 5.25",
        stroke: e.color ? ti.color[e.color] : ti.color.textMuted,
        strokeWidth: e.strokeWidth ?? 2,
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    )
  }
), fy = ({ size: e = 12 }) => /* @__PURE__ */ S.jsx(
  "svg",
  {
    width: e,
    height: e,
    viewBox: "0 0 12 12",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: /* @__PURE__ */ S.jsx(
      "path",
      {
        d: "M9.75 4.5L6 8.25L2.25 4.5",
        stroke: ti.color.text,
        strokeWidth: "1.33333",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    )
  }
), rOe = () => /* @__PURE__ */ S.jsx(
  "svg",
  {
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: ti.color.text,
    xmlns: "http://www.w3.org/2000/svg",
    children: /* @__PURE__ */ S.jsx(
      "path",
      {
        d: "M13.5307 12.4693L10.5625 9.49998C11.4525 8.34027 11.868 6.88547 11.7247 5.43069C11.5815 3.97591 10.8902 2.63008 9.79119 1.66622C8.69215 0.702356 7.26764 0.192633 5.8066 0.24045C4.34557 0.288266 2.95742 0.890041 1.92376 1.9237C0.890102 2.95736 0.288327 4.34551 0.240511 5.80654C0.192694 7.26757 0.702417 8.69209 1.66628 9.79113C2.63014 10.8902 3.97597 11.5814 5.43075 11.7247C6.88553 11.8679 8.34033 11.4524 9.50004 10.5625L12.4707 13.5337C12.5404 13.6035 12.6232 13.6588 12.7144 13.6966C12.8056 13.7343 12.9032 13.7538 13.0019 13.7538C13.1006 13.7538 13.1983 13.7343 13.2894 13.6966C13.3806 13.6588 13.4634 13.6035 13.5332 13.5337C13.6029 13.464 13.6583 13.3811 13.696 13.29C13.7338 13.1988 13.7532 13.1011 13.7532 13.0025C13.7532 12.9038 13.7338 12.8061 13.696 12.715C13.6583 12.6238 13.6029 12.541 13.5332 12.4712L13.5307 12.4693ZM1.75004 5.99998C1.75004 5.15941 1.99929 4.33771 2.46629 3.6388C2.93329 2.93989 3.59705 2.39516 4.37363 2.07349C5.15022 1.75182 6.00475 1.66765 6.82917 1.83164C7.65359 1.99563 8.41087 2.4004 9.00524 2.99477C9.59961 3.58914 10.0044 4.34642 10.1684 5.17084C10.3324 5.99526 10.2482 6.84979 9.92652 7.62638C9.60485 8.40297 9.06012 9.06672 8.36121 9.53372C7.6623 10.0007 6.84061 10.25 6.00004 10.25C4.87322 10.2488 3.79289 9.80068 2.99611 9.0039C2.19933 8.20712 1.75119 7.12679 1.75004 5.99998Z",
        fill: ti.color.text
      }
    )
  }
);
var iOe = "_33v9qv0", oOe = "_33v9qv2 _33v9qv1 yv8y4rn", aOe = "_33v9qv3";
const sOe = () => {
  const e = Bi(), { address: t } = fr(), n = k.useContext(sP);
  return /* @__PURE__ */ S.jsx(rx.Custom, { children: ({ account: r, openAccountModal: i }) => he.fromNullable(r).map((o) => /* @__PURE__ */ S.jsx(
    ae,
    {
      "data-rk": "account-modal-container",
      borderRadius: "2xl",
      background: "backgroundMuted",
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      className: iOe,
      onClick: () => {
        e("accountModalOpened"), i();
      },
      children: /* @__PURE__ */ S.jsxs(
        ae,
        {
          as: "button",
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          paddingLeft: "2",
          py: "2",
          children: [
            o.ensAvatar ? /* @__PURE__ */ S.jsx(ae, { as: "img", src: o.ensAvatar, hw: "6", borderRadius: "half" }) : /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
              /* @__PURE__ */ S.jsx(
                ae,
                {
                  borderRadius: "half",
                  marginRight: "2",
                  className: aOe,
                  children: /* @__PURE__ */ S.jsx(n, { address: t, size: 24 })
                }
              ),
              /* @__PURE__ */ S.jsx(Ge, { className: oOe, children: o.ensName ?? o.displayName })
            ] }),
            /* @__PURE__ */ S.jsx(ae, { mx: "2", children: /* @__PURE__ */ S.jsx(fy, {}) })
          ]
        }
      )
    }
  )).extractNullable() });
};
var lOe = "_1910ja40", cOe = "_1910ja42 _1910ja41 yv8y4rn";
const uOe = () => {
  const e = Bi(), { t } = ln(), { variant: n } = dr();
  return /* @__PURE__ */ S.jsx(rx.Custom, { children: ({ chain: r, openChainModal: i }) => he.fromNullable(r).map((o) => /* @__PURE__ */ S.jsx(
    ae,
    {
      "data-rk": "chain-modal-container",
      borderRadius: "2xl",
      background: "backgroundMuted",
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      className: lOe,
      onClick: () => {
        e("chainModalOpened"), i();
      },
      children: he.fromFalsy(o.unsupported && n !== "zerion").map(() => /* @__PURE__ */ S.jsx(ae, { px: "2", py: "2", children: /* @__PURE__ */ S.jsx(Ge, { variant: { type: "danger" }, children: t("shared.unsupported_network") }) })).orDefaultLazy(() => /* @__PURE__ */ S.jsxs(
        ae,
        {
          as: "button",
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          paddingLeft: "2",
          py: "2",
          children: [
            o.iconUrl && /* @__PURE__ */ S.jsx(
              ae,
              {
                as: "img",
                borderRadius: "full",
                hw: "6",
                src: o.iconUrl
              }
            ),
            o.name && /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
              /* @__PURE__ */ S.jsx(ae, { marginLeft: "2", children: /* @__PURE__ */ S.jsx(Ge, { className: cOe, children: o.name }) }),
              /* @__PURE__ */ S.jsx(ae, { mx: "2", children: /* @__PURE__ */ S.jsx(fy, {}) })
            ] })
          ]
        }
      ))
    }
  )).extractNullable() });
};
var dOe = "v3r9r70", fOe = "v3r9r72 v3r9r71 yv8y4rpl";
const NA = (e) => {
  const t = k.useRef(null), n = Pr(e);
  return tf(() => {
    if (!t.current) return;
    const r = new ResizeObserver((i) => {
      const o = i[0];
      n.current(o.target.clientHeight);
    });
    return r.observe(t.current), () => {
      r.disconnect();
    };
  }, [n]), { containerRef: t };
}, mx = (e) => {
  const t = k.createContext(void 0), n = (o, s) => k.createElement(t.Provider, o, s);
  return [() => {
    const o = k.useContext(t);
    if (o == null)
      throw new Error("useStateContext must be used inside a StateProvider.");
    return o;
  }, ({
    children: o,
    initialValue: s
  }) => {
    const c = k.useState(
      s !== void 0 ? s : e
    );
    return n({ value: c }, o);
  }, t];
}, [_Q, hOe] = mx(0), pOe = () => NA(_Q()[1]), mOe = () => {
  const e = La(), { containerRef: t } = pOe(), { variant: n } = dr(), { isConnected: r, isConnecting: i, connector: o } = fr(), s = k.useMemo(
    () => he.fromNullable(o).map(hK).orDefault(!1),
    [o]
  ), c = ox(), u = !TQ(), f = Bi(), p = () => {
    u && (f("backClicked"), e(-1));
  }, { mutate: y } = nSe(), v = () => {
    f("widgetDisconnectClicked"), y();
  };
  return /* @__PURE__ */ S.jsx(ae, { ref: t, "data-rk": "header", children: /* @__PURE__ */ S.jsxs(ae, { paddingTop: "4", paddingBottom: "1", children: [
    /* @__PURE__ */ S.jsxs(ae, { display: "flex", justifyContent: "space-between", alignItems: "center", children: [
      /* @__PURE__ */ S.jsx(
        ae,
        {
          hw: "7",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          children: u ? /* @__PURE__ */ S.jsx(
            ae,
            {
              as: "button",
              onClick: p,
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              children: /* @__PURE__ */ S.jsx(ZRe, {})
            }
          ) : /* @__PURE__ */ S.jsx(ae, {})
        }
      ),
      s && /* @__PURE__ */ S.jsx(
        ae,
        {
          as: "button",
          onClick: v,
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          children: /* @__PURE__ */ S.jsx(Pg, { hw: 24 })
        }
      )
    ] }),
    he.fromFalsy(
      !c.isLoading && c.data && n !== "zerion"
    ).map(() => /* @__PURE__ */ S.jsx(rx.Custom, { children: ({ account: w, chain: C, mounted: x }) => /* @__PURE__ */ S.jsx(
      ae,
      {
        className: zs({ [dOe]: !x }),
        "aria-hidden": !x,
        children: he.fromFalsy(
          (r || i) && C && w
        ).map(() => /* @__PURE__ */ S.jsxs(
          gi.div,
          {
            className: fOe,
            initial: { opacity: 0 },
            animate: { opacity: 1 },
            transition: { delay: 0.2, duration: 0.2 },
            children: [
              /* @__PURE__ */ S.jsx(uOe, {}),
              /* @__PURE__ */ S.jsx(sOe, {})
            ]
          }
        )).extractNullable()
      }
    ) })).extractNullable()
  ] }) });
}, eI = ({ children: e, className: t }) => /* @__PURE__ */ S.jsx(
  ae,
  {
    background: "backgroundMuted",
    display: "inline",
    px: "1",
    borderRadius: "lg",
    marginRight: "1",
    my: "1",
    as: "span",
    className: t,
    children: e
  }
);
var yOe = Wb({ defaultClassName: "_1qt23ex6 _1qt23ex0 yv8y4rrb yv8y4rrc", variantClassNames: { level: { h1: "_1qt23ex7", h2: "_1qt23ex8", h3: "_1qt23ex9", h4: "_1qt23exa" }, weight: { normal: "_1qt23exb _1qt23ex1 yv8y4ri", medium: "_1qt23exc _1qt23ex2 yv8y4rj", semibold: "_1qt23exd _1qt23ex3 yv8y4rk", bold: "_1qt23exe _1qt23ex4 yv8y4rl", extrabold: "_1qt23exf _1qt23ex5 yv8y4rm" } }, defaultVariants: { weight: "normal" }, compoundVariants: [] }), vOe = Wb({ defaultClassName: "_1qt23exr", variantClassNames: { weight: { normal: "_1qt23exs _1qt23exg yv8y4ri", medium: "_1qt23ext _1qt23exh yv8y4rj", semibold: "_1qt23exu _1qt23exi yv8y4rk", bold: "_1qt23exv _1qt23exj yv8y4rl", extrabold: "_1qt23exw _1qt23exk yv8y4rm" }, type: { accent: "_1qt23exx _1qt23exl yv8y4rr7 yv8y4rr8", regular: "_1qt23exy _1qt23exm yv8y4rrb yv8y4rrc", muted: "_1qt23exz _1qt23exn yv8y4rrd yv8y4rre", inverted: "_1qt23ex10 _1qt23exo yv8y4rr5 yv8y4rr6", white: "_1qt23ex11 _1qt23exp yv8y4rqz yv8y4rr0", danger: "_1qt23ex12 _1qt23exq yv8y4rrf yv8y4rrg" }, size: { large: "_1qt23ex13", medium: "_1qt23ex14", small: "_1qt23ex15" } }, defaultVariants: { type: "regular", size: "medium", weight: "medium" }, compoundVariants: [] });
const Ge = ({ children: e, variant: t, className: n, ...r }) => /* @__PURE__ */ S.jsx(
  ae,
  {
    as: "p",
    className: zs(n, vOe(t)),
    ...r,
    children: e
  }
), $u = ({ children: e, variant: t, className: n, ...r }) => /* @__PURE__ */ S.jsx(
  ae,
  {
    as: (t == null ? void 0 : t.level) ?? "h1",
    className: zs(yOe(t), n),
    ...r,
    children: e
  }
);
function Ln(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(i) {
    if (e == null || e(i), n === !1 || !i.defaultPrevented)
      return t == null ? void 0 : t(i);
  };
}
function gOe(e, t) {
  typeof e == "function" ? e(t) : e != null && (e.current = t);
}
function BA(...e) {
  return (t) => e.forEach((n) => gOe(n, t));
}
function Oo(...e) {
  return k.useCallback(BA(...e), e);
}
function bOe(e, t) {
  const n = k.createContext(t);
  function r(o) {
    const { children: s, ...c } = o, u = k.useMemo(() => c, Object.values(c));
    return /* @__PURE__ */ S.jsx(n.Provider, { value: u, children: s });
  }
  function i(o) {
    const s = k.useContext(n);
    if (s) return s;
    if (t !== void 0) return t;
    throw new Error(`\`${o}\` must be used within \`${e}\``);
  }
  return r.displayName = e + "Provider", [r, i];
}
function hy(e, t = []) {
  let n = [];
  function r(o, s) {
    const c = k.createContext(s), u = n.length;
    n = [...n, s];
    function f(y) {
      const { scope: v, children: w, ...C } = y, x = (v == null ? void 0 : v[e][u]) || c, A = k.useMemo(() => C, Object.values(C));
      return /* @__PURE__ */ S.jsx(x.Provider, { value: A, children: w });
    }
    function p(y, v) {
      const w = (v == null ? void 0 : v[e][u]) || c, C = k.useContext(w);
      if (C) return C;
      if (s !== void 0) return s;
      throw new Error(`\`${y}\` must be used within \`${o}\``);
    }
    return f.displayName = o + "Provider", [f, p];
  }
  const i = () => {
    const o = n.map((s) => k.createContext(s));
    return function(c) {
      const u = (c == null ? void 0 : c[e]) || o;
      return k.useMemo(
        () => ({ [`__scope${e}`]: { ...c, [e]: u } }),
        [c, u]
      );
    };
  };
  return i.scopeName = e, [r, wOe(i, ...t)];
}
function wOe(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(o) {
      const s = r.reduce((c, { useScope: u, scopeName: f }) => {
        const y = u(o)[`__scope${f}`];
        return { ...c, ...y };
      }, {});
      return k.useMemo(() => ({ [`__scope${t.scopeName}`]: s }), [s]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
var ny = globalThis != null && globalThis.document ? k.useLayoutEffect : () => {
}, COe = Qz.useId || (() => {
}), xOe = 0;
function Hm(e) {
  const [t, n] = k.useState(COe());
  return ny(() => {
    n((r) => r ?? String(xOe++));
  }, [e]), t ? `radix-${t}` : "";
}
function $c(e) {
  const t = k.useRef(e);
  return k.useEffect(() => {
    t.current = e;
  }), k.useMemo(() => (...n) => {
    var r;
    return (r = t.current) == null ? void 0 : r.call(t, ...n);
  }, []);
}
function LA({
  prop: e,
  defaultProp: t,
  onChange: n = () => {
  }
}) {
  const [r, i] = EOe({ defaultProp: t, onChange: n }), o = e !== void 0, s = o ? e : r, c = $c(n), u = k.useCallback(
    (f) => {
      if (o) {
        const y = typeof f == "function" ? f(e) : f;
        y !== e && c(y);
      } else
        i(f);
    },
    [o, e, i, c]
  );
  return [s, u];
}
function EOe({
  defaultProp: e,
  onChange: t
}) {
  const n = k.useState(e), [r] = n, i = k.useRef(r), o = $c(t);
  return k.useEffect(() => {
    i.current !== r && (o(r), i.current = r);
  }, [r, i, o]), n;
}
var bb = k.forwardRef((e, t) => {
  const { children: n, ...r } = e, i = k.Children.toArray(n), o = i.find(SOe);
  if (o) {
    const s = o.props.children, c = i.map((u) => u === o ? k.Children.count(s) > 1 ? k.Children.only(null) : k.isValidElement(s) ? s.props.children : null : u);
    return /* @__PURE__ */ S.jsx(SD, { ...r, ref: t, children: k.isValidElement(s) ? k.cloneElement(s, void 0, c) : null });
  }
  return /* @__PURE__ */ S.jsx(SD, { ...r, ref: t, children: n });
});
bb.displayName = "Slot";
var SD = k.forwardRef((e, t) => {
  const { children: n, ...r } = e;
  if (k.isValidElement(n)) {
    const i = AOe(n);
    return k.cloneElement(n, {
      ...kOe(r, n.props),
      // @ts-ignore
      ref: t ? BA(t, i) : i
    });
  }
  return k.Children.count(n) > 1 ? k.Children.only(null) : null;
});
SD.displayName = "SlotClone";
var RQ = ({ children: e }) => /* @__PURE__ */ S.jsx(S.Fragment, { children: e });
function SOe(e) {
  return k.isValidElement(e) && e.type === RQ;
}
function kOe(e, t) {
  const n = { ...t };
  for (const r in t) {
    const i = e[r], o = t[r];
    /^on[A-Z]/.test(r) ? i && o ? n[r] = (...c) => {
      o(...c), i(...c);
    } : i && (n[r] = i) : r === "style" ? n[r] = { ...i, ...o } : r === "className" && (n[r] = [i, o].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function AOe(e) {
  var r, i;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var TOe = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], Li = TOe.reduce((e, t) => {
  const n = k.forwardRef((r, i) => {
    const { asChild: o, ...s } = r, c = o ? bb : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ S.jsx(c, { ...s, ref: i });
  });
  return n.displayName = `Primitive.${t}`, { ...e, [t]: n };
}, {});
function OQ(e, t) {
  e && Wu.flushSync(() => e.dispatchEvent(t));
}
function _Oe(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = $c(e);
  k.useEffect(() => {
    const r = (i) => {
      i.key === "Escape" && n(i);
    };
    return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 });
  }, [n, t]);
}
var ROe = "DismissableLayer", kD = "dismissableLayer.update", OOe = "dismissableLayer.pointerDownOutside", IOe = "dismissableLayer.focusOutside", B9, IQ = k.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), jA = k.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: i,
      onFocusOutside: o,
      onInteractOutside: s,
      onDismiss: c,
      ...u
    } = e, f = k.useContext(IQ), [p, y] = k.useState(null), v = (p == null ? void 0 : p.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, w] = k.useState({}), C = Oo(t, (F) => y(F)), x = Array.from(f.layers), [A] = [...f.layersWithOutsidePointerEventsDisabled].slice(-1), R = x.indexOf(A), I = p ? x.indexOf(p) : -1, D = f.layersWithOutsidePointerEventsDisabled.size > 0, M = I >= R, L = POe((F) => {
      const O = F.target, z = [...f.branches].some((H) => H.contains(O));
      !M || z || (i == null || i(F), s == null || s(F), F.defaultPrevented || c == null || c());
    }, v), j = NOe((F) => {
      const O = F.target;
      [...f.branches].some((H) => H.contains(O)) || (o == null || o(F), s == null || s(F), F.defaultPrevented || c == null || c());
    }, v);
    return _Oe((F) => {
      I === f.layers.size - 1 && (r == null || r(F), !F.defaultPrevented && c && (F.preventDefault(), c()));
    }, v), k.useEffect(() => {
      if (p)
        return n && (f.layersWithOutsidePointerEventsDisabled.size === 0 && (B9 = v.body.style.pointerEvents, v.body.style.pointerEvents = "none"), f.layersWithOutsidePointerEventsDisabled.add(p)), f.layers.add(p), L9(), () => {
          n && f.layersWithOutsidePointerEventsDisabled.size === 1 && (v.body.style.pointerEvents = B9);
        };
    }, [p, v, n, f]), k.useEffect(() => () => {
      p && (f.layers.delete(p), f.layersWithOutsidePointerEventsDisabled.delete(p), L9());
    }, [p, f]), k.useEffect(() => {
      const F = () => w({});
      return document.addEventListener(kD, F), () => document.removeEventListener(kD, F);
    }, []), /* @__PURE__ */ S.jsx(
      Li.div,
      {
        ...u,
        ref: C,
        style: {
          pointerEvents: D ? M ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: Ln(e.onFocusCapture, j.onFocusCapture),
        onBlurCapture: Ln(e.onBlurCapture, j.onBlurCapture),
        onPointerDownCapture: Ln(
          e.onPointerDownCapture,
          L.onPointerDownCapture
        )
      }
    );
  }
);
jA.displayName = ROe;
var DOe = "DismissableLayerBranch", MOe = k.forwardRef((e, t) => {
  const n = k.useContext(IQ), r = k.useRef(null), i = Oo(t, r);
  return k.useEffect(() => {
    const o = r.current;
    if (o)
      return n.branches.add(o), () => {
        n.branches.delete(o);
      };
  }, [n.branches]), /* @__PURE__ */ S.jsx(Li.div, { ...e, ref: i });
});
MOe.displayName = DOe;
function POe(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = $c(e), r = k.useRef(!1), i = k.useRef(() => {
  });
  return k.useEffect(() => {
    const o = (c) => {
      if (c.target && !r.current) {
        let u = function() {
          DQ(
            OOe,
            n,
            f,
            { discrete: !0 }
          );
        };
        const f = { originalEvent: c };
        c.pointerType === "touch" ? (t.removeEventListener("click", i.current), i.current = u, t.addEventListener("click", i.current, { once: !0 })) : u();
      } else
        t.removeEventListener("click", i.current);
      r.current = !1;
    }, s = window.setTimeout(() => {
      t.addEventListener("pointerdown", o);
    }, 0);
    return () => {
      window.clearTimeout(s), t.removeEventListener("pointerdown", o), t.removeEventListener("click", i.current);
    };
  }, [t, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function NOe(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = $c(e), r = k.useRef(!1);
  return k.useEffect(() => {
    const i = (o) => {
      o.target && !r.current && DQ(IOe, n, { originalEvent: o }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", i), () => t.removeEventListener("focusin", i);
  }, [t, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function L9() {
  const e = new CustomEvent(kD);
  document.dispatchEvent(e);
}
function DQ(e, t, n, { discrete: r }) {
  const i = n.originalEvent.target, o = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && i.addEventListener(e, t, { once: !0 }), r ? OQ(i, o) : i.dispatchEvent(o);
}
var tI = "focusScope.autoFocusOnMount", nI = "focusScope.autoFocusOnUnmount", j9 = { bubbles: !1, cancelable: !0 }, BOe = "FocusScope", fN = k.forwardRef((e, t) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: i,
    onUnmountAutoFocus: o,
    ...s
  } = e, [c, u] = k.useState(null), f = $c(i), p = $c(o), y = k.useRef(null), v = Oo(t, (x) => u(x)), w = k.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  k.useEffect(() => {
    if (r) {
      let x = function(D) {
        if (w.paused || !c) return;
        const M = D.target;
        c.contains(M) ? y.current = M : Ah(y.current, { select: !0 });
      }, A = function(D) {
        if (w.paused || !c) return;
        const M = D.relatedTarget;
        M !== null && (c.contains(M) || Ah(y.current, { select: !0 }));
      }, R = function(D) {
        if (document.activeElement === document.body)
          for (const L of D)
            L.removedNodes.length > 0 && Ah(c);
      };
      document.addEventListener("focusin", x), document.addEventListener("focusout", A);
      const I = new MutationObserver(R);
      return c && I.observe(c, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", x), document.removeEventListener("focusout", A), I.disconnect();
      };
    }
  }, [r, c, w.paused]), k.useEffect(() => {
    if (c) {
      U9.add(w);
      const x = document.activeElement;
      if (!c.contains(x)) {
        const R = new CustomEvent(tI, j9);
        c.addEventListener(tI, f), c.dispatchEvent(R), R.defaultPrevented || (LOe(VOe(MQ(c)), { select: !0 }), document.activeElement === x && Ah(c));
      }
      return () => {
        c.removeEventListener(tI, f), setTimeout(() => {
          const R = new CustomEvent(nI, j9);
          c.addEventListener(nI, p), c.dispatchEvent(R), R.defaultPrevented || Ah(x ?? document.body, { select: !0 }), c.removeEventListener(nI, p), U9.remove(w);
        }, 0);
      };
    }
  }, [c, f, p, w]);
  const C = k.useCallback(
    (x) => {
      if (!n && !r || w.paused) return;
      const A = x.key === "Tab" && !x.altKey && !x.ctrlKey && !x.metaKey, R = document.activeElement;
      if (A && R) {
        const I = x.currentTarget, [D, M] = jOe(I);
        D && M ? !x.shiftKey && R === M ? (x.preventDefault(), n && Ah(D, { select: !0 })) : x.shiftKey && R === D && (x.preventDefault(), n && Ah(M, { select: !0 })) : R === I && x.preventDefault();
      }
    },
    [n, r, w.paused]
  );
  return /* @__PURE__ */ S.jsx(Li.div, { tabIndex: -1, ...s, ref: v, onKeyDown: C });
});
fN.displayName = BOe;
function LOe(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const r of e)
    if (Ah(r, { select: t }), document.activeElement !== n) return;
}
function jOe(e) {
  const t = MQ(e), n = F9(t, e), r = F9(t.reverse(), e);
  return [n, r];
}
function MQ(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const i = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function F9(e, t) {
  for (const n of e)
    if (!FOe(n, { upTo: t })) return n;
}
function FOe(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function UOe(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function Ah(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== n && UOe(e) && t && e.select();
  }
}
var U9 = zOe();
function zOe() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && (n == null || n.pause()), e = z9(e, t), e.unshift(t);
    },
    remove(t) {
      var n;
      e = z9(e, t), (n = e[0]) == null || n.resume();
    }
  };
}
function z9(e, t) {
  const n = [...e], r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
function VOe(e) {
  return e.filter((t) => t.tagName !== "A");
}
var $Oe = "Portal", hN = k.forwardRef((e, t) => {
  var c;
  const { container: n, ...r } = e, [i, o] = k.useState(!1);
  ny(() => o(!0), []);
  const s = n || i && ((c = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : c.body);
  return s ? NW.createPortal(/* @__PURE__ */ S.jsx(Li.div, { ...r, ref: t }), s) : null;
});
hN.displayName = $Oe;
function HOe(e, t) {
  return k.useReducer((n, r) => t[n][r] ?? n, e);
}
var uf = (e) => {
  const { present: t, children: n } = e, r = qOe(t), i = typeof n == "function" ? n({ present: r.isPresent }) : k.Children.only(n), o = Oo(r.ref, WOe(i));
  return typeof n == "function" || r.isPresent ? k.cloneElement(i, { ref: o }) : null;
};
uf.displayName = "Presence";
function qOe(e) {
  const [t, n] = k.useState(), r = k.useRef({}), i = k.useRef(e), o = k.useRef("none"), s = e ? "mounted" : "unmounted", [c, u] = HOe(s, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return k.useEffect(() => {
    const f = Hk(r.current);
    o.current = c === "mounted" ? f : "none";
  }, [c]), ny(() => {
    const f = r.current, p = i.current;
    if (p !== e) {
      const v = o.current, w = Hk(f);
      e ? u("MOUNT") : w === "none" || (f == null ? void 0 : f.display) === "none" ? u("UNMOUNT") : u(p && v !== w ? "ANIMATION_OUT" : "UNMOUNT"), i.current = e;
    }
  }, [e, u]), ny(() => {
    if (t) {
      const f = (y) => {
        const w = Hk(r.current).includes(y.animationName);
        y.target === t && w && Wu.flushSync(() => u("ANIMATION_END"));
      }, p = (y) => {
        y.target === t && (o.current = Hk(r.current));
      };
      return t.addEventListener("animationstart", p), t.addEventListener("animationcancel", f), t.addEventListener("animationend", f), () => {
        t.removeEventListener("animationstart", p), t.removeEventListener("animationcancel", f), t.removeEventListener("animationend", f);
      };
    } else
      u("ANIMATION_END");
  }, [t, u]), {
    isPresent: ["mounted", "unmountSuspended"].includes(c),
    ref: k.useCallback((f) => {
      f && (r.current = getComputedStyle(f)), n(f);
    }, [])
  };
}
function Hk(e) {
  return (e == null ? void 0 : e.animationName) || "none";
}
function WOe(e) {
  var r, i;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var rI = 0;
function PQ() {
  k.useEffect(() => {
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e[0] ?? V9()), document.body.insertAdjacentElement("beforeend", e[1] ?? V9()), rI++, () => {
      rI === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), rI--;
    };
  }, []);
}
function V9() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none", e;
}
var GOe = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, cg = /* @__PURE__ */ new WeakMap(), qk = /* @__PURE__ */ new WeakMap(), Wk = {}, iI = 0, NQ = function(e) {
  return e && (e.host || NQ(e.parentNode));
}, KOe = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var r = NQ(n);
    return r && e.contains(r) ? r : null;
  }).filter(function(n) {
    return !!n;
  });
}, YOe = function(e, t, n, r) {
  var i = KOe(t, Array.isArray(e) ? e : [e]);
  Wk[n] || (Wk[n] = /* @__PURE__ */ new WeakMap());
  var o = Wk[n], s = [], c = /* @__PURE__ */ new Set(), u = new Set(i), f = function(y) {
    !y || c.has(y) || (c.add(y), f(y.parentNode));
  };
  i.forEach(f);
  var p = function(y) {
    !y || u.has(y) || Array.prototype.forEach.call(y.children, function(v) {
      if (c.has(v))
        p(v);
      else {
        var w = v.getAttribute(r), C = w !== null && w !== "false", x = (cg.get(v) || 0) + 1, A = (o.get(v) || 0) + 1;
        cg.set(v, x), o.set(v, A), s.push(v), x === 1 && C && qk.set(v, !0), A === 1 && v.setAttribute(n, "true"), C || v.setAttribute(r, "true");
      }
    });
  };
  return p(t), c.clear(), iI++, function() {
    s.forEach(function(y) {
      var v = cg.get(y) - 1, w = o.get(y) - 1;
      cg.set(y, v), o.set(y, w), v || (qk.has(y) || y.removeAttribute(r), qk.delete(y)), w || y.removeAttribute(n);
    }), iI--, iI || (cg = /* @__PURE__ */ new WeakMap(), cg = /* @__PURE__ */ new WeakMap(), qk = /* @__PURE__ */ new WeakMap(), Wk = {});
  };
}, BQ = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(e) ? e : [e]), i = GOe(e);
  return i ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live]"))), YOe(r, i, n, "aria-hidden")) : function() {
    return null;
  };
}, pN = "Dialog", [LQ, Bje] = hy(pN), [QOe, Yc] = LQ(pN), jQ = (e) => {
  const {
    __scopeDialog: t,
    children: n,
    open: r,
    defaultOpen: i,
    onOpenChange: o,
    modal: s = !0
  } = e, c = k.useRef(null), u = k.useRef(null), [f = !1, p] = LA({
    prop: r,
    defaultProp: i,
    onChange: o
  });
  return /* @__PURE__ */ S.jsx(
    QOe,
    {
      scope: t,
      triggerRef: c,
      contentRef: u,
      contentId: Hm(),
      titleId: Hm(),
      descriptionId: Hm(),
      open: f,
      onOpenChange: p,
      onOpenToggle: k.useCallback(() => p((y) => !y), [p]),
      modal: s,
      children: n
    }
  );
};
jQ.displayName = pN;
var FQ = "DialogTrigger", UQ = k.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Yc(FQ, n), o = Oo(t, i.triggerRef);
    return /* @__PURE__ */ S.jsx(
      Li.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": i.open,
        "aria-controls": i.contentId,
        "data-state": vN(i.open),
        ...r,
        ref: o,
        onClick: Ln(e.onClick, i.onOpenToggle)
      }
    );
  }
);
UQ.displayName = FQ;
var mN = "DialogPortal", [XOe, zQ] = LQ(mN, {
  forceMount: void 0
}), VQ = (e) => {
  const { __scopeDialog: t, forceMount: n, children: r, container: i } = e, o = Yc(mN, t);
  return /* @__PURE__ */ S.jsx(XOe, { scope: t, forceMount: n, children: k.Children.map(r, (s) => /* @__PURE__ */ S.jsx(uf, { present: n || o.open, children: /* @__PURE__ */ S.jsx(hN, { asChild: !0, container: i, children: s }) })) });
};
VQ.displayName = mN;
var n8 = "DialogOverlay", $Q = k.forwardRef(
  (e, t) => {
    const n = zQ(n8, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, o = Yc(n8, e.__scopeDialog);
    return o.modal ? /* @__PURE__ */ S.jsx(uf, { present: r || o.open, children: /* @__PURE__ */ S.jsx(JOe, { ...i, ref: t }) }) : null;
  }
);
$Q.displayName = n8;
var JOe = k.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Yc(n8, n);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ S.jsx(J8, { as: bb, allowPinchZoom: !0, shards: [i.contentRef], children: /* @__PURE__ */ S.jsx(
        Li.div,
        {
          "data-state": vN(i.open),
          ...r,
          ref: t,
          style: { pointerEvents: "auto", ...r.style }
        }
      ) })
    );
  }
), ry = "DialogContent", HQ = k.forwardRef(
  (e, t) => {
    const n = zQ(ry, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, o = Yc(ry, e.__scopeDialog);
    return /* @__PURE__ */ S.jsx(uf, { present: r || o.open, children: o.modal ? /* @__PURE__ */ S.jsx(ZOe, { ...i, ref: t }) : /* @__PURE__ */ S.jsx(eIe, { ...i, ref: t }) });
  }
);
HQ.displayName = ry;
var ZOe = k.forwardRef(
  (e, t) => {
    const n = Yc(ry, e.__scopeDialog), r = k.useRef(null), i = Oo(t, n.contentRef, r);
    return k.useEffect(() => {
      const o = r.current;
      if (o) return BQ(o);
    }, []), /* @__PURE__ */ S.jsx(
      qQ,
      {
        ...e,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Ln(e.onCloseAutoFocus, (o) => {
          var s;
          o.preventDefault(), (s = n.triggerRef.current) == null || s.focus();
        }),
        onPointerDownOutside: Ln(e.onPointerDownOutside, (o) => {
          const s = o.detail.originalEvent, c = s.button === 0 && s.ctrlKey === !0;
          (s.button === 2 || c) && o.preventDefault();
        }),
        onFocusOutside: Ln(
          e.onFocusOutside,
          (o) => o.preventDefault()
        )
      }
    );
  }
), eIe = k.forwardRef(
  (e, t) => {
    const n = Yc(ry, e.__scopeDialog), r = k.useRef(!1), i = k.useRef(!1);
    return /* @__PURE__ */ S.jsx(
      qQ,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (o) => {
          var s, c;
          (s = e.onCloseAutoFocus) == null || s.call(e, o), o.defaultPrevented || (r.current || (c = n.triggerRef.current) == null || c.focus(), o.preventDefault()), r.current = !1, i.current = !1;
        },
        onInteractOutside: (o) => {
          var u, f;
          (u = e.onInteractOutside) == null || u.call(e, o), o.defaultPrevented || (r.current = !0, o.detail.originalEvent.type === "pointerdown" && (i.current = !0));
          const s = o.target;
          ((f = n.triggerRef.current) == null ? void 0 : f.contains(s)) && o.preventDefault(), o.detail.originalEvent.type === "focusin" && i.current && o.preventDefault();
        }
      }
    );
  }
), qQ = k.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: i, onCloseAutoFocus: o, ...s } = e, c = Yc(ry, n), u = k.useRef(null), f = Oo(t, u);
    return PQ(), /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
      /* @__PURE__ */ S.jsx(
        fN,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: i,
          onUnmountAutoFocus: o,
          children: /* @__PURE__ */ S.jsx(
            jA,
            {
              role: "dialog",
              id: c.contentId,
              "aria-describedby": c.descriptionId,
              "aria-labelledby": c.titleId,
              "data-state": vN(c.open),
              ...s,
              ref: f,
              onDismiss: () => c.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
        /* @__PURE__ */ S.jsx(rIe, { titleId: c.titleId }),
        /* @__PURE__ */ S.jsx(oIe, { contentRef: u, descriptionId: c.descriptionId })
      ] })
    ] });
  }
), yN = "DialogTitle", WQ = k.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Yc(yN, n);
    return /* @__PURE__ */ S.jsx(Li.h2, { id: i.titleId, ...r, ref: t });
  }
);
WQ.displayName = yN;
var GQ = "DialogDescription", tIe = k.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Yc(GQ, n);
    return /* @__PURE__ */ S.jsx(Li.p, { id: i.descriptionId, ...r, ref: t });
  }
);
tIe.displayName = GQ;
var KQ = "DialogClose", nIe = k.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Yc(KQ, n);
    return /* @__PURE__ */ S.jsx(
      Li.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: Ln(e.onClick, () => i.onOpenChange(!1))
      }
    );
  }
);
nIe.displayName = KQ;
function vN(e) {
  return e ? "open" : "closed";
}
var YQ = "DialogTitleWarning", [Lje, QQ] = bOe(YQ, {
  contentName: ry,
  titleName: yN,
  docsSlug: "dialog"
}), rIe = ({ titleId: e }) => {
  const t = QQ(YQ), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
  return k.useEffect(() => {
    if (e) {
      const r = document.getElementById(e);
    }
  }, [n, e]), null;
}, iIe = "DialogDescriptionWarning", oIe = ({ contentRef: e, descriptionId: t }) => {
  const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${QQ(iIe).contentName}}.`;
  return k.useEffect(() => {
    var o;
    const i = (o = e.current) == null ? void 0 : o.getAttribute("aria-describedby");
    if (t && i) {
      const s = document.getElementById(t);
    }
  }, [r, e, t]), null;
}, aIe = jQ, wb = UQ, sIe = VQ, lIe = $Q, cIe = HQ, $9 = WQ, uIe = "VisuallyHidden", XQ = k.forwardRef(
  (e, t) => /* @__PURE__ */ S.jsx(
    Li.span,
    {
      ...e,
      ref: t,
      style: {
        // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
        position: "absolute",
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        ...e.style
      }
    }
  )
);
XQ.displayName = uIe;
var JQ = XQ;
const FA = "stakekit", AD = `[data-rk="${FA}"]`;
var dIe = Wb({ defaultClassName: "asebzi1 asebzi0 yv8y4re6 yv8y4re3 yv8y4rco yv8y4rcl yv8y4r9l yv8y4rb3 yv8y4r2n yv8y4rg3 yv8y4rfj yv8y4rx yv8y4r1a yv8y4rvv yv8y4rvw", variantClassNames: { hover: { disabled: "asebzi2", enabled: "asebzi3" }, type: { disabled: "asebzi4", enabled: "asebzi5" } }, defaultVariants: { hover: "enabled", type: "enabled" }, compoundVariants: [] });
const UA = ({
  children: e,
  onClick: t,
  testId: n,
  variant: r,
  className: i,
  ...o
}) => /* @__PURE__ */ S.jsx(
  ae,
  {
    className: zs(dIe(r), i),
    onClick: t,
    "data-testid": n,
    ...o,
    children: e
  }
);
var fIe = "_7eq6502", hIe = "_7eq6503", pIe = "_7eq6505 _7eq6504 yv8y4r9n yv8y4rb5 yv8y4rj7 yv8y4rwv yv8y4rww", mIe = "_7eq6506", yIe = "_7eq6507";
const ZQ = k.createContext(
  void 0
), eX = () => {
  const e = k.useContext(ZQ);
  if (!e)
    throw new Error("SelectModalContext is not provided");
  return e;
}, vIe = ({
  children: e,
  trigger: t,
  title: n,
  onSearch: r,
  searchValue: i,
  inputPlaceholder: o,
  onClose: s,
  onOpen: c,
  isLoading: u,
  errorMessage: f,
  disableClose: p,
  hideTopBar: y
}) => {
  const { isOpen: v, setOpen: w } = eX(), C = Pr(s), x = Pr(c);
  k.useEffect(() => {
    var R, I;
    v ? (I = x.current) == null || I.call(x) : (R = C.current) == null || R.call(C);
  }, [v, C, x]);
  const A = !!n || !y || r;
  return /* @__PURE__ */ S.jsxs(aIe, { open: v, onOpenChange: w, children: [
    t,
    /* @__PURE__ */ S.jsx(sIe, { children: /* @__PURE__ */ S.jsxs(ae, { className: fIe, "data-select-modal": !0, "data-rk": FA, children: [
      /* @__PURE__ */ S.jsx(lIe, { onClick: () => w(!1), className: hIe }),
      /* @__PURE__ */ S.jsx(
        cIe,
        {
          "data-testid": "select-modal__container",
          className: pIe,
          "aria-describedby": void 0,
          children: /* @__PURE__ */ S.jsxs(ae, { display: "flex", flexDirection: "column", height: "full", children: [
            A && /* @__PURE__ */ S.jsxs(
              ae,
              {
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                px: "4",
                children: [
                  /* @__PURE__ */ S.jsxs(ae, { flex: 1, display: "flex", alignItems: "center", gap: "2", children: [
                    n ? /* @__PURE__ */ S.jsx($9, { children: /* @__PURE__ */ S.jsx(
                      Ge,
                      {
                        "data-testid": "select-modal__title",
                        variant: { weight: "bold", size: "large" },
                        children: n
                      }
                    ) }) : /* @__PURE__ */ S.jsx(JQ, { asChild: !0, children: /* @__PURE__ */ S.jsx($9, { children: "Selection Modal" }) }),
                    u && /* @__PURE__ */ S.jsx(Wl, {})
                  ] }),
                  !p && /* @__PURE__ */ S.jsx(ae, { as: "button", onClick: () => w(!1), children: /* @__PURE__ */ S.jsx(Pg, {}) })
                ]
              }
            ),
            r && /* @__PURE__ */ S.jsxs(
              ae,
              {
                display: "flex",
                mx: "4",
                my: "2",
                background: "tokenSelectBackground",
                borderRadius: "xl",
                alignItems: "center",
                as: "label",
                children: [
                  /* @__PURE__ */ S.jsx(ae, { mx: "3", display: "flex", alignItems: "center", children: /* @__PURE__ */ S.jsx(rOe, {}) }),
                  /* @__PURE__ */ S.jsx(
                    ae,
                    {
                      "data-testid": "select-modal__search-input",
                      className: mIe,
                      as: "input",
                      border: "none",
                      flex: 1,
                      py: "3",
                      borderRadius: "xl",
                      color: "text",
                      placeholder: o ?? "",
                      value: i,
                      onChange: (R) => r(R.target.value)
                    }
                  )
                ]
              }
            ),
            !!f && /* @__PURE__ */ S.jsx(
              ae,
              {
                display: "flex",
                justifyContent: "center",
                marginTop: "4",
                marginBottom: "2",
                children: /* @__PURE__ */ S.jsx(Ge, { variant: { type: "danger" }, children: f })
              }
            ),
            e
          ] })
        }
      )
    ] }) })
  ] });
}, dp = ({ state: e, ...t }) => {
  const [n, r] = k.useState(!1), i = k.useMemo(
    () => e ?? {
      isOpen: n,
      setOpen: (o) => r(o)
    },
    [n, e]
  );
  return /* @__PURE__ */ S.jsx(ZQ.Provider, { value: i, children: /* @__PURE__ */ S.jsx(vIe, { ...t }) });
}, Cb = ({ children: e }) => /* @__PURE__ */ S.jsx(ae, { mx: "4", className: yIe, children: e }), zA = ({
  children: e,
  onItemClick: t,
  testId: n,
  variant: r
}) => {
  const { setOpen: i } = eX(), o = () => t == null ? void 0 : t({ closeModal: () => i(!1) });
  return /* @__PURE__ */ S.jsx(UA, { variant: r, onClick: o, testId: n, children: e });
}, tX = k.createContext(
  void 0
), gIe = ({ children: e }) => {
  const [t, n] = k.useState(null);
  return k.useLayoutEffect(() => {
    fb.chainNullable(
      (r) => r.querySelector(AD)
    ).ifJust((r) => n(r));
  }, []), /* @__PURE__ */ S.jsx(tX.Provider, { value: t, children: e });
}, bIe = () => {
  const e = k.useContext(tX);
  if (e === void 0)
    throw new Error("RootElementProvider not found in the tree");
  return e;
};
var wIe = "var(--sk-font-size-3xl)", CIe = "_1s53f1w3 _1s53f1w1 _1s53f1w0 yv8y4ri _1s53f1w2 yv8y4r1a yv8y4rjh yv8y4rrb yv8y4rrc", xIe = "_1s53f1w4 _1s53f1w1 _1s53f1w0 yv8y4ri", EIe = "_1s53f1w5";
const r8 = (e) => {
  const t = k.useRef(null), n = k.useRef(null);
  return k.useEffect(() => {
    t.current = n.current, n.current = e;
  }, [e]), e === n.current ? t.current : n.current;
}, SIe = ({
  inputVal: e,
  inputRef: t,
  spanRef: n
}) => {
  const r = r8(e), { disableResizingInputFontSize: i } = dr();
  k.useEffect(() => {
    if (!t.current || !n.current || !r || e.length === r.length || i)
      return;
    const o = kIe({
      inputEl: t.current,
      spanEl: n.current
    });
    t.current.style.fontSize = `${o}px`, n.current.style.fontSize = `${o}px`;
  }, [t, e, r, n, i]);
}, kIe = ({
  inputEl: e,
  spanEl: t
}) => Ro.map((n) => {
  const r = e.offsetWidth, i = TIe(e);
  let o = Number.parseFloat(
    n.getComputedStyle(t).fontSize
  );
  for (const s of i)
    if (t.style.fontSize = `${s}px`, t.offsetWidth < r) {
      o = s;
      break;
    }
  return o;
}).extractNullable(), AIe = (e) => e * Number.parseFloat(
  fb.map(
    (t) => getComputedStyle(t.documentElement).fontSize
  ).orDefault("0")
), TIe = (e) => Ro.map(
  (t) => [
    wIe,
    ti.fontSize["2xl"],
    ti.fontSize.xl,
    ti.fontSize.lgx,
    ti.fontSize.lg
  ].map(
    (n) => AIe(
      Number.parseFloat(
        t.getComputedStyle(e).getPropertyValue(n.replace(/(var\()|(\))/g, ""))
      )
    )
  )
).orDefault([]), nX = k.memo(
  ({
    onChange: e,
    value: t,
    disabled: n,
    onBlur: r,
    isInvalid: i,
    shakeOnInvalid: o
  }) => {
    const [s, c] = k.useState("0"), [u, f] = k.useState(!1);
    k.useEffect(() => {
      u || c((A) => t.isEqualTo(H9(A)) ? A : To(t));
    }, [t, u]);
    const p = (A) => {
      const R = A.target.value;
      if (!A.target.validity.valid) return;
      if (c(R), !R) return e(new Nt(0));
      const I = H9(R);
      I.isNaN() || e(I);
    }, y = s === "0" || s === "", v = k.useRef(null), w = k.useRef(null);
    SIe({
      inputRef: v,
      spanRef: w,
      inputVal: s
    });
    const C = bIe(), x = Q2e();
    return k.useEffect(() => {
      !o || !i || x.start("shake");
    }, [x, i, o]), /* @__PURE__ */ S.jsxs(
      gi.div,
      {
        animate: x,
        variants: {
          shake: {
            rotate: [-1.5, 1.5, 0],
            transition: { repeat: 3, duration: 0.12, ease: "easeInOut" }
          }
        },
        className: EIe,
        children: [
          /* @__PURE__ */ S.jsx(
            ae,
            {
              as: "input",
              color: o && i ? "textDanger" : "text",
              disabled: n,
              name: "stake-amount",
              ref: v,
              "data-testid": "number-input",
              type: "text",
              inputMode: "decimal",
              className: CIe,
              value: s,
              onChange: p,
              autoComplete: "off",
              autoCorrect: "off",
              spellCheck: "false",
              pattern: "^(?!0\\d)\\d*([.,])?(\\d+)?$",
              minLength: 1,
              maxLength: 79,
              onBlur: () => {
                f(!1), y && c("0"), r == null || r();
              },
              onFocus: () => {
                f(!0), y && c("");
              }
            }
          ),
          C && Wu.createPortal(
            /* @__PURE__ */ S.jsx("span", { ref: w, className: xIe, children: s }),
            C
          )
        ]
      }
    );
  }
), H9 = (e) => new Nt(e.replace(/,/g, ".")), _Ie = ({
  height: e,
  width: t
}) => /* @__PURE__ */ S.jsxs(
  "svg",
  {
    width: t ?? 16,
    height: e ?? 16,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 16 16",
    children: [
      /* @__PURE__ */ S.jsx(
        "path",
        {
          d: "M10.75 6.5 7.081 10 5.25 8.25",
          stroke: ti.color.text,
          strokeWidth: 2,
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ),
      /* @__PURE__ */ S.jsx(
        "path",
        {
          d: "M8 14A6 6 0 1 0 8 2a6 6 0 0 0 0 12Z",
          stroke: ti.color.text,
          strokeWidth: 2,
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      )
    ]
  }
), Gk = /* @__PURE__ */ new Set(), Hc = ({
  fallback: e,
  src: t,
  containerProps: n,
  imageProps: r
}) => {
  const [i, o] = k.useState(() => ({
    src: t,
    loaded: !1,
    timeoutFallback: !1
  }));
  i.src !== t && o({ src: t, loaded: !1, timeoutFallback: !1 }), k.useEffect(() => {
    if (t && Gk.has(t)) return;
    const f = setTimeout(() => {
      o((p) => ({ ...p, timeoutFallback: !0 }));
    }, 500);
    return () => clearTimeout(f);
  }, [t]);
  const s = (f) => {
    var p;
    o((y) => ({ ...y, loaded: !0 })), (p = r == null ? void 0 : r.onLoad) == null || p.call(r, f);
  }, c = (f) => {
    var p;
    t && Gk.add(t), (p = r == null ? void 0 : r.onError) == null || p.call(r, f);
  }, u = k.useMemo(
    () => (t && Gk.has(t) || i.timeoutFallback && !i.loaded) && k.isValidElement(e),
    [e, i.loaded, i.timeoutFallback, t]
  );
  return /* @__PURE__ */ S.jsxs(
    ae,
    {
      ...n,
      position: "relative",
      display: "flex",
      justifyContent: "center",
      children: [
        u && /* @__PURE__ */ S.jsx(ae, { position: "absolute", children: e }),
        !!(t && !Gk.has(t)) && /* @__PURE__ */ S.jsx(
          ae,
          {
            ...r,
            src: t,
            as: "img",
            style: { visibility: i.loaded ? "visible" : "hidden" },
            onLoad: s,
            onError: c
          }
        )
      ]
    }
  );
};
function q9(e) {
  var t = e.match(/^var\((.*)\)$/);
  return t ? t[1] : e;
}
function RIe(e, t) {
  var n = e;
  for (var r of t) {
    if (!(r in n))
      throw new Error("Path ".concat(t.join(" -> "), " does not exist in object"));
    n = n[r];
  }
  return n;
}
function rX(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], r = {};
  for (var i in e) {
    var o = e[i], s = [...n, i];
    typeof o == "string" || typeof o == "number" || o == null ? r[i] = t(o, s) : typeof o == "object" && !Array.isArray(o) && (r[i] = rX(o, t, s));
  }
  return r;
}
function TD(e, t) {
  var n = {};
  if (typeof t == "object") {
    var r = e;
    rX(t, (c, u) => {
      if (c != null) {
        var f = RIe(r, u);
        n[q9(f)] = String(c);
      }
    });
  } else {
    var i = e;
    for (var o in i) {
      var s = i[o];
      s != null && (n[q9(o)] = s);
    }
  }
  return Object.defineProperty(n, "toString", {
    value: function() {
      return Object.keys(this).map((u) => "".concat(u, ":").concat(this[u])).join(";");
    },
    writable: !1
  }), n;
}
var OIe = "var(--_3w72kd0)", IIe = "_3w72kd1";
const df = ({
  name: e,
  tokenLogoHw: t,
  textVariant: n
}) => /* @__PURE__ */ S.jsx(
  ae,
  {
    className: IIe,
    borderRadius: "half",
    style: TD({
      [OIe]: xue(e)
    }),
    hw: t ?? "9",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    children: /* @__PURE__ */ S.jsx(
      Ge,
      {
        variant: n ?? {
          size: "large",
          type: "white",
          weight: "bold"
        },
        children: e.charAt(0).toUpperCase()
      }
    )
  }
);
var DIe = "_6teug80", MIe = "_6teug81";
const iX = ({
  networkLogoUri: e,
  tokenNetworkLogoHw: t = "3"
}) => /* @__PURE__ */ S.jsx(ae, { className: DIe, "data-rk": "token-network-logo", children: /* @__PURE__ */ S.jsx(
  Hc,
  {
    src: e,
    fallback: null,
    containerProps: { hw: t },
    imageProps: { className: MIe }
  }
) }), PIe = (e, t) => {
  const { variant: n } = dr();
  return k.useMemo(() => {
    var i;
    return t ? {
      mainUrl: he.fromFalsy(n === "zerion").filter(
        () => NIe.some((s) => t.logoURI.endsWith(s))
      ).map(() => W9).orDefault(t.logoURI),
      fallbackUrl: t.logoURI ?? e.logoURI,
      name: t.name,
      providerIcon: (i = t.provider) == null ? void 0 : i.logoURI
    } : {
      mainUrl: he.fromFalsy(n === "zerion").map(() => e.address && e.symbol === "MATIC" ? BIe(e.address) : e.symbol === "ETH" ? W9 : e.logoURI).orDefault(e.logoURI),
      fallbackUrl: e.logoURI,
      name: e.name,
      providerIcon: void 0
    };
  }, [e, t, n]);
}, NIe = ["/tokens/eth.svg", "/tokens/steth2.svg"], BIe = (e) => `${ni.zerion.iconsByAddress}${e}.png`, W9 = `${ni.zerion.iconsByAddress}eth.png`, oX = ({
  token: e,
  metadata: t,
  hideNetwork: n,
  children: r
}) => {
  const { mainUrl: i, fallbackUrl: o, name: s, providerIcon: c } = PIe(
    e,
    t
  ), u = Bh(e.network);
  return /* @__PURE__ */ S.jsx(
    ae,
    {
      position: "relative",
      marginRight: n ? "0" : "2",
      display: "flex",
      children: r({ mainUrl: i, fallbackUrl: o, name: s, networkLogoUri: u, providerIcon: c })
    }
  );
}, aX = ({
  mainUrl: e,
  fallbackUrl: t,
  name: n,
  tokenLogoHw: r = "9"
}) => /* @__PURE__ */ S.jsx(
  Hc,
  {
    "data-rk": "token-logo",
    containerProps: { hw: r, "data-rk": "token-logo" },
    src: e,
    fallback: /* @__PURE__ */ S.jsx(
      Hc,
      {
        "data-rk": "token-logo",
        containerProps: { hw: r, "data-rk": "token-logo" },
        src: t,
        fallback: /* @__PURE__ */ S.jsx(df, { name: n, tokenLogoHw: r })
      }
    )
  }
), nf = ({
  token: e,
  metadata: t,
  tokenLogoHw: n,
  tokenNetworkLogoHw: r,
  hideNetwork: i
}) => {
  const { hideNetworkLogo: o } = dr();
  return /* @__PURE__ */ S.jsx(
    oX,
    {
      hideNetwork: i,
      token: e,
      metadata: t,
      children: ({ fallbackUrl: s, mainUrl: c, name: u, networkLogoUri: f }) => /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
        /* @__PURE__ */ S.jsx(
          aX,
          {
            fallbackUrl: s,
            mainUrl: c,
            name: u,
            tokenLogoHw: n
          }
        ),
        !i && !o && /* @__PURE__ */ S.jsx(
          iX,
          {
            networkLogoUri: f,
            tokenNetworkLogoHw: r
          }
        )
      ] })
    }
  );
}, yx = ({ children: e }) => /* @__PURE__ */ S.jsx(
  gi.div,
  {
    initial: { opacity: 0, scale: 1, translateY: "-15px" },
    animate: {
      opacity: 1,
      translateY: 0,
      transition: { duration: 0.5, delay: 0.1 }
    },
    exit: {
      opacity: 0,
      filter: "blur(8px)",
      scale: 0.8,
      transition: { duration: 0.4 }
    },
    children: e
  }
), oI = Symbol("cachedRes"), LIe = (e) => {
  const t = /* @__PURE__ */ new Map();
  return (...r) => {
    let i = t;
    for (const s of r)
      if (i.has(s))
        i = i.get(s);
      else {
        const c = /* @__PURE__ */ new Map();
        i.set(s, c), i = c;
      }
    if (i.has(oI))
      return i.get(oI).cachedRes;
    const o = e(...r);
    return i.set(oI, { cachedRes: o }), o;
  };
}, sX = LIe(
  (e) => e.charAt(0).toUpperCase() + e.slice(1).toLowerCase()
), lX = k.createContext(void 0), jIe = ({ children: e }) => {
  const [t, n] = k.useState(null), { pathname: r } = Kc(), i = Pr(r), o = k.useCallback(
    ({ height: c, pathname: u }) => {
      i.current === u && n({ pathname: u, height: c });
    },
    [i]
  ), s = k.useMemo(
    () => ({ state: t, setState: o }),
    [o, t]
  );
  return /* @__PURE__ */ S.jsx(lX.Provider, { value: s, children: e });
}, cX = () => {
  const e = k.useContext(lX);
  if (!e)
    throw new Error(
      "useCurrentLayout must be used within a CurrentLayoutContextProvider"
    );
  return e;
};
var FIe = "_1qbrdb71 _1qbrdb70 yv8y4re5 yv8y4rcn", UIe = "_1qbrdb72";
const zIe = ({ currentPathname: e }) => {
  const { setState: t } = cX(), { containerRef: n } = NA((r) => {
    r !== 0 && t({ pathname: e, height: r });
  });
  return /* @__PURE__ */ S.jsx(
    gi.div,
    {
      layout: "position",
      ref: n,
      className: UIe,
      children: /* @__PURE__ */ S.jsx(lN, {})
    }
  );
}, fp = ({
  children: e,
  ...t
}) => /* @__PURE__ */ S.jsx(
  ae,
  {
    "data-rk": "page-container",
    display: "flex",
    flexDirection: "column",
    px: "4",
    marginBottom: "4",
    flex: 1,
    paddingTop: "2",
    ...t,
    children: e
  }
), VIe = () => Kl("activity/unstake/complete") || Kl("activity/unstake-review/complete"), $Ie = () => Kl("activity/pending/complete") || Kl("activity/pending-review/complete"), HIe = () => Kl("activity/stake-review/complete") || Kl("activity/unstake-review/complete") || Kl("activity/pending-review/complete"), gN = (e) => Kl(`positions/:integrationId/:balanceId/${e ?? "*"}`), qIe = (e) => gN("pending-action/*"), WIe = (e) => gN("unstake/*"), [bN, GIe] = mx(0), [uX, KIe] = mx(null), YIe = () => NA(bN()[1]), py = (e) => {
  const [, t] = uX(), n = AAe();
  tf(() => {
    n || t((r) => r === e ? null : r);
  }, [n, t, e]), tf(() => {
    if (!(!n || e != null && e.hide))
      return t(e), () => {
        t((r) => r === e ? null : r);
      };
  }, [t, e]);
}, QIe = () => {
  var w;
  const e = La(), n = ((w = Kc().state) == null ? void 0 : w.urls) ?? [], r = Bi(), i = () => {
    e("/");
  }, o = (C) => Ro.ifJust((x) => {
    r("viewTxClicked"), x.open(C, "_blank");
  }), s = WIe(), c = qIe(), u = VIe(), f = $Ie(), p = HIe(), y = Pr(i), { t: v } = ln();
  return py(
    k.useMemo(
      () => ({
        disabled: !1,
        isLoading: !1,
        label: v("shared.ok"),
        onClick: () => y.current(),
        hide: !!p
      }),
      [y, v, p]
    )
  ), {
    urls: n,
    unstakeMatch: s || u,
    pendingActionMatch: c || f,
    onViewTransactionClick: o
  };
}, VA = ({
  amount: e,
  metadata: t,
  network: n,
  token: r,
  pendingActionType: i,
  yieldType: o,
  providersDetails: s
}) => {
  const { t: c } = ln(), { onViewTransactionClick: u, unstakeMatch: f, pendingActionMatch: p, urls: y } = QIe();
  return /* @__PURE__ */ S.jsx(yx, { children: /* @__PURE__ */ S.jsx(fp, { children: /* @__PURE__ */ S.jsx(
    ae,
    {
      flex: 1,
      display: "flex",
      flexDirection: "column",
      justifyContent: "space-between",
      my: "4",
      children: /* @__PURE__ */ S.jsxs(
        ae,
        {
          flex: 1,
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center",
          textAlign: "center",
          children: [
            he.fromRecord({ token: r, metadata: t }).map((v) => /* @__PURE__ */ S.jsx(
              gi.div,
              {
                initial: { opacity: 0, scale: 0.1 },
                animate: {
                  opacity: 1,
                  scale: 1,
                  transition: { delay: 0.2, duration: 0.3 }
                },
                children: /* @__PURE__ */ S.jsx(ae, { my: "4", children: /* @__PURE__ */ S.jsx(
                  nf,
                  {
                    metadata: v.metadata,
                    tokenLogoHw: "32",
                    tokenNetworkLogoHw: "8",
                    token: v.token
                  }
                ) })
              }
            )).extractNullable(),
            /* @__PURE__ */ S.jsx(
              gi.div,
              {
                initial: { opacity: 0, translateX: "-40px" },
                animate: {
                  opacity: 1,
                  translateX: 0,
                  transition: { delay: 0.2, duration: 0.8 }
                },
                children: /* @__PURE__ */ S.jsx($u, { overflowWrap: "anywhere", variant: { level: "h3" }, children: c(
                  f ? "complete.successfully_unstaked" : p ? "complete.successfully_pending_action" : "complete.successfully_staked",
                  {
                    action: o.mapOrDefault(
                      (v) => c(f ? `complete.unstake.${v}` : `complete.stake.${v}`),
                      ""
                    ),
                    amount: e,
                    tokenNetwork: n,
                    pendingAction: c(
                      `complete.pending_action.${i == null ? void 0 : i.toLowerCase()}`
                    )
                  }
                ) })
              }
            ),
            !f && !p ? s.map(
              (v) => v.map((w, C) => /* @__PURE__ */ S.jsxs(
                ae,
                {
                  display: "flex",
                  marginTop: "2",
                  justifyContent: "center",
                  alignItems: "center",
                  gap: "1",
                  children: [
                    w.logo && /* @__PURE__ */ S.jsx(
                      Hc,
                      {
                        imageProps: { borderRadius: "full" },
                        containerProps: { hw: "5" },
                        src: w.logo,
                        fallback: /* @__PURE__ */ S.jsx(
                          df,
                          {
                            name: w.name || w.logo,
                            tokenLogoHw: "5"
                          }
                        )
                      }
                    ),
                    /* @__PURE__ */ S.jsx(Ge, { variant: { type: "muted" }, children: c("complete.via", { providerName: w.name }) })
                  ]
                },
                C
              ))
            ).extractNullable() : null,
            y.map((v) => /* @__PURE__ */ S.jsxs(
              ae,
              {
                marginTop: "4",
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                as: "button",
                onClick: () => u(v.url),
                children: [
                  /* @__PURE__ */ S.jsx(
                    ae,
                    {
                      marginRight: "1",
                      display: "flex",
                      justifyContent: "center",
                      alignItems: "center",
                      children: /* @__PURE__ */ S.jsx(_Ie, { width: 22, height: 22 })
                    }
                  ),
                  /* @__PURE__ */ S.jsx(Ge, { variant: { type: "muted" }, children: c("complete.view_transaction", {
                    type: _n(v.type).map((w) => c(`steps.tx_type.${w}`)).map(sX).extract()
                  }) })
                ]
              },
              v.url
            ))
          ]
        }
      )
    }
  ) }) });
}, XIe = typeof Symbol == "function" && Symbol.observable || "@@observable";
function G9(e, t, n) {
  var o, s, c;
  const r = typeof e == "object", i = r ? e : void 0;
  return {
    next: (o = r ? e.next : e) == null ? void 0 : o.bind(i),
    error: (s = r ? e.error : t) == null ? void 0 : s.bind(i),
    complete: (c = r ? e.complete : n) == null ? void 0 : c.bind(i)
  };
}
function JIe(e, t) {
  return t(e);
}
const ug = /* @__PURE__ */ new WeakMap();
function K9(e, t, n) {
  let r, i;
  const o = {
    context: e,
    status: "active",
    output: void 0,
    error: void 0
  };
  let s = o;
  const c = (y) => {
    if (!i)
      return;
    const v = y.type, w = i.get(v);
    w && w.forEach((C) => C(y));
  }, u = ZIe(t);
  function f(y) {
    var w;
    let v;
    [s, v] = u(s, y), (w = ug.get(p)) == null || w.forEach((C) => {
      var x;
      (x = C.next) == null || x.call(C, {
        type: "@xstate.snapshot",
        event: y,
        snapshot: s,
        actorRef: p,
        rootId: p.sessionId
      });
    }), r == null || r.forEach((C) => {
      var x;
      return (x = C.next) == null ? void 0 : x.call(C, s);
    }), v.forEach(c);
  }
  const p = {
    on(y, v) {
      i || (i = /* @__PURE__ */ new Map());
      let w = i.get(y);
      w || (w = /* @__PURE__ */ new Set(), i.set(y, w));
      const C = v.bind(void 0);
      return w.add(C), {
        unsubscribe() {
          w.delete(C);
        }
      };
    },
    sessionId: e5e(),
    send(y) {
      var v;
      (v = ug.get(p)) == null || v.forEach((w) => {
        var C;
        (C = w.next) == null || C.call(w, {
          type: "@xstate.event",
          event: y,
          sourceRef: void 0,
          actorRef: p,
          rootId: p.sessionId
        });
      }), f(y);
    },
    getSnapshot() {
      return s;
    },
    getInitialSnapshot() {
      return o;
    },
    subscribe(y) {
      const v = G9(y);
      return r ?? (r = /* @__PURE__ */ new Set()), r.add(v), {
        unsubscribe() {
          return r == null ? void 0 : r.delete(v);
        }
      };
    },
    [XIe]() {
      return this;
    },
    inspect: (y) => {
      var w, C;
      const v = G9(y);
      return ug.set(p, ug.get(p) ?? /* @__PURE__ */ new Set()), ug.get(p).add(v), (w = v.next) == null || w.call(v, {
        type: "@xstate.actor",
        actorRef: p,
        rootId: p.sessionId
      }), (C = v.next) == null || C.call(v, {
        type: "@xstate.snapshot",
        snapshot: o,
        event: {
          type: "@xstate.init"
        },
        actorRef: p,
        rootId: p.sessionId
      }), {
        unsubscribe() {
          var x;
          return (x = ug.get(p)) == null ? void 0 : x.delete(v);
        }
      };
    }
  };
  return p;
}
function $A(e, t) {
  return t === void 0 ? K9(e.context, e.on) : K9(e, t);
}
function ZIe(e, t) {
  return (n, r) => {
    let i = n.context;
    const o = e == null ? void 0 : e[r.type], s = [], c = {
      emit: (u) => {
        s.push(u);
      }
    };
    if (!o)
      return [n, s];
    if (typeof o == "function")
      i = JIe(i, (u) => Object.assign({}, i, o == null ? void 0 : o(
        u,
        r,
        // TODO: help me
        c
      )));
    else {
      const u = {};
      for (const f of Object.keys(o)) {
        const p = o[f];
        u[f] = typeof p == "function" ? p(i, r, c) : p;
      }
      i = Object.assign({}, i, u);
    }
    return [{
      ...n,
      context: i
    }, s];
  };
}
function e5e() {
  return Math.random().toString(36).slice(6);
}
const t5e = $A(
  {
    selectedAction: he.empty(),
    selectedYield: he.empty()
  },
  {
    setSelectedAction: (e, t) => ({
      selectedAction: t.data.map(({ selectedAction: n }) => n),
      selectedYield: t.data.map(({ selectedYield: n }) => n)
    })
  }
), dX = k.createContext(void 0), n5e = ({ children: e }) => /* @__PURE__ */ S.jsx(dX.Provider, { value: t5e, children: e }), xb = () => {
  const e = k.useContext(dX);
  if (!e)
    throw new Error(
      "useActivityContext must be used within a ActivityProvider"
    );
  return e;
};
function r5e(e, t) {
  return e === t;
}
function i5e(e, t) {
  const n = k.useRef();
  return (r) => {
    const i = e(r);
    return t(n.current, i) ? n.current : n.current = i;
  };
}
function ss(e, t, n = r5e) {
  const r = i5e(t, n);
  return k.useSyncExternalStore(k.useCallback((i) => e.subscribe(i).unsubscribe, [e]), () => r(e.getSnapshot()), () => r(e.getInitialSnapshot()));
}
const sa = (e, t) => {
  const { trackPageView: n } = dK(), r = Pr(t);
  k.useEffect(() => {
    r.current ? n(e, r.current) : n(e);
  }, [e, r, n]);
}, o5e = () => {
  sa("activityComplete");
  const e = ss(
    xb(),
    (u) => u.context.selectedAction
  ).unsafeCoerce(), t = k.useMemo(
    () => he.fromNullable(e.amount).map(Na).unsafeCoerce(),
    [e]
  ), n = ss(
    xb(),
    (u) => u.context.selectedYield
  ), r = Xh(n).map((u) => u.type), i = k.useMemo(
    () => he.fromNullable(e).map((u) => u.inputToken),
    [e]
  ), o = k.useMemo(
    () => n.map((u) => u.metadata),
    [n]
  ), s = i.mapOrDefault((u) => u.symbol, ""), c = cf({
    integrationData: n,
    validatorsAddresses: he.of(e.validatorAddresses ?? [])
  });
  return /* @__PURE__ */ S.jsx(
    VA,
    {
      yieldType: r,
      providersDetails: c,
      token: i,
      metadata: o,
      network: s,
      amount: t,
      pendingActionType: e.type
    }
  );
}, fX = () => Kl("positions/:integrationId/:balanceId/select-validator/:pendingActionType"), wN = () => {
  const e = gN(), t = fX();
  return k.useMemo(() => {
    const { balanceId: n, integrationId: r } = (e == null ? void 0 : e.params) ?? (t == null ? void 0 : t.params) ?? {}, i = t == null ? void 0 : t.params.pendingActionType;
    return {
      balanceId: he.fromNullable(n),
      integrationId: he.fromNullable(r),
      pendingActionType: he.fromNullable(i),
      plain: {
        balanceId: n,
        integrationId: r,
        pendingActionType: i
      }
    };
  }, [
    t == null ? void 0 : t.params,
    e == null ? void 0 : e.params
  ]);
}, hX = k.createContext(void 0), a5e = ({
  children: e
}) => {
  const [t, n] = k.useState(he.empty()), r = k.useCallback(() => {
    n(he.of({ timestamp: Date.now() }));
  }, []), i = k.useMemo(
    () => [t, r],
    [t, r]
  );
  return /* @__PURE__ */ S.jsx(hX.Provider, { value: i, children: e });
}, pX = () => {
  const e = k.useContext(hX);
  if (e === void 0)
    throw new Error(
      "useActionHistory must be used within a ActionHistoryContextProvider"
    );
  return e;
}, s5e = () => pX()[0], l5e = () => pX()[1], c5e = ({
  key: e,
  shouldRefetch: t,
  enabled: n,
  queryKey: r,
  waitMs: i = 4e3,
  times: o = 2
}) => {
  const s = tc();
  Qr({
    queryKey: ["refetch-n-times", ...e],
    refetchOnMount: !1,
    enabled: n,
    queryFn: async () => (t() && await Ye.sequence(
      Array.from({ length: o }).map(
        () => Ye(async () => {
          await u$(i), await s.invalidateQueries({ queryKey: r });
        }).chainLeft(async () => Pt(null))
      )
    ), null)
  });
}, mX = (e) => {
  const [t] = k.useState(
    () => mA(e).mapLeft(() => null).extract()
  ), n = k.useRef(t);
  return k.useSyncExternalStore(
    k.useCallback(
      (r) => {
        const i = Nke(e, (o) => {
          n.current = o, r();
        });
        return () => i();
      },
      [e]
    ),
    k.useCallback(() => n.current, []),
    k.useCallback(() => null, [])
  );
}, u5e = (e) => {
  const { network: t, address: n, additionalAddresses: r } = fr(), i = s5e(), o = k.useMemo(
    () => i.map((f) => f.timestamp).extractNullable(),
    [i]
  ), s = mX(
    "sk-widget@1//customValidators"
  ), c = k.useMemo(
    () => he.fromRecord({
      additionalAddresses: _n(r ?? void 0),
      address: he.fromNullable(n),
      network: he.fromNullable(t)
    }).mapOrDefault(
      (f) => ({
        enabled: !0,
        dto: {
          addresses: {
            address: f.address,
            additionalAddresses: f.additionalAddresses
          },
          network: f.network,
          customValidators: he.fromNullable(s).chainNullable((p) => p[f.network]).chainNullable((p) => p[f.address]).orDefault([])
        }
      }),
      {
        enabled: !1,
        dto: {
          addresses: { address: "", additionalAddresses: void 0 },
          network: "ethereum"
        }
      }
    ),
    [r, n, s, t]
  ), u = mde(c.dto, {
    query: {
      enabled: c.enabled,
      select: e == null ? void 0 : e.select,
      refetchInterval: 1e3 * 60
    }
  });
  return c5e({
    enabled: !!o,
    key: ["yield-balances-refetch", o],
    queryKey: [lM(c.dto)[0]],
    waitMs: 4e3,
    shouldRefetch: () => !!o && Date.now() - o < 1e3 * 12
  }), u;
}, d5e = () => {
  const e = tc();
  return k.useCallback(
    () => e.invalidateQueries({
      queryKey: [
        lM(
          {}
        )[0]
      ]
    }),
    [e]
  );
}, CN = () => {
  const { data: e, ...t } = u5e({
    select: f5e
  });
  return { data: k.useMemo(
    () => e ?? /* @__PURE__ */ new Map(),
    [e]
  ), ...t };
}, f5e = $b(
  (e) => e,
  (e) => e.reduce((t, n) => (t.set(n.integrationId, {
    integrationId: n.integrationId,
    balanceData: n.balances.toSorted((r, i) => (r.groupId ?? "").localeCompare(i.groupId ?? "")).reduce((r, i) => {
      const o = r.get(i.groupId);
      return o ? o.balances.push(i) : i.validatorAddresses || i.validatorAddress || i.providerId ? r.set(i.groupId, {
        balances: [i],
        type: "validators",
        validatorsAddresses: i.validatorAddresses ?? (i.providerId ? [i.providerId] : [i.validatorAddress])
      }) : r.set(i.groupId, {
        balances: [i],
        type: "default"
      }), r;
    }, /* @__PURE__ */ new Map())
  }), t), /* @__PURE__ */ new Map())
), h5e = ({
  integrationId: e
}) => {
  const { data: t, ...n } = CN();
  return { data: k.useMemo(
    () => he.fromRecord({
      id: he.fromNullable(e),
      data: he.fromNullable(t)
    }).chainNullable((i) => i.data.get(i.id)),
    [e, t]
  ), ...n };
}, xN = ({
  balanceId: e,
  integrationId: t
}) => {
  const { data: n, ...r } = h5e({ integrationId: t });
  return { data: k.useMemo(
    () => he.fromRecord({
      positionData: n,
      balanceId: he.fromNullable(e)
    }).chainNullable(
      (o) => o.positionData.balanceData.get(o.balanceId)
    ),
    [e, n]
  ), ...r };
}, p5e = $A(
  { data: he.empty() },
  {
    initFlow: (e, t) => ({
      data: he.of({ ...t.data, actionDto: he.empty() })
    }),
    setActionDto: (e, t) => ({
      data: e.data.map((n) => ({
        ...n,
        actionDto: he.of(t.data)
      }))
    })
  }
), yX = k.createContext(
  void 0
), m5e = ({ children: e }) => /* @__PURE__ */ S.jsx(yX.Provider, { value: p5e, children: e }), vx = () => {
  const e = k.useContext(yX);
  if (!e)
    throw new Error(
      "usePendingActionStore must be used within a PendingActionProvider"
    );
  return e;
}, y5e = () => {
  var p;
  const { plain: e } = wN(), t = xN({
    balanceId: e.balanceId,
    integrationId: e.integrationId
  }), n = ss(
    vx(),
    (y) => y.context.data
  ).unsafeCoerce(), r = k.useMemo(
    () => he.of(n.integrationData),
    [n.integrationData]
  ), i = k.useMemo(
    () => he.of(n.interactedToken),
    [n.interactedToken]
  );
  sa("pendingActionCompelete");
  const o = cf({
    integrationData: r,
    validatorsAddresses: t.data.map(
      (y) => y.type === "validators" ? y.validatorsAddresses : []
    )
  }), s = r.map((y) => y.metadata), c = i.mapOrDefault((y) => y.symbol, ""), u = k.useMemo(
    () => {
      var y;
      return he.fromNullable((y = n.requestDto.args) == null ? void 0 : y.amount).map((v) => new Nt(v ?? 0)).mapOrDefault((v) => To(v), "");
    },
    [(p = n.requestDto.args) == null ? void 0 : p.amount]
  ), f = Xh(r).map((y) => y.type);
  return /* @__PURE__ */ S.jsx(
    VA,
    {
      providersDetails: o,
      yieldType: f,
      token: i,
      metadata: s,
      network: c,
      amount: u,
      pendingActionType: n.pendingActionType
    }
  );
}, v5e = $A(
  { data: he.empty() },
  {
    initFlow: (e, t) => ({
      data: he.of({ ...t.data, actionDto: he.empty() })
    }),
    setActionDto: (e, t) => ({
      data: e.data.map((n) => ({
        ...n,
        actionDto: he.of(t.data)
      }))
    })
  }
), vX = k.createContext(
  void 0
), g5e = ({ children: e }) => /* @__PURE__ */ S.jsx(vX.Provider, { value: v5e, children: e }), Eb = () => {
  const e = k.useContext(vX);
  if (!e)
    throw new Error(
      "useExitStakeStore must be used within a ExitStakeStoreProvider"
    );
  return e;
}, b5e = () => {
  const { plain: e } = wN(), t = xN({
    balanceId: e.balanceId,
    integrationId: e.integrationId
  }), n = ss(
    Eb(),
    (p) => p.context.data
  ).unsafeCoerce(), r = k.useMemo(
    () => he.of(n.integrationData),
    [n.integrationData]
  );
  sa("unstakeComplete");
  const i = cf({
    integrationData: r,
    validatorsAddresses: t.data.map(
      (p) => p.type === "validators" ? p.validatorsAddresses : []
    )
  }), o = k.useMemo(
    () => he.of(n.unstakeToken),
    [n.unstakeToken]
  ), s = r.map((p) => p.metadata), c = o.mapOrDefault((p) => p.symbol, ""), u = k.useMemo(
    () => To(n.requestDto.args.amount),
    [n.requestDto.args.amount]
  ), f = Xh(r).map((p) => p.type);
  return /* @__PURE__ */ S.jsx(
    VA,
    {
      providersDetails: i,
      yieldType: f,
      token: o,
      metadata: s,
      network: c,
      amount: u
    }
  );
}, dg = (e) => `${ni.assetsUrl}/widget/${e}`, Fs = {
  bitget: dg("bitget.png"),
  fees: dg("fees.png"),
  ledgerLogo: dg("ledger-logo.svg"),
  poweredBy: dg("powered-by.png"),
  wcLogo: dg("wc-logo.svg"),
  whatIsLiquidStaking: dg("what-is-liquid-staking.png")
}, w5e = () => fb.map(
  () => Object.values(Fs).forEach((e) => {
    const t = new Image();
    t.src = e;
  })
), C5e = () => /* @__PURE__ */ S.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: 17, height: 16, fill: "none", children: [
  /* @__PURE__ */ S.jsx("g", { clipPath: "url(#a)", filter: "url(#b)", children: /* @__PURE__ */ S.jsx(
    "path",
    {
      fill: "url(#c)",
      d: "M13.573 6.92c.028-2.343.043-3.515-.703-4.17-.747-.657-1.905-.491-4.222-.16l-3.065.439a1.142 1.142 0 1 0 .395 2.248l1.952-.405c.702-.146 1.053-.218 1.205-.126.14.086.223.24.216.405-.008.178-.264.429-.776.93L6.787 7.834c-.423.414-.634.621-.737.804-.375.671-.169 1.52.474 1.943.175.116.458.203 1.024.377.177.054.265.081.32.117.198.132.26.396.14.603-.032.056-.1.12-.234.246l-1.93 1.825a1.232 1.232 0 1 0 1.814 1.654l2.104-2.696c.645-.826.967-1.239.944-1.659a1.122 1.122 0 0 0-.12-.444c-.189-.375-.675-.573-1.646-.967-.344-.14-.516-.21-.576-.34a.361.361 0 0 1-.032-.153c0-.144.13-.278.387-.545l1.604-1.665c.413-.428.619-.642.779-.662a.456.456 0 0 1 .44.207c.086.135.054.431-.01 1.022l-.218 1.996a1.115 1.115 0 1 0 2.226.137l.033-2.714Z"
    }
  ) }),
  /* @__PURE__ */ S.jsxs("defs", { children: [
    /* @__PURE__ */ S.jsxs(
      "linearGradient",
      {
        id: "c",
        x1: 11.651,
        x2: 4.464,
        y1: 2.55,
        y2: 16.736,
        gradientUnits: "userSpaceOnUse",
        children: [
          /* @__PURE__ */ S.jsx("stop", { offset: 0.052, stopColor: "#FFC21B" }),
          /* @__PURE__ */ S.jsx("stop", { offset: 0.234, stopColor: "#B1A5B9" }),
          /* @__PURE__ */ S.jsx("stop", { offset: 0.385, stopColor: "#F46FC8" }),
          /* @__PURE__ */ S.jsx("stop", { offset: 0.797, stopColor: "#FF5F25" }),
          /* @__PURE__ */ S.jsx("stop", { offset: 1, stopColor: "#6D05F3" })
        ]
      }
    ),
    /* @__PURE__ */ S.jsx("clipPath", { id: "a", children: /* @__PURE__ */ S.jsx("path", { fill: "#fff", d: "M.935.975h16v15h-16z" }) }),
    /* @__PURE__ */ S.jsxs(
      "filter",
      {
        id: "b",
        width: 8.977,
        height: 13.756,
        x: 4.605,
        y: 2.3,
        colorInterpolationFilters: "sRGB",
        filterUnits: "userSpaceOnUse",
        children: [
          /* @__PURE__ */ S.jsx("feFlood", { floodOpacity: 0, result: "BackgroundImageFix" }),
          /* @__PURE__ */ S.jsx("feBlend", { in: "SourceGraphic", in2: "BackgroundImageFix", result: "shape" }),
          /* @__PURE__ */ S.jsx(
            "feColorMatrix",
            {
              in: "SourceAlpha",
              result: "hardAlpha",
              values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"
            }
          ),
          /* @__PURE__ */ S.jsx("feOffset", { dy: 0.18 }),
          /* @__PURE__ */ S.jsx("feGaussianBlur", { stdDeviation: 0.51 }),
          /* @__PURE__ */ S.jsx("feComposite", { in2: "hardAlpha", k2: -1, k3: 1, operator: "arithmetic" }),
          /* @__PURE__ */ S.jsx("feColorMatrix", { values: "0 0 0 0 0.98 0 0 0 0 1 0 0 0 0 0 0 0 0 0.3 0" }),
          /* @__PURE__ */ S.jsx("feBlend", { in2: "shape", result: "effect1_innerShadow_1687_4078" })
        ]
      }
    )
  ] })
] }), gX = k.createContext(void 0), x5e = ({
  children: e
}) => {
  const t = Kc(), n = r8(t), r = k.useMemo(() => ({
    current: t,
    prev: n
  }), [t, n]);
  return /* @__PURE__ */ S.jsx(gX.Provider, { value: r, children: e });
}, EN = () => {
  const e = k.useContext(gX);
  if (!e)
    throw new Error("useSKLocation must be used within a SKLocationProvider");
  return e;
}, E5e = () => ({
  earnPage: !1,
  layout: !1
}), S5e = (e, t) => {
  switch (t.type) {
    case "layout":
      return { ...e, layout: !0 };
    case "earnPage":
      return { ...e, earnPage: !0 };
    case "all":
      return { layout: !0, earnPage: !0 };
    default:
      return e;
  }
}, bX = k.createContext(
  void 0
), k5e = Rde(), A5e = ({ children: e }) => {
  const t = Pr(
    dr().onMountAnimationComplete
  ), [n, r] = k.useReducer(S5e, E5e());
  k.useEffect(() => {
    var c;
    n.layout && n.earnPage && (k5e(), (c = t.current) == null || c.call(t));
  }, [t, n.earnPage, n.layout]);
  const { current: i } = EN();
  k.useEffect(() => {
    i.pathname !== "/" && r({ type: "all" });
  }, [i.pathname]);
  const o = n.layout && n.earnPage, s = k.useMemo(
    () => ({ dispatch: r, state: n, mountAnimationFinished: o }),
    [o, n]
  );
  return /* @__PURE__ */ S.jsx(bX.Provider, { value: s, children: e });
}, ff = () => {
  const e = k.useContext(bX);
  if (!e)
    throw new Error(
      "useMountAnimation must be used within a MountAnimationProvider"
    );
  return e;
}, [wX, T5e] = mx(0), _5e = () => NA(wX()[1]), CX = ({ opacity: e }) => {
  const { containerRef: t } = _5e(), { t: n } = ln(), { state: r } = ff();
  return /* @__PURE__ */ S.jsx(
    gi.div,
    {
      "data-rk": "powered-by",
      ref: t,
      initial: { opacity: 0 },
      animate: {
        opacity: e || r.layout ? 1 : 0,
        transition: { duration: 0.3, delay: 0.2 }
      },
      children: /* @__PURE__ */ S.jsxs(
        ae,
        {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          marginBottom: "3",
          gap: "1",
          children: [
            /* @__PURE__ */ S.jsx(Ge, { variant: { type: "muted", weight: "normal" }, children: /* @__PURE__ */ S.jsx(
              _a,
              {
                i18nKey: "shared.powered_by",
                values: { name: n("shared.stake_kit") },
                components: {
                  span0: /* @__PURE__ */ S.jsx(
                    Ge,
                    {
                      as: "span",
                      variant: { type: "muted", weight: "semibold" }
                    }
                  )
                }
              }
            ) }),
            /* @__PURE__ */ S.jsx(C5e, {})
          ]
        }
      )
    }
  );
};
var xX = "_1eove2b3 _1eove2b2 yv8y4rvr yv8y4rvs", R5e = "_1eove2b5 _1eove2b4 yv8y4r0 yv8y4rhp yv8y4r2n yv8y4rg7 yv8y4rfz", O5e = "_1eove2b6", I5e = "_1c1q0ss0", D5e = "_1c1q0ss1";
const M5e = () => {
  const { t: e } = ln();
  return /* @__PURE__ */ S.jsxs(ae, { className: xX, children: [
    /* @__PURE__ */ S.jsxs(
      ae,
      {
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        paddingBottom: { mobile: "8" },
        className: D5e,
        "data-testid": "under-maintenance",
        children: [
          /* @__PURE__ */ S.jsx(ae, { as: "img", src: Fs.fees, className: I5e }),
          /* @__PURE__ */ S.jsxs(ae, { children: [
            /* @__PURE__ */ S.jsx(
              $u,
              {
                marginBottom: "4",
                textAlign: "center",
                variant: { level: "h4" },
                children: e("help_modals.under_maintenance.title")
              }
            ),
            /* @__PURE__ */ S.jsx(
              Ge,
              {
                variant: { type: "muted", weight: "normal" },
                textAlign: "center",
                marginBottom: "4",
                children: e("help_modals.under_maintenance.description")
              }
            ),
            /* @__PURE__ */ S.jsx(
              Ge,
              {
                variant: { type: "muted", weight: "normal" },
                textAlign: "center",
                marginBottom: "4",
                children: e("help_modals.under_maintenance.description2")
              }
            )
          ] })
        ]
      }
    ),
    /* @__PURE__ */ S.jsx(CX, { opacity: 1 })
  ] });
}, P5e = $.createContext({}), EX = !0;
function N5e({ baseColor: e, highlightColor: t, width: n, height: r, borderRadius: i, circle: o, direction: s, duration: c, enableAnimation: u = EX }) {
  const f = {};
  return s === "rtl" && (f["--animation-direction"] = "reverse"), typeof c == "number" && (f["--animation-duration"] = `${c}s`), u || (f["--pseudo-element-display"] = "none"), (typeof n == "string" || typeof n == "number") && (f.width = n), (typeof r == "string" || typeof r == "number") && (f.height = r), (typeof i == "string" || typeof i == "number") && (f.borderRadius = i), o && (f.borderRadius = "50%"), typeof e < "u" && (f["--base-color"] = e), typeof t < "u" && (f["--highlight-color"] = t), f;
}
function B5e({ count: e = 1, wrapper: t, className: n, containerClassName: r, containerTestId: i, circle: o = !1, style: s, ...c }) {
  var u, f, p;
  const y = $.useContext(P5e), v = { ...c };
  for (const [D, M] of Object.entries(c))
    typeof M > "u" && delete v[D];
  const w = {
    ...y,
    ...v,
    circle: o
  }, C = {
    ...s,
    ...N5e(w)
  };
  let x = "react-loading-skeleton";
  n && (x += ` ${n}`);
  const A = (u = w.inline) !== null && u !== void 0 ? u : !1, R = [], I = Math.ceil(e);
  for (let D = 0; D < I; D++) {
    let M = C;
    if (I > e && D === I - 1) {
      const j = (f = M.width) !== null && f !== void 0 ? f : "100%", F = e % 1, O = typeof j == "number" ? j * F : `calc(${j} * ${F})`;
      M = { ...M, width: O };
    }
    const L = $.createElement("span", { className: x, style: M, key: D }, "");
    A ? R.push(L) : R.push($.createElement(
      $.Fragment,
      { key: D },
      L,
      $.createElement("br", null)
    ));
  }
  return $.createElement("span", { className: r, "data-testid": i, "aria-live": "polite", "aria-busy": (p = w.enableAnimation) !== null && p !== void 0 ? p : EX }, t ? R.map((D, M) => $.createElement(t, { key: M }, D)) : R);
}
const hf = ({
  heightPx: e,
  variant: t
}) => /* @__PURE__ */ S.jsx(
  B5e,
  {
    height: e,
    baseColor: ti.color.skeletonLoaderBase,
    highlightColor: ti.color.skeletonLoaderHighlight,
    enableAnimation: !0,
    borderRadius: (t == null ? void 0 : t.size) === "medium" ? ti.borderRadius.baseContract.md : ti.borderRadius.baseContract.xl
  }
), L5e = k.createContext(void 0), SX = () => k.useContext(L5e), j5e = {
  mobile: 0,
  tablet: 520
  // desktop: 1280,
};
function fg(e, t, n) {
  let r = n.initialDeps ?? [], i;
  return () => {
    var o, s, c, u;
    let f;
    n.key && ((o = n.debug) != null && o.call(n)) && (f = Date.now());
    const p = e();
    if (!(p.length !== r.length || p.some((w, C) => r[C] !== w)))
      return i;
    r = p;
    let v;
    if (n.key && ((s = n.debug) != null && s.call(n)) && (v = Date.now()), i = t(...p), n.key && ((c = n.debug) != null && c.call(n))) {
      const w = Math.round((Date.now() - f) * 100) / 100, x = Math.round((Date.now() - v) * 100) / 100 / 16, A = (R, I) => {
        for (R = String(R); R.length < I; )
          R = " " + R;
        return R;
      };
    }
    return (u = n == null ? void 0 : n.onChange) == null || u.call(n, i), i;
  };
}
function aI(e, t) {
  if (e === void 0)
    throw new Error("Unexpected undefined");
  return e;
}
const F5e = (e, t) => Math.abs(e - t) < 1, U5e = (e, t, n) => {
  let r;
  return function(...i) {
    e.clearTimeout(r), r = e.setTimeout(() => t.apply(this, i), n);
  };
}, z5e = (e) => e, V5e = (e) => {
  const t = Math.max(e.startIndex - e.overscan, 0), n = Math.min(e.endIndex + e.overscan, e.count - 1), r = [];
  for (let i = t; i <= n; i++)
    r.push(i);
  return r;
}, $5e = (e, t) => {
  const n = e.scrollElement;
  if (!n)
    return;
  const r = e.targetWindow;
  if (!r)
    return;
  const i = (s) => {
    const { width: c, height: u } = s;
    t({ width: Math.round(c), height: Math.round(u) });
  };
  if (i(n.getBoundingClientRect()), !r.ResizeObserver)
    return () => {
    };
  const o = new r.ResizeObserver((s) => {
    const c = s[0];
    if (c != null && c.borderBoxSize) {
      const u = c.borderBoxSize[0];
      if (u) {
        i({ width: u.inlineSize, height: u.blockSize });
        return;
      }
    }
    i(n.getBoundingClientRect());
  });
  return o.observe(n, { box: "border-box" }), () => {
    o.unobserve(n);
  };
}, Y9 = {
  passive: !0
}, H5e = typeof window > "u" ? !0 : "onscrollend" in window, q5e = (e, t) => {
  const n = e.scrollElement;
  if (!n)
    return;
  const r = e.targetWindow;
  if (!r)
    return;
  let i = 0;
  const o = H5e ? () => {
  } : U5e(
    r,
    () => {
      t(i, !1);
    },
    e.options.isScrollingResetDelay
  ), s = (f) => () => {
    const { horizontal: p, isRtl: y } = e.options;
    i = p ? n.scrollLeft * (y && -1 || 1) : n.scrollTop, o(), t(i, f);
  }, c = s(!0), u = s(!1);
  return u(), n.addEventListener("scroll", c, Y9), n.addEventListener("scrollend", u, Y9), () => {
    n.removeEventListener("scroll", c), n.removeEventListener("scrollend", u);
  };
}, W5e = (e, t, n) => {
  if (t != null && t.borderBoxSize) {
    const r = t.borderBoxSize[0];
    if (r)
      return Math.round(
        r[n.options.horizontal ? "inlineSize" : "blockSize"]
      );
  }
  return Math.round(
    e.getBoundingClientRect()[n.options.horizontal ? "width" : "height"]
  );
}, G5e = (e, {
  adjustments: t = 0,
  behavior: n
}, r) => {
  var i, o;
  const s = e + t;
  (o = (i = r.scrollElement) == null ? void 0 : i.scrollTo) == null || o.call(i, {
    [r.options.horizontal ? "left" : "top"]: s,
    behavior: n
  });
};
class K5e {
  constructor(t) {
    this.unsubs = [], this.scrollElement = null, this.targetWindow = null, this.isScrolling = !1, this.scrollToIndexTimeoutId = null, this.measurementsCache = [], this.itemSizeCache = /* @__PURE__ */ new Map(), this.pendingMeasuredCacheIndexes = [], this.scrollRect = null, this.scrollOffset = null, this.scrollDirection = null, this.scrollAdjustments = 0, this.elementsCache = /* @__PURE__ */ new Map(), this.observer = /* @__PURE__ */ (() => {
      let n = null;
      const r = () => n || (!this.targetWindow || !this.targetWindow.ResizeObserver ? null : n = new this.targetWindow.ResizeObserver((i) => {
        i.forEach((o) => {
          this._measureElement(o.target, o);
        });
      }));
      return {
        disconnect: () => {
          var i;
          (i = r()) == null || i.disconnect(), n = null;
        },
        observe: (i) => {
          var o;
          return (o = r()) == null ? void 0 : o.observe(i, { box: "border-box" });
        },
        unobserve: (i) => {
          var o;
          return (o = r()) == null ? void 0 : o.unobserve(i);
        }
      };
    })(), this.range = null, this.setOptions = (n) => {
      Object.entries(n).forEach(([r, i]) => {
        typeof i > "u" && delete n[r];
      }), this.options = {
        debug: !1,
        initialOffset: 0,
        overscan: 1,
        paddingStart: 0,
        paddingEnd: 0,
        scrollPaddingStart: 0,
        scrollPaddingEnd: 0,
        horizontal: !1,
        getItemKey: z5e,
        rangeExtractor: V5e,
        onChange: () => {
        },
        measureElement: W5e,
        initialRect: { width: 0, height: 0 },
        scrollMargin: 0,
        gap: 0,
        indexAttribute: "data-index",
        initialMeasurementsCache: [],
        lanes: 1,
        isScrollingResetDelay: 150,
        enabled: !0,
        isRtl: !1,
        ...n
      };
    }, this.notify = (n) => {
      var r, i;
      (i = (r = this.options).onChange) == null || i.call(r, this, n);
    }, this.maybeNotify = fg(
      () => (this.calculateRange(), [
        this.isScrolling,
        this.range ? this.range.startIndex : null,
        this.range ? this.range.endIndex : null
      ]),
      (n) => {
        this.notify(n);
      },
      {
        key: ct.env.NODE_ENV !== "production" && "maybeNotify",
        debug: () => this.options.debug,
        initialDeps: [
          this.isScrolling,
          this.range ? this.range.startIndex : null,
          this.range ? this.range.endIndex : null
        ]
      }
    ), this.cleanup = () => {
      this.unsubs.filter(Boolean).forEach((n) => n()), this.unsubs = [], this.observer.disconnect(), this.scrollElement = null, this.targetWindow = null;
    }, this._didMount = () => () => {
      this.cleanup();
    }, this._willUpdate = () => {
      var n;
      const r = this.options.enabled ? this.options.getScrollElement() : null;
      if (this.scrollElement !== r) {
        if (this.cleanup(), !r) {
          this.maybeNotify();
          return;
        }
        this.scrollElement = r, this.scrollElement && "ownerDocument" in this.scrollElement ? this.targetWindow = this.scrollElement.ownerDocument.defaultView : this.targetWindow = ((n = this.scrollElement) == null ? void 0 : n.window) ?? null, this.elementsCache.forEach((i) => {
          this.observer.observe(i);
        }), this._scrollToOffset(this.getScrollOffset(), {
          adjustments: void 0,
          behavior: void 0
        }), this.unsubs.push(
          this.options.observeElementRect(this, (i) => {
            this.scrollRect = i, this.maybeNotify();
          })
        ), this.unsubs.push(
          this.options.observeElementOffset(this, (i, o) => {
            this.scrollAdjustments = 0, this.scrollDirection = o ? this.getScrollOffset() < i ? "forward" : "backward" : null, this.scrollOffset = i, this.isScrolling = o, this.maybeNotify();
          })
        );
      }
    }, this.getSize = () => this.options.enabled ? (this.scrollRect = this.scrollRect ?? this.options.initialRect, this.scrollRect[this.options.horizontal ? "width" : "height"]) : (this.scrollRect = null, 0), this.getScrollOffset = () => this.options.enabled ? (this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset == "function" ? this.options.initialOffset() : this.options.initialOffset), this.scrollOffset) : (this.scrollOffset = null, 0), this.getFurthestMeasurement = (n, r) => {
      const i = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
      for (let s = r - 1; s >= 0; s--) {
        const c = n[s];
        if (i.has(c.lane))
          continue;
        const u = o.get(
          c.lane
        );
        if (u == null || c.end > u.end ? o.set(c.lane, c) : c.end < u.end && i.set(c.lane, !0), i.size === this.options.lanes)
          break;
      }
      return o.size === this.options.lanes ? Array.from(o.values()).sort((s, c) => s.end === c.end ? s.index - c.index : s.end - c.end)[0] : void 0;
    }, this.getMeasurementOptions = fg(
      () => [
        this.options.count,
        this.options.paddingStart,
        this.options.scrollMargin,
        this.options.getItemKey,
        this.options.enabled
      ],
      (n, r, i, o, s) => (this.pendingMeasuredCacheIndexes = [], {
        count: n,
        paddingStart: r,
        scrollMargin: i,
        getItemKey: o,
        enabled: s
      }),
      {
        key: !1
      }
    ), this.getMeasurements = fg(
      () => [this.getMeasurementOptions(), this.itemSizeCache],
      ({ count: n, paddingStart: r, scrollMargin: i, getItemKey: o, enabled: s }, c) => {
        if (!s)
          return this.measurementsCache = [], this.itemSizeCache.clear(), [];
        this.measurementsCache.length === 0 && (this.measurementsCache = this.options.initialMeasurementsCache, this.measurementsCache.forEach((p) => {
          this.itemSizeCache.set(p.key, p.size);
        }));
        const u = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;
        this.pendingMeasuredCacheIndexes = [];
        const f = this.measurementsCache.slice(0, u);
        for (let p = u; p < n; p++) {
          const y = o(p), v = this.options.lanes === 1 ? f[p - 1] : this.getFurthestMeasurement(f, p), w = v ? v.end + this.options.gap : r + i, C = c.get(y), x = typeof C == "number" ? C : this.options.estimateSize(p), A = w + x, R = v ? v.lane : p % this.options.lanes;
          f[p] = {
            index: p,
            start: w,
            size: x,
            end: A,
            key: y,
            lane: R
          };
        }
        return this.measurementsCache = f, f;
      },
      {
        key: ct.env.NODE_ENV !== "production" && "getMeasurements",
        debug: () => this.options.debug
      }
    ), this.calculateRange = fg(
      () => [this.getMeasurements(), this.getSize(), this.getScrollOffset()],
      (n, r, i) => this.range = n.length > 0 && r > 0 ? Y5e({
        measurements: n,
        outerSize: r,
        scrollOffset: i
      }) : null,
      {
        key: ct.env.NODE_ENV !== "production" && "calculateRange",
        debug: () => this.options.debug
      }
    ), this.getIndexes = fg(
      () => [
        this.options.rangeExtractor,
        this.calculateRange(),
        this.options.overscan,
        this.options.count
      ],
      (n, r, i, o) => r === null ? [] : n({
        startIndex: r.startIndex,
        endIndex: r.endIndex,
        overscan: i,
        count: o
      }),
      {
        key: ct.env.NODE_ENV !== "production" && "getIndexes",
        debug: () => this.options.debug
      }
    ), this.indexFromElement = (n) => {
      const r = this.options.indexAttribute, i = n.getAttribute(r);
      return i ? parseInt(i, 10) : -1;
    }, this._measureElement = (n, r) => {
      const i = this.indexFromElement(n), o = this.measurementsCache[i];
      if (!o)
        return;
      const s = o.key, c = this.elementsCache.get(s);
      c !== n && (c && this.observer.unobserve(c), this.observer.observe(n), this.elementsCache.set(s, n)), n.isConnected && this.resizeItem(i, this.options.measureElement(n, r, this));
    }, this.resizeItem = (n, r) => {
      const i = this.measurementsCache[n];
      if (!i)
        return;
      const o = this.itemSizeCache.get(i.key) ?? i.size, s = r - o;
      s !== 0 && ((this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(i, s, this) : i.start < this.getScrollOffset() + this.scrollAdjustments) && (ct.env.NODE_ENV !== "production" && this.options.debug, this._scrollToOffset(this.getScrollOffset(), {
        adjustments: this.scrollAdjustments += s,
        behavior: void 0
      })), this.pendingMeasuredCacheIndexes.push(i.index), this.itemSizeCache = new Map(this.itemSizeCache.set(i.key, r)), this.notify(!1));
    }, this.measureElement = (n) => {
      if (!n) {
        this.elementsCache.forEach((r, i) => {
          r.isConnected || (this.observer.unobserve(r), this.elementsCache.delete(i));
        });
        return;
      }
      this._measureElement(n, void 0);
    }, this.getVirtualItems = fg(
      () => [this.getIndexes(), this.getMeasurements()],
      (n, r) => {
        const i = [];
        for (let o = 0, s = n.length; o < s; o++) {
          const c = n[o], u = r[c];
          i.push(u);
        }
        return i;
      },
      {
        key: ct.env.NODE_ENV !== "production" && "getVirtualItems",
        debug: () => this.options.debug
      }
    ), this.getVirtualItemForOffset = (n) => {
      const r = this.getMeasurements();
      if (r.length !== 0)
        return aI(
          r[kX(
            0,
            r.length - 1,
            (i) => aI(r[i]).start,
            n
          )]
        );
    }, this.getOffsetForAlignment = (n, r) => {
      const i = this.getSize(), o = this.getScrollOffset();
      r === "auto" && (n <= o ? r = "start" : n >= o + i ? r = "end" : r = "start"), r === "start" ? n = n : r === "end" ? n = n - i : r === "center" && (n = n - i / 2);
      const s = this.options.horizontal ? "scrollWidth" : "scrollHeight", u = (this.scrollElement ? "document" in this.scrollElement ? this.scrollElement.document.documentElement[s] : this.scrollElement[s] : 0) - i;
      return Math.max(Math.min(u, n), 0);
    }, this.getOffsetForIndex = (n, r = "auto") => {
      n = Math.max(0, Math.min(n, this.options.count - 1));
      const i = this.measurementsCache[n];
      if (!i)
        return;
      const o = this.getSize(), s = this.getScrollOffset();
      if (r === "auto")
        if (i.end >= s + o - this.options.scrollPaddingEnd)
          r = "end";
        else if (i.start <= s + this.options.scrollPaddingStart)
          r = "start";
        else
          return [s, r];
      const c = r === "end" ? i.end + this.options.scrollPaddingEnd : i.start - this.options.scrollPaddingStart;
      return [this.getOffsetForAlignment(c, r), r];
    }, this.isDynamicMode = () => this.elementsCache.size > 0, this.cancelScrollToIndex = () => {
      this.scrollToIndexTimeoutId !== null && this.targetWindow && (this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId), this.scrollToIndexTimeoutId = null);
    }, this.scrollToOffset = (n, { align: r = "start", behavior: i } = {}) => {
      this.cancelScrollToIndex(), i === "smooth" && this.isDynamicMode(), this._scrollToOffset(this.getOffsetForAlignment(n, r), {
        adjustments: void 0,
        behavior: i
      });
    }, this.scrollToIndex = (n, { align: r = "auto", behavior: i } = {}) => {
      n = Math.max(0, Math.min(n, this.options.count - 1)), this.cancelScrollToIndex(), i === "smooth" && this.isDynamicMode();
      const o = this.getOffsetForIndex(n, r);
      if (!o) return;
      const [s, c] = o;
      this._scrollToOffset(s, { adjustments: void 0, behavior: i }), i !== "smooth" && this.isDynamicMode() && this.targetWindow && (this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(() => {
        if (this.scrollToIndexTimeoutId = null, this.elementsCache.has(
          this.options.getItemKey(n)
        )) {
          const [f] = aI(
            this.getOffsetForIndex(n, c)
          );
          F5e(f, this.getScrollOffset()) || this.scrollToIndex(n, { align: c, behavior: i });
        } else
          this.scrollToIndex(n, { align: c, behavior: i });
      }));
    }, this.scrollBy = (n, { behavior: r } = {}) => {
      this.cancelScrollToIndex(), r === "smooth" && this.isDynamicMode(), this._scrollToOffset(this.getScrollOffset() + n, {
        adjustments: void 0,
        behavior: r
      });
    }, this.getTotalSize = () => {
      var n;
      const r = this.getMeasurements();
      let i;
      return r.length === 0 ? i = this.options.paddingStart : i = this.options.lanes === 1 ? ((n = r[r.length - 1]) == null ? void 0 : n.end) ?? 0 : Math.max(
        ...r.slice(-this.options.lanes).map((o) => o.end)
      ), Math.max(
        i - this.options.scrollMargin + this.options.paddingEnd,
        0
      );
    }, this._scrollToOffset = (n, {
      adjustments: r,
      behavior: i
    }) => {
      this.options.scrollToFn(n, { behavior: i, adjustments: r }, this);
    }, this.measure = () => {
      this.itemSizeCache = /* @__PURE__ */ new Map(), this.notify(!1);
    }, this.setOptions(t);
  }
}
const kX = (e, t, n, r) => {
  for (; e <= t; ) {
    const i = (e + t) / 2 | 0, o = n(i);
    if (o < r)
      e = i + 1;
    else if (o > r)
      t = i - 1;
    else
      return i;
  }
  return e > 0 ? e - 1 : 0;
};
function Y5e({
  measurements: e,
  outerSize: t,
  scrollOffset: n
}) {
  const r = e.length - 1, o = kX(0, r, (c) => e[c].start, n);
  let s = o;
  for (; s < r && e[s].end < n + t; )
    s++;
  return { startIndex: o, endIndex: s };
}
const Q5e = typeof document < "u" ? k.useLayoutEffect : k.useEffect;
function X5e(e) {
  const t = k.useReducer(() => ({}), {})[1], n = {
    ...e,
    onChange: (i, o) => {
      var s;
      o ? Wu.flushSync(t) : t(), (s = e.onChange) == null || s.call(e, i, o);
    }
  }, [r] = k.useState(
    () => new K5e(n)
  );
  return r.setOptions(n), k.useEffect(() => r._didMount(), []), Q5e(() => r._willUpdate()), r;
}
function AX(e) {
  return X5e({
    observeElementRect: $5e,
    observeElementOffset: q5e,
    scrollToFn: G5e,
    ...e
  });
}
var TX = "aruav30", _X = "aruav31", RX = "aruav32";
const SN = ({
  data: e,
  itemContent: t,
  className: n,
  estimateSize: r,
  maxHeight: i = 600,
  hasNextPage: o,
  isFetchingNextPage: s,
  fetchNextPage: c
}) => {
  var A;
  const u = k.useRef(null), f = SX(), p = OX(), y = AX({
    count: e.length,
    getScrollElement: () => u.current,
    estimateSize: r,
    overscan: 10,
    ...f && { observeElementRect: f }
  }), v = y.getVirtualItems(), w = k.useMemo(
    () => Wn.head([...v].reverse()).filter((R) => R.index >= e.length - 1).isJust(),
    [v, e.length]
  ), C = Pr(c);
  k.useEffect(() => {
    he.fromFalsy(w).filter(() => !!o && !s).ifJust(() => {
      var R;
      return (R = C.current) == null ? void 0 : R.call(C);
    });
  }, [w, o, s, C]);
  const x = p ? i : "max(65vh, 400px)";
  return /* @__PURE__ */ S.jsx(ae, { ref: u, className: zs([TX, n]), children: /* @__PURE__ */ S.jsx(
    ae,
    {
      className: _X,
      style: {
        height: `${y.getTotalSize()}px`,
        maxHeight: x
      },
      children: /* @__PURE__ */ S.jsxs(
        ae,
        {
          className: RX,
          style: {
            transform: `translateY(${((A = v[0]) == null ? void 0 : A.start) ?? 0}px)`
          },
          children: [
            v.map((R) => /* @__PURE__ */ S.jsx(
              ae,
              {
                "data-index": R.index,
                ref: y.measureElement,
                children: t(R.index, e[R.index])
              },
              R.key
            )),
            s && /* @__PURE__ */ S.jsx(ae, { justifyContent: "center", display: "flex", my: "4", children: /* @__PURE__ */ S.jsx(Wl, {}) })
          ]
        }
      )
    }
  ) });
}, kN = ({
  itemContent: e,
  groupContent: t,
  increaseViewportBy: n,
  groupCounts: r,
  className: i,
  maxHeight: o = 600,
  estimateSize: s,
  hasNextPage: c,
  isFetchingNextPage: u,
  fetchNextPage: f
}) => {
  var D;
  const p = k.useRef(null), y = OX(), v = SX(), w = AX({
    count: r.reduce(
      (M, L) => M + L,
      r.length
    ),
    getScrollElement: () => p.current,
    estimateSize: s,
    overscan: 10,
    paddingStart: n == null ? void 0 : n.top,
    paddingEnd: n == null ? void 0 : n.bottom,
    ...v && { observeElementRect: v }
  }), C = w.getVirtualItems(), x = Pr(f), { resultArray: A } = k.useMemo(
    () => r.reduce(
      (M, L, j) => (M.resultArray.push({ type: "parent", index: j }), M.resultArray.push(
        ...Array.from(
          { length: L },
          (F, O) => ({
            type: "child",
            index: M.childIndex + O,
            parentIndex: j
          })
        )
      ), M.childIndex += L, M),
      { resultArray: [], childIndex: 0 }
    ),
    [r]
  ), R = k.useMemo(
    () => Wn.head([...C].reverse()).filter((M) => M.index >= A.length - 1).isJust(),
    [C, A.length]
  );
  k.useEffect(() => {
    he.fromFalsy(R).filter(() => !!c && !u).ifJust(() => {
      var M;
      return (M = x.current) == null ? void 0 : M.call(x);
    });
  }, [R, c, u, x]);
  const I = y ? o : "max(65vh, 500px)";
  return /* @__PURE__ */ S.jsx(ae, { ref: p, className: zs([TX, i]), children: /* @__PURE__ */ S.jsx(
    ae,
    {
      className: _X,
      style: {
        height: `${w.getTotalSize()}px`,
        maxHeight: I
      },
      children: /* @__PURE__ */ S.jsxs(
        ae,
        {
          className: RX,
          style: {
            transform: `translateY(${((D = w.getVirtualItems()[0]) == null ? void 0 : D.start) ?? 0}px)`
          },
          children: [
            w.getVirtualItems().map((M) => {
              const L = A[M.index], j = L.type;
              return /* @__PURE__ */ S.jsx(
                ae,
                {
                  ref: w.measureElement,
                  "data-index": M.index,
                  children: j === "child" ? e(L.index, L.parentIndex) : t(L.index)
                },
                M.index
              );
            }),
            u && /* @__PURE__ */ S.jsx(ae, { justifyContent: "center", display: "flex", my: "4", children: /* @__PURE__ */ S.jsx(Wl, {}) })
          ]
        }
      )
    }
  ) });
}, OX = () => {
  const [e] = k.useState(
    () => Ro.map((t) => t.innerWidth).orDefault(0)
  );
  return e >= j5e.tablet;
}, J5e = (e) => {
  const t = /* @__PURE__ */ new Date(), n = 1e3 * 60 * 60 * 24, r = Date.UTC(t.getFullYear(), t.getMonth(), t.getDate()), i = Date.UTC(
    e.getFullYear(),
    e.getMonth(),
    e.getDate()
  );
  return Math.floor((i - r) / n);
}, IX = (e) => {
  const t = /* @__PURE__ */ new Date();
  return t.setDate(t.getDate() - 7), new Date(e) < t;
}, Z5e = {
  SUCCESS: "claim",
  FAILED: "actionRequired",
  CREATED: "pending",
  WAITING_FOR_NEXT: "pending",
  CANCELED: "actionRequired",
  PROCESSING: "claim"
}, eDe = (e) => {
  const { t } = ln(), n = k.useMemo(
    () => he.fromNullable(e.yieldData),
    [e.yieldData]
  ), r = cf({
    integrationData: n,
    validatorsAddresses: he.of(e.actionData.validatorAddresses ?? [])
  }), i = k.useMemo(
    () => he.of(e.actionData.type).map((f) => f.replaceAll("_", " ")).map(K4).extract(),
    [e]
  ), o = k.useMemo(
    () => he.of(e.actionData.createdAt).map(IX).orDefault(!1),
    [e]
  ), s = k.useMemo(
    () => he.fromNullable(e.actionData.status).map((f) => f === Pu.WAITING_FOR_NEXT ? o ? Pu.FAILED : t("activity.review.in_progress") : f).map((f) => f.replaceAll("_", " ")).map(K4).extract(),
    [e, t, o]
  ), c = k.useMemo(
    () => he.fromNullable(e.actionData.status).map((f) => f === Pu.WAITING_FOR_NEXT && o ? Pu.FAILED : f).map((f) => Z5e[f]).extract(),
    [e, o]
  ), u = k.useMemo(
    () => he.fromNullable(e.actionData.amount).map(Na),
    [e]
  );
  return {
    integrationData: n,
    providersDetails: r,
    actionType: i,
    amount: u,
    badgeLabel: s,
    badgeColor: c
  };
};
var tDe = "blr5el0", nDe = "blr5el1", rDe = "blr5el3 blr5el2 yv8y4rpj yv8y4rpm", iDe = "blr5el5 blr5el4 yv8y4rpj", oDe = "blr5el6", aDe = "blr5el8 blr5el7 yv8y4r2n yv8y4rpn yv8y4rdz", _D = Wb({ defaultClassName: "_8stx5f4 _8stx5f0 yv8y4ru", variantClassNames: { type: { claim: "_8stx5f5 _8stx5f1 yv8y4rwn yv8y4rwo", actionRequired: "_8stx5f6 _8stx5f2 yv8y4rwp yv8y4rwq", pending: "_8stx5f7 _8stx5f3 yv8y4rwr yv8y4rws" } }, defaultVariants: {}, compoundVariants: [] }), sDe = "_8stx5f9 _8stx5f8 yv8y4rpj yv8y4rpm", lDe = "_8stx5fa", cDe = "_8stx5fb";
const uDe = ({
  action: e,
  onActionSelect: t
}) => {
  const { t: n } = ln(), {
    integrationData: r,
    providersDetails: i,
    actionType: o,
    amount: s,
    badgeLabel: c,
    badgeColor: u
  } = eDe(e);
  return /* @__PURE__ */ S.jsx(ae, { py: "1", width: "full", children: r.mapOrDefault(
    (f) => /* @__PURE__ */ S.jsx(UA, { onClick: () => t(e), className: iDe, children: /* @__PURE__ */ S.jsxs(
      ae,
      {
        display: "flex",
        width: "full",
        justifyContent: "space-between",
        gap: "2",
        children: [
          /* @__PURE__ */ S.jsxs(
            ae,
            {
              display: "flex",
              justifyContent: "flex-start",
              alignItems: "center",
              children: [
                /* @__PURE__ */ S.jsx(nf, { metadata: f.metadata, token: f.token }),
                /* @__PURE__ */ S.jsxs(
                  ae,
                  {
                    display: "flex",
                    flexDirection: "column",
                    justifyContent: "center",
                    alignItems: "flex-start",
                    gap: "1",
                    children: [
                      /* @__PURE__ */ S.jsxs(ae, { className: rDe, children: [
                        /* @__PURE__ */ S.jsx(Ge, { children: f.token.symbol }),
                        /* @__PURE__ */ S.jsx(
                          ae,
                          {
                            className: _D({
                              type: u
                            }),
                            children: /* @__PURE__ */ S.jsx(
                              Ge,
                              {
                                variant: { type: "white", size: "small" },
                                className: oDe,
                                children: c
                              }
                            )
                          }
                        )
                      ] }),
                      i.chain(
                        (p) => Wn.head(p).map((y) => /* @__PURE__ */ S.jsx(
                          Ge,
                          {
                            className: nDe,
                            variant: {
                              type: "muted",
                              weight: "normal"
                            },
                            children: n("positions.via", {
                              providerName: y.name ?? y.address,
                              count: Math.max(p.length - 1, 1)
                            })
                          }
                        ))
                      ).extractNullable()
                    ]
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ S.jsxs(
            ae,
            {
              display: "flex",
              justifyContent: "center",
              alignItems: "flex-end",
              flexDirection: "column",
              textAlign: "end",
              gap: "1",
              children: [
                /* @__PURE__ */ S.jsx(Ge, { variant: { weight: "normal" }, children: o }),
                /* @__PURE__ */ S.jsxs(
                  Ge,
                  {
                    overflowWrap: "anywhere",
                    variant: { weight: "normal", type: "muted" },
                    children: [
                      s.extractNullable(),
                      " ",
                      f.token.symbol
                    ]
                  }
                )
              ]
            }
          )
        ]
      }
    ) }),
    /* @__PURE__ */ S.jsx(hf, { heightPx: 60 })
  ) });
}, dDe = ({
  isFirst: e,
  isLast: t
}) => /* @__PURE__ */ S.jsxs(
  ae,
  {
    flex: 1,
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    gap: "1",
    children: [
      /* @__PURE__ */ S.jsx(
        ae,
        {
          flex: 1,
          width: "1",
          background: e ? "transparent" : "tokenSelectBackground"
        }
      ),
      /* @__PURE__ */ S.jsx(
        ae,
        {
          width: "3",
          height: "3",
          borderRadius: "full",
          background: "tokenSelectBackground"
        }
      ),
      /* @__PURE__ */ S.jsx(
        ae,
        {
          flex: 1,
          width: "1",
          background: t ? "transparent" : "tokenSelectBackground"
        }
      )
    ]
  }
), fDe = () => {
  const { address: e, network: t } = fr(), n = Yue(), r = ap(), { isLedgerLive: i } = fr(), o = tc(), s = Jae({
    enabled: !!e && !!t,
    queryKey: Que({
      network: t,
      walletAddress: e
    }),
    queryFn: async ({ pageParam: u = 1 }) => (await Ye(
      () => n({
        page: u,
        walletAddress: e,
        network: t,
        sort: "createdAtDesc"
      })
    ).mapLeft(() => new Error("Could not get action list")).map((f) => ({
      ...f,
      data: f.data.filter(
        (p) => p.status !== Pu.CREATED
      )
    })).chain(
      async (f) => Ye.all(
        f.data.map(
          (p) => vA({
            yieldId: p.integrationId,
            isLedgerLive: i,
            queryClient: o,
            yieldYieldOpportunity: r
          }).map((y) => ({ actionData: p, yieldData: y })).chainLeft(() => Ye(() => Promise.resolve(null)))
        )
      ).map((p) => p.filter((y) => y !== null)).map((p) => p.filter((y) => !!y.actionData.inputToken)).map((p) => ({ ...f, data: p }))
    )).unsafeCoerce(),
    initialPageParam: 1,
    getNextPageParam: (u) => u.hasNextPage ? u.page + 1 : void 0
  });
  return {
    allItems: k.useMemo(
      () => {
        var u;
        return (u = s.data) == null ? void 0 : u.pages.flatMap((f) => f.data);
      },
      [s.data]
    ),
    ...s
  };
}, Uh = {
  ALONE: "alone",
  FIRST: "first",
  MIDDLE: "middle",
  LAST: "last"
}, DX = k.createContext(
  void 0
), hDe = ({
  children: e
}) => {
  const t = xb(), { openConnectModal: n } = cA(), { isConnected: r } = fr(), i = La(), { i18n: o } = ln(), s = (C) => {
    if (!r) return n == null ? void 0 : n();
    if (t.send({
      type: "setSelectedAction",
      data: he.of({
        selectedAction: C.actionData,
        selectedYield: C.yieldData
      })
    }), C.actionData.status === Pu.SUCCESS || C.actionData.status === Pu.PROCESSING) {
      const x = C.actionData.transactions.map((R) => ({ type: R.type, url: R.explorerUrl })).filter(
        (R) => !!R.url
      ), A = C.actionData.type === Tm.UNSTAKE ? "unstake" : C.actionData.type === Tm.STAKE ? "stake" : "pending";
      return i(`/activity/${A}-review/complete`, {
        state: {
          urls: x
        }
      });
    }
    if (C.actionData.status === Pu.CREATED || C.actionData.status === Pu.WAITING_FOR_NEXT || C.actionData.status === Pu.FAILED)
      return i("/activity/review");
  }, c = fDe(), u = k.useMemo(
    () => he.fromNullable(c.allItems),
    [c.allItems]
  ), f = k.useMemo(
    () => u.map((C) => C.map((x) => x.actionData.createdAt)),
    [u]
  ), [p, y] = k.useMemo(
    () => Aue(f.extract() ?? [], o),
    [f, o]
  ), v = k.useMemo(
    () => y.reduce(
      (C, x) => C.concat(mDe(x)),
      []
    ),
    [y]
  ), w = {
    onActionSelect: s,
    activityActions: c,
    labels: p,
    counts: y,
    bulletLines: v
  };
  return /* @__PURE__ */ S.jsx(DX.Provider, { value: w, children: e });
}, pDe = () => {
  const e = k.useContext(DX);
  if (!e)
    throw new Error(
      "useActivityPageContext must be used within a ActivityPageContext"
    );
  return e;
}, mDe = (e) => Array.from({ length: e }, (t, n) => e === 1 ? Uh.ALONE : n === 0 ? Uh.FIRST : n === e - 1 ? Uh.LAST : Uh.MIDDLE), yDe = (e, t) => e === "today" ? t("activity.date_group_labels.today") : e === "yesterday" ? t("activity.date_group_labels.yesterday") : e;
let Q9 = () => {
};
const vDe = () => ({
  closeChainModal: Q9,
  setCloseChainModal: (e) => {
    Q9 = e;
  }
}), AN = () => {
  const { connector: e } = fr(), { closeChainModal: t } = vDe();
  return ec({
    mutationFn: async (n) => {
      (await Ye.liftEither(
        e && zd(e) ? Pt(e) : Rn(new Error("Only Ledger Live is supported"))
      ).chain(
        (r) => r.requestAndSwitchAccount(n)
      ).ifRight(t)).unsafeCoerce();
    }
  });
}, gDe = (e) => {
  const { t } = ln(), { isLedgerLiveAccountPlaceholder: n, chain: r } = fr(), i = AN(), { openConnectModal: o } = cA(), s = Bi(), c = () => {
    if (n && r)
      return s("addLedgerAccountClicked"), i.mutate(r);
    s("connectWalletClicked"), o == null || o();
  };
  return /* @__PURE__ */ S.jsx(Jl, { onClick: c, ...e, children: t(
    n ? "init.ledger_add_account" : "init.connect_wallet"
  ) });
}, Tg = ({
  type: e
}) => {
  const { t } = ln(), { externalProviders: n } = dr(), r = () => e === "spinner" ? /* @__PURE__ */ S.jsx(ae, { display: "flex", justifyContent: "center", children: /* @__PURE__ */ S.jsx(Wl, {}) }) : e === "not_connected" && !n ? /* @__PURE__ */ S.jsx(gDe, {}) : e === "something_wrong" ? /* @__PURE__ */ S.jsx(Ge, { variant: { type: "danger" }, textAlign: "center", children: t("shared.something_went_wrong") }) : e === "no_current_positions" ? /* @__PURE__ */ S.jsx(Ge, { variant: { weight: "medium" }, textAlign: "center", children: t("positions.no_current_positions") }) : e === "no_previous_activity" ? /* @__PURE__ */ S.jsx(Ge, { variant: { weight: "medium" }, textAlign: "center", children: t("activity.no_previous_activity") }) : null;
  return /* @__PURE__ */ S.jsx(ae, { marginTop: "2", marginBottom: "4", children: r() });
}, bDe = () => {
  sa("activity");
  const { t: e } = ln(), { isConnected: t, isConnecting: n } = fr(), { mountAnimationFinished: r } = ff(), { activityActions: i, onActionSelect: o, labels: s, counts: c, bulletLines: u } = pDe(), f = i.allItems, p = k.useMemo(() => !t && !n ? /* @__PURE__ */ S.jsx(Tg, { type: "not_connected" }) : t && !(f != null && f.length) && !i.isPending ? /* @__PURE__ */ S.jsx(ae, { my: "4", children: /* @__PURE__ */ S.jsx(Tg, { type: "no_previous_activity" }) }) : t && i.isPending && !i.isFetchingNextPage ? /* @__PURE__ */ S.jsx(ae, { display: "flex", gap: "1", flexDirection: "column", children: [...Array(5).keys()].map((y) => /* @__PURE__ */ S.jsx(hf, { heightPx: 60 }, y)) }) : null, [
    t,
    n,
    f,
    i.isPending,
    i.isFetchingNextPage
  ]);
  return /* @__PURE__ */ S.jsx(
    gi.div,
    {
      initial: { opacity: 0, translateY: "-10px" },
      animate: { opacity: 1, translateY: 0 },
      transition: {
        duration: r ? 0.3 : 1,
        delay: r ? 0 : 1.5
      },
      children: /* @__PURE__ */ S.jsx(fp, { children: /* @__PURE__ */ S.jsxs(
        ae,
        {
          className: tDe,
          display: "flex",
          flex: 1,
          flexDirection: "column",
          children: [
            p,
            /* @__PURE__ */ S.jsx(ae, { display: "flex", flexDirection: "column", children: !i.isPending && f && /* @__PURE__ */ S.jsx(
              kN,
              {
                hasNextPage: i.hasNextPage,
                isFetchingNextPage: i.isFetchingNextPage,
                fetchNextPage: i.fetchNextPage,
                estimateSize: () => 60,
                groupCounts: c,
                groupContent: (y) => /* @__PURE__ */ S.jsx(ae, { py: "4", children: /* @__PURE__ */ S.jsx(Ge, { variant: { weight: "bold" }, children: yDe(s[y], e) }) }),
                itemContent: (y) => {
                  const v = f[y];
                  return /* @__PURE__ */ S.jsxs(ae, { className: aDe, children: [
                    /* @__PURE__ */ S.jsx(
                      dDe,
                      {
                        isFirst: u[y] === Uh.FIRST || u[y] === Uh.ALONE,
                        isLast: u[y] === Uh.LAST || u[y] === Uh.ALONE
                      }
                    ),
                    /* @__PURE__ */ S.jsx(
                      uDe,
                      {
                        onActionSelect: o,
                        action: v
                      }
                    )
                  ] });
                }
              }
            ) })
          ]
        }
      ) })
    }
  );
}, wDe = () => /* @__PURE__ */ S.jsx(hDe, { children: /* @__PURE__ */ S.jsx(bDe, {}) }), qm = () => /* @__PURE__ */ S.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    fill: "#909090",
    viewBox: "0 0 256 256",
    children: /* @__PURE__ */ S.jsx("path", { d: "M108 84a16 16 0 1 1 16 16 16 16 0 0 1-16-16Zm128 44A108 108 0 1 1 128 20a108.12 108.12 0 0 1 108 108Zm-24 0a84 84 0 1 0-84 84 84.09 84.09 0 0 0 84-84Zm-72 36.68V132a20 20 0 0 0-20-20 12 12 0 0 0-4 23.32V168a20 20 0 0 0 20 20 12 12 0 0 0 4-23.32Z" })
  }
), CDe = ["top", "right", "bottom", "left"], tp = Math.min, ll = Math.max, i8 = Math.round, Kk = Math.floor, np = (e) => ({
  x: e,
  y: e
}), xDe = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, EDe = {
  start: "end",
  end: "start"
};
function RD(e, t, n) {
  return ll(e, tp(t, n));
}
function rf(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function of(e) {
  return e.split("-")[0];
}
function Kb(e) {
  return e.split("-")[1];
}
function TN(e) {
  return e === "x" ? "y" : "x";
}
function _N(e) {
  return e === "y" ? "height" : "width";
}
function Yb(e) {
  return ["top", "bottom"].includes(of(e)) ? "y" : "x";
}
function RN(e) {
  return TN(Yb(e));
}
function SDe(e, t, n) {
  n === void 0 && (n = !1);
  const r = Kb(e), i = RN(e), o = _N(i);
  let s = i === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[o] > t.floating[o] && (s = o8(s)), [s, o8(s)];
}
function kDe(e) {
  const t = o8(e);
  return [OD(e), t, OD(t)];
}
function OD(e) {
  return e.replace(/start|end/g, (t) => EDe[t]);
}
function ADe(e, t, n) {
  const r = ["left", "right"], i = ["right", "left"], o = ["top", "bottom"], s = ["bottom", "top"];
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? i : r : t ? r : i;
    case "left":
    case "right":
      return t ? o : s;
    default:
      return [];
  }
}
function TDe(e, t, n, r) {
  const i = Kb(e);
  let o = ADe(of(e), n === "start", r);
  return i && (o = o.map((s) => s + "-" + i), t && (o = o.concat(o.map(OD)))), o;
}
function o8(e) {
  return e.replace(/left|right|bottom|top/g, (t) => xDe[t]);
}
function _De(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function MX(e) {
  return typeof e != "number" ? _De(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function a8(e) {
  return {
    ...e,
    top: e.y,
    left: e.x,
    right: e.x + e.width,
    bottom: e.y + e.height
  };
}
function X9(e, t, n) {
  let {
    reference: r,
    floating: i
  } = e;
  const o = Yb(t), s = RN(t), c = _N(s), u = of(t), f = o === "y", p = r.x + r.width / 2 - i.width / 2, y = r.y + r.height / 2 - i.height / 2, v = r[c] / 2 - i[c] / 2;
  let w;
  switch (u) {
    case "top":
      w = {
        x: p,
        y: r.y - i.height
      };
      break;
    case "bottom":
      w = {
        x: p,
        y: r.y + r.height
      };
      break;
    case "right":
      w = {
        x: r.x + r.width,
        y
      };
      break;
    case "left":
      w = {
        x: r.x - i.width,
        y
      };
      break;
    default:
      w = {
        x: r.x,
        y: r.y
      };
  }
  switch (Kb(t)) {
    case "start":
      w[s] -= v * (n && f ? -1 : 1);
      break;
    case "end":
      w[s] += v * (n && f ? -1 : 1);
      break;
  }
  return w;
}
const RDe = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: o = [],
    platform: s
  } = n, c = o.filter(Boolean), u = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let f = await s.getElementRects({
    reference: e,
    floating: t,
    strategy: i
  }), {
    x: p,
    y
  } = X9(f, r, u), v = r, w = {}, C = 0;
  for (let x = 0; x < c.length; x++) {
    const {
      name: A,
      fn: R
    } = c[x], {
      x: I,
      y: D,
      data: M,
      reset: L
    } = await R({
      x: p,
      y,
      initialPlacement: r,
      placement: v,
      strategy: i,
      middlewareData: w,
      rects: f,
      platform: s,
      elements: {
        reference: e,
        floating: t
      }
    });
    if (p = I ?? p, y = D ?? y, w = {
      ...w,
      [A]: {
        ...w[A],
        ...M
      }
    }, L && C <= 50) {
      C++, typeof L == "object" && (L.placement && (v = L.placement), L.rects && (f = L.rects === !0 ? await s.getElementRects({
        reference: e,
        floating: t,
        strategy: i
      }) : L.rects), {
        x: p,
        y
      } = X9(f, v, u)), x = -1;
      continue;
    }
  }
  return {
    x: p,
    y,
    placement: v,
    strategy: i,
    middlewareData: w
  };
};
async function EC(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: i,
    platform: o,
    rects: s,
    elements: c,
    strategy: u
  } = e, {
    boundary: f = "clippingAncestors",
    rootBoundary: p = "viewport",
    elementContext: y = "floating",
    altBoundary: v = !1,
    padding: w = 0
  } = rf(t, e), C = MX(w), A = c[v ? y === "floating" ? "reference" : "floating" : y], R = a8(await o.getClippingRect({
    element: (n = await (o.isElement == null ? void 0 : o.isElement(A))) == null || n ? A : A.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(c.floating)),
    boundary: f,
    rootBoundary: p,
    strategy: u
  })), I = y === "floating" ? {
    ...s.floating,
    x: r,
    y: i
  } : s.reference, D = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(c.floating)), M = await (o.isElement == null ? void 0 : o.isElement(D)) ? await (o.getScale == null ? void 0 : o.getScale(D)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, L = a8(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: I,
    offsetParent: D,
    strategy: u
  }) : I);
  return {
    top: (R.top - L.top + C.top) / M.y,
    bottom: (L.bottom - R.bottom + C.bottom) / M.y,
    left: (R.left - L.left + C.left) / M.x,
    right: (L.right - R.right + C.right) / M.x
  };
}
const ODe = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: r,
      placement: i,
      rects: o,
      platform: s,
      elements: c,
      middlewareData: u
    } = t, {
      element: f,
      padding: p = 0
    } = rf(e, t) || {};
    if (f == null)
      return {};
    const y = MX(p), v = {
      x: n,
      y: r
    }, w = RN(i), C = _N(w), x = await s.getDimensions(f), A = w === "y", R = A ? "top" : "left", I = A ? "bottom" : "right", D = A ? "clientHeight" : "clientWidth", M = o.reference[C] + o.reference[w] - v[w] - o.floating[C], L = v[w] - o.reference[w], j = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(f));
    let F = j ? j[D] : 0;
    (!F || !await (s.isElement == null ? void 0 : s.isElement(j))) && (F = c.floating[D] || o.floating[C]);
    const O = M / 2 - L / 2, z = F / 2 - x[C] / 2 - 1, H = tp(y[R], z), Q = tp(y[I], z), Y = H, ee = F - x[C] - Q, ie = F / 2 - x[C] / 2 + O, X = RD(Y, ie, ee), Z = !u.arrow && Kb(i) != null && ie != X && o.reference[C] / 2 - (ie < Y ? H : Q) - x[C] / 2 < 0, J = Z ? ie < Y ? ie - Y : ie - ee : 0;
    return {
      [w]: v[w] + J,
      data: {
        [w]: X,
        centerOffset: ie - X - J,
        ...Z && {
          alignmentOffset: J
        }
      },
      reset: Z
    };
  }
}), IDe = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: i,
        middlewareData: o,
        rects: s,
        initialPlacement: c,
        platform: u,
        elements: f
      } = t, {
        mainAxis: p = !0,
        crossAxis: y = !0,
        fallbackPlacements: v,
        fallbackStrategy: w = "bestFit",
        fallbackAxisSideDirection: C = "none",
        flipAlignment: x = !0,
        ...A
      } = rf(e, t);
      if ((n = o.arrow) != null && n.alignmentOffset)
        return {};
      const R = of(i), I = of(c) === c, D = await (u.isRTL == null ? void 0 : u.isRTL(f.floating)), M = v || (I || !x ? [o8(c)] : kDe(c));
      !v && C !== "none" && M.push(...TDe(c, x, C, D));
      const L = [c, ...M], j = await EC(t, A), F = [];
      let O = ((r = o.flip) == null ? void 0 : r.overflows) || [];
      if (p && F.push(j[R]), y) {
        const Y = SDe(i, s, D);
        F.push(j[Y[0]], j[Y[1]]);
      }
      if (O = [...O, {
        placement: i,
        overflows: F
      }], !F.every((Y) => Y <= 0)) {
        var z, H;
        const Y = (((z = o.flip) == null ? void 0 : z.index) || 0) + 1, ee = L[Y];
        if (ee)
          return {
            data: {
              index: Y,
              overflows: O
            },
            reset: {
              placement: ee
            }
          };
        let ie = (H = O.filter((X) => X.overflows[0] <= 0).sort((X, Z) => X.overflows[1] - Z.overflows[1])[0]) == null ? void 0 : H.placement;
        if (!ie)
          switch (w) {
            case "bestFit": {
              var Q;
              const X = (Q = O.map((Z) => [Z.placement, Z.overflows.filter((J) => J > 0).reduce((J, K) => J + K, 0)]).sort((Z, J) => Z[1] - J[1])[0]) == null ? void 0 : Q[0];
              X && (ie = X);
              break;
            }
            case "initialPlacement":
              ie = c;
              break;
          }
        if (i !== ie)
          return {
            reset: {
              placement: ie
            }
          };
      }
      return {};
    }
  };
};
function J9(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function Z9(e) {
  return CDe.some((t) => e[t] >= 0);
}
const DDe = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: r = "referenceHidden",
        ...i
      } = rf(e, t);
      switch (r) {
        case "referenceHidden": {
          const o = await EC(t, {
            ...i,
            elementContext: "reference"
          }), s = J9(o, n.reference);
          return {
            data: {
              referenceHiddenOffsets: s,
              referenceHidden: Z9(s)
            }
          };
        }
        case "escaped": {
          const o = await EC(t, {
            ...i,
            altBoundary: !0
          }), s = J9(o, n.floating);
          return {
            data: {
              escapedOffsets: s,
              escaped: Z9(s)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
async function MDe(e, t) {
  const {
    placement: n,
    platform: r,
    elements: i
  } = e, o = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), s = of(n), c = Kb(n), u = Yb(n) === "y", f = ["left", "top"].includes(s) ? -1 : 1, p = o && u ? -1 : 1, y = rf(t, e);
  let {
    mainAxis: v,
    crossAxis: w,
    alignmentAxis: C
  } = typeof y == "number" ? {
    mainAxis: y,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...y
  };
  return c && typeof C == "number" && (w = c === "end" ? C * -1 : C), u ? {
    x: w * p,
    y: v * f
  } : {
    x: v * f,
    y: w * p
  };
}
const PDe = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, r;
      const {
        x: i,
        y: o,
        placement: s,
        middlewareData: c
      } = t, u = await MDe(t, e);
      return s === ((n = c.offset) == null ? void 0 : n.placement) && (r = c.arrow) != null && r.alignmentOffset ? {} : {
        x: i + u.x,
        y: o + u.y,
        data: {
          ...u,
          placement: s
        }
      };
    }
  };
}, NDe = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: i
      } = t, {
        mainAxis: o = !0,
        crossAxis: s = !1,
        limiter: c = {
          fn: (A) => {
            let {
              x: R,
              y: I
            } = A;
            return {
              x: R,
              y: I
            };
          }
        },
        ...u
      } = rf(e, t), f = {
        x: n,
        y: r
      }, p = await EC(t, u), y = Yb(of(i)), v = TN(y);
      let w = f[v], C = f[y];
      if (o) {
        const A = v === "y" ? "top" : "left", R = v === "y" ? "bottom" : "right", I = w + p[A], D = w - p[R];
        w = RD(I, w, D);
      }
      if (s) {
        const A = y === "y" ? "top" : "left", R = y === "y" ? "bottom" : "right", I = C + p[A], D = C - p[R];
        C = RD(I, C, D);
      }
      const x = c.fn({
        ...t,
        [v]: w,
        [y]: C
      });
      return {
        ...x,
        data: {
          x: x.x - n,
          y: x.y - r
        }
      };
    }
  };
}, BDe = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: r,
        placement: i,
        rects: o,
        middlewareData: s
      } = t, {
        offset: c = 0,
        mainAxis: u = !0,
        crossAxis: f = !0
      } = rf(e, t), p = {
        x: n,
        y: r
      }, y = Yb(i), v = TN(y);
      let w = p[v], C = p[y];
      const x = rf(c, t), A = typeof x == "number" ? {
        mainAxis: x,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...x
      };
      if (u) {
        const D = v === "y" ? "height" : "width", M = o.reference[v] - o.floating[D] + A.mainAxis, L = o.reference[v] + o.reference[D] - A.mainAxis;
        w < M ? w = M : w > L && (w = L);
      }
      if (f) {
        var R, I;
        const D = v === "y" ? "width" : "height", M = ["top", "left"].includes(of(i)), L = o.reference[y] - o.floating[D] + (M && ((R = s.offset) == null ? void 0 : R[y]) || 0) + (M ? 0 : A.crossAxis), j = o.reference[y] + o.reference[D] + (M ? 0 : ((I = s.offset) == null ? void 0 : I[y]) || 0) - (M ? A.crossAxis : 0);
        C < L ? C = L : C > j && (C = j);
      }
      return {
        [v]: w,
        [y]: C
      };
    }
  };
}, LDe = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      const {
        placement: n,
        rects: r,
        platform: i,
        elements: o
      } = t, {
        apply: s = () => {
        },
        ...c
      } = rf(e, t), u = await EC(t, c), f = of(n), p = Kb(n), y = Yb(n) === "y", {
        width: v,
        height: w
      } = r.floating;
      let C, x;
      f === "top" || f === "bottom" ? (C = f, x = p === (await (i.isRTL == null ? void 0 : i.isRTL(o.floating)) ? "start" : "end") ? "left" : "right") : (x = f, C = p === "end" ? "top" : "bottom");
      const A = w - u[C], R = v - u[x], I = !t.middlewareData.shift;
      let D = A, M = R;
      if (y) {
        const j = v - u.left - u.right;
        M = p || I ? tp(R, j) : j;
      } else {
        const j = w - u.top - u.bottom;
        D = p || I ? tp(A, j) : j;
      }
      if (I && !p) {
        const j = ll(u.left, 0), F = ll(u.right, 0), O = ll(u.top, 0), z = ll(u.bottom, 0);
        y ? M = v - 2 * (j !== 0 || F !== 0 ? j + F : ll(u.left, u.right)) : D = w - 2 * (O !== 0 || z !== 0 ? O + z : ll(u.top, u.bottom));
      }
      await s({
        ...t,
        availableWidth: M,
        availableHeight: D
      });
      const L = await i.getDimensions(o.floating);
      return v !== L.width || w !== L.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function rp(e) {
  return PX(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function ul(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function pf(e) {
  var t;
  return (t = (PX(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function PX(e) {
  return e instanceof Node || e instanceof ul(e).Node;
}
function af(e) {
  return e instanceof Element || e instanceof ul(e).Element;
}
function Hu(e) {
  return e instanceof HTMLElement || e instanceof ul(e).HTMLElement;
}
function ez(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof ul(e).ShadowRoot;
}
function gx(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: i
  } = Zl(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(i);
}
function jDe(e) {
  return ["table", "td", "th"].includes(rp(e));
}
function ON(e) {
  const t = IN(), n = Zl(e);
  return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((r) => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (n.contain || "").includes(r));
}
function FDe(e) {
  let t = Sb(e);
  for (; Hu(t) && !HA(t); ) {
    if (ON(t))
      return t;
    t = Sb(t);
  }
  return null;
}
function IN() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function HA(e) {
  return ["html", "body", "#document"].includes(rp(e));
}
function Zl(e) {
  return ul(e).getComputedStyle(e);
}
function qA(e) {
  return af(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.pageXOffset,
    scrollTop: e.pageYOffset
  };
}
function Sb(e) {
  if (rp(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    ez(e) && e.host || // Fallback.
    pf(e)
  );
  return ez(t) ? t.host : t;
}
function NX(e) {
  const t = Sb(e);
  return HA(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Hu(t) && gx(t) ? t : NX(t);
}
function SC(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const i = NX(e), o = i === ((r = e.ownerDocument) == null ? void 0 : r.body), s = ul(i);
  return o ? t.concat(s, s.visualViewport || [], gx(i) ? i : [], s.frameElement && n ? SC(s.frameElement) : []) : t.concat(i, SC(i, [], n));
}
function BX(e) {
  const t = Zl(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const i = Hu(e), o = i ? e.offsetWidth : n, s = i ? e.offsetHeight : r, c = i8(n) !== o || i8(r) !== s;
  return c && (n = o, r = s), {
    width: n,
    height: r,
    $: c
  };
}
function DN(e) {
  return af(e) ? e : e.contextElement;
}
function Ng(e) {
  const t = DN(e);
  if (!Hu(t))
    return np(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: i,
    $: o
  } = BX(t);
  let s = (o ? i8(n.width) : n.width) / r, c = (o ? i8(n.height) : n.height) / i;
  return (!s || !Number.isFinite(s)) && (s = 1), (!c || !Number.isFinite(c)) && (c = 1), {
    x: s,
    y: c
  };
}
const UDe = /* @__PURE__ */ np(0);
function LX(e) {
  const t = ul(e);
  return !IN() || !t.visualViewport ? UDe : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function zDe(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== ul(e) ? !1 : t;
}
function iy(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const i = e.getBoundingClientRect(), o = DN(e);
  let s = np(1);
  t && (r ? af(r) && (s = Ng(r)) : s = Ng(e));
  const c = zDe(o, n, r) ? LX(o) : np(0);
  let u = (i.left + c.x) / s.x, f = (i.top + c.y) / s.y, p = i.width / s.x, y = i.height / s.y;
  if (o) {
    const v = ul(o), w = r && af(r) ? ul(r) : r;
    let C = v.frameElement;
    for (; C && r && w !== v; ) {
      const x = Ng(C), A = C.getBoundingClientRect(), R = Zl(C), I = A.left + (C.clientLeft + parseFloat(R.paddingLeft)) * x.x, D = A.top + (C.clientTop + parseFloat(R.paddingTop)) * x.y;
      u *= x.x, f *= x.y, p *= x.x, y *= x.y, u += I, f += D, C = ul(C).frameElement;
    }
  }
  return a8({
    width: p,
    height: y,
    x: u,
    y: f
  });
}
function VDe(e) {
  let {
    rect: t,
    offsetParent: n,
    strategy: r
  } = e;
  const i = Hu(n), o = pf(n);
  if (n === o)
    return t;
  let s = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = np(1);
  const u = np(0);
  if ((i || !i && r !== "fixed") && ((rp(n) !== "body" || gx(o)) && (s = qA(n)), Hu(n))) {
    const f = iy(n);
    c = Ng(n), u.x = f.x + n.clientLeft, u.y = f.y + n.clientTop;
  }
  return {
    width: t.width * c.x,
    height: t.height * c.y,
    x: t.x * c.x - s.scrollLeft * c.x + u.x,
    y: t.y * c.y - s.scrollTop * c.y + u.y
  };
}
function $De(e) {
  return Array.from(e.getClientRects());
}
function jX(e) {
  return iy(pf(e)).left + qA(e).scrollLeft;
}
function HDe(e) {
  const t = pf(e), n = qA(e), r = e.ownerDocument.body, i = ll(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), o = ll(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let s = -n.scrollLeft + jX(e);
  const c = -n.scrollTop;
  return Zl(r).direction === "rtl" && (s += ll(t.clientWidth, r.clientWidth) - i), {
    width: i,
    height: o,
    x: s,
    y: c
  };
}
function qDe(e, t) {
  const n = ul(e), r = pf(e), i = n.visualViewport;
  let o = r.clientWidth, s = r.clientHeight, c = 0, u = 0;
  if (i) {
    o = i.width, s = i.height;
    const f = IN();
    (!f || f && t === "fixed") && (c = i.offsetLeft, u = i.offsetTop);
  }
  return {
    width: o,
    height: s,
    x: c,
    y: u
  };
}
function WDe(e, t) {
  const n = iy(e, !0, t === "fixed"), r = n.top + e.clientTop, i = n.left + e.clientLeft, o = Hu(e) ? Ng(e) : np(1), s = e.clientWidth * o.x, c = e.clientHeight * o.y, u = i * o.x, f = r * o.y;
  return {
    width: s,
    height: c,
    x: u,
    y: f
  };
}
function tz(e, t, n) {
  let r;
  if (t === "viewport")
    r = qDe(e, n);
  else if (t === "document")
    r = HDe(pf(e));
  else if (af(t))
    r = WDe(t, n);
  else {
    const i = LX(e);
    r = {
      ...t,
      x: t.x - i.x,
      y: t.y - i.y
    };
  }
  return a8(r);
}
function FX(e, t) {
  const n = Sb(e);
  return n === t || !af(n) || HA(n) ? !1 : Zl(n).position === "fixed" || FX(n, t);
}
function GDe(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = SC(e, [], !1).filter((c) => af(c) && rp(c) !== "body"), i = null;
  const o = Zl(e).position === "fixed";
  let s = o ? Sb(e) : e;
  for (; af(s) && !HA(s); ) {
    const c = Zl(s), u = ON(s);
    !u && c.position === "fixed" && (i = null), (o ? !u && !i : !u && c.position === "static" && !!i && ["absolute", "fixed"].includes(i.position) || gx(s) && !u && FX(e, s)) ? r = r.filter((p) => p !== s) : i = c, s = Sb(s);
  }
  return t.set(e, r), r;
}
function KDe(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: i
  } = e;
  const s = [...n === "clippingAncestors" ? GDe(t, this._c) : [].concat(n), r], c = s[0], u = s.reduce((f, p) => {
    const y = tz(t, p, i);
    return f.top = ll(y.top, f.top), f.right = tp(y.right, f.right), f.bottom = tp(y.bottom, f.bottom), f.left = ll(y.left, f.left), f;
  }, tz(t, c, i));
  return {
    width: u.right - u.left,
    height: u.bottom - u.top,
    x: u.left,
    y: u.top
  };
}
function YDe(e) {
  const {
    width: t,
    height: n
  } = BX(e);
  return {
    width: t,
    height: n
  };
}
function QDe(e, t, n) {
  const r = Hu(t), i = pf(t), o = n === "fixed", s = iy(e, !0, o, t);
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const u = np(0);
  if (r || !r && !o)
    if ((rp(t) !== "body" || gx(i)) && (c = qA(t)), r) {
      const f = iy(t, !0, o, t);
      u.x = f.x + t.clientLeft, u.y = f.y + t.clientTop;
    } else i && (u.x = jX(i));
  return {
    x: s.left + c.scrollLeft - u.x,
    y: s.top + c.scrollTop - u.y,
    width: s.width,
    height: s.height
  };
}
function nz(e, t) {
  return !Hu(e) || Zl(e).position === "fixed" ? null : t ? t(e) : e.offsetParent;
}
function UX(e, t) {
  const n = ul(e);
  if (!Hu(e))
    return n;
  let r = nz(e, t);
  for (; r && jDe(r) && Zl(r).position === "static"; )
    r = nz(r, t);
  return r && (rp(r) === "html" || rp(r) === "body" && Zl(r).position === "static" && !ON(r)) ? n : r || FDe(e) || n;
}
const XDe = async function(e) {
  let {
    reference: t,
    floating: n,
    strategy: r
  } = e;
  const i = this.getOffsetParent || UX, o = this.getDimensions;
  return {
    reference: QDe(t, await i(n), r),
    floating: {
      x: 0,
      y: 0,
      ...await o(n)
    }
  };
};
function JDe(e) {
  return Zl(e).direction === "rtl";
}
const ZDe = {
  convertOffsetParentRelativeRectToViewportRelativeRect: VDe,
  getDocumentElement: pf,
  getClippingRect: KDe,
  getOffsetParent: UX,
  getElementRects: XDe,
  getClientRects: $De,
  getDimensions: YDe,
  getScale: Ng,
  isElement: af,
  isRTL: JDe
};
function eMe(e, t) {
  let n = null, r;
  const i = pf(e);
  function o() {
    clearTimeout(r), n && n.disconnect(), n = null;
  }
  function s(c, u) {
    c === void 0 && (c = !1), u === void 0 && (u = 1), o();
    const {
      left: f,
      top: p,
      width: y,
      height: v
    } = e.getBoundingClientRect();
    if (c || t(), !y || !v)
      return;
    const w = Kk(p), C = Kk(i.clientWidth - (f + y)), x = Kk(i.clientHeight - (p + v)), A = Kk(f), I = {
      rootMargin: -w + "px " + -C + "px " + -x + "px " + -A + "px",
      threshold: ll(0, tp(1, u)) || 1
    };
    let D = !0;
    function M(L) {
      const j = L[0].intersectionRatio;
      if (j !== u) {
        if (!D)
          return s();
        j ? s(!1, j) : r = setTimeout(() => {
          s(!1, 1e-7);
        }, 100);
      }
      D = !1;
    }
    try {
      n = new IntersectionObserver(M, {
        ...I,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(M, I);
    }
    n.observe(e);
  }
  return s(!0), o;
}
function tMe(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: o = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: c = typeof IntersectionObserver == "function",
    animationFrame: u = !1
  } = r, f = DN(e), p = i || o ? [...f ? SC(f) : [], ...SC(t)] : [];
  p.forEach((R) => {
    i && R.addEventListener("scroll", n, {
      passive: !0
    }), o && R.addEventListener("resize", n);
  });
  const y = f && c ? eMe(f, n) : null;
  let v = -1, w = null;
  s && (w = new ResizeObserver((R) => {
    let [I] = R;
    I && I.target === f && w && (w.unobserve(t), cancelAnimationFrame(v), v = requestAnimationFrame(() => {
      w && w.observe(t);
    })), n();
  }), f && !u && w.observe(f), w.observe(t));
  let C, x = u ? iy(e) : null;
  u && A();
  function A() {
    const R = iy(e);
    x && (R.x !== x.x || R.y !== x.y || R.width !== x.width || R.height !== x.height) && n(), x = R, C = requestAnimationFrame(A);
  }
  return n(), () => {
    p.forEach((R) => {
      i && R.removeEventListener("scroll", n), o && R.removeEventListener("resize", n);
    }), y && y(), w && w.disconnect(), w = null, u && cancelAnimationFrame(C);
  };
}
const nMe = NDe, rMe = IDe, iMe = LDe, oMe = DDe, rz = ODe, aMe = BDe, sMe = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), i = {
    platform: ZDe,
    ...n
  }, o = {
    ...i.platform,
    _c: r
  };
  return RDe(e, t, {
    ...i,
    platform: o
  });
}, lMe = (e) => {
  function t(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(n) {
      const {
        element: r,
        padding: i
      } = typeof e == "function" ? e(n) : e;
      return r && t(r) ? r.current != null ? rz({
        element: r.current,
        padding: i
      }).fn(n) : {} : r ? rz({
        element: r,
        padding: i
      }).fn(n) : {};
    }
  };
};
var b4 = typeof document < "u" ? k.useLayoutEffect : k.useEffect;
function s8(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, r, i;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n != t.length) return !1;
      for (r = n; r-- !== 0; )
        if (!s8(e[r], t[r]))
          return !1;
      return !0;
    }
    if (i = Object.keys(e), n = i.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(t, i[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const o = i[r];
      if (!(o === "_owner" && e.$$typeof) && !s8(e[o], t[o]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function zX(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function iz(e, t) {
  const n = zX(e);
  return Math.round(t * n) / n;
}
function oz(e) {
  const t = k.useRef(e);
  return b4(() => {
    t.current = e;
  }), t;
}
function cMe(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: i,
    elements: {
      reference: o,
      floating: s
    } = {},
    transform: c = !0,
    whileElementsMounted: u,
    open: f
  } = e, [p, y] = k.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [v, w] = k.useState(r);
  s8(v, r) || w(r);
  const [C, x] = k.useState(null), [A, R] = k.useState(null), I = k.useCallback((Z) => {
    Z != j.current && (j.current = Z, x(Z));
  }, [x]), D = k.useCallback((Z) => {
    Z !== F.current && (F.current = Z, R(Z));
  }, [R]), M = o || C, L = s || A, j = k.useRef(null), F = k.useRef(null), O = k.useRef(p), z = oz(u), H = oz(i), Q = k.useCallback(() => {
    if (!j.current || !F.current)
      return;
    const Z = {
      placement: t,
      strategy: n,
      middleware: v
    };
    H.current && (Z.platform = H.current), sMe(j.current, F.current, Z).then((J) => {
      const K = {
        ...J,
        isPositioned: !0
      };
      Y.current && !s8(O.current, K) && (O.current = K, Wu.flushSync(() => {
        y(K);
      }));
    });
  }, [v, t, n, H]);
  b4(() => {
    f === !1 && O.current.isPositioned && (O.current.isPositioned = !1, y((Z) => ({
      ...Z,
      isPositioned: !1
    })));
  }, [f]);
  const Y = k.useRef(!1);
  b4(() => (Y.current = !0, () => {
    Y.current = !1;
  }), []), b4(() => {
    if (M && (j.current = M), L && (F.current = L), M && L) {
      if (z.current)
        return z.current(M, L, Q);
      Q();
    }
  }, [M, L, Q, z]);
  const ee = k.useMemo(() => ({
    reference: j,
    floating: F,
    setReference: I,
    setFloating: D
  }), [I, D]), ie = k.useMemo(() => ({
    reference: M,
    floating: L
  }), [M, L]), X = k.useMemo(() => {
    const Z = {
      position: n,
      left: 0,
      top: 0
    };
    if (!ie.floating)
      return Z;
    const J = iz(ie.floating, p.x), K = iz(ie.floating, p.y);
    return c ? {
      ...Z,
      transform: "translate(" + J + "px, " + K + "px)",
      ...zX(ie.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: J,
      top: K
    };
  }, [n, c, ie.floating, p.x, p.y]);
  return k.useMemo(() => ({
    ...p,
    update: Q,
    refs: ee,
    elements: ie,
    floatingStyles: X
  }), [p, Q, ee, ie, X]);
}
var uMe = "Arrow", VX = k.forwardRef((e, t) => {
  const { children: n, width: r = 10, height: i = 5, ...o } = e;
  return /* @__PURE__ */ S.jsx(
    Li.svg,
    {
      ...o,
      ref: t,
      width: r,
      height: i,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e.asChild ? n : /* @__PURE__ */ S.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
VX.displayName = uMe;
var dMe = VX;
function fMe(e) {
  const [t, n] = k.useState(void 0);
  return ny(() => {
    if (e) {
      n({ width: e.offsetWidth, height: e.offsetHeight });
      const r = new ResizeObserver((i) => {
        if (!Array.isArray(i) || !i.length)
          return;
        const o = i[0];
        let s, c;
        if ("borderBoxSize" in o) {
          const u = o.borderBoxSize, f = Array.isArray(u) ? u[0] : u;
          s = f.inlineSize, c = f.blockSize;
        } else
          s = e.offsetWidth, c = e.offsetHeight;
        n({ width: s, height: c });
      });
      return r.observe(e, { box: "border-box" }), () => r.unobserve(e);
    } else
      n(void 0);
  }, [e]), t;
}
var MN = "Popper", [$X, WA] = hy(MN), [hMe, HX] = $X(MN), qX = (e) => {
  const { __scopePopper: t, children: n } = e, [r, i] = k.useState(null);
  return /* @__PURE__ */ S.jsx(hMe, { scope: t, anchor: r, onAnchorChange: i, children: n });
};
qX.displayName = MN;
var WX = "PopperAnchor", GX = k.forwardRef(
  (e, t) => {
    const { __scopePopper: n, virtualRef: r, ...i } = e, o = HX(WX, n), s = k.useRef(null), c = Oo(t, s);
    return k.useEffect(() => {
      o.onAnchorChange((r == null ? void 0 : r.current) || s.current);
    }), r ? null : /* @__PURE__ */ S.jsx(Li.div, { ...i, ref: c });
  }
);
GX.displayName = WX;
var PN = "PopperContent", [pMe, mMe] = $X(PN), KX = k.forwardRef(
  (e, t) => {
    var st, mt, yt, Ut, hn, wn;
    const {
      __scopePopper: n,
      side: r = "bottom",
      sideOffset: i = 0,
      align: o = "center",
      alignOffset: s = 0,
      arrowPadding: c = 0,
      avoidCollisions: u = !0,
      collisionBoundary: f = [],
      collisionPadding: p = 0,
      sticky: y = "partial",
      hideWhenDetached: v = !1,
      updatePositionStrategy: w = "optimized",
      onPlaced: C,
      ...x
    } = e, A = HX(PN, n), [R, I] = k.useState(null), D = Oo(t, (Ot) => I(Ot)), [M, L] = k.useState(null), j = fMe(M), F = (j == null ? void 0 : j.width) ?? 0, O = (j == null ? void 0 : j.height) ?? 0, z = r + (o !== "center" ? "-" + o : ""), H = typeof p == "number" ? p : { top: 0, right: 0, bottom: 0, left: 0, ...p }, Q = Array.isArray(f) ? f : [f], Y = Q.length > 0, ee = {
      padding: H,
      boundary: Q.filter(vMe),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: Y
    }, { refs: ie, floatingStyles: X, placement: Z, isPositioned: J, middlewareData: K } = cMe({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: z,
      whileElementsMounted: (...Ot) => tMe(...Ot, {
        animationFrame: w === "always"
      }),
      elements: {
        reference: A.anchor
      },
      middleware: [
        PDe({ mainAxis: i + O, alignmentAxis: s }),
        u && nMe({
          mainAxis: !0,
          crossAxis: !1,
          limiter: y === "partial" ? aMe() : void 0,
          ...ee
        }),
        u && rMe({ ...ee }),
        iMe({
          ...ee,
          apply: ({ elements: Ot, rects: xt, availableWidth: zt, availableHeight: Pn }) => {
            const { width: Fn, height: tr } = xt.reference, or = Ot.floating.style;
            or.setProperty("--radix-popper-available-width", `${zt}px`), or.setProperty("--radix-popper-available-height", `${Pn}px`), or.setProperty("--radix-popper-anchor-width", `${Fn}px`), or.setProperty("--radix-popper-anchor-height", `${tr}px`);
          }
        }),
        M && lMe({ element: M, padding: c }),
        gMe({ arrowWidth: F, arrowHeight: O }),
        v && oMe({ strategy: "referenceHidden", ...ee })
      ]
    }), [oe, be] = XX(Z), ce = $c(C);
    ny(() => {
      J && (ce == null || ce());
    }, [J, ce]);
    const pe = (st = K.arrow) == null ? void 0 : st.x, Ee = (mt = K.arrow) == null ? void 0 : mt.y, Se = ((yt = K.arrow) == null ? void 0 : yt.centerOffset) !== 0, [Me, Fe] = k.useState();
    return ny(() => {
      R && Fe(window.getComputedStyle(R).zIndex);
    }, [R]), /* @__PURE__ */ S.jsx(
      "div",
      {
        ref: ie.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...X,
          transform: J ? X.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: Me,
          "--radix-popper-transform-origin": [
            (Ut = K.transformOrigin) == null ? void 0 : Ut.x,
            (hn = K.transformOrigin) == null ? void 0 : hn.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((wn = K.hide) == null ? void 0 : wn.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: e.dir,
        children: /* @__PURE__ */ S.jsx(
          pMe,
          {
            scope: n,
            placedSide: oe,
            onArrowChange: L,
            arrowX: pe,
            arrowY: Ee,
            shouldHideArrow: Se,
            children: /* @__PURE__ */ S.jsx(
              Li.div,
              {
                "data-side": oe,
                "data-align": be,
                ...x,
                ref: D,
                style: {
                  ...x.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: J ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
KX.displayName = PN;
var YX = "PopperArrow", yMe = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, QX = k.forwardRef(function(t, n) {
  const { __scopePopper: r, ...i } = t, o = mMe(YX, r), s = yMe[o.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ S.jsx(
      "span",
      {
        ref: o.onArrowChange,
        style: {
          position: "absolute",
          left: o.arrowX,
          top: o.arrowY,
          [s]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[o.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[o.placedSide],
          visibility: o.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ S.jsx(
          dMe,
          {
            ...i,
            ref: n,
            style: {
              ...i.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
QX.displayName = YX;
function vMe(e) {
  return e !== null;
}
var gMe = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    var A, R, I;
    const { placement: n, rects: r, middlewareData: i } = t, s = ((A = i.arrow) == null ? void 0 : A.centerOffset) !== 0, c = s ? 0 : e.arrowWidth, u = s ? 0 : e.arrowHeight, [f, p] = XX(n), y = { start: "0%", center: "50%", end: "100%" }[p], v = (((R = i.arrow) == null ? void 0 : R.x) ?? 0) + c / 2, w = (((I = i.arrow) == null ? void 0 : I.y) ?? 0) + u / 2;
    let C = "", x = "";
    return f === "bottom" ? (C = s ? y : `${v}px`, x = `${-u}px`) : f === "top" ? (C = s ? y : `${v}px`, x = `${r.floating.height + u}px`) : f === "right" ? (C = `${-u}px`, x = s ? y : `${w}px`) : f === "left" && (C = `${r.floating.width + u}px`, x = s ? y : `${w}px`), { data: { x: C, y: x } };
  }
});
function XX(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
var JX = qX, ZX = GX, eJ = KX, tJ = QX, [GA, jje] = hy("Tooltip", [
  WA
]), KA = WA(), nJ = "TooltipProvider", bMe = 700, ID = "tooltip.open", [wMe, NN] = GA(nJ), rJ = (e) => {
  const {
    __scopeTooltip: t,
    delayDuration: n = bMe,
    skipDelayDuration: r = 300,
    disableHoverableContent: i = !1,
    children: o
  } = e, [s, c] = k.useState(!0), u = k.useRef(!1), f = k.useRef(0);
  return k.useEffect(() => {
    const p = f.current;
    return () => window.clearTimeout(p);
  }, []), /* @__PURE__ */ S.jsx(
    wMe,
    {
      scope: t,
      isOpenDelayed: s,
      delayDuration: n,
      onOpen: k.useCallback(() => {
        window.clearTimeout(f.current), c(!1);
      }, []),
      onClose: k.useCallback(() => {
        window.clearTimeout(f.current), f.current = window.setTimeout(
          () => c(!0),
          r
        );
      }, [r]),
      isPointerInTransitRef: u,
      onPointerInTransitChange: k.useCallback((p) => {
        u.current = p;
      }, []),
      disableHoverableContent: i,
      children: o
    }
  );
};
rJ.displayName = nJ;
var YA = "Tooltip", [CMe, bx] = GA(YA), iJ = (e) => {
  const {
    __scopeTooltip: t,
    children: n,
    open: r,
    defaultOpen: i = !1,
    onOpenChange: o,
    disableHoverableContent: s,
    delayDuration: c
  } = e, u = NN(YA, e.__scopeTooltip), f = KA(t), [p, y] = k.useState(null), v = Hm(), w = k.useRef(0), C = s ?? u.disableHoverableContent, x = c ?? u.delayDuration, A = k.useRef(!1), [R = !1, I] = LA({
    prop: r,
    defaultProp: i,
    onChange: (F) => {
      F ? (u.onOpen(), document.dispatchEvent(new CustomEvent(ID))) : u.onClose(), o == null || o(F);
    }
  }), D = k.useMemo(() => R ? A.current ? "delayed-open" : "instant-open" : "closed", [R]), M = k.useCallback(() => {
    window.clearTimeout(w.current), A.current = !1, I(!0);
  }, [I]), L = k.useCallback(() => {
    window.clearTimeout(w.current), I(!1);
  }, [I]), j = k.useCallback(() => {
    window.clearTimeout(w.current), w.current = window.setTimeout(() => {
      A.current = !0, I(!0);
    }, x);
  }, [x, I]);
  return k.useEffect(() => () => window.clearTimeout(w.current), []), /* @__PURE__ */ S.jsx(JX, { ...f, children: /* @__PURE__ */ S.jsx(
    CMe,
    {
      scope: t,
      contentId: v,
      open: R,
      stateAttribute: D,
      trigger: p,
      onTriggerChange: y,
      onTriggerEnter: k.useCallback(() => {
        u.isOpenDelayed ? j() : M();
      }, [u.isOpenDelayed, j, M]),
      onTriggerLeave: k.useCallback(() => {
        C ? L() : window.clearTimeout(w.current);
      }, [L, C]),
      onOpen: M,
      onClose: L,
      disableHoverableContent: C,
      children: n
    }
  ) });
};
iJ.displayName = YA;
var DD = "TooltipTrigger", oJ = k.forwardRef(
  (e, t) => {
    const { __scopeTooltip: n, ...r } = e, i = bx(DD, n), o = NN(DD, n), s = KA(n), c = k.useRef(null), u = Oo(t, c, i.onTriggerChange), f = k.useRef(!1), p = k.useRef(!1), y = k.useCallback(() => f.current = !1, []);
    return k.useEffect(() => () => document.removeEventListener("pointerup", y), [y]), /* @__PURE__ */ S.jsx(ZX, { asChild: !0, ...s, children: /* @__PURE__ */ S.jsx(
      Li.button,
      {
        "aria-describedby": i.open ? i.contentId : void 0,
        "data-state": i.stateAttribute,
        ...r,
        ref: u,
        onPointerMove: Ln(e.onPointerMove, (v) => {
          v.pointerType !== "touch" && !p.current && !o.isPointerInTransitRef.current && (i.onTriggerEnter(), p.current = !0);
        }),
        onPointerLeave: Ln(e.onPointerLeave, () => {
          i.onTriggerLeave(), p.current = !1;
        }),
        onPointerDown: Ln(e.onPointerDown, () => {
          f.current = !0, document.addEventListener("pointerup", y, { once: !0 });
        }),
        onFocus: Ln(e.onFocus, () => {
          f.current || i.onOpen();
        }),
        onBlur: Ln(e.onBlur, i.onClose),
        onClick: Ln(e.onClick, i.onClose)
      }
    ) });
  }
);
oJ.displayName = DD;
var BN = "TooltipPortal", [xMe, EMe] = GA(BN, {
  forceMount: void 0
}), aJ = (e) => {
  const { __scopeTooltip: t, forceMount: n, children: r, container: i } = e, o = bx(BN, t);
  return /* @__PURE__ */ S.jsx(xMe, { scope: t, forceMount: n, children: /* @__PURE__ */ S.jsx(uf, { present: n || o.open, children: /* @__PURE__ */ S.jsx(hN, { asChild: !0, container: i, children: r }) }) });
};
aJ.displayName = BN;
var kb = "TooltipContent", sJ = k.forwardRef(
  (e, t) => {
    const n = EMe(kb, e.__scopeTooltip), { forceMount: r = n.forceMount, side: i = "top", ...o } = e, s = bx(kb, e.__scopeTooltip);
    return /* @__PURE__ */ S.jsx(uf, { present: r || s.open, children: s.disableHoverableContent ? /* @__PURE__ */ S.jsx(lJ, { side: i, ...o, ref: t }) : /* @__PURE__ */ S.jsx(SMe, { side: i, ...o, ref: t }) });
  }
), SMe = k.forwardRef((e, t) => {
  const n = bx(kb, e.__scopeTooltip), r = NN(kb, e.__scopeTooltip), i = k.useRef(null), o = Oo(t, i), [s, c] = k.useState(null), { trigger: u, onClose: f } = n, p = i.current, { onPointerInTransitChange: y } = r, v = k.useCallback(() => {
    c(null), y(!1);
  }, [y]), w = k.useCallback(
    (C, x) => {
      const A = C.currentTarget, R = { x: C.clientX, y: C.clientY }, I = TMe(R, A.getBoundingClientRect()), D = _Me(R, I), M = RMe(x.getBoundingClientRect()), L = IMe([...D, ...M]);
      c(L), y(!0);
    },
    [y]
  );
  return k.useEffect(() => () => v(), [v]), k.useEffect(() => {
    if (u && p) {
      const C = (A) => w(A, p), x = (A) => w(A, u);
      return u.addEventListener("pointerleave", C), p.addEventListener("pointerleave", x), () => {
        u.removeEventListener("pointerleave", C), p.removeEventListener("pointerleave", x);
      };
    }
  }, [u, p, w, v]), k.useEffect(() => {
    if (s) {
      const C = (x) => {
        const A = x.target, R = { x: x.clientX, y: x.clientY }, I = (u == null ? void 0 : u.contains(A)) || (p == null ? void 0 : p.contains(A)), D = !OMe(R, s);
        I ? v() : D && (v(), f());
      };
      return document.addEventListener("pointermove", C), () => document.removeEventListener("pointermove", C);
    }
  }, [u, p, s, f, v]), /* @__PURE__ */ S.jsx(lJ, { ...e, ref: o });
}), [kMe, AMe] = GA(YA, { isInside: !1 }), lJ = k.forwardRef(
  (e, t) => {
    const {
      __scopeTooltip: n,
      children: r,
      "aria-label": i,
      onEscapeKeyDown: o,
      onPointerDownOutside: s,
      ...c
    } = e, u = bx(kb, n), f = KA(n), { onClose: p } = u;
    return k.useEffect(() => (document.addEventListener(ID, p), () => document.removeEventListener(ID, p)), [p]), k.useEffect(() => {
      if (u.trigger) {
        const y = (v) => {
          const w = v.target;
          w != null && w.contains(u.trigger) && p();
        };
        return window.addEventListener("scroll", y, { capture: !0 }), () => window.removeEventListener("scroll", y, { capture: !0 });
      }
    }, [u.trigger, p]), /* @__PURE__ */ S.jsx(
      jA,
      {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: o,
        onPointerDownOutside: s,
        onFocusOutside: (y) => y.preventDefault(),
        onDismiss: p,
        children: /* @__PURE__ */ S.jsxs(
          eJ,
          {
            "data-state": u.stateAttribute,
            ...f,
            ...c,
            ref: t,
            style: {
              ...c.style,
              "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
              "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
              "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [
              /* @__PURE__ */ S.jsx(RQ, { children: r }),
              /* @__PURE__ */ S.jsx(kMe, { scope: n, isInside: !0, children: /* @__PURE__ */ S.jsx(JQ, { id: u.contentId, role: "tooltip", children: i || r }) })
            ]
          }
        )
      }
    );
  }
);
sJ.displayName = kb;
var cJ = "TooltipArrow", uJ = k.forwardRef(
  (e, t) => {
    const { __scopeTooltip: n, ...r } = e, i = KA(n);
    return AMe(
      cJ,
      n
    ).isInside ? null : /* @__PURE__ */ S.jsx(tJ, { ...i, ...r, ref: t });
  }
);
uJ.displayName = cJ;
function TMe(e, t) {
  const n = Math.abs(t.top - e.y), r = Math.abs(t.bottom - e.y), i = Math.abs(t.right - e.x), o = Math.abs(t.left - e.x);
  switch (Math.min(n, r, i, o)) {
    case o:
      return "left";
    case i:
      return "right";
    case n:
      return "top";
    case r:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function _Me(e, t, n = 5) {
  const r = [];
  switch (t) {
    case "top":
      r.push(
        { x: e.x - n, y: e.y + n },
        { x: e.x + n, y: e.y + n }
      );
      break;
    case "bottom":
      r.push(
        { x: e.x - n, y: e.y - n },
        { x: e.x + n, y: e.y - n }
      );
      break;
    case "left":
      r.push(
        { x: e.x + n, y: e.y - n },
        { x: e.x + n, y: e.y + n }
      );
      break;
    case "right":
      r.push(
        { x: e.x - n, y: e.y - n },
        { x: e.x - n, y: e.y + n }
      );
      break;
  }
  return r;
}
function RMe(e) {
  const { top: t, right: n, bottom: r, left: i } = e;
  return [
    { x: i, y: t },
    { x: n, y: t },
    { x: n, y: r },
    { x: i, y: r }
  ];
}
function OMe(e, t) {
  const { x: n, y: r } = e;
  let i = !1;
  for (let o = 0, s = t.length - 1; o < t.length; s = o++) {
    const c = t[o].x, u = t[o].y, f = t[s].x, p = t[s].y;
    u > r != p > r && n < (f - c) * (r - u) / (p - u) + c && (i = !i);
  }
  return i;
}
function IMe(e) {
  const t = e.slice();
  return t.sort((n, r) => n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0), DMe(t);
}
function DMe(e) {
  if (e.length <= 1) return e.slice();
  const t = [];
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    for (; t.length >= 2; ) {
      const o = t[t.length - 1], s = t[t.length - 2];
      if ((o.x - s.x) * (i.y - s.y) >= (o.y - s.y) * (i.x - s.x)) t.pop();
      else break;
    }
    t.push(i);
  }
  t.pop();
  const n = [];
  for (let r = e.length - 1; r >= 0; r--) {
    const i = e[r];
    for (; n.length >= 2; ) {
      const o = n[n.length - 1], s = n[n.length - 2];
      if ((o.x - s.x) * (i.y - s.y) >= (o.y - s.y) * (i.x - s.x)) n.pop();
      else break;
    }
    n.push(i);
  }
  return n.pop(), t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n);
}
var MMe = rJ, PMe = iJ, NMe = oJ, BMe = aJ, LMe = sJ, jMe = uJ, FMe = "_1mg6yyw0 yv8y4re1 yv8y4rcj yv8y4r9j yv8y4rb1 yv8y4rv yv8y4rwx yv8y4rwy", UMe = "_1mg6yyw1 yv8y4r2n";
const kC = ({
  children: e,
  label: t,
  maxWidth: n = 200,
  textAlign: r = "center",
  asChild: i
}) => /* @__PURE__ */ S.jsx(MMe, { children: /* @__PURE__ */ S.jsxs(PMe, { delayDuration: 0, children: [
  /* @__PURE__ */ S.jsx(NMe, { className: UMe, asChild: i, children: e }),
  /* @__PURE__ */ S.jsx(BMe, { children: /* @__PURE__ */ S.jsxs(
    LMe,
    {
      className: FMe,
      style: { maxWidth: n },
      sideOffset: 5,
      "data-rk": FA,
      children: [
        /* @__PURE__ */ S.jsx(Ge, { textAlign: r, variant: { type: "white" }, children: t }),
        /* @__PURE__ */ S.jsx(jMe, {})
      ]
    }
  ) })
] }) }), zMe = () => {
  sa("stakeReview");
  const e = La(), { t } = ln(), n = ss(
    xb(),
    (x) => x.context.selectedAction
  ).unsafeCoerce(), r = k.useMemo(
    () => he.of(n.inputToken),
    [n]
  ), i = ss(
    xb(),
    (x) => x.context.selectedYield
  ).unsafeCoerce(), o = k.useMemo(
    () => he.fromNullable(n).map((x) => x.transactions).map((x) => x.sort((A, R) => A.stepIndex - R.stepIndex)),
    [n]
  ), s = (x) => Ro.ifJust((A) => {
    A.open(x, "_blank");
  }), c = Xh(he.of(i)).mapOrDefault(
    (x) => x.review,
    ""
  ), u = k.useMemo(() => {
    switch (i.metadata.type) {
      case "staking":
      case "liquid-staking":
        return t("position_details.unstake");
      default:
        return t("position_details.withdraw");
    }
  }, [i, t]), f = k.useMemo(
    () => t(
      `position_details.pending_action_button.${n.type.toLowerCase()}`
    ),
    [n.type, t]
  ), p = k.useMemo(
    () => n.type === Tm.STAKE ? c : n.type === Tm.UNSTAKE ? u : f,
    [n, c, u, f]
  ), y = k.useMemo(
    () => he.fromNullable(n.amount).map(Na).extractNullable(),
    [n]
  ), v = k.useMemo(
    () => n.type === Tm.UNSTAKE ? "unstake" : n.type === Tm.STAKE ? "stake" : "pending",
    [n]
  ), w = k.useMemo(
    () => o.chain(
      (x) => Wn.find(
        (A) => A.status === Fj.WAITING_FOR_SIGNATURE,
        x
      ).chain(
        (A) => Wn.findIndex((R) => R === A, x).chainNullable((R) => x[R - 1]).filter((R) => R.status === Fj.CONFIRMED).map(() => "continue")
      )
    ).orDefault("retry"),
    [o]
  ), C = k.useMemo(
    () => he.of(n.createdAt).map(IX).orDefault(!1),
    [n]
  );
  return py(
    k.useMemo(
      () => ({
        label: t(`activity.review.${w}`),
        onClick: () => e(`/activity/${v}/steps`),
        disabled: !1,
        isLoading: !1,
        hide: C
      }),
      [e, v, w, C, t]
    )
  ), {
    selectedYield: i,
    selectedAction: n,
    transactions: o,
    onViewTransactionClick: s,
    title: p,
    amount: y,
    inputToken: r,
    actionOlderThan7Days: C,
    labelKey: w
  };
};
var dJ = "_7p05ef0", fJ = "_7p05ef1", VMe = "_7p05ef2";
const hJ = ({
  title: e,
  token: t,
  metadata: n,
  info: r,
  rewardTokenDetailsProps: i
}) => {
  const { t: o } = ln();
  return /* @__PURE__ */ S.jsxs(ae, { marginBottom: "4", children: [
    /* @__PURE__ */ S.jsx(
      gi.div,
      {
        initial: { opacity: 0, translateY: "-20px" },
        animate: { opacity: 1, translateY: 0 },
        transition: { duration: 1 },
        children: /* @__PURE__ */ S.jsxs(
          ae,
          {
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            marginBottom: "1",
            children: [
              /* @__PURE__ */ S.jsx($u, { variant: { level: "h1" }, children: e }),
              he.fromRecord({ token: t, metadata: n }).map((s) => /* @__PURE__ */ S.jsx(nf, { token: s.token, metadata: s.metadata })).extractNullable()
            ]
          }
        )
      }
    ),
    /* @__PURE__ */ S.jsx(
      gi.div,
      {
        initial: { opacity: 0, translateY: "-20px" },
        animate: { opacity: 1, translateY: 0 },
        transition: { duration: 1, delay: 0.3 },
        children: /* @__PURE__ */ S.jsx(
          $u,
          {
            variant: { level: "h2" },
            overflowWrap: "anywhere",
            className: VMe,
            children: r
          }
        )
      }
    ),
    i == null ? void 0 : i.filter((s) => s.type === "stake").map(() => /* @__PURE__ */ S.jsx(ae, { marginTop: "2", children: /* @__PURE__ */ S.jsx(Ge, { variant: { type: "muted", weight: "normal" }, children: o("review.estimated_reward") }) })).extractNullable()
  ] });
}, $Me = () => {
  const { t: e } = ln(), t = Bi(), {
    selectedYield: n,
    transactions: r,
    title: i,
    amount: o,
    inputToken: s,
    actionOlderThan7Days: c,
    labelKey: u
  } = zMe(), f = k.useMemo(
    () => he.fromNullable(n.token).map((p) => `${o} ${p.symbol}`).extractNullable(),
    [o, n.token]
  );
  return /* @__PURE__ */ S.jsx(yx, { children: /* @__PURE__ */ S.jsxs(fp, { children: [
    /* @__PURE__ */ S.jsx(
      hJ,
      {
        info: f,
        metadata: he.of(n.metadata),
        token: s,
        title: i
      }
    ),
    /* @__PURE__ */ S.jsx(Gl, {}),
    /* @__PURE__ */ S.jsxs(Ge, { marginTop: "4", marginBottom: "2", children: [
      e("activity.review.transactions"),
      ":"
    ] }),
    r.map(
      (p) => p.map((y) => /* @__PURE__ */ S.jsxs(
        ae,
        {
          marginBottom: "2",
          display: "flex",
          justifyContent: "space-between",
          children: [
            /* @__PURE__ */ S.jsx(Ge, { as: "span", color: "textMuted", children: K4(y.type) }),
            /* @__PURE__ */ S.jsxs(
              ae,
              {
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                gap: "1",
                children: [
                  /* @__PURE__ */ S.jsx(Ge, { color: "textMuted", children: he.of(y.status).map((v) => v.replaceAll("_", " ")).map(K4).extract() }),
                  he.fromNullable(y.error).map((v) => /* @__PURE__ */ S.jsx(kC, { maxWidth: 300, label: v, children: /* @__PURE__ */ S.jsx(qm, {}) })).extractNullable()
                ]
              }
            )
          ]
        },
        y.id
      ))
    ).extractNullable(),
    /* @__PURE__ */ S.jsx(Gl, { my: "2" }),
    !c && /* @__PURE__ */ S.jsx(ae, { marginTop: "4", marginBottom: "16", children: /* @__PURE__ */ S.jsx(Ge, { variant: { weight: "normal", type: "muted" }, children: /* @__PURE__ */ S.jsx(
      _a,
      {
        i18nKey: "activity.review.terms_of_use",
        values: { action: e(`activity.review.${u}`) },
        components: {
          underline0: (
            // biome-ignore lint/a11y/useAnchorContent: <explanation>
            /* @__PURE__ */ S.jsx(
              "a",
              {
                target: "_blank",
                onClick: () => t("termsClicked"),
                href: "https://docs.stakek.it/docs/terms-of-use",
                className: fJ,
                rel: "noreferrer"
              }
            )
          )
        }
      }
    ) }) })
  ] }) });
}, HMe = ({
  addressWithTokenDto: e,
  gasEstimate: t,
  tokenGetTokenBalances: n,
  ...r
}) => Ia({
  fn: () => n({ addresses: [e] })
}).mapLeft(() => new qMe()).chain(
  (i) => Ye.liftEither(
    Wn.head(i).map((o) => ({ ...o, amount: new Nt(o.amount ?? 0) })).toEither(new mJ())
  ).chain(async (o) => {
    const s = r.isStake && dA(o.token, r.stakeToken) ? o.amount.minus(r.stakeAmount) : o.amount;
    return t.amount.isGreaterThan(s) ? Rn(new pJ()) : Pt(null);
  })
).chainLeft(async (i) => Pt(i));
class pJ extends Error {
  constructor() {
    super("Not enough gas token");
  }
}
class mJ extends Error {
  constructor() {
    super("Gas token missing from response");
  }
}
class qMe extends Error {
  constructor() {
    super("Get gas token failed");
  }
}
const LN = (e) => {
  const t = fde(), n = k.useMemo(
    () => e.gasAmount.map((r) => ({
      ...e,
      gasAmount: r,
      stakeData: e.isStake ? {
        isStake: e.isStake,
        stakeAmount: e.stakeAmount,
        stakeToken: e.stakeToken
      } : { isStake: e.isStake }
    })),
    [e]
  );
  return Qr({
    queryKey: ["gas-check", n.extract()],
    enabled: n.isJust(),
    staleTime: 0,
    queryFn: async () => (await Ye.liftEither(
      n.toEither(new Error("Request data is missing"))
    ).chain(
      (r) => HMe({
        gasEstimate: {
          amount: r.gasAmount,
          token: r.gasFeeToken
        },
        addressWithTokenDto: {
          address: r.address,
          additionalAddresses: r.additionalAddresses,
          network: r.gasFeeToken.network,
          tokenAddress: r.gasFeeToken.address
        },
        tokenGetTokenBalances: t,
        ...r.stakeData
      })
    ).map(
      (r) => r instanceof pJ || r instanceof mJ
    )).unsafeCoerce()
  });
};
var WMe = "_1w60nqq0";
const jN = (e) => e.map(
  (t, n) => t.isPoints ? /* @__PURE__ */ S.jsxs(ae, { as: "span", display: "inline-block", children: [
    /* @__PURE__ */ S.jsx(
      ae,
      {
        display: "inline-block",
        className: WMe,
        as: "img",
        src: t.logoURI,
        hw: "5",
        marginRight: "1"
      }
    ),
    az({
      arrLength: e.length,
      i: n,
      str: t.name.replace(/points/i, "").trim()
    })
  ] }, as(t)) : /* @__PURE__ */ S.jsx($.Fragment, { children: az({
    arrLength: e.length,
    i: n,
    str: t.symbol
  }) }, as(t))
), az = ({
  arrLength: e,
  i: t,
  str: n
}) => t !== e - 1 ? /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
  n,
  ","
] }) : n, FN = ({
  amount: e,
  feeConfigDto: t,
  prices: n,
  token: r
}) => {
  const { t: i } = ln(), o = k.useCallback(
    (p) => n4e({
      amount: _n(Sue(Nt(p), e)),
      prices: n,
      token: r
    }),
    [e, r, n]
  ), s = k.useCallback(
    (p) => `${kue(p)}%`,
    []
  ), c = k.useMemo(
    () => t.chainNullable((p) => p.depositFeeBps).map((p) => ({
      inUSD: o(p),
      inPercentage: s(p),
      explanation: i("review.deposit_fee_explanation"),
      label: i("review.deposit_fee")
    })),
    [t, o, s, i]
  ), u = k.useMemo(
    () => t.chainNullable((p) => p.managementFeeBps).map((p) => ({
      inUSD: o(p),
      inPercentage: s(p),
      explanation: i("review.management_fee_explanation"),
      label: i("review.management_fee")
    })),
    [t, o, s, i]
  ), f = k.useMemo(
    () => t.chainNullable((p) => p.performanceFeeBps).map((p) => ({
      inUSD: o(p),
      inPercentage: s(p),
      explanation: i("review.performance_fee_explanation"),
      label: i("review.performance_fee")
    })),
    [t, o, s, i]
  );
  return { depositFee: c, managementFee: u, performanceFee: f };
}, GMe = () => {
  var z;
  const e = vx(), t = ss(
    e,
    (H) => H.context.data
  ).unsafeCoerce(), n = t.requestDto.integrationId, r = ede(
    t.requestDto,
    { query: { staleTime: 0, gcTime: 0 } }
  ), i = cM(n), o = k.useMemo(
    () => {
      var H;
      return he.fromNullable((H = r.data) == null ? void 0 : H.amount).map(Nt);
    },
    [r.data]
  ), s = k.useMemo(
    () => {
      var H;
      return new Nt(((H = t.requestDto.args) == null ? void 0 : H.amount) ?? 0);
    },
    [(z = t.requestDto.args) == null ? void 0 : z.amount]
  ), c = k.useMemo(
    () => he.of(t.interactedToken),
    [t.interactedToken]
  ), u = k.useMemo(
    () => he.of(t.integrationData),
    [t.integrationData]
  ), f = fA({
    token: c,
    yieldDto: u
  }), { depositFee: p, managementFee: y, performanceFee: v } = FN({
    amount: s,
    token: c,
    feeConfigDto: k.useMemo(
      () => he.fromNullable(i.data),
      [i.data]
    ),
    prices: k.useMemo(
      () => he.fromNullable(f.data),
      [f.data]
    )
  }), w = LN({
    gasAmount: o,
    gasFeeToken: t.gasFeeToken,
    address: t.addresses.address,
    additionalAddresses: t.addresses.additionalAddresses,
    isStake: !1
  }), { t: C } = ln(), x = k.useMemo(
    () => he.of(
      C(
        `position_details.pending_action_button.${t.requestDto.type.toLowerCase()}`
      )
    ),
    [t.requestDto.type, C]
  ), A = La(), R = k.useMemo(
    () => kP({
      gas: o,
      prices: he.fromNullable(f.data),
      yieldDto: u
    }),
    [u, o, f.data]
  ), I = Uue(), D = ec({
    mutationFn: async () => (await Ia({
      fn: () => I(t.requestDto)
    }).mapLeft(() => new Error("Pending actions error")).chain(
      (H) => Ye.liftEither(vP(H))
    )).unsafeCoerce(),
    onSuccess: (H) => {
      e.send({ type: "setActionDto", data: H }), A("../steps", { relative: "path" });
    }
  }), M = () => D.mutate(), L = k.useMemo(
    () => u.chainNullable(
      (H) => H.metadata.provider ? { provider: H.metadata.provider, rest: H } : null
    ).map((H) => {
      const Q = he.of({
        logoUri: H.provider.logoURI,
        providerName: H.provider.name,
        symbols: jN([H.rest.token]),
        rewardTokens: [H.rest.token]
      });
      return {
        type: "pendingAction",
        pendingAction: t.requestDto.type,
        rewardToken: Q
      };
    }),
    [u, t.requestDto.type]
  ), j = Pr(M);
  py(
    k.useMemo(
      () => ({
        label: C("shared.confirm"),
        onClick: () => j.current(),
        disabled: !1,
        isLoading: D.isPending
      }),
      [j, C, D.isPending]
    )
  );
  const F = k.useMemo(() => ({ showMetaInfo: !1 }), []), O = k.useMemo(() => To(s), [s]);
  return {
    integrationData: u,
    title: x,
    amount: O,
    fee: R,
    rewardTokenDetailsProps: L,
    token: c,
    metaInfo: F,
    isGasCheckWarning: !!w.data,
    gasCheckLoading: r.isLoading || w.isLoading,
    depositFee: p,
    managementFee: y,
    performanceFee: v,
    feeConfigLoading: i.isPending
  };
}, KMe = () => /* @__PURE__ */ S.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: 17, height: 17, fill: "none", children: [
  /* @__PURE__ */ S.jsx(
    "path",
    {
      stroke: "#FFC21B",
      strokeWidth: 1.5,
      d: "M7.574 2.021a1.25 1.25 0 0 1 2.165 0l5.9 10.219a1.25 1.25 0 0 1-1.083 1.875h-11.8a1.25 1.25 0 0 1-1.082-1.875l5.9-10.219Z"
    }
  ),
  /* @__PURE__ */ S.jsx(
    "path",
    {
      stroke: "#FFC21B",
      strokeLinecap: "round",
      strokeWidth: 1.5,
      d: "M8.656 5.154v3.708"
    }
  ),
  /* @__PURE__ */ S.jsx("circle", { cx: 8.656, cy: 11.325, r: 0.924, fill: "#FFC21B" })
] }), YMe = ({ text: e }) => /* @__PURE__ */ S.jsxs(
  ae,
  {
    borderRadius: "md",
    px: "2",
    py: "1",
    display: "inline-flex",
    justifyContent: "center",
    alignItems: "center",
    gap: "3",
    background: "warningBoxBackground",
    children: [
      /* @__PURE__ */ S.jsx(ae, { display: "flex", justifyContent: "center", alignItems: "center", children: /* @__PURE__ */ S.jsx(KMe, {}) }),
      /* @__PURE__ */ S.jsx(ae, { children: /* @__PURE__ */ S.jsx(Ge, { lineHeight: "short", children: e }) })
    ]
  }
), yJ = ({
  selectedStake: e,
  validators: t,
  tokenDto: n
}) => {
  const { t: r } = ln(), i = k.useMemo(
    () => Wn.find((o) => !!(o.name ?? o.address), t).alt(Wn.head(t)).map(
      (o) => r("details.selected_validators", {
        providerName: o.name ?? o.address,
        count: t.length - 1
      })
    ),
    [t, r]
  );
  return k.useMemo(() => he.fromRecord({ selectedStake: e, tokenDto: n }).mapOrDefault(({ selectedStake: o, tokenDto: s }) => {
    var R, I, D, M, L;
    const c = i.extract(), u = s.symbol, f = ((R = o.metadata.rewardTokens) == null ? void 0 : R.filter((j) => !j.isPoints).map((j) => j.symbol).join(", ")) ?? "", p = c ?? (o.metadata.provider ? o.metadata.provider.name : o.metadata.name), y = o.metadata.rewardSchedule, v = ((I = o.metadata.cooldownPeriod) == null ? void 0 : I.days) ?? 0, w = ((D = o.metadata.warmupPeriod) == null ? void 0 : D.days) ?? 0, C = o.metadata.rewardClaiming, x = p.includes("Compound"), A = {
      extra: o.rewardType === "variable" ? r("details.reward_type_varialbe", {
        symbol: sX(o.token.symbol)
      }) : o.metadata.token.network === yi.Tezos ? r("details.extra_tezos") : void 0
    };
    switch (o.metadata.type) {
      case "staking":
        return {
          description: null,
          earnPeriod: w > 0 ? r("details.native_staking.earn_after_warmup", {
            count: w
          }) : null,
          earnRewards: C === "manual" ? r("details.native_staking.earn_rewards_manual", {
            rewardSchedule: y
          }) : r("details.native_staking.earn_rewards_auto", {
            rewardSchedule: y
          }),
          withdrawnTime: v > 0 ? r("details.native_staking.unstake_time_days", {
            cooldownPeriodDays: v
          }) : r("details.native_staking.unstake_time_immediately"),
          withdrawnNotAvailable: null,
          ...A
        };
      case "lending":
        return {
          earnPeriod: w > 0 ? r("details.lend.earn_after_warmup", {
            count: w
          }) : null,
          earnRewards: C === "manual" ? r("details.lend.earn_interest_manual", { rewardSchedule: y }) : r("details.lend.earn_interest_auto", { rewardSchedule: y }),
          withdrawnTime: v > 0 ? r("details.lend.withdrawn_time_days", {
            cooldownPeriodDays: v
          }) : r("details.lend.withdrawn_time_immediately"),
          description: x ? r("details.lend.description_compound", {
            stakeToken: u,
            rewardTokens: f
          }) : r("details.lend.description", {
            stakeToken: u,
            rewardTokens: f,
            providerName: p
          }),
          withdrawnNotAvailable: null,
          ...A
        };
      case "vault":
        return {
          description: r("details.vault.description", {
            stakeToken: u,
            depositToken: f
          }),
          earnPeriod: w > 0 ? r("details.vault.earn_after_warmup", {
            count: w
          }) : null,
          earnRewards: C === "manual" ? r("details.vault.earn_yield_manual", { rewardSchedule: y }) : r("details.vault.earn_yield_auto", { rewardSchedule: y }),
          withdrawnTime: v > 0 ? r("details.vault.withdrawn_time_days", { cooldownPeriodDays: v }) : r("details.vault.withdrawn_time_immediately"),
          withdrawnNotAvailable: null,
          ...A
        };
      case "liquid-staking":
        return {
          description: r("details.liquid_stake.description", {
            stakeToken: u,
            rewardTokens: f
          }),
          earnPeriod: w > 0 ? r("details.liquid_stake.earn_after_warmup", {
            count: w
          }) : null,
          earnRewards: C === "manual" ? r("details.liquid_stake.earn_rewards_manual", {
            rewardSchedule: y
          }) : r("details.liquid_stake.earn_rewards_auto", {
            rewardSchedule: y
          }),
          withdrawnTime: o.status.exit ? v > 0 ? r("details.liquid_stake.unstake_time_days", {
            cooldownPeriodDays: v,
            claimDays: ((M = o.metadata.withdrawPeriod) == null ? void 0 : M.days) ?? 0,
            context: (((L = o.metadata.withdrawPeriod) == null ? void 0 : L.days) ?? 0) > 0 ? "with_claim_days" : void 0
          }) : r("details.liquid_stake.unstake_time_immediately") : null,
          withdrawnNotAvailable: o.status.exit ? null : r("details.liquid_stake.withdrawn_not_available", {
            rewardTokens: f
          }),
          ...A
        };
      case "restaking":
        return {
          description: r("details.restake.description", {
            stakeToken: u,
            rewardTokens: f
          }),
          earnPeriod: w > 0 ? r("details.restake.earn_after_warmup", {
            count: w
          }) : null,
          earnRewards: C === "manual" ? r("details.restake.earn_rewards_manual", {
            rewardSchedule: y
          }) : r("details.restake.earn_rewards_auto", {
            rewardSchedule: y
          }),
          withdrawnTime: o.status.exit ? v > 0 ? r("details.restake.unstake_time_days", {
            cooldownPeriodDays: v
          }) : r("details.restake.unstake_time_immediately") : null,
          withdrawnNotAvailable: o.status.exit ? null : r("details.restake.withdrawn_not_available", {
            rewardTokens: f
          }),
          ...A
        };
      default:
        return sz;
    }
  }, sz), [e, r, n, i]);
}, sz = {
  description: null,
  earnPeriod: null,
  earnRewards: null,
  withdrawnTime: null,
  withdrawnNotAvailable: null
};
var QMe = "_56h8890", XMe = "_56h8891";
const vJ = ({
  isLoading: e,
  selectedStake: t,
  selectedToken: n,
  selectedValidators: r
}) => {
  const {
    description: i,
    earnPeriod: o,
    earnRewards: s,
    withdrawnNotAvailable: c,
    withdrawnTime: u,
    extra: f
  } = yJ({
    selectedStake: t,
    validators: [...r.values()],
    tokenDto: n
  }), p = k.useMemo(
    () => [
      { text: i, icon: /* @__PURE__ */ S.jsx(JRe, {}) },
      { text: o, icon: /* @__PURE__ */ S.jsx(eOe, {}) },
      { text: s, icon: /* @__PURE__ */ S.jsx(tOe, {}) },
      { text: c, icon: /* @__PURE__ */ S.jsx(qm, {}) },
      { text: u, icon: /* @__PURE__ */ S.jsx(qm, {}) },
      { text: f, icon: /* @__PURE__ */ S.jsx(qm, {}) }
    ].filter((y) => !!y.text),
    [
      i,
      o,
      s,
      c,
      u,
      f
    ]
  );
  return e ? /* @__PURE__ */ S.jsx(hf, { heightPx: 150 }) : /* @__PURE__ */ S.jsx(ae, { as: "footer", gap: "3", display: "flex", flexDirection: "column", children: p.map((y) => /* @__PURE__ */ S.jsxs(ae, { display: "flex", alignItems: "center", gap: "4", children: [
    /* @__PURE__ */ S.jsx(ae, { alignItems: "center", justifyContent: "center", display: "flex", children: y.icon ? y.icon : /* @__PURE__ */ S.jsx(ae, { className: QMe, children: /* @__PURE__ */ S.jsx(
      Ge,
      {
        className: XMe,
        variant: { weight: "normal", type: "muted" },
        children: ""
      }
    ) }) }),
    /* @__PURE__ */ S.jsx(ae, { children: /* @__PURE__ */ S.jsx(Ge, { variant: { weight: "normal", type: "muted" }, children: y.text }) })
  ] }, y.text)) });
}, UN = ({
  fee: e,
  title: t,
  token: n,
  metadata: r,
  info: i,
  rewardTokenDetailsProps: o,
  isGasCheckError: s,
  loading: c = !1,
  depositFee: u,
  managementFee: f,
  performanceFee: p,
  feeConfigLoading: y = !1,
  ...v
}) => {
  sa("stakeReview");
  const w = Bi(), { t: C } = ln(), x = c || y;
  return /* @__PURE__ */ S.jsx(yx, { children: /* @__PURE__ */ S.jsxs(fp, { children: [
    /* @__PURE__ */ S.jsx(
      hJ,
      {
        info: i,
        metadata: r,
        rewardTokenDetailsProps: o,
        title: t,
        token: n
      }
    ),
    /* @__PURE__ */ S.jsx(Gl, {}),
    /* @__PURE__ */ S.jsx(
      ae,
      {
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        marginTop: "4",
        children: /* @__PURE__ */ S.jsx(Ge, { variant: { weight: "semibold" }, children: C("shared.fees") })
      }
    ),
    /* @__PURE__ */ S.jsx(
      JMe,
      {
        label: C("review.estimated_gas_fee"),
        price: e,
        loading: x
      }
    ),
    !x && /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
      u.map((A) => /* @__PURE__ */ S.jsx(sI, { feesBps: A })).extractNullable(),
      f.map((A) => /* @__PURE__ */ S.jsx(sI, { feesBps: A })).extractNullable(),
      p.map((A) => /* @__PURE__ */ S.jsx(sI, { feesBps: A })).extractNullable()
    ] }),
    s && /* @__PURE__ */ S.jsx(ae, { marginBottom: "2", children: /* @__PURE__ */ S.jsx(YMe, { text: "This action is unlikely to succeed due to insufficient funds to cover gas fees" }) }),
    /* @__PURE__ */ S.jsx(Gl, {}),
    v.showMetaInfo && /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
      /* @__PURE__ */ S.jsxs(ae, { marginBottom: "4", children: [
        /* @__PURE__ */ S.jsx(ae, { my: "4", children: /* @__PURE__ */ S.jsx(Ge, { variant: { weight: "semibold" }, children: C("review.additional_info") }) }),
        /* @__PURE__ */ S.jsx(vJ, { ...v.metaInfoProps })
      ] }),
      /* @__PURE__ */ S.jsx(Gl, {})
    ] }),
    /* @__PURE__ */ S.jsx(ae, { marginTop: "4", marginBottom: v.showMetaInfo ? "4" : "16", children: /* @__PURE__ */ S.jsx(Ge, { variant: { weight: "normal", type: "muted" }, children: /* @__PURE__ */ S.jsx(
      _a,
      {
        i18nKey: "review.terms_of_use",
        components: {
          underline0: (
            // biome-ignore lint/a11y/useAnchorContent: <explanation>
            /* @__PURE__ */ S.jsx(
              "a",
              {
                target: "_blank",
                onClick: () => w("termsClicked"),
                href: "https://docs.stakek.it/docs/terms-of-use",
                className: fJ,
                rel: "noreferrer"
              }
            )
          )
        }
      }
    ) }) })
  ] }) });
}, JMe = ({
  label: e,
  price: t,
  loading: n
}) => /* @__PURE__ */ S.jsxs(
  ae,
  {
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    marginTop: "2",
    marginBottom: "2",
    "data-testid": "estimated_gas_fee",
    height: "4",
    children: [
      /* @__PURE__ */ S.jsx(Ge, { variant: { weight: "normal", type: "muted" }, children: e }),
      n ? /* @__PURE__ */ S.jsx(ae, { width: "40", children: /* @__PURE__ */ S.jsx(hf, { heightPx: 16, variant: { size: "medium" } }) }) : /* @__PURE__ */ S.jsx(
        Ge,
        {
          className: dJ,
          variant: { type: "muted", weight: "normal" },
          children: t
        }
      )
    ]
  }
), sI = ({ feesBps: e }) => /* @__PURE__ */ S.jsxs(
  ae,
  {
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    "data-testid": "estimated_gas_fee",
    marginBottom: "2",
    children: [
      /* @__PURE__ */ S.jsxs(ae, { display: "flex", alignItems: "center", justifyContent: "center", gap: "1", children: [
        /* @__PURE__ */ S.jsx(Ge, { variant: { weight: "normal", type: "muted" }, children: e.label }),
        /* @__PURE__ */ S.jsx(kC, { label: e.explanation, children: /* @__PURE__ */ S.jsx(ae, { display: "flex", children: /* @__PURE__ */ S.jsx(qm, {}) }) })
      ] }),
      /* @__PURE__ */ S.jsx(kC, { label: e.inUSD, children: /* @__PURE__ */ S.jsx(
        Ge,
        {
          className: dJ,
          variant: { weight: "normal", type: "muted" },
          children: e.inPercentage
        }
      ) })
    ]
  }
), ZMe = () => {
  const {
    amount: e,
    fee: t,
    integrationData: n,
    rewardTokenDetailsProps: r,
    title: i,
    token: o,
    metaInfo: s,
    gasCheckLoading: c,
    isGasCheckWarning: u,
    depositFee: f,
    managementFee: p,
    performanceFee: y,
    feeConfigLoading: v
  } = GMe();
  sa("pendingActionReview");
  const w = k.useMemo(
    () => o.map((C) => `${e} ${C.symbol}`).extractNullable(),
    [e, o]
  );
  return /* @__PURE__ */ S.jsx(
    UN,
    {
      rewardTokenDetailsProps: r,
      title: i.orDefault(""),
      fee: t,
      depositFee: f,
      managementFee: p,
      performanceFee: y,
      feeConfigLoading: v,
      info: w,
      metadata: n.map((C) => C.metadata),
      token: o,
      isGasCheckError: u,
      loading: c,
      ...s
    }
  );
};
var lz = "_4g9e6t0", ePe = "_4g9e6t2 _4g9e6t1 yv8y4ru yv8y4rwp yv8y4rwq", tPe = "_4g9e6t3", nPe = "_4g9e6t4", rPe = "_4g9e6t5", iPe = "_4g9e6t6", oPe = "_4g9e6t7", aPe = "_4g9e6t8";
const sPe = ({
  onCancel: e,
  onClick: t,
  isOpen: n
}) => {
  const { t: r } = ln();
  return /* @__PURE__ */ S.jsx(dp, { state: { isOpen: n, setOpen: e }, onClose: e, children: /* @__PURE__ */ S.jsxs(
    ae,
    {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center",
      paddingBottom: { mobile: "8" },
      className: oPe,
      children: [
        /* @__PURE__ */ S.jsx(
          ae,
          {
            as: "img",
            src: Fs.poweredBy,
            className: iPe
          }
        ),
        /* @__PURE__ */ S.jsx($u, { variant: { level: "h4" }, children: r("position_details.unstake_sign.title") }),
        /* @__PURE__ */ S.jsx(ae, { marginTop: "2", lineHeight: "short", children: /* @__PURE__ */ S.jsx(
          Ge,
          {
            variant: { type: "muted", weight: "normal" },
            textAlign: "center",
            children: r("position_details.unstake_sign.description")
          }
        ) }),
        /* @__PURE__ */ S.jsx(ae, { marginTop: "8", width: "full", children: /* @__PURE__ */ S.jsx(Jl, { onClick: t, children: /* @__PURE__ */ S.jsx(Ge, { variant: { type: "inverted", weight: "bold", size: "large" }, children: r("shared.continue") }) }) })
      ]
    }
  ) });
};
var lPe = k.useLayoutEffect;
function cPe() {
  if (typeof globalThis < "u")
    return globalThis;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof WI < "u")
    return WI;
}
function uPe() {
  const e = cPe();
  if (e.__xstate__)
    return e.__xstate__;
}
const dPe = (e) => {
  if (typeof window > "u")
    return;
  const t = uPe();
  t && t.register(e);
};
class cz {
  constructor(t) {
    this._process = t, this._active = !1, this._current = null, this._last = null;
  }
  start() {
    this._active = !0, this.flush();
  }
  clear() {
    this._current && (this._current.next = null, this._last = this._current);
  }
  enqueue(t) {
    const n = {
      value: t,
      next: null
    };
    if (this._current) {
      this._last.next = n, this._last = n;
      return;
    }
    this._current = n, this._last = n, this._active && this.flush();
  }
  flush() {
    for (; this._current; ) {
      const t = this._current;
      this._process(t.value), this._current = t.next;
    }
    this._last = null;
  }
}
const gJ = ".", fPe = "", bJ = "", hPe = "#", pPe = "*", wJ = "xstate.init", MD = "xstate.stop";
function mPe(e, t) {
  return {
    type: `xstate.after.${e}.${t}`
  };
}
function PD(e, t) {
  return {
    type: `xstate.done.state.${e}`,
    output: t
  };
}
function yPe(e, t) {
  return {
    type: `xstate.done.actor.${e}`,
    output: t,
    actorId: e
  };
}
function vPe(e, t) {
  return {
    type: `xstate.error.actor.${e}`,
    error: t,
    actorId: e
  };
}
function CJ(e) {
  return {
    type: wJ,
    input: e
  };
}
function Bd(e) {
  setTimeout(() => {
    throw e;
  });
}
const gPe = typeof Symbol == "function" && Symbol.observable || "@@observable";
function xJ(e, t) {
  const n = uz(e), r = uz(t);
  return typeof r == "string" ? typeof n == "string" ? r === n : !1 : typeof n == "string" ? n in r : Object.keys(n).every((i) => i in r ? xJ(n[i], r[i]) : !1);
}
function zN(e) {
  if (SJ(e))
    return e;
  let t = [], n = "";
  for (let r = 0; r < e.length; r++) {
    switch (e.charCodeAt(r)) {
      case 92:
        n += e[r + 1], r++;
        continue;
      case 46:
        t.push(n), n = "";
        continue;
    }
    n += e[r];
  }
  return t.push(n), t;
}
function uz(e) {
  if (XPe(e))
    return e.value;
  if (typeof e != "string")
    return e;
  const t = zN(e);
  return bPe(t);
}
function bPe(e) {
  if (e.length === 1)
    return e[0];
  const t = {};
  let n = t;
  for (let r = 0; r < e.length - 1; r++)
    if (r === e.length - 2)
      n[e[r]] = e[r + 1];
    else {
      const i = n;
      n = {}, i[e[r]] = n;
    }
  return t;
}
function dz(e, t) {
  const n = {}, r = Object.keys(e);
  for (let i = 0; i < r.length; i++) {
    const o = r[i];
    n[o] = t(e[o], o, e, i);
  }
  return n;
}
function EJ(e) {
  return SJ(e) ? e : [e];
}
function zh(e) {
  return e === void 0 ? [] : EJ(e);
}
function ND(e, t, n, r) {
  return typeof e == "function" ? e({
    context: t,
    event: n,
    self: r
  }) : e;
}
function SJ(e) {
  return Array.isArray(e);
}
function wPe(e) {
  return e.type.startsWith("xstate.error.actor");
}
function yg(e) {
  return EJ(e).map((t) => typeof t > "u" || typeof t == "string" ? {
    target: t
  } : t);
}
function kJ(e) {
  if (!(e === void 0 || e === fPe))
    return zh(e);
}
function BD(e, t, n) {
  var o, s, c;
  const r = typeof e == "object", i = r ? e : void 0;
  return {
    next: (o = r ? e.next : e) == null ? void 0 : o.bind(i),
    error: (s = r ? e.error : t) == null ? void 0 : s.bind(i),
    complete: (c = r ? e.complete : n) == null ? void 0 : c.bind(i)
  };
}
function fz(e, t) {
  return `${t}.${e}`;
}
function VN(e, t) {
  const n = t.match(/^xstate\.invoke\.(\d+)\.(.*)/);
  if (!n)
    return e.implementations.actors[t];
  const [, r, i] = n, s = e.getStateNodeById(i).config.invoke;
  return (Array.isArray(s) ? s[r] : s).src;
}
function hz(e, t) {
  return `${e.sessionId}.${t}`;
}
let CPe = 0;
function xPe(e, t) {
  const n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new WeakMap(), o = /* @__PURE__ */ new Set(), s = {}, {
    clock: c,
    logger: u
  } = t, f = {
    schedule: (v, w, C, x, A = Math.random().toString(36).slice(2)) => {
      const R = {
        source: v,
        target: w,
        event: C,
        delay: x,
        id: A,
        startedAt: Date.now()
      }, I = hz(v, A);
      y._snapshot._scheduledEvents[I] = R;
      const D = c.setTimeout(() => {
        delete s[I], delete y._snapshot._scheduledEvents[I], y._relay(v, w, C);
      }, x);
      s[I] = D;
    },
    cancel: (v, w) => {
      const C = hz(v, w), x = s[C];
      delete s[C], delete y._snapshot._scheduledEvents[C], x !== void 0 && c.clearTimeout(x);
    },
    cancelAll: (v) => {
      for (const w in y._snapshot._scheduledEvents) {
        const C = y._snapshot._scheduledEvents[w];
        C.source === v && f.cancel(v, C.id);
      }
    }
  }, p = (v) => {
    if (!o.size)
      return;
    const w = {
      ...v,
      rootId: e.sessionId
    };
    o.forEach((C) => {
      var x;
      return (x = C.next) == null ? void 0 : x.call(C, w);
    });
  }, y = {
    _snapshot: {
      _scheduledEvents: ((t == null ? void 0 : t.snapshot) && t.snapshot.scheduler) ?? {}
    },
    _bookId: () => `x:${CPe++}`,
    _register: (v, w) => (n.set(v, w), v),
    _unregister: (v) => {
      n.delete(v.sessionId);
      const w = i.get(v);
      w !== void 0 && (r.delete(w), i.delete(v));
    },
    get: (v) => r.get(v),
    _set: (v, w) => {
      const C = r.get(v);
      if (C && C !== w)
        throw new Error(`Actor with system ID '${v}' already exists.`);
      r.set(v, w), i.set(w, v);
    },
    inspect: (v) => {
      const w = BD(v);
      return o.add(w), {
        unsubscribe() {
          o.delete(w);
        }
      };
    },
    _sendInspectionEvent: p,
    _relay: (v, w, C) => {
      y._sendInspectionEvent({
        type: "@xstate.event",
        sourceRef: v,
        actorRef: w,
        event: C
      }), w._send(C);
    },
    scheduler: f,
    getSnapshot: () => ({
      _scheduledEvents: {
        ...y._snapshot._scheduledEvents
      }
    }),
    start: () => {
      const v = y._snapshot._scheduledEvents;
      y._snapshot._scheduledEvents = {};
      for (const w in v) {
        const {
          source: C,
          target: x,
          event: A,
          delay: R,
          id: I
        } = v[w];
        f.schedule(C, x, A, R, I);
      }
    },
    _clock: c,
    _logger: u
  };
  return y;
}
const $N = 1;
let ts = /* @__PURE__ */ function(e) {
  return e[e.NotStarted = 0] = "NotStarted", e[e.Running = 1] = "Running", e[e.Stopped = 2] = "Stopped", e;
}({});
const EPe = {
  clock: {
    setTimeout: (e, t) => setTimeout(e, t),
    clearTimeout: (e) => clearTimeout(e)
  },
  logger: void 0,
  devTools: !1
};
class SPe {
  /**
   * Creates a new actor instance for the given logic with the provided options,
   * if any.
   *
   * @param logic The logic to create an actor from
   * @param options Actor options
   */
  constructor(t, n) {
    this.logic = t, this._snapshot = void 0, this.clock = void 0, this.options = void 0, this.id = void 0, this.mailbox = new cz(this._process.bind(this)), this.observers = /* @__PURE__ */ new Set(), this.eventListeners = /* @__PURE__ */ new Map(), this.logger = void 0, this._processingStatus = ts.NotStarted, this._parent = void 0, this._syncSnapshot = void 0, this.ref = void 0, this._actorScope = void 0, this._systemId = void 0, this.sessionId = void 0, this.system = void 0, this._doneEvent = void 0, this.src = void 0, this._deferred = [];
    const r = {
      ...EPe,
      ...n
    }, {
      clock: i,
      logger: o,
      parent: s,
      syncSnapshot: c,
      id: u,
      systemId: f,
      inspect: p
    } = r;
    this.system = s ? s.system : xPe(this, {
      clock: i,
      logger: o
    }), p && !s && this.system.inspect(BD(p)), this.sessionId = this.system._bookId(), this.id = u ?? this.sessionId, this.logger = (n == null ? void 0 : n.logger) ?? this.system._logger, this.clock = (n == null ? void 0 : n.clock) ?? this.system._clock, this._parent = s, this._syncSnapshot = c, this.options = r, this.src = r.src ?? t, this.ref = this, this._actorScope = {
      self: this,
      id: this.id,
      sessionId: this.sessionId,
      logger: this.logger,
      defer: (y) => {
        this._deferred.push(y);
      },
      system: this.system,
      stopChild: (y) => {
        if (y._parent !== this)
          throw new Error(`Cannot stop child actor ${y.id} of ${this.id} because it is not a child`);
        y._stop();
      },
      emit: (y) => {
        const v = this.eventListeners.get(y.type), w = this.eventListeners.get("*");
        if (!v && !w)
          return;
        const C = /* @__PURE__ */ new Set([...v ? v.values() : [], ...w ? w.values() : []]);
        for (const x of Array.from(C))
          x(y);
      }
    }, this.send = this.send.bind(this), this.system._sendInspectionEvent({
      type: "@xstate.actor",
      actorRef: this
    }), f && (this._systemId = f, this.system._set(f, this)), this._initState((n == null ? void 0 : n.snapshot) ?? (n == null ? void 0 : n.state)), f && this._snapshot.status !== "active" && this.system._unregister(this);
  }
  _initState(t) {
    var n;
    try {
      this._snapshot = t ? this.logic.restoreSnapshot ? this.logic.restoreSnapshot(t, this._actorScope) : t : this.logic.getInitialSnapshot(this._actorScope, (n = this.options) == null ? void 0 : n.input);
    } catch (r) {
      this._snapshot = {
        status: "error",
        output: void 0,
        error: r
      };
    }
  }
  update(t, n) {
    var i, o;
    this._snapshot = t;
    let r;
    for (; r = this._deferred.shift(); )
      try {
        r();
      } catch (s) {
        this._deferred.length = 0, this._snapshot = {
          ...t,
          status: "error",
          error: s
        };
      }
    switch (this._snapshot.status) {
      case "active":
        for (const s of this.observers)
          try {
            (i = s.next) == null || i.call(s, t);
          } catch (c) {
            Bd(c);
          }
        break;
      case "done":
        for (const s of this.observers)
          try {
            (o = s.next) == null || o.call(s, t);
          } catch (c) {
            Bd(c);
          }
        this._stopProcedure(), this._complete(), this._doneEvent = yPe(this.id, this._snapshot.output), this._parent && this.system._relay(this, this._parent, this._doneEvent);
        break;
      case "error":
        this._error(this._snapshot.error);
        break;
    }
    this.system._sendInspectionEvent({
      type: "@xstate.snapshot",
      actorRef: this,
      event: n,
      snapshot: t
    });
  }
  /**
   * Subscribe an observer to an actors snapshot values.
   *
   * @remarks
   * The observer will receive the actors snapshot value when it is emitted.
   * The observer can be:
   *
   * - A plain function that receives the latest snapshot, or
   * - An observer object whose `.next(snapshot)` method receives the latest
   *   snapshot
   *
   * @example
   *
   * ```ts
   * // Observer as a plain function
   * const subscription = actor.subscribe((snapshot) => {
   *   console.log(snapshot);
   * });
   * ```
   *
   * @example
   *
   * ```ts
   * // Observer as an object
   * const subscription = actor.subscribe({
   *   next(snapshot) {
   *     console.log(snapshot);
   *   },
   *   error(err) {
   *     // ...
   *   },
   *   complete() {
   *     // ...
   *   }
   * });
   * ```
   *
   * The return value of `actor.subscribe(observer)` is a subscription object
   * that has an `.unsubscribe()` method. You can call
   * `subscription.unsubscribe()` to unsubscribe the observer:
   *
   * @example
   *
   * ```ts
   * const subscription = actor.subscribe((snapshot) => {
   *   // ...
   * });
   *
   * // Unsubscribe the observer
   * subscription.unsubscribe();
   * ```
   *
   * When the actor is stopped, all of its observers will automatically be
   * unsubscribed.
   *
   * @param observer - Either a plain function that receives the latest
   *   snapshot, or an observer object whose `.next(snapshot)` method receives
   *   the latest snapshot
   */
  subscribe(t, n, r) {
    var o;
    const i = BD(t, n, r);
    if (this._processingStatus !== ts.Stopped)
      this.observers.add(i);
    else
      switch (this._snapshot.status) {
        case "done":
          try {
            (o = i.complete) == null || o.call(i);
          } catch (s) {
            Bd(s);
          }
          break;
        case "error": {
          const s = this._snapshot.error;
          if (!i.error)
            Bd(s);
          else
            try {
              i.error(s);
            } catch (c) {
              Bd(c);
            }
          break;
        }
      }
    return {
      unsubscribe: () => {
        this.observers.delete(i);
      }
    };
  }
  on(t, n) {
    let r = this.eventListeners.get(t);
    r || (r = /* @__PURE__ */ new Set(), this.eventListeners.set(t, r));
    const i = n.bind(void 0);
    return r.add(i), {
      unsubscribe: () => {
        r.delete(i);
      }
    };
  }
  /** Starts the Actor from the initial state */
  start() {
    if (this._processingStatus === ts.Running)
      return this;
    this._syncSnapshot && this.subscribe({
      next: (r) => {
        r.status === "active" && this.system._relay(this, this._parent, {
          type: `xstate.snapshot.${this.id}`,
          snapshot: r
        });
      },
      error: () => {
      }
    }), this.system._register(this.sessionId, this), this._systemId && this.system._set(this._systemId, this), this._processingStatus = ts.Running;
    const t = CJ(this.options.input);
    switch (this.system._sendInspectionEvent({
      type: "@xstate.event",
      sourceRef: this._parent,
      actorRef: this,
      event: t
    }), this._snapshot.status) {
      case "done":
        return this.update(this._snapshot, t), this;
      case "error":
        return this._error(this._snapshot.error), this;
    }
    if (this._parent || this.system.start(), this.logic.start)
      try {
        this.logic.start(this._snapshot, this._actorScope);
      } catch (r) {
        return this._snapshot = {
          ...this._snapshot,
          status: "error",
          error: r
        }, this._error(r), this;
      }
    return this.update(this._snapshot, t), this.options.devTools && this.attachDevTools(), this.mailbox.start(), this;
  }
  _process(t) {
    let n, r;
    try {
      n = this.logic.transition(this._snapshot, t, this._actorScope);
    } catch (i) {
      r = {
        err: i
      };
    }
    if (r) {
      const {
        err: i
      } = r;
      this._snapshot = {
        ...this._snapshot,
        status: "error",
        error: i
      }, this._error(i);
      return;
    }
    this.update(n, t), t.type === MD && (this._stopProcedure(), this._complete());
  }
  _stop() {
    return this._processingStatus === ts.Stopped ? this : (this.mailbox.clear(), this._processingStatus === ts.NotStarted ? (this._processingStatus = ts.Stopped, this) : (this.mailbox.enqueue({
      type: MD
    }), this));
  }
  /** Stops the Actor and unsubscribe all listeners. */
  stop() {
    if (this._parent)
      throw new Error("A non-root actor cannot be stopped directly.");
    return this._stop();
  }
  _complete() {
    var t;
    for (const n of this.observers)
      try {
        (t = n.complete) == null || t.call(n);
      } catch (r) {
        Bd(r);
      }
    this.observers.clear();
  }
  _reportError(t) {
    if (!this.observers.size) {
      this._parent || Bd(t);
      return;
    }
    let n = !1;
    for (const r of this.observers) {
      const i = r.error;
      n || (n = !i);
      try {
        i == null || i(t);
      } catch (o) {
        Bd(o);
      }
    }
    this.observers.clear(), n && Bd(t);
  }
  _error(t) {
    this._stopProcedure(), this._reportError(t), this._parent && this.system._relay(this, this._parent, vPe(this.id, t));
  }
  // TODO: atm children don't belong entirely to the actor so
  // in a way - it's not even super aware of them
  // so we can't stop them from here but we really should!
  // right now, they are being stopped within the machine's transition
  // but that could throw and leave us with "orphaned" active actors
  _stopProcedure() {
    return this._processingStatus !== ts.Running ? this : (this.system.scheduler.cancelAll(this), this.mailbox.clear(), this.mailbox = new cz(this._process.bind(this)), this._processingStatus = ts.Stopped, this.system._unregister(this), this);
  }
  /** @internal */
  _send(t) {
    this._processingStatus !== ts.Stopped && this.mailbox.enqueue(t);
  }
  /**
   * Sends an event to the running Actor to trigger a transition.
   *
   * @param event The event to send
   */
  send(t) {
    this.system._relay(void 0, this, t);
  }
  attachDevTools() {
    const {
      devTools: t
    } = this.options;
    t && (typeof t == "function" ? t : dPe)(this);
  }
  toJSON() {
    return {
      xstate$$type: $N,
      id: this.id
    };
  }
  /**
   * Obtain the internal state of the actor, which can be persisted.
   *
   * @remarks
   * The internal state can be persisted from any actor, not only machines.
   *
   * Note that the persisted state is not the same as the snapshot from
   * {@link Actor.getSnapshot}. Persisted state represents the internal state of
   * the actor, while snapshots represent the actor's last emitted value.
   *
   * Can be restored with {@link ActorOptions.state}
   * @see https://stately.ai/docs/persistence
   */
  getPersistedSnapshot(t) {
    return this.logic.getPersistedSnapshot(this._snapshot, t);
  }
  [gPe]() {
    return this;
  }
  /**
   * Read an actors snapshot synchronously.
   *
   * @remarks
   * The snapshot represent an actor's last emitted value.
   *
   * When an actor receives an event, its internal state may change. An actor
   * may emit a snapshot when a state transition occurs.
   *
   * Note that some actors, such as callback actors generated with
   * `fromCallback`, will not emit snapshots.
   * @see {@link Actor.subscribe} to subscribe to an actors snapshot values.
   * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).
   */
  getSnapshot() {
    return this._snapshot;
  }
}
function Ab(e, ...[t]) {
  return new SPe(e, t);
}
function kPe(e, t, n, r, {
  sendId: i
}) {
  const o = typeof i == "function" ? i(n, r) : i;
  return [t, o];
}
function APe(e, t) {
  e.defer(() => {
    e.system.scheduler.cancel(e.self, t);
  });
}
function TPe(e) {
  function t(n, r) {
  }
  return t.type = "xstate.cancel", t.sendId = e, t.resolve = kPe, t.execute = APe, t;
}
function _Pe(e, t, n, r, {
  id: i,
  systemId: o,
  src: s,
  input: c,
  syncSnapshot: u
}) {
  const f = typeof s == "string" ? VN(t.machine, s) : s, p = typeof i == "function" ? i(n) : i;
  let y;
  return f && (y = Ab(f, {
    id: p,
    src: s,
    parent: e.self,
    syncSnapshot: u,
    systemId: o,
    input: typeof c == "function" ? c({
      context: t.context,
      event: n.event,
      self: e.self
    }) : c
  })), [oy(t, {
    children: {
      ...t.children,
      [p]: y
    }
  }), {
    id: i,
    actorRef: y
  }];
}
function RPe(e, {
  id: t,
  actorRef: n
}) {
  n && e.defer(() => {
    n._processingStatus !== ts.Stopped && n.start();
  });
}
function OPe(...[e, {
  id: t,
  systemId: n,
  input: r,
  syncSnapshot: i = !1
} = {}]) {
  function o(s, c) {
  }
  return o.type = "snapshot.spawnChild", o.id = t, o.systemId = n, o.src = e, o.input = r, o.syncSnapshot = i, o.resolve = _Pe, o.execute = RPe, o;
}
function IPe(e, t, n, r, {
  actorRef: i
}) {
  const o = typeof i == "function" ? i(n, r) : i, s = typeof o == "string" ? t.children[o] : o;
  let c = t.children;
  return s && (c = {
    ...c
  }, delete c[s.id]), [oy(t, {
    children: c
  }), s];
}
function DPe(e, t) {
  if (t) {
    if (e.system._unregister(t), t._processingStatus !== ts.Running) {
      e.stopChild(t);
      return;
    }
    e.defer(() => {
      e.stopChild(t);
    });
  }
}
function AJ(e) {
  function t(n, r) {
  }
  return t.type = "xstate.stopChild", t.actorRef = e, t.resolve = IPe, t.execute = DPe, t;
}
function HN(e, t, n, r) {
  const {
    machine: i
  } = r, o = typeof e == "function", s = o ? e : i.implementations.guards[typeof e == "string" ? e : e.type];
  if (!o && !s)
    throw new Error(`Guard '${typeof e == "string" ? e : e.type}' is not implemented.'.`);
  if (typeof s != "function")
    return HN(s, t, n, r);
  const c = {
    context: t,
    event: n
  }, u = o || typeof e == "string" ? void 0 : "params" in e ? typeof e.params == "function" ? e.params({
    context: t,
    event: n
  }) : e.params : void 0;
  return "check" in s ? s.check(
    r,
    c,
    s
    // this holds all params
  ) : s(c, u);
}
const qN = (e) => e.type === "atomic" || e.type === "final";
function Tb(e) {
  return Object.values(e.states).filter((t) => t.type !== "history");
}
function wx(e, t) {
  const n = [];
  if (t === e)
    return n;
  let r = e.parent;
  for (; r && r !== t; )
    n.push(r), r = r.parent;
  return n;
}
function l8(e) {
  const t = new Set(e), n = _J(t);
  for (const r of t)
    if (r.type === "compound" && (!n.get(r) || !n.get(r).length))
      pz(r).forEach((i) => t.add(i));
    else if (r.type === "parallel") {
      for (const i of Tb(r))
        if (i.type !== "history" && !t.has(i)) {
          const o = pz(i);
          for (const s of o)
            t.add(s);
        }
    }
  for (const r of t) {
    let i = r.parent;
    for (; i; )
      t.add(i), i = i.parent;
  }
  return t;
}
function TJ(e, t) {
  const n = t.get(e);
  if (!n)
    return {};
  if (e.type === "compound") {
    const i = n[0];
    if (i) {
      if (qN(i))
        return i.key;
    } else
      return {};
  }
  const r = {};
  for (const i of n)
    r[i.key] = TJ(i, t);
  return r;
}
function _J(e) {
  const t = /* @__PURE__ */ new Map();
  for (const n of e)
    t.has(n) || t.set(n, []), n.parent && (t.has(n.parent) || t.set(n.parent, []), t.get(n.parent).push(n));
  return t;
}
function RJ(e, t) {
  const n = l8(t);
  return TJ(e, _J(n));
}
function WN(e, t) {
  return t.type === "compound" ? Tb(t).some((n) => n.type === "final" && e.has(n)) : t.type === "parallel" ? Tb(t).every((n) => WN(e, n)) : t.type === "final";
}
const QA = (e) => e[0] === hPe;
function MPe(e, t) {
  return e.transitions.get(t) || [...e.transitions.keys()].filter((r) => {
    if (r === pPe)
      return !0;
    if (!r.endsWith(".*"))
      return !1;
    const i = r.split("."), o = t.split(".");
    for (let s = 0; s < i.length; s++) {
      const c = i[s], u = o[s];
      if (c === "*")
        return s === i.length - 1;
      if (c !== u)
        return !1;
    }
    return !0;
  }).sort((r, i) => i.length - r.length).flatMap((r) => e.transitions.get(r));
}
function PPe(e) {
  const t = e.config.after;
  if (!t)
    return [];
  const n = (i, o) => {
    const s = mPe(i, e.id), c = s.type;
    return e.entry.push(aNe(s, {
      id: c,
      delay: i
    })), e.exit.push(TPe(c)), c;
  };
  return Object.keys(t).flatMap((i, o) => {
    const s = t[i], c = typeof s == "string" ? {
      target: s
    } : s, u = Number.isNaN(+i) ? i : +i, f = n(u);
    return zh(c).map((p) => ({
      ...p,
      event: f,
      delay: u
    }));
  }).map((i) => {
    const {
      delay: o
    } = i;
    return {
      ...Sm(e, i.event, i),
      delay: o
    };
  });
}
function Sm(e, t, n) {
  const r = kJ(n.target), i = n.reenter ?? !1, o = LPe(e, r), s = {
    ...n,
    actions: zh(n.actions),
    guard: n.guard,
    target: o,
    source: e,
    reenter: i,
    eventType: t,
    toJSON: () => ({
      ...s,
      source: `#${e.id}`,
      target: o ? o.map((c) => `#${c.id}`) : void 0
    })
  };
  return s;
}
function NPe(e) {
  const t = /* @__PURE__ */ new Map();
  if (e.config.on)
    for (const n of Object.keys(e.config.on)) {
      if (n === bJ)
        throw new Error('Null events ("") cannot be specified as a transition key. Use `always: { ... }` instead.');
      const r = e.config.on[n];
      t.set(n, yg(r).map((i) => Sm(e, n, i)));
    }
  if (e.config.onDone) {
    const n = `xstate.done.state.${e.id}`;
    t.set(n, yg(e.config.onDone).map((r) => Sm(e, n, r)));
  }
  for (const n of e.invoke) {
    if (n.onDone) {
      const r = `xstate.done.actor.${n.id}`;
      t.set(r, yg(n.onDone).map((i) => Sm(e, r, i)));
    }
    if (n.onError) {
      const r = `xstate.error.actor.${n.id}`;
      t.set(r, yg(n.onError).map((i) => Sm(e, r, i)));
    }
    if (n.onSnapshot) {
      const r = `xstate.snapshot.${n.id}`;
      t.set(r, yg(n.onSnapshot).map((i) => Sm(e, r, i)));
    }
  }
  for (const n of e.after) {
    let r = t.get(n.eventType);
    r || (r = [], t.set(n.eventType, r)), r.push(n);
  }
  return t;
}
function BPe(e, t) {
  const n = typeof t == "string" ? e.states[t] : t ? e.states[t.target] : void 0;
  if (!n && t)
    throw new Error(`Initial state node "${t}" not found on parent state node #${e.id}`);
  const r = {
    source: e,
    actions: !t || typeof t == "string" ? [] : zh(t.actions),
    eventType: null,
    reenter: !1,
    target: n ? [n] : [],
    toJSON: () => ({
      ...r,
      source: `#${e.id}`,
      target: n ? [`#${n.id}`] : []
    })
  };
  return r;
}
function LPe(e, t) {
  if (t !== void 0)
    return t.map((n) => {
      if (typeof n != "string")
        return n;
      if (QA(n))
        return e.machine.getStateNodeById(n);
      const r = n[0] === gJ;
      if (r && !e.parent)
        return c8(e, n.slice(1));
      const i = r ? e.key + n : n;
      if (e.parent)
        try {
          return c8(e.parent, i);
        } catch (o) {
          throw new Error(`Invalid transition definition for state node '${e.id}':
${o.message}`);
        }
      else
        throw new Error(`Invalid target: "${n}" is not a valid target from the root node. Did you mean ".${n}"?`);
    });
}
function OJ(e) {
  const t = kJ(e.config.target);
  return t ? {
    target: t.map((n) => typeof n == "string" ? c8(e.parent, n) : n)
  } : e.parent.initial;
}
function Dm(e) {
  return e.type === "history";
}
function pz(e) {
  const t = IJ(e);
  for (const n of t)
    for (const r of wx(n, e))
      t.add(r);
  return t;
}
function IJ(e) {
  const t = /* @__PURE__ */ new Set();
  function n(r) {
    if (!t.has(r)) {
      if (t.add(r), r.type === "compound")
        n(r.initial.target[0]);
      else if (r.type === "parallel")
        for (const i of Tb(r))
          n(i);
    }
  }
  return n(e), t;
}
function _b(e, t) {
  if (QA(t))
    return e.machine.getStateNodeById(t);
  if (!e.states)
    throw new Error(`Unable to retrieve child state '${t}' from '${e.id}'; no child states exist.`);
  const n = e.states[t];
  if (!n)
    throw new Error(`Child state '${t}' does not exist on '${e.id}'`);
  return n;
}
function c8(e, t) {
  if (typeof t == "string" && QA(t))
    try {
      return e.machine.getStateNodeById(t);
    } catch {
    }
  const n = zN(t).slice();
  let r = e;
  for (; n.length; ) {
    const i = n.shift();
    if (!i.length)
      break;
    r = _b(r, i);
  }
  return r;
}
function u8(e, t) {
  if (typeof t == "string") {
    const i = e.states[t];
    if (!i)
      throw new Error(`State '${t}' does not exist on '${e.id}'`);
    return [e, i];
  }
  const n = Object.keys(t), r = n.map((i) => _b(e, i)).filter(Boolean);
  return [e.machine.root, e].concat(r, n.reduce((i, o) => {
    const s = _b(e, o);
    if (!s)
      return i;
    const c = u8(s, t[o]);
    return i.concat(c);
  }, []));
}
function jPe(e, t, n, r) {
  const o = _b(e, t).next(n, r);
  return !o || !o.length ? e.next(n, r) : o;
}
function FPe(e, t, n, r) {
  const i = Object.keys(t), o = _b(e, i[0]), s = GN(o, t[i[0]], n, r);
  return !s || !s.length ? e.next(n, r) : s;
}
function UPe(e, t, n, r) {
  const i = [];
  for (const o of Object.keys(t)) {
    const s = t[o];
    if (!s)
      continue;
    const c = _b(e, o), u = GN(c, s, n, r);
    u && i.push(...u);
  }
  return i.length ? i : e.next(n, r);
}
function GN(e, t, n, r) {
  return typeof t == "string" ? jPe(e, t, n, r) : Object.keys(t).length === 1 ? FPe(e, t, n, r) : UPe(e, t, n, r);
}
function zPe(e) {
  return Object.keys(e.states).map((t) => e.states[t]).filter((t) => t.type === "history");
}
function ip(e, t) {
  let n = e;
  for (; n.parent && n.parent !== t; )
    n = n.parent;
  return n.parent === t;
}
function VPe(e, t) {
  const n = new Set(e), r = new Set(t);
  for (const i of n)
    if (r.has(i))
      return !0;
  for (const i of r)
    if (n.has(i))
      return !0;
  return !1;
}
function DJ(e, t, n) {
  const r = /* @__PURE__ */ new Set();
  for (const i of e) {
    let o = !1;
    const s = /* @__PURE__ */ new Set();
    for (const c of r)
      if (VPe(LD([i], t, n), LD([c], t, n)))
        if (ip(i.source, c.source))
          s.add(c);
        else {
          o = !0;
          break;
        }
    if (!o) {
      for (const c of s)
        r.delete(c);
      r.add(i);
    }
  }
  return Array.from(r);
}
function $Pe(e) {
  const [t, ...n] = e;
  for (const r of wx(t, void 0))
    if (n.every((i) => ip(i, r)))
      return r;
}
function KN(e, t) {
  if (!e.target)
    return [];
  const n = /* @__PURE__ */ new Set();
  for (const r of e.target)
    if (Dm(r))
      if (t[r.id])
        for (const i of t[r.id])
          n.add(i);
      else
        for (const i of KN(OJ(r), t))
          n.add(i);
    else
      n.add(r);
  return [...n];
}
function MJ(e, t) {
  const n = KN(e, t);
  if (!n)
    return;
  if (!e.reenter && n.every((i) => i === e.source || ip(i, e.source)))
    return e.source;
  const r = $Pe(n.concat(e.source));
  if (r)
    return r;
  if (!e.reenter)
    return e.source.machine.root;
}
function LD(e, t, n) {
  var i;
  const r = /* @__PURE__ */ new Set();
  for (const o of e)
    if ((i = o.target) != null && i.length) {
      const s = MJ(o, n);
      o.reenter && o.source === s && r.add(s);
      for (const c of t)
        ip(c, s) && r.add(c);
    }
  return [...r];
}
function HPe(e, t) {
  if (e.length !== t.size)
    return !1;
  for (const n of e)
    if (!t.has(n))
      return !1;
  return !0;
}
function jD(e, t, n, r, i, o) {
  if (!e.length)
    return t;
  const s = new Set(t._nodes);
  let c = t.historyValue;
  const u = DJ(e, s, c);
  let f = t;
  i || ([f, c] = KPe(f, r, n, u, s, c, o)), f = Rb(f, r, n, u.flatMap((y) => y.actions), o), f = WPe(f, r, n, u, s, o, c, i);
  const p = [...s];
  f.status === "done" && (f = Rb(f, r, n, p.sort((y, v) => v.order - y.order).flatMap((y) => y.exit), o));
  try {
    return c === t.historyValue && HPe(t._nodes, s) ? f : oy(f, {
      _nodes: p,
      historyValue: c
    });
  } catch (y) {
    throw y;
  }
}
function qPe(e, t, n, r, i) {
  if (r.output === void 0)
    return;
  const o = PD(i.id, i.output !== void 0 && i.parent ? ND(i.output, e.context, t, n.self) : void 0);
  return ND(r.output, e.context, o, n.self);
}
function WPe(e, t, n, r, i, o, s, c) {
  let u = e;
  const f = /* @__PURE__ */ new Set(), p = /* @__PURE__ */ new Set();
  GPe(r, s, p, f), c && p.add(e.machine.root);
  const y = /* @__PURE__ */ new Set();
  for (const v of [...f].sort((w, C) => w.order - C.order)) {
    i.add(v);
    const w = [];
    w.push(...v.entry);
    for (const C of v.invoke)
      w.push(OPe(C.src, {
        ...C,
        syncSnapshot: !!C.onSnapshot
      }));
    if (p.has(v)) {
      const C = v.initial.actions;
      w.push(...C);
    }
    if (u = Rb(u, t, n, w, o, v.invoke.map((C) => C.id)), v.type === "final") {
      const C = v.parent;
      let x = (C == null ? void 0 : C.type) === "parallel" ? C : C == null ? void 0 : C.parent, A = x || v;
      for ((C == null ? void 0 : C.type) === "compound" && o.push(PD(C.id, v.output !== void 0 ? ND(v.output, u.context, t, n.self) : void 0)); (x == null ? void 0 : x.type) === "parallel" && !y.has(x) && WN(i, x); )
        y.add(x), o.push(PD(x.id)), A = x, x = x.parent;
      if (x)
        continue;
      u = oy(u, {
        status: "done",
        output: qPe(u, t, n, u.machine.root, A)
      });
    }
  }
  return u;
}
function GPe(e, t, n, r) {
  for (const i of e) {
    const o = MJ(i, t);
    for (const c of i.target || [])
      !Dm(c) && // if the target is different than the source then it will *definitely* be entered
      (i.source !== c || // we know that the domain can't lie within the source
      // if it's different than the source then it's outside of it and it means that the target has to be entered as well
      i.source !== o || // reentering transitions always enter the target, even if it's the source itself
      i.reenter) && (r.add(c), n.add(c)), _g(c, t, n, r);
    const s = KN(i, t);
    for (const c of s) {
      const u = wx(c, o);
      (o == null ? void 0 : o.type) === "parallel" && u.push(o), PJ(r, t, n, u, !i.source.parent && i.reenter ? void 0 : o);
    }
  }
}
function _g(e, t, n, r) {
  var i;
  if (Dm(e))
    if (t[e.id]) {
      const o = t[e.id];
      for (const s of o)
        r.add(s), _g(s, t, n, r);
      for (const s of o)
        lI(s, e.parent, r, t, n);
    } else {
      const o = OJ(e);
      for (const s of o.target)
        r.add(s), o === ((i = e.parent) == null ? void 0 : i.initial) && n.add(e.parent), _g(s, t, n, r);
      for (const s of o.target)
        lI(s, e.parent, r, t, n);
    }
  else if (e.type === "compound") {
    const [o] = e.initial.target;
    Dm(o) || (r.add(o), n.add(o)), _g(o, t, n, r), lI(o, e, r, t, n);
  } else if (e.type === "parallel")
    for (const o of Tb(e).filter((s) => !Dm(s)))
      [...r].some((s) => ip(s, o)) || (Dm(o) || (r.add(o), n.add(o)), _g(o, t, n, r));
}
function PJ(e, t, n, r, i) {
  for (const o of r)
    if ((!i || ip(o, i)) && e.add(o), o.type === "parallel")
      for (const s of Tb(o).filter((c) => !Dm(c)))
        [...e].some((c) => ip(c, s)) || (e.add(s), _g(s, t, n, e));
}
function lI(e, t, n, r, i) {
  PJ(n, r, i, wx(e, t));
}
function KPe(e, t, n, r, i, o, s) {
  let c = e;
  const u = LD(r, i, o);
  u.sort((p, y) => y.order - p.order);
  let f;
  for (const p of u)
    for (const y of zPe(p)) {
      let v;
      y.history === "deep" ? v = (w) => qN(w) && ip(w, p) : v = (w) => w.parent === p, f ?? (f = {
        ...o
      }), f[y.id] = Array.from(i).filter(v);
    }
  for (const p of u)
    c = Rb(c, t, n, [...p.exit, ...p.invoke.map((y) => AJ(y.id))], s), i.delete(p);
  return [c, f || o];
}
let mz = !1;
function NJ(e, t, n, r, i, o) {
  const {
    machine: s
  } = e;
  let c = e;
  for (const u of r) {
    let w = function() {
      n.system._sendInspectionEvent({
        type: "@xstate.action",
        actorRef: n.self,
        action: {
          type: typeof u == "string" ? u : typeof u == "object" ? u.type : u.name || "(anonymous)",
          params: v
        }
      });
      try {
        mz = p, p(y, v);
      } finally {
        mz = !1;
      }
    };
    const f = typeof u == "function", p = f ? u : (
      // the existing type of `.actions` assumes non-nullable `TExpressionAction`
      // it's fine to cast this here to get a common type and lack of errors in the rest of the code
      // our logic below makes sure that we call those 2 "variants" correctly
      s.implementations.actions[typeof u == "string" ? u : u.type]
    );
    if (!p)
      continue;
    const y = {
      context: c.context,
      event: t,
      self: n.self,
      system: n.system
    }, v = f || typeof u == "string" ? void 0 : "params" in u ? typeof u.params == "function" ? u.params({
      context: c.context,
      event: t
    }) : u.params : void 0;
    if (!("resolve" in p)) {
      n.self._processingStatus === ts.Running ? w() : n.defer(() => {
        w();
      });
      continue;
    }
    const C = p, [x, A, R] = C.resolve(
      n,
      c,
      y,
      v,
      p,
      // this holds all params
      i
    );
    c = x, "retryResolve" in C && (o == null || o.push([C, A])), "execute" in C && (n.self._processingStatus === ts.Running ? C.execute(n, A) : n.defer(C.execute.bind(null, n, A))), R && (c = NJ(c, t, n, R, i, o));
  }
  return c;
}
function Rb(e, t, n, r, i, o) {
  const s = o ? [] : void 0, c = NJ(e, t, n, r, {
    internalQueue: i,
    deferredActorIds: o
  }, s);
  return s == null || s.forEach(([u, f]) => {
    u.retryResolve(n, c, f);
  }), c;
}
function cI(e, t, n, r = []) {
  let i = e;
  const o = [];
  function s(f, p, y) {
    n.system._sendInspectionEvent({
      type: "@xstate.microstep",
      actorRef: n.self,
      event: p,
      snapshot: f,
      _transitions: y
    }), o.push(f);
  }
  if (t.type === MD)
    return i = oy(yz(i, t, n), {
      status: "stopped"
    }), s(i, t, []), {
      snapshot: i,
      microstates: o
    };
  let c = t;
  if (c.type !== wJ) {
    const f = c, p = wPe(f), y = vz(f, i);
    if (p && !y.length)
      return i = oy(e, {
        status: "error",
        error: f.error
      }), s(i, f, []), {
        snapshot: i,
        microstates: o
      };
    i = jD(
      y,
      e,
      n,
      c,
      !1,
      // isInitial
      r
    ), s(i, f, y);
  }
  let u = !0;
  for (; i.status === "active"; ) {
    let f = u ? YPe(i, c) : [];
    const p = f.length ? i : void 0;
    if (!f.length) {
      if (!r.length)
        break;
      c = r.shift(), f = vz(c, i);
    }
    i = jD(f, i, n, c, !1, r), u = i !== p, s(i, c, f);
  }
  return i.status !== "active" && yz(i, c, n), {
    snapshot: i,
    microstates: o
  };
}
function yz(e, t, n) {
  return Rb(e, t, n, Object.values(e.children).map((r) => AJ(r)), []);
}
function vz(e, t) {
  return t.machine.getTransitionData(t, e);
}
function YPe(e, t) {
  const n = /* @__PURE__ */ new Set(), r = e._nodes.filter(qN);
  for (const i of r)
    e: for (const o of [i].concat(wx(i, void 0)))
      if (o.always) {
        for (const s of o.always)
          if (s.guard === void 0 || HN(s.guard, e.context, t, e)) {
            n.add(s);
            break e;
          }
      }
  return DJ(Array.from(n), new Set(e._nodes), e.historyValue);
}
function QPe(e, t) {
  const n = l8(u8(e, t));
  return RJ(e, [...n]);
}
function XPe(e) {
  return !!e && typeof e == "object" && "machine" in e && "value" in e;
}
const JPe = function(t) {
  return xJ(t, this.value);
}, ZPe = function(t) {
  return this.tags.has(t);
}, eNe = function(t) {
  const n = this.machine.getTransitionData(this, t);
  return !!(n != null && n.length) && // Check that at least one transition is not forbidden
  n.some((r) => r.target !== void 0 || r.actions.length);
}, tNe = function() {
  const {
    _nodes: t,
    tags: n,
    machine: r,
    getMeta: i,
    toJSON: o,
    can: s,
    hasTag: c,
    matches: u,
    ...f
  } = this;
  return {
    ...f,
    tags: Array.from(n)
  };
}, nNe = function() {
  return this._nodes.reduce((t, n) => (n.meta !== void 0 && (t[n.id] = n.meta), t), {});
};
function w4(e, t) {
  return {
    status: e.status,
    output: e.output,
    error: e.error,
    machine: t,
    context: e.context,
    _nodes: e._nodes,
    value: RJ(t.root, e._nodes),
    tags: new Set(e._nodes.flatMap((n) => n.tags)),
    children: e.children,
    historyValue: e.historyValue || {},
    matches: JPe,
    hasTag: ZPe,
    can: eNe,
    getMeta: nNe,
    toJSON: tNe
  };
}
function oy(e, t = {}) {
  return w4({
    ...e,
    ...t
  }, e.machine);
}
function rNe(e, t) {
  const {
    _nodes: n,
    tags: r,
    machine: i,
    children: o,
    context: s,
    can: c,
    hasTag: u,
    matches: f,
    getMeta: p,
    toJSON: y,
    ...v
  } = e, w = {};
  for (const x in o) {
    const A = o[x];
    w[x] = {
      snapshot: A.getPersistedSnapshot(t),
      src: A.src,
      systemId: A._systemId,
      syncSnapshot: A._syncSnapshot
    };
  }
  return {
    ...v,
    context: BJ(s),
    children: w
  };
}
function BJ(e) {
  let t;
  for (const n in e) {
    const r = e[n];
    if (r && typeof r == "object")
      if ("sessionId" in r && "send" in r && "ref" in r)
        t ?? (t = Array.isArray(e) ? e.slice() : {
          ...e
        }), t[n] = {
          xstate$$type: $N,
          id: r.id
        };
      else {
        const i = BJ(r);
        i !== r && (t ?? (t = Array.isArray(e) ? e.slice() : {
          ...e
        }), t[n] = i);
      }
  }
  return t ?? e;
}
function iNe(e, t, n, r, {
  event: i,
  id: o,
  delay: s
}, {
  internalQueue: c
}) {
  const u = t.machine.implementations.delays;
  if (typeof i == "string")
    throw new Error(`Only event objects may be used with raise; use raise({ type: "${i}" }) instead`);
  const f = typeof i == "function" ? i(n, r) : i;
  let p;
  if (typeof s == "string") {
    const y = u && u[s];
    p = typeof y == "function" ? y(n, r) : y;
  } else
    p = typeof s == "function" ? s(n, r) : s;
  return typeof p != "number" && c.push(f), [t, {
    event: f,
    id: o,
    delay: p
  }];
}
function oNe(e, t) {
  const {
    event: n,
    delay: r,
    id: i
  } = t;
  if (typeof r == "number") {
    e.defer(() => {
      const o = e.self;
      e.system.scheduler.schedule(o, o, n, r, i);
    });
    return;
  }
}
function aNe(e, t) {
  function n(r, i) {
  }
  return n.type = "xstate.raise", n.event = e, n.id = t == null ? void 0 : t.id, n.delay = t == null ? void 0 : t.delay, n.resolve = iNe, n.execute = oNe, n;
}
function sNe(e, {
  machine: t,
  context: n
}, r, i) {
  const o = (s, c = {}) => {
    const {
      systemId: u,
      input: f
    } = c;
    if (typeof s == "string") {
      const p = VN(t, s);
      if (!p)
        throw new Error(`Actor logic '${s}' not implemented in machine '${t.id}'`);
      const y = Ab(p, {
        id: c.id,
        parent: e.self,
        syncSnapshot: c.syncSnapshot,
        input: typeof f == "function" ? f({
          context: n,
          event: r,
          self: e.self
        }) : f,
        src: s,
        systemId: u
      });
      return i[y.id] = y, y;
    } else
      return Ab(s, {
        id: c.id,
        parent: e.self,
        syncSnapshot: c.syncSnapshot,
        input: c.input,
        src: s,
        systemId: u
      });
  };
  return (s, c) => {
    const u = o(s, c);
    return i[u.id] = u, e.defer(() => {
      u._processingStatus !== ts.Stopped && u.start();
    }), u;
  };
}
function lNe(e, t, n, r, {
  assignment: i
}) {
  if (!t.context)
    throw new Error("Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.");
  const o = {}, s = {
    context: t.context,
    event: n.event,
    spawn: sNe(e, t, n.event, o),
    self: e.self,
    system: e.system
  };
  let c = {};
  if (typeof i == "function")
    c = i(s, r);
  else
    for (const f of Object.keys(i)) {
      const p = i[f];
      c[f] = typeof p == "function" ? p(s, r) : p;
    }
  const u = Object.assign({}, t.context, c);
  return [oy(t, {
    context: u,
    children: Object.keys(o).length ? {
      ...t.children,
      ...o
    } : t.children
  })];
}
function Ra(e) {
  function t(n, r) {
  }
  return t.type = "xstate.assign", t.assignment = e, t.resolve = lNe, t;
}
function cNe(e, t, n, r, {
  event: i
}) {
  const o = typeof i == "function" ? i(n, r) : i;
  return [t, {
    event: o
  }];
}
function uNe(e, {
  event: t
}) {
  e.defer(() => e.emit(t));
}
function dNe(e) {
  function t(n, r) {
  }
  return t.type = "xstate.emit", t.event = e, t.resolve = cNe, t.execute = uNe, t;
}
const gz = /* @__PURE__ */ new WeakMap();
function hg(e, t, n) {
  let r = gz.get(e);
  return r ? t in r || (r[t] = n()) : (r = {
    [t]: n()
  }, gz.set(e, r)), r[t];
}
const fNe = {}, m1 = (e) => typeof e == "string" ? {
  type: e
} : typeof e == "function" ? "resolve" in e ? {
  type: e.type
} : {
  type: e.name
} : e;
class YN {
  constructor(t, n) {
    if (this.config = t, this.key = void 0, this.id = void 0, this.type = void 0, this.path = void 0, this.states = void 0, this.history = void 0, this.entry = void 0, this.exit = void 0, this.parent = void 0, this.machine = void 0, this.meta = void 0, this.output = void 0, this.order = -1, this.description = void 0, this.tags = [], this.transitions = void 0, this.always = void 0, this.parent = n._parent, this.key = n._key, this.machine = n._machine, this.path = this.parent ? this.parent.path.concat(this.key) : [], this.id = this.config.id || [this.machine.id, ...this.path].join(gJ), this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? "compound" : this.config.history ? "history" : "atomic"), this.description = this.config.description, this.order = this.machine.idMap.size, this.machine.idMap.set(this.id, this), this.states = this.config.states ? dz(this.config.states, (r, i) => new YN(r, {
      _parent: this,
      _key: i,
      _machine: this.machine
    })) : fNe, this.type === "compound" && !this.config.initial)
      throw new Error(`No initial state specified for compound state node "#${this.id}". Try adding { initial: "${Object.keys(this.states)[0]}" } to the state config.`);
    this.history = this.config.history === !0 ? "shallow" : this.config.history || !1, this.entry = zh(this.config.entry).slice(), this.exit = zh(this.config.exit).slice(), this.meta = this.config.meta, this.output = this.type === "final" || !this.parent ? this.config.output : void 0, this.tags = zh(t.tags).slice();
  }
  /** @internal */
  _initialize() {
    this.transitions = NPe(this), this.config.always && (this.always = yg(this.config.always).map((t) => Sm(this, bJ, t))), Object.keys(this.states).forEach((t) => {
      this.states[t]._initialize();
    });
  }
  /** The well-structured state node definition. */
  get definition() {
    return {
      id: this.id,
      key: this.key,
      version: this.machine.version,
      type: this.type,
      initial: this.initial ? {
        target: this.initial.target,
        source: this,
        actions: this.initial.actions.map(m1),
        eventType: null,
        reenter: !1,
        toJSON: () => ({
          target: this.initial.target.map((t) => `#${t.id}`),
          source: `#${this.id}`,
          actions: this.initial.actions.map(m1),
          eventType: null
        })
      } : void 0,
      history: this.history,
      states: dz(this.states, (t) => t.definition),
      on: this.on,
      transitions: [...this.transitions.values()].flat().map((t) => ({
        ...t,
        actions: t.actions.map(m1)
      })),
      entry: this.entry.map(m1),
      exit: this.exit.map(m1),
      meta: this.meta,
      order: this.order || -1,
      output: this.output,
      invoke: this.invoke,
      description: this.description,
      tags: this.tags
    };
  }
  /** @internal */
  toJSON() {
    return this.definition;
  }
  /** The logic invoked as actors by this state node. */
  get invoke() {
    return hg(this, "invoke", () => zh(this.config.invoke).map((t, n) => {
      const {
        src: r,
        systemId: i
      } = t, o = t.id ?? fz(this.id, n), s = typeof r == "string" ? r : `xstate.invoke.${fz(this.id, n)}`;
      return {
        ...t,
        src: s,
        id: o,
        systemId: i,
        toJSON() {
          const {
            onDone: c,
            onError: u,
            ...f
          } = t;
          return {
            ...f,
            type: "xstate.invoke",
            src: s,
            id: o
          };
        }
      };
    }));
  }
  /** The mapping of events to transitions. */
  get on() {
    return hg(this, "on", () => [...this.transitions].flatMap(([n, r]) => r.map((i) => [n, i])).reduce((n, [r, i]) => (n[r] = n[r] || [], n[r].push(i), n), {}));
  }
  get after() {
    return hg(this, "delayedTransitions", () => PPe(this));
  }
  get initial() {
    return hg(this, "initial", () => BPe(this, this.config.initial));
  }
  /** @internal */
  next(t, n) {
    const r = n.type, i = [];
    let o;
    const s = hg(this, `candidates-${r}`, () => MPe(this, r));
    for (const c of s) {
      const {
        guard: u
      } = c, f = t.context;
      let p = !1;
      try {
        p = !u || HN(u, f, n, t);
      } catch (y) {
        const v = typeof u == "string" ? u : typeof u == "object" ? u.type : void 0;
        throw new Error(`Unable to evaluate guard ${v ? `'${v}' ` : ""}in transition for event '${r}' in state node '${this.id}':
${y.message}`);
      }
      if (p) {
        i.push(...c.actions), o = c;
        break;
      }
    }
    return o ? [o] : void 0;
  }
  /** All the event types accepted by this state node and its descendants. */
  get events() {
    return hg(this, "events", () => {
      const {
        states: t
      } = this, n = new Set(this.ownEvents);
      if (t)
        for (const r of Object.keys(t)) {
          const i = t[r];
          if (i.states)
            for (const o of i.events)
              n.add(`${o}`);
        }
      return Array.from(n);
    });
  }
  /**
   * All the events that have transitions directly from this state node.
   *
   * Excludes any inert events.
   */
  get ownEvents() {
    const t = new Set([...this.transitions.keys()].filter((n) => this.transitions.get(n).some((r) => !(!r.target && !r.actions.length && !r.reenter))));
    return Array.from(t);
  }
}
const hNe = "#";
class QN {
  constructor(t, n) {
    this.config = t, this.version = void 0, this.schemas = void 0, this.implementations = void 0, this.__xstatenode = !0, this.idMap = /* @__PURE__ */ new Map(), this.root = void 0, this.id = void 0, this.states = void 0, this.events = void 0, this.id = t.id || "(machine)", this.implementations = {
      actors: (n == null ? void 0 : n.actors) ?? {},
      actions: (n == null ? void 0 : n.actions) ?? {},
      delays: (n == null ? void 0 : n.delays) ?? {},
      guards: (n == null ? void 0 : n.guards) ?? {}
    }, this.version = this.config.version, this.schemas = this.config.schemas, this.transition = this.transition.bind(this), this.getInitialSnapshot = this.getInitialSnapshot.bind(this), this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this), this.restoreSnapshot = this.restoreSnapshot.bind(this), this.start = this.start.bind(this), this.root = new YN(t, {
      _key: this.id,
      _machine: this
    }), this.root._initialize(), this.states = this.root.states, this.events = this.root.events;
  }
  /**
   * Clones this state machine with the provided implementations and merges the
   * `context` (if provided).
   *
   * @param implementations Options (`actions`, `guards`, `actors`, `delays`,
   *   `context`) to recursively merge with the existing options.
   * @returns A new `StateMachine` instance with the provided implementations.
   */
  provide(t) {
    const {
      actions: n,
      guards: r,
      actors: i,
      delays: o
    } = this.implementations;
    return new QN(this.config, {
      actions: {
        ...n,
        ...t.actions
      },
      guards: {
        ...r,
        ...t.guards
      },
      actors: {
        ...i,
        ...t.actors
      },
      delays: {
        ...o,
        ...t.delays
      }
    });
  }
  resolveState(t) {
    const n = QPe(this.root, t.value), r = l8(u8(this.root, n));
    return w4({
      _nodes: [...r],
      context: t.context || {},
      children: {},
      status: WN(r, this.root) ? "done" : t.status || "active",
      output: t.output,
      error: t.error,
      historyValue: t.historyValue
    }, this);
  }
  /**
   * Determines the next snapshot given the current `snapshot` and received
   * `event`. Calculates a full macrostep from all microsteps.
   *
   * @param snapshot The current snapshot
   * @param event The received event
   */
  transition(t, n, r) {
    return cI(t, n, r).snapshot;
  }
  /**
   * Determines the next state given the current `state` and `event`. Calculates
   * a microstep.
   *
   * @param state The current state
   * @param event The received event
   */
  microstep(t, n, r) {
    return cI(t, n, r).microstates;
  }
  getTransitionData(t, n) {
    return GN(this.root, t.value, t, n) || [];
  }
  /**
   * The initial state _before_ evaluating any microsteps. This "pre-initial"
   * state is provided to initial actions executed in the initial state.
   */
  getPreInitialState(t, n, r) {
    const {
      context: i
    } = this.config, o = w4({
      context: typeof i != "function" && i ? i : {},
      _nodes: [this.root],
      children: {},
      status: "active"
    }, this);
    return typeof i == "function" ? Rb(o, n, t, [Ra(({
      spawn: c,
      event: u,
      self: f
    }) => i({
      spawn: c,
      input: u.input,
      self: f
    }))], r) : o;
  }
  /**
   * Returns the initial `State` instance, with reference to `self` as an
   * `ActorRef`.
   */
  getInitialSnapshot(t, n) {
    const r = CJ(n), i = [], o = this.getPreInitialState(t, r, i), s = jD([{
      target: [...IJ(this.root)],
      source: this.root,
      reenter: !0,
      actions: [],
      eventType: null,
      toJSON: null
      // TODO: fix
    }], o, t, r, !0, i), {
      snapshot: c
    } = cI(s, r, t, i);
    return c;
  }
  start(t) {
    Object.values(t.children).forEach((n) => {
      n.getSnapshot().status === "active" && n.start();
    });
  }
  getStateNodeById(t) {
    const n = zN(t), r = n.slice(1), i = QA(n[0]) ? n[0].slice(hNe.length) : n[0], o = this.idMap.get(i);
    if (!o)
      throw new Error(`Child state node '#${i}' does not exist on machine '${this.id}'`);
    return c8(o, r);
  }
  get definition() {
    return this.root.definition;
  }
  toJSON() {
    return this.definition;
  }
  getPersistedSnapshot(t, n) {
    return rNe(t, n);
  }
  restoreSnapshot(t, n) {
    const r = {}, i = t.children;
    Object.keys(i).forEach((u) => {
      const f = i[u], p = f.snapshot, y = f.src, v = typeof y == "string" ? VN(this, y) : y;
      if (!v)
        return;
      const w = Ab(v, {
        id: u,
        parent: n.self,
        syncSnapshot: f.syncSnapshot,
        snapshot: p,
        src: y,
        systemId: f.systemId
      });
      r[u] = w;
    });
    const o = w4({
      ...t,
      children: r,
      _nodes: Array.from(l8(u8(this.root, t.value)))
    }, this);
    let s = /* @__PURE__ */ new Set();
    function c(u, f) {
      if (!s.has(u)) {
        s.add(u);
        for (let p in u) {
          const y = u[p];
          if (y && typeof y == "object") {
            if ("xstate$$type" in y && y.xstate$$type === $N) {
              u[p] = f[y.id];
              continue;
            }
            c(y, f);
          }
        }
      }
    }
    return c(o.context, r), o;
  }
}
function pNe(e, t) {
  return new QN(e, t);
}
function LJ({
  schemas: e,
  actors: t,
  actions: n,
  guards: r,
  delays: i
}) {
  return {
    createMachine: (o) => pNe({
      ...o,
      schemas: e
    }, {
      actors: t,
      actions: n,
      guards: r,
      delays: i
    })
  };
}
var uI = {}, FD = { exports: {} }, dI = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var bz;
function mNe() {
  if (bz) return dI;
  bz = 1;
  var e = k;
  function t(y, v) {
    return y === v && (y !== 0 || 1 / y === 1 / v) || y !== y && v !== v;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, i = e.useEffect, o = e.useLayoutEffect, s = e.useDebugValue;
  function c(y, v) {
    var w = v(), C = r({ inst: { value: w, getSnapshot: v } }), x = C[0].inst, A = C[1];
    return o(function() {
      x.value = w, x.getSnapshot = v, u(x) && A({ inst: x });
    }, [y, w, v]), i(function() {
      return u(x) && A({ inst: x }), y(function() {
        u(x) && A({ inst: x });
      });
    }, [y]), s(w), w;
  }
  function u(y) {
    var v = y.getSnapshot;
    y = y.value;
    try {
      var w = v();
      return !n(y, w);
    } catch {
      return !0;
    }
  }
  function f(y, v) {
    return v();
  }
  var p = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? f : c;
  return dI.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : p, dI;
}
var fI = {}, wz;
function yNe() {
  return wz || (wz = 1, ct.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = k, t = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function n(D) {
      {
        for (var M = arguments.length, L = new Array(M > 1 ? M - 1 : 0), j = 1; j < M; j++)
          L[j - 1] = arguments[j];
        r("error", D, L);
      }
    }
    function r(D, M, L) {
      {
        var j = t.ReactDebugCurrentFrame, F = j.getStackAddendum();
        F !== "" && (M += "%s", L = L.concat([F]));
        var O = L.map(function(z) {
          return String(z);
        });
        O.unshift("Warning: " + M), Function.prototype.apply.call(console[D], console, O);
      }
    }
    function i(D, M) {
      return D === M && (D !== 0 || 1 / D === 1 / M) || D !== D && M !== M;
    }
    var o = typeof Object.is == "function" ? Object.is : i, s = e.useState, c = e.useEffect, u = e.useLayoutEffect, f = e.useDebugValue, p = !1, y = !1;
    function v(D, M, L) {
      p || e.startTransition !== void 0 && (p = !0, n("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var j = M();
      if (!y) {
        var F = M();
        o(j, F) || (n("The result of getSnapshot should be cached to avoid an infinite loop"), y = !0);
      }
      var O = s({
        inst: {
          value: j,
          getSnapshot: M
        }
      }), z = O[0].inst, H = O[1];
      return u(function() {
        z.value = j, z.getSnapshot = M, w(z) && H({
          inst: z
        });
      }, [D, j, M]), c(function() {
        w(z) && H({
          inst: z
        });
        var Q = function() {
          w(z) && H({
            inst: z
          });
        };
        return D(Q);
      }, [D]), f(j), j;
    }
    function w(D) {
      var M = D.getSnapshot, L = D.value;
      try {
        var j = M();
        return !o(L, j);
      } catch {
        return !0;
      }
    }
    function C(D, M, L) {
      return M();
    }
    var x = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", A = !x, R = A ? C : v, I = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : R;
    fI.useSyncExternalStore = I, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), fI;
}
ct.env.NODE_ENV === "production" ? FD.exports = mNe() : FD.exports = yNe();
var XN = FD.exports;
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Cz;
function vNe() {
  if (Cz) return uI;
  Cz = 1;
  var e = k, t = XN;
  function n(f, p) {
    return f === p && (f !== 0 || 1 / f === 1 / p) || f !== f && p !== p;
  }
  var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, o = e.useRef, s = e.useEffect, c = e.useMemo, u = e.useDebugValue;
  return uI.useSyncExternalStoreWithSelector = function(f, p, y, v, w) {
    var C = o(null);
    if (C.current === null) {
      var x = { hasValue: !1, value: null };
      C.current = x;
    } else x = C.current;
    C = c(function() {
      function R(j) {
        if (!I) {
          if (I = !0, D = j, j = v(j), w !== void 0 && x.hasValue) {
            var F = x.value;
            if (w(F, j)) return M = F;
          }
          return M = j;
        }
        if (F = M, r(D, j)) return F;
        var O = v(j);
        return w !== void 0 && w(F, O) ? F : (D = j, M = O);
      }
      var I = !1, D, M, L = y === void 0 ? null : y;
      return [function() {
        return R(p());
      }, L === null ? void 0 : function() {
        return R(L());
      }];
    }, [p, y, v, w]);
    var A = i(f, C[0], C[1]);
    return s(function() {
      x.hasValue = !0, x.value = A;
    }, [A]), u(A), A;
  }, uI;
}
var hI = {}, xz;
function gNe() {
  return xz || (xz = 1, ct.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = k, t = XN;
    function n(p, y) {
      return p === y && (p !== 0 || 1 / p === 1 / y) || p !== p && y !== y;
    }
    var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, o = e.useRef, s = e.useEffect, c = e.useMemo, u = e.useDebugValue;
    function f(p, y, v, w, C) {
      var x = o(null), A;
      x.current === null ? (A = {
        hasValue: !1,
        value: null
      }, x.current = A) : A = x.current;
      var R = c(function() {
        var L = !1, j, F, O = function(Y) {
          if (!L) {
            L = !0, j = Y;
            var ee = w(Y);
            if (C !== void 0 && A.hasValue) {
              var ie = A.value;
              if (C(ie, ee))
                return F = ie, ie;
            }
            return F = ee, ee;
          }
          var X = j, Z = F;
          if (r(X, Y))
            return Z;
          var J = w(Y);
          return C !== void 0 && C(Z, J) ? Z : (j = Y, F = J, J);
        }, z = v === void 0 ? null : v, H = function() {
          return O(y());
        }, Q = z === null ? void 0 : function() {
          return O(z());
        };
        return [H, Q];
      }, [y, v, w, C]), I = R[0], D = R[1], M = i(p, I, D);
      return s(function() {
        A.hasValue = !0, A.value = M;
      }, [M]), u(M), M;
    }
    hI.useSyncExternalStoreWithSelector = f, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), hI;
}
ct.env.NODE_ENV === "production" ? vNe() : gNe();
const jJ = (e, t) => {
  t(e);
  const n = e.getSnapshot().children;
  n && Object.values(n).forEach((r) => {
    jJ(r, t);
  });
};
function bNe(e) {
  var r, i;
  const t = [];
  jJ(e, (o) => {
    t.push([o, o.getSnapshot()]), o.observers = /* @__PURE__ */ new Set();
  });
  const n = (i = (r = e.system).getSnapshot) == null ? void 0 : i.call(r);
  e.stop(), e.system._snapshot = n, t.forEach(([o, s]) => {
    o._processingStatus = 0, o._snapshot = s;
  });
}
function wNe(e, ...[t]) {
  let [[n, r], i] = k.useState(() => {
    const o = Ab(e, t);
    return [e.config, o];
  });
  if (e.config !== n) {
    const o = Ab(e, {
      ...t,
      snapshot: r.getPersistedSnapshot({
        __unsafeAllowInlineActors: !0
      })
    });
    i([e.config, o]), r = o;
  }
  return lPe(() => {
    r.logic.implementations = e.implementations;
  }), r;
}
function CNe(e, ...[t]) {
  const n = wNe(e, t), r = k.useCallback(() => n.getSnapshot(), [n]), i = k.useCallback((s) => {
    const {
      unsubscribe: c
    } = n.subscribe(s);
    return c;
  }, [n]), o = XN.useSyncExternalStore(i, r, r);
  return k.useEffect(() => (n.start(), () => {
    bNe(n);
  }), [n]), [o, n.send, n];
}
function FJ(e, ...[t]) {
  return CNe(e, t);
}
const xNe = ({ onDone: e }) => {
  const t = Bi(), n = Fue(), r = Eb(), i = ss(
    Eb(),
    (y) => y.context.data
  ).unsafeCoerce(), { network: o, address: s, additionalAddresses: c, signMessage: u } = fr(), f = sde(), p = Pr({
    onDone: e,
    trackEvent: t,
    exitStore: r,
    actionExit: n,
    signMessage: u,
    transactionGetTransactionVerificationMessageForNetwork: f,
    getData: () => he.fromRecord({
      network: he.fromNullable(o),
      address: he.fromNullable(s)
    }).map((y) => ({ ...y, ...i, additionalAddresses: c }))
  });
  return FJ(k.useState(() => ENe(p))[0]);
}, ENe = (e) => LJ({
  types: {
    context: {},
    events: {}
  }
}).createMachine({
  context: {
    error: he.empty(),
    transactionVerificationMessageDto: he.empty(),
    signedMessage: he.empty(),
    data: he.empty()
  },
  on: { UNSTAKE: { target: ".check", reenter: !0 } },
  initial: "initial",
  states: {
    initial: {},
    check: {
      on: {
        __GET_VERIFICATION_MESSAGE__: {
          target: "getVerificationMessage",
          actions: Ra({ data: ({ event: t }) => he.of(t.val) })
        },
        __SUBMIT__: {
          target: "submit",
          actions: Ra({ data: ({ event: t }) => he.of(t.val) })
        },
        __RESET__: "initial"
      },
      entry: ({ self: t }) => e.current.getData().caseOf({
        Just: (n) => {
          var r, i, o;
          e.current.trackEvent("unstakeClicked", {
            yieldId: n.integrationData.id,
            amount: n.requestDto.args.amount
          }), (o = (i = (r = n.integrationData.args.exit) == null ? void 0 : r.args) == null ? void 0 : i.signatureVerification) != null && o.required ? t.send({ type: "__GET_VERIFICATION_MESSAGE__", val: n }) : t.send({ type: "__SUBMIT__", val: n });
        },
        Nothing: () => t.send({ type: "__RESET__" })
      })
    },
    getVerificationMessage: {
      on: {
        __GET_VERIFICATION_MESSAGE_SUCCESS__: {
          target: "showPopup",
          actions: Ra(({ context: t, event: n }) => ({
            ...t,
            transactionVerificationMessageDto: he.of(n.val)
          }))
        },
        __GET_VERIFICATION_MESSAGE_ERROR__: {
          target: ".error",
          actions: Ra(({ context: t, event: n }) => ({
            ...t,
            error: he.of(n.val)
          }))
        }
      },
      initial: "loading",
      states: {
        loading: {
          entry: ({ self: t, context: n }) => Ye.liftEither(
            n.data.toEither(new Error("Missing init values"))
          ).chain(
            (r) => Ia({
              fn: () => e.current.transactionGetTransactionVerificationMessageForNetwork(
                r.network,
                {
                  addresses: {
                    address: r.address,
                    additionalAddresses: r.additionalAddresses ?? void 0
                  }
                }
              )
            }).mapLeft(
              () => new Error("Failed to get verification message")
            )
          ).caseOf({
            Right(r) {
              t.send({
                type: "__GET_VERIFICATION_MESSAGE_SUCCESS__",
                val: r
              });
            },
            Left(r) {
              t.send({
                type: "__GET_VERIFICATION_MESSAGE_ERROR__",
                val: r
              });
            }
          })
        },
        error: {}
      }
    },
    showPopup: {
      on: {
        CONTINUE_MESSAGE_SIGN: "signMessage",
        CANCEL_MESSAGE_SIGN: "initial"
      }
    },
    signMessage: {
      on: {
        __SIGN_MESSAGE_SUCCESS__: {
          target: "submit",
          actions: Ra(({ context: t, event: n }) => ({
            ...t,
            signedMessage: he.of(n.val)
          }))
        },
        __SIGN_MESSAGE_ERROR__: {
          target: ".error",
          actions: Ra(({ context: t, event: n }) => ({
            ...t,
            error: he.of(n.val)
          }))
        }
      },
      initial: "loading",
      states: {
        loading: {
          entry: ({ self: t, context: n }) => Ye.liftEither(
            n.transactionVerificationMessageDto.toEither(
              new Error("Missing transaction verification message")
            )
          ).chain((r) => e.current.signMessage(r.message)).caseOf({
            Right(r) {
              t.send({
                type: "__SIGN_MESSAGE_SUCCESS__",
                val: r
              });
            },
            Left(r) {
              t.send({ type: "__SIGN_MESSAGE_ERROR__", val: r });
            }
          })
        },
        error: {}
      }
    },
    submit: {
      on: {
        __SUBMIT_SUCCESS__: "done",
        __SUBMIT_ERROR__: ".error"
      },
      initial: "loading",
      states: {
        loading: {
          entry: ({
            self: t,
            context: {
              data: n,
              signedMessage: r,
              transactionVerificationMessageDto: i
            }
          }) => Ye.liftEither(
            n.map((o) => o.requestDto).map(
              (o) => he.fromRecord({
                transactionVerificationMessageDto: i,
                signedMessage: r
              }).map(
                (s) => ({
                  ...o,
                  args: {
                    ...o.args,
                    signatureVerification: {
                      message: s.transactionVerificationMessageDto.message,
                      signed: s.signedMessage
                    }
                  }
                })
              ).orDefault(o)
            ).toEither(new Error("Missing params"))
          ).chain(
            (o) => Ia({
              fn: () => e.current.actionExit(o)
            }).mapLeft(() => new Error("Stake exit error")).chain(
              (s) => Ye.liftEither(vP(s))
            ).ifRight(
              (s) => e.current.exitStore.send({
                type: "setActionDto",
                data: s
              })
            )
          ).caseOf({
            Right() {
              t.send({ type: "__SUBMIT_SUCCESS__" });
            },
            Left(o) {
              Ra(({ context: s }) => ({ ...s, error: o })), t.send({ type: "__SUBMIT_ERROR__" });
            }
          })
        },
        error: {}
      }
    },
    done: {
      type: "final",
      entry: e.current.onDone
    }
  }
}), SNe = () => {
  const e = ss(
    Eb(),
    (Y) => Y.context.data
  ).unsafeCoerce(), t = e.requestDto.integrationId, n = Kue(
    e.requestDto,
    { query: { staleTime: 0, gcTime: 0 } }
  ), r = cM(t), i = k.useMemo(
    () => {
      var Y;
      return he.fromNullable((Y = n.data) == null ? void 0 : Y.amount).map(Nt);
    },
    [n.data]
  ), o = k.useMemo(
    () => he.of(e.unstakeToken),
    [e.unstakeToken]
  ), s = k.useMemo(
    () => he.of(e.integrationData),
    [e.integrationData]
  ), c = fA({
    token: o,
    yieldDto: s
  }), u = k.useMemo(
    () => new Nt(e.requestDto.args.amount ?? 0),
    [e.requestDto.args.amount]
  ), { depositFee: f, managementFee: p, performanceFee: y } = FN({
    amount: u,
    token: o,
    feeConfigDto: k.useMemo(
      () => he.fromNullable(r.data),
      [r.data]
    ),
    prices: k.useMemo(
      () => he.fromNullable(c.data),
      [c.data]
    )
  }), v = LN({
    gasAmount: i,
    gasFeeToken: e.gasFeeToken,
    address: e.requestDto.addresses.address,
    additionalAddresses: e.requestDto.addresses.additionalAddresses,
    isStake: !1
  }), { t: w } = ln(), C = k.useMemo(() => To(u), [u]), x = s.map((Y) => {
    switch (Y.metadata.type) {
      case "staking":
      case "liquid-staking":
        return w("position_details.unstake");
      default:
        return w("position_details.withdraw");
    }
  }), A = La(), R = k.useMemo(
    () => kP({
      gas: i,
      prices: he.fromNullable(c.data),
      yieldDto: s
    }),
    [s, c.data, i]
  ), I = s.chainNullable(
    (Y) => Y.metadata.provider ? { provider: Y.metadata.provider, rest: Y } : null
  ).map((Y) => ({ type: "unstake", rewardToken: he.of({
    logoUri: Y.provider.logoURI,
    providerName: Y.provider.name,
    symbols: jN([Y.rest.token]),
    rewardTokens: [Y.rest.token]
  }) })), D = k.useMemo(() => ({ showMetaInfo: !1 }), []), [M, L] = xNe({
    onDone: () => A("../steps", { relative: "path" })
  }), j = M.matches("check") || M.matches({ getVerificationMessage: "loading" }) || M.matches({ signMessage: "loading" }) || M.matches({ submit: "loading" }), F = M.matches("showPopup"), O = () => L({ type: "CONTINUE_MESSAGE_SIGN" }), z = () => L({ type: "CANCEL_MESSAGE_SIGN" }), Q = Pr(() => {
    j || L({ type: "UNSTAKE" });
  });
  return py(
    k.useMemo(
      () => ({
        label: w("shared.confirm"),
        onClick: () => Q.current(),
        disabled: !1,
        isLoading: j
      }),
      [Q, w, j]
    )
  ), {
    integrationData: s,
    title: x,
    amount: C,
    fee: R,
    rewardTokenDetailsProps: I,
    token: o,
    metaInfo: D,
    onContinueUnstakeSignMessage: O,
    onCloseUnstakeSignMessage: z,
    showUnstakeSignMessagePopup: F,
    gasCheckLoading: n.isLoading || v.isLoading,
    isGasCheckWarning: !!v.data,
    depositFee: f,
    managementFee: p,
    performanceFee: y,
    feeConfigLoading: r.isPending
  };
}, kNe = () => {
  const {
    amount: e,
    fee: t,
    integrationData: n,
    rewardTokenDetailsProps: r,
    title: i,
    token: o,
    metaInfo: s,
    onContinueUnstakeSignMessage: c,
    onCloseUnstakeSignMessage: u,
    showUnstakeSignMessagePopup: f,
    gasCheckLoading: p,
    isGasCheckWarning: y,
    depositFee: v,
    managementFee: w,
    performanceFee: C,
    feeConfigLoading: x
  } = SNe();
  sa("unstakeReview");
  const A = k.useMemo(
    () => o.map((R) => `${e} ${R.symbol}`).extractNullable(),
    [e, o]
  );
  return /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
    /* @__PURE__ */ S.jsx(
      UN,
      {
        rewardTokenDetailsProps: r,
        title: i.orDefault(""),
        fee: t,
        depositFee: v,
        managementFee: w,
        performanceFee: C,
        feeConfigLoading: x,
        info: A,
        metadata: n.map((R) => R.metadata),
        token: o,
        isGasCheckError: y,
        loading: p,
        ...s
      }
    ),
    /* @__PURE__ */ S.jsx(
      sPe,
      {
        isOpen: f,
        onClick: c,
        onCancel: u
      }
    )
  ] });
}, UJ = () => {
  const {
    additionalAddresses: e,
    address: t,
    network: n,
    isLedgerLiveAccountPlaceholder: r
  } = fr(), i = k.useMemo(
    () => he.fromRecord({
      additionalAddresses: _n(e ?? void 0),
      address: he.fromNullable(t),
      network: he.fromNullable(n)
    }).mapOrDefault(
      (s) => ({
        enabled: !r,
        dto: {
          addresses: {
            address: s.address,
            additionalAddresses: s.additionalAddresses
          },
          network: s.network
        }
      }),
      {
        enabled: !1,
        dto: {
          addresses: { address: "", additionalAddresses: void 0 },
          network: "ethereum"
        }
      }
    ),
    [e, t, r, n]
  ), o = aM();
  return Qr({
    queryKey: sM(i.dto),
    enabled: i.enabled,
    refetchInterval: 1e3 * 60,
    queryFn: async () => (await zJ({
      tokenBalanceScanDto: i.dto,
      tokenTokenBalancesScan: o
    })).unsafeCoerce()
  });
}, ANe = (e) => Ye(
  () => e.queryClient.fetchQuery({
    queryKey: sM(e.tokenBalanceScanDto),
    queryFn: async () => (await zJ(e)).unsafeCoerce()
  })
).mapLeft((t) => new Error("could not get multi yields")), zJ = ({
  tokenBalanceScanDto: e,
  tokenTokenBalancesScan: t
}) => Ye(() => t(e)).mapLeft(
  (n) => new Error("could not get token balances")
), TNe = () => {
  const e = tc();
  return k.useCallback(
    () => e.invalidateQueries({
      queryKey: [
        sM({})[0]
      ]
    }),
    [e]
  );
}, pI = ({
  network: e,
  transactionGetGasForNetwork: t
}) => Ia({ fn: () => t(e) }).mapLeft(() => new Error("Get gas for network error")).chain(
  (n) => Ye.liftEither(
    Wn.find((r) => r.name === "average", n.modes.values).toEither(
      new Error("Average gas mode not found")
    )
  )
), _Ne = ({
  transactions: e,
  integrationId: t
}) => {
  const {
    signTransaction: n,
    signMultipleTransactions: r,
    signMessage: i,
    connector: o,
    isLedgerLive: s
  } = fr(), c = Bi(), u = rde(), f = ode(), p = tde(), y = ide(), v = ade(), w = nde(), C = k.useMemo(
    () => he.fromNullable(o).map(Uke).orDefault(!1),
    [o]
  ), x = k.useMemo(
    () => e.sort((R, I) => R.stepIndex - I.stepIndex),
    [e]
  ), A = Pr({
    transactions: x,
    integrationId: t,
    multiSend: C,
    isLedgerLive: s,
    trackEvent: c,
    signMultipleTransactions: r,
    signMessage: i,
    signTransaction: n,
    transactionSubmit: u,
    transactionGetTransactionStatusFromId: f,
    transactionGetTransaction: p,
    transactionSubmitHash: y,
    transactionGetGasForNetwork: v,
    transactionConstruct: w
  });
  return FJ(k.useState(() => RNe(A))[0]);
}, RNe = (e) => {
  const t = (...r) => Ia({
    fn: () => e.current.transactionConstruct(...r),
    shouldRetry: (i, o) => {
      var s;
      return o <= 3 && Qd(i) && ((s = i.response) == null ? void 0 : s.status) === 404;
    }
  }).mapLeft(() => new Error("Transaction construct error")), n = ONe(
    e.current.transactions,
    e.current.integrationId,
    e.current.multiSend
  );
  return LJ({
    types: {
      emitted: {},
      context: {},
      events: {}
    }
  }).createMachine({
    context: {
      yieldId: he.fromNullable(n == null ? void 0 : n.yieldId),
      txStates: (n == null ? void 0 : n.txStates) ?? [],
      currentTxMeta: he.fromNullable(n == null ? void 0 : n.currentTxMeta),
      txCheckTimeoutId: he.empty()
    },
    initial: n.enabled ? "idle" : "disabled",
    states: {
      idle: {
        on: { START: "signLoading" }
      },
      disabled: {},
      signLoading: {
        on: {
          __SIGN_SUCCESS__: {
            target: "broadcastLoading",
            actions: [
              Ra({
                txStates: ({ context: r, event: i }) => r.currentTxMeta.map(
                  (o) => r.txStates.map(
                    (s, c) => c === o.idx ? {
                      ...s,
                      meta: {
                        ...s.meta,
                        txCheckError: null,
                        signError: null,
                        broadcasted: i.val.data.broadcasted,
                        signedTx: i.val.data.signedTx
                      }
                    } : s
                  )
                ).orDefault(r.txStates)
              }),
              dNe({ type: "signSuccess" })
            ]
          },
          __SIGN_ERROR__: {
            target: "signError",
            actions: Ra({
              txStates: ({ context: r, event: i }) => r.currentTxMeta.map(
                (o) => r.txStates.map(
                  (s, c) => c === o.idx ? {
                    ...s,
                    meta: {
                      ...s.meta,
                      txCheckError: null,
                      signError: i.val
                    }
                  } : s
                )
              ).orDefault(r.txStates)
            })
          },
          __BROADCAST_SUCCESS__: "txCheckLoading"
        },
        entry: ({ context: r, self: i }) => {
          Ye.liftEither(
            r.currentTxMeta.chainNullable((o) => r.txStates[o.idx].tx).toEither(new Error("missing tx"))
          ).chain((o) => {
            const s = e.current.transactions;
            return e.current.multiSend ? Ye.liftEither(
              Pt(
                s.find(
                  (c) => ZG.has(c.type)
                )
              )
            ).chain((c) => c ? pI({
              network: c.network,
              transactionGetGasForNetwork: e.current.transactionGetGasForNetwork
            }).chainLeft(async () => Pt(null)).chain(
              (u) => t(c.id, {
                gasArgs: u == null ? void 0 : u.gasArgs,
                ledgerWalletAPICompatible: e.current.isLedgerLive
              }).mapLeft(() => new u1())
            ).chain(
              () => Ia({
                fn: () => e.current.transactionGetTransactionStatusFromId(
                  c.id
                ),
                retryTimes: 10,
                retryWaitForMs: () => 5e3
              }).mapLeft(
                () => new Error(
                  `failed to get ${c.id} tx status`
                )
              )
            ) : Ye.liftEither(Pt(null))).map(() => aSe(s)).chain(
              (c) => pI({
                network: o.network,
                transactionGetGasForNetwork: e.current.transactionGetGasForNetwork
              }).chain(
                (u) => Ye.sequence(
                  c.map(
                    (f) => t(f.id, {
                      gasArgs: u == null ? void 0 : u.gasArgs,
                      ledgerWalletAPICompatible: e.current.isLedgerLive
                    }).mapLeft(() => new u1())
                  )
                )
              )
            ).map(
              (c) => c.map((u) => u.unsignedTransaction).filter((u) => u !== null)
            ).chain((c) => c.length ? e.current.signMultipleTransactions({ txs: c }) : Ye.liftEither(
              Rn(new u1())
            )).map((c) => ({ type: "regular", data: c })) : pI({
              network: o.network,
              transactionGetGasForNetwork: e.current.transactionGetGasForNetwork
            }).chainLeft(async () => Pt(null)).chain(
              (c) => t(o.id, {
                gasArgs: c == null ? void 0 : c.gasArgs,
                ledgerWalletAPICompatible: e.current.isLedgerLive
              }).mapLeft(() => new u1())
            ).chain((c) => c.status === "BROADCASTED" || c.status === "CONFIRMED" ? Ye.liftEither(
              Pt({ type: "broadcasted" })
            ) : c.unsignedTransaction ? c.isMessage ? e.current.signMessage(c.unsignedTransaction).map((u) => ({
              type: "regular",
              data: { signedTx: u, broadcasted: !1 }
            })) : e.current.signTransaction({
              tx: c.unsignedTransaction,
              ledgerHwAppId: c.ledgerHwAppId
            }).map((u) => ({
              ...u,
              network: c.network,
              txId: c.id
            })).ifRight(
              () => e.current.trackEvent("txSigned", {
                txId: c.id,
                network: c.network,
                yieldId: r.yieldId
              })
            ).map((u) => ({ type: "regular", data: u })) : Ye.liftEither(
              Rn(new u1())
            ));
          }).caseOf({
            Left: (o) => {
              i.send({ type: "__SIGN_ERROR__", val: o });
            },
            Right: (o) => {
              if (o.type === "broadcasted")
                return i.send({ type: "__BROADCAST_SUCCESS__" });
              i.send({ type: "__SIGN_SUCCESS__", val: o });
            }
          });
        }
      },
      signError: {
        on: { __SIGN_RETRY__: "signLoading" }
      },
      broadcastLoading: {
        on: {
          __BROADCAST_SUCCESS__: {
            target: "txCheckLoading",
            actions: Ra({
              txStates: ({ context: r }) => r.currentTxMeta.map(
                (i) => r.txStates.map(
                  (o, s) => s === i.idx ? {
                    ...o,
                    meta: {
                      ...o.meta,
                      txCheckError: null,
                      signError: null
                    }
                  } : o
                )
              ).orDefault(r.txStates)
            })
          },
          __BROADCAST_ERROR__: {
            target: "broadcastError",
            actions: Ra({
              txStates: ({ context: r }) => r.currentTxMeta.map(
                (i) => r.txStates.map(
                  (o, s) => s === i.idx ? {
                    ...o,
                    meta: {
                      ...o.meta,
                      txCheckError: null,
                      signError: null
                    }
                  } : o
                )
              ).orDefault(r.txStates)
            })
          }
        },
        entry: ({ self: r, context: i }) => {
          Ye.liftEither(
            i.currentTxMeta.chainNullable((o) => i.txStates[o.idx]).toEither(new Error("missing tx"))
          ).chain((o) => o.meta.broadcasted ? Ia({
            fn: () => e.current.transactionSubmitHash(o.tx.id, {
              hash: o.meta.signedTx
            })
          }).mapLeft(() => new _ke()).ifRight(() => {
            e.current.trackEvent("txSubmitted", {
              txId: o.tx.id,
              network: o.tx.network,
              yieldId: i.yieldId
            });
          }) : Ia({
            fn: async () => {
              await e.current.transactionSubmit(o.tx.id, {
                signedTransaction: o.meta.signedTx
              });
            }
          }).mapLeft(() => new Rke()).ifRight(() => {
            e.current.trackEvent("txSubmitted", {
              txId: o.tx.id,
              network: o.tx.network,
              yieldId: i.yieldId
            });
          })).caseOf({
            Left: (o) => {
              r.send({ type: "__BROADCAST_ERROR__", val: o });
            },
            Right: () => r.send({ type: "__BROADCAST_SUCCESS__" })
          });
        }
      },
      broadcastError: {
        on: { __BROADCAST_RETRY__: "broadcastLoading" }
      },
      txCheckLoading: {
        on: {
          __SIGN_NEXT_TX__: {
            target: "signLoading",
            actions: Ra({
              currentTxMeta: ({ event: r }) => he.of(r.val.newCurrentTxMeta),
              txStates: ({ event: r }) => r.val.newTxStates
            })
          },
          __DONE__: {
            target: "done",
            actions: Ra({ txStates: ({ event: r }) => r.val })
          },
          __TX_CHECK_ERROR__: {
            target: "txCheckError",
            actions: Ra({
              txStates: ({ context: r, event: i }) => r.currentTxMeta.map(
                (o) => r.txStates.map(
                  (s, c) => c === o.idx ? {
                    ...s,
                    meta: {
                      ...s.meta,
                      txCheckError: i.val,
                      signError: null
                    }
                  } : s
                )
              ).orDefault(r.txStates)
            })
          },
          __TX_CHECK_RETRY__: "txCheckRetry"
        },
        entry: ({ self: r, context: i }) => {
          Ye.liftEither(
            i.currentTxMeta.chainNullable((o) => i.txStates[o.idx]).toEither(new Error("missing tx"))
          ).chain(
            (o) => Ia({
              fn: () => e.current.transactionGetTransactionStatusFromId(
                o.tx.id
              ),
              shouldRetry: (s, c) => {
                var u, f;
                return c <= 3 && Qd(s) && (((u = s.response) == null ? void 0 : u.status) === 404 || ((f = s.response) == null ? void 0 : f.status) === 503);
              }
            }).map((s) => ({ url: s.url, status: s.status })).chainLeft(
              () => Ia({
                fn: () => e.current.transactionGetTransaction(o.tx.id)
              }).map((s) => ({
                url: s.explorerUrl,
                status: s.status
              }))
            ).mapLeft(() => new Tke()).chain(
              (s) => Ye.liftEither(
                JG(s.status) ? Rn(
                  new WU({
                    txId: o.tx.id,
                    network: o.tx.network
                  })
                ) : Pt({
                  url: s.url,
                  isConfirmed: s.status === "CONFIRMED"
                })
              )
            )
          ).caseOf({
            Left: (o) => {
              o instanceof WU && e.current.trackEvent("txNotConfirmed", {
                txId: o.txId,
                yieldId: i.yieldId
              }), r.send({ type: "__TX_CHECK_ERROR__", val: o });
            },
            Right: (o) => {
              if (o.isConfirmed) {
                const s = i.currentTxMeta.map(
                  (u) => i.txStates.map(
                    (f, p) => p === u.idx ? {
                      ...f,
                      meta: {
                        ...f.meta,
                        signError: null,
                        txCheckError: null,
                        url: o.url,
                        done: !0
                      }
                    } : f
                  )
                ).orDefault(i.txStates), c = Wn.findIndex(
                  (u) => !u.meta.done,
                  s
                ).map((u) => ({
                  idx: u,
                  id: s[u].tx.id
                })).extractNullable();
                if (!c)
                  return r.send({ type: "__DONE__", val: s });
                r.send({
                  type: "__SIGN_NEXT_TX__",
                  val: { newTxStates: s, newCurrentTxMeta: c }
                });
              } else
                r.send({ type: "__TX_CHECK_RETRY__" });
            }
          });
        }
      },
      txCheckRetry: {
        on: {
          __TX_CHECK_RETRY__: "txCheckLoading",
          __TX_CHECK_RETRY_TIMEOUT__: {
            actions: Ra({
              txCheckTimeoutId: ({ event: r }) => he.of(r.val)
            })
          }
        },
        entry: ({ self: r }) => {
          const i = setTimeout(() => {
            r.send({ type: "__TX_CHECK_RETRY__" });
          }, 4e3);
          r.send({
            type: "__TX_CHECK_RETRY_TIMEOUT__",
            val: i
          });
        }
      },
      txCheckError: {
        on: { __TX_CHECK_RETRY__: "txCheckLoading" }
      },
      done: {
        type: "final"
      }
    }
  });
}, ONe = (e, t, n) => {
  if (!e.length)
    return {
      enabled: !1,
      txStates: null,
      currentTxMeta: null,
      yieldId: null
    };
  const r = e.map((s) => ({
    tx: s,
    meta: {
      broadcasted: null,
      signedTx: null,
      url: null,
      signError: null,
      txCheckError: null,
      done: !1
    }
  })), i = 0, o = {
    idx: i,
    id: e[i].id
  };
  return {
    enabled: !0,
    txStates: n ? [r[i]] : r,
    currentTxMeta: o,
    yieldId: t
  };
}, INe = ({
  session: e,
  onSignSuccess: t
}) => {
  const n = La(), r = Pr({ onSignSuccess: t }), [i, o, s] = _Ne({
    transactions: e.transactions,
    integrationId: e.integrationId
  });
  k.useLayoutEffect(() => {
    o({ type: "START" });
  }, [o]), k.useEffect(() => {
    const x = s.on(
      "signSuccess",
      () => {
        var A, R;
        return (R = (A = r.current).onSignSuccess) == null ? void 0 : R.call(A);
      }
    );
    return () => {
      x.unsubscribe();
    };
  }, [s, r]), k.useEffect(() => () => {
    i.context.txCheckTimeoutId.ifJust((x) => clearTimeout(x));
  }, [i.context.txCheckTimeoutId]);
  const c = d5e(), u = TNe(), f = l5e();
  k.useEffect(() => {
    i.status === "done" && (c(), u(), f(), n("../complete", {
      state: {
        urls: i.context.txStates.map((x) => ({ type: x.tx.type, url: x.meta.url })).filter(
          (x) => !!x.url
        )
      },
      relative: "path",
      replace: !0
    }));
  }, [
    c,
    u,
    f,
    n,
    i.context.txStates,
    i.status
  ]);
  const p = () => n(-1), y = (() => {
    if (i.matches("signError"))
      return () => o({ type: "__SIGN_RETRY__" });
    if (i.matches("broadcastError"))
      return () => o({ type: "__BROADCAST_RETRY__" });
    if (i.matches("txCheckError"))
      return () => o({ type: "__TX_CHECK_RETRY__" });
  })(), v = k.useMemo(
    () => i.context.txStates.map((x) => ({
      ...x,
      state: DNe({
        txState: x,
        machineState: i.value,
        currentTxId: i.context.currentTxMeta.map((A) => A.id).extractNullable()
      })
    })),
    [
      i.context.currentTxMeta,
      i.context.txStates,
      i.value
    ]
  ), { t: w } = ln(), C = Pr(p);
  return py(
    k.useMemo(
      () => v.length ? {
        disabled: !1,
        isLoading: !1,
        label: w("shared.cancel"),
        onClick: () => C.current(),
        variant: "secondary"
      } : null,
      [v.length, w, C]
    )
  ), {
    retry: y,
    txStates: v
  };
};
var zn = /* @__PURE__ */ ((e) => (e[e.SIGN_IDLE = 0] = "SIGN_IDLE", e[e.SIGN_ERROR = 1] = "SIGN_ERROR", e[e.SIGN_LOADING = 2] = "SIGN_LOADING", e[e.SIGN_SUCCESS = 3] = "SIGN_SUCCESS", e[e.BROADCAST_IDLE = 4] = "BROADCAST_IDLE", e[e.BROADCAST_ERROR = 5] = "BROADCAST_ERROR", e[e.BROADCAST_LOADING = 6] = "BROADCAST_LOADING", e[e.BROADCAST_SUCCESS = 7] = "BROADCAST_SUCCESS", e[e.CHECK_TX_STATUS_IDLE = 8] = "CHECK_TX_STATUS_IDLE", e[e.CHECK_TX_STATUS_ERROR = 9] = "CHECK_TX_STATUS_ERROR", e[e.CHECK_TX_STATUS_LOADING = 10] = "CHECK_TX_STATUS_LOADING", e[e.CHECK_TX_STATUS_SUCCESS = 11] = "CHECK_TX_STATUS_SUCCESS", e))(zn || {});
const DNe = ({
  currentTxId: e,
  machineState: t,
  txState: n
}) => {
  const r = e === null ? !1 : e === n.tx.id;
  return (() => {
    if (n.meta.done) return 11;
    if (!r) return 0;
    switch (t) {
      case "idle":
      case "signLoading":
        return 2;
      case "signError":
        return 1;
      case "broadcastLoading":
        return 6;
      case "broadcastError":
        return 5;
      case "txCheckError":
        return 9;
      case "txCheckRetry":
      case "txCheckLoading":
        return 10;
      case "done":
        return 11;
      case "disabled":
        return 0;
    }
  })();
}, MNe = () => {
  var n;
  const e = pC(), t = mX(
    "sk-widget@1//referralCode"
  );
  return k.useEffect(() => {
    var r;
    (r = e.data) != null && r.referralCode && G4(
      "sk-widget@1//referralCode",
      e.data.referralCode
    );
  }, [(n = e.data) == null ? void 0 : n.referralCode]), pC({
    select: (r) => r.referralCode ?? t
  });
}, VJ = ["referral-code"], XA = () => {
  const e = MNe(), { referralCheck: t } = dr(), n = _8();
  return Qr({
    queryKey: VJ,
    enabled: !e.isPending && !!t,
    staleTime: Number.POSITIVE_INFINITY,
    queryFn: async () => (await Ye.liftEither(
      he.fromNullable(e.data).toEither(
        new Error("missing referral code")
      )
    ).chain((r) => $J({ referralCode: r, apiClient: n }))).unsafeCoerce()
  });
}, PNe = () => {
  const e = tc(), t = _8();
  return ec({
    mutationFn: async (n) => (await $J({ referralCode: n, apiClient: t })).unsafeCoerce(),
    onSuccess: (n) => {
      G4("sk-widget@1//referralCode", n.code), e.setQueryData(VJ, n);
    }
  });
}, $J = ({
  apiClient: e,
  referralCode: t
}) => Ye(
  () => e.get(`/v1/referrals/${t}`)
).map((n) => n.data).mapLeft((n) => Qd(n) ? n : new Error("unknown error")), [HJ, NNe] = mx(!1), BNe = ({ children: e }) => {
  var C;
  const t = cX(), [n] = _Q(), [r] = bN(), [i] = wX(), { state: o, dispatch: s } = ff(), { referralCheck: c, disableInitLayoutAnimation: u } = dr(), f = XA(), p = !c || !!f.data, y = (C = t.state) != null && C.height && n ? t.state.height + n + r + i : 0, [v] = HJ(), w = _n(y).chain(
    (x) => _n(null).map(() => v ? { duration: 0 } : o.layout ? { duration: 0.3 } : u ? { duration: 0 } : { duration: 0.6, delay: 0.3 }).map((A) => ({ height: x, transition: A }))
  ).unsafeCoerce();
  return /* @__PURE__ */ S.jsx(S.Fragment, { children: p ? /* @__PURE__ */ S.jsx(
    gi.div,
    {
      "data-rk": "widget-container",
      layout: "size",
      className: xX,
      initial: { height: 0 },
      animate: w,
      onAnimationComplete: (x) => {
        !x.height || o.layout || s({ type: "layout" });
      },
      children: e
    }
  ) : f.isLoading ? /* @__PURE__ */ S.jsx(ae, { display: "flex", justifyContent: "center", alignItems: "center", children: /* @__PURE__ */ S.jsx(Wl, {}) }) : null });
};
var LNe = "xx8dwz0", jNe = "xx8dwz1", FNe = "xx8dwz2";
const qJ = k.createContext(void 0), JN = () => {
  const e = k.useContext(qJ);
  if (!e)
    throw new Error("useCollapsible must be used within a CollapsibleRoot");
  return e;
}, WJ = ({ children: e, ...t }) => {
  const n = k.useState(!0), r = k.useMemo(
    () => t.onClick ? {
      collapsed: t.collapsed,
      onClick: t.onClick
    } : {
      collapsed: n[0],
      onClick: () => n[1]((i) => !i)
    },
    [t.onClick, t.collapsed, n]
  );
  return /* @__PURE__ */ S.jsx(qJ.Provider, { value: r, children: e });
}, GJ = ({
  children: e,
  ...t
}) => {
  const { onClick: n } = JN();
  return /* @__PURE__ */ S.jsx(
    ae,
    {
      display: "flex",
      onClick: n,
      justifyContent: "space-between",
      alignItems: "center",
      className: LNe,
      ...t,
      children: e
    }
  );
}, KJ = () => {
  const { collapsed: e } = JN();
  return /* @__PURE__ */ S.jsx(
    ae,
    {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      className: zs([jNe, { [FNe]: !e }]),
      children: /* @__PURE__ */ S.jsx(fy, { size: 20 })
    }
  );
}, YJ = ({ children: e }) => {
  const { collapsed: t } = JN(), n = pK();
  return /* @__PURE__ */ S.jsx(_A, { children: !t && /* @__PURE__ */ S.jsx(UNe, { isFirstMount: n, children: e }) });
}, Yk = {
  open: { opacity: 1, height: "auto" },
  closed: { opacity: 0, height: 0 }
}, UNe = ({
  isFirstMount: e,
  children: t
}) => {
  const [n, r] = AY(), [i, o] = K2e(), [, s] = HJ();
  return k.useEffect(() => {
    n ? (async () => (s(!0), await o(i.current, Yk.open), s(!1)))() : (async () => (s(!0), await o(i.current, Yk.closed), s(!1), r()))();
  }, [o, n, r, i, s]), /* @__PURE__ */ S.jsx(
    gi.div,
    {
      ref: i,
      initial: e ? Yk.open : Yk.closed,
      style: { overflow: "hidden" },
      transition: { duration: 0.3 },
      children: t
    }
  );
}, _1 = (e) => /* @__PURE__ */ S.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 448 512",
    fill: e.color ?? ti.color.background,
    height: e.hw ?? 24,
    width: e.hw ?? 24,
    children: /* @__PURE__ */ S.jsx("path", { d: "M438.6 105.4c12.5 12.5 12.5 32.8 0 45.3l-256 256c-12.5 12.5-32.8 12.5-45.3 0l-128-128c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0L160 338.7l233.4-233.3c12.5-12.5 32.8-12.5 45.3 0z" })
  }
);
var mI = "_1gejx700", yI = "_1gejx701 _1gejx700", vI = "_1gejx702", gI = "_1gejx703 _1gejx702", bI = "_1gejx704";
const zNe = ({ txState: e, position: t, count: n }) => {
  const { t: r } = ln(), i = e.meta.done && t !== "LAST" && t !== "SINGLE" || e.state === zn.SIGN_IDLE, [o, s] = k.useState(i);
  return k.useLayoutEffect(() => {
    s(i);
  }, [i]), /* @__PURE__ */ S.jsx(
    ae,
    {
      marginTop: t === "FIRST" || t === "SINGLE" ? "0" : "4",
      children: /* @__PURE__ */ S.jsxs(
        WJ,
        {
          onClick: () => i && s((c) => !c),
          collapsed: o,
          children: [
            /* @__PURE__ */ S.jsxs(
              GJ,
              {
                width: "full",
                marginBottom: "4",
                as: i ? "button" : "div",
                children: [
                  /* @__PURE__ */ S.jsx(Ge, { children: r("steps.tx_of", {
                    count: n.total,
                    current: n.current,
                    type: r(`steps.tx_type.${e.tx.type}`)
                  }) }),
                  i && !!n && /* @__PURE__ */ S.jsx(KJ, {})
                ]
              }
            ),
            /* @__PURE__ */ S.jsxs(YJ, { children: [
              /* @__PURE__ */ S.jsxs(
                ae,
                {
                  display: "flex",
                  opacity: e.state > zn.SIGN_IDLE ? 1 : 0.5,
                  children: [
                    /* @__PURE__ */ S.jsx(
                      ae,
                      {
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "center",
                        marginRight: "3",
                        className: zs({
                          [mI]: !0,
                          [bI]: e.state < zn.SIGN_SUCCESS,
                          [yI]: e.state > zn.SIGN_IDLE && e.state < zn.SIGN_SUCCESS
                        }),
                        children: /* @__PURE__ */ S.jsx(
                          ae,
                          {
                            background: e.state > zn.SIGN_IDLE ? "text" : "white",
                            borderColor: e.state > zn.SIGN_IDLE ? "text" : "textMuted",
                            borderRadius: "half",
                            hw: "10",
                            borderWidth: 3,
                            borderStyle: "solid",
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            "data-rk": "tx-state-step-circle",
                            "data-state": e.state > zn.SIGN_IDLE ? "success" : "pending",
                            children: e.state === zn.SIGN_LOADING ? /* @__PURE__ */ S.jsx(Wl, { variant: { color: "inverted" } }) : e.state === zn.SIGN_ERROR ? /* @__PURE__ */ S.jsx(Pg, { color: "background" }) : e.state >= zn.SIGN_SUCCESS ? /* @__PURE__ */ S.jsx(_1, { hw: 18 }) : null
                          }
                        )
                      }
                    ),
                    /* @__PURE__ */ S.jsxs(
                      ae,
                      {
                        flexDirection: "column",
                        display: "flex",
                        alignItems: "flex-start",
                        gap: "1",
                        children: [
                          /* @__PURE__ */ S.jsx(Ge, { children: r("steps.approve") }),
                          e.state === zn.SIGN_ERROR ? /* @__PURE__ */ S.jsx(Ge, { variant: { type: "danger" }, children: r("steps.approve_error") }) : /* @__PURE__ */ S.jsx(Ge, { variant: { type: "muted", weight: "normal" }, children: r("steps.approve_desc") })
                        ]
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ S.jsxs(
                ae,
                {
                  display: "flex",
                  alignItems: "center",
                  opacity: e.state >= zn.SIGN_SUCCESS ? 1 : 0.5,
                  children: [
                    /* @__PURE__ */ S.jsx(
                      ae,
                      {
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "center",
                        marginRight: "3",
                        className: zs({
                          [mI]: !0,
                          [vI]: !0,
                          [yI]: e.state < zn.BROADCAST_SUCCESS,
                          [bI]: e.state === zn.BROADCAST_LOADING || e.state === zn.BROADCAST_ERROR,
                          [gI]: e.state < zn.SIGN_SUCCESS
                        }),
                        children: /* @__PURE__ */ S.jsx(
                          ae,
                          {
                            background: e.state >= zn.SIGN_SUCCESS ? "text" : "white",
                            borderColor: e.state >= zn.SIGN_SUCCESS ? "text" : "textMuted",
                            borderRadius: "half",
                            borderWidth: 3,
                            borderStyle: "solid",
                            hw: "10",
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            "data-rk": "tx-state-step-circle",
                            "data-state": e.state >= zn.SIGN_SUCCESS ? "success" : "pending",
                            children: e.state === zn.BROADCAST_LOADING ? /* @__PURE__ */ S.jsx(Wl, { variant: { color: "inverted" } }) : e.state === zn.BROADCAST_ERROR ? /* @__PURE__ */ S.jsx(Pg, { color: "background" }) : e.state >= zn.BROADCAST_SUCCESS ? /* @__PURE__ */ S.jsx(_1, { hw: 18 }) : null
                          }
                        )
                      }
                    ),
                    /* @__PURE__ */ S.jsxs(
                      ae,
                      {
                        flexDirection: "column",
                        display: "flex",
                        alignItems: "flex-start",
                        gap: "1",
                        marginTop: "6",
                        children: [
                          /* @__PURE__ */ S.jsx(Ge, { children: r("steps.submitting") }),
                          e.state === zn.BROADCAST_ERROR && /* @__PURE__ */ S.jsx(Ge, { variant: { type: "danger" }, children: r("shared.something_went_wrong") })
                        ]
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ S.jsxs(
                ae,
                {
                  display: "flex",
                  alignItems: "center",
                  opacity: e.state >= zn.BROADCAST_SUCCESS ? 1 : 0.5,
                  children: [
                    /* @__PURE__ */ S.jsx(
                      ae,
                      {
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "center",
                        marginRight: "3",
                        className: zs({
                          [mI]: !0,
                          [vI]: !0,
                          [yI]: e.state < zn.CHECK_TX_STATUS_SUCCESS,
                          [bI]: e.state === zn.CHECK_TX_STATUS_LOADING || e.state === zn.CHECK_TX_STATUS_ERROR,
                          [gI]: e.state < zn.BROADCAST_SUCCESS
                        }),
                        children: /* @__PURE__ */ S.jsx(
                          ae,
                          {
                            background: e.state >= zn.BROADCAST_SUCCESS ? "text" : "white",
                            borderColor: e.state >= zn.BROADCAST_SUCCESS ? "text" : "textMuted",
                            borderRadius: "half",
                            borderWidth: 3,
                            borderStyle: "solid",
                            hw: "10",
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            "data-rk": "tx-state-step-circle",
                            "data-state": e.state >= zn.BROADCAST_SUCCESS ? "success" : "pending",
                            children: e.state === zn.CHECK_TX_STATUS_LOADING ? /* @__PURE__ */ S.jsx(Wl, { variant: { color: "inverted" } }) : e.state === zn.CHECK_TX_STATUS_ERROR ? /* @__PURE__ */ S.jsx(Pg, { color: "background" }) : e.state >= zn.CHECK_TX_STATUS_SUCCESS ? /* @__PURE__ */ S.jsx(_1, { hw: 18 }) : null
                          }
                        )
                      }
                    ),
                    /* @__PURE__ */ S.jsxs(
                      ae,
                      {
                        flexDirection: "column",
                        display: "flex",
                        alignItems: "flex-start",
                        gap: "1",
                        marginTop: "6",
                        children: [
                          /* @__PURE__ */ S.jsx(Ge, { children: r("steps.pending") }),
                          e.state === zn.CHECK_TX_STATUS_ERROR && /* @__PURE__ */ S.jsx(Ge, { variant: { type: "danger" }, children: r("shared.something_went_wrong") })
                        ]
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ S.jsxs(
                ae,
                {
                  display: "flex",
                  alignItems: "center",
                  opacity: e.state >= zn.CHECK_TX_STATUS_SUCCESS ? 1 : 0.5,
                  children: [
                    /* @__PURE__ */ S.jsx(
                      ae,
                      {
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "center",
                        marginRight: "3",
                        paddingBottom: "2",
                        className: zs({
                          [vI]: !0,
                          [gI]: e.state < zn.CHECK_TX_STATUS_SUCCESS
                        }),
                        children: /* @__PURE__ */ S.jsx(
                          ae,
                          {
                            background: e.state >= zn.CHECK_TX_STATUS_SUCCESS ? "text" : "white",
                            borderColor: e.state >= zn.CHECK_TX_STATUS_SUCCESS ? "text" : "textMuted",
                            borderWidth: 3,
                            borderStyle: "solid",
                            borderRadius: "half",
                            hw: "10",
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            "data-rk": "tx-state-step-circle",
                            "data-state": e.state >= zn.CHECK_TX_STATUS_SUCCESS ? "success" : "pending",
                            children: e.state >= zn.CHECK_TX_STATUS_SUCCESS && /* @__PURE__ */ S.jsx(_1, { hw: 18 })
                          }
                        )
                      }
                    ),
                    /* @__PURE__ */ S.jsx(
                      ae,
                      {
                        flexDirection: "column",
                        display: "flex",
                        alignItems: "flex-start",
                        gap: "1",
                        marginTop: "4",
                        children: /* @__PURE__ */ S.jsx(Ge, { children: r("steps.completed") })
                      }
                    )
                  ]
                }
              )
            ] })
          ]
        }
      )
    },
    e.tx.id
  );
}, JA = ({ session: e, onSignSuccess: t }) => {
  const { retry: n, txStates: r } = INe({
    session: e,
    onSignSuccess: t
  }), { t: i } = ln();
  return /* @__PURE__ */ S.jsx(yx, { children: /* @__PURE__ */ S.jsx(gi.div, { layout: "position", children: /* @__PURE__ */ S.jsxs(fp, { children: [
    /* @__PURE__ */ S.jsx(ae, { marginBottom: "2", children: /* @__PURE__ */ S.jsx($u, { variant: { level: "h4" }, children: i("steps.title") }) }),
    /* @__PURE__ */ S.jsx(ae, { flex: 1, display: "flex", children: /* @__PURE__ */ S.jsx(
      ae,
      {
        background: "backgroundMuted",
        flexDirection: "column",
        display: "flex",
        px: "4",
        py: "4",
        borderRadius: "xl",
        flex: 1,
        children: r.map((o, s) => /* @__PURE__ */ S.jsx(
          zNe,
          {
            txState: o,
            position: VNe(r.length, s),
            count: { current: s + 1, total: r.length }
          },
          s
        ))
      }
    ) }),
    n && /* @__PURE__ */ S.jsx(ae, { my: "4", children: /* @__PURE__ */ S.jsx(Jl, { "data-rk": "footer-button-primary", onClick: n, children: i("shared.retry") }) })
  ] }) }) });
}, VNe = (e, t) => e === 1 ? "SINGLE" : t === 0 ? "FIRST" : t === e - 1 ? "LAST" : "ELSE", $Ne = () => {
  sa("activitySteps");
  const e = ss(
    xb(),
    (t) => t.context.selectedAction
  ).unsafeCoerce();
  return /* @__PURE__ */ S.jsx(JA, { session: e });
}, HNe = () => {
  const e = ss(
    vx(),
    (t) => t.context.data
  ).unsafeCoerce();
  return sa("pendingActionSteps"), /* @__PURE__ */ S.jsx(JA, { session: e.actionDto.unsafeCoerce() });
}, qNe = () => {
  const e = ss(
    Eb(),
    (t) => t.context.data
  ).unsafeCoerce();
  return sa("unstakeSteps"), /* @__PURE__ */ S.jsx(JA, { session: e.actionDto.unsafeCoerce() });
};
var R1 = {}, y1 = Wu;
if (ct.env.NODE_ENV === "production")
  R1.createRoot = y1.createRoot, R1.hydrateRoot = y1.hydrateRoot;
else {
  var Qk = y1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  R1.createRoot = function(e, t) {
    Qk.usingClientEntryPoint = !0;
    try {
      return y1.createRoot(e, t);
    } finally {
      Qk.usingClientEntryPoint = !1;
    }
  }, R1.hydrateRoot = function(e, t, n) {
    Qk.usingClientEntryPoint = !0;
    try {
      return y1.hydrateRoot(e, t, n);
    } finally {
      Qk.usingClientEntryPoint = !1;
    }
  };
}
const WNe = (e) => Qr({
  queryKey: ["region-codes"],
  enabled: !!e,
  staleTime: Number.POSITIVE_INFINITY,
  queryFn: async () => (await Ye.liftEither(
    he.fromNullable(e).toEither(
      new Error("missing regionCode")
    )
  ).chain(
    (t) => Ye(() => import("./region-iso-3166-codes-yx6U7De7.js")).mapLeft(() => new Error("Failed to load region-iso-3166-codes")).chain(
      (n) => Ye.liftEither(
        he.fromNullable(
          n.countries[t].subdivisionName
        ).toEither(new Error("region not found"))
      )
    )
  )).unsafeCoerce()
});
var GNe = "xzdlz11 xzdlz10 yv8y4rrb yv8y4rrc";
const Ll = (e) => /* @__PURE__ */ S.jsx(
  ae,
  {
    className: GNe,
    as: "a",
    href: e.href ?? e.children ?? "",
    target: "_blank",
    children: e.children ?? e.href
  }
);
var KNe = "mk05t70", YNe = "mk05t71";
const QNe = ({ modal: e, customTrigger: t }) => {
  var v;
  const { t: n, i18n: r } = ln(), i = (w) => {
    switch (w.type) {
      case "geoBlock": {
        const C = n("help_modals.geo_block.title"), x = t4e({
          language: r.language,
          countryCode: w.countryCode
        });
        return w.tags.has("OFAC") && w.tags.has("OFSI") ? {
          title: C,
          description: /* @__PURE__ */ S.jsx(
            _a,
            {
              i18nKey: "help_modals.geo_block.ofac_ofsi",
              values: { countryName: x },
              components: { link0: /* @__PURE__ */ S.jsx(Ll, {}) }
            }
          ),
          image: Fs.fees
        } : w.tags.has("OFSI") && w.tags.has("Crypto Ban") ? {
          title: C,
          description: /* @__PURE__ */ S.jsx(
            _a,
            {
              i18nKey: "help_modals.geo_block.ofsi_crypto_ban",
              values: { countryName: x },
              components: { link0: /* @__PURE__ */ S.jsx(Ll, {}) }
            }
          ),
          image: Fs.fees
        } : w.tags.has("Crypto Ban") ? {
          title: C,
          description: /* @__PURE__ */ S.jsx(
            _a,
            {
              i18nKey: "help_modals.geo_block.crypto_ban",
              values: { countryName: x },
              components: { link0: /* @__PURE__ */ S.jsx(Ll, {}) }
            }
          ),
          image: Fs.fees
        } : w.tags.has("OFAC") ? {
          title: C,
          description: /* @__PURE__ */ S.jsx(
            _a,
            {
              i18nKey: "help_modals.geo_block.ofac",
              values: { countryName: x },
              components: { link0: /* @__PURE__ */ S.jsx(Ll, {}) }
            }
          ),
          image: Fs.fees
        } : w.tags.has("OFSI") ? {
          title: C,
          description: /* @__PURE__ */ S.jsx(
            _a,
            {
              i18nKey: "help_modals.geo_block.ofsi",
              values: { countryName: x },
              components: { link0: /* @__PURE__ */ S.jsx(Ll, {}) }
            }
          ),
          image: Fs.fees
        } : w.tags.has("Pending Litigation") ? {
          title: C,
          description: /* @__PURE__ */ S.jsx(
            _a,
            {
              i18nKey: "help_modals.geo_block.pending_litigation",
              values: {
                countryName: x,
                nameOfRegion: w.regionCodeName ?? ""
              },
              components: { link0: /* @__PURE__ */ S.jsx(Ll, {}) }
            }
          ),
          image: Fs.fees
        } : w.tags.has("Staking Ban") ? {
          title: C,
          description: /* @__PURE__ */ S.jsx(
            _a,
            {
              i18nKey: "help_modals.geo_block.staking_ban",
              values: { countryName: x },
              components: { link0: /* @__PURE__ */ S.jsx(Ll, {}) }
            }
          ),
          image: Fs.fees
        } : {
          title: C,
          description: /* @__PURE__ */ S.jsx(
            _a,
            {
              i18nKey: "help_modals.geo_block.default",
              values: { countryName: x },
              components: { link0: /* @__PURE__ */ S.jsx(Ll, {}) }
            }
          ),
          image: Fs.fees
        };
      }
      case "getInTouch":
        return {
          title: n("help_modals.get_in_touch.title"),
          button: {
            title: n("help_modals.get_in_touch.button"),
            onClick: () => Ro.ifJust(
              (C) => C.open("https://twitter.com/stakekit", "_blank")
            )
          },
          description: "",
          image: Fs.whatIsLiquidStaking
        };
      case "whatIsStakeKit":
        return {
          title: n("help_modals.what_is_stakekit.title"),
          description: /* @__PURE__ */ S.jsx(
            _a,
            {
              i18nKey: "help_modals.what_is_stakekit.description",
              components: {
                br0: /* @__PURE__ */ S.jsx("br", {}),
                link0: /* @__PURE__ */ S.jsx(Ll, { href: "https://www.stakek.it/" }),
                link1: /* @__PURE__ */ S.jsx(Ll, { href: "https://docs.stakek.it/docs/faqs" })
              }
            }
          ),
          image: Fs.poweredBy
        };
    }
  }, o = (v = k.useContext(EP)) == null ? void 0 : v.trackEvent, { description: s, image: c, title: u, link: f, button: p } = i(e), y = k.useMemo(() => {
    const w = {
      onOpen: () => o == null ? void 0 : o("helpModalOpened", { modal: u })
    };
    return e.type === "geoBlock" ? {
      ...w,
      state: {
        isOpen: !0,
        setOpen: e.onClose
      }
    } : {
      ...w,
      trigger: /* @__PURE__ */ S.jsx(wb, { asChild: !!t, children: t ?? /* @__PURE__ */ S.jsx(ae, { display: "flex", alignItems: "center", justifyContent: "center", children: /* @__PURE__ */ S.jsx(nOe, {}) }) })
    };
  }, [t, e, u, o]);
  return /* @__PURE__ */ S.jsx(dp, { ...y, children: /* @__PURE__ */ S.jsxs(
    ae,
    {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center",
      paddingBottom: { mobile: "8" },
      className: YNe,
      children: [
        /* @__PURE__ */ S.jsx(ae, { as: "img", src: c, className: KNe }),
        /* @__PURE__ */ S.jsx($u, { variant: { level: "h4" }, children: u }),
        /* @__PURE__ */ S.jsx(ae, { marginTop: "2", lineHeight: "short", children: /* @__PURE__ */ S.jsx(
          Ge,
          {
            variant: { type: "muted", weight: "normal" },
            textAlign: "center",
            children: s
          }
        ) }),
        !!f && /* @__PURE__ */ S.jsx(Ll, { children: f }),
        p && /* @__PURE__ */ S.jsx(ae, { marginTop: "4", width: "full", children: /* @__PURE__ */ S.jsx(Jl, { variant: { color: "secondary" }, onClick: p.onClick, children: /* @__PURE__ */ S.jsx(Ge, { variant: { weight: "bold" }, children: p.title }) }) })
      ]
    }
  ) });
};
var XNe = "tk2kcv1 tk2kcv0 yv8y4re3 yv8y4rcl yv8y4r9t yv8y4rbb yv8y4rpj yv8y4rvb yv8y4rvc yv8y4rx yv8y4rfj yv8y4rg1", JNe = "tk2kcv3 tk2kcv2 yv8y4rt yv8y4r39 yv8y4ri yv8y4rqz yv8y4rr0 yv8y4raz", ZNe = "tk2kcv4";
const wI = 6, e3e = () => {
  const e = XA(), t = PNe(), [n, r] = k.useState(
    () => Array.from({ length: 6 }).fill("")
  ), { t: i } = ln(), o = k.useRef(
    Array.from({ length: wI }).fill(null)
  ), s = !e.data && !e.isLoading && e.isError, c = k.useMemo(
    () => t.isPending || n.some((w) => !w),
    [n, t.isPending]
  ), u = () => {
    c || t.mutate(n.join(""));
  }, f = (w, C) => {
    var A;
    const x = [...n];
    x[C] = w, Wu.flushSync(() => {
      r(x);
    }), w && ((A = o.current[C + 1]) == null || A.focus());
  }, p = (w) => r((C) => C.map((x, A) => A < w ? x : "")), y = (w, C) => {
    var A;
    const x = w.toLowerCase();
    x !== "backspace" && x !== "delete" || n[C] || (A = o.current[C - 1]) == null || A.focus();
  }, v = (w) => {
    r(w.slice(0, wI).split("")), fb.ifJust((C) => {
      const x = C.activeElement;
      x && "blur" in x && typeof x.blur == "function" && x.blur();
    });
  };
  return /* @__PURE__ */ S.jsx(dp, { state: { isOpen: s, setOpen: () => {
  } }, disableClose: !0, children: /* @__PURE__ */ S.jsxs(
    ae,
    {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center",
      children: [
        /* @__PURE__ */ S.jsx(ae, { marginBottom: "4", children: /* @__PURE__ */ S.jsx(Ge, { variant: { size: "large" }, children: i("referral_lock.title") }) }),
        /* @__PURE__ */ S.jsxs(Cb, { children: [
          /* @__PURE__ */ S.jsx(ae, { children: /* @__PURE__ */ S.jsx(Ge, { textAlign: "center", variant: { type: "muted" }, children: i("referral_lock.body") }) }),
          /* @__PURE__ */ S.jsx(ae, { my: "4", children: /* @__PURE__ */ S.jsx(Gl, {}) }),
          /* @__PURE__ */ S.jsx(ae, { className: XNe, children: Array.from({ length: wI }).map((w, C) => /* @__PURE__ */ S.jsx(ae, { className: JNe, children: /* @__PURE__ */ S.jsx(
            "input",
            {
              ref: (x) => {
                x && (o.current[C] = x);
              },
              autoFocus: C === 0,
              value: n[C],
              onPaste: (x) => v(x.clipboardData.getData("text")),
              onFocus: () => p(C),
              onChange: (x) => f(x.target.value, C),
              onKeyDown: (x) => y(x.key, C),
              className: ZNe,
              type: "text",
              maxLength: 1,
              disabled: C > 0 && !n[C - 1]
            }
          ) }, C)) }),
          /* @__PURE__ */ S.jsx(ae, { marginTop: "4", children: /* @__PURE__ */ S.jsx(
            Jl,
            {
              variant: { color: c ? "disabled" : "primary" },
              disabled: c,
              onClick: u,
              isLoading: t.isPending,
              children: i("referral_lock.submit")
            }
          ) })
        ] })
      ]
    }
  ) });
};
var t3e = "_1ax7bim0";
const n3e = () => {
  const { t: e } = ln(), { error: t, resetError: n } = Zde(), { message: r, details: i } = t ?? {};
  return /* @__PURE__ */ S.jsx(
    dp,
    {
      state: { isOpen: !!t, setOpen: () => n() },
      onClose: n,
      children: /* @__PURE__ */ S.jsxs(
        ae,
        {
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          justifyContent: "center",
          paddingBottom: { mobile: "8" },
          px: "6",
          lineHeight: "sm",
          children: [
            /* @__PURE__ */ S.jsx(ae, { as: "img", src: Fs.whatIsLiquidStaking, className: t3e }),
            !r && /* @__PURE__ */ S.jsx(ae, { marginBottom: "6", children: /* @__PURE__ */ S.jsx($u, { variant: { level: "h4" }, children: e("shared.something_went_wrong") }) }),
            r && /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
              /* @__PURE__ */ S.jsxs(ae, { textAlign: "center", children: [
                /* @__PURE__ */ S.jsx($u, { variant: { level: "h4" }, children: e(`errors.${r}.title`) }),
                /* @__PURE__ */ S.jsx(
                  Ge,
                  {
                    variant: { type: "muted", weight: "normal" },
                    textAlign: "center",
                    children: e(`errors.${r}.details`, i)
                  }
                )
              ] }),
              /* @__PURE__ */ S.jsxs(ae, { marginTop: "4", textAlign: "center", children: [
                /* @__PURE__ */ S.jsx(Ge, { variant: { size: "large" }, children: e("error_modal.solution") }),
                /* @__PURE__ */ S.jsx(
                  ae,
                  {
                    borderRadius: "md",
                    background: "backgroundMuted",
                    px: "4",
                    py: "1",
                    marginTop: "2",
                    children: /* @__PURE__ */ S.jsx(Ge, { variant: { size: "medium" }, textAlign: "center", children: e(`errors.${r}.solution`) })
                  }
                )
              ] })
            ] })
          ]
        }
      )
    }
  );
}, r3e = () => {
  const e = Mde(), t = WNe(
    e ? e.regionCode : void 0
  ), [n, r] = k.useState(!1), { referralCheck: i } = dr();
  return e && !n ? /* @__PURE__ */ S.jsx(
    QNe,
    {
      modal: {
        type: "geoBlock",
        ...e,
        regionCodeName: t.data,
        onClose: () => r(!0)
      }
    }
  ) : /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
    i && /* @__PURE__ */ S.jsx(e3e, {}),
    /* @__PURE__ */ S.jsx(n3e, {})
  ] });
}, d8 = ({
  actionType: e,
  balanceType: t,
  token: n
}) => `${t}-${as(n)}-${e}`, QJ = ({
  pendingActionsState: e,
  additionalAddresses: t,
  address: n,
  pendingActionDto: r,
  integration: i,
  yieldBalance: o,
  selectedValidators: s
}) => he.fromNullable(n).toEither(new Error("missing address")).map((c) => {
  var f, p, y, v, w, C, x, A, R;
  const u = {
    amount: he.fromPredicate(
      Boolean,
      (y = (p = (f = r.args) == null ? void 0 : f.args) == null ? void 0 : p.amount) == null ? void 0 : y.required
    ).chainNullable(
      () => e.get(
        d8({
          balanceType: o.type,
          token: o.token,
          actionType: r.type
        })
      )
    ).map((I) => I.toString()).alt(he.of(o.amount)).extract()
  };
  return s.length && ((C = (w = (v = r.args) == null ? void 0 : v.args) == null ? void 0 : w.validatorAddresses) != null && C.required ? u.validatorAddresses = s : (R = (A = (x = r.args) == null ? void 0 : x.args) == null ? void 0 : A.validatorAddress) != null && R.required && (u.validatorAddress = Wn.head(s).orDefault(""))), {
    requestDto: {
      args: u,
      integrationId: i.id,
      passthrough: r.passthrough,
      type: r.type
    },
    address: c,
    additionalAddresses: t ?? void 0,
    gasFeeToken: i.metadata.gasFeeToken,
    integrationData: i
  };
}), XJ = () => {
  const { isLedgerLive: e, isConnected: t, address: n, connector: r, additionalAddresses: i } = fr(), o = tc(), s = Cde(), c = ap(), { externalProviders: u } = dr();
  return Qr({
    staleTime: Number.POSITIVE_INFINITY,
    gcTime: Number.POSITIVE_INFINITY,
    queryKey: ["pending-action-deep-link", e, n],
    enabled: !!(t && n && r),
    queryFn: async () => (await Ye.liftEither(
      he.fromNullable(n).toEither(
        new Error("missing wagmi config")
      )
    ).chain(
      (f) => i3e({
        isLedgerLive: e,
        additionalAddresses: i,
        address: f,
        queryClient: o,
        yieldGetSingleYieldBalances: s,
        yieldYieldOpportunity: c,
        externalProviders: u
      })
    )).unsafeCoerce()
  });
}, i3e = ({
  isLedgerLive: e,
  additionalAddresses: t,
  address: n,
  queryClient: r,
  yieldGetSingleYieldBalances: i,
  yieldYieldOpportunity: o,
  externalProviders: s
}) => gA({
  isLedgerLive: e,
  queryClient: r,
  yieldYieldOpportunity: o,
  externalProviders: s
}).chain((c) => {
  const u = he.of(c).filter(
    (f) => !!f.yieldId && !!f.pendingaction
  ).toEither(new Error("missing yieldId or pendingaction"));
  return u.isLeft() ? Ye.liftEither(Pt(null)) : Ye.liftEither(u).chain(
    (f) => Ia({
      fn: () => i(f.yieldId, {
        addresses: {
          address: n,
          additionalAddresses: t ?? void 0
        }
      })
    }).mapLeft(() => new Error("could not get yield balances")).map((p) => ({
      yieldId: f.yieldId,
      pendingaction: f.pendingaction,
      validatorAddress: f.validator,
      singleYieldBalances: p,
      address: n,
      additionalAddresses: t ?? void 0
    }))
  ).chain(
    (f) => Ye.liftEither(
      Pt(f.singleYieldBalances).chain((p) => {
        for (const y of p) {
          if (f.validatorAddress && y.validatorAddress !== f.validatorAddress)
            continue;
          const v = y.pendingActions.find(
            (w) => w.type === f.pendingaction
          );
          if (v)
            return Pt({
              pendingAction: v,
              balance: y,
              balanceId: y.groupId ?? "default"
            });
        }
        return Rn(new Error("no pending action found"));
      })
    ).chain(
      (p) => vA({
        isLedgerLive: e,
        yieldId: f.yieldId,
        queryClient: r,
        yieldYieldOpportunity: o
      }).map((y) => ({ ...p, yieldOp: y }))
    ).chain(
      (p) => Z5(p.pendingAction) || eD(p.pendingAction) ? Ye.liftEither(
        Pt({ type: "positionDetails", ...p })
      ) : Ye.liftEither(
        QJ({
          // TODO: fix this
          pendingActionsState: /* @__PURE__ */ new Map(),
          address: f.address,
          additionalAddresses: f.additionalAddresses ?? null,
          integration: p.yieldOp,
          yieldBalance: p.balance,
          pendingActionDto: p.pendingAction,
          selectedValidators: []
        })
      ).map((y) => ({
        yieldOp: p.yieldOp,
        pendingActionDto: y,
        type: "review",
        balanceId: p.balanceId,
        balance: p.balance
      }))
    )
  );
}), o3e = () => {
  const e = XJ(), t = Pr(La()), n = vx(), r = Wfe(), { mountAnimationFinished: i } = ff(), { isConnected: o } = fr(), s = i && o;
  k.useEffect(() => {
    r.filter(
      (c) => !!(c.yieldId && c.balanceId && !c.pendingaction && s)
    ).ifJust(
      (c) => t.current(`positions/${c.yieldId}/${c.balanceId}`)
    );
  }, [r, t, s]), k.useEffect(() => {
    he.fromNullable(e.data).filter(
      (c) => s && c.type === "positionDetails"
    ).ifJust(
      (c) => t.current(
        `positions/${c.yieldOp.id}/${c.balanceId}/select-validator/${c.pendingAction.type}`
      )
    );
  }, [t, e.data, s]), k.useEffect(() => {
    he.fromNullable(e.data).filter(
      (c) => s && c.type === "review"
    ).ifJust((c) => {
      n.send({
        type: "initFlow",
        data: {
          requestDto: c.pendingActionDto.requestDto,
          addresses: {
            address: c.pendingActionDto.address,
            additionalAddresses: c.pendingActionDto.additionalAddresses
          },
          gasFeeToken: c.pendingActionDto.gasFeeToken,
          integrationData: c.pendingActionDto.integrationData,
          interactedToken: c.balance.token,
          pendingActionType: c.pendingActionDto.requestDto.type
        }
      }), t.current(
        `positions/${c.yieldOp.id}/${c.balanceId}/pending-action/review`
      );
    });
  }, [
    n,
    e.data,
    s,
    t
  ]);
}, a3e = () => {
  const { isConnected: e } = fr();
  return e ? /* @__PURE__ */ S.jsx(lN, {}) : /* @__PURE__ */ S.jsx(SQ, { to: "/", replace: !0 });
}, s3e = $A(
  { data: he.empty() },
  {
    initFlow: (e, t) => ({
      data: he.of({ ...t.data, actionDto: he.empty() })
    }),
    setActionDto: (e, t) => ({
      data: e.data.map((n) => ({
        ...n,
        actionDto: he.of(t.data)
      }))
    })
  }
), JJ = k.createContext(
  void 0
), l3e = ({ children: e }) => /* @__PURE__ */ S.jsx(JJ.Provider, { value: s3e, children: e }), ZA = () => {
  const e = k.useContext(JJ);
  if (!e)
    throw new Error(
      "useEnterStakeStore must be used within a EnterStakeStoreProvider"
    );
  return e;
}, c3e = () => {
  sa("stakeComplete");
  const e = ss(
    ZA(),
    (u) => u.context.data
  ).unsafeCoerce(), t = k.useMemo(
    () => he.of(e.selectedStake),
    [e.selectedStake]
  ), n = k.useMemo(
    () => he.of(e.selectedToken),
    [e.selectedToken]
  ), r = t.map((u) => u.metadata), i = n.mapOrDefault((u) => u.symbol, ""), o = k.useMemo(
    () => To(new Nt(e.requestDto.args.amount)),
    [e.requestDto.args.amount]
  ), s = Xh(t).map((u) => u.type), c = cf({
    integrationData: t,
    validatorsAddresses: he.of(e.selectedValidators)
  });
  return /* @__PURE__ */ S.jsx(
    VA,
    {
      yieldType: s,
      providersDetails: c,
      token: n,
      metadata: r,
      network: i,
      amount: o
    }
  );
}, ZJ = () => {
  const e = dr(), { connectorChains: t, connector: n, chain: r } = fr(), i = k.useMemo(
    () => t.map((c) => c.id),
    [t]
  ), o = n == null ? void 0 : n.switchChain, s = k.useCallback((c) => o == null ? void 0 : o({ chainId: c }), [o]);
  return e.variant !== "zerion" || !o || !n ? null : he.fromNullable(
    e.chainModal({
      chainIds: i,
      selectedChainId: r.id,
      onSwitchChain: s
    })
  ).map((c) => /* @__PURE__ */ S.jsx(ae, { minHeight: "8", "data-rk": "chain-modal", children: c })).extractNullable();
}, u3e = (e) => {
  const t = yA(e.integrationId), n = k.useMemo(
    () => he.fromNullable(t.data),
    [t.data]
  ), r = cf({
    integrationData: n,
    validatorsAddresses: he.of(
      e.type === "validators" ? e.validatorsAddresses : []
    )
  }), i = k.useMemo(
    () => he.fromRecord({ providersDetails: r, integrationData: n }).map((s) => ({
      ...s,
      rewardRateAverage: s.providersDetails.reduce(
        (c, u) => c.plus(new Nt(u.rewardRate || 0)),
        new Nt(0)
      ).dividedBy(s.providersDetails.length)
    })).map(
      (s) => Hh({
        rewardRate: s.rewardRateAverage.toNumber(),
        rewardType: s.integrationData.rewardType
      })
    ),
    [n, r]
  ), o = k.useMemo(
    () => r.chain((s) => Wn.find((c) => c.status !== "active", s)).chainNullable((s) => s.status).map((s) => s).extractNullable(),
    [r]
  );
  return {
    integrationData: n,
    providersDetails: r,
    rewardRateAverage: i,
    inactiveValidator: o
  };
};
var d3e = "_1dulflp0";
const f3e = ({ children: e, ...t }) => /* @__PURE__ */ S.jsx(dN, { className: d3e, ...t, children: e }), eT = () => /* @__PURE__ */ S.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "none", children: /* @__PURE__ */ S.jsx(
  "path",
  {
    fill: "#45D65C",
    d: "M14.116 6.426c-.235-.246-.48-.5-.571-.723-.085-.204-.09-.543-.095-.871-.01-.61-.02-1.301-.5-1.782-.48-.48-1.172-.49-1.782-.5-.328-.005-.667-.01-.871-.095-.223-.092-.477-.336-.723-.571C9.143 1.469 8.653 1 8 1c-.652 0-1.142.47-1.574.884-.246.235-.5.48-.723.571-.203.085-.543.09-.871.095-.61.01-1.301.02-1.782.5-.48.48-.487 1.172-.5 1.782-.005.328-.01.667-.095.871-.092.223-.336.477-.571.723C1.469 6.857 1 7.347 1 8c0 .652.47 1.142.884 1.574.235.246.48.5.571.723.085.204.09.543.095.871.01.61.02 1.301.5 1.782.48.48 1.172.49 1.782.5.328.005.667.01.871.095.223.092.477.336.723.571.431.415.921.884 1.574.884.652 0 1.142-.47 1.574-.884.246-.235.5-.48.723-.571.204-.085.543-.09.871-.095.61-.01 1.301-.02 1.782-.5.48-.48.49-1.172.5-1.782.005-.328.01-.667.095-.871.092-.223.336-.477.571-.723C14.531 9.143 15 8.653 15 8c0-.652-.47-1.142-.884-1.574Zm-3.262.428-3.5 3.5a.502.502 0 0 1-.708 0l-1.5-1.5a.5.5 0 1 1 .708-.708L7 9.293l3.146-3.147a.501.501 0 0 1 .708.708Z"
  }
) });
var h3e = "gsuntr0", Ez = "gsuntr1", p3e = "gsuntr2", UD = "gsuntr3", m3e = "gsuntr5 gsuntr4 yv8y4rpj";
const y3e = ({
  foundValidatorsData: e,
  onValidatorAddressOrNameChange: t,
  errorMessage: n,
  isLoading: r,
  onClose: i,
  onImportValidatorImport: o
}) => {
  const { t: s } = ln(), c = k.useRef(null), [u, f] = k.useState(""), p = Bi();
  return /* @__PURE__ */ S.jsx(
    dp,
    {
      title: s("positions.import_validator_modal_title"),
      searchValue: u,
      onSearch: (y) => {
        f(y), t(y);
      },
      onOpen: () => p("importValidatorModalOpened"),
      errorMessage: n,
      isLoading: r,
      onClose: () => {
        f(""), i == null || i();
      },
      trigger: /* @__PURE__ */ S.jsx(wb, { asChild: !0, children: /* @__PURE__ */ S.jsx(ae, { children: /* @__PURE__ */ S.jsx(Jl, { variant: { size: "small", color: "smallButton" }, children: /* @__PURE__ */ S.jsx(Ge, { children: s("positions.import_button") }) }) }) }),
      children: e.map((y) => /* @__PURE__ */ S.jsxs(ae, { className: p3e, children: [
        !u && /* @__PURE__ */ S.jsx(ae, { marginTop: "2", children: /* @__PURE__ */ S.jsx(Cb, { children: /* @__PURE__ */ S.jsx(Ge, { children: s("positions.search_for_validators") }) }) }),
        /* @__PURE__ */ S.jsx(
          SN,
          {
            data: y,
            estimateSize: () => 60,
            itemContent: (v, w) => /* @__PURE__ */ S.jsx(Cb, { children: /* @__PURE__ */ S.jsxs(zA, { children: [
              /* @__PURE__ */ S.jsxs(ae, { display: "flex", gap: "2", minWidth: "0", marginRight: "4", children: [
                /* @__PURE__ */ S.jsx(ae, { children: /* @__PURE__ */ S.jsx(
                  Hc,
                  {
                    containerProps: { hw: "9" },
                    imageProps: { borderRadius: "full" },
                    src: w.validator.image,
                    fallback: /* @__PURE__ */ S.jsx(
                      df,
                      {
                        name: w.validator.name || w.validator.address,
                        tokenLogoHw: "9"
                      }
                    )
                  }
                ) }),
                /* @__PURE__ */ S.jsxs(ae, { display: "flex", flexDirection: "column", minWidth: "0", children: [
                  /* @__PURE__ */ S.jsxs(ae, { display: "flex", alignItems: "center", children: [
                    /* @__PURE__ */ S.jsx(
                      Ge,
                      {
                        className: zs([
                          h3e,
                          Ez
                        ]),
                        variant: { weight: "bold" },
                        children: w.validator.name
                      }
                    ),
                    w.validator.preferred && /* @__PURE__ */ S.jsx(ae, { marginLeft: "1", display: "flex", children: /* @__PURE__ */ S.jsx(eT, {}) })
                  ] }),
                  w.validator.name !== w.validator.address && /* @__PURE__ */ S.jsx(
                    Ge,
                    {
                      variant: { weight: "normal" },
                      className: Ez,
                      children: w.validator.address
                    }
                  )
                ] })
              ] }),
              /* @__PURE__ */ S.jsx(
                ae,
                {
                  display: "flex",
                  justifyContent: "center",
                  alignItems: "flex-end",
                  textAlign: "right",
                  children: w.validator.preferred ? /* @__PURE__ */ S.jsx(Ge, { children: s("positions.import_validator_already_imported") }) : /* @__PURE__ */ S.jsx(
                    Jl,
                    {
                      variant: { size: "small", color: "smallButton" },
                      onClick: () => {
                        var C;
                        o(w), (C = c.current) == null || C.close();
                      },
                      children: /* @__PURE__ */ S.jsx(Ge, { children: s("positions.import_button") })
                    }
                  )
                }
              )
            ] }) })
          }
        )
      ] })).extractNullable()
    }
  );
}, v3e = k.memo(
  ({
    item: e
  }) => {
    const { t } = ln(), {
      integrationData: n,
      providersDetails: r,
      inactiveValidator: i,
      rewardRateAverage: o
    } = u3e(e);
    return /* @__PURE__ */ S.jsx(
      f3e,
      {
        relative: "path",
        to: `../positions/${e.integrationId}/${e.balanceId}`,
        children: /* @__PURE__ */ S.jsx(ae, { py: "1", children: n.mapOrDefault(
          (s) => /* @__PURE__ */ S.jsxs(UA, { className: m3e, children: [
            /* @__PURE__ */ S.jsxs(
              ae,
              {
                display: "flex",
                width: "full",
                justifyContent: "space-between",
                gap: "2",
                children: [
                  /* @__PURE__ */ S.jsxs(
                    ae,
                    {
                      display: "flex",
                      justifyContent: "flex-start",
                      alignItems: "center",
                      children: [
                        e.token.mapOrDefault(
                          (c) => /* @__PURE__ */ S.jsx(nf, { metadata: s.metadata, token: c }),
                          /* @__PURE__ */ S.jsx(ae, { display: "flex", marginRight: "2", children: /* @__PURE__ */ S.jsx(Wl, {}) })
                        ),
                        /* @__PURE__ */ S.jsxs(
                          ae,
                          {
                            display: "flex",
                            flexDirection: "column",
                            justifyContent: "center",
                            alignItems: "flex-start",
                            gap: "1",
                            children: [
                              /* @__PURE__ */ S.jsxs(ae, { className: sDe, children: [
                                e.token.map((c) => /* @__PURE__ */ S.jsx(Ge, { children: c.symbol })).extractNullable(),
                                e.yieldLabelDto.map((c) => /* @__PURE__ */ S.jsx(
                                  kC,
                                  {
                                    textAlign: "left",
                                    maxWidth: 300,
                                    label: t(
                                      `position_details.labels.${c.type}.details`,
                                      c.params
                                    ),
                                    children: /* @__PURE__ */ S.jsx(
                                      ae,
                                      {
                                        className: _D({
                                          type: "actionRequired"
                                        }),
                                        children: /* @__PURE__ */ S.jsx(
                                          Ge,
                                          {
                                            variant: { type: "white" },
                                            className: UD,
                                            children: t(
                                              `position_details.labels.${c.type}.label`
                                            )
                                          }
                                        )
                                      }
                                    )
                                  }
                                )).extractNullable(),
                                (e.actionRequired || e.hasPendingClaimRewards || i) && /* @__PURE__ */ S.jsx(
                                  ae,
                                  {
                                    className: _D({
                                      type: e.actionRequired || i ? "actionRequired" : "claim"
                                    }),
                                    children: /* @__PURE__ */ S.jsx(
                                      Ge,
                                      {
                                        variant: { type: "white" },
                                        className: UD,
                                        children: t(
                                          e.actionRequired ? "positions.action_required" : i ? i === "jailed" ? "details.validators_jailed" : "details.validators_inactive" : "positions.claim_rewards"
                                        )
                                      }
                                    )
                                  }
                                )
                              ] }),
                              r.chain(
                                (c) => Wn.head(c).map((u) => /* @__PURE__ */ S.jsx(
                                  Ge,
                                  {
                                    className: lDe,
                                    variant: {
                                      type: "muted",
                                      weight: "normal"
                                    },
                                    children: t("positions.via", {
                                      providerName: u.name ?? u.address,
                                      count: Math.max(c.length - 1, 1)
                                    })
                                  }
                                ))
                              ).extractNullable()
                            ]
                          }
                        )
                      ]
                    }
                  ),
                  he.fromRecord({
                    token: e.token,
                    rewardRateAverage: o
                  }).map((c) => /* @__PURE__ */ S.jsxs(
                    ae,
                    {
                      display: "flex",
                      justifyContent: "center",
                      alignItems: "flex-end",
                      flexDirection: "column",
                      textAlign: "end",
                      gap: "1",
                      children: [
                        /* @__PURE__ */ S.jsx(Ge, { variant: { weight: "normal" }, children: e.actionRequired ? " " : c.rewardRateAverage }),
                        /* @__PURE__ */ S.jsxs(
                          Ge,
                          {
                            overflowWrap: "anywhere",
                            variant: { weight: "normal", type: "muted" },
                            children: [
                              e.amount,
                              " ",
                              c.token.symbol
                            ]
                          }
                        )
                      ]
                    }
                  )).extractNullable()
                ]
              }
            ),
            e.pointsRewardTokenBalance.map((c) => /* @__PURE__ */ S.jsxs(
              ae,
              {
                alignSelf: "flex-end",
                background: "background",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                borderRadius: "lg",
                px: "2",
                py: "1",
                gap: "1",
                children: [
                  /* @__PURE__ */ S.jsx(
                    nf,
                    {
                      token: c.token,
                      hideNetwork: !0,
                      tokenLogoHw: "5"
                    }
                  ),
                  /* @__PURE__ */ S.jsx(
                    Ge,
                    {
                      overflowWrap: "anywhere",
                      variant: { type: "muted", weight: "normal" },
                      children: c.amount
                    }
                  )
                ]
              }
            )).extractNullable()
          ] }),
          /* @__PURE__ */ S.jsx(hf, { heightPx: 60 })
        ) })
      }
    );
  }
), g3e = ({
  importValidators: e
}) => {
  const { t } = ln();
  return /* @__PURE__ */ S.jsx(ae, { py: "1", children: /* @__PURE__ */ S.jsx(UA, { variant: { hover: "disabled" }, children: /* @__PURE__ */ S.jsxs(
    ae,
    {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      gap: "2",
      children: [
        /* @__PURE__ */ S.jsxs(ae, { display: "flex", flexDirection: "column", gap: "2", flex: 2, children: [
          /* @__PURE__ */ S.jsx(Ge, { variant: { weight: "bold" }, children: t("positions.dont_see_position") }),
          /* @__PURE__ */ S.jsx(Ge, { variant: { weight: "normal", type: "muted" }, children: t("positions.import_validator") })
        ] }),
        /* @__PURE__ */ S.jsx(
          ae,
          {
            flex: 1,
            display: "flex",
            justifyContent: "flex-end",
            alignItems: "center",
            children: /* @__PURE__ */ S.jsx(y3e, { ...e })
          }
        )
      ]
    }
  ) }) });
}, eZ = ({
  address: e,
  network: t,
  validatorData: n
}) => mA("sk-widget@1//customValidators").chain(
  (r) => r ? Pt(r) : Rn(new Error("No custom validators"))
).caseOf({
  Right: (r) => {
    const i = he.fromNullable(r[t]).chain((s) => he.fromNullable(s[e])).map((s) => new Map(s.map((c) => [c.integrationId, c]))).orDefault(/* @__PURE__ */ new Map()), o = i.get(n.integrationId);
    return i.set(
      n.integrationId,
      o ? {
        ...o,
        validatorAddresses: [
          ...o.validatorAddresses,
          n.validator.address
        ]
      } : {
        integrationId: n.integrationId,
        validatorAddresses: [n.validator.address]
      }
    ), G4("sk-widget@1//customValidators", {
      ...r,
      [t]: {
        ...r[t],
        [e]: [...i.values()]
      }
    });
  },
  Left: () => G4("sk-widget@1//customValidators", {
    [t]: {
      [e]: [
        {
          integrationId: n.integrationId,
          validatorAddresses: [n.validator.address]
        }
      ]
    }
  })
}), tZ = () => {
  const { variant: e } = dr(), t = CN(), n = k.useMemo(
    () => b3e({
      positionsData: t.data,
      variant: e
    }),
    [t.data, e]
  ), r = { ...t, data: n }, { network: i, address: o, isConnected: s } = fr(), [c, u] = k.useState(""), f = k.useDeferredValue(
    c
  ), p = (D) => {
    u(D);
  }, y = wde(
    { query: f, network: i ?? void 0 },
    { query: { enabled: f.length >= 2 } }
  ), v = he.fromNullable(y.data).alt(he.of([])).map(
    (D) => D.reduce(
      (M, L) => (L.validators.forEach((j) => {
        M.push({
          integrationId: L.integrationId,
          validator: j
        });
      }), M),
      new Array()
    )
  ), { t: w } = ln(), C = Bi(), x = (D) => {
    he.fromRecord({
      network: he.fromNullable(i),
      address: he.fromNullable(o)
    }).ifJust((M) => {
      eZ({ ...M, validatorData: D }), C("validatorImported", {
        yieldId: D.integrationId,
        name: D.validator.name,
        address: D.validator.address
      });
    });
  }, A = {
    foundValidatorsData: v,
    onValidatorAddressOrNameChange: p,
    isLoading: y.isLoading,
    errorMessage: y.error ? w("shared.something_went_wrong") : void 0,
    onClose: () => u(""),
    onImportValidatorImport: x
  }, R = s && (!!r.data.length || !r.isLoading && !r.isError), I = k.useMemo(
    () => ["header", ...r.data],
    [r.data]
  );
  return {
    positionsData: r,
    listData: I,
    importValidators: A,
    showPositions: R
  };
}, b3e = $b(
  (e) => e.positionsData,
  (e) => e.variant,
  (e, t) => _n([...e.values()]).map(
    (n) => n.reduce(
      (r, i) => ([...i.balanceData.entries()].forEach(([o, s]) => {
        _n(
          s.balances.filter(
            (c) => _n(new Nt(c.amount)).filter((u) => !u.isZero() && !u.isNaN()).isJust()
          )
        ).filter((c) => !!c.length).ifJust(
          (c) => r.push({
            ...s,
            integrationId: i.integrationId,
            balancesWithAmount: c,
            balanceId: o,
            allBalances: s.balances,
            yieldLabelDto: Wn.find(
              (u) => !!u.label,
              s.balances
            ).chainNullable((u) => u.label),
            token: Wn.head(
              Wn.sort(
                (u, f) => aue(Sz[u.type], Sz[f.type]),
                s.balances
              )
            ).map((u) => u.token),
            actionRequired: c.some(
              (u) => u.type === "locked" || u.type === "unstaked"
            ),
            amount: _n(
              c.reduce((u, f) => f.token.isPoints ? u : new Nt(f.amount).plus(u), new Nt(0))
            ).map(Na).unsafeCoerce(),
            pointsRewardTokenBalance: Wn.find(
              (u) => !!u.token.isPoints,
              c
            ).map((u) => ({
              ...u,
              amount: Na(u.amount)
            })),
            hasPendingClaimRewards: Wn.find(
              (u) => u.type === "rewards",
              c
            ).chain(
              (u) => Wn.find(
                (f) => f.type === "CLAIM_REWARDS",
                u.pendingActions
              )
            ).isJust()
          })
        );
      }), r),
      []
    )
  ).map(
    (n) => t === "zerion" ? n.toSorted((r, i) => r.hasPendingClaimRewards ? -1 : i.hasPendingClaimRewards ? 1 : Nt(i.amount).minus(Nt(r.amount)).toNumber()) : n
  ).unsafeCoerce()
), Sz = {
  available: 1,
  staked: 2,
  unstaking: 3,
  unstaked: 4,
  preparing: 5,
  locked: 6,
  unlocking: 7,
  rewards: 8
}, w3e = () => {
  sa("positions");
  const { positionsData: e, listData: t, importValidators: n, showPositions: r } = tZ(), { isConnected: i, isConnecting: o } = fr(), s = k.useMemo(() => e.isLoading && e.isFetching && i ? /* @__PURE__ */ S.jsx(Tg, { type: "spinner" }) : !i && !o ? /* @__PURE__ */ S.jsx(Tg, { type: "not_connected" }) : e.isError && !e.data.length ? /* @__PURE__ */ S.jsx(Tg, { type: "something_wrong" }) : null, [
    i,
    o,
    e.data.length,
    e.isError,
    e.isFetching,
    e.isLoading
  ]), { mountAnimationFinished: c } = ff();
  return /* @__PURE__ */ S.jsx(
    gi.div,
    {
      initial: { opacity: 0, translateY: "-10px" },
      animate: { opacity: 1, translateY: 0 },
      transition: {
        duration: c ? 0.3 : 1,
        delay: c ? 0 : 1.5
      },
      children: /* @__PURE__ */ S.jsx(fp, { children: /* @__PURE__ */ S.jsxs(
        ae,
        {
          className: cDe,
          display: "flex",
          flex: 1,
          flexDirection: "column",
          children: [
            s,
            r && /* @__PURE__ */ S.jsx(ae, { flex: 1, display: "flex", flexDirection: "column", children: /* @__PURE__ */ S.jsx(
              SN,
              {
                estimateSize: () => 60,
                data: t,
                itemContent: (u, f) => f === "header" ? /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
                  /* @__PURE__ */ S.jsx(ZJ, {}),
                  /* @__PURE__ */ S.jsx(
                    g3e,
                    {
                      importValidators: n
                    }
                  ),
                  i && !e.data.length && /* @__PURE__ */ S.jsx(ae, { my: "4", children: /* @__PURE__ */ S.jsx(Tg, { type: "no_current_positions" }) })
                ] }) : /* @__PURE__ */ S.jsx(v3e, { item: f })
              }
            ) })
          ]
        }
      ) })
    }
  );
}, C3e = (e, t) => () => {
  let n = 0;
  const r = new Array(e.length), i = (o, s) => {
    if (r[s] = o, n < e.length) {
      const c = n++;
      return e[c]().chain((u) => i(u, c));
    }
    return Ye.liftEither(Pt(null));
  };
  return Ye.all(
    Array.from({ length: Math.min(t, e.length) }).map(() => {
      const o = n++;
      return e[o]().chain((s) => i(s, o));
    })
  ).map(() => r);
}, ZN = (e) => [
  "multi-yields",
  e
], x3e = ({
  queryClient: e,
  yieldIds: t
}) => he.fromNullable(
  e.getQueryData(ZN(t))
), nZ = (e, t) => {
  const { network: n, isConnected: r, isLedgerLive: i } = fr(), o = tc(), s = ap();
  return Qr({
    queryKey: ZN(e),
    enabled: !!e.length,
    staleTime: ni.queryClient.cacheTime,
    select: t == null ? void 0 : t.select,
    queryFn: async () => (await iZ({
      isConnected: r,
      isLedgerLive: i,
      network: n,
      queryClient: o,
      yieldIds: e,
      yieldYieldOpportunity: s
    })).unsafeCoerce()
  });
}, rZ = (e) => Ye(
  () => e.queryClient.fetchQuery({
    queryKey: ZN(e.yieldIds),
    queryFn: async () => (await iZ(e)).unsafeCoerce()
  })
).mapLeft((t) => new Error("could not get multi yields")), iZ = ({
  yieldIds: e,
  isLedgerLive: t,
  queryClient: n,
  isConnected: r,
  network: i,
  yieldYieldOpportunity: o
}) => C3e(
  e.map(
    (s) => () => vA({
      isLedgerLive: t,
      yieldId: s,
      queryClient: n,
      yieldYieldOpportunity: o
    }).chainLeft(async () => Pt(null))
  ),
  5
)().map((s) => s.filter((c) => !!c)).map(
  (s) => T3e({ data: s, isConnected: r, network: i, isLedgerLive: t })
).ifRight((s) => {
  s.forEach(
    (c) => Jke({
      isLedgerLive: t,
      yieldDto: c,
      queryClient: n
    })
  );
}), E3e = ({
  o: e,
  isConnected: t,
  network: n
}) => {
  var i;
  const r = !((i = e.args.enter.args) != null && i.nfts) && e.id !== "binance-bnb-native-staking" && e.id !== "binance-testnet-bnb-native-staking" && e.id !== "avax-native-staking" && e.status.enter && V$(e.token.network);
  return t ? n === e.token.network && r : r;
}, S3e = (e) => e.data, k3e = (e) => e.isConnected, A3e = (e) => e.network, T3e = $b(
  S3e,
  k3e,
  A3e,
  (e, t, n) => e.filter((r) => E3e({ o: r, isConnected: t, network: n }))
), _3e = (e) => new Nt(e.amount).isGreaterThan(0), zD = (e) => !!e.availableYields.length, R3e = (e) => zD(e) && _3e(e), O3e = (e) => (
  /**
   * TB based on query params
   */
  e.initQueryParams.filter((t) => !!t.token).chain(
    (t) => Wn.find(
      (n) => n.token.symbol === t.token && n.token.network === t.network || as(n.token) === t.token,
      [...e.tokenBalances, ...e.defaultTokens]
    )
  ).altLazy(() => Wn.find(R3e, e.tokenBalances)).altLazy(() => Wn.find(zD, e.tokenBalances)).altLazy(() => Wn.find(zD, e.defaultTokens)).map((t) => t.token)
), kz = {
  staking: 1,
  restaking: 2,
  "liquid-staking": 3,
  vault: 4,
  lending: 5
}, oZ = (e) => {
  const t = e.yieldDtos.toSorted(
    (n, r) => kz[n.metadata.type] - kz[r.metadata.type] || f8(r).minus(f8(n)).toNumber()
  );
  return e.initQueryParams.filter((n) => !!n.yieldId).chain((n) => Wn.find((r) => n.yieldId === r.id, t)).altLazy(
    () => Wn.find(
      (n) => I3e({
        tokenBalanceAmount: e.tokenBalanceAmount,
        yieldDto: n
      }),
      t
    )
  ).altLazy(() => Wn.head(t));
}, I3e = ({
  tokenBalanceAmount: e,
  yieldDto: t
}) => e.isGreaterThanOrEqualTo(f8(t)), f8 = (e) => {
  var t, n;
  return new Nt(((n = (t = e.args.enter.args) == null ? void 0 : t.amount) == null ? void 0 : n.minimum) ?? 0);
}, D3e = (e) => e.initQueryParams.chainNullable((t) => t.validator).chain(
  (t) => Wn.find(
    (n) => n.name === t || n.address === t,
    e.yieldDto.validators
  )
).altLazy(() => Wn.head(e.yieldDto.validators)).map((t) => /* @__PURE__ */ new Map([[t.address, t]])).orDefault(/* @__PURE__ */ new Map()), Ob = (e) => e.minimum === -1 && e.maximum === -1, e3 = ({
  type: e,
  integration: t
}) => t.chainNullable(
  (n) => {
    var r, i, o;
    return e === "enter" ? (r = n.args.enter.args) == null ? void 0 : r.amount : (o = (i = n.args.exit) == null ? void 0 : i.args) == null ? void 0 : o.amount;
  }
).map(Ob).orDefault(!1), aZ = ({
  type: e,
  yieldOpportunity: t,
  availableAmount: n,
  positionsData: r
}) => {
  const i = e3({
    type: e,
    integration: t
  }), o = k.useMemo(() => (i ? n : t.chainNullable((f) => {
    var p, y, v;
    return e === "enter" && SSe(f.id, r) ? new Nt(0) : (v = (y = (p = e === "enter" ? f.args.enter : f.args.exit) == null ? void 0 : p.args) == null ? void 0 : y.amount) == null ? void 0 : v.minimum;
  }).map((f) => new Nt(f))).orDefault(new Nt(0)), [n, i, e, t, r]), s = k.useMemo(() => (i ? n : t.chainNullable(
    (f) => {
      var p, y, v;
      return (v = (y = (p = e === "enter" ? f.args.enter : f.args.exit) == null ? void 0 : p.args) == null ? void 0 : y.amount) == null ? void 0 : v.maximum;
    }
  ).map((f) => new Nt(f))).orDefault(new Nt(Number.POSITIVE_INFINITY)), [n, i, e, t]), c = k.useMemo(
    () => iSe({
      availableAmount: n.orDefault(new Nt(0)),
      gasEstimateTotal: new Nt(0),
      integrationMaxLimit: s
    }),
    [s, n]
  ), u = o;
  return k.useMemo(
    () => ({
      minEnterOrExitAmount: u,
      maxEnterOrExitAmount: c,
      maxIntegrationAmount: s
    }),
    [c, u, s]
  );
}, M3e = ({
  availableAmount: e,
  stakeAmount: t,
  maxEnterOrExitAmount: n,
  minEnterOrExitAmount: r
}) => {
  const i = k.useMemo(
    () => e.map(() => t.isLessThan(r)).orDefault(!1),
    [e, t, r]
  ), o = k.useMemo(
    () => e.map(() => t.isGreaterThan(n)).orDefault(!1),
    [e, t, n]
  ), s = k.useMemo(
    () => e.map(() => t.isZero()).orDefault(!1),
    [t, e]
  ), c = k.useMemo(
    () => e.map((u) => t.isGreaterThan(u)).orDefault(!1),
    [e, t]
  );
  return {
    stakeAmountLessThanMin: i,
    stakeAmountGreaterThanMax: o,
    stakeAmountGreaterThanAvailableAmount: c,
    stakeAmountIsZero: s
  };
}, sZ = () => {
  const { network: e } = fr(), t = oM();
  return Qr({
    queryKey: f$({ network: e ?? void 0 }),
    queryFn: async () => (await lZ({ network: e, tokenGetTokens: t })).unsafeCoerce(),
    staleTime: 1e3 * 60 * 5
  });
}, P3e = (e) => Ye(
  () => e.queryClient.fetchQuery({
    queryKey: f$({
      network: e.network ?? void 0
    }),
    queryFn: async () => (await lZ(e)).unsafeCoerce()
  })
).mapLeft((t) => new Error("could not get multi yields")), lZ = ({
  network: e,
  tokenGetTokens: t
}) => Ye(() => t({ network: e ?? void 0 })).map(
  (n) => n.map((r) => ({ ...r, amount: "0" }))
), t3 = () => k.useCallback(
  ({
    defaultTokens: e,
    tokenBalancesScan: t
  }) => new Map([
    ...(e ?? []).map((n) => [as(n.token), n]),
    ...(t ?? []).map(
      (n) => [as(n.token), n]
    )
  ]),
  []
), cZ = () => {
  const e = UJ(), t = sZ();
  return t3()({
    defaultTokens: t.data ?? [],
    tokenBalancesScan: e.data ?? []
  });
}, N3e = () => {
  const e = pC(), t = tc(), n = cZ();
  return k.useCallback(
    ({ selectedToken: r }) => he.fromNullable(n.get(as(r))).chain(
      (i) => x3e({
        queryClient: t,
        yieldIds: i.availableYields
      }).map((o) => ({
        yields: o,
        availableAmount: new Nt(i.amount)
      }))
    ).chain(
      (i) => oZ({
        initQueryParams: he.fromNullable(e.data),
        yieldDtos: i.yields,
        tokenBalanceAmount: i.availableAmount
      })
    ),
    [e.data, t, n]
  );
}, uZ = ({
  additionalAddresses: e,
  address: t,
  network: n,
  queryClient: r,
  tokenGetTokens: i,
  tokenTokenBalancesScan: o
}) => Ye.fromPromise(
  () => Promise.all([
    P3e({ queryClient: r, network: n, tokenGetTokens: i }),
    Ye.liftEither(
      Pt({ additionalAddresses: e, address: t, network: n })
    ).chain(async (s) => !s.address || !s.network ? Pt([]) : ANe({
      queryClient: r,
      tokenTokenBalancesScan: o,
      tokenBalanceScanDto: {
        addresses: {
          address: s.address,
          additionalAddresses: s.additionalAddresses ?? void 0
        },
        network: s.network
      }
    }).mapLeft(() => new Error("could not get token balances scan")))
  ]).then(
    ([s, c]) => s.chain(
      (u) => c.map((f) => ({
        defaultTokens: u,
        tokenBalancesScan: f
      }))
    )
  )
).mapLeft(() => new Error("could not get tokens")), B3e = () => {
  const e = t3(), { isLedgerLive: t, isConnected: n, network: r, additionalAddresses: i, address: o } = fr(), s = tc(), c = ap(), u = oM(), f = aM(), { externalProviders: p } = dr();
  return Qr({
    staleTime: Number.POSITIVE_INFINITY,
    queryKey: [
      "init-token",
      n,
      r,
      o,
      i
    ],
    queryFn: async () => (await uZ({
      additionalAddresses: i,
      address: o,
      network: r,
      queryClient: s,
      tokenGetTokens: u,
      tokenTokenBalancesScan: f
    }).chain(
      (y) => gA({
        isLedgerLive: t,
        queryClient: s,
        yieldYieldOpportunity: c,
        externalProviders: p
      }).chain(
        (v) => Ye.liftEither(
          O3e({
            defaultTokens: y.defaultTokens,
            tokenBalances: y.tokenBalancesScan,
            initQueryParams: he.fromNullable(v)
          }).toEither(new Error("could not get initial token"))
        ).chain(
          (w) => Ye.liftEither(
            he.fromNullable(
              e(y).get(as(w))
            ).toEither(new Error("could not get token balance"))
          ).chain(
            (C) => rZ({
              isConnected: n,
              isLedgerLive: t,
              queryClient: s,
              yieldYieldOpportunity: c,
              network: r,
              yieldIds: C.availableYields
            })
          ).map(() => w)
        )
      )
    )).unsafeCoerce()
  });
}, L3e = ({
  selectedToken: e
}) => {
  const t = t3(), { isLedgerLive: n, isConnected: r, network: i, additionalAddresses: o, address: s } = fr(), c = tc(), u = ap(), f = oM(), p = aM(), { externalProviders: y } = dr();
  return Qr({
    staleTime: Number.POSITIVE_INFINITY,
    queryKey: [
      "init-yield",
      r,
      i,
      o,
      s,
      e.extract()
    ],
    queryFn: async () => (await Ye.liftEither(
      e.toEither(new Error("no token selected"))
    ).chain(
      (v) => uZ({
        additionalAddresses: o,
        address: s,
        network: i,
        queryClient: c,
        tokenGetTokens: f,
        tokenTokenBalancesScan: p
      }).chain(
        (w) => Ye.liftEither(
          he.fromNullable(
            t(w).get(as(v))
          ).toEither(new Error("could not get token balance"))
        )
      ).chain(
        (w) => gA({
          isLedgerLive: n,
          queryClient: c,
          yieldYieldOpportunity: u,
          externalProviders: y
        }).chain(
          (C) => rZ({
            isConnected: r,
            isLedgerLive: n,
            queryClient: c,
            yieldYieldOpportunity: u,
            network: i,
            yieldIds: w.availableYields
          }).chain(
            (x) => Ye.liftEither(
              oZ({
                initQueryParams: he.fromNullable(C),
                yieldDtos: x,
                tokenBalanceAmount: new Nt(w.amount)
              }).toEither(new Error("could not get initial yield"))
            )
          )
        )
      )
    )).unsafeCoerce()
  });
}, j3e = ({
  selectedToken: e
}) => {
  const t = cZ(), n = k.useMemo(
    () => e.chainNullable(
      (o) => t.get(as(o))
    ),
    [e, t]
  ), r = k.useMemo(
    () => n.map((o) => new Nt(o.amount)),
    [n]
  ), i = k.useMemo(
    () => n.map((o) => o.availableYields),
    [n]
  );
  return {
    availableAmount: r,
    availableYields: i,
    tokenBalance: n
  };
}, Az = ({
  yieldDto: e,
  initParams: t
}) => {
  var n, r;
  return {
    selectedStakeId: he.of(e.id),
    stakeAmount: f8(e),
    selectedValidators: D3e({
      initQueryParams: t,
      yieldDto: e
    }),
    tronResource: he.fromFalsy(
      (r = (n = e.args.enter.args) == null ? void 0 : n.tronResource) == null ? void 0 : r.required
    ).map(() => "ENERGY")
  };
}, dZ = k.createContext(
  void 0
), fZ = k.createContext(
  void 0
), hZ = k.createContext(!1), F3e = ({
  children: e
}) => /* @__PURE__ */ S.jsx(hZ.Provider, { value: !0, children: e }), Xk = () => ({
  selectedToken: he.empty(),
  selectedStakeId: he.empty(),
  selectedValidators: /* @__PURE__ */ new Map(),
  stakeAmount: new Nt(0),
  tronResource: he.empty()
}), U3e = ({ children: e }) => {
  var Ee;
  const t = pC(), { network: n, isConnected: r } = fr(), i = N3e(), o = (Se, Me) => {
    switch (Me.type) {
      case "token/select":
        return he.fromFalsy(
          Se.selectedToken.map((Fe) => !dA(Fe, Me.data)).orDefault(!0)
        ).chain(
          () => i({ selectedToken: Me.data }).map(
            (Fe) => Az({
              initParams: he.fromNullable(t.data),
              yieldDto: Fe
            })
          ).alt(he.of(null))
        ).map((Fe) => ({
          ...Xk(),
          selectedToken: he.of(Me.data),
          ...Fe
        })).orDefault(Se);
      case "yield/select":
        return he.fromFalsy(
          Se.selectedStakeId.map((Fe) => Fe !== Me.data.id).orDefault(!0)
        ).map(
          () => Az({
            initParams: he.fromNullable(t.data),
            yieldDto: Me.data
          })
        ).map((Fe) => ({
          ...Xk(),
          selectedToken: Se.selectedToken,
          ...Fe
        })).orDefault(Se);
      case "validator/select": {
        const Fe = /* @__PURE__ */ new Map();
        return Fe.set(Me.data.address, Me.data), {
          ...Se,
          selectedValidators: Fe
        };
      }
      case "validator/multiselect": {
        const Fe = new Map(Se.selectedValidators);
        return Fe.has(Me.data.address) ? Fe.delete(Me.data.address) : Fe.set(Me.data.address, Me.data), Fe.size === 0 ? Se : {
          ...Se,
          selectedValidators: Fe
        };
      }
      case "validator/remove": {
        const Fe = new Map(Se.selectedValidators);
        return Fe.delete(Me.data.address), {
          ...Se,
          selectedValidators: Fe
        };
      }
      case "stakeAmount/change":
        return {
          ...Se,
          stakeAmount: Me.data
        };
      case "stakeAmount/max":
        return {
          ...Se,
          stakeAmount: Me.data
        };
      case "tronResource/select":
        return { ...Se, tronResource: he.of(Me.data) };
      case "state/reset":
        return Xk();
      default:
        return Se;
    }
  }, [s, c] = k.useReducer(o, Xk()), {
    selectedToken: u,
    selectedStakeId: f,
    selectedValidators: p,
    stakeAmount: y,
    tronResource: v
  } = s, w = B3e(), C = k.useMemo(
    () => he.fromNullable(w.data),
    [w.data]
  ), x = L3e({ selectedToken: u }), A = k.useMemo(
    () => he.fromNullable(x.data),
    [x.data]
  ), { availableAmount: R, availableYields: I } = j3e({
    selectedToken: u
  }), D = nZ(I.orDefault([])), M = yA(f.extract()), { data: L } = CN(), { minEnterOrExitAmount: j, maxEnterOrExitAmount: F } = aZ({
    type: "enter",
    yieldOpportunity: he.fromNullable(M.data),
    availableAmount: R,
    positionsData: L
  }), O = k.useMemo(
    () => he.fromNullable(M.data),
    [M.data]
  ), z = e3({
    integration: O,
    type: "enter"
  }), H = k.useMemo(
    () => z ? F : y,
    [z, F, y]
  ), Q = k.useCallback(
    (Se) => c({ type: "token/select", data: Se }),
    []
  ), Y = k.useCallback(
    (Se) => c({ type: "yield/select", data: Se }),
    []
  );
  u.ifJust((Se) => {
    n && Se.network !== n && c({ type: "state/reset" });
  });
  const ee = Pr(u), ie = Pr(C), X = Pr(A), Z = !D.isLoading && ((Ee = D.data) == null ? void 0 : Ee.length) === 0 && C.isJust() && A.isNothing() && f.isNothing();
  k.useEffect(() => {
    !r && ee.current.isJust() && c({ type: "state/reset" });
  }, [ee, r]), k.useEffect(() => {
    C.ifJust(Q);
  }, [C, Q]), k.useEffect(() => {
    u.ifNothing(() => ie.current.ifJust(Q));
  }, [ie, u, Q]), k.useEffect(() => {
    A.ifJust(Y);
  }, [A, Y]), k.useEffect(() => {
    f.ifNothing(() => X.current.ifJust(Y));
  }, [X, f, Y]), k.useEffect(() => {
    C.ifNothing(
      () => u.ifJust(() => c({ type: "state/reset" }))
    );
  }, [C, u]);
  const J = k.useMemo(
    () => ({
      onMaxClick: () => c({ type: "stakeAmount/max", data: F })
    }),
    [F]
  ), {
    stakeAmountGreaterThanAvailableAmount: K,
    stakeAmountGreaterThanMax: oe,
    stakeAmountLessThanMin: be,
    stakeAmountIsZero: ce
  } = M3e({
    availableAmount: R,
    stakeAmount: H,
    maxEnterOrExitAmount: F,
    minEnterOrExitAmount: j
  }), pe = k.useMemo(
    () => ({
      selectedStakeId: f,
      selectedStake: O,
      selectedValidators: p,
      stakeAmount: H,
      actions: J,
      tronResource: v,
      stakeAmountGreaterThanAvailableAmount: K,
      stakeAmountGreaterThanMax: oe,
      stakeAmountLessThanMin: be,
      stakeAmountIsZero: ce,
      availableAmount: R,
      availableYields: I,
      selectedToken: u,
      hasNotYieldsForToken: Z
    }),
    [
      f,
      O,
      u,
      p,
      H,
      J,
      v,
      K,
      oe,
      be,
      ce,
      R,
      I,
      Z
    ]
  );
  return /* @__PURE__ */ S.jsx(dZ.Provider, { value: pe, children: /* @__PURE__ */ S.jsx(fZ.Provider, { value: c, children: e }) });
}, pZ = () => {
  if (!k.useContext(hZ))
    throw new Error("hook must be used withing EarnPageStateUsageBoundary");
}, mZ = () => {
  pZ();
  const e = k.useContext(dZ);
  if (e === void 0)
    throw new Error("useState must be used within a StateProvider");
  return e;
}, z3e = () => {
  pZ();
  const e = k.useContext(fZ);
  if (e === void 0)
    throw new Error("useDispatch must be used within a StateProvider");
  return e;
};
function yZ(e) {
  const t = e + "CollectionProvider", [n, r] = hy(t), [i, o] = n(
    t,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), s = (w) => {
    const { scope: C, children: x } = w, A = $.useRef(null), R = $.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ S.jsx(i, { scope: C, itemMap: R, collectionRef: A, children: x });
  };
  s.displayName = t;
  const c = e + "CollectionSlot", u = $.forwardRef(
    (w, C) => {
      const { scope: x, children: A } = w, R = o(c, x), I = Oo(C, R.collectionRef);
      return /* @__PURE__ */ S.jsx(bb, { ref: I, children: A });
    }
  );
  u.displayName = c;
  const f = e + "CollectionItemSlot", p = "data-radix-collection-item", y = $.forwardRef(
    (w, C) => {
      const { scope: x, children: A, ...R } = w, I = $.useRef(null), D = Oo(C, I), M = o(f, x);
      return $.useEffect(() => (M.itemMap.set(I, { ref: I, ...R }), () => void M.itemMap.delete(I))), /* @__PURE__ */ S.jsx(bb, { [p]: "", ref: D, children: A });
    }
  );
  y.displayName = f;
  function v(w) {
    const C = o(e + "CollectionConsumer", w);
    return $.useCallback(() => {
      const A = C.collectionRef.current;
      if (!A) return [];
      const R = Array.from(A.querySelectorAll(`[${p}]`));
      return Array.from(C.itemMap.values()).sort(
        (M, L) => R.indexOf(M.ref.current) - R.indexOf(L.ref.current)
      );
    }, [C.collectionRef, C.itemMap]);
  }
  return [
    { Provider: s, Slot: u, ItemSlot: y },
    v,
    r
  ];
}
var V3e = k.createContext(void 0);
function vZ(e) {
  const t = k.useContext(V3e);
  return e || t || "ltr";
}
var CI = "rovingFocusGroup.onEntryFocus", $3e = { bubbles: !1, cancelable: !0 }, tT = "RovingFocusGroup", [VD, gZ, H3e] = yZ(tT), [q3e, bZ] = hy(
  tT,
  [H3e]
), [W3e, G3e] = q3e(tT), wZ = k.forwardRef(
  (e, t) => /* @__PURE__ */ S.jsx(VD.Provider, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ S.jsx(VD.Slot, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ S.jsx(K3e, { ...e, ref: t }) }) })
);
wZ.displayName = tT;
var K3e = k.forwardRef((e, t) => {
  const {
    __scopeRovingFocusGroup: n,
    orientation: r,
    loop: i = !1,
    dir: o,
    currentTabStopId: s,
    defaultCurrentTabStopId: c,
    onCurrentTabStopIdChange: u,
    onEntryFocus: f,
    preventScrollOnEntryFocus: p = !1,
    ...y
  } = e, v = k.useRef(null), w = Oo(t, v), C = vZ(o), [x = null, A] = LA({
    prop: s,
    defaultProp: c,
    onChange: u
  }), [R, I] = k.useState(!1), D = $c(f), M = gZ(n), L = k.useRef(!1), [j, F] = k.useState(0);
  return k.useEffect(() => {
    const O = v.current;
    if (O)
      return O.addEventListener(CI, D), () => O.removeEventListener(CI, D);
  }, [D]), /* @__PURE__ */ S.jsx(
    W3e,
    {
      scope: n,
      orientation: r,
      dir: C,
      loop: i,
      currentTabStopId: x,
      onItemFocus: k.useCallback(
        (O) => A(O),
        [A]
      ),
      onItemShiftTab: k.useCallback(() => I(!0), []),
      onFocusableItemAdd: k.useCallback(
        () => F((O) => O + 1),
        []
      ),
      onFocusableItemRemove: k.useCallback(
        () => F((O) => O - 1),
        []
      ),
      children: /* @__PURE__ */ S.jsx(
        Li.div,
        {
          tabIndex: R || j === 0 ? -1 : 0,
          "data-orientation": r,
          ...y,
          ref: w,
          style: { outline: "none", ...e.style },
          onMouseDown: Ln(e.onMouseDown, () => {
            L.current = !0;
          }),
          onFocus: Ln(e.onFocus, (O) => {
            const z = !L.current;
            if (O.target === O.currentTarget && z && !R) {
              const H = new CustomEvent(CI, $3e);
              if (O.currentTarget.dispatchEvent(H), !H.defaultPrevented) {
                const Q = M().filter((Z) => Z.focusable), Y = Q.find((Z) => Z.active), ee = Q.find((Z) => Z.id === x), X = [Y, ee, ...Q].filter(
                  Boolean
                ).map((Z) => Z.ref.current);
                EZ(X, p);
              }
            }
            L.current = !1;
          }),
          onBlur: Ln(e.onBlur, () => I(!1))
        }
      )
    }
  );
}), CZ = "RovingFocusGroupItem", xZ = k.forwardRef(
  (e, t) => {
    const {
      __scopeRovingFocusGroup: n,
      focusable: r = !0,
      active: i = !1,
      tabStopId: o,
      ...s
    } = e, c = Hm(), u = o || c, f = G3e(CZ, n), p = f.currentTabStopId === u, y = gZ(n), { onFocusableItemAdd: v, onFocusableItemRemove: w } = f;
    return k.useEffect(() => {
      if (r)
        return v(), () => w();
    }, [r, v, w]), /* @__PURE__ */ S.jsx(
      VD.ItemSlot,
      {
        scope: n,
        id: u,
        focusable: r,
        active: i,
        children: /* @__PURE__ */ S.jsx(
          Li.span,
          {
            tabIndex: p ? 0 : -1,
            "data-orientation": f.orientation,
            ...s,
            ref: t,
            onMouseDown: Ln(e.onMouseDown, (C) => {
              r ? f.onItemFocus(u) : C.preventDefault();
            }),
            onFocus: Ln(e.onFocus, () => f.onItemFocus(u)),
            onKeyDown: Ln(e.onKeyDown, (C) => {
              if (C.key === "Tab" && C.shiftKey) {
                f.onItemShiftTab();
                return;
              }
              if (C.target !== C.currentTarget) return;
              const x = X3e(C, f.orientation, f.dir);
              if (x !== void 0) {
                if (C.metaKey || C.ctrlKey || C.altKey || C.shiftKey) return;
                C.preventDefault();
                let R = y().filter((I) => I.focusable).map((I) => I.ref.current);
                if (x === "last") R.reverse();
                else if (x === "prev" || x === "next") {
                  x === "prev" && R.reverse();
                  const I = R.indexOf(C.currentTarget);
                  R = f.loop ? J3e(R, I + 1) : R.slice(I + 1);
                }
                setTimeout(() => EZ(R));
              }
            })
          }
        )
      }
    );
  }
);
xZ.displayName = CZ;
var Y3e = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function Q3e(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function X3e(e, t, n) {
  const r = Q3e(e.key, n);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
    return Y3e[r];
}
function EZ(e, t = !1) {
  const n = document.activeElement;
  for (const r of e)
    if (r === n || (r.focus({ preventScroll: t }), document.activeElement !== n)) return;
}
function J3e(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
var Z3e = wZ, eBe = xZ, $D = ["Enter", " "], tBe = ["ArrowDown", "PageUp", "Home"], SZ = ["ArrowUp", "PageDown", "End"], nBe = [...tBe, ...SZ], rBe = {
  ltr: [...$D, "ArrowRight"],
  rtl: [...$D, "ArrowLeft"]
}, iBe = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
}, Cx = "Menu", [AC, oBe, aBe] = yZ(Cx), [my, kZ] = hy(Cx, [
  aBe,
  WA,
  bZ
]), nT = WA(), AZ = bZ(), [sBe, Qb] = my(Cx), [lBe, xx] = my(Cx), TZ = (e) => {
  const { __scopeMenu: t, open: n = !1, children: r, dir: i, onOpenChange: o, modal: s = !0 } = e, c = nT(t), [u, f] = k.useState(null), p = k.useRef(!1), y = $c(o), v = vZ(i);
  return k.useEffect(() => {
    const w = () => {
      p.current = !0, document.addEventListener("pointerdown", C, { capture: !0, once: !0 }), document.addEventListener("pointermove", C, { capture: !0, once: !0 });
    }, C = () => p.current = !1;
    return document.addEventListener("keydown", w, { capture: !0 }), () => {
      document.removeEventListener("keydown", w, { capture: !0 }), document.removeEventListener("pointerdown", C, { capture: !0 }), document.removeEventListener("pointermove", C, { capture: !0 });
    };
  }, []), /* @__PURE__ */ S.jsx(JX, { ...c, children: /* @__PURE__ */ S.jsx(
    sBe,
    {
      scope: t,
      open: n,
      onOpenChange: y,
      content: u,
      onContentChange: f,
      children: /* @__PURE__ */ S.jsx(
        lBe,
        {
          scope: t,
          onClose: k.useCallback(() => y(!1), [y]),
          isUsingKeyboardRef: p,
          dir: v,
          modal: s,
          children: r
        }
      )
    }
  ) });
};
TZ.displayName = Cx;
var cBe = "MenuAnchor", n3 = k.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e, i = nT(n);
    return /* @__PURE__ */ S.jsx(ZX, { ...i, ...r, ref: t });
  }
);
n3.displayName = cBe;
var uBe = "MenuPortal", [Fje, _Z] = my(uBe, {
  forceMount: void 0
}), Yl = "MenuContent", [dBe, r3] = my(Yl), RZ = k.forwardRef(
  (e, t) => {
    const n = _Z(Yl, e.__scopeMenu), { forceMount: r = n.forceMount, ...i } = e, o = Qb(Yl, e.__scopeMenu), s = xx(Yl, e.__scopeMenu);
    return /* @__PURE__ */ S.jsx(AC.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ S.jsx(uf, { present: r || o.open, children: /* @__PURE__ */ S.jsx(AC.Slot, { scope: e.__scopeMenu, children: s.modal ? /* @__PURE__ */ S.jsx(fBe, { ...i, ref: t }) : /* @__PURE__ */ S.jsx(hBe, { ...i, ref: t }) }) }) });
  }
), fBe = k.forwardRef(
  (e, t) => {
    const n = Qb(Yl, e.__scopeMenu), r = k.useRef(null), i = Oo(t, r);
    return k.useEffect(() => {
      const o = r.current;
      if (o) return BQ(o);
    }, []), /* @__PURE__ */ S.jsx(
      i3,
      {
        ...e,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: n.open,
        disableOutsideScroll: !0,
        onFocusOutside: Ln(
          e.onFocusOutside,
          (o) => o.preventDefault(),
          { checkForDefaultPrevented: !1 }
        ),
        onDismiss: () => n.onOpenChange(!1)
      }
    );
  }
), hBe = k.forwardRef((e, t) => {
  const n = Qb(Yl, e.__scopeMenu);
  return /* @__PURE__ */ S.jsx(
    i3,
    {
      ...e,
      ref: t,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => n.onOpenChange(!1)
    }
  );
}), i3 = k.forwardRef(
  (e, t) => {
    const {
      __scopeMenu: n,
      loop: r = !1,
      trapFocus: i,
      onOpenAutoFocus: o,
      onCloseAutoFocus: s,
      disableOutsidePointerEvents: c,
      onEntryFocus: u,
      onEscapeKeyDown: f,
      onPointerDownOutside: p,
      onFocusOutside: y,
      onInteractOutside: v,
      onDismiss: w,
      disableOutsideScroll: C,
      ...x
    } = e, A = Qb(Yl, n), R = xx(Yl, n), I = nT(n), D = AZ(n), M = oBe(n), [L, j] = k.useState(null), F = k.useRef(null), O = Oo(t, F, A.onContentChange), z = k.useRef(0), H = k.useRef(""), Q = k.useRef(0), Y = k.useRef(null), ee = k.useRef("right"), ie = k.useRef(0), X = C ? J8 : k.Fragment, Z = C ? { as: bb, allowPinchZoom: !0 } : void 0, J = (oe) => {
      var st, mt;
      const be = H.current + oe, ce = M().filter((yt) => !yt.disabled), pe = document.activeElement, Ee = (st = ce.find((yt) => yt.ref.current === pe)) == null ? void 0 : st.textValue, Se = ce.map((yt) => yt.textValue), Me = kBe(Se, be, Ee), Fe = (mt = ce.find((yt) => yt.textValue === Me)) == null ? void 0 : mt.ref.current;
      (function yt(Ut) {
        H.current = Ut, window.clearTimeout(z.current), Ut !== "" && (z.current = window.setTimeout(() => yt(""), 1e3));
      })(be), Fe && setTimeout(() => Fe.focus());
    };
    k.useEffect(() => () => window.clearTimeout(z.current), []), PQ();
    const K = k.useCallback((oe) => {
      var ce, pe;
      return ee.current === ((ce = Y.current) == null ? void 0 : ce.side) && TBe(oe, (pe = Y.current) == null ? void 0 : pe.area);
    }, []);
    return /* @__PURE__ */ S.jsx(
      dBe,
      {
        scope: n,
        searchRef: H,
        onItemEnter: k.useCallback(
          (oe) => {
            K(oe) && oe.preventDefault();
          },
          [K]
        ),
        onItemLeave: k.useCallback(
          (oe) => {
            var be;
            K(oe) || ((be = F.current) == null || be.focus(), j(null));
          },
          [K]
        ),
        onTriggerLeave: k.useCallback(
          (oe) => {
            K(oe) && oe.preventDefault();
          },
          [K]
        ),
        pointerGraceTimerRef: Q,
        onPointerGraceIntentChange: k.useCallback((oe) => {
          Y.current = oe;
        }, []),
        children: /* @__PURE__ */ S.jsx(X, { ...Z, children: /* @__PURE__ */ S.jsx(
          fN,
          {
            asChild: !0,
            trapped: i,
            onMountAutoFocus: Ln(o, (oe) => {
              var be;
              oe.preventDefault(), (be = F.current) == null || be.focus({ preventScroll: !0 });
            }),
            onUnmountAutoFocus: s,
            children: /* @__PURE__ */ S.jsx(
              jA,
              {
                asChild: !0,
                disableOutsidePointerEvents: c,
                onEscapeKeyDown: f,
                onPointerDownOutside: p,
                onFocusOutside: y,
                onInteractOutside: v,
                onDismiss: w,
                children: /* @__PURE__ */ S.jsx(
                  Z3e,
                  {
                    asChild: !0,
                    ...D,
                    dir: R.dir,
                    orientation: "vertical",
                    loop: r,
                    currentTabStopId: L,
                    onCurrentTabStopIdChange: j,
                    onEntryFocus: Ln(u, (oe) => {
                      R.isUsingKeyboardRef.current || oe.preventDefault();
                    }),
                    preventScrollOnEntryFocus: !0,
                    children: /* @__PURE__ */ S.jsx(
                      eJ,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": qZ(A.open),
                        "data-radix-menu-content": "",
                        dir: R.dir,
                        ...I,
                        ...x,
                        ref: O,
                        style: { outline: "none", ...x.style },
                        onKeyDown: Ln(x.onKeyDown, (oe) => {
                          const ce = oe.target.closest("[data-radix-menu-content]") === oe.currentTarget, pe = oe.ctrlKey || oe.altKey || oe.metaKey, Ee = oe.key.length === 1;
                          ce && (oe.key === "Tab" && oe.preventDefault(), !pe && Ee && J(oe.key));
                          const Se = F.current;
                          if (oe.target !== Se || !nBe.includes(oe.key)) return;
                          oe.preventDefault();
                          const Fe = M().filter((st) => !st.disabled).map((st) => st.ref.current);
                          SZ.includes(oe.key) && Fe.reverse(), EBe(Fe);
                        }),
                        onBlur: Ln(e.onBlur, (oe) => {
                          oe.currentTarget.contains(oe.target) || (window.clearTimeout(z.current), H.current = "");
                        }),
                        onPointerMove: Ln(
                          e.onPointerMove,
                          TC((oe) => {
                            const be = oe.target, ce = ie.current !== oe.clientX;
                            if (oe.currentTarget.contains(be) && ce) {
                              const pe = oe.clientX > ie.current ? "right" : "left";
                              ee.current = pe, ie.current = oe.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
RZ.displayName = Yl;
var pBe = "MenuGroup", o3 = k.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ S.jsx(Li.div, { role: "group", ...r, ref: t });
  }
);
o3.displayName = pBe;
var mBe = "MenuLabel", OZ = k.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ S.jsx(Li.div, { ...r, ref: t });
  }
);
OZ.displayName = mBe;
var h8 = "MenuItem", Tz = "menu.itemSelect", rT = k.forwardRef(
  (e, t) => {
    const { disabled: n = !1, onSelect: r, ...i } = e, o = k.useRef(null), s = xx(h8, e.__scopeMenu), c = r3(h8, e.__scopeMenu), u = Oo(t, o), f = k.useRef(!1), p = () => {
      const y = o.current;
      if (!n && y) {
        const v = new CustomEvent(Tz, { bubbles: !0, cancelable: !0 });
        y.addEventListener(Tz, (w) => r == null ? void 0 : r(w), { once: !0 }), OQ(y, v), v.defaultPrevented ? f.current = !1 : s.onClose();
      }
    };
    return /* @__PURE__ */ S.jsx(
      IZ,
      {
        ...i,
        ref: u,
        disabled: n,
        onClick: Ln(e.onClick, p),
        onPointerDown: (y) => {
          var v;
          (v = e.onPointerDown) == null || v.call(e, y), f.current = !0;
        },
        onPointerUp: Ln(e.onPointerUp, (y) => {
          var v;
          f.current || (v = y.currentTarget) == null || v.click();
        }),
        onKeyDown: Ln(e.onKeyDown, (y) => {
          const v = c.searchRef.current !== "";
          n || v && y.key === " " || $D.includes(y.key) && (y.currentTarget.click(), y.preventDefault());
        })
      }
    );
  }
);
rT.displayName = h8;
var IZ = k.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, disabled: r = !1, textValue: i, ...o } = e, s = r3(h8, n), c = AZ(n), u = k.useRef(null), f = Oo(t, u), [p, y] = k.useState(!1), [v, w] = k.useState("");
    return k.useEffect(() => {
      const C = u.current;
      C && w((C.textContent ?? "").trim());
    }, [o.children]), /* @__PURE__ */ S.jsx(
      AC.ItemSlot,
      {
        scope: n,
        disabled: r,
        textValue: i ?? v,
        children: /* @__PURE__ */ S.jsx(eBe, { asChild: !0, ...c, focusable: !r, children: /* @__PURE__ */ S.jsx(
          Li.div,
          {
            role: "menuitem",
            "data-highlighted": p ? "" : void 0,
            "aria-disabled": r || void 0,
            "data-disabled": r ? "" : void 0,
            ...o,
            ref: f,
            onPointerMove: Ln(
              e.onPointerMove,
              TC((C) => {
                r ? s.onItemLeave(C) : (s.onItemEnter(C), C.defaultPrevented || C.currentTarget.focus({ preventScroll: !0 }));
              })
            ),
            onPointerLeave: Ln(
              e.onPointerLeave,
              TC((C) => s.onItemLeave(C))
            ),
            onFocus: Ln(e.onFocus, () => y(!0)),
            onBlur: Ln(e.onBlur, () => y(!1))
          }
        ) })
      }
    );
  }
), yBe = "MenuCheckboxItem", DZ = k.forwardRef(
  (e, t) => {
    const { checked: n = !1, onCheckedChange: r, ...i } = e;
    return /* @__PURE__ */ S.jsx(LZ, { scope: e.__scopeMenu, checked: n, children: /* @__PURE__ */ S.jsx(
      rT,
      {
        role: "menuitemcheckbox",
        "aria-checked": p8(n) ? "mixed" : n,
        ...i,
        ref: t,
        "data-state": s3(n),
        onSelect: Ln(
          i.onSelect,
          () => r == null ? void 0 : r(p8(n) ? !0 : !n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
DZ.displayName = yBe;
var MZ = "MenuRadioGroup", [vBe, gBe] = my(
  MZ,
  { value: void 0, onValueChange: () => {
  } }
), PZ = k.forwardRef(
  (e, t) => {
    const { value: n, onValueChange: r, ...i } = e, o = $c(r);
    return /* @__PURE__ */ S.jsx(vBe, { scope: e.__scopeMenu, value: n, onValueChange: o, children: /* @__PURE__ */ S.jsx(o3, { ...i, ref: t }) });
  }
);
PZ.displayName = MZ;
var NZ = "MenuRadioItem", BZ = k.forwardRef(
  (e, t) => {
    const { value: n, ...r } = e, i = gBe(NZ, e.__scopeMenu), o = n === i.value;
    return /* @__PURE__ */ S.jsx(LZ, { scope: e.__scopeMenu, checked: o, children: /* @__PURE__ */ S.jsx(
      rT,
      {
        role: "menuitemradio",
        "aria-checked": o,
        ...r,
        ref: t,
        "data-state": s3(o),
        onSelect: Ln(
          r.onSelect,
          () => {
            var s;
            return (s = i.onValueChange) == null ? void 0 : s.call(i, n);
          },
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
BZ.displayName = NZ;
var a3 = "MenuItemIndicator", [LZ, bBe] = my(
  a3,
  { checked: !1 }
), jZ = k.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, forceMount: r, ...i } = e, o = bBe(a3, n);
    return /* @__PURE__ */ S.jsx(
      uf,
      {
        present: r || p8(o.checked) || o.checked === !0,
        children: /* @__PURE__ */ S.jsx(
          Li.span,
          {
            ...i,
            ref: t,
            "data-state": s3(o.checked)
          }
        )
      }
    );
  }
);
jZ.displayName = a3;
var wBe = "MenuSeparator", FZ = k.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ S.jsx(
      Li.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...r,
        ref: t
      }
    );
  }
);
FZ.displayName = wBe;
var CBe = "MenuArrow", UZ = k.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e, i = nT(n);
    return /* @__PURE__ */ S.jsx(tJ, { ...i, ...r, ref: t });
  }
);
UZ.displayName = CBe;
var xBe = "MenuSub", [Uje, zZ] = my(xBe), O1 = "MenuSubTrigger", VZ = k.forwardRef(
  (e, t) => {
    const n = Qb(O1, e.__scopeMenu), r = xx(O1, e.__scopeMenu), i = zZ(O1, e.__scopeMenu), o = r3(O1, e.__scopeMenu), s = k.useRef(null), { pointerGraceTimerRef: c, onPointerGraceIntentChange: u } = o, f = { __scopeMenu: e.__scopeMenu }, p = k.useCallback(() => {
      s.current && window.clearTimeout(s.current), s.current = null;
    }, []);
    return k.useEffect(() => p, [p]), k.useEffect(() => {
      const y = c.current;
      return () => {
        window.clearTimeout(y), u(null);
      };
    }, [c, u]), /* @__PURE__ */ S.jsx(n3, { asChild: !0, ...f, children: /* @__PURE__ */ S.jsx(
      IZ,
      {
        id: i.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": n.open,
        "aria-controls": i.contentId,
        "data-state": qZ(n.open),
        ...e,
        ref: BA(t, i.onTriggerChange),
        onClick: (y) => {
          var v;
          (v = e.onClick) == null || v.call(e, y), !(e.disabled || y.defaultPrevented) && (y.currentTarget.focus(), n.open || n.onOpenChange(!0));
        },
        onPointerMove: Ln(
          e.onPointerMove,
          TC((y) => {
            o.onItemEnter(y), !y.defaultPrevented && !e.disabled && !n.open && !s.current && (o.onPointerGraceIntentChange(null), s.current = window.setTimeout(() => {
              n.onOpenChange(!0), p();
            }, 100));
          })
        ),
        onPointerLeave: Ln(
          e.onPointerLeave,
          TC((y) => {
            var w, C;
            p();
            const v = (w = n.content) == null ? void 0 : w.getBoundingClientRect();
            if (v) {
              const x = (C = n.content) == null ? void 0 : C.dataset.side, A = x === "right", R = A ? -5 : 5, I = v[A ? "left" : "right"], D = v[A ? "right" : "left"];
              o.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: y.clientX + R, y: y.clientY },
                  { x: I, y: v.top },
                  { x: D, y: v.top },
                  { x: D, y: v.bottom },
                  { x: I, y: v.bottom }
                ],
                side: x
              }), window.clearTimeout(c.current), c.current = window.setTimeout(
                () => o.onPointerGraceIntentChange(null),
                300
              );
            } else {
              if (o.onTriggerLeave(y), y.defaultPrevented) return;
              o.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: Ln(e.onKeyDown, (y) => {
          var w;
          const v = o.searchRef.current !== "";
          e.disabled || v && y.key === " " || rBe[r.dir].includes(y.key) && (n.onOpenChange(!0), (w = n.content) == null || w.focus(), y.preventDefault());
        })
      }
    ) });
  }
);
VZ.displayName = O1;
var $Z = "MenuSubContent", HZ = k.forwardRef(
  (e, t) => {
    const n = _Z(Yl, e.__scopeMenu), { forceMount: r = n.forceMount, ...i } = e, o = Qb(Yl, e.__scopeMenu), s = xx(Yl, e.__scopeMenu), c = zZ($Z, e.__scopeMenu), u = k.useRef(null), f = Oo(t, u);
    return /* @__PURE__ */ S.jsx(AC.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ S.jsx(uf, { present: r || o.open, children: /* @__PURE__ */ S.jsx(AC.Slot, { scope: e.__scopeMenu, children: /* @__PURE__ */ S.jsx(
      i3,
      {
        id: c.contentId,
        "aria-labelledby": c.triggerId,
        ...i,
        ref: f,
        align: "start",
        side: s.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        trapFocus: !1,
        onOpenAutoFocus: (p) => {
          var y;
          s.isUsingKeyboardRef.current && ((y = u.current) == null || y.focus()), p.preventDefault();
        },
        onCloseAutoFocus: (p) => p.preventDefault(),
        onFocusOutside: Ln(e.onFocusOutside, (p) => {
          p.target !== c.trigger && o.onOpenChange(!1);
        }),
        onEscapeKeyDown: Ln(e.onEscapeKeyDown, (p) => {
          s.onClose(), p.preventDefault();
        }),
        onKeyDown: Ln(e.onKeyDown, (p) => {
          var w;
          const y = p.currentTarget.contains(p.target), v = iBe[s.dir].includes(p.key);
          y && v && (o.onOpenChange(!1), (w = c.trigger) == null || w.focus(), p.preventDefault());
        })
      }
    ) }) }) });
  }
);
HZ.displayName = $Z;
function qZ(e) {
  return e ? "open" : "closed";
}
function p8(e) {
  return e === "indeterminate";
}
function s3(e) {
  return p8(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
function EBe(e) {
  const t = document.activeElement;
  for (const n of e)
    if (n === t || (n.focus(), document.activeElement !== t)) return;
}
function SBe(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
function kBe(e, t, n) {
  const i = t.length > 1 && Array.from(t).every((f) => f === t[0]) ? t[0] : t, o = n ? e.indexOf(n) : -1;
  let s = SBe(e, Math.max(o, 0));
  i.length === 1 && (s = s.filter((f) => f !== n));
  const u = s.find(
    (f) => f.toLowerCase().startsWith(i.toLowerCase())
  );
  return u !== n ? u : void 0;
}
function ABe(e, t) {
  const { x: n, y: r } = e;
  let i = !1;
  for (let o = 0, s = t.length - 1; o < t.length; s = o++) {
    const c = t[o].x, u = t[o].y, f = t[s].x, p = t[s].y;
    u > r != p > r && n < (f - c) * (r - u) / (p - u) + c && (i = !i);
  }
  return i;
}
function TBe(e, t) {
  if (!t) return !1;
  const n = { x: e.clientX, y: e.clientY };
  return ABe(n, t);
}
function TC(e) {
  return (t) => t.pointerType === "mouse" ? e(t) : void 0;
}
var _Be = TZ, RBe = n3, OBe = RZ, IBe = o3, DBe = OZ, MBe = rT, PBe = DZ, NBe = PZ, BBe = BZ, LBe = jZ, jBe = FZ, FBe = UZ, UBe = VZ, zBe = HZ, l3 = "DropdownMenu", [VBe, zje] = hy(
  l3,
  [kZ]
), Ws = kZ(), [$Be, WZ] = VBe(l3), GZ = (e) => {
  const {
    __scopeDropdownMenu: t,
    children: n,
    dir: r,
    open: i,
    defaultOpen: o,
    onOpenChange: s,
    modal: c = !0
  } = e, u = Ws(t), f = k.useRef(null), [p = !1, y] = LA({
    prop: i,
    defaultProp: o,
    onChange: s
  });
  return /* @__PURE__ */ S.jsx(
    $Be,
    {
      scope: t,
      triggerId: Hm(),
      triggerRef: f,
      contentId: Hm(),
      open: p,
      onOpenChange: y,
      onOpenToggle: k.useCallback(() => y((v) => !v), [y]),
      modal: c,
      children: /* @__PURE__ */ S.jsx(_Be, { ...u, open: p, onOpenChange: y, dir: r, modal: c, children: n })
    }
  );
};
GZ.displayName = l3;
var KZ = "DropdownMenuTrigger", YZ = k.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, disabled: r = !1, ...i } = e, o = WZ(KZ, n), s = Ws(n);
    return /* @__PURE__ */ S.jsx(RBe, { asChild: !0, ...s, children: /* @__PURE__ */ S.jsx(
      Li.button,
      {
        type: "button",
        id: o.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": o.open,
        "aria-controls": o.open ? o.contentId : void 0,
        "data-state": o.open ? "open" : "closed",
        "data-disabled": r ? "" : void 0,
        disabled: r,
        ...i,
        ref: BA(t, o.triggerRef),
        onPointerDown: Ln(e.onPointerDown, (c) => {
          !r && c.button === 0 && c.ctrlKey === !1 && (o.onOpenToggle(), o.open || c.preventDefault());
        }),
        onKeyDown: Ln(e.onKeyDown, (c) => {
          r || (["Enter", " "].includes(c.key) && o.onOpenToggle(), c.key === "ArrowDown" && o.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(c.key) && c.preventDefault());
        })
      }
    ) });
  }
);
YZ.displayName = KZ;
var QZ = "DropdownMenuContent", XZ = k.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = WZ(QZ, n), o = Ws(n), s = k.useRef(!1);
    return /* @__PURE__ */ S.jsx(
      OBe,
      {
        id: i.contentId,
        "aria-labelledby": i.triggerId,
        ...o,
        ...r,
        ref: t,
        onCloseAutoFocus: Ln(e.onCloseAutoFocus, (c) => {
          var u;
          s.current || (u = i.triggerRef.current) == null || u.focus(), s.current = !1, c.preventDefault();
        }),
        onInteractOutside: Ln(e.onInteractOutside, (c) => {
          const u = c.detail.originalEvent, f = u.button === 0 && u.ctrlKey === !0, p = u.button === 2 || f;
          (!i.modal || p) && (s.current = !0);
        }),
        style: {
          ...e.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
XZ.displayName = QZ;
var HBe = "DropdownMenuGroup", qBe = k.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = Ws(n);
    return /* @__PURE__ */ S.jsx(IBe, { ...i, ...r, ref: t });
  }
);
qBe.displayName = HBe;
var WBe = "DropdownMenuLabel", GBe = k.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = Ws(n);
    return /* @__PURE__ */ S.jsx(DBe, { ...i, ...r, ref: t });
  }
);
GBe.displayName = WBe;
var KBe = "DropdownMenuItem", YBe = k.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = Ws(n);
    return /* @__PURE__ */ S.jsx(MBe, { ...i, ...r, ref: t });
  }
);
YBe.displayName = KBe;
var QBe = "DropdownMenuCheckboxItem", XBe = k.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = Ws(n);
  return /* @__PURE__ */ S.jsx(PBe, { ...i, ...r, ref: t });
});
XBe.displayName = QBe;
var JBe = "DropdownMenuRadioGroup", JZ = k.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = Ws(n);
  return /* @__PURE__ */ S.jsx(NBe, { ...i, ...r, ref: t });
});
JZ.displayName = JBe;
var ZBe = "DropdownMenuRadioItem", ZZ = k.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = Ws(n);
  return /* @__PURE__ */ S.jsx(BBe, { ...i, ...r, ref: t });
});
ZZ.displayName = ZBe;
var e6e = "DropdownMenuItemIndicator", t6e = k.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = Ws(n);
  return /* @__PURE__ */ S.jsx(LBe, { ...i, ...r, ref: t });
});
t6e.displayName = e6e;
var n6e = "DropdownMenuSeparator", eee = k.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = Ws(n);
  return /* @__PURE__ */ S.jsx(jBe, { ...i, ...r, ref: t });
});
eee.displayName = n6e;
var r6e = "DropdownMenuArrow", i6e = k.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = Ws(n);
    return /* @__PURE__ */ S.jsx(FBe, { ...i, ...r, ref: t });
  }
);
i6e.displayName = r6e;
var o6e = "DropdownMenuSubTrigger", a6e = k.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = Ws(n);
  return /* @__PURE__ */ S.jsx(UBe, { ...i, ...r, ref: t });
});
a6e.displayName = o6e;
var s6e = "DropdownMenuSubContent", l6e = k.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = Ws(n);
  return /* @__PURE__ */ S.jsx(
    zBe,
    {
      ...i,
      ...r,
      ref: t,
      style: {
        ...e.style,
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
l6e.displayName = s6e;
var c6e = GZ, u6e = YZ, d6e = XZ, f6e = JZ, h6e = ZZ, p6e = eee, m6e = "_12si65s1 _12si65s0 yv8y4re3 yv8y4rcl yv8y4r9j yv8y4rb1 yv8y4rw9 yv8y4rwa", y6e = "_12si65s3 _12si65s2 yv8y4rw9 yv8y4rwa", v6e = "_12si65s4", g6e = "_12si65s6 _12si65s5 yv8y4re7 yv8y4rcp yv8y4r9j yv8y4rb1 yv8y4r2n yv8y4rfj", b6e = "_12si65s8 _12si65s7 yv8y4rvr yv8y4rvs";
function w6e({
  options: e,
  onSelect: t,
  selectedOption: n,
  placeholder: r,
  isError: i
}) {
  return /* @__PURE__ */ S.jsxs(c6e, { children: [
    /* @__PURE__ */ S.jsx(u6e, { children: /* @__PURE__ */ S.jsxs(
      ae,
      {
        className: m6e,
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        gap: "2",
        borderStyle: "solid",
        borderColor: i ? "textDanger" : "transparent",
        borderWidth: 1,
        children: [
          /* @__PURE__ */ S.jsx(Ge, { children: (n == null ? void 0 : n.label) ?? r }),
          /* @__PURE__ */ S.jsx(fy, {})
        ]
      }
    ) }),
    /* @__PURE__ */ S.jsx(
      d6e,
      {
        className: y6e,
        sideOffset: 3,
        align: "start",
        children: /* @__PURE__ */ S.jsx(
          f6e,
          {
            className: v6e,
            value: n == null ? void 0 : n.value,
            onValueChange: t,
            children: e.map((o, s) => /* @__PURE__ */ S.jsxs(k.Fragment, { children: [
              /* @__PURE__ */ S.jsx(
                h6e,
                {
                  className: g6e,
                  value: o.value,
                  children: /* @__PURE__ */ S.jsx(Ge, { children: o.label })
                }
              ),
              s < e.length - 1 && /* @__PURE__ */ S.jsx(p6e, { className: b6e })
            ] }, o.value))
          }
        )
      }
    )
  ] });
}
const C6e = () => {
  const e = La(), { disableAutoScrollToTop: t } = dr();
  return k.useCallback(
    (n, r) => (t || window.scrollTo(0, 0), e(n, r)),
    [e, t]
  );
}, tee = ({
  selectedStake: e,
  stakeAmount: t,
  selectedValidators: n
}) => {
  const r = cf({
    integrationData: e,
    validatorsAddresses: he.of(n)
  });
  return k.useMemo(
    () => he.fromRecord({ providersDetails: r, selectedStake: e }).map((i) => ({
      ...i,
      rewardRateAverage: i.providersDetails.reduce(
        (o, s) => o.plus(new Nt(s.rewardRate ?? 0)),
        new Nt(0)
      ).dividedBy(i.providersDetails.length)
    })).map((i) => ({
      percentage: Hh({
        rewardRate: i.rewardRateAverage.toNumber(),
        rewardType: i.selectedStake.rewardType
      }),
      yearly: i.rewardRateAverage.isGreaterThan(0) ? To(
        t.times(i.rewardRateAverage).decimalPlaces(5)
      ) : "-",
      monthly: i.rewardRateAverage.isGreaterThan(0) ? To(
        t.times(i.rewardRateAverage).dividedBy(12).decimalPlaces(5)
      ) : "-"
    })),
    [r, e, t]
  );
}, nee = (e) => k.useMemo(
  () => e.chain(
    (t) => he.fromNullable(t.metadata.rewardTokens).chain(
      (n) => he.fromNullable(t.metadata.provider).map((r) => ({ rt: n, p: r }))
    )
  ).map(({ p: t, rt: n }) => ({
    logoUri: t.logoURI ?? null,
    rewardTokens: n,
    symbols: jN(n),
    providerName: t.name ?? null
  })),
  [e]
), x6e = () => {
  var f;
  const {
    selectedStake: e,
    stakeAmount: t,
    selectedValidators: n,
    tronResource: r,
    selectedToken: i
  } = mZ(), { address: o, additionalAddresses: s, isLedgerLive: c } = fr(), u = XA();
  return k.useMemo(
    () => he.fromRecord({
      address: he.fromNullable(o),
      selectedStake: e,
      selectedToken: i
    }).map((p) => {
      var v;
      const y = _n(p.selectedStake).chain((w) => {
        var x, A;
        const C = [...n.values()];
        return w.metadata.isIntegrationAggregator ? Wn.head(C).map((R) => ({
          providerId: R.providerId
        })) : (A = (x = w.args.enter.args) == null ? void 0 : x.validatorAddresses) != null && A.required ? _n({
          validatorAddresses: C.map((R) => R.address)
        }) : Wn.head(C).map((R) => R.address).map((R) => ({ validatorAddress: R }));
      }).orDefault({});
      return {
        selectedValidators: n,
        selectedStake: p.selectedStake,
        gasFeeToken: p.selectedStake.metadata.gasFeeToken,
        dto: {
          addresses: {
            address: p.address,
            additionalAddresses: s ?? void 0
          },
          integrationId: p.selectedStake.id,
          referralCode: (v = u.data) == null ? void 0 : v.code,
          args: {
            inputToken: p.selectedToken,
            ledgerWalletAPICompatible: c ?? void 0,
            tronResource: r.extract(),
            amount: t.toString(10),
            ...y
          }
        }
      };
    }),
    [
      s,
      o,
      c,
      (f = u.data) == null ? void 0 : f.code,
      e,
      i,
      n,
      t,
      r
    ]
  );
}, ree = k.createContext(
  void 0
), E6e = ({ children: e }) => {
  var Ae;
  const {
    actions: { onMaxClick: t },
    selectedToken: n,
    selectedStakeId: r,
    selectedValidators: i,
    stakeAmount: o,
    selectedStake: s,
    tronResource: c,
    stakeAmountGreaterThanAvailableAmount: u,
    stakeAmountGreaterThanMax: f,
    stakeAmountLessThanMin: p,
    stakeAmountIsZero: y,
    availableAmount: v,
    availableYields: w,
    hasNotYieldsForToken: C
  } = mZ(), x = z3e(), { t: A } = ln(), R = ix(s), { externalProviders: I } = dr(), { isConnected: D, isConnecting: M, isLedgerLiveAccountPlaceholder: L, chain: j } = fr(), F = Xh(s).mapOrDefault(
    (ye) => ye.title,
    ""
  ), O = tee({
    selectedStake: s,
    selectedValidators: i,
    stakeAmount: o
  }), z = nee(s), H = k.useMemo(
    () => s.chainNullable((ye) => ye.metadata.rewardTokens).map((ye) => ye.filter((re) => re.isPoints)),
    [s]
  ), Q = fA({
    token: n,
    yieldDto: s
  }), Y = n.mapOrDefault((ye) => ye.symbol, ""), ee = k.useMemo(
    () => he.fromRecord({
      prices: he.fromNullable(Q.data),
      selectedToken: n,
      baseToken: R
    }).map(
      (ye) => Vb({
        baseToken: ye.baseToken,
        amount: o,
        token: ye.selectedToken,
        prices: ye.prices,
        pricePerShare: null
      })
    ).mapOrDefault((ye) => `$${Na(ye)}`, ""),
    [R, Q.data, n, o]
  ), ie = k.useMemo(
    () => v.map((ye) => ({
      symbol: Y,
      shortFormattedAmount: Na(ye),
      fullFormattedAmount: To(ye),
      amount: ye
    })),
    [v, Y]
  ), [X, Z] = k.useState(""), J = k.useDeferredValue(X), [K, oe] = k.useState(""), be = k.useDeferredValue(K), [ce, pe] = k.useState(""), Ee = k.useDeferredValue(ce), Se = nZ(w.orDefault([])), Me = UJ(), Fe = sZ(), st = k.useMemo(
    () => he.fromRecord({
      defTb: he.fromNullable(Fe.data).alt(he.of([])),
      tb: he.fromNullable(Me.data).alt(he.of([]))
    }).map((ye) => {
      const { tbWithAmount: re, tbWithoutAmount: _e, tbSet: Pe } = ye.tb.reduce(
        (Qe, Ke) => (Qe.tbSet.add(as(Ke.token)), new Nt(Ke.amount).isGreaterThan(0) ? Qe.tbWithAmount.push(Ke) : Qe.tbWithoutAmount.push(Ke), Qe),
        {
          tbSet: /* @__PURE__ */ new Set(),
          tbWithAmount: [],
          tbWithoutAmount: []
        }
      );
      return [
        ...re,
        ..._e,
        ...ye.defTb.filter((Qe) => !Pe.has(as(Qe.token)))
      ];
    }).chain(
      (ye) => he.of(be).chain(
        (re) => re.length >= 1 ? he.of(re.toLowerCase()) : he.empty()
      ).map((re) => ({
        all: ye,
        filtered: ye.filter(
          (_e) => _e.token.name.toLowerCase().includes(re) || _e.token.symbol.toLowerCase().includes(re)
        )
      })).alt(he.of({ all: ye, filtered: ye }))
    ),
    [Fe.data, be, Me.data]
  ), mt = k.useMemo(
    () => he.fromNullable(Se.data).alt(he.of([])).map((ye) => ye.toSorted((re, _e) => _e.apy - re.apy)).map((ye) => ye.filter((re) => re.apy > 0)).chain(
      (ye) => he.of(J).chain(
        (re) => re.length >= 1 ? he.of(re.toLowerCase()) : he.empty()
      ).map((re) => ({
        all: ye,
        filteredDtos: ye.filter(
          (_e) => {
            var Pe;
            return _e.token.name.toLowerCase().includes(re) || _e.token.symbol.toLowerCase().includes(re) || _e.metadata.name.toLowerCase().includes(re) || ((Pe = _e.metadata.rewardTokens) == null ? void 0 : Pe.some(
              (Qe) => Qe.name.toLowerCase().includes(re) || Qe.symbol.toLowerCase().includes(re)
            ));
          }
        )
      })).alt(he.of({ all: ye, filteredDtos: ye }))
    ).map(({ all: ye, filteredDtos: re }) => {
      const _e = re.toSorted(
        (Qe, Ke) => zU(Qe) - zU(Ke)
      ), Pe = [
        ..._e.reduce(
          (Qe, Ke) => {
            const lt = tK(Ke);
            return Qe.has(lt) ? Qe.get(lt).items.push(Ke) : Qe.set(lt, {
              type: lt,
              title: nK(Ke, A).title,
              items: [Ke]
            }), Qe;
          },
          /* @__PURE__ */ new Map()
        ).values()
      ].reduce(
        (Qe, Ke) => {
          var lt;
          return Qe.set(Ke.type, {
            title: Ke.title,
            itemsLength: (((lt = Qe.get(Ke.type)) == null ? void 0 : lt.itemsLength) ?? 0) + Ke.items.length
          }), Qe;
        },
        /* @__PURE__ */ new Map()
      );
      return {
        all: ye,
        filtered: _e,
        groupsWithCounts: Pe
      };
    }),
    [J, Se.data, A]
  ), yt = k.useMemo(
    () => s.chain(
      (ye) => he.fromNullable(Ee).map((re) => re.toLowerCase()).map(
        (re) => ye.validators.filter(
          (_e) => {
            var Pe;
            return ((Pe = _e.name) == null ? void 0 : Pe.toLowerCase().includes(re)) || _e.address.toLowerCase().includes(re);
          }
        )
      ).alt(he.of(ye.validators))
    ),
    [Ee, s]
  ), Ut = (ye) => Z(ye), hn = (ye) => oe(ye), wn = (ye) => pe(ye), Ot = k.useCallback(
    (ye) => x({ type: "token/select", data: ye.token }),
    [x]
  ), xt = (ye) => {
    he.fromNullable(Se.data).chain((re) => Wn.find((_e) => _e.id === ye, re)).ifJust((re) => x({ type: "yield/select", data: re }));
  }, zt = (ye) => s.ifJust(
    (re) => {
      var _e, Pe;
      return (Pe = (_e = re.args.enter.args) == null ? void 0 : _e.validatorAddresses) != null && Pe.required ? x({ type: "validator/multiselect", data: ye }) : x({ type: "validator/select", data: ye });
    }
  ), Pn = (ye) => x({ type: "validator/remove", data: ye }), Fn = (ye) => x({ type: "stakeAmount/change", data: ye }), tr = x6e(), { openConnectModal: or } = cA(), ar = C6e(), Cr = ZA(), Un = ec({
    mutationFn: async () => {
      if (gr.hasErrors) return;
      if (!D) return or == null ? void 0 : or();
      const ye = he.fromRecord({
        stakeEnterRequestDto: tr,
        selectedToken: n
      }).unsafeCoerce();
      Cr.send({
        type: "initFlow",
        data: {
          requestDto: ye.stakeEnterRequestDto.dto,
          selectedToken: ye.selectedToken,
          gasFeeToken: ye.stakeEnterRequestDto.gasFeeToken,
          selectedStake: ye.stakeEnterRequestDto.selectedStake,
          selectedValidators: ye.stakeEnterRequestDto.selectedValidators
        }
      }), ar("/review");
    }
  }), $n = Pr(Un.reset);
  k.useEffect(() => {
    $n.current();
  }, [D, s, $n]);
  const gr = k.useMemo(() => {
    const ye = {
      submitted: !1,
      hasErrors: !1,
      errors: {
        tronResource: !1,
        stakeAmountGreaterThanAvailableAmount: !1,
        stakeAmountGreaterThanMax: !1,
        stakeAmountLessThanMin: !1,
        stakeAmountIsZero: !1
      }
    };
    return D && (s.ifJust((re) => {
      var _e, Pe;
      (Pe = (_e = re.args.enter.args) == null ? void 0 : _e.tronResource) != null && Pe.required && c.isNothing() && (ye.errors.tronResource = !0);
    }), ye.errors = {
      ...ye.errors,
      stakeAmountGreaterThanAvailableAmount: u,
      stakeAmountGreaterThanMax: f,
      stakeAmountLessThanMin: p,
      stakeAmountIsZero: y
    }, ye.submitted = Un.status !== "idle", ye.hasErrors = Object.values(ye.errors).some(Boolean)), ye;
  }, [
    D,
    Un.status,
    s,
    u,
    f,
    y,
    p,
    c
  ]), Tt = k.useMemo(
    () => s.chainNullable((ye) => {
      var re;
      return (re = ye.args.enter.args) == null ? void 0 : re.amount;
    }).filter((ye) => !Ob(ye)).chainNullable((ye) => ye.maximum),
    [s]
  ), qt = k.useMemo(
    () => s.chainNullable((ye) => {
      var re;
      return (re = ye.args.enter.args) == null ? void 0 : re.amount;
    }).filter((ye) => !Ob(ye)).chainNullable((ye) => ye.minimum).filter((ye) => new Nt(ye).isGreaterThan(0)),
    [s]
  ), gt = () => Z(""), Ht = () => oe(""), br = ox(), ne = XJ(), { state: N } = ff(), U = yA(
    (Ae = s.extract()) == null ? void 0 : Ae.id
  ).isLoading, le = XA(), Ce = n.isNothing() || !br.data || le.isLoading || br.isLoading || ne.isLoading || M || !N.layout, Te = Se.isLoading, Ve = Me.isLoading, kt = Fe.isLoading, bn = Se.isFetching || Me.isFetching, Wt = !Se.data && Se.isError || !Me.data && Me.isError, xn = D && (bn || tr.isNothing()), St = Xh(s).mapOrDefault(
    (ye) => ye.cta,
    ""
  ), Qn = cf({
    integrationData: s,
    validatorsAddresses: he.of(i)
  }), Nr = Bi(), bi = () => {
    Nr("earnPageMaxClicked"), t();
  }, Do = (ye) => x({
    type: "tronResource/select",
    data: ye
  }), la = Pr(Un.mutate), ja = AN(), Mo = Pr(() => {
    if (L && j)
      return Nr("addLedgerAccountClicked"), ja.mutate(j);
    Nr("connectWalletClicked"), or == null || or();
  }), ri = k.useMemo(
    () => he.fromRecord({ selectedStake: s, selectedToken: n }).mapOrDefault(
      (ye) => rSe({
        stakeToken: ye.selectedToken,
        yieldDto: ye.selectedStake
      }),
      !1
    ),
    [s, n]
  );
  py(
    k.useMemo(
      () => D && !L ? {
        disabled: xn,
        isLoading: bn,
        onClick: () => la.current(),
        label: St
      } : I ? null : {
        disabled: Ce,
        isLoading: Ce,
        label: A(
          L ? "init.ledger_add_account" : "init.connect_wallet"
        ),
        onClick: () => Mo.current()
      },
      [
        Ce,
        St,
        xn,
        Mo,
        D,
        L,
        la,
        I,
        bn,
        A
      ]
    )
  );
  const ui = Ve || kt, ji = r.isNothing() && !C || Te || U || Ve || kt, _i = kt || Ve || Te || U, ho = kt || Ve || Te || U, { referralCheck: wi } = dr(), we = {
    referralCheck: wi,
    selectedTokenAvailableAmount: ie,
    formattedPrice: ee,
    symbol: Y,
    selectedStakeData: mt,
    selectedStake: s,
    onYieldSelect: xt,
    onTokenBalanceSelect: Ot,
    onStakeAmountChange: Fn,
    estimatedRewards: O,
    yieldType: F,
    onMaxClick: bi,
    stakeAmount: o,
    isFetching: bn,
    buttonDisabled: xn,
    onClick: Un.mutate,
    onYieldSearch: Ut,
    onValidatorSelect: zt,
    onValidatorRemove: Pn,
    selectedValidators: i,
    isError: Wt,
    rewardToken: z,
    onSelectOpportunityClose: gt,
    onSelectTokenClose: Ht,
    isConnected: D,
    appLoading: Ce,
    yieldOpportunityLoading: U,
    multiYieldsLoading: Te,
    tokenBalancesScanLoading: Ve,
    tokenBalancesData: st,
    onTokenSearch: hn,
    onValidatorSearch: wn,
    buttonCTAText: St,
    providersDetails: Qn,
    tokenSearch: K,
    stakeSearch: X,
    defaultTokensIsLoading: kt,
    isLedgerLiveAccountPlaceholder: L,
    tronResource: c,
    onTronResourceSelect: Do,
    validation: gr,
    pointsRewardTokens: H,
    selectTokenIsLoading: ui,
    selectYieldIsLoading: ji,
    selectValidatorIsLoading: _i,
    footerIsLoading: ho,
    stakeMaxAmount: Tt,
    stakeMinAmount: qt,
    selectedToken: n,
    validatorsData: yt,
    validatorSearch: ce,
    hasNotYieldsForToken: C,
    isStakeTokenSameAsGasToken: ri
  };
  return /* @__PURE__ */ S.jsx(ree.Provider, { value: we, children: e });
}, ml = () => {
  const e = k.useContext(ree);
  if (!e)
    throw new Error("useEarnPageContext must be used within a EarnPageContext");
  return e;
}, S6e = () => {
  const { selectedStake: e, tronResource: t, onTronResourceSelect: n, validation: r } = ml(), { t: i } = ln();
  return e.chainNullable((o) => {
    var s;
    return (s = o.args.enter.args) == null ? void 0 : s.tronResource;
  }).map((o) => {
    const s = o.options.map((f) => ({
      label: f,
      value: f
    })), c = t.map((f) => ({ value: f, label: f })).extract(), u = r.submitted && r.errors.tronResource;
    return /* @__PURE__ */ S.jsxs(ae, { children: [
      /* @__PURE__ */ S.jsx(ae, { my: "2", children: /* @__PURE__ */ S.jsx(
        Ge,
        {
          variant: {
            type: u ? "danger" : "regular"
          },
          children: i("details.tron_resources.label")
        }
      ) }),
      /* @__PURE__ */ S.jsx(
        w6e,
        {
          options: s,
          onSelect: (f) => n(f),
          selectedOption: c,
          placeholder: i("details.tron_resources.placeholder"),
          isError: u
        }
      ),
      /* @__PURE__ */ S.jsx(ae, { marginTop: "3", children: /* @__PURE__ */ S.jsx(Gl, {}) })
    ] });
  }).extractNullable();
}, k6e = () => {
  const {
    appLoading: e,
    footerIsLoading: t,
    selectedStake: n,
    selectedValidators: r,
    selectedToken: i
  } = ml();
  return /* @__PURE__ */ S.jsx(
    vJ,
    {
      isLoading: e || t,
      selectedStake: n,
      selectedValidators: r,
      selectedToken: i
    }
  );
}, iee = ({
  color: e,
  hw: t = 24,
  className: n
}) => /* @__PURE__ */ S.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: t,
    height: t,
    fill: e ? ti.color[e] : ti.color.textMuted,
    viewBox: "0 0 256 256",
    className: n,
    children: /* @__PURE__ */ S.jsx("path", { d: "m232.49 80.49-128 128a12 12 0 0 1-17 0l-56-56a12 12 0 1 1 17-17L96 183 215.51 63.51a12 12 0 0 1 17 17Z" })
  }
), oee = ({
  hw: e = 24,
  className: t
}) => /* @__PURE__ */ S.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: e,
    height: e,
    fill: "#909090",
    viewBox: "0 0 256 256",
    className: t,
    children: /* @__PURE__ */ S.jsx("path", { d: "M216 28H88a12 12 0 0 0-12 12v36H40a12 12 0 0 0-12 12v128a12 12 0 0 0 12 12h128a12 12 0 0 0 12-12v-36h36a12 12 0 0 0 12-12V40a12 12 0 0 0-12-12Zm-60 176H52V100h104Zm48-48h-24V88a12 12 0 0 0-12-12h-68V52h104Z" })
  }
), _z = ({ address: e, network: t }) => `/v1/networks/${t}/addresses/${e}/referrals`, A6e = ({
  address: e,
  network: t
}) => ["own-referral-code", t, e], T6e = () => {
  const { address: e, network: t } = fr(), n = _8(), { referralCheck: r } = dr();
  return Qr({
    enabled: !!(e && t && r),
    queryKey: A6e({ address: e, network: t }),
    staleTime: Number.POSITIVE_INFINITY,
    queryFn: async () => (await Ye.liftEither(
      he.fromNullable(
        e && t ? { address: e, network: t } : null
      ).toEither(new Error("missing args"))
    ).chain(
      (i) => Ye(() => n.get(_z(i))).chainLeft((o) => Tue(o) ? Ye(
        () => n.post(_z(i))
      ) : Ye.liftEither(Rn(o))).mapLeft(
        (o) => Qd(o) ? o : new Error("unknown error")
      )
    ).map((i) => i.data)).unsafeCoerce()
  });
}, _6e = () => {
  const { appLoading: e } = ml(), t = T6e(), n = e || t.isLoading, r = k.useMemo(
    () => Ro.chain(
      (u) => he.fromNullable(t.data).map((f) => ({ data: f, w: u }))
    ).map((u) => `${u.w.location.origin}/?ref=${u.data.code}`).extractNullable(),
    [t.data]
  ), { t: i } = ln(), [o, s] = k.useState(!1), c = (u) => {
    Ro.ifJust((f) => f.navigator.clipboard.writeText(u)), s(!0);
  };
  return k.useEffect(() => {
    if (!o) return;
    const u = setTimeout(() => s(!1), 1e3);
    return () => {
      clearTimeout(u);
    };
  }, [o]), n ? /* @__PURE__ */ S.jsx(ae, { marginTop: "2", children: /* @__PURE__ */ S.jsx(hf, { heightPx: 20, variant: { size: "medium" } }) }) : he.fromNullable(r).map((u) => /* @__PURE__ */ S.jsxs(
    ae,
    {
      px: "3",
      py: "3",
      background: "backgroundMuted",
      borderRadius: "md",
      display: "flex",
      flexDirection: "column",
      children: [
        /* @__PURE__ */ S.jsx(ae, { marginBottom: "3", children: /* @__PURE__ */ S.jsx(Ge, { variant: { size: "medium" }, children: i("details.referral_code.title") }) }),
        /* @__PURE__ */ S.jsxs(
          ae,
          {
            background: "background",
            px: "3",
            py: "3",
            borderRadius: "md",
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            as: "button",
            onClick: () => c(u),
            children: [
              /* @__PURE__ */ S.jsx(Ge, { variant: { size: "large" }, children: u }),
              /* @__PURE__ */ S.jsx(_A, { mode: "wait", children: /* @__PURE__ */ S.jsx(
                gi.div,
                {
                  whileTap: { scale: o ? 1 : 0.9 },
                  initial: { opacity: 0 },
                  animate: { opacity: 1, transition: { duration: 0.05 } },
                  exit: { opacity: 0, transition: { duration: 0.05 } },
                  children: o ? /* @__PURE__ */ S.jsx(iee, { color: "positionsClaimRewardsBackground" }) : /* @__PURE__ */ S.jsx(oee, {})
                },
                o ? "copy" : "check"
              ) })
            ]
          }
        )
      ]
    }
  )).extractNullable();
}, aee = ({ onMaxClick: e, ...t }) => {
  const { t: n } = ln();
  return /* @__PURE__ */ S.jsx(
    ae,
    {
      "data-rk": "stake-token-section-max-button",
      as: "button",
      borderRadius: "xl",
      background: "background",
      px: "2",
      py: "1",
      marginLeft: "2",
      onClick: e,
      className: RA,
      ...t,
      children: /* @__PURE__ */ S.jsx(Ge, { variant: { weight: "semibold", type: "regular" }, children: n("shared.max") })
    }
  );
}, see = k.createContext(void 0), lee = ({ children: e, init: t }) => /* @__PURE__ */ S.jsx(see.Provider, { value: k.useState(t ?? "short"), children: e }), cee = ({ fullAmount: e, shortAmount: t, children: n }) => {
  const [r, i] = R6e(), o = () => i(r === "full" ? "short" : "full");
  return /* @__PURE__ */ S.jsx(ae, { as: "button", onClick: o, children: (n == null ? void 0 : n({ state: r })) ?? (r === "full" ? e : t) });
}, R6e = () => {
  const e = k.useContext(see);
  if (!e)
    throw new Error("useAmountContext must be used within a Root");
  return e;
};
var O6e = "_1dlf2pf0", uee = "_1a682410", I6e = "_1a682412 _1a682411 yv8y4r3j", D6e = "_1a682413", Rz = "_1a682414", M6e = "_1a682415", P6e = "_1a682417 _1a682416 yv8y4r2n yv8y4rfj yv8y4rg1 yv8y4rvt yv8y4rvu yv8y4r10", N6e = "_1a682419 _1a682418 yv8y4r10 yv8y4rvt yv8y4rvu yv8y4r2n yv8y4rfj yv8y4rg1", B6e = "_1a68241b _1a68241a yv8y4r6j yv8y4r2n yv8y4rfx yv8y4rfl yv8y4r3l yv8y4rgd";
const L6e = k.memo(
  ({ item: e, isConnected: t, onTokenBalanceSelect: n }) => {
    const r = k.useMemo(() => new Nt(e.amount), [e.amount]), i = k.useMemo(
      () => Na(r),
      [r]
    ), o = k.useMemo(
      () => r.isGreaterThan(0),
      [r]
    ), s = Bi(), c = ({ closeModal: u }) => {
      s("tokenSelected", { token: e.token.symbol }), n(e), u();
    };
    return /* @__PURE__ */ S.jsx(Cb, { children: /* @__PURE__ */ S.jsxs(
      zA,
      {
        variant: o || !t ? { type: "enabled", hover: "enabled" } : { type: "disabled", hover: "enabled" },
        onItemClick: c,
        children: [
          /* @__PURE__ */ S.jsx(nf, { token: e.token }),
          /* @__PURE__ */ S.jsxs(ae, { display: "flex", flexDirection: "column", flex: 1, minWidth: "0", children: [
            /* @__PURE__ */ S.jsxs(
              ae,
              {
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                gap: "2",
                children: [
                  /* @__PURE__ */ S.jsx(Ge, { className: uee, variant: { weight: "bold" }, children: e.token.name }),
                  o && /* @__PURE__ */ S.jsx(Ge, { children: i })
                ]
              }
            ),
            /* @__PURE__ */ S.jsx(
              ae,
              {
                display: "flex",
                marginTop: "1",
                justifyContent: "space-between",
                alignItems: "center",
                children: /* @__PURE__ */ S.jsx(Ge, { variant: { type: "muted" }, children: e.token.symbol })
              }
            )
          ] })
        ]
      }
    ) });
  }
), j6e = () => {
  const {
    onSelectTokenClose: e,
    onTokenBalanceSelect: t,
    tokenBalancesData: n,
    selectedToken: r,
    onTokenSearch: i,
    tokenSearch: o
  } = ml(), s = Bi(), { t: c } = ln(), { isConnected: u } = fr(), f = k.useMemo(
    () => r.map((p) => ({
      st: p,
      tokenBalances: n.map((y) => y.filtered).extract() ?? []
    })).extractNullable(),
    [r, n]
  );
  return f ? /* @__PURE__ */ S.jsx(
    dp,
    {
      title: c("select_token.title"),
      onSearch: i,
      searchValue: o,
      onClose: e,
      onOpen: () => s("selectTokenModalOpened"),
      trigger: /* @__PURE__ */ S.jsx(wb, { asChild: !0, children: /* @__PURE__ */ S.jsxs(
        ae,
        {
          as: "button",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          background: "background",
          borderRadius: "2xl",
          px: "2",
          py: "1",
          "data-testid": "select-token",
          className: RA,
          children: [
            /* @__PURE__ */ S.jsxs(
              ae,
              {
                marginRight: "2",
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                children: [
                  /* @__PURE__ */ S.jsx(nf, { token: f.st }),
                  /* @__PURE__ */ S.jsx(Ge, { variant: { weight: "bold" }, children: f.st.symbol })
                ]
              }
            ),
            /* @__PURE__ */ S.jsx(fy, {})
          ]
        }
      ) }),
      children: /* @__PURE__ */ S.jsx(
        SN,
        {
          className: I6e,
          data: f.tokenBalances,
          estimateSize: () => 60,
          itemContent: (p, y) => /* @__PURE__ */ S.jsx(
            L6e,
            {
              item: y,
              onTokenBalanceSelect: t,
              isConnected: u
            }
          )
        }
      )
    }
  ) : null;
}, dee = () => {
  const {
    appLoading: e,
    yieldType: t,
    selectTokenIsLoading: n,
    selectYieldIsLoading: r,
    selectValidatorIsLoading: i,
    footerIsLoading: o
  } = ml(), s = e || n || r || i || o;
  return /* @__PURE__ */ S.jsx(ae, { display: "flex", alignItems: "center", my: "1", children: s ? /* @__PURE__ */ S.jsx(ae, { display: "flex", children: /* @__PURE__ */ S.jsx(Wl, {}) }) : /* @__PURE__ */ S.jsx(Ge, { children: t }) });
}, F6e = () => {
  const { t: e } = ln(), { variant: t } = dr(), {
    appLoading: n,
    selectedTokenAvailableAmount: r,
    formattedPrice: i,
    onMaxClick: o,
    onStakeAmountChange: s,
    stakeAmount: c,
    validation: u,
    selectTokenIsLoading: f,
    stakeMaxAmount: p,
    stakeMinAmount: y,
    symbol: v,
    isStakeTokenSameAsGasToken: w
  } = ml(), C = n || f, {
    submitted: x,
    errors: {
      stakeAmountGreaterThanAvailableAmount: A,
      stakeAmountGreaterThanMax: R,
      stakeAmountLessThanMin: I,
      stakeAmountIsZero: D
    }
  } = u, M = x && D || A || R || I, L = A, j = _n([
    y.map((F) => `${e("shared.min")} ${F} ${v}`).extractNullable(),
    p.map((F) => `${e("shared.max")} ${F} ${v}`).extractNullable()
  ]).filter((F) => F.some(Boolean)).map(([F, O]) => /* @__PURE__ */ S.jsx(
    ae,
    {
      display: "flex",
      justifyContent: "flex-end",
      alignItems: "center",
      ...t === "default" && { marginRight: "2", marginTop: "2" },
      "data-rk": "stake-token-section-min-max",
      children: /* @__PURE__ */ S.jsx(
        Ge,
        {
          variant: { type: I ? "danger" : "muted" },
          children: F && O ? `${F} / ${O}` : F ?? O
        },
        "min"
      )
    }
  )).extractNullable();
  return C ? /* @__PURE__ */ S.jsx(ae, { marginTop: "2", children: /* @__PURE__ */ S.jsx(hf, { heightPx: 112.5 }) }) : /* @__PURE__ */ S.jsxs(
    ae,
    {
      "data-rk": "stake-token-section",
      background: "stakeSectionBackground",
      borderRadius: "xl",
      marginTop: "2",
      py: "4",
      px: "4",
      borderStyle: "solid",
      borderWidth: 1,
      borderColor: x && D ? "textDanger" : "transparent",
      children: [
        t === "zerion" && /* @__PURE__ */ S.jsxs(ae, { display: "flex", justifyContent: "space-between", children: [
          /* @__PURE__ */ S.jsx(dee, {}),
          j
        ] }),
        /* @__PURE__ */ S.jsxs(ae, { display: "flex", justifyContent: "space-between", alignItems: "center", children: [
          /* @__PURE__ */ S.jsx(ae, { minWidth: "0", display: "flex", flex: 1, children: /* @__PURE__ */ S.jsx(
            nX,
            {
              shakeOnInvalid: !0,
              isInvalid: M,
              onChange: s,
              value: c
            }
          ) }),
          /* @__PURE__ */ S.jsx(ae, { display: "flex", justifyContent: "center", alignItems: "center", children: /* @__PURE__ */ S.jsx(j6e, {}) })
        ] }),
        t === "default" && j,
        /* @__PURE__ */ S.jsxs(
          ae,
          {
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            marginTop: "2",
            flexWrap: "wrap",
            "data-rk": "stake-token-section-balance",
            gap: "1",
            children: [
              /* @__PURE__ */ S.jsx(ae, { className: O6e, display: "flex", children: /* @__PURE__ */ S.jsx(Ge, { variant: { type: "muted", weight: "normal" }, children: i }) }),
              /* @__PURE__ */ S.jsxs(
                ae,
                {
                  flexGrow: 1,
                  display: "flex",
                  justifyContent: "space-between",
                  alignItems: "center",
                  children: [
                    /* @__PURE__ */ S.jsx(ae, { display: "flex", children: /* @__PURE__ */ S.jsx(
                      Ge,
                      {
                        variant: {
                          weight: "normal",
                          type: L ? "danger" : "muted"
                        },
                        "data-state": L ? "error" : "valid",
                        children: r.map(
                          (F) => t === "zerion" ? /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
                            /* @__PURE__ */ S.jsxs("span", { children: [
                              e("shared.balance"),
                              ":"
                            ] }),
                            /* @__PURE__ */ S.jsxs(
                              ae,
                              {
                                ...w ? { as: "span" } : {
                                  onClick: o,
                                  as: "button"
                                },
                                children: [
                                  F.shortFormattedAmount,
                                  "",
                                  F.symbol
                                ]
                              }
                            )
                          ] }) : /* @__PURE__ */ S.jsx(lee, { children: /* @__PURE__ */ S.jsx(cee, { children: ({ state: O }) => /* @__PURE__ */ S.jsxs("span", { children: [
                            O === "full" ? F.fullFormattedAmount : F.shortFormattedAmount,
                            "",
                            F.symbol,
                            "",
                            e("shared.available")
                          ] }) }) })
                        ).extractNullable()
                      }
                    ) }),
                    !w && /* @__PURE__ */ S.jsx(aee, { onMaxClick: o })
                  ]
                }
              )
            ]
          }
        )
      ]
    }
  );
}, fee = ({
  commission: e,
  stakedBalance: t,
  stakedBalanceToken: n,
  votingPower: r,
  address: i,
  rewardRate: o,
  rewardType: s,
  website: c
}) => {
  const { t: u } = ln();
  return k.useMemo(
    () => ({
      rewardRate: o && s ? {
        title: xK(s),
        val: Hh({
          rewardRate: o,
          rewardType: s
        })
      } : null,
      stakedBalance: t && n ? {
        title: u("details.validators_staked_balance"),
        val: _n(new Nt(t)).filter((f) => !f.isNaN()).map(
          (f) => `${To(f, 0)} ${n.symbol}`
        ).orDefault("-")
      } : null,
      votingPower: r ? {
        title: u("details.validators_voting_power"),
        val: _n(new Nt(r)).filter((f) => !f.isNaN()).map((f) => `${e5(f.toNumber())}%`).orDefault("-")
      } : null,
      commission: e ? {
        title: u("details.validators_comission"),
        val: _n(new Nt(e)).filter((f) => !f.isNaN()).map((f) => `${To(e5(f.toNumber()))}%`).orDefault("-")
      } : null,
      address: i ? {
        title: u("details.validators_address"),
        val: I4(i, { leadingChars: 6, trailingChars: 6 })
      } : null,
      website: c ? {
        title: u("details.validators_website"),
        val: /* @__PURE__ */ S.jsx(Ll, { href: c, children: I4(c, {
          leadingChars: 16,
          trailingChars: 8
        }) })
      } : null
    }),
    [
      o,
      s,
      t,
      n,
      u,
      r,
      e,
      i,
      c
    ]
  );
};
var U6e = "_174mpfi1 _174mpfi0 yv8y4r3j", z6e = "_174mpfi4 _174mpfi3 yv8y4r6j _174mpfi2", hee = "_174mpfi6 _174mpfi5 yv8y4ru yv8y4rwp yv8y4rwq", V6e = "_174mpfi7";
const $6e = ({
  multiSelect: e,
  selectedValidators: t,
  onItemClick: n,
  onViewMoreClick: r,
  selectedStake: i,
  groupCounts: o,
  groupedItems: s,
  tableData: c
}) => {
  const { t: u } = ln();
  return /* @__PURE__ */ S.jsx(
    kN,
    {
      increaseViewportBy: { bottom: 50, top: 0 },
      estimateSize: () => 60,
      groupCounts: o,
      groupContent: (f) => s[f].label === "view_more" || !s[f].items.length ? null : /* @__PURE__ */ S.jsxs(
        ae,
        {
          py: "4",
          px: "4",
          background: "modalBodyBackground",
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          children: [
            /* @__PURE__ */ S.jsx(Ge, { variant: { weight: "medium" }, children: s[f].label }),
            /* @__PURE__ */ S.jsx(ae, { marginRight: "4", children: /* @__PURE__ */ S.jsx(Ge, { variant: { weight: "normal", type: "muted" }, children: xK(i.rewardType) }) })
          ]
        }
      ),
      className: U6e,
      itemContent: (f, p) => {
        var A;
        if (((A = s[p]) == null ? void 0 : A.label) === "view_more")
          return /* @__PURE__ */ S.jsx(ae, { display: "flex", justifyContent: "center", marginTop: "6", children: /* @__PURE__ */ S.jsx(
            Jl,
            {
              variant: { color: "secondary", size: "small" },
              onClick: r,
              children: /* @__PURE__ */ S.jsx(Ge, { children: u("details.validators_view_all") })
            }
          ) });
        const y = c[f], v = y.preferred, w = y.status, C = t.has(y.address), x = ({ closeModal: R }) => {
          n(y), !e && R();
        };
        return /* @__PURE__ */ S.jsx(Cb, { children: /* @__PURE__ */ S.jsx(zA, { onItemClick: x, testId: y.address, children: /* @__PURE__ */ S.jsxs(ae, { flex: 1, display: "flex", flexDirection: "column", gap: "3", children: [
          /* @__PURE__ */ S.jsxs(ae, { display: "flex", justifyContent: "center", alignItems: "center", children: [
            e && /* @__PURE__ */ S.jsx(
              ae,
              {
                background: C ? "selectValidatorMultiSelectedBackground" : "selectValidatorMultiDefaultBackground",
                hw: "8",
                as: "button",
                borderRadius: "full",
                marginRight: "2",
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                children: t.has(y.address) ? /* @__PURE__ */ S.jsx(_1, { hw: 16, color: ti.color.white }) : /* @__PURE__ */ S.jsx(S.Fragment, {})
              }
            ),
            /* @__PURE__ */ S.jsx(
              Hc,
              {
                containerProps: { hw: "9" },
                imageProps: { borderRadius: "full" },
                src: y.image,
                fallback: /* @__PURE__ */ S.jsx(
                  df,
                  {
                    name: y.name || y.address,
                    tokenLogoHw: "9",
                    textVariant: { type: "white", weight: "bold" }
                  }
                )
              }
            ),
            /* @__PURE__ */ S.jsx(
              ae,
              {
                display: "flex",
                flexDirection: "column",
                flex: 1,
                marginLeft: "2",
                children: /* @__PURE__ */ S.jsxs(
                  ae,
                  {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center",
                    children: [
                      /* @__PURE__ */ S.jsxs(ae, { className: z6e, children: [
                        /* @__PURE__ */ S.jsx(Ge, { variant: { weight: "bold" }, children: y.name ?? y.address }),
                        v && /* @__PURE__ */ S.jsx(ae, { marginLeft: "1", display: "flex", children: /* @__PURE__ */ S.jsx(eT, {}) }),
                        w !== "active" && /* @__PURE__ */ S.jsx(ae, { marginLeft: "1", className: hee, children: /* @__PURE__ */ S.jsx(
                          Ge,
                          {
                            variant: {
                              type: "white",
                              weight: "medium",
                              size: "small"
                            },
                            className: V6e,
                            children: u(
                              w === "jailed" ? "details.validators_jailed" : "details.validators_inactive"
                            )
                          }
                        ) })
                      ] }),
                      /* @__PURE__ */ S.jsx(ae, { children: /* @__PURE__ */ S.jsx(Ge, { variant: { size: "large" }, children: Hh({
                        rewardRate: y.apr,
                        rewardType: i.rewardType
                      }) }) })
                    ]
                  }
                )
              }
            )
          ] }),
          /* @__PURE__ */ S.jsx(
            H6e,
            {
              address: y.address,
              commission: y.commission,
              stakedBalance: y.stakedBalance,
              votingPower: y.votingPower,
              rewardRate: void 0,
              rewardType: void 0,
              stakedBalanceToken: i.token,
              website: void 0
            }
          )
        ] }) }) });
      }
    }
  );
}, H6e = k.memo((e) => {
  const t = fee(e);
  return /* @__PURE__ */ S.jsx(ae, { display: "flex", flexDirection: "column", gap: "1", children: Object.entries(t).filter(
    (n) => !!n[1]
  ).map(([n, r]) => /* @__PURE__ */ S.jsxs(
    ae,
    {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      children: [
        /* @__PURE__ */ S.jsx(Ge, { variant: { type: "muted" }, children: r.title }),
        /* @__PURE__ */ S.jsx(Ge, { variant: { type: "muted", weight: "normal" }, children: r.val })
      ]
    },
    n
  )) });
}), pee = ({
  state: e,
  onClose: t,
  onOpen: n,
  trigger: r,
  selectedValidators: i,
  onItemClick: o,
  onViewMoreClick: s,
  validators: c,
  multiSelect: u,
  selectedStake: f,
  children: p,
  ...y
}) => {
  const { t: v } = ln(), [w, C] = k.useState(!1), x = () => {
    s == null || s(), C(!0);
  }, A = () => {
    C(!1), t == null || t();
  }, R = !!u || w || y.searchValue, I = k.useMemo(() => {
    if (!c.length)
      return {
        tableData: [],
        groupedItems: [],
        groupCounts: []
      };
    const M = c.reduce(
      (F, O) => (O.preferred ? F.preferred.items.push(O) : R && F.other.items.push(O), F),
      {
        preferred: {
          items: [],
          label: v("details.validators_preferred")
        },
        other: {
          items: [],
          label: v("details.validators_other")
        }
      }
    );
    if (!M.preferred.items.length && c.length)
      return {
        tableData: c,
        groupedItems: [
          {
            items: c,
            label: v("details.validators_other")
          }
        ],
        groupCounts: [c.length]
      };
    const L = !R && M.preferred.items.length !== c.length, j = Object.values(M);
    return {
      tableData: j.flatMap((F) => F.items),
      groupedItems: [
        ...j.filter((F) => !!F.items.length),
        ...L ? [{ items: [], label: "view_more" }] : []
      ],
      groupCounts: [
        ...j.filter((F) => !!F.items.length).map((F) => F.items.length),
        ...L ? [1] : []
      ]
    };
  }, [c, v, R]), D = y.onSearch ? {
    onSearch: y.onSearch,
    searchValue: y.searchValue
  } : {};
  return /* @__PURE__ */ S.jsxs(
    dp,
    {
      title: v("details.validator_search_title", {
        count: u ? 2 : 1
      }),
      onClose: A,
      onOpen: n,
      trigger: r,
      state: e,
      ...D,
      children: [
        /* @__PURE__ */ S.jsx(
          $6e,
          {
            ...I,
            selectedValidators: i,
            multiSelect: u,
            onItemClick: o,
            onViewMoreClick: x,
            selectedStake: f
          }
        ),
        p
      ]
    }
  );
}, q6e = (e) => /* @__PURE__ */ S.jsx(
  "svg",
  {
    viewBox: "0 0 24 24",
    width: e.hw ?? 24,
    height: e.hw ?? 24,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    transform: "rotate(45)",
    children: /* @__PURE__ */ S.jsx(
      "path",
      {
        d: "m18.75 5.25-13.5 13.5M18.75 18.75 5.25 5.25",
        stroke: e.color ? ti.color[e.color] : ti.color.textMuted,
        strokeWidth: e.strokeWidth ?? 2,
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    )
  }
), W6e = ({
  onRemoveValidator: e,
  multiSelect: t,
  selectedValidatorsArr: n
}) => {
  const { t: r } = ln();
  return /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
    /* @__PURE__ */ S.jsxs(
      ae,
      {
        "data-rk": "select-validator-trigger-container",
        className: B6e,
        children: [
          /* @__PURE__ */ S.jsx(ae, { display: "flex", alignItems: "center", justifyContent: "center", children: /* @__PURE__ */ S.jsx(Ge, { className: Rz, variant: { weight: "bold" }, children: r("details.earn_with") }) }),
          (() => {
            const i = /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
              n.map((o) => {
                const s = o.name ?? o.address;
                return /* @__PURE__ */ S.jsx(ae, { children: /* @__PURE__ */ S.jsxs(
                  ae,
                  {
                    "data-rk": "select-validator-trigger",
                    className: P6e,
                    children: [
                      /* @__PURE__ */ S.jsx(ae, { marginRight: "2", children: /* @__PURE__ */ S.jsx(
                        Hc,
                        {
                          containerProps: { hw: "5" },
                          imageProps: { borderRadius: "full" },
                          src: o.image,
                          fallback: /* @__PURE__ */ S.jsx(ae, { marginRight: "1", children: /* @__PURE__ */ S.jsx(
                            df,
                            {
                              name: s,
                              tokenLogoHw: "5",
                              textVariant: {
                                type: "white",
                                weight: "bold"
                              }
                            }
                          ) })
                        }
                      ) }),
                      /* @__PURE__ */ S.jsx(Ge, { className: Rz, variant: { weight: "bold" }, children: s }),
                      o.preferred && /* @__PURE__ */ S.jsx(ae, { marginLeft: "1", display: "flex", children: /* @__PURE__ */ S.jsx(eT, {}) }),
                      o.status !== "active" && /* @__PURE__ */ S.jsx(ae, { marginLeft: "1", className: hee, children: /* @__PURE__ */ S.jsx(
                        Ge,
                        {
                          variant: {
                            type: "white",
                            weight: "medium",
                            size: "small"
                          },
                          className: UD,
                          children: r(
                            o.status === "jailed" ? "details.validators_jailed" : "details.validators_inactive"
                          )
                        }
                      ) }),
                      t && n.length > 1 && /* @__PURE__ */ S.jsx(
                        ae,
                        {
                          as: "button",
                          display: "flex",
                          marginLeft: "1",
                          onClick: () => e(o),
                          children: /* @__PURE__ */ S.jsx(Pg, { hw: 12, strokeWidth: 4.9 })
                        }
                      )
                    ]
                  }
                ) }, o.address);
              }),
              t ? /* @__PURE__ */ S.jsx(ae, { children: /* @__PURE__ */ S.jsx(wb, { asChild: !0, children: /* @__PURE__ */ S.jsx(
                ae,
                {
                  "data-rk": "select-validator-plus",
                  as: "button",
                  className: N6e,
                  children: /* @__PURE__ */ S.jsx(q6e, { hw: 12, strokeWidth: 4.9 })
                }
              ) }) }) : /* @__PURE__ */ S.jsx(
                ae,
                {
                  "data-rk": "select-validator-caret-down",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  children: /* @__PURE__ */ S.jsx(fy, {})
                }
              )
            ] });
            return t ? i : /* @__PURE__ */ S.jsx(wb, { asChild: !0, children: /* @__PURE__ */ S.jsx(ae, { as: "button", display: "flex", gap: "1", children: i }) });
          })()
        ]
      }
    ),
    /* @__PURE__ */ S.jsx(ae, { marginTop: "3", children: /* @__PURE__ */ S.jsx(Gl, {}) })
  ] });
}, G6e = () => {
  const {
    appLoading: e,
    onValidatorSelect: t,
    onValidatorRemove: n,
    selectedValidators: r,
    selectedStake: i,
    selectValidatorIsLoading: o,
    onValidatorSearch: s,
    validatorsData: c,
    validatorSearch: u
  } = ml(), f = e || o, p = Bi(), y = () => p("selectValidatorViewMoreClicked"), v = () => p("selectValidatorModalClosed"), w = () => p("selectValidatorModalOpened"), C = (A) => {
    p("validatorSelected", {
      validatorName: A.name,
      validatorAddress: A.address
    }), t(A);
  }, x = (A) => {
    p("validatorRemoved", {
      validatorName: A.name,
      validatorAddress: A.address
    }), n(A);
  };
  return f ? /* @__PURE__ */ S.jsx(ae, { marginTop: "2", children: /* @__PURE__ */ S.jsx(hf, { heightPx: 20, variant: { size: "medium" } }) }) : he.fromRecord({ selectedStake: i, validatorsData: c }).filter((A) => !!A.selectedStake.validators.length).map((A) => {
    var D, M;
    const R = [...r.values()], I = !!((M = (D = A.selectedStake.args.enter.args) == null ? void 0 : D.validatorAddresses) != null && M.required);
    return /* @__PURE__ */ S.jsx(
      pee,
      {
        trigger: /* @__PURE__ */ S.jsx(
          W6e,
          {
            onRemoveValidator: x,
            selectedValidatorsArr: R,
            multiSelect: I
          }
        ),
        selectedValidators: new Set(R.map((L) => L.address)),
        multiSelect: I,
        selectedStake: A.selectedStake,
        onItemClick: C,
        onViewMoreClick: y,
        onClose: v,
        onOpen: w,
        onSearch: s,
        searchValue: u,
        validators: A.validatorsData
      }
    );
  }).extractNullable();
}, mee = ({
  token: e,
  metadata: t,
  tokenLogoHw: n,
  tokenNetworkLogoHw: r,
  hideNetwork: i
}) => {
  const { hideNetworkLogo: o } = dr();
  return /* @__PURE__ */ S.jsx(
    oX,
    {
      hideNetwork: i,
      token: e,
      metadata: t,
      children: ({ fallbackUrl: s, mainUrl: c, name: u, networkLogoUri: f, providerIcon: p }) => /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
        /* @__PURE__ */ S.jsx(
          aX,
          {
            fallbackUrl: s,
            mainUrl: p,
            name: u,
            tokenLogoHw: n
          }
        ),
        !i && !o && /* @__PURE__ */ S.jsx(
          iX,
          {
            networkLogoUri: c || f,
            tokenNetworkLogoHw: r
          }
        )
      ] })
    }
  );
}, K6e = ({
  item: e,
  index: t
}) => {
  const { onYieldSelect: n } = ml(), r = Bi(), i = ({
    closeModal: o
  }) => {
    r("yieldSelected", { yield: e.id }), n(e.id), o();
  };
  return /* @__PURE__ */ S.jsxs(
    zA,
    {
      testId: `select-opportunity__item_${e.id}-${t}`,
      onItemClick: i,
      children: [
        /* @__PURE__ */ S.jsx(mee, { metadata: e.metadata, token: e.token }),
        /* @__PURE__ */ S.jsxs(
          ae,
          {
            display: "flex",
            flexDirection: "column",
            flex: 1,
            marginLeft: "2",
            minWidth: "0",
            children: [
              /* @__PURE__ */ S.jsxs(
                ae,
                {
                  display: "flex",
                  justifyContent: "space-between",
                  alignItems: "center",
                  gap: "2",
                  children: [
                    /* @__PURE__ */ S.jsx(ae, { children: /* @__PURE__ */ S.jsx(Ge, { className: uee, variant: { weight: "bold" }, children: e.metadata.name }) }),
                    /* @__PURE__ */ S.jsx(ae, { children: /* @__PURE__ */ S.jsx(Ge, { children: Hh({
                      rewardRate: e.rewardRate,
                      rewardType: e.rewardType
                    }) }) })
                  ]
                }
              ),
              /* @__PURE__ */ S.jsxs(ae, { display: "flex", marginTop: "1", flexWrap: "wrap", gap: "1", children: [
                /* @__PURE__ */ S.jsx(Ge, { variant: { type: "muted" }, children: he.fromNullable(e.metadata.rewardTokens).map((o) => o.map((s) => s.symbol).join(", ")).orDefault(e.token.symbol) }),
                he.fromNullable(e.metadata.rewardTokens).map(() => /* @__PURE__ */ S.jsx(ae, { background: "background", borderRadius: "2xl", px: "2", children: /* @__PURE__ */ S.jsx(Ge, { variant: { type: "muted" }, children: e.token.symbol }) })).extractNullable()
              ] })
            ]
          }
        )
      ]
    }
  );
}, Y6e = () => {
  const {
    selectedStake: e,
    selectedStakeData: t,
    onSelectOpportunityClose: n,
    onYieldSearch: r,
    stakeSearch: i
  } = ml(), o = Bi(), { t: s } = ln(), c = k.useMemo(
    () => t.chain(
      (u) => e.map((f) => {
        const p = [...u.groupsWithCounts.values()];
        return {
          ss: f,
          all: u.filtered,
          groups: p.map((y) => y.title),
          groupCounts: p.map((y) => y.itemsLength)
        };
      })
    ).extractNullable(),
    [e, t]
  );
  return c ? /* @__PURE__ */ S.jsx(
    dp,
    {
      title: s("details.opportunity_search_title"),
      onSearch: r,
      searchValue: i,
      onClose: n,
      onOpen: () => o("selectYieldModalOpened"),
      trigger: /* @__PURE__ */ S.jsx(wb, { asChild: !0, children: /* @__PURE__ */ S.jsxs(
        ae,
        {
          as: "button",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          background: "background",
          borderRadius: "2xl",
          px: "2",
          py: "1",
          "data-testid": "select-opportunity",
          className: RA,
          children: [
            /* @__PURE__ */ S.jsxs(
              ae,
              {
                marginRight: "2",
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                children: [
                  /* @__PURE__ */ S.jsx(mee, { token: c.ss.token, metadata: c.ss.metadata }),
                  /* @__PURE__ */ S.jsx(Ge, { variant: { weight: "bold" }, children: c.ss.token.symbol })
                ]
              }
            ),
            /* @__PURE__ */ S.jsx(fy, {})
          ]
        }
      ) }),
      children: /* @__PURE__ */ S.jsx(
        kN,
        {
          estimateSize: () => 60,
          groupCounts: c.groupCounts,
          groupContent: (u) => /* @__PURE__ */ S.jsx(ae, { py: "4", px: "4", background: "modalBodyBackground", children: /* @__PURE__ */ S.jsx(Ge, { variant: { weight: "bold" }, children: c.groups[u] }) }),
          itemContent: (u) => {
            const f = c.all[u];
            return /* @__PURE__ */ S.jsx(Cb, { children: typeof f == "string" ? /* @__PURE__ */ S.jsx(ae, { py: "4", children: /* @__PURE__ */ S.jsx(Ge, { variant: { weight: "bold" }, children: f }) }) : /* @__PURE__ */ S.jsx(K6e, { index: u, item: f }) });
          }
        }
      )
    }
  ) : null;
}, yee = () => /* @__PURE__ */ S.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 15 14",
    fill: "none",
    color: "#2470FFe6",
    children: /* @__PURE__ */ S.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M4.79.7a.7.7 0 1 0-1.4 0c0 .21-.112.478-.342.708-.23.23-.498.342-.708.342a.7.7 0 0 0 0 1.4c.21 0 .478.112.708.342.23.23.342.498.342.708a.7.7 0 0 0 1.4 0c0-.21.112-.478.342-.708.23-.23.498-.342.708-.342a.7.7 0 1 0 0-1.4c-.202 0-.47-.113-.705-.35C4.9 1.16 4.79.89 4.79.7Zm5.6 2.1a.7.7 0 0 1 .7.7c0 .527.284 1.147.783 1.652.497.504 1.115.798 1.667.798a.7.7 0 1 1 0 1.4c-.56 0-1.178.287-1.67.78-.493.492-.78 1.11-.78 1.67a.7.7 0 1 1-1.4 0c0-.56-.287-1.178-.78-1.67-.492-.493-1.11-.78-1.67-.78a.7.7 0 1 1 0-1.4c.56 0 1.178-.287 1.67-.78.493-.492.78-1.11.78-1.67a.7.7 0 0 1 .7-.7Zm-7 4.9a.7.7 0 0 1 .7.7c0 .359.196.804.564 1.176.366.37.81.574 1.186.574a.7.7 0 1 1 0 1.4c-.385 0-.828.2-1.19.56-.36.362-.56.805-.56 1.19a.7.7 0 1 1-1.4 0c0-.385-.2-.828-.56-1.19-.361-.36-.805-.56-1.19-.56a.7.7 0 1 1 0-1.4c.385 0 .829-.2 1.19-.56.36-.362.56-.805.56-1.19a.7.7 0 0 1 .7-.7Z",
        clipRule: "evenodd"
      }
    )
  }
);
var Q6e = "_10xz6vc1 _10xz6vc0 yv8y4r2t yv8y4rrd yv8y4rre";
const X6e = ({
  rewardToken: e,
  ...t
}) => {
  const n = t.type === "stake" ? "details.reward_token" : t.type === "pendingAction" ? `pending_action_review.pending_action_type.${t.pendingAction.toLowerCase()}` : "unstake_review.unstake_from";
  return e.map((r) => /* @__PURE__ */ S.jsx(S.Fragment, { children: /* @__PURE__ */ S.jsxs(ae, { display: "flex", alignItems: "center", gap: "2", children: [
    he.fromNullable(r.logoUri).filter(() => vee(r.providerName)).map((i) => /* @__PURE__ */ S.jsxs(
      ae,
      {
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        gap: "1",
        alignSelf: "flex-start",
        children: [
          /* @__PURE__ */ S.jsx(
            Hc,
            {
              imageProps: { borderRadius: "full" },
              containerProps: { hw: "5" },
              src: i,
              fallback: /* @__PURE__ */ S.jsx(df, { name: r.providerName, tokenLogoHw: "5" })
            }
          ),
          /* @__PURE__ */ S.jsx(ae, { width: "5", height: "5", children: /* @__PURE__ */ S.jsx(yee, {}) })
        ]
      }
    )).extractNullable(),
    /* @__PURE__ */ S.jsx(Ge, { variant: { weight: "semibold" }, children: /* @__PURE__ */ S.jsx(
      _a,
      {
        i18nKey: n,
        values: { providerName: r.providerName },
        components: {
          symbols1: /* @__PURE__ */ S.jsx(S.Fragment, { children: r.symbols }),
          highlight2: /* @__PURE__ */ S.jsx(
            Ge,
            {
              as: "span",
              className: Q6e,
              variant: { type: "muted", weight: "medium" }
            }
          )
        }
      }
    ) })
  ] }) })).extractNullable();
}, vee = (e) => /morpho/i.test(e), Oz = () => {
  const { t: e } = ln(), { variant: t } = dr(), { rewardToken: n, estimatedRewards: r, symbol: i } = ml(), o = r.mapOrDefault(
    (c) => `${c.yearly} ${i}`,
    ""
  ), s = r.mapOrDefault(
    (c) => `${c.monthly} ${i}`,
    ""
  );
  return /* @__PURE__ */ S.jsxs(ae, { "data-rk": "yield-rewards", children: [
    t === "default" && /* @__PURE__ */ S.jsx(ae, { marginTop: "3", children: /* @__PURE__ */ S.jsx(X6e, { rewardToken: n, type: "stake" }) }),
    /* @__PURE__ */ S.jsxs(ae, { display: "flex", flexDirection: "column", gap: "2", marginTop: "3", children: [
      t === "zerion" && n.map((c) => /* @__PURE__ */ S.jsxs(
        ae,
        {
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          gap: "2",
          children: [
            /* @__PURE__ */ S.jsx(Ge, { variant: { type: "muted", weight: "normal" }, children: /* @__PURE__ */ S.jsx(
              _a,
              {
                i18nKey: "details.rewards.receive",
                components: {
                  symbols1: /* @__PURE__ */ S.jsx(ae, { as: "span", fontWeight: "bold", children: c.symbols })
                }
              }
            ) }),
            /* @__PURE__ */ S.jsxs(
              ae,
              {
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                flexShrink: 0,
                children: [
                  c.logoUri && /* @__PURE__ */ S.jsxs(
                    ae,
                    {
                      marginRight: "1",
                      display: "flex",
                      justifyContent: "center",
                      alignItems: "center",
                      gap: "1",
                      children: [
                        /* @__PURE__ */ S.jsx(
                          Hc,
                          {
                            imageProps: { borderRadius: "full" },
                            containerProps: { hw: "5" },
                            src: c.logoUri,
                            fallback: /* @__PURE__ */ S.jsx(
                              df,
                              {
                                name: c.providerName,
                                tokenLogoHw: "5"
                              }
                            )
                          }
                        ),
                        vee(c.providerName) && /* @__PURE__ */ S.jsx(ae, { width: "5", height: "5", children: /* @__PURE__ */ S.jsx(yee, {}) })
                      ]
                    }
                  ),
                  /* @__PURE__ */ S.jsx(Ge, { variant: { type: "muted", weight: "normal" }, children: c.providerName })
                ]
              }
            )
          ]
        }
      )).extractNullable(),
      /* @__PURE__ */ S.jsxs(
        ae,
        {
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          "data-testid": "estimated-reward__yearly",
          "data-rk": "estimated-reward__yearly",
          gap: "2",
          children: [
            /* @__PURE__ */ S.jsx(Ge, { variant: { type: "muted", weight: "normal" }, children: e(
              t === "zerion" ? "details.rewards.yearly" : "shared.yearly"
            ) }),
            /* @__PURE__ */ S.jsx(Ge, { variant: { type: "muted", weight: "normal" }, children: o })
          ]
        }
      ),
      /* @__PURE__ */ S.jsxs(
        ae,
        {
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          "data-testid": "estimated-reward__monthly",
          "data-rk": "estimated-reward__monthly",
          gap: "2",
          children: [
            /* @__PURE__ */ S.jsx(Ge, { variant: { type: "muted", weight: "normal" }, children: e("shared.monthly") }),
            /* @__PURE__ */ S.jsx(Ge, { variant: { type: "muted", weight: "normal" }, children: s })
          ]
        }
      )
    ] })
  ] });
}, J6e = (e) => {
  const t = e.map((i) => {
    const o = Number.parseFloat(i.percentage);
    return Number.isNaN(o) ? i.percentage : o;
  }).extractNullable(), n = rQ(0);
  k.useEffect(() => {
    if (t === null || typeof t == "string")
      return n.set(0);
    t !== n.get() && G2e(n, t, {
      duration: 0.8,
      ease: "easeInOut"
    });
  }, [t, n]);
  const r = A2e(
    n,
    (i) => `${i.toFixed(2)}%`
  );
  return typeof t == "string" ? t : r;
}, Z6e = () => {
  const {
    appLoading: e,
    selectedStakeData: t,
    estimatedRewards: n,
    selectedStake: r,
    selectYieldIsLoading: i
  } = ml(), { variant: o } = dr(), { t: s } = ln(), c = e || i, u = J6e(n);
  return c ? /* @__PURE__ */ S.jsx(ae, { marginTop: "2", children: /* @__PURE__ */ S.jsx(hf, { heightPx: 112.5 }) }) : t.map((f) => f.all.length === 0 ? /* @__PURE__ */ S.jsx(
    ae,
    {
      my: "4",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      children: /* @__PURE__ */ S.jsx(Ge, { children: s("details.no_opportunities") })
    }
  ) : /* @__PURE__ */ S.jsxs(ae, { children: [
    o === "default" && /* @__PURE__ */ S.jsx(ae, { my: "2", children: /* @__PURE__ */ S.jsx(Ge, { children: s("details.earn") }) }),
    /* @__PURE__ */ S.jsxs(
      ae,
      {
        "data-rk": "stake-yield-section",
        background: "stakeSectionBackground",
        borderRadius: "xl",
        marginTop: "2",
        py: "4",
        px: "4",
        children: [
          o === "zerion" && /* @__PURE__ */ S.jsx(ae, { my: "1", children: /* @__PURE__ */ S.jsx(Ge, { children: s("details.earn") }) }),
          /* @__PURE__ */ S.jsxs(
            ae,
            {
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              children: [
                /* @__PURE__ */ S.jsx(ae, { minWidth: "0", display: "flex", marginRight: "2", flex: 1, children: /* @__PURE__ */ S.jsxs(
                  ae,
                  {
                    position: "relative",
                    "data-testid": "estimated-reward__percent",
                    children: [
                      r.filter((p) => p.rewardType === "variable").map(() => /* @__PURE__ */ S.jsx(
                        kC,
                        {
                          asChild: !0,
                          maxWidth: 160,
                          label: s("details.reward_rate_estimate_tooltip"),
                          children: /* @__PURE__ */ S.jsx(ae, { className: M6e, children: /* @__PURE__ */ S.jsx(Ge, { variant: { size: "large" }, children: "*" }) })
                        }
                      )).extractNullable(),
                      /* @__PURE__ */ S.jsx(gi.div, { className: D6e, children: u })
                    ]
                  }
                ) }),
                /* @__PURE__ */ S.jsx(ae, { display: "flex", justifyContent: "center", alignItems: "center", children: /* @__PURE__ */ S.jsx(Y6e, {}) })
              ]
            }
          ),
          o === "default" && /* @__PURE__ */ S.jsx(Oz, {})
        ]
      }
    ),
    o === "zerion" && /* @__PURE__ */ S.jsxs(ae, { display: "flex", flexDirection: "column", gap: "3", children: [
      /* @__PURE__ */ S.jsx(Oz, {}),
      /* @__PURE__ */ S.jsx(Gl, {})
    ] })
  ] })).extractNullable();
}, eLe = () => {
  const { selectedStake: e, appLoading: t } = ml(), { t: n } = ln();
  return t ? null : e.filter(
    (r) => !!(r.metadata.type === "staking" && !r.validators.length && r.metadata.provider)
  ).chainNullable((r) => r.metadata.provider).map((r) => /* @__PURE__ */ S.jsxs(
    ae,
    {
      display: "flex",
      justifyContent: "flex-start",
      alignItems: "center",
      marginTop: "2",
      gap: "2",
      "data-rk": "stake-token-section-staked-via",
      children: [
        /* @__PURE__ */ S.jsxs(Ge, { variant: { type: "regular", size: "medium" }, children: [
          n("details.earn_with"),
          " ",
          /* @__PURE__ */ S.jsx(ae, { as: "span", fontWeight: "bold", children: r.name })
        ] }),
        /* @__PURE__ */ S.jsx(
          Hc,
          {
            containerProps: { hw: "7" },
            src: r.logoURI,
            fallback: /* @__PURE__ */ S.jsx(df, { name: r.name, tokenLogoHw: "7" })
          }
        )
      ]
    }
  )).extractNullable();
}, tLe = () => {
  sa("earn");
  const { t: e } = ln(), { variant: t } = dr(), { referralCheck: n, isError: r } = ml(), { mountAnimationFinished: i, dispatch: o } = ff(), { disableInitLayoutAnimation: s } = dr(), { animate: c, initial: u } = _n({
    opacity: 1,
    translateY: 0
  }).chain(
    (f) => _n(null).map(() => i ? {
      transition: { duration: 0.3, delay: 0 },
      initial: { opacity: 0, translateY: "-10px" }
    } : s ? {
      transition: { duration: 0 },
      initial: { opacity: 1, translateY: 0 }
    } : {
      transition: { duration: 1, delay: 0.8 },
      initial: { opacity: 0, translateY: "-40px" }
    }).map((p) => ({
      animate: { ...f, transition: p.transition },
      initial: p.initial
    }))
  ).unsafeCoerce();
  return /* @__PURE__ */ S.jsx(
    gi.div,
    {
      initial: u,
      animate: c,
      onAnimationComplete: (f) => {
        f.translateY !== 0 || i || o({ type: "earnPage" });
      },
      children: /* @__PURE__ */ S.jsxs(fp, { children: [
        /* @__PURE__ */ S.jsxs(ae, { children: [
          t === "default" && /* @__PURE__ */ S.jsx(dee, {}),
          /* @__PURE__ */ S.jsx(ZJ, {}),
          /* @__PURE__ */ S.jsx(F6e, {}),
          /* @__PURE__ */ S.jsx(Z6e, {}),
          /* @__PURE__ */ S.jsx(eLe, {}),
          /* @__PURE__ */ S.jsx(G6e, {}),
          /* @__PURE__ */ S.jsx(S6e, {})
        ] }),
        r && /* @__PURE__ */ S.jsx(
          ae,
          {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            my: "4",
            children: /* @__PURE__ */ S.jsx(Ge, { variant: { type: "danger" }, textAlign: "center", children: e("shared.something_went_wrong") })
          }
        ),
        /* @__PURE__ */ S.jsx(ae, { marginTop: "4", children: /* @__PURE__ */ S.jsx(k6e, {}) }),
        n && /* @__PURE__ */ S.jsx(ae, { marginTop: "4", children: /* @__PURE__ */ S.jsx(_6e, {}) })
      ] })
    }
  );
}, nLe = () => /* @__PURE__ */ S.jsx(F3e, { children: /* @__PURE__ */ S.jsx(E6e, { children: /* @__PURE__ */ S.jsx(tLe, {}) }) });
var rLe = "_1b4p78a0", iLe = "_1b4p78a2 _1b4p78a1 yv8y4re5 yv8y4rcn yv8y4r9l yv8y4rb3", oLe = "_1b4p78a7 _1b4p78a6 yv8y4ri7 yv8y4rgp yv8y4r10 yv8y4r2n yv8y4rg1 yv8y4rfj yv8y4r1 yv8y4rwp yv8y4rwq", aLe = "_1b4p78a8", sLe = "_1b4p78aa _1b4p78a9 yv8y4rw5 yv8y4rw6 yv8y4r10 yv8y4r1";
const xI = ({
  isSelected: e,
  variant: t,
  pendingActionsCount: n,
  onTabPress: r
}) => {
  const { t: i } = ln();
  return /* @__PURE__ */ S.jsxs(ae, { className: rLe, children: [
    /* @__PURE__ */ S.jsx(ae, { className: zs([RA, iLe]), onClick: r, children: /* @__PURE__ */ S.jsxs(
      ae,
      {
        ...t === "positions" && { position: "relative" },
        display: "inline-flex",
        children: [
          /* @__PURE__ */ S.jsx(
            Ge,
            {
              "data-state": e ? "selected" : "default",
              variant: { type: e ? "regular" : "muted" },
              children: i(`details.tabs.${t}`, t)
            }
          ),
          !!n && /* @__PURE__ */ S.jsx(ae, { className: oLe, children: /* @__PURE__ */ S.jsx(Ge, { style: { fontSize: 8 }, children: n }) })
        ]
      }
    ) }),
    e ? /* @__PURE__ */ S.jsx(
      gi.div,
      {
        className: sLe,
        layoutId: "underline",
        transition: { duration: 0.15 }
      }
    ) : null
  ] });
}, lLe = ({
  selectedTab: e,
  onTabPress: t,
  pendingActionsCount: n
}) => {
  const { state: r } = ff(), { disableInitLayoutAnimation: i } = dr(), { animate: o, initial: s } = _n({ opacity: 1, translateY: 0 }).chain(
    (c) => _n(null).map(() => r.layout || i ? {
      transition: { duration: 0 },
      initial: { opacity: 1, translateY: 0 }
    } : {
      transition: { duration: 1, delay: 0.5 },
      initial: { opacity: 0, translateY: "-40px" }
    }).map((u) => ({
      animate: { ...c, transition: u.transition },
      initial: u.initial
    }))
  ).unsafeCoerce();
  return /* @__PURE__ */ S.jsx(gi.div, { initial: s, animate: o, children: /* @__PURE__ */ S.jsxs(ae, { position: "relative", display: "flex", justifyContent: "center", children: [
    /* @__PURE__ */ S.jsxs(
      ae,
      {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        "data-rk": "tabs-section",
        zIndex: "simple",
        children: [
          /* @__PURE__ */ S.jsx(
            xI,
            {
              isSelected: e === "earn",
              onTabPress: () => t("earn"),
              variant: "earn"
            }
          ),
          /* @__PURE__ */ S.jsx(
            xI,
            {
              isSelected: e === "positions",
              onTabPress: () => t("positions"),
              variant: "positions",
              pendingActionsCount: n
            }
          ),
          /* @__PURE__ */ S.jsx(
            xI,
            {
              isSelected: e === "activity",
              onTabPress: () => t("activity"),
              variant: "activity"
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ S.jsx(ae, { className: aLe, children: /* @__PURE__ */ S.jsx(Gl, {}) })
  ] }) });
}, cLe = {
  earn: "/",
  positions: "/positions",
  activity: "/activity"
}, uLe = () => {
  const e = Bi(), { positionsData: t } = tZ(), n = k.useMemo(
    () => t.data.reduce((u, f) => f.hasPendingClaimRewards || f.actionRequired ? u + 1 : u, 0),
    [t.data]
  ), { current: r } = EN(), i = La(), [o, s] = k.useState("earn");
  r.pathname === "/" && o === "positions" ? s("earn") : r.pathname === "/positions" && o === "earn" ? s("positions") : r.pathname === "/activity" && o === "earn" && s("activity");
  const c = (u) => {
    o !== u && (e("tabClicked", { selected: u }), s(u), i(cLe[u]));
  };
  return /* @__PURE__ */ S.jsx(
    gi.div,
    {
      exit: { opacity: 0, filter: "blur(8px)", scale: 0.8 },
      transition: { exit: { duration: 0.4 } },
      children: /* @__PURE__ */ S.jsxs(ae, { flex: 1, display: "flex", flexDirection: "column", children: [
        /* @__PURE__ */ S.jsx(ae, { marginBottom: "1", children: /* @__PURE__ */ S.jsx(
          lLe,
          {
            onTabPress: c,
            selectedTab: o,
            pendingActionsCount: n
          }
        ) }),
        /* @__PURE__ */ S.jsx(ae, { display: "flex", flex: 1, flexDirection: "column", children: /* @__PURE__ */ S.jsx(lN, {}) })
      ] })
    }
  );
}, dLe = () => {
  const e = ZA(), t = ss(
    e,
    (ee) => ee.context.data
  ).unsafeCoerce(), n = t.requestDto.integrationId, r = cM(n), i = k.useMemo(
    () => new Nt(t.requestDto.args.amount),
    [t]
  ), o = Hue(
    t.requestDto,
    { query: { staleTime: 0, gcTime: 0 } }
  ), s = k.useMemo(
    () => {
      var ee;
      return he.fromNullable((ee = o.data) == null ? void 0 : ee.amount).map(Nt);
    },
    [o.data]
  ), c = LN({
    gasAmount: s,
    gasFeeToken: t.gasFeeToken,
    address: t.requestDto.addresses.address,
    additionalAddresses: t.requestDto.addresses.additionalAddresses,
    isStake: !0,
    stakeAmount: i,
    stakeToken: t.selectedToken
  }), u = k.useMemo(
    () => he.of(t.selectedStake),
    [t.selectedStake]
  ), f = k.useMemo(
    () => he.of(t.selectedToken),
    [t.selectedToken]
  ), p = nee(u), y = tee({
    selectedStake: u,
    stakeAmount: i,
    selectedValidators: t.selectedValidators
  }), v = Xh(u).mapOrDefault(
    (ee) => ee.review,
    ""
  ), w = k.useMemo(() => To(i), [i]), C = k.useMemo(
    () => y.mapOrDefault((ee) => ee.percentage.toString(), ""),
    [y]
  ), x = fA({
    token: f,
    yieldDto: u
  }), A = k.useMemo(
    () => kP({
      gas: s,
      prices: he.fromNullable(x.data),
      yieldDto: u
    }),
    [x.data, u, s]
  ), { depositFee: R, managementFee: I, performanceFee: D } = FN({
    amount: i,
    token: f,
    feeConfigDto: k.useMemo(
      () => he.fromNullable(r.data),
      [r.data]
    ),
    prices: k.useMemo(
      () => he.fromNullable(x.data),
      [x.data]
    )
  }), M = u.map((ee) => ee.metadata), L = La(), j = jue(), F = ec({
    mutationFn: async () => (await Ia({
      fn: () => j(t.requestDto)
    }).mapLeft((ee) => {
      var ie;
      return Qd(ee) && HD.isStakingNotAllowedErrorDto(
        (ie = ee.response) == null ? void 0 : ie.data
      ) ? new HD() : new Error("Stake enter error");
    }).chain(
      (ee) => Ye.liftEither(vP(ee))
    )).unsafeCoerce(),
    onSuccess: (ee) => {
      e.send({ type: "setActionDto", data: ee }), L("/steps");
    }
  }), z = Pr(() => F.mutate()), { t: H } = ln();
  py(
    k.useMemo(
      () => ({
        disabled: !1,
        isLoading: F.isPending,
        label: H("shared.confirm"),
        onClick: () => z.current()
      }),
      [z, H, F.isPending]
    )
  );
  const { variant: Q } = dr(), Y = k.useMemo(
    () => Q === "zerion" ? {
      showMetaInfo: !0,
      metaInfoProps: {
        selectedStake: u,
        selectedToken: f,
        selectedValidators: t.selectedValidators
      }
    } : { showMetaInfo: !1 },
    [u, f, t.selectedValidators, Q]
  );
  return {
    token: f,
    amount: w,
    fee: A,
    interestRate: C,
    yieldType: v,
    rewardToken: p,
    metadata: M,
    metaInfo: Y,
    isGasCheckWarning: !!c.data,
    gasCheckLoading: o.isLoading || c.isLoading,
    depositFee: R,
    managementFee: I,
    performanceFee: D,
    feeConfigLoading: r.isPending
  };
};
class HD extends Error {
  constructor() {
    super("Staking not allowed, needs unstaking and trying again");
  }
}
Ms(HD, "isStakingNotAllowedErrorDto", (t) => {
  const n = t;
  return n && n.code === 422 && n.type === "STAKING_ERROR";
});
const fLe = () => {
  sa("stakeReview");
  const {
    fee: e,
    yieldType: t,
    amount: n,
    interestRate: r,
    metadata: i,
    rewardToken: o,
    token: s,
    metaInfo: c,
    gasCheckLoading: u,
    isGasCheckWarning: f,
    depositFee: p,
    managementFee: y,
    performanceFee: v,
    feeConfigLoading: w
  } = dLe(), C = k.useMemo(
    () => s.map((A) => /* @__PURE__ */ S.jsx(
      _a,
      {
        i18nKey: "review.amount_and_earn",
        values: {
          amount: n,
          tokenSymbol: A.symbol,
          interestRate: r
        },
        components: {
          highlight0: /* @__PURE__ */ S.jsx(eI, {}),
          highlight1: /* @__PURE__ */ S.jsx(eI, {}),
          highlight3: /* @__PURE__ */ S.jsx(eI, {})
        }
      }
    )).extractNullable(),
    [n, r, s]
  ), x = k.useMemo(
    () => he.of({ rewardToken: o, type: "stake" }),
    [o]
  );
  return /* @__PURE__ */ S.jsx(
    UN,
    {
      fee: e,
      depositFee: p,
      managementFee: y,
      performanceFee: v,
      feeConfigLoading: w,
      title: t,
      metadata: i,
      token: s,
      info: C,
      rewardTokenDetailsProps: x,
      isGasCheckError: f,
      loading: u,
      ...c
    }
  );
}, hLe = () => {
  sa("stakingSteps");
  const { address: e, network: t } = fr(), n = ss(
    ZA(),
    (i) => i.context.data
  ).unsafeCoerce(), r = () => he.fromRecord({
    network: he.fromNullable(t),
    address: he.fromNullable(e)
  }).ifJust(
    (i) => n.selectedValidators.forEach(
      (o) => eZ({
        validatorData: {
          integrationId: n.selectedStake.id,
          validator: o
        },
        network: i.network,
        address: i.address
      })
    )
  );
  return /* @__PURE__ */ S.jsx(
    JA,
    {
      session: n.actionDto.unsafeCoerce(),
      onSignSuccess: r
    }
  );
};
var pLe = "pk0cy50";
const mLe = ({
  disabled: e,
  isLoading: t,
  onClick: n,
  label: r,
  variant: i
}) => {
  const { containerRef: o } = YIe(), { state: s } = ff(), [c, u] = k.useState(
    s.layout
  ), { disableInitLayoutAnimation: f } = dr(), { animate: p, initial: y } = _n({ translateY: 0, opacity: 1 }).chain(
    (v) => _n(null).map(() => f && !s.layout ? {
      animate: {},
      initial: { opacity: 1, translateY: 0 }
    } : s.layout ? {
      animate: {
        ...v,
        transition: {
          duration: c ? 0.3 : 0.6,
          delay: 0.2
        }
      },
      initial: { opacity: 0, translateY: "-20px" }
    } : {
      animate: {},
      initial: { opacity: 0, translateY: "-40px" }
    })
  ).unsafeCoerce();
  return /* @__PURE__ */ S.jsx(
    gi.div,
    {
      "data-rk": "footer-outlet",
      ref: o,
      className: pLe,
      initial: y,
      animate: p,
      onAnimationComplete: (v) => {
        v.translateY !== 0 || c || u(!0);
      },
      children: /* @__PURE__ */ S.jsx(ae, { px: "4", marginTop: "2", marginBottom: "4", zIndex: "modal", children: /* @__PURE__ */ S.jsx(
        ae,
        {
          flex: 1,
          display: "flex",
          justifyContent: "flex-end",
          flexDirection: "column",
          children: /* @__PURE__ */ S.jsx(
            Jl,
            {
              "data-rk": `footer-button-${i ?? "primary"}`,
              disabled: e,
              isLoading: t,
              onClick: n,
              variant: {
                color: i ?? (e || t ? "disabled" : "primary"),
                animation: "press"
              },
              children: r
            }
          )
        }
      ) })
    }
  );
}, yLe = () => {
  const [e] = uX(), [, t] = bN();
  return tf(() => {
    !e && t(0);
  }, [t, e]), e ? /* @__PURE__ */ S.jsx(mLe, { ...e }) : null;
}, vLe = ({
  positionBalancesData: e,
  prices: t,
  baseToken: n
}) => k.useMemo(
  () => he.fromRecord({ positionBalancesData: e, baseToken: n }).map(
    (r) => CLe({
      baseToken: r.baseToken,
      prices: t.data,
      pvd: r.positionBalancesData.balances
    })
  ),
  [e, t, n]
), gLe = (e) => e.prices, bLe = (e) => e.pvd, wLe = (e) => e.baseToken, CLe = $b(
  gLe,
  bLe,
  wLe,
  (e, t, n) => t.reduce((r, i) => {
    const o = new Nt(i.amount);
    if (o.isZero() || o.isNaN()) return r;
    const s = e ? Vb({
      amount: i.amount,
      prices: e,
      token: i.token,
      pricePerShare: i.pricePerShare,
      baseToken: n
    }) : new Nt(0), c = r.get(i.type);
    return r.set(i.type, [...c ?? [], { ...i, tokenPriceInUsd: s }]), r;
  }, /* @__PURE__ */ new Map())
), xLe = (e) => k.useMemo(
  () => e.chain(
    (t) => he.fromNullable(t.get("staked")).altLazy(
      () => he.fromNullable(t.get("available"))
    )
  ),
  [e]
), gee = k.createContext(void 0), bee = k.createContext(void 0), ELe = ({
  children: e
}) => {
  const { plain: t, pendingActionType: n } = wN(), r = t.balanceId, i = t.integrationId, o = yA(i), s = k.useMemo(
    () => he.fromNullable(o.data),
    [o.data]
  ), c = ix(s), u = xN({ balanceId: r, integrationId: i }), f = oK(
    k.useMemo(
      () => he.fromRecord({
        positionBalances: u.data,
        baseToken: c
      }).map((J) => ({
        currency: ni.currency,
        tokenList: [
          J.baseToken,
          ...J.positionBalances.balances.map((K) => K.token)
        ]
      })).extractNullable(),
      [u, c]
    )
  ), p = vLe({
    baseToken: c,
    positionBalancesData: u.data,
    prices: f
  }), y = xLe(
    p
  ), v = k.useMemo(
    () => y.map(
      (J) => J.reduce(
        (K, oe) => (K.amount = K.amount.plus(new Nt(oe.amount)), K.token = oe.token, K.pricePerShare = oe.pricePerShare, K),
        {
          amount: new Nt(0),
          token: J[0].token,
          pricePerShare: J[0].pricePerShare
        }
      )
    ),
    [y]
  ), w = k.useMemo(
    () => y.chain((J) => Wn.head(J)).map((J) => J.token),
    [y]
  ), { maxIntegrationAmount: C, maxEnterOrExitAmount: x, minEnterOrExitAmount: A } = aZ({
    yieldOpportunity: s,
    type: "exit",
    availableAmount: v.map((J) => J.amount)
  }), R = e3({
    type: "exit",
    integration: s
  }), I = s.map(
    (J) => {
      var K, oe, be;
      return !!(!R && ((be = (oe = (K = J.args.exit) == null ? void 0 : K.args) == null ? void 0 : oe.amount) != null && be.required));
    }
  ), D = k.useMemo(
    () => new Map(
      p.map(
        (J) => [...J.values()].flatMap(
          (K) => K.flatMap(
            (oe) => oe.pendingActions.map(
              (be) => [
                d8({
                  balanceType: oe.type,
                  token: oe.token,
                  actionType: be.type
                }),
                { pendingAction: be, balance: oe }
              ]
            )
          )
        )
      ).orDefault([])
    ),
    [p]
  ), M = ({
    state: J,
    amount: K,
    actionType: oe,
    balanceType: be,
    token: ce
  }) => {
    const pe = d8({ actionType: oe, balanceType: be, token: ce });
    return he.fromNullable(
      D.get(pe)
    ).mapOrDefault((Ee) => {
      var st, mt, yt, Ut, hn, wn, Ot, xt;
      const Se = new Map(J);
      Se.set(pe, K);
      const Me = new Nt(
        ((yt = (mt = (st = Ee.pendingAction.args) == null ? void 0 : st.args) == null ? void 0 : mt.amount) == null ? void 0 : yt.maximum) ?? Number.POSITIVE_INFINITY
      ), Fe = new Nt(
        ((wn = (hn = (Ut = Ee.pendingAction.args) == null ? void 0 : Ut.args) == null ? void 0 : hn.amount) == null ? void 0 : wn.minimum) ?? 0
      );
      return he.fromNullable((xt = (Ot = Ee.pendingAction.args) == null ? void 0 : Ot.args) == null ? void 0 : xt.amount).mapOrDefault(
        Ob,
        !1
      ) ? Se.set(pe, new Nt(Ee.balance.amount)) : K.isLessThan(Fe) ? Se.set(pe, Fe) : K.isGreaterThan(Me) && Se.set(pe, Me), Se;
    }, J);
  }, L = (J, K) => {
    switch (K.type) {
      case "unstake/amount/change":
        return {
          ...J,
          unstakeAmount: K.data
        };
      case "unstake/amount/max":
        return {
          ...J,
          unstakeAmount: x
        };
      case "pendingAction/amount/change":
        return {
          ...J,
          pendingActions: M({
            state: J.pendingActions,
            ...K.data
          })
        };
      default:
        return J;
    }
  }, [j, F] = k.useReducer(L, {
    unstakeAmount: A,
    pendingActions: /* @__PURE__ */ new Map()
  }), { pendingActions: O, unstakeAmount: z } = j, H = k.useMemo(
    () => he.fromRecord({
      reducedStakedOrLiquidBalance: v,
      canChangeUnstakeAmount: I
    }).map((J) => (!J.canChangeUnstakeAmount || R) && !J.reducedStakedOrLiquidBalance.amount.isEqualTo(z) ? J.reducedStakedOrLiquidBalance.amount : z).orDefault(z),
    [
      z,
      I,
      R,
      v
    ]
  ), Q = k.useMemo(
    () => H.isGreaterThanOrEqualTo(A) && H.isLessThanOrEqualTo(x) && !H.isZero(),
    [x, A, H]
  ), Y = k.useMemo(
    () => H.isGreaterThan(x),
    [H, x]
  ), ee = k.useMemo(
    () => H.isLessThan(A),
    [H, A]
  ), ie = k.useMemo(
    () => H.isGreaterThan(C) || ee,
    [H, ee, C]
  ), X = k.useMemo(
    () => !H.isZero() && ee || Y || ie,
    [
      H,
      ee,
      Y,
      ie
    ]
  ), Z = k.useMemo(
    () => ({
      canChangeUnstakeAmount: I,
      unstakeAmountError: X,
      unstakeToken: w,
      unstakeAmount: H,
      pendingActions: O,
      positionBalancePrices: f,
      reducedStakedOrLiquidBalance: v,
      positionBalancesByType: p,
      stakedOrLiquidBalances: y,
      yieldOpportunity: o,
      positionBalances: u,
      pendingActionType: n,
      integrationData: s,
      unstakeAmountValid: Q,
      unstakeIsGreaterOrLessIntegrationLimitError: ie
    }),
    [
      I,
      X,
      w,
      H,
      O,
      f,
      v,
      p,
      y,
      o,
      u,
      s,
      Q,
      n,
      ie
    ]
  );
  return /* @__PURE__ */ S.jsx(gee.Provider, { value: Z, children: /* @__PURE__ */ S.jsx(bee.Provider, { value: F, children: e }) });
}, c3 = () => {
  const e = k.useContext(gee);
  if (e === void 0)
    throw new Error("useState must be used within a UnstakeContextProvider");
  return e;
}, wee = () => {
  const e = k.useContext(bee);
  if (e === void 0)
    throw new Error("useDispatch must be used within a UnstakeContextProvider");
  return e;
}, Iz = ({
  onAmountChange: e,
  value: t,
  canChangeAmount: n,
  disabled: r,
  onClick: i,
  label: o,
  formattedAmount: s,
  onMaxClick: c,
  balance: u,
  unstakeAmountError: f,
  ...p
}) => {
  const { t: y } = ln(), v = he.fromPredicate(
    (C) => C.variant === "unstake",
    p
  ).map(
    (C) => [
      C.unstakeMinAmount.map(
        (x) => `${y("shared.min")} ${To(new Nt(x))} ${C.unstakeToken.symbol}`
      ).extractNullable(),
      C.unstakeMaxAmount.map(
        (x) => `${y("shared.max")} ${To(new Nt(x))} ${C.unstakeToken.symbol}`
      ).extractNullable(),
      C.unstakeIsGreaterOrLessIntegrationLimitError
    ]
  ).filter((C) => C.some(Boolean)).map(([C, x, A]) => /* @__PURE__ */ S.jsx(
    ae,
    {
      display: "flex",
      justifyContent: "flex-end",
      alignItems: "center",
      marginTop: "2",
      marginRight: "2",
      children: /* @__PURE__ */ S.jsx(
        Ge,
        {
          variant: { type: A ? "danger" : "muted" },
          textAlign: "right",
          children: C && x ? `${C} / ${x}` : C ?? x
        },
        "min"
      )
    }
  )).extractNullable(), w = p.variant === "action" ? {
    background: "background",
    borderWidth: 1,
    borderStyle: "solid",
    borderColor: "backgroundMuted"
  } : { background: "stakeSectionBackground" };
  return /* @__PURE__ */ S.jsxs(ae, { ...w, borderRadius: "xl", marginTop: "2", py: "4", px: "4", children: [
    (p.variant === "action" || p.canUnstake) && /* @__PURE__ */ S.jsxs(ae, { marginBottom: "3", children: [
      /* @__PURE__ */ S.jsxs(
        ae,
        {
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          children: [
            /* @__PURE__ */ S.jsx(ae, { minWidth: "0", display: "flex", marginRight: "2", flex: 1, children: /* @__PURE__ */ S.jsx(
              nX,
              {
                onChange: e,
                value: t,
                disabled: !n,
                shakeOnInvalid: !0,
                isInvalid: f
              }
            ) }),
            /* @__PURE__ */ S.jsx(
              Jl,
              {
                onClick: i,
                disabled: r,
                variant: {
                  size: "small",
                  color: p.variant === "unstake" ? "smallButton" : "smallButtonLight"
                },
                children: /* @__PURE__ */ S.jsx(Ge, { children: o })
              }
            )
          ]
        }
      ),
      v,
      /* @__PURE__ */ S.jsxs(
        ae,
        {
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          marginTop: "2",
          flexWrap: "wrap",
          children: [
            /* @__PURE__ */ S.jsx(ae, { className: aPe, children: /* @__PURE__ */ S.jsx(Ge, { variant: { type: "muted", weight: "normal" }, children: s }) }),
            /* @__PURE__ */ S.jsxs(
              ae,
              {
                flexGrow: 1,
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                children: [
                  u && /* @__PURE__ */ S.jsx(lee, { children: /* @__PURE__ */ S.jsx(cee, { children: ({ state: C }) => {
                    var x;
                    return /* @__PURE__ */ S.jsx(Ge, { variant: { weight: "normal" }, children: y("position_details.available", {
                      amount: C === "full" ? To(u.amount) : Na(u.amount),
                      symbol: ((x = u.token) == null ? void 0 : x.symbol) ?? ""
                    }) });
                  } }) }),
                  n && c && /* @__PURE__ */ S.jsx(
                    aee,
                    {
                      onMaxClick: c,
                      background: p.variant === "unstake" ? "background" : "backgroundMuted"
                    }
                  )
                ]
              }
            )
          ]
        }
      )
    ] }),
    p.variant === "unstake" && /* @__PURE__ */ S.jsx(ae, { children: /* @__PURE__ */ S.jsx(
      SLe,
      {
        validators: p.validators,
        yieldDto: p.yieldDto,
        unstakeToken: p.unstakeToken
      }
    ) })
  ] });
}, SLe = ({
  validators: e,
  yieldDto: t,
  unstakeToken: n
}) => {
  const { withdrawnTime: r, withdrawnNotAvailable: i } = yJ({
    validators: e,
    selectedStake: _n(t),
    tokenDto: _n(n)
  });
  return k.useMemo(
    () => _n([r, i]).map((o) => o.filter((s) => s !== null)).filter((o) => !!o.length).map((o) => /* @__PURE__ */ S.jsx(ae, { display: "flex", flexDirection: "column", gap: "2", children: o.map((s, c) => /* @__PURE__ */ S.jsxs(
      ae,
      {
        display: "flex",
        alignItems: "center",
        justifyContent: "flex-start",
        gap: "1",
        children: [
          /* @__PURE__ */ S.jsx(ae, { display: "flex", alignItems: "center", justifyContent: "center", children: /* @__PURE__ */ S.jsx(qm, {}) }),
          /* @__PURE__ */ S.jsx(Ge, { variant: { type: "muted", size: "small" }, children: s })
        ]
      },
      c
    )) })).extractNullable(),
    [r, i]
  );
}, kLe = ({
  yieldBalance: e,
  integrationData: t
}) => {
  const { t: n } = ln(), r = k.useMemo(() => (e.type === "unstaking" || e.type === "unlocking") && e.date ? J5e(new Date(e.date)) : null, [e.date, e.type]), i = t.metadata.type, o = i === "vault" || i === "lending" ? "yearn_or_deposit" : void 0;
  return /* @__PURE__ */ S.jsxs(
    ae,
    {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      gap: "4",
      children: [
        /* @__PURE__ */ S.jsx(Ge, { variant: { weight: "normal" }, children: n(`position_details.balance_type.${e.type}`, {
          context: o
        }) }),
        /* @__PURE__ */ S.jsxs(ae, { textAlign: "end", children: [
          /* @__PURE__ */ S.jsxs(ae, { display: "flex", gap: "1", alignItems: "center", children: [
            e.token.isPoints && /* @__PURE__ */ S.jsx(ae, { as: "span", display: "inline-flex", children: /* @__PURE__ */ S.jsx(
              nf,
              {
                token: e.token,
                hideNetwork: !0,
                tokenLogoHw: "5"
              }
            ) }),
            /* @__PURE__ */ S.jsxs(
              Ge,
              {
                overflowWrap: "anywhere",
                variant: { type: "muted", weight: "normal" },
                children: [
                  Na(new Nt(e.amount ?? 0)),
                  " ",
                  e.token.symbol,
                  !e.token.isPoints && ` ($${Na(e.tokenPriceInUsd)})`
                ]
              }
            )
          ] }),
          typeof r == "number" && /* @__PURE__ */ S.jsx(Ge, { variant: { type: "muted", weight: "normal" }, children: n("position_details.unstaking_days", {
            count: r
          }) })
        ] })
      ]
    }
  );
};
var ALe = "ti8s800";
const u3 = k.createContext(
  void 0
), d3 = () => {
  const e = k.useContext(u3);
  if (!e)
    throw new Error("useCopyText must be used within a CopyTextProvider");
  return e;
}, TLe = ({
  text: e,
  children: t
}) => {
  const [n, r] = k.useState(!1), i = k.useCallback(() => {
    Ro.ifJust((s) => s.navigator.clipboard.writeText(e)), r(!0);
  }, [e]);
  k.useEffect(() => {
    if (!n) return;
    const s = setTimeout(() => r(!1), 1e3);
    return () => {
      clearTimeout(s);
    };
  }, [n]);
  const o = k.useMemo(
    () => ({ showCopySuccess: n, onClick: i }),
    [i, n]
  );
  return /* @__PURE__ */ S.jsx(u3.Provider, { value: o, children: t });
}, _Le = ({
  children: e
}) => {
  const { onClick: t, showCopySuccess: n } = d3();
  return /* @__PURE__ */ S.jsx(
    ae,
    {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      onClick: t,
      as: "a",
      className: ALe,
      children: typeof e == "function" ? e({ showCopySuccess: n }) : e
    }
  );
}, RLe = ({
  children: e,
  className: t
}) => {
  const { showCopySuccess: n, onClick: r } = d3();
  return /* @__PURE__ */ S.jsx(_A, { mode: "wait", initial: !1, children: /* @__PURE__ */ S.jsx(
    gi.div,
    {
      whileTap: { scale: n ? 1 : 0.9 },
      initial: { opacity: 0 },
      animate: { opacity: 1, transition: { duration: 0.3 } },
      exit: { opacity: 0, transition: { duration: 0 } },
      className: t,
      children: /* @__PURE__ */ S.jsx(u3.Provider, { value: { showCopySuccess: n, onClick: r }, children: e })
    },
    n ? "check" : "copy"
  ) });
}, OLe = ({
  hw: e,
  className: t
}) => {
  const { showCopySuccess: n } = d3();
  return n ? /* @__PURE__ */ S.jsx(
    iee,
    {
      className: t,
      hw: e,
      color: "positionsClaimRewardsBackground"
    }
  ) : /* @__PURE__ */ S.jsx(oee, { className: t, hw: e });
}, ILe = ({
  stakeType: e,
  isFirst: t,
  integrationData: n,
  logo: r,
  ...i
}) => {
  const { t: o } = ln(), s = i.name ?? i ?? "";
  return /* @__PURE__ */ S.jsx(S.Fragment, { children: /* @__PURE__ */ S.jsx(WJ, { children: /* @__PURE__ */ S.jsxs(ae, { display: "flex", flexDirection: "column", children: [
    t && /* @__PURE__ */ S.jsx(Gl, {}),
    /* @__PURE__ */ S.jsxs(
      ae,
      {
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        my: "2",
        children: [
          /* @__PURE__ */ S.jsxs(ae, { display: "flex", justifyContent: "flex-start", alignItems: "center", children: [
            /* @__PURE__ */ S.jsx(ae, { marginRight: "2", children: /* @__PURE__ */ S.jsx(
              Hc,
              {
                containerProps: { hw: "8" },
                imageProps: { borderRadius: "full" },
                src: r,
                fallback: /* @__PURE__ */ S.jsx(ae, { marginRight: "1", children: /* @__PURE__ */ S.jsx(
                  df,
                  {
                    name: s,
                    tokenLogoHw: "8",
                    textVariant: { type: "white", weight: "bold" }
                  }
                ) })
              }
            ) }),
            /* @__PURE__ */ S.jsx(Ge, { children: o("position_details.via", {
              stakeType: e,
              providerName: s
            }) }),
            i.preferred && /* @__PURE__ */ S.jsx(ae, { marginLeft: "1", display: "flex", children: /* @__PURE__ */ S.jsx(eT, {}) }),
            i.status && i.status !== "active" && /* @__PURE__ */ S.jsx(ae, { marginLeft: "1", className: ePe, children: /* @__PURE__ */ S.jsx(
              Ge,
              {
                variant: {
                  type: "white",
                  weight: "medium",
                  size: "small"
                },
                className: tPe,
                children: o(
                  i.status === "jailed" ? "details.validators_jailed" : "details.validators_inactive"
                )
              }
            ) })
          ] }),
          /* @__PURE__ */ S.jsx(GJ, { flex: 1, justifyContent: "flex-end", children: /* @__PURE__ */ S.jsx(KJ, {}) })
        ]
      }
    ),
    /* @__PURE__ */ S.jsx(YJ, { children: /* @__PURE__ */ S.jsx(
      DLe,
      {
        address: i.address,
        commission: i.commission,
        rewardRate: i.rewardRate,
        stakedBalance: i.stakedBalance,
        votingPower: i.votingPower,
        rewardType: i.rewardType,
        website: i.website,
        stakedBalanceToken: n.token
      }
    ) }),
    /* @__PURE__ */ S.jsx(Gl, {})
  ] }) }) });
}, DLe = k.memo((e) => {
  const t = fee(e);
  return /* @__PURE__ */ S.jsx(ae, { marginTop: "1", children: Object.entries(t).filter(
    (n) => !!n[1]
  ).map(([n, r]) => /* @__PURE__ */ S.jsxs(
    ae,
    {
      marginTop: "1",
      marginBottom: "3",
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      children: [
        /* @__PURE__ */ S.jsx(Ge, { variant: { weight: "normal" }, children: r.title }),
        n === "address" && e.address ? /* @__PURE__ */ S.jsx(TLe, { text: e.address, children: /* @__PURE__ */ S.jsx(_Le, { children: /* @__PURE__ */ S.jsxs(ae, { display: "flex", gap: "1", className: nPe, children: [
          /* @__PURE__ */ S.jsx(
            Ge,
            {
              variant: { type: "muted", weight: "normal" },
              className: rPe,
              children: r.val
            }
          ),
          /* @__PURE__ */ S.jsx(RLe, { children: /* @__PURE__ */ S.jsx(
            ae,
            {
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              children: /* @__PURE__ */ S.jsx(OLe, { hw: 16 })
            }
          ) })
        ] }) }) }) : /* @__PURE__ */ S.jsx(Ge, { variant: { type: "muted", weight: "normal" }, children: r.val })
      ]
    },
    n
  )) });
}), MLe = ({
  pendingActionDto: e,
  yieldBalance: t,
  onPendingActionClick: n
}) => {
  const { t: r } = ln();
  return /* @__PURE__ */ S.jsxs(
    ae,
    {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      px: "4",
      py: "4",
      borderRadius: "2xl",
      borderColor: "backgroundMuted",
      borderWidth: 1,
      borderStyle: "solid",
      children: [
        /* @__PURE__ */ S.jsx(ae, { flex: 2, children: /* @__PURE__ */ S.jsx(Ge, { variant: { weight: "normal" }, children: /* @__PURE__ */ S.jsx(
          _a,
          {
            i18nKey: "position_details.available_to",
            values: {
              amount: To(new Nt(t.amount)),
              symbol: t.token.symbol,
              pendingAction: r(
                `position_details.pending_action.${e.type.toLowerCase()}`
              )
            },
            components: {
              bold: /* @__PURE__ */ S.jsx(ae, { as: "span", fontWeight: "bold", display: "block" })
            }
          }
        ) }) }),
        /* @__PURE__ */ S.jsx(
          ae,
          {
            flex: 1,
            maxWidth: "24",
            justifyContent: "flex-end",
            display: "flex",
            alignItems: "center",
            children: /* @__PURE__ */ S.jsx(
              Jl,
              {
                variant: {
                  size: "small",
                  color: "smallButtonLight"
                },
                onClick: () => n({
                  yieldBalance: t,
                  pendingActionDto: e
                }),
                children: /* @__PURE__ */ S.jsx(Ge, { children: r(
                  `position_details.pending_action_button.${e.type.toLowerCase()}`
                ) })
              }
            )
          }
        )
      ]
    }
  );
}, PLe = () => {
  const { address: e, additionalAddresses: t } = fr(), { unstakeAmount: n, integrationData: r, stakedOrLiquidBalances: i } = c3();
  return k.useMemo(
    () => he.fromRecord({
      address: he.fromNullable(e),
      integrationData: r,
      stakedOrLiquidBalances: i
    }).map((o) => {
      const s = _n(null).chain(() => {
        var c, u, f, p, y, v;
        return o.integrationData.metadata.isIntegrationAggregator ? Wn.find(
          (w) => !!w.providerId,
          o.stakedOrLiquidBalances
        ).map((w) => ({
          providerId: w.providerId,
          validatorAddress: w.validatorAddress
        })) : (f = (u = (c = o.integrationData.args.exit) == null ? void 0 : c.args) == null ? void 0 : u.validatorAddresses) != null && f.required ? Wn.find(
          (w) => !!w.validatorAddresses,
          o.stakedOrLiquidBalances
        ).map((w) => ({ validatorAddresses: w.validatorAddresses })) : (v = (y = (p = o.integrationData.args.exit) == null ? void 0 : p.args) == null ? void 0 : y.validatorAddress) != null && v.required ? Wn.find(
          (w) => !!w.validatorAddress,
          o.stakedOrLiquidBalances
        ).map((w) => ({ validatorAddress: w.validatorAddress })) : he.empty();
      }).orDefault({});
      return {
        gasFeeToken: o.integrationData.metadata.gasFeeToken,
        dto: {
          addresses: {
            address: o.address,
            additionalAddresses: t ?? void 0
          },
          integrationId: o.integrationData.id,
          args: {
            amount: n.toString(10),
            ...s
          }
        }
      };
    }),
    [
      t,
      e,
      i,
      r,
      n
    ]
  );
}, NLe = (e, t) => {
  var n, r, i;
  switch (t.type) {
    case "validator/multiselect": {
      const o = new Set(e.selectedValidators);
      return o.has(t.data) ? o.delete(t.data) : o.add(t.data), o.size === 0 ? e : {
        ...e,
        selectedValidators: o
      };
    }
    case "validator/select": {
      const o = /* @__PURE__ */ new Set([t.data]);
      return {
        ...e,
        selectedValidators: o
      };
    }
    case "validator/close":
      return {
        ...e,
        multiSelect: !1,
        pendingActionDto: null,
        yieldBalance: null,
        showValidatorsModal: !1
      };
    case "validator/open": {
      const o = new Set(
        t.data.yieldBalance.validatorAddresses
      );
      return {
        ...e,
        multiSelect: !!((i = (r = (n = t.data.pendingActionDto.args) == null ? void 0 : n.args) == null ? void 0 : r.validatorAddresses) != null && i.required),
        selectedValidators: o,
        pendingActionDto: t.data.pendingActionDto,
        yieldBalance: t.data.yieldBalance,
        showValidatorsModal: !0
      };
    }
    default:
      return e;
  }
}, BLe = () => ({
  selectedValidators: /* @__PURE__ */ new Set(),
  showValidatorsModal: !1,
  pendingActionDto: null,
  yieldBalance: null,
  multiSelect: !1
}), LLe = () => {
  const [e, t] = k.useReducer(NLe, BLe()), n = k.useCallback(
    () => t({ type: "validator/close" }),
    []
  ), r = k.useCallback(
    (s) => t({ type: "validator/open", data: s }),
    []
  ), i = k.useCallback(
    (s) => t({ type: "validator/multiselect", data: s }),
    []
  ), o = k.useMemo(
    () => ({
      isOpen: e.showValidatorsModal,
      setOpen: (s) => !s && n()
    }),
    [n, e.showValidatorsModal]
  );
  return {
    ...e,
    modalState: o,
    closeModal: n,
    openModal: r,
    onItemClick: i,
    submitDisabled: e.selectedValidators.size === 0
  };
}, jLe = () => {
  const {
    pendingActions: e,
    reducedStakedOrLiquidBalance: t,
    pendingActionType: n,
    positionBalancesByType: r,
    integrationData: i,
    positionBalancePrices: o
  } = c3(), s = ix(i), c = wee(), u = Bi(), f = La(), p = k.useMemo(
    () => r.map(
      (j) => [...j.values()].flatMap(
        (F) => F.flatMap(
          (O) => O.pendingActions.map((z) => {
            var Y, ee, ie;
            const H = he.fromPredicate(
              (X) => !!X,
              (ie = (ee = (Y = z.args) == null ? void 0 : Y.args) == null ? void 0 : ee.amount) == null ? void 0 : ie.required
            ).chain(
              () => he.fromNullable(
                e.get(
                  d8({
                    balanceType: O.type,
                    token: O.token,
                    actionType: z.type
                  })
                )
              ).altLazy(() => he.of(new Nt(0)))
            ), Q = he.fromRecord({
              prices: he.fromNullable(o.data),
              amount: H,
              reducedStakedOrLiquidBalance: t,
              baseToken: s
            }).map(
              (X) => Vb({
                amount: X.amount,
                token: X.reducedStakedOrLiquidBalance.token,
                prices: X.prices,
                pricePerShare: O.pricePerShare,
                baseToken: X.baseToken
              })
            ).mapOrDefault((X) => `$${Na(X)}`, "");
            return {
              amount: H.extractNullable(),
              formattedAmount: Q,
              pendingActionDto: z,
              yieldBalance: O
            };
          })
        )
      )
    ),
    [
      e,
      o.data,
      r,
      t,
      s
    ]
  ), y = (j) => {
    c({ type: "pendingAction/amount/change", data: j });
  }, v = LLe(), w = Pr(v), C = k.useRef(!1);
  k.useEffect(() => {
    C.current || n.chain(
      (j) => p.chain(
        (F) => Wn.find(
          (O) => O.pendingActionDto.type === j && !!(Z5(O.pendingActionDto) || eD(O.pendingActionDto)),
          F
        )
      )
    ).ifJust((j) => {
      C.current = !0, w.current.openModal({
        pendingActionDto: j.pendingActionDto,
        yieldBalance: j.yieldBalance
      });
    });
  }, [n, p, w]);
  const x = ({
    yieldBalance: j,
    pendingActionDto: F
  }) => {
    if (u("pendingActionClicked", {
      yieldId: i.map((O) => O.id).extract(),
      type: F.type
    }), Z5(F) || eD(F))
      return v.openModal({
        pendingActionDto: F,
        yieldBalance: j
      });
    i.toEither(new Error("missing integration data")).ifRight(
      (O) => L({
        integrationData: O,
        pendingActionDto: F,
        yieldBalance: j,
        selectedValidators: []
      })
    );
  }, A = (j) => i.toEither(new Error("missing integration data")).chain((F) => {
    if (!v.showValidatorsModal)
      return Rn(
        new Error("missing validatorAddressesHandling.showValidatorsModal")
      );
    if (!j.length)
      return Rn(new Error("selectedValidators is empty"));
    const { pendingActionDto: O, yieldBalance: z } = v;
    return Pt({
      yieldDto: F,
      selectedValidators: j,
      pendingActionDto: O,
      yieldBalance: z
    });
  }).ifRight(
    ({ selectedValidators: F, pendingActionDto: O, yieldBalance: z, yieldDto: H }) => {
      u("validatorsSubmitted", {
        yieldId: H.id,
        type: O.type,
        validators: F
      }), v.closeModal(), L({
        integrationData: H,
        pendingActionDto: O,
        yieldBalance: z,
        selectedValidators: F
      });
    }
  ), { additionalAddresses: R, address: I } = fr(), D = fX(), M = vx(), L = ({
    integrationData: j,
    pendingActionDto: F,
    yieldBalance: O,
    selectedValidators: z
  }) => {
    QJ({
      pendingActionsState: e,
      yieldBalance: O,
      pendingActionDto: F,
      additionalAddresses: R,
      address: I,
      integration: j,
      selectedValidators: z
    }).ifRight((H) => {
      M.send({
        type: "initFlow",
        data: {
          gasFeeToken: H.gasFeeToken,
          integrationData: H.integrationData,
          interactedToken: O.token,
          pendingActionType: F.type,
          requestDto: H.requestDto,
          addresses: {
            address: H.address,
            additionalAddresses: H.additionalAddresses
          }
        }
      }), D ? f("../pending-action/review", { relative: "route" }) : f("pending-action/review");
    });
  };
  return {
    onPendingActionAmountChange: y,
    validatorAddressesHandling: v,
    pendingActions: p,
    onPendingActionClick: x,
    onValidatorsSubmit: A
  };
}, FLe = () => {
  const {
    unstakeAmount: e,
    integrationData: t,
    yieldOpportunity: n,
    positionBalances: r,
    reducedStakedOrLiquidBalance: i,
    positionBalancesByType: o,
    positionBalancePrices: s,
    unstakeAmountValid: c,
    unstakeToken: u,
    unstakeAmountError: f,
    canChangeUnstakeAmount: p,
    unstakeIsGreaterOrLessIntegrationLimitError: y
  } = c3(), v = La(), w = PLe(), C = Eb(), x = k.useMemo(
    () => t.chainNullable((pe) => {
      var Ee, Se;
      return (Se = (Ee = pe.args.exit) == null ? void 0 : Ee.args) == null ? void 0 : Se.amount;
    }).filter((pe) => !Ob(pe)).chainNullable((pe) => pe.maximum),
    [t]
  ), A = k.useMemo(
    () => t.chainNullable((pe) => {
      var Ee, Se;
      return (Se = (Ee = pe.args.exit) == null ? void 0 : Ee.args) == null ? void 0 : Se.amount;
    }).filter((pe) => !Ob(pe)).chainNullable((pe) => pe.minimum).filter((pe) => new Nt(pe).isGreaterThan(0)),
    [t]
  ), R = ec({
    mutationKey: [e.toString()],
    mutationFn: async () => {
      if (!c) throw new Error("Invalid amount");
      return he.fromRecord({
        stakeExitRequestDto: w,
        integrationData: t,
        unstakeToken: u
      }).ifJust((pe) => {
        C.send({
          type: "initFlow",
          data: {
            gasFeeToken: pe.stakeExitRequestDto.gasFeeToken,
            integrationData: pe.integrationData,
            requestDto: pe.stakeExitRequestDto.dto,
            unstakeAmount: e,
            unstakeToken: pe.unstakeToken
          }
        }), v("unstake/review");
      }), null;
    }
  }), I = R.mutate, D = R.isError || f, M = k.useMemo(
    () => r.data.chainNullable(
      (pe) => {
        var Ee;
        return (Ee = pe.balances.find((Se) => Se.label)) == null ? void 0 : Ee.label;
      }
    ),
    [r.data]
  ), L = wee(), j = Bi(), F = ix(t), O = cf({
    integrationData: t,
    validatorsAddresses: r.data.map((pe) => pe.type === "validators" ? pe.validatorsAddresses : [])
  }), z = t.filter((pe) => !!pe.args.exit).isJust(), H = (pe) => L({ type: "unstake/amount/change", data: pe }), Q = k.useMemo(
    () => he.fromRecord({
      prices: he.fromNullable(s.data),
      reducedStakedOrLiquidBalance: i,
      baseToken: F
    }).map(
      (pe) => Vb({
        amount: e,
        token: pe.reducedStakedOrLiquidBalance.token,
        prices: pe.prices,
        pricePerShare: pe.reducedStakedOrLiquidBalance.pricePerShare,
        baseToken: pe.baseToken
      })
    ).mapOrDefault((pe) => `$${Na(pe)}`, ""),
    [
      s.data,
      i,
      e,
      F
    ]
  ), Y = () => {
    j("positionDetailsPageMaxClicked", {
      yieldId: t.map((pe) => pe.id).extract()
    }), L({ type: "unstake/amount/max" });
  }, ee = t.mapOrDefault(
    (pe) => pe.status.exit,
    !1
  ), {
    onPendingActionAmountChange: ie,
    pendingActions: X,
    onPendingActionClick: Z,
    onValidatorsSubmit: J,
    validatorAddressesHandling: K
  } = jLe(), oe = k.useMemo(
    () => he.fromRecord({
      integrationData: t,
      positionBalancesByType: o,
      baseToken: F
    }).map(
      (pe) => [...pe.positionBalancesByType.values()].reduce((Ee, Se) => (Se.filter(
        (Me) => !Me.token.isPoints && Me.pricePerShare && !dA(Me.token, pe.baseToken)
      ).forEach((Me) => {
        Ee.set(
          Me.token.symbol,
          `1 ${Me.token.symbol} = ${Na(
            new Nt(Me.pricePerShare)
          )} ${pe.baseToken.symbol}`
        );
      }), Ee), /* @__PURE__ */ new Map())
    ),
    [t, o, F]
  ), be = n.isLoading || !ee, ce = r.isLoading || s.isLoading || n.isLoading;
  return {
    integrationData: t,
    reducedStakedOrLiquidBalance: i,
    positionBalancesByType: o,
    canUnstake: z,
    unstakeAmount: e,
    onUnstakeAmountChange: H,
    unstakeFormattedAmount: Q,
    onMaxClick: Y,
    canChangeUnstakeAmount: p,
    onUnstakeClick: I,
    unstakeDisabled: be,
    isLoading: ce,
    onPendingActionClick: Z,
    providersDetails: O,
    pendingActions: X,
    liquidTokensToNativeConversion: oe,
    validatorAddressesHandling: K,
    onValidatorsSubmit: J,
    onPendingActionAmountChange: ie,
    unstakeToken: u,
    positionLabel: M,
    unstakeAmountError: D,
    unstakeMaxAmount: x,
    unstakeMinAmount: A,
    unstakeIsGreaterOrLessIntegrationLimitError: y
  };
}, ULe = () => {
  const {
    onPendingActionAmountChange: e,
    integrationData: t,
    isLoading: n,
    reducedStakedOrLiquidBalance: r,
    positionBalancesByType: i,
    onUnstakeAmountChange: o,
    unstakeAmount: s,
    unstakeFormattedAmount: c,
    canChangeUnstakeAmount: u,
    onMaxClick: f,
    onUnstakeClick: p,
    unstakeDisabled: y,
    onPendingActionClick: v,
    pendingActions: w,
    providersDetails: C,
    liquidTokensToNativeConversion: x,
    validatorAddressesHandling: A,
    onValidatorsSubmit: R,
    unstakeToken: I,
    canUnstake: D,
    unstakeAmountError: M,
    positionLabel: L,
    unstakeMaxAmount: j,
    unstakeMinAmount: F,
    unstakeIsGreaterOrLessIntegrationLimitError: O
  } = FLe();
  sa("positionDetails", {
    yield: t.map((H) => H.metadata.name).extract()
  });
  const { t: z } = ln();
  return /* @__PURE__ */ S.jsx(yx, { children: /* @__PURE__ */ S.jsx(fp, { children: n ? /* @__PURE__ */ S.jsx(
    ae,
    {
      className: lz,
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      children: /* @__PURE__ */ S.jsx(Wl, {})
    }
  ) : he.fromRecord({ integrationData: t, positionBalancesByType: i }).map((H) => /* @__PURE__ */ S.jsxs(
    ae,
    {
      className: lz,
      flex: 1,
      display: "flex",
      flexDirection: "column",
      children: [
        I.altLazy(() => _n(H.integrationData.token)).map((Q) => /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
          /* @__PURE__ */ S.jsx(
            ae,
            {
              display: "flex",
              justifyContent: "center",
              alignItems: "center",
              children: /* @__PURE__ */ S.jsx(
                nf,
                {
                  metadata: H.integrationData.metadata,
                  token: Q,
                  tokenLogoHw: "14"
                }
              )
            }
          ),
          /* @__PURE__ */ S.jsxs(
            ae,
            {
              marginTop: "3",
              display: "flex",
              justifyContent: "center",
              alignItems: "center",
              flexDirection: "column",
              children: [
                /* @__PURE__ */ S.jsx($u, { variant: { level: "h4" }, textAlign: "center", children: H.integrationData.metadata.name }),
                /* @__PURE__ */ S.jsx(Ge, { variant: { type: "muted" }, children: Q.symbol })
              ]
            }
          )
        ] })).extractNullable(),
        L.map((Q) => /* @__PURE__ */ S.jsx(
          ae,
          {
            background: "stakeSectionBackground",
            borderRadius: "xl",
            marginTop: "2",
            py: "4",
            px: "4",
            children: /* @__PURE__ */ S.jsxs(
              ae,
              {
                display: "flex",
                alignItems: "center",
                justifyContent: "flex-start",
                gap: "1",
                children: [
                  /* @__PURE__ */ S.jsx(
                    ae,
                    {
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      children: /* @__PURE__ */ S.jsx(qm, {})
                    }
                  ),
                  /* @__PURE__ */ S.jsx(Ge, { variant: { type: "muted", size: "small" }, children: z(
                    `position_details.labels.${Q.type}.details`,
                    Q.params
                  ) })
                ]
              }
            )
          }
        )).extractNullable(),
        /* @__PURE__ */ S.jsx(ae, { marginTop: "4", children: C.map(
          (Q) => Q.map((Y, ee) => /* @__PURE__ */ k.createElement(
            ILe,
            {
              ...Y,
              key: Y.address ?? ee,
              isFirst: ee === 0,
              stakeType: z(
                `position_details.stake_type.${H.integrationData.metadata.type}`
              ),
              integrationData: H.integrationData
            }
          ))
        ).extractNullable() }),
        /* @__PURE__ */ S.jsx(ae, { py: "3", gap: "2", display: "flex", flexDirection: "column", children: [...H.positionBalancesByType.values()].flatMap(
          (Q) => Q.map((Y, ee) => /* @__PURE__ */ S.jsx(
            kLe,
            {
              integrationData: H.integrationData,
              yieldBalance: Y
            },
            `${Y.type}-${ee}`
          ))
        ) }),
        x.map((Q) => /* @__PURE__ */ S.jsx(
          ae,
          {
            my: "2",
            display: "flex",
            alignItems: "flex-end",
            flexDirection: "column",
            gap: "1",
            children: [...Q.values()].map((Y) => /* @__PURE__ */ S.jsx(
              Ge,
              {
                variant: { type: "muted", weight: "normal" },
                children: Y
              },
              Y
            ))
          }
        )).extractNullable(),
        /* @__PURE__ */ S.jsxs(
          ae,
          {
            display: "flex",
            flex: 1,
            justifyContent: "flex-end",
            flexDirection: "column",
            marginTop: "10",
            gap: "2",
            children: [
              w.map(
                (Q) => Q.map(
                  (Y) => Y.amount ? /* @__PURE__ */ S.jsx(
                    Iz,
                    {
                      variant: "action",
                      onAmountChange: (ee) => e({
                        balanceType: Y.yieldBalance.type,
                        token: Y.yieldBalance.token,
                        actionType: Y.pendingActionDto.type,
                        amount: ee
                      }),
                      value: Y.amount,
                      canChangeAmount: !0,
                      onClick: () => v({
                        pendingActionDto: Y.pendingActionDto,
                        yieldBalance: Y.yieldBalance
                      }),
                      label: z(
                        `position_details.pending_action_button.${Y.pendingActionDto.type.toLowerCase()}`
                      ),
                      onMaxClick: null,
                      formattedAmount: Y.formattedAmount,
                      balance: null
                    },
                    `${Y.pendingActionDto.type}-${Y.pendingActionDto.passthrough}`
                  ) : /* @__PURE__ */ k.createElement(
                    MLe,
                    {
                      ...Y,
                      key: `${Y.pendingActionDto.type}-${Y.pendingActionDto.passthrough}`,
                      onPendingActionClick: v
                    }
                  )
                )
              ).extractNullable(),
              he.fromRecord({
                reducedStakedOrLiquidBalance: r,
                canChangeUnstakeAmount: u,
                unstakeToken: I
              }).map(
                ({
                  reducedStakedOrLiquidBalance: Q,
                  canChangeUnstakeAmount: Y,
                  unstakeToken: ee
                }) => /* @__PURE__ */ S.jsx(
                  Iz,
                  {
                    unstakeMaxAmount: j,
                    unstakeMinAmount: F,
                    unstakeIsGreaterOrLessIntegrationLimitError: O,
                    variant: "unstake",
                    canUnstake: D,
                    unstakeToken: ee,
                    onAmountChange: o,
                    value: s,
                    canChangeAmount: Y,
                    disabled: y,
                    onClick: p,
                    unstakeAmountError: M,
                    onMaxClick: f,
                    label: z(
                      `position_details.unstake_label.${H.integrationData.metadata.type}`
                    ),
                    formattedAmount: c,
                    balance: Q,
                    yieldDto: H.integrationData,
                    validators: C.orDefault([])
                  }
                )
              ).extractNullable()
            ]
          }
        ),
        A.showValidatorsModal && /* @__PURE__ */ S.jsx(
          pee,
          {
            selectedValidators: A.selectedValidators,
            onItemClick: (Q) => {
              A.onItemClick(Q.address), !A.multiSelect && R([Q.address]);
            },
            selectedStake: H.integrationData,
            validators: H.integrationData.validators,
            multiSelect: A.multiSelect,
            state: A.modalState,
            children: A.multiSelect && /* @__PURE__ */ S.jsx(
              ae,
              {
                px: "4",
                paddingTop: "3",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                children: /* @__PURE__ */ S.jsx(
                  Jl,
                  {
                    variant: {
                      color: A.submitDisabled ? "disabled" : "primary"
                    },
                    disabled: A.submitDisabled,
                    onClick: () => R([
                      ...A.selectedValidators.values()
                    ]),
                    children: z("position_details.select_validators.submit")
                  }
                )
              }
            )
          }
        )
      ]
    }
  )).extractNullable() }) });
}, Dz = () => /* @__PURE__ */ S.jsx(ELe, { children: /* @__PURE__ */ S.jsx(ULe, {}) }), zLe = k.createContext(void 0), VLe = ({ children: e }) => {
  const t = k.useState({ positions: null });
  return /* @__PURE__ */ S.jsx(zLe.Provider, { value: t, children: e });
}, $Le = (e) => {
  const [t] = k.useState(() => new ly([])), n = k.useCallback(
    (o) => {
      if (!e || !zd(e))
        return () => {
        };
      const s = e.$disabledChains.subscribe((c) => {
        t.next(c), o();
      });
      return () => s.unsubscribe();
    },
    [e, t]
  ), r = k.useCallback(() => t.value, [t]), i = k.useCallback(() => t.value, [t.value]);
  return k.useSyncExternalStore(n, r, i);
}, HLe = {
  ...uA.lightMode,
  colors: ti.color.connectKit,
  // ThemeWrapper applies final light/dark colors
  radii: ti.borderRadius.connectKit
}, qLe = ({
  children: e
}) => {
  const { connector: t, connectorChains: n } = fr(), r = $Le(t), i = Bi(), o = AN(), { t: s } = ln(), c = k.useMemo(
    () => new Set(n.map((p) => p.id)),
    [n]
  ), u = k.useMemo(
    () => r.map((p) => ({
      ...p,
      info: s("chain_modal.disabled_chain_info")
    })),
    [r, s]
  ), f = k.useMemo(
    () => he.fromNullable(t).map((p) => !hK(p)).orDefault(!0),
    [t]
  );
  return /* @__PURE__ */ S.jsxs(
    dxe,
    {
      chainIdsToUse: c,
      id: FA,
      modalSize: "compact",
      disabledChains: u,
      onDisabledChainClick: (p) => {
        i("addLedgerAccountClicked"), o.mutate(p);
      },
      appInfo: { disclaimer: GLe, appName: "StakeKit" },
      theme: HLe,
      hideDisconnect: f,
      children: [
        /* @__PURE__ */ S.jsx(WLe, {}),
        e
      ]
    }
  );
}, WLe = () => (KG().closeChainModal, null), GLe = () => /* @__PURE__ */ S.jsx(Ge, { children: "Powered by StakeKit" }), KLe = ({ children: e }) => {
  const { ledgerAccounts: t, address: n, onLedgerAccountChange: r } = fr(), i = he.fromNullable(t).map(
    (o) => o.filter((s) => s.address !== n).map((s) => I4(s.address))
  ).orDefault([]);
  return /* @__PURE__ */ S.jsx(
    PG.Provider,
    {
      value: {
        otherAddresses: i,
        onOtherAddressClick: (o) => he.fromNullable(t).ifJust(
          (s) => Wn.find(
            (c) => I4(c.address) === o,
            s
          ).ifJust((c) => r == null ? void 0 : r(c))
        )
      },
      children: /* @__PURE__ */ S.jsx(qLe, { children: e })
    }
  );
};
var m8 = { exports: {} };
m8.exports;
(function(e, t) {
  var n = 200, r = "__lodash_hash_undefined__", i = 800, o = 16, s = 9007199254740991, c = "[object Arguments]", u = "[object Array]", f = "[object AsyncFunction]", p = "[object Boolean]", y = "[object Date]", v = "[object Error]", w = "[object Function]", C = "[object GeneratorFunction]", x = "[object Map]", A = "[object Number]", R = "[object Null]", I = "[object Object]", D = "[object Proxy]", M = "[object RegExp]", L = "[object Set]", j = "[object String]", F = "[object Undefined]", O = "[object WeakMap]", z = "[object ArrayBuffer]", H = "[object DataView]", Q = "[object Float32Array]", Y = "[object Float64Array]", ee = "[object Int8Array]", ie = "[object Int16Array]", X = "[object Int32Array]", Z = "[object Uint8Array]", J = "[object Uint8ClampedArray]", K = "[object Uint16Array]", oe = "[object Uint32Array]", be = /[\\^$.*+?()[\]{}|]/g, ce = /^\[object .+?Constructor\]$/, pe = /^(?:0|[1-9]\d*)$/, Ee = {};
  Ee[Q] = Ee[Y] = Ee[ee] = Ee[ie] = Ee[X] = Ee[Z] = Ee[J] = Ee[K] = Ee[oe] = !0, Ee[c] = Ee[u] = Ee[z] = Ee[p] = Ee[H] = Ee[y] = Ee[v] = Ee[w] = Ee[x] = Ee[A] = Ee[I] = Ee[M] = Ee[L] = Ee[j] = Ee[O] = !1;
  var Se = typeof v1 == "object" && v1 && v1.Object === Object && v1, Me = typeof self == "object" && self && self.Object === Object && self, Fe = Se || Me || Function("return this")(), st = t && !t.nodeType && t, mt = st && !0 && e && !e.nodeType && e, yt = mt && mt.exports === st, Ut = yt && Se.process, hn = function() {
    try {
      var fe = mt && mt.require && mt.require("util").types;
      return fe || Ut && Ut.binding && Ut.binding("util");
    } catch {
    }
  }(), wn = hn && hn.isTypedArray;
  function Ot(fe, Ie, $e) {
    switch ($e.length) {
      case 0:
        return fe.call(Ie);
      case 1:
        return fe.call(Ie, $e[0]);
      case 2:
        return fe.call(Ie, $e[0], $e[1]);
      case 3:
        return fe.call(Ie, $e[0], $e[1], $e[2]);
    }
    return fe.apply(Ie, $e);
  }
  function xt(fe, Ie) {
    for (var $e = -1, It = Array(fe); ++$e < fe; )
      It[$e] = Ie($e);
    return It;
  }
  function zt(fe) {
    return function(Ie) {
      return fe(Ie);
    };
  }
  function Pn(fe, Ie) {
    return fe == null ? void 0 : fe[Ie];
  }
  function Fn(fe, Ie) {
    return function($e) {
      return fe(Ie($e));
    };
  }
  var tr = Array.prototype, or = Function.prototype, ar = Object.prototype, Cr = Fe["__core-js_shared__"], Un = or.toString, $n = ar.hasOwnProperty, gr = function() {
    var fe = /[^.]+$/.exec(Cr && Cr.keys && Cr.keys.IE_PROTO || "");
    return fe ? "Symbol(src)_1." + fe : "";
  }(), Tt = ar.toString, qt = Un.call(Object), gt = RegExp(
    "^" + Un.call($n).replace(be, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), Ht = yt ? Fe.Buffer : void 0, br = Fe.Symbol, ne = Fe.Uint8Array;
  Ht && Ht.allocUnsafe;
  var N = Fn(Object.getPrototypeOf, Object), U = Object.create, le = ar.propertyIsEnumerable, Ce = tr.splice, Te = br ? br.toStringTag : void 0, Ve = function() {
    try {
      var fe = us(Object, "defineProperty");
      return fe({}, "", {}), fe;
    } catch {
    }
  }(), kt = Ht ? Ht.isBuffer : void 0, bn = Math.max, Wt = Date.now, xn = us(Fe, "Map"), St = us(Object, "create"), Qn = /* @__PURE__ */ function() {
    function fe() {
    }
    return function(Ie) {
      if (!di(Ie))
        return {};
      if (U)
        return U(Ie);
      fe.prototype = Ie;
      var $e = new fe();
      return fe.prototype = void 0, $e;
    };
  }();
  function Nr(fe) {
    var Ie = -1, $e = fe == null ? 0 : fe.length;
    for (this.clear(); ++Ie < $e; ) {
      var It = fe[Ie];
      this.set(It[0], It[1]);
    }
  }
  function bi() {
    this.__data__ = St ? St(null) : {}, this.size = 0;
  }
  function Do(fe) {
    var Ie = this.has(fe) && delete this.__data__[fe];
    return this.size -= Ie ? 1 : 0, Ie;
  }
  function la(fe) {
    var Ie = this.__data__;
    if (St) {
      var $e = Ie[fe];
      return $e === r ? void 0 : $e;
    }
    return $n.call(Ie, fe) ? Ie[fe] : void 0;
  }
  function ja(fe) {
    var Ie = this.__data__;
    return St ? Ie[fe] !== void 0 : $n.call(Ie, fe);
  }
  function Mo(fe, Ie) {
    var $e = this.__data__;
    return this.size += this.has(fe) ? 0 : 1, $e[fe] = St && Ie === void 0 ? r : Ie, this;
  }
  Nr.prototype.clear = bi, Nr.prototype.delete = Do, Nr.prototype.get = la, Nr.prototype.has = ja, Nr.prototype.set = Mo;
  function ri(fe) {
    var Ie = -1, $e = fe == null ? 0 : fe.length;
    for (this.clear(); ++Ie < $e; ) {
      var It = fe[Ie];
      this.set(It[0], It[1]);
    }
  }
  function ui() {
    this.__data__ = [], this.size = 0;
  }
  function ji(fe) {
    var Ie = this.__data__, $e = sr(Ie, fe);
    if ($e < 0)
      return !1;
    var It = Ie.length - 1;
    return $e == It ? Ie.pop() : Ce.call(Ie, $e, 1), --this.size, !0;
  }
  function _i(fe) {
    var Ie = this.__data__, $e = sr(Ie, fe);
    return $e < 0 ? void 0 : Ie[$e][1];
  }
  function ho(fe) {
    return sr(this.__data__, fe) > -1;
  }
  function wi(fe, Ie) {
    var $e = this.__data__, It = sr($e, fe);
    return It < 0 ? (++this.size, $e.push([fe, Ie])) : $e[It][1] = Ie, this;
  }
  ri.prototype.clear = ui, ri.prototype.delete = ji, ri.prototype.get = _i, ri.prototype.has = ho, ri.prototype.set = wi;
  function we(fe) {
    var Ie = -1, $e = fe == null ? 0 : fe.length;
    for (this.clear(); ++Ie < $e; ) {
      var It = fe[Ie];
      this.set(It[0], It[1]);
    }
  }
  function Ae() {
    this.size = 0, this.__data__ = {
      hash: new Nr(),
      map: new (xn || ri)(),
      string: new Nr()
    };
  }
  function ye(fe) {
    var Ie = Ua(this, fe).delete(fe);
    return this.size -= Ie ? 1 : 0, Ie;
  }
  function re(fe) {
    return Ua(this, fe).get(fe);
  }
  function _e(fe) {
    return Ua(this, fe).has(fe);
  }
  function Pe(fe, Ie) {
    var $e = Ua(this, fe), It = $e.size;
    return $e.set(fe, Ie), this.size += $e.size == It ? 0 : 1, this;
  }
  we.prototype.clear = Ae, we.prototype.delete = ye, we.prototype.get = re, we.prototype.has = _e, we.prototype.set = Pe;
  function Qe(fe) {
    var Ie = this.__data__ = new ri(fe);
    this.size = Ie.size;
  }
  function Ke() {
    this.__data__ = new ri(), this.size = 0;
  }
  function lt(fe) {
    var Ie = this.__data__, $e = Ie.delete(fe);
    return this.size = Ie.size, $e;
  }
  function tt(fe) {
    return this.__data__.get(fe);
  }
  function ot(fe) {
    return this.__data__.has(fe);
  }
  function cn(fe, Ie) {
    var $e = this.__data__;
    if ($e instanceof ri) {
      var It = $e.__data__;
      if (!xn || It.length < n - 1)
        return It.push([fe, Ie]), this.size = ++$e.size, this;
      $e = this.__data__ = new we(It);
    }
    return $e.set(fe, Ie), this.size = $e.size, this;
  }
  Qe.prototype.clear = Ke, Qe.prototype.delete = lt, Qe.prototype.get = tt, Qe.prototype.has = ot, Qe.prototype.set = cn;
  function Qt(fe, Ie) {
    var $e = Zi(fe), It = !$e && Br(fe), jn = !$e && !It && Hr(fe), cr = !$e && !It && !jn && Qu(fe), Sr = $e || It || jn || cr, Nn = Sr ? xt(fe.length, String) : [], W = Nn.length;
    for (var ve in fe)
      Sr && // Safari 9 has enumerable `arguments.length` in strict mode.
      (ve == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      jn && (ve == "offset" || ve == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      cr && (ve == "buffer" || ve == "byteLength" || ve == "byteOffset") || // Skip index properties.
      oc(ve, W)) || Nn.push(ve);
    return Nn;
  }
  function on(fe, Ie, $e) {
    ($e !== void 0 && !fs(fe[Ie], $e) || $e === void 0 && !(Ie in fe)) && tn(fe, Ie, $e);
  }
  function pn(fe, Ie, $e) {
    var It = fe[Ie];
    (!($n.call(fe, Ie) && fs(It, $e)) || $e === void 0 && !(Ie in fe)) && tn(fe, Ie, $e);
  }
  function sr(fe, Ie) {
    for (var $e = fe.length; $e--; )
      if (fs(fe[$e][0], Ie))
        return $e;
    return -1;
  }
  function tn(fe, Ie, $e) {
    Ie == "__proto__" && Ve ? Ve(fe, Ie, {
      configurable: !0,
      enumerable: !0,
      value: $e,
      writable: !0
    }) : fe[Ie] = $e;
  }
  var Ur = po();
  function xr(fe) {
    return fe == null ? fe === void 0 ? F : R : Te && Te in Object(fe) ? yl(fe) : ac(fe);
  }
  function vn(fe) {
    return Xr(fe) && xr(fe) == c;
  }
  function ii(fe) {
    if (!di(fe) || ds(fe))
      return !1;
    var Ie = lr(fe) ? gt : ce;
    return Ie.test(En(fe));
  }
  function qo(fe) {
    return Xr(fe) && Yu(fe.length) && !!Ee[xr(fe)];
  }
  function Xi(fe) {
    if (!di(fe))
      return Xc(fe);
    var Ie = nr(fe), $e = [];
    for (var It in fe)
      It == "constructor" && (Ie || !$n.call(fe, It)) || $e.push(It);
    return $e;
  }
  function Po(fe, Ie, $e, It, jn) {
    fe !== Ie && Ur(Ie, function(cr, Sr) {
      if (jn || (jn = new Qe()), di(cr))
        Ci(fe, Ie, Sr, $e, Po, It, jn);
      else {
        var Nn = It ? It(Hn(fe, Sr), cr, Sr + "", fe, Ie, jn) : void 0;
        Nn === void 0 && (Nn = cr), on(fe, Sr, Nn);
      }
    }, Ys);
  }
  function Ci(fe, Ie, $e, It, jn, cr, Sr) {
    var Nn = Hn(fe, $e), W = Hn(Ie, $e), ve = Sr.get(W);
    if (ve) {
      on(fe, $e, ve);
      return;
    }
    var Be = cr ? cr(Nn, W, $e + "", fe, Ie, Sr) : void 0, We = Be === void 0;
    if (We) {
      var ft = Zi(W), rn = !ft && Hr(W), vt = !ft && !rn && Qu(W);
      Be = W, ft || rn || vt ? Zi(Nn) ? Be = Nn : vl(Nn) ? Be = Ji(Nn) : rn ? (We = !1, Be = Er(W)) : vt ? (We = !1, Be = _r(W)) : Be = [] : hs(W) || Br(W) ? (Be = Nn, Br(Nn) ? Be = Ks(Nn) : (!di(Nn) || lr(Nn)) && (Be = Qc(W))) : We = !1;
    }
    We && (Sr.set(W, Be), jn(Be, W, It, cr, Sr), Sr.delete(W)), on(fe, $e, Be);
  }
  function cs(fe, Ie) {
    return Zc(Jc(fe, Ie, Qs), fe + "");
  }
  var Zt = Ve ? function(fe, Ie) {
    return Ve(fe, "toString", {
      configurable: !0,
      enumerable: !1,
      value: ca(Ie),
      writable: !0
    });
  } : Qs;
  function Er(fe, Ie) {
    return fe.slice();
  }
  function xi(fe) {
    var Ie = new fe.constructor(fe.byteLength);
    return new ne(Ie).set(new ne(fe)), Ie;
  }
  function _r(fe, Ie) {
    var $e = xi(fe.buffer);
    return new fe.constructor($e, fe.byteOffset, fe.length);
  }
  function Ji(fe, Ie) {
    var $e = -1, It = fe.length;
    for (Ie || (Ie = Array(It)); ++$e < It; )
      Ie[$e] = fe[$e];
    return Ie;
  }
  function Fa(fe, Ie, $e, It) {
    var jn = !$e;
    $e || ($e = {});
    for (var cr = -1, Sr = Ie.length; ++cr < Sr; ) {
      var Nn = Ie[cr], W = void 0;
      W === void 0 && (W = fe[Nn]), jn ? tn($e, Nn, W) : pn($e, Nn, W);
    }
    return $e;
  }
  function Wo(fe) {
    return cs(function(Ie, $e) {
      var It = -1, jn = $e.length, cr = jn > 1 ? $e[jn - 1] : void 0, Sr = jn > 2 ? $e[2] : void 0;
      for (cr = fe.length > 3 && typeof cr == "function" ? (jn--, cr) : void 0, Sr && Gs($e[0], $e[1], Sr) && (cr = jn < 3 ? void 0 : cr, jn = 1), Ie = Object(Ie); ++It < jn; ) {
        var Nn = $e[It];
        Nn && fe(Ie, Nn, It, cr);
      }
      return Ie;
    });
  }
  function po(fe) {
    return function(Ie, $e, It) {
      for (var jn = -1, cr = Object(Ie), Sr = It(Ie), Nn = Sr.length; Nn--; ) {
        var W = Sr[++jn];
        if ($e(cr[W], W, cr) === !1)
          break;
      }
      return Ie;
    };
  }
  function Ua(fe, Ie) {
    var $e = fe.__data__;
    return hp(Ie) ? $e[typeof Ie == "string" ? "string" : "hash"] : $e.map;
  }
  function us(fe, Ie) {
    var $e = Pn(fe, Ie);
    return ii($e) ? $e : void 0;
  }
  function yl(fe) {
    var Ie = $n.call(fe, Te), $e = fe[Te];
    try {
      fe[Te] = void 0;
      var It = !0;
    } catch {
    }
    var jn = Tt.call(fe);
    return It && (Ie ? fe[Te] = $e : delete fe[Te]), jn;
  }
  function Qc(fe) {
    return typeof fe.constructor == "function" && !nr(fe) ? Qn(N(fe)) : {};
  }
  function oc(fe, Ie) {
    var $e = typeof fe;
    return Ie = Ie ?? s, !!Ie && ($e == "number" || $e != "symbol" && pe.test(fe)) && fe > -1 && fe % 1 == 0 && fe < Ie;
  }
  function Gs(fe, Ie, $e) {
    if (!di($e))
      return !1;
    var It = typeof Ie;
    return (It == "number" ? Fi($e) && oc(Ie, $e.length) : It == "string" && Ie in $e) ? fs($e[Ie], fe) : !1;
  }
  function hp(fe) {
    var Ie = typeof fe;
    return Ie == "string" || Ie == "number" || Ie == "symbol" || Ie == "boolean" ? fe !== "__proto__" : fe === null;
  }
  function ds(fe) {
    return !!gr && gr in fe;
  }
  function nr(fe) {
    var Ie = fe && fe.constructor, $e = typeof Ie == "function" && Ie.prototype || ar;
    return fe === $e;
  }
  function Xc(fe) {
    var Ie = [];
    if (fe != null)
      for (var $e in Object(fe))
        Ie.push($e);
    return Ie;
  }
  function ac(fe) {
    return Tt.call(fe);
  }
  function Jc(fe, Ie, $e) {
    return Ie = bn(Ie === void 0 ? fe.length - 1 : Ie, 0), function() {
      for (var It = arguments, jn = -1, cr = bn(It.length - Ie, 0), Sr = Array(cr); ++jn < cr; )
        Sr[jn] = It[Ie + jn];
      jn = -1;
      for (var Nn = Array(Ie + 1); ++jn < Ie; )
        Nn[jn] = It[jn];
      return Nn[Ie] = $e(Sr), Ot(fe, this, Nn);
    };
  }
  function Hn(fe, Ie) {
    if (!(Ie === "constructor" && typeof fe[Ie] == "function") && Ie != "__proto__")
      return fe[Ie];
  }
  var Zc = eu(Zt);
  function eu(fe) {
    var Ie = 0, $e = 0;
    return function() {
      var It = Wt(), jn = o - (It - $e);
      if ($e = It, jn > 0) {
        if (++Ie >= i)
          return arguments[0];
      } else
        Ie = 0;
      return fe.apply(void 0, arguments);
    };
  }
  function En(fe) {
    if (fe != null) {
      try {
        return Un.call(fe);
      } catch {
      }
      try {
        return fe + "";
      } catch {
      }
    }
    return "";
  }
  function fs(fe, Ie) {
    return fe === Ie || fe !== fe && Ie !== Ie;
  }
  var Br = vn(/* @__PURE__ */ function() {
    return arguments;
  }()) ? vn : function(fe) {
    return Xr(fe) && $n.call(fe, "callee") && !le.call(fe, "callee");
  }, Zi = Array.isArray;
  function Fi(fe) {
    return fe != null && Yu(fe.length) && !lr(fe);
  }
  function vl(fe) {
    return Xr(fe) && Fi(fe);
  }
  var Hr = kt || Xs;
  function lr(fe) {
    if (!di(fe))
      return !1;
    var Ie = xr(fe);
    return Ie == w || Ie == C || Ie == f || Ie == D;
  }
  function Yu(fe) {
    return typeof fe == "number" && fe > -1 && fe % 1 == 0 && fe <= s;
  }
  function di(fe) {
    var Ie = typeof fe;
    return fe != null && (Ie == "object" || Ie == "function");
  }
  function Xr(fe) {
    return fe != null && typeof fe == "object";
  }
  function hs(fe) {
    if (!Xr(fe) || xr(fe) != I)
      return !1;
    var Ie = N(fe);
    if (Ie === null)
      return !0;
    var $e = $n.call(Ie, "constructor") && Ie.constructor;
    return typeof $e == "function" && $e instanceof $e && Un.call($e) == qt;
  }
  var Qu = wn ? zt(wn) : qo;
  function Ks(fe) {
    return Fa(fe, Ys(fe));
  }
  function Ys(fe) {
    return Fi(fe) ? Qt(fe) : Xi(fe);
  }
  var mf = Wo(function(fe, Ie, $e) {
    Po(fe, Ie, $e);
  });
  function ca(fe) {
    return function() {
      return fe;
    };
  }
  function Qs(fe) {
    return fe;
  }
  function Xs() {
    return !1;
  }
  e.exports = mf;
})(m8, m8.exports);
var YLe = m8.exports;
const EI = /* @__PURE__ */ DC(YLe), QLe = ({ children: e }) => {
  const { theme: t = { lightMode: Pk } } = dr(), n = k.useMemo(
    () => "lightMode" in t ? EI(structuredClone(Pk), t.lightMode) : t ? EI(structuredClone(Pk), t) : Pk,
    [t]
  ), r = k.useMemo(
    () => "darkMode" in t ? EI(structuredClone(eSe), t.darkMode) : null,
    [t]
  );
  return /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
    /* @__PURE__ */ S.jsx(
      "style",
      {
        dangerouslySetInnerHTML: {
          __html: [
            n ? `${AD} {${TD(ti, n)}}` : null,
            r ? `@media (prefers-color-scheme: dark) { ${AD} {${TD(
              ti,
              r
            )}} }` : null
          ].join("")
        }
      }
    ),
    e
  ] });
}, XLe = ({ children: e }) => {
  var n;
  const t = ox();
  return /* @__PURE__ */ S.jsx(
    Jq.Provider,
    {
      value: ((n = t.data) == null ? void 0 : n.wagmiConfig) ?? wke,
      children: e
    }
  );
}, JLe = ({
  children: e
}) => /* @__PURE__ */ S.jsx(k.StrictMode, { children: /* @__PURE__ */ S.jsx(gIe, { children: /* @__PURE__ */ S.jsx(ile, { i18n: uM, children: /* @__PURE__ */ S.jsx(tfe, { children: /* @__PURE__ */ S.jsx(ehe, { children: /* @__PURE__ */ S.jsx(x5e, { children: /* @__PURE__ */ S.jsx(A5e, { children: /* @__PURE__ */ S.jsx(XLe, { children: /* @__PURE__ */ S.jsx(Ske, { children: /* @__PURE__ */ S.jsx(Qke, { children: /* @__PURE__ */ S.jsx(KLe, { children: /* @__PURE__ */ S.jsx(a5e, { children: /* @__PURE__ */ S.jsx(U3e, { children: /* @__PURE__ */ S.jsx(QLe, { children: /* @__PURE__ */ S.jsx(VLe, { children: /* @__PURE__ */ S.jsx(jIe, { children: /* @__PURE__ */ S.jsx(hOe, { children: /* @__PURE__ */ S.jsx(GIe, { children: /* @__PURE__ */ S.jsx(KIe, { children: /* @__PURE__ */ S.jsx(T5e, { children: /* @__PURE__ */ S.jsx(NNe, { children: /* @__PURE__ */ S.jsx(l3e, { children: /* @__PURE__ */ S.jsx(g5e, { children: /* @__PURE__ */ S.jsx(m5e, { children: /* @__PURE__ */ S.jsx(n5e, { children: e }) }) }) }) }) }) }) }) }) }) }) }) }) }) }) }) }) }) }) }) }) }) }) }) });
w5e();
const ZLe = () => {
  var y;
  tSe();
  const e = e4e();
  jfe();
  const { chain: t, address: n } = fr(), r = r8(t), i = r8(n), { current: o } = EN(), s = Pr(o.pathname), c = Pr(La());
  tf(() => {
    s.current !== "/" && s.current !== "/positions" && s.current !== "/activity" && (r && t !== r || i && n !== i) && Ro.ifJust((v) => {
      const w = new URL(v.location.href), C = new URL(v.location.origin);
      w.searchParams.has("embed") && C.searchParams.set("embed", "true"), v.history.pushState({}, v.document.title, C.href), c.current("/", { replace: !0 });
    });
  }, [t, n, s, c, r, i]);
  const u = (y = pC().data) == null ? void 0 : y.tab;
  k.useEffect(() => {
    u && c.current(u === "earn" ? "/" : "/positions");
  }, [u, c]), o3e();
  const p = TQ() ? "/" : o.pathname;
  return e ? /* @__PURE__ */ S.jsx(M5e, {}) : /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
    /* @__PURE__ */ S.jsx(BNe, { children: /* @__PURE__ */ S.jsxs(C2e, { children: [
      /* @__PURE__ */ S.jsx(gi.div, { layout: "position", className: FIe, children: /* @__PURE__ */ S.jsx(mOe, {}) }),
      /* @__PURE__ */ S.jsx(gi.div, { layout: "position", className: R5e, children: /* @__PURE__ */ S.jsx(_A, { children: /* @__PURE__ */ S.jsx(gRe, { location: o, children: /* @__PURE__ */ S.jsxs(Yr, { element: /* @__PURE__ */ S.jsx(zIe, { currentPathname: o.pathname }), children: [
        /* @__PURE__ */ S.jsxs(Yr, { element: /* @__PURE__ */ S.jsx(uLe, {}), children: [
          /* @__PURE__ */ S.jsx(Yr, { index: !0, element: /* @__PURE__ */ S.jsx(nLe, {}) }),
          /* @__PURE__ */ S.jsx(Yr, { path: "positions", element: /* @__PURE__ */ S.jsx(w3e, {}) }),
          /* @__PURE__ */ S.jsx(Yr, { path: "activity", element: /* @__PURE__ */ S.jsx(wDe, {}) })
        ] }),
        /* @__PURE__ */ S.jsxs(Yr, { element: /* @__PURE__ */ S.jsx(a3e, {}), children: [
          /* @__PURE__ */ S.jsxs(Yr, { path: "activity", children: [
            /* @__PURE__ */ S.jsx(Yr, { path: "review", element: /* @__PURE__ */ S.jsx($Me, {}) }),
            /* @__PURE__ */ S.jsx(
              Yr,
              {
                path: ":pendingActionType/steps",
                element: /* @__PURE__ */ S.jsx($Ne, {})
              }
            ),
            /* @__PURE__ */ S.jsx(
              Yr,
              {
                path: ":pendingActionType/complete",
                element: /* @__PURE__ */ S.jsx(o5e, {})
              }
            )
          ] }),
          /* @__PURE__ */ S.jsxs(Yr, { children: [
            /* @__PURE__ */ S.jsx(Yr, { path: "review", element: /* @__PURE__ */ S.jsx(fLe, {}) }),
            /* @__PURE__ */ S.jsx(Yr, { path: "steps", element: /* @__PURE__ */ S.jsx(hLe, {}) }),
            /* @__PURE__ */ S.jsx(Yr, { path: "complete", element: /* @__PURE__ */ S.jsx(c3e, {}) })
          ] }),
          /* @__PURE__ */ S.jsxs(Yr, { path: "positions/:integrationId/:balanceId", children: [
            /* @__PURE__ */ S.jsx(Yr, { index: !0, element: /* @__PURE__ */ S.jsx(Dz, {}) }),
            /* @__PURE__ */ S.jsx(
              Yr,
              {
                path: "select-validator/:pendingActionType",
                element: /* @__PURE__ */ S.jsx(Dz, {})
              }
            ),
            /* @__PURE__ */ S.jsxs(Yr, { path: "unstake", children: [
              /* @__PURE__ */ S.jsx(Yr, { path: "review", element: /* @__PURE__ */ S.jsx(kNe, {}) }),
              /* @__PURE__ */ S.jsx(Yr, { path: "steps", element: /* @__PURE__ */ S.jsx(qNe, {}) }),
              /* @__PURE__ */ S.jsx(
                Yr,
                {
                  path: "complete",
                  element: /* @__PURE__ */ S.jsx(b5e, {})
                }
              )
            ] }),
            /* @__PURE__ */ S.jsxs(Yr, { path: "pending-action", children: [
              /* @__PURE__ */ S.jsx(Yr, { path: "review", element: /* @__PURE__ */ S.jsx(ZMe, {}) }),
              /* @__PURE__ */ S.jsx(Yr, { path: "steps", element: /* @__PURE__ */ S.jsx(HNe, {}) }),
              /* @__PURE__ */ S.jsx(
                Yr,
                {
                  path: "complete",
                  element: /* @__PURE__ */ S.jsx(y5e, {})
                }
              )
            ] })
          ] })
        ] }),
        /* @__PURE__ */ S.jsx(Yr, { path: "*", element: /* @__PURE__ */ S.jsx(SQ, { to: "/", replace: !0 }) })
      ] }) }, p) }) }),
      /* @__PURE__ */ S.jsx(yLe, {}),
      /* @__PURE__ */ S.jsx(CX, {})
    ] }) }),
    /* @__PURE__ */ S.jsx(r3e, {})
  ] });
}, eje = () => {
  const [e, t] = k.useState(!1);
  return tf(() => t(!0), []), /* @__PURE__ */ S.jsx(JLe, { children: e && /* @__PURE__ */ S.jsx(ZLe, {}) });
}, tje = (e) => {
  const t = !e.variant || e.variant === "default" ? { variant: "default" } : { variant: e.variant, chainModal: e.chainModal }, [n] = k.useState(
    () => wRe([{ path: "*", Component: eje }])
  );
  return /* @__PURE__ */ S.jsx(efe, { ...t, ...e, children: /* @__PURE__ */ S.jsx(ae, { className: O5e, children: /* @__PURE__ */ S.jsx(LRe, { router: n }) }) });
}, Vje = ({
  container: e,
  ...t
}) => {
  if (!t.apiKey) throw new Error("API key is required");
  R1.createRoot(e).render(/* @__PURE__ */ S.jsx(tje, { ...t }));
}, Mz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: s5
}, Symbol.toStringTag, { value: "Module" }));
export {
  Vje as $,
  WI as A,
  it as B,
  q$ as C,
  Ma as D,
  fbe as E,
  Rje as F,
  xq as G,
  M1 as H,
  $d as I,
  Nt as J,
  S8 as K,
  Ije as L,
  he as M,
  Ike as N,
  BC as O,
  Th as P,
  Wn as Q,
  sSe as R,
  L$ as S,
  Oje as T,
  Yi as U,
  _je as V,
  Oke as W,
  u$ as X,
  _n as Y,
  fn as Z,
  sy as _,
  EM as a,
  eSe as a0,
  Pk as a1,
  XC as b,
  V8 as c,
  uye as d,
  Jd as e,
  Nb as f,
  DC as g,
  Ql as h,
  LM as i,
  aje as j,
  uje as k,
  v1 as l,
  ece as m,
  DV as n,
  Dke as o,
  ct as p,
  ay as q,
  Fs as r,
  Pa as s,
  Mje as t,
  G4 as u,
  nke as v,
  Ye as w,
  mA as x,
  ly as y,
  ni as z
};
//# sourceMappingURL=en_US-FEVFXARA-Bt5B3GiI.js.map
