import { l as x, n as jt, p as Jd } from "./en_US-FEVFXARA-Bt5B3GiI.js";
import { b as qa } from "./readable-browser-BUOHmf6V.js";
import { t as Qt, e as Va, f as Wa, p as Tm, m as bc, n as Gf, o as wm, q as Cm, r as Kf, u as zf, s as Qa, j as re, k as ie, h as Pe, l as De, v as Nm, w as _m } from "./wallet-manager-CHh0V-QY.js";
import { r as xf } from "./index.es-SooumTx_.js";
function Em(e, n) {
  for (var r = 0; r < n.length; r++) {
    const t = n[r];
    if (typeof t != "string" && !Array.isArray(t)) {
      for (const i in t)
        if (i !== "default" && !(i in e)) {
          const f = Object.getOwnPropertyDescriptor(t, i);
          f && Object.defineProperty(e, i, f.get ? f : {
            enumerable: !0,
            get: () => t[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
var Zf = {}, ko = {}, Ie = {}, Fa = {}, Um = x && x.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Fa, "__esModule", { value: !0 });
Fa.Decimal = void 0;
const Qn = Um(qa), Al = 100;
class Oe {
  static fromUserInput(n, r) {
    Oe.verifyFractionalDigits(r);
    const t = n.match(/[^0-9.]/);
    if (t)
      throw new Error(`Invalid character at position ${t.index + 1}`);
    let i, f;
    if (n === "")
      i = "0", f = "";
    else if (n.search(/\./) === -1)
      i = n, f = "";
    else {
      const w = n.split(".");
      switch (w.length) {
        case 0:
        case 1:
          throw new Error("Fewer than two elements in split result. This must not happen here.");
        case 2:
          if (!w[1])
            throw new Error("Fractional part missing");
          i = w[0], f = w[1].replace(/0+$/, "");
          break;
        default:
          throw new Error("More than one separator found");
      }
    }
    if (f.length > r)
      throw new Error("Got more fractional digits than supported");
    const S = `${i}${f.padEnd(r, "0")}`;
    return new Oe(S, r);
  }
  static fromAtomics(n, r) {
    return Oe.verifyFractionalDigits(r), new Oe(n, r);
  }
  /**
   * Creates a Decimal with value 0.0 and the given number of fractial digits.
   *
   * Fractional digits are not relevant for the value but needed to be able
   * to perform arithmetic operations with other decimals.
   */
  static zero(n) {
    return Oe.verifyFractionalDigits(n), new Oe("0", n);
  }
  /**
   * Creates a Decimal with value 1.0 and the given number of fractial digits.
   *
   * Fractional digits are not relevant for the value but needed to be able
   * to perform arithmetic operations with other decimals.
   */
  static one(n) {
    return Oe.verifyFractionalDigits(n), new Oe("1" + "0".repeat(n), n);
  }
  static verifyFractionalDigits(n) {
    if (!Number.isInteger(n))
      throw new Error("Fractional digits is not an integer");
    if (n < 0)
      throw new Error("Fractional digits must not be negative");
    if (n > Al)
      throw new Error(`Fractional digits must not exceed ${Al}`);
  }
  static compare(n, r) {
    if (n.fractionalDigits !== r.fractionalDigits)
      throw new Error("Fractional digits do not match");
    return n.data.atomics.cmp(new Qn.default(r.atomics));
  }
  get atomics() {
    return this.data.atomics.toString();
  }
  get fractionalDigits() {
    return this.data.fractionalDigits;
  }
  constructor(n, r) {
    if (!n.match(/^[0-9]+$/))
      throw new Error("Invalid string format. Only non-negative integers in decimal representation supported.");
    this.data = {
      atomics: new Qn.default(n),
      fractionalDigits: r
    };
  }
  /** Creates a new instance with the same value */
  clone() {
    return new Oe(this.atomics, this.fractionalDigits);
  }
  /** Returns the greatest decimal <= this which has no fractional part (rounding down) */
  floor() {
    const n = new Qn.default(10).pow(new Qn.default(this.data.fractionalDigits)), r = this.data.atomics.div(n);
    return this.data.atomics.mod(n).isZero() ? this.clone() : Oe.fromAtomics(r.mul(n).toString(), this.fractionalDigits);
  }
  /** Returns the smallest decimal >= this which has no fractional part (rounding up) */
  ceil() {
    const n = new Qn.default(10).pow(new Qn.default(this.data.fractionalDigits)), r = this.data.atomics.div(n);
    return this.data.atomics.mod(n).isZero() ? this.clone() : Oe.fromAtomics(r.addn(1).mul(n).toString(), this.fractionalDigits);
  }
  toString() {
    const n = new Qn.default(10).pow(new Qn.default(this.data.fractionalDigits)), r = this.data.atomics.div(n), t = this.data.atomics.mod(n);
    if (t.isZero())
      return r.toString();
    {
      const f = t.toString().padStart(this.data.fractionalDigits, "0").replace(/0+$/, "");
      return `${r.toString()}.${f}`;
    }
  }
  /**
   * Returns an approximation as a float type. Only use this if no
   * exact calculation is required.
   */
  toFloatApproximation() {
    const n = Number(this.toString());
    if (Number.isNaN(n))
      throw new Error("Conversion to number failed");
    return n;
  }
  /**
   * a.plus(b) returns a+b.
   *
   * Both values need to have the same fractional digits.
   */
  plus(n) {
    if (this.fractionalDigits !== n.fractionalDigits)
      throw new Error("Fractional digits do not match");
    const r = this.data.atomics.add(new Qn.default(n.atomics));
    return new Oe(r.toString(), this.fractionalDigits);
  }
  /**
   * a.minus(b) returns a-b.
   *
   * Both values need to have the same fractional digits.
   * The resulting difference needs to be non-negative.
   */
  minus(n) {
    if (this.fractionalDigits !== n.fractionalDigits)
      throw new Error("Fractional digits do not match");
    const r = this.data.atomics.sub(new Qn.default(n.atomics));
    if (r.ltn(0))
      throw new Error("Difference must not be negative");
    return new Oe(r.toString(), this.fractionalDigits);
  }
  /**
   * a.multiply(b) returns a*b.
   *
   * We only allow multiplication by unsigned integers to avoid rounding errors.
   */
  multiply(n) {
    const r = this.data.atomics.mul(new Qn.default(n.toString()));
    return new Oe(r.toString(), this.fractionalDigits);
  }
  equals(n) {
    return Oe.compare(this, n) === 0;
  }
  isLessThan(n) {
    return Oe.compare(this, n) < 0;
  }
  isLessThanOrEqual(n) {
    return Oe.compare(this, n) <= 0;
  }
  isGreaterThan(n) {
    return Oe.compare(this, n) > 0;
  }
  isGreaterThanOrEqual(n) {
    return Oe.compare(this, n) >= 0;
  }
}
Fa.Decimal = Oe;
var Yn = {}, Jm = x && x.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Yn, "__esModule", { value: !0 });
Yn.Uint64 = Yn.Uint53 = Yn.Int53 = Yn.Uint32 = void 0;
const aa = Jm(qa), Dm = new aa.default("18446744073709551615", 10, "be");
class uo {
  /** @deprecated use Uint32.fromBytes */
  static fromBigEndianBytes(n) {
    return uo.fromBytes(n);
  }
  /**
   * Creates a Uint32 from a fixed length byte array.
   *
   * @param bytes a list of exactly 4 bytes
   * @param endianess defaults to big endian
   */
  static fromBytes(n, r = "be") {
    if (n.length !== 4)
      throw new Error("Invalid input length. Expected 4 bytes.");
    for (let i = 0; i < n.length; ++i)
      if (!Number.isInteger(n[i]) || n[i] > 255 || n[i] < 0)
        throw new Error("Invalid value in byte. Found: " + n[i]);
    const t = r === "be" ? n : Array.from(n).reverse();
    return new uo(t[0] * 2 ** 24 + t[1] * 2 ** 16 + t[2] * 2 ** 8 + t[3]);
  }
  static fromString(n) {
    if (!n.match(/^[0-9]+$/))
      throw new Error("Invalid string format");
    return new uo(Number.parseInt(n, 10));
  }
  constructor(n) {
    if (Number.isNaN(n))
      throw new Error("Input is not a number");
    if (!Number.isInteger(n))
      throw new Error("Input is not an integer");
    if (n < 0 || n > 4294967295)
      throw new Error("Input not in uint32 range: " + n.toString());
    this.data = n;
  }
  toBytesBigEndian() {
    return new Uint8Array([
      Math.floor(this.data / 2 ** 24) & 255,
      Math.floor(this.data / 2 ** 16) & 255,
      Math.floor(this.data / 2 ** 8) & 255,
      Math.floor(this.data / 2 ** 0) & 255
    ]);
  }
  toBytesLittleEndian() {
    return new Uint8Array([
      Math.floor(this.data / 2 ** 0) & 255,
      Math.floor(this.data / 2 ** 8) & 255,
      Math.floor(this.data / 2 ** 16) & 255,
      Math.floor(this.data / 2 ** 24) & 255
    ]);
  }
  toNumber() {
    return this.data;
  }
  toBigInt() {
    return BigInt(this.toNumber());
  }
  toString() {
    return this.data.toString();
  }
}
Yn.Uint32 = uo;
class fo {
  static fromString(n) {
    if (!n.match(/^-?[0-9]+$/))
      throw new Error("Invalid string format");
    return new fo(Number.parseInt(n, 10));
  }
  constructor(n) {
    if (Number.isNaN(n))
      throw new Error("Input is not a number");
    if (!Number.isInteger(n))
      throw new Error("Input is not an integer");
    if (n < Number.MIN_SAFE_INTEGER || n > Number.MAX_SAFE_INTEGER)
      throw new Error("Input not in int53 range: " + n.toString());
    this.data = n;
  }
  toNumber() {
    return this.data;
  }
  toBigInt() {
    return BigInt(this.toNumber());
  }
  toString() {
    return this.data.toString();
  }
}
Yn.Int53 = fo;
class Rc {
  static fromString(n) {
    const r = fo.fromString(n);
    return new Rc(r.toNumber());
  }
  constructor(n) {
    const r = new fo(n);
    if (r.toNumber() < 0)
      throw new Error("Input is negative");
    this.data = r;
  }
  toNumber() {
    return this.data.toNumber();
  }
  toBigInt() {
    return BigInt(this.toNumber());
  }
  toString() {
    return this.data.toString();
  }
}
Yn.Uint53 = Rc;
class Rr {
  /** @deprecated use Uint64.fromBytes */
  static fromBytesBigEndian(n) {
    return Rr.fromBytes(n);
  }
  /**
   * Creates a Uint64 from a fixed length byte array.
   *
   * @param bytes a list of exactly 8 bytes
   * @param endianess defaults to big endian
   */
  static fromBytes(n, r = "be") {
    if (n.length !== 8)
      throw new Error("Invalid input length. Expected 8 bytes.");
    for (let i = 0; i < n.length; ++i)
      if (!Number.isInteger(n[i]) || n[i] > 255 || n[i] < 0)
        throw new Error("Invalid value in byte. Found: " + n[i]);
    const t = r === "be" ? Array.from(n) : Array.from(n).reverse();
    return new Rr(new aa.default(t));
  }
  static fromString(n) {
    if (!n.match(/^[0-9]+$/))
      throw new Error("Invalid string format");
    return new Rr(new aa.default(n, 10, "be"));
  }
  static fromNumber(n) {
    if (Number.isNaN(n))
      throw new Error("Input is not a number");
    if (!Number.isInteger(n))
      throw new Error("Input is not an integer");
    let r;
    try {
      r = new aa.default(n);
    } catch {
      throw new Error("Input is not a safe integer");
    }
    return new Rr(r);
  }
  constructor(n) {
    if (n.isNeg())
      throw new Error("Input is negative");
    if (n.gt(Dm))
      throw new Error("Input exceeds uint64 range");
    this.data = n;
  }
  toBytesBigEndian() {
    return Uint8Array.from(this.data.toArray("be", 8));
  }
  toBytesLittleEndian() {
    return Uint8Array.from(this.data.toArray("le", 8));
  }
  toString() {
    return this.data.toString(10);
  }
  toBigInt() {
    return BigInt(this.toString());
  }
  toNumber() {
    return this.data.toNumber();
  }
}
Yn.Uint64 = Rr;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Uint64 = e.Uint53 = e.Uint32 = e.Int53 = e.Decimal = void 0;
  var n = Fa;
  Object.defineProperty(e, "Decimal", { enumerable: !0, get: function() {
    return n.Decimal;
  } });
  var r = Yn;
  Object.defineProperty(e, "Int53", { enumerable: !0, get: function() {
    return r.Int53;
  } }), Object.defineProperty(e, "Uint32", { enumerable: !0, get: function() {
    return r.Uint32;
  } }), Object.defineProperty(e, "Uint53", { enumerable: !0, get: function() {
    return r.Uint53;
  } }), Object.defineProperty(e, "Uint64", { enumerable: !0, get: function() {
    return r.Uint64;
  } });
})(Ie);
var Ft = {}, $a = {};
Object.defineProperty($a, "__esModule", { value: !0 });
$a.decodeTxRaw = void 0;
const Dd = Qt;
function Mm(e) {
  const n = Dd.TxRaw.decode(e);
  return {
    authInfo: Dd.AuthInfo.decode(n.authInfoBytes),
    body: Dd.TxBody.decode(n.bodyBytes),
    signatures: n.signatures
  };
}
$a.decodeTxRaw = Mm;
var Vr = {}, Po = {}, Sn = {}, _e = {}, Xn = {}, La = {}, Wr = {};
Object.defineProperty(Wr, "__esModule", { value: !0 });
Wr.fromAscii = Wr.toAscii = void 0;
function Hm(e) {
  const n = (r) => r.split("").map((t) => {
    const i = t.charCodeAt(0);
    if (i < 32 || i > 126)
      throw new Error("Cannot encode character that is out of printable ASCII range: " + i);
    return i;
  });
  return Uint8Array.from(n(e));
}
Wr.toAscii = Hm;
function qm(e) {
  return ((r) => r.map((t) => {
    if (t < 32 || t > 126)
      throw new Error("Cannot decode character that is out of printable ASCII range: " + t);
    return String.fromCharCode(t);
  }))(Array.from(e)).join("");
}
Wr.fromAscii = qm;
var Qr = {}, Vm = x && x.__createBinding || (Object.create ? function(e, n, r, t) {
  t === void 0 && (t = r);
  var i = Object.getOwnPropertyDescriptor(n, r);
  (!i || ("get" in i ? !n.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return n[r];
  } }), Object.defineProperty(e, t, i);
} : function(e, n, r, t) {
  t === void 0 && (t = r), e[t] = n[r];
}), Wm = x && x.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), Qm = x && x.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var n = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && Vm(n, e, r);
  return Wm(n, e), n;
};
Object.defineProperty(Qr, "__esModule", { value: !0 });
Qr.fromBase64 = Qr.toBase64 = void 0;
const Yf = Qm(Va);
function Fm(e) {
  return Yf.fromByteArray(e);
}
Qr.toBase64 = Fm;
function $m(e) {
  if (!e.match(/^[a-zA-Z0-9+/]*={0,2}$/))
    throw new Error("Invalid base64 string format");
  return Yf.toByteArray(e);
}
Qr.fromBase64 = $m;
var bt = {}, Lm = x && x.__createBinding || (Object.create ? function(e, n, r, t) {
  t === void 0 && (t = r);
  var i = Object.getOwnPropertyDescriptor(n, r);
  (!i || ("get" in i ? !n.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return n[r];
  } }), Object.defineProperty(e, t, i);
} : function(e, n, r, t) {
  t === void 0 && (t = r), e[t] = n[r];
}), Gm = x && x.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), Km = x && x.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var n = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && Lm(n, e, r);
  return Gm(n, e), n;
};
Object.defineProperty(bt, "__esModule", { value: !0 });
bt.normalizeBech32 = bt.fromBech32 = bt.toBech32 = void 0;
const Sa = Km(Wa);
function Xf(e, n, r) {
  return Sa.encode(e, Sa.toWords(n), r);
}
bt.toBech32 = Xf;
function jf(e, n = 1 / 0) {
  const r = Sa.decode(e, n);
  return {
    prefix: r.prefix,
    data: new Uint8Array(Sa.fromWords(r.words))
  };
}
bt.fromBech32 = jf;
function zm(e) {
  const { prefix: n, data: r } = jf(e);
  return Xf(n, r);
}
bt.normalizeBech32 = zm;
var Fr = {};
Object.defineProperty(Fr, "__esModule", { value: !0 });
Fr.fromHex = Fr.toHex = void 0;
function xm(e) {
  let n = "";
  for (const r of e)
    n += ("0" + r.toString(16)).slice(-2);
  return n;
}
Fr.toHex = xm;
function Zm(e) {
  if (e.length % 2 !== 0)
    throw new Error("hex string length must be a multiple of 2");
  const n = new Uint8Array(e.length / 2);
  for (let r = 0; r < n.length; r++) {
    const t = 2 * r, i = e.slice(t, t + 2);
    if (!i.match(/[0-9a-f]{2}/i))
      throw new Error("hex string contains invalid characters");
    n[r] = parseInt(i, 16);
  }
  return n;
}
Fr.fromHex = Zm;
var $r = {};
Object.defineProperty($r, "__esModule", { value: !0 });
$r.toRfc3339 = $r.fromRfc3339 = void 0;
const Ym = /^(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(\.\d{1,9})?((?:[+-]\d{2}:\d{2})|Z)$/;
function cr(e, n = 2) {
  return e.toString().padStart(n, "0");
}
function Xm(e) {
  const n = Ym.exec(e);
  if (!n)
    throw new Error("Date string is not in RFC3339 format");
  const r = +n[1], t = +n[2], i = +n[3], f = +n[4], S = +n[5], w = +n[6], T = n[7] ? Math.floor(+n[7] * 1e3) : 0;
  let J, C, R;
  n[8] === "Z" ? (J = 1, C = 0, R = 0) : (J = n[8].substring(0, 1) === "-" ? -1 : 1, C = +n[8].substring(1, 3), R = +n[8].substring(4, 6));
  const p = J * (C * 60 + R) * 60, m = /* @__PURE__ */ new Date();
  return m.setUTCFullYear(r, t - 1, i), m.setUTCHours(f, S, w, T), new Date(m.getTime() - p * 1e3);
}
$r.fromRfc3339 = Xm;
function jm(e) {
  const n = e.getUTCFullYear(), r = cr(e.getUTCMonth() + 1), t = cr(e.getUTCDate()), i = cr(e.getUTCHours()), f = cr(e.getUTCMinutes()), S = cr(e.getUTCSeconds()), w = cr(e.getUTCMilliseconds(), 3);
  return `${n}-${r}-${t}T${i}:${f}:${S}.${w}Z`;
}
$r.toRfc3339 = jm;
var Lr = {};
Object.defineProperty(Lr, "__esModule", { value: !0 });
Lr.fromUtf8 = Lr.toUtf8 = void 0;
function eg(e) {
  return new TextEncoder().encode(e);
}
Lr.toUtf8 = eg;
function ng(e, n = !1) {
  const r = !n;
  return new TextDecoder("utf-8", { fatal: r }).decode(e);
}
Lr.fromUtf8 = ng;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.toUtf8 = e.fromUtf8 = e.toRfc3339 = e.fromRfc3339 = e.toHex = e.fromHex = e.toBech32 = e.normalizeBech32 = e.fromBech32 = e.toBase64 = e.fromBase64 = e.toAscii = e.fromAscii = void 0;
  var n = Wr;
  Object.defineProperty(e, "fromAscii", { enumerable: !0, get: function() {
    return n.fromAscii;
  } }), Object.defineProperty(e, "toAscii", { enumerable: !0, get: function() {
    return n.toAscii;
  } });
  var r = Qr;
  Object.defineProperty(e, "fromBase64", { enumerable: !0, get: function() {
    return r.fromBase64;
  } }), Object.defineProperty(e, "toBase64", { enumerable: !0, get: function() {
    return r.toBase64;
  } });
  var t = bt;
  Object.defineProperty(e, "fromBech32", { enumerable: !0, get: function() {
    return t.fromBech32;
  } }), Object.defineProperty(e, "normalizeBech32", { enumerable: !0, get: function() {
    return t.normalizeBech32;
  } }), Object.defineProperty(e, "toBech32", { enumerable: !0, get: function() {
    return t.toBech32;
  } });
  var i = Fr;
  Object.defineProperty(e, "fromHex", { enumerable: !0, get: function() {
    return i.fromHex;
  } }), Object.defineProperty(e, "toHex", { enumerable: !0, get: function() {
    return i.toHex;
  } });
  var f = $r;
  Object.defineProperty(e, "fromRfc3339", { enumerable: !0, get: function() {
    return f.fromRfc3339;
  } }), Object.defineProperty(e, "toRfc3339", { enumerable: !0, get: function() {
    return f.toRfc3339;
  } });
  var S = Lr;
  Object.defineProperty(e, "fromUtf8", { enumerable: !0, get: function() {
    return S.fromUtf8;
  } }), Object.defineProperty(e, "toUtf8", { enumerable: !0, get: function() {
    return S.toUtf8;
  } });
})(La);
var rn = {}, Te = {}, Gr = {};
Object.defineProperty(Gr, "__esModule", { value: !0 });
Gr.arrayContentStartsWith = Gr.arrayContentEquals = void 0;
function tg(e, n) {
  if (e.length !== n.length)
    return !1;
  for (let r = 0; r < e.length; ++r)
    if (e[r] !== n[r])
      return !1;
  return !0;
}
Gr.arrayContentEquals = tg;
function rg(e, n) {
  if (e.length < n.length)
    return !1;
  for (let r = 0; r < n.length; ++r)
    if (e[r] !== n[r])
      return !1;
  return !0;
}
Gr.arrayContentStartsWith = rg;
var Rt = {};
Object.defineProperty(Rt, "__esModule", { value: !0 });
Rt.assertDefinedAndNotNull = Rt.assertDefined = Rt.assert = void 0;
function ig(e, n) {
  if (!e)
    throw new Error(n || "condition is not truthy");
}
Rt.assert = ig;
function og(e, n) {
  if (e === void 0)
    throw new Error(n ?? "value is undefined");
}
Rt.assertDefined = og;
function ag(e, n) {
  if (e == null)
    throw new Error(n ?? "value is undefined or null");
}
Rt.assertDefinedAndNotNull = ag;
var Ga = {};
Object.defineProperty(Ga, "__esModule", { value: !0 });
Ga.sleep = void 0;
async function sg(e) {
  return new Promise((n) => setTimeout(n, e));
}
Ga.sleep = sg;
var Bt = {};
Object.defineProperty(Bt, "__esModule", { value: !0 });
Bt.isDefined = Bt.isUint8Array = Bt.isNonNullObject = void 0;
function ep(e) {
  return typeof e == "object" && e !== null;
}
Bt.isNonNullObject = ep;
function dg(e) {
  return !(!ep(e) || Object.prototype.toString.call(e) !== "[object Uint8Array]" || typeof jt < "u" && typeof jt.isBuffer < "u" && jt.isBuffer(e));
}
Bt.isUint8Array = dg;
function ug(e) {
  return e !== void 0;
}
Bt.isDefined = ug;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.isUint8Array = e.isNonNullObject = e.isDefined = e.sleep = e.assertDefinedAndNotNull = e.assertDefined = e.assert = e.arrayContentStartsWith = e.arrayContentEquals = void 0;
  var n = Gr;
  Object.defineProperty(e, "arrayContentEquals", { enumerable: !0, get: function() {
    return n.arrayContentEquals;
  } }), Object.defineProperty(e, "arrayContentStartsWith", { enumerable: !0, get: function() {
    return n.arrayContentStartsWith;
  } });
  var r = Rt;
  Object.defineProperty(e, "assert", { enumerable: !0, get: function() {
    return r.assert;
  } }), Object.defineProperty(e, "assertDefined", { enumerable: !0, get: function() {
    return r.assertDefined;
  } }), Object.defineProperty(e, "assertDefinedAndNotNull", { enumerable: !0, get: function() {
    return r.assertDefinedAndNotNull;
  } });
  var t = Ga;
  Object.defineProperty(e, "sleep", { enumerable: !0, get: function() {
    return t.sleep;
  } });
  var i = Bt;
  Object.defineProperty(e, "isDefined", { enumerable: !0, get: function() {
    return i.isDefined;
  } }), Object.defineProperty(e, "isNonNullObject", { enumerable: !0, get: function() {
    return i.isNonNullObject;
  } }), Object.defineProperty(e, "isUint8Array", { enumerable: !0, get: function() {
    return i.isUint8Array;
  } });
})(Te);
var cg = x && x.__createBinding || (Object.create ? function(e, n, r, t) {
  t === void 0 && (t = r);
  var i = Object.getOwnPropertyDescriptor(n, r);
  (!i || ("get" in i ? !n.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return n[r];
  } }), Object.defineProperty(e, t, i);
} : function(e, n, r, t) {
  t === void 0 && (t = r), e[t] = n[r];
}), lg = x && x.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), fg = x && x.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var n = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && cg(n, e, r);
  return lg(n, e), n;
};
Object.defineProperty(rn, "__esModule", { value: !0 });
rn.pbkdf2Sha512 = rn.pbkdf2Sha512Noble = rn.pbkdf2Sha512NodeCrypto = rn.pbkdf2Sha512Subtle = rn.getSubtle = rn.getNodeCrypto = void 0;
const Yt = Te, pg = Tm, hg = bc;
async function np() {
  try {
    const e = await Promise.resolve().then(() => fg(xf));
    return typeof e == "object" && Object.keys(e).length <= 1 ? void 0 : e;
  } catch {
    return;
  }
}
rn.getNodeCrypto = np;
async function tp() {
  var n, r, t;
  let e = (n = globalThis == null ? void 0 : globalThis.crypto) == null ? void 0 : n.subtle;
  return e || (e = (t = (r = globalThis == null ? void 0 : globalThis.crypto) == null ? void 0 : r.webcrypto) == null ? void 0 : t.subtle), e;
}
rn.getSubtle = tp;
async function rp(e, n, r, t, i) {
  return (0, Yt.assert)(e, "Argument subtle is falsy"), (0, Yt.assert)(typeof e == "object", "Argument subtle is not of type object"), (0, Yt.assert)(typeof e.importKey == "function", "subtle.importKey is not a function"), (0, Yt.assert)(typeof e.deriveBits == "function", "subtle.deriveBits is not a function"), e.importKey("raw", n, { name: "PBKDF2" }, !1, ["deriveBits"]).then((f) => e.deriveBits({
    name: "PBKDF2",
    salt: r,
    iterations: t,
    hash: { name: "SHA-512" }
  }, f, i * 8).then((S) => new Uint8Array(S)));
}
rn.pbkdf2Sha512Subtle = rp;
async function ip(e, n, r, t, i) {
  return (0, Yt.assert)(e, "Argument nodeCrypto is falsy"), (0, Yt.assert)(typeof e == "object", "Argument nodeCrypto is not of type object"), (0, Yt.assert)(typeof e.pbkdf2 == "function", "nodeCrypto.pbkdf2 is not a function"), new Promise((f, S) => {
    e.pbkdf2(n, r, t, i, "sha512", (w, T) => {
      w ? S(w) : f(Uint8Array.from(T));
    });
  });
}
rn.pbkdf2Sha512NodeCrypto = ip;
async function op(e, n, r, t) {
  return (0, pg.pbkdf2Async)(hg.sha512, e, n, { c: r, dkLen: t });
}
rn.pbkdf2Sha512Noble = op;
async function yg(e, n, r, t) {
  const i = await tp();
  if (i)
    return rp(i, e, n, r, t);
  {
    const f = await np();
    return f ? ip(f, e, n, r, t) : op(e, n, r, t);
  }
}
rn.pbkdf2Sha512 = yg;
var Jn = {}, Hi = {};
Object.defineProperty(Hi, "__esModule", { value: !0 });
Hi.toRealUint8Array = void 0;
function mg(e) {
  return e instanceof Uint8Array ? e : Uint8Array.from(e);
}
Hi.toRealUint8Array = mg;
Object.defineProperty(Jn, "__esModule", { value: !0 });
Jn.sha512 = Jn.Sha512 = Jn.sha256 = Jn.Sha256 = void 0;
const gg = Gf, Sg = bc, ap = Hi;
class sp {
  constructor(n) {
    this.blockSize = 512 / 8, this.impl = gg.sha256.create(), n && this.update(n);
  }
  update(n) {
    return this.impl.update((0, ap.toRealUint8Array)(n)), this;
  }
  digest() {
    return this.impl.digest();
  }
}
Jn.Sha256 = sp;
function kg(e) {
  return new sp(e).digest();
}
Jn.sha256 = kg;
class dp {
  constructor(n) {
    this.blockSize = 1024 / 8, this.impl = Sg.sha512.create(), n && this.update(n);
  }
  update(n) {
    return this.impl.update((0, ap.toRealUint8Array)(n)), this;
  }
  digest() {
    return this.impl.digest();
  }
}
Jn.Sha512 = dp;
function Pg(e) {
  return new dp(e).digest();
}
Jn.sha512 = Pg;
Object.defineProperty(Xn, "__esModule", { value: !0 });
Xn.Bip39 = Xn.EnglishMnemonic = Xn.mnemonicToEntropy = Xn.entropyToMnemonic = void 0;
const Il = La, vg = rn, bg = Jn, Bc = [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo"
];
function up(e) {
  return Array.from(e).map((n) => n.toString(2).padStart(8, "0")).join("");
}
function cp(e) {
  const r = e.length * 8 / 32, t = (0, bg.sha256)(e);
  return up(t).slice(0, r);
}
function lp(e) {
  return parseInt(e, 2);
}
const Rg = [16, 20, 24, 28, 32], Bg = [12, 15, 18, 21, 24];
function fp(e) {
  if (Rg.indexOf(e.length) === -1)
    throw new Error("invalid input length");
  const n = up(e), r = cp(e);
  return (n + r).match(/(.{11})/g).map((S) => {
    const w = lp(S);
    return Bc[w];
  }).join(" ");
}
Xn.entropyToMnemonic = fp;
const Og = "Invalid number of words", Ag = "Found word that is not in the wordlist", Ig = "Invalid entropy", Tg = "Invalid mnemonic checksum";
function qu(e) {
  return e.normalize("NFKD");
}
function Oc(e) {
  const n = qu(e).split(" ");
  if (!Bg.includes(n.length))
    throw new Error(Og);
  const r = n.map((J) => {
    const C = Bc.indexOf(J);
    if (C === -1)
      throw new Error(Ag);
    return C.toString(2).padStart(11, "0");
  }).join(""), t = Math.floor(r.length / 33) * 32, i = r.slice(0, t), f = r.slice(t), S = i.match(/(.{1,8})/g).map(lp);
  if (S.length < 16 || S.length > 32 || S.length % 4 !== 0)
    throw new Error(Ig);
  const w = Uint8Array.from(S);
  if (cp(w) !== f)
    throw new Error(Tg);
  return w;
}
Xn.mnemonicToEntropy = Oc;
class tr {
  constructor(n) {
    if (!tr.mnemonicMatcher.test(n))
      throw new Error("Invalid mnemonic format");
    const r = n.split(" "), t = [12, 15, 18, 21, 24];
    if (t.indexOf(r.length) === -1)
      throw new Error(`Invalid word count in mnemonic (allowed: ${t} got: ${r.length})`);
    for (const i of r)
      if (tr.wordlist.indexOf(i) === -1)
        throw new Error("Mnemonic contains invalid word");
    Oc(n), this.data = n;
  }
  toString() {
    return this.data;
  }
}
Xn.EnglishMnemonic = tr;
tr.wordlist = Bc;
tr.mnemonicMatcher = /^[a-z]+( [a-z]+)*$/;
class wg {
  /**
   * Encodes raw entropy of length 16, 20, 24, 28 or 32 bytes as an English mnemonic between 12 and 24 words.
   *
   * | Entropy            | Words |
   * |--------------------|-------|
   * | 128 bit (16 bytes) |    12 |
   * | 160 bit (20 bytes) |    15 |
   * | 192 bit (24 bytes) |    18 |
   * | 224 bit (28 bytes) |    21 |
   * | 256 bit (32 bytes) |    24 |
   *
   *
   * @see https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#generating-the-mnemonic
   * @param entropy The entropy to be encoded. This must be cryptographically secure.
   */
  static encode(n) {
    return new tr(fp(n));
  }
  static decode(n) {
    return Oc(n.toString());
  }
  static async mnemonicToSeed(n, r) {
    const t = (0, Il.toUtf8)(qu(n.toString())), i = "mnemonic" + (r ? qu(r) : ""), f = (0, Il.toUtf8)(i);
    return (0, vg.pbkdf2Sha512)(t, f, 2048, 64);
  }
}
Xn.Bip39 = wg;
var vo = {};
Object.defineProperty(vo, "__esModule", { value: !0 });
vo.Hmac = void 0;
class Cg {
  constructor(n, r) {
    const t = new n().blockSize;
    this.hash = (f) => new n().update(f).digest();
    let i = r;
    if (i.length > t && (i = this.hash(i)), i.length < t) {
      const f = new Uint8Array(t - i.length);
      i = new Uint8Array([...i, ...f]);
    }
    this.oKeyPad = i.map((f) => f ^ 92), this.iKeyPad = i.map((f) => f ^ 54), this.messageHasher = new n(), this.blockSize = t, this.update(this.iKeyPad);
  }
  update(n) {
    return this.messageHasher.update(n), this;
  }
  digest() {
    const n = this.messageHasher.digest();
    return this.hash(new Uint8Array([...this.oKeyPad, ...n]));
  }
}
vo.Hmac = Cg;
var Kr = {};
Object.defineProperty(Kr, "__esModule", { value: !0 });
Kr.keccak256 = Kr.Keccak256 = void 0;
const Ng = wm, _g = Hi;
class pp {
  constructor(n) {
    this.blockSize = 512 / 8, this.impl = Ng.keccak_256.create(), n && this.update(n);
  }
  update(n) {
    return this.impl.update((0, _g.toRealUint8Array)(n)), this;
  }
  digest() {
    return this.impl.digest();
  }
}
Kr.Keccak256 = pp;
function Eg(e) {
  return new pp(e).digest();
}
Kr.keccak256 = Eg;
var on = {}, Ug = x && x.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(on, "__esModule", { value: !0 });
on.Xchacha20poly1305Ietf = on.xchacha20NonceLength = on.Ed25519 = on.Ed25519Keypair = on.Argon2id = on.isArgon2idOptions = void 0;
const Jg = Te, hn = Ug(Cm);
function Dg(e) {
  return !(!(0, Jg.isNonNullObject)(e) || typeof e.outputLength != "number" || typeof e.opsLimit != "number" || typeof e.memLimitKib != "number");
}
on.isArgon2idOptions = Dg;
class Mg {
  static async execute(n, r, t) {
    return await hn.default.ready, hn.default.crypto_pwhash(
      t.outputLength,
      n,
      r,
      // libsodium only supports 16 byte salts and will throw when you don't respect that
      t.opsLimit,
      t.memLimitKib * 1024,
      hn.default.crypto_pwhash_ALG_ARGON2ID13
    );
  }
}
on.Argon2id = Mg;
class Ka {
  // a libsodium privkey has the format `<ed25519 privkey> + <ed25519 pubkey>`
  static fromLibsodiumPrivkey(n) {
    if (n.length !== 64)
      throw new Error(`Unexpected key length ${n.length}. Must be 64.`);
    return new Ka(n.slice(0, 32), n.slice(32, 64));
  }
  constructor(n, r) {
    this.privkey = n, this.pubkey = r;
  }
  toLibsodiumPrivkey() {
    return new Uint8Array([...this.privkey, ...this.pubkey]);
  }
}
on.Ed25519Keypair = Ka;
class Hg {
  /**
   * Generates a keypair deterministically from a given 32 bytes seed.
   *
   * This seed equals the Ed25519 private key.
   * For implementation details see crypto_sign_seed_keypair in
   * https://download.libsodium.org/doc/public-key_cryptography/public-key_signatures.html
   * and diagram on https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
   */
  static async makeKeypair(n) {
    await hn.default.ready;
    const r = hn.default.crypto_sign_seed_keypair(n);
    return Ka.fromLibsodiumPrivkey(r.privateKey);
  }
  static async createSignature(n, r) {
    return await hn.default.ready, hn.default.crypto_sign_detached(n, r.toLibsodiumPrivkey());
  }
  static async verifySignature(n, r, t) {
    return await hn.default.ready, hn.default.crypto_sign_verify_detached(n, r, t);
  }
}
on.Ed25519 = Hg;
on.xchacha20NonceLength = 24;
class qg {
  static async encrypt(n, r, t) {
    return await hn.default.ready, hn.default.crypto_aead_xchacha20poly1305_ietf_encrypt(
      n,
      null,
      null,
      // secret nonce: unused and should be null (https://download.libsodium.org/doc/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction)
      t,
      r
    );
  }
  static async decrypt(n, r, t) {
    return await hn.default.ready, hn.default.crypto_aead_xchacha20poly1305_ietf_decrypt(
      null,
      // secret nonce: unused and should be null (https://download.libsodium.org/doc/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction)
      n,
      null,
      t,
      r
    );
  }
}
on.Xchacha20poly1305Ietf = qg;
var za = {};
Object.defineProperty(za, "__esModule", { value: !0 });
za.Random = void 0;
class Vg {
  /**
   * Returns `count` cryptographically secure random bytes
   */
  static getBytes(n) {
    try {
      const r = typeof window == "object" ? window : self, t = typeof r.crypto < "u" ? r.crypto : r.msCrypto, i = new Uint8Array(n);
      return t.getRandomValues(i), i;
    } catch {
      try {
        const r = xf;
        return new Uint8Array([...r.randomBytes(n)]);
      } catch {
        throw new Error("No secure random number generator found");
      }
    }
  }
}
za.Random = Vg;
var zr = {};
Object.defineProperty(zr, "__esModule", { value: !0 });
zr.ripemd160 = zr.Ripemd160 = void 0;
const Wg = Kf, Qg = Hi;
class hp {
  constructor(n) {
    this.blockSize = 512 / 8, this.impl = Wg.ripemd160.create(), n && this.update(n);
  }
  update(n) {
    return this.impl.update((0, Qg.toRealUint8Array)(n)), this;
  }
  digest() {
    return this.impl.digest();
  }
}
zr.Ripemd160 = hp;
function Fg(e) {
  return new hp(e).digest();
}
zr.ripemd160 = Fg;
var xa = {}, rr = {};
Object.defineProperty(rr, "__esModule", { value: !0 });
rr.ExtendedSecp256k1Signature = rr.Secp256k1Signature = void 0;
function Br(e) {
  let n = 0;
  for (const r of e)
    if (r === 0)
      n++;
    else
      break;
  return e.slice(n);
}
const qo = 2;
class po {
  /**
   * Takes the pair of integers (r, s) as 2x32 byte of binary data.
   *
   * Note: This is the format Cosmos SDK uses natively.
   *
   * @param data a 64 byte value containing integers r and s.
   */
  static fromFixedLength(n) {
    if (n.length !== 64)
      throw new Error(`Got invalid data length: ${n.length}. Expected 2x 32 bytes for the pair (r, s)`);
    return new po(Br(n.slice(0, 32)), Br(n.slice(32, 64)));
  }
  static fromDer(n) {
    let r = 0;
    if (n[r++] !== 48)
      throw new Error("Prefix 0x30 expected");
    const t = n[r++];
    if (n.length - r !== t)
      throw new Error("Data length mismatch detected");
    if (n[r++] !== qo)
      throw new Error("INTEGER tag expected");
    const f = n[r++];
    if (f >= 128)
      throw new Error("Decoding length values above 127 not supported");
    const S = n.slice(r, r + f);
    if (r += f, n[r++] !== qo)
      throw new Error("INTEGER tag expected");
    const T = n[r++];
    if (T >= 128)
      throw new Error("Decoding length values above 127 not supported");
    const J = n.slice(r, r + T);
    return r += T, new po(
      // r/s data can contain leading 0 bytes to express integers being non-negative in DER
      Br(S),
      Br(J)
    );
  }
  constructor(n, r) {
    if (n.length > 32 || n.length === 0 || n[0] === 0)
      throw new Error("Unsigned integer r must be encoded as unpadded big endian.");
    if (r.length > 32 || r.length === 0 || r[0] === 0)
      throw new Error("Unsigned integer s must be encoded as unpadded big endian.");
    this.data = {
      r: n,
      s: r
    };
  }
  r(n) {
    if (n === void 0)
      return this.data.r;
    {
      const r = n - this.data.r.length;
      if (r < 0)
        throw new Error("Length too small to hold parameter r");
      const t = new Uint8Array(r);
      return new Uint8Array([...t, ...this.data.r]);
    }
  }
  s(n) {
    if (n === void 0)
      return this.data.s;
    {
      const r = n - this.data.s.length;
      if (r < 0)
        throw new Error("Length too small to hold parameter s");
      const t = new Uint8Array(r);
      return new Uint8Array([...t, ...this.data.s]);
    }
  }
  toFixedLength() {
    return new Uint8Array([...this.r(32), ...this.s(32)]);
  }
  toDer() {
    const n = this.data.r[0] >= 128 ? new Uint8Array([0, ...this.data.r]) : this.data.r, r = this.data.s[0] >= 128 ? new Uint8Array([0, ...this.data.s]) : this.data.s, t = n.length, i = r.length, f = new Uint8Array([qo, t, ...n, qo, i, ...r]);
    return new Uint8Array([48, f.length, ...f]);
  }
}
rr.Secp256k1Signature = po;
class Ac extends po {
  /**
   * Decode extended signature from the simple fixed length encoding
   * described in toFixedLength().
   */
  static fromFixedLength(n) {
    if (n.length !== 65)
      throw new Error(`Got invalid data length ${n.length}. Expected 32 + 32 + 1`);
    return new Ac(Br(n.slice(0, 32)), Br(n.slice(32, 64)), n[64]);
  }
  constructor(n, r, t) {
    if (super(n, r), !Number.isInteger(t))
      throw new Error("The recovery parameter must be an integer.");
    if (t < 0 || t > 4)
      throw new Error("The recovery parameter must be one of 0, 1, 2, 3.");
    this.recovery = t;
  }
  /**
   * A simple custom encoding that encodes the extended signature as
   * r (32 bytes) | s (32 bytes) | recovery param (1 byte)
   * where | denotes concatenation of bonary data.
   */
  toFixedLength() {
    return new Uint8Array([...this.r(32), ...this.s(32), this.recovery]);
  }
}
rr.ExtendedSecp256k1Signature = Ac;
var yp = x && x.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(xa, "__esModule", { value: !0 });
xa.Secp256k1 = void 0;
const Vo = La, mp = yp(qa), $g = yp(zf), Lg = rr, $t = new $g.default.ec("secp256k1"), Gg = new mp.default("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", "hex");
class Kg {
  /**
   * Takes a 32 byte private key and returns a privkey/pubkey pair.
   *
   * The resulting pubkey is uncompressed. For the use in Cosmos it should
   * be compressed first using `Secp256k1.compressPubkey`.
   */
  static async makeKeypair(n) {
    if (n.length !== 32)
      throw new Error("input data is not a valid secp256k1 private key");
    const r = $t.keyFromPrivate(n);
    if (r.validate().result !== !0)
      throw new Error("input data is not a valid secp256k1 private key");
    if (new mp.default(n).gte(Gg))
      throw new Error("input data is not a valid secp256k1 private key");
    return {
      privkey: (0, Vo.fromHex)(r.getPrivate("hex")),
      // encodes uncompressed as
      // - 1-byte prefix "04"
      // - 32-byte x coordinate
      // - 32-byte y coordinate
      pubkey: Uint8Array.from(r.getPublic("array"))
    };
  }
  /**
   * Creates a signature that is
   * - deterministic (RFC 6979)
   * - lowS signature
   * - DER encoded
   */
  static async createSignature(n, r) {
    if (n.length === 0)
      throw new Error("Message hash must not be empty");
    if (n.length > 32)
      throw new Error("Message hash length must not exceed 32 bytes");
    const t = $t.keyFromPrivate(r), { r: i, s: f, recoveryParam: S } = t.sign(n, { canonical: !0 });
    if (typeof S != "number")
      throw new Error("Recovery param missing");
    return new Lg.ExtendedSecp256k1Signature(Uint8Array.from(i.toArray()), Uint8Array.from(f.toArray()), S);
  }
  static async verifySignature(n, r, t) {
    if (r.length === 0)
      throw new Error("Message hash must not be empty");
    if (r.length > 32)
      throw new Error("Message hash length must not exceed 32 bytes");
    const i = $t.keyFromPublic(t);
    try {
      return i.verify(r, n.toDer());
    } catch {
      return !1;
    }
  }
  static recoverPubkey(n, r) {
    const t = { r: (0, Vo.toHex)(n.r()), s: (0, Vo.toHex)(n.s()) }, i = $t.recoverPubKey(r, t, n.recovery), f = $t.keyFromPublic(i);
    return (0, Vo.fromHex)(f.getPublic(!1, "hex"));
  }
  /**
   * Takes a compressed or uncompressed pubkey and return a compressed one.
   *
   * This function is idempotent.
   */
  static compressPubkey(n) {
    switch (n.length) {
      case 33:
        return n;
      case 65:
        return Uint8Array.from($t.keyFromPublic(n).getPublic(!0, "array"));
      default:
        throw new Error("Invalid pubkey length");
    }
  }
  /**
   * Takes a compressed or uncompressed pubkey and returns an uncompressed one.
   *
   * This function is idempotent.
   */
  static uncompressPubkey(n) {
    switch (n.length) {
      case 33:
        return Uint8Array.from($t.keyFromPublic(n).getPublic(!1, "array"));
      case 65:
        return n;
      default:
        throw new Error("Invalid pubkey length");
    }
  }
  static trimRecoveryByte(n) {
    switch (n.length) {
      case 64:
        return n;
      case 65:
        return n.slice(0, 64);
      default:
        throw new Error("Invalid signature length");
    }
  }
}
xa.Secp256k1 = Kg;
var gp = {};
(function(e) {
  var n = x && x.__importDefault || function(a) {
    return a && a.__esModule ? a : { default: a };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.stringToPath = e.pathToString = e.Slip10 = e.Slip10RawIndex = e.slip10CurveFromString = e.Slip10Curve = void 0;
  const r = La, t = Ie, i = n(qa), f = n(zf), S = vo, w = Jn;
  var T;
  (function(a) {
    a.Secp256k1 = "Bitcoin seed", a.Ed25519 = "ed25519 seed";
  })(T = e.Slip10Curve || (e.Slip10Curve = {}));
  function J(a) {
    switch (a) {
      case T.Ed25519:
        return T.Ed25519;
      case T.Secp256k1:
        return T.Secp256k1;
      default:
        throw new Error(`Unknown curve string: '${a}'`);
    }
  }
  e.slip10CurveFromString = J;
  class C extends t.Uint32 {
    static hardened(d) {
      return new C(d + 2 ** 31);
    }
    static normal(d) {
      return new C(d);
    }
    isHardened() {
      return this.data >= 2 ** 31;
    }
  }
  e.Slip10RawIndex = C;
  const R = new f.default.ec("secp256k1");
  class p {
    static derivePath(d, y, _) {
      let E = this.master(d, y);
      for (const U of _)
        E = this.child(d, E.privkey, E.chainCode, U);
      return E;
    }
    static master(d, y) {
      const _ = new S.Hmac(w.Sha512, (0, r.toAscii)(d)).update(y).digest(), E = _.slice(0, 32), U = _.slice(32, 64);
      return d !== T.Ed25519 && (this.isZero(E) || this.isGteN(d, E)) ? this.master(d, _) : {
        chainCode: U,
        privkey: E
      };
    }
    static child(d, y, _, E) {
      let U;
      if (E.isHardened()) {
        const V = new Uint8Array([0, ...y, ...E.toBytesBigEndian()]);
        U = new S.Hmac(w.Sha512, _).update(V).digest();
      } else {
        if (d === T.Ed25519)
          throw new Error("Normal keys are not allowed with ed25519");
        {
          const V = new Uint8Array([
            ...p.serializedPoint(d, new i.default(y)),
            ...E.toBytesBigEndian()
          ]);
          U = new S.Hmac(w.Sha512, _).update(V).digest();
        }
      }
      return this.childImpl(d, y, _, E, U);
    }
    /**
     * Implementation of ser_P(point(k_par)) from BIP-0032
     *
     * @see https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki
     */
    static serializedPoint(d, y) {
      switch (d) {
        case T.Secp256k1:
          return (0, r.fromHex)(R.g.mul(y).encodeCompressed("hex"));
        default:
          throw new Error("curve not supported");
      }
    }
    static childImpl(d, y, _, E, U) {
      const V = U.slice(0, 32), o = U.slice(32, 64), h = o;
      if (d === T.Ed25519)
        return {
          chainCode: h,
          privkey: V
        };
      const N = this.n(d), q = new i.default(V).add(new i.default(y)).mod(N), u = Uint8Array.from(q.toArray("be", 32));
      if (this.isGteN(d, V) || this.isZero(u)) {
        const l = new S.Hmac(w.Sha512, _).update(new Uint8Array([1, ...o, ...E.toBytesBigEndian()])).digest();
        return this.childImpl(d, y, _, E, l);
      }
      return {
        chainCode: h,
        privkey: u
      };
    }
    static isZero(d) {
      return d.every((y) => y === 0);
    }
    static isGteN(d, y) {
      return new i.default(y).gte(this.n(d));
    }
    static n(d) {
      switch (d) {
        case T.Secp256k1:
          return new i.default("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", 16);
        default:
          throw new Error("curve not supported");
      }
    }
  }
  e.Slip10 = p;
  function m(a) {
    return a.reduce((d, y) => {
      const _ = y.isHardened() ? `${y.toNumber() - 2147483648}'` : y.toString();
      return d + "/" + _;
    }, "m");
  }
  e.pathToString = m;
  function v(a) {
    if (!a.startsWith("m"))
      throw new Error("Path string must start with 'm'");
    let d = a.slice(1);
    const y = new Array();
    for (; d; ) {
      const _ = d.match(/^\/([0-9]+)('?)/);
      if (!_)
        throw new Error("Syntax error while reading path component");
      const [E, U, V] = _, o = t.Uint53.fromString(U).toNumber();
      if (o >= 2 ** 31)
        throw new Error("Component value too high. Must not exceed 2**31-1.");
      V ? y.push(C.hardened(o)) : y.push(C.normal(o)), d = d.slice(E.length);
    }
    return y;
  }
  e.stringToPath = v;
})(gp);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.stringToPath = e.Slip10RawIndex = e.slip10CurveFromString = e.Slip10Curve = e.Slip10 = e.pathToString = e.sha512 = e.Sha512 = e.sha256 = e.Sha256 = e.Secp256k1Signature = e.ExtendedSecp256k1Signature = e.Secp256k1 = e.ripemd160 = e.Ripemd160 = e.Random = e.Xchacha20poly1305Ietf = e.xchacha20NonceLength = e.isArgon2idOptions = e.Ed25519Keypair = e.Ed25519 = e.Argon2id = e.keccak256 = e.Keccak256 = e.Hmac = e.EnglishMnemonic = e.Bip39 = void 0;
  var n = Xn;
  Object.defineProperty(e, "Bip39", { enumerable: !0, get: function() {
    return n.Bip39;
  } }), Object.defineProperty(e, "EnglishMnemonic", { enumerable: !0, get: function() {
    return n.EnglishMnemonic;
  } });
  var r = vo;
  Object.defineProperty(e, "Hmac", { enumerable: !0, get: function() {
    return r.Hmac;
  } });
  var t = Kr;
  Object.defineProperty(e, "Keccak256", { enumerable: !0, get: function() {
    return t.Keccak256;
  } }), Object.defineProperty(e, "keccak256", { enumerable: !0, get: function() {
    return t.keccak256;
  } });
  var i = on;
  Object.defineProperty(e, "Argon2id", { enumerable: !0, get: function() {
    return i.Argon2id;
  } }), Object.defineProperty(e, "Ed25519", { enumerable: !0, get: function() {
    return i.Ed25519;
  } }), Object.defineProperty(e, "Ed25519Keypair", { enumerable: !0, get: function() {
    return i.Ed25519Keypair;
  } }), Object.defineProperty(e, "isArgon2idOptions", { enumerable: !0, get: function() {
    return i.isArgon2idOptions;
  } }), Object.defineProperty(e, "xchacha20NonceLength", { enumerable: !0, get: function() {
    return i.xchacha20NonceLength;
  } }), Object.defineProperty(e, "Xchacha20poly1305Ietf", { enumerable: !0, get: function() {
    return i.Xchacha20poly1305Ietf;
  } });
  var f = za;
  Object.defineProperty(e, "Random", { enumerable: !0, get: function() {
    return f.Random;
  } });
  var S = zr;
  Object.defineProperty(e, "Ripemd160", { enumerable: !0, get: function() {
    return S.Ripemd160;
  } }), Object.defineProperty(e, "ripemd160", { enumerable: !0, get: function() {
    return S.ripemd160;
  } });
  var w = xa;
  Object.defineProperty(e, "Secp256k1", { enumerable: !0, get: function() {
    return w.Secp256k1;
  } });
  var T = rr;
  Object.defineProperty(e, "ExtendedSecp256k1Signature", { enumerable: !0, get: function() {
    return T.ExtendedSecp256k1Signature;
  } }), Object.defineProperty(e, "Secp256k1Signature", { enumerable: !0, get: function() {
    return T.Secp256k1Signature;
  } });
  var J = Jn;
  Object.defineProperty(e, "Sha256", { enumerable: !0, get: function() {
    return J.Sha256;
  } }), Object.defineProperty(e, "sha256", { enumerable: !0, get: function() {
    return J.sha256;
  } }), Object.defineProperty(e, "Sha512", { enumerable: !0, get: function() {
    return J.Sha512;
  } }), Object.defineProperty(e, "sha512", { enumerable: !0, get: function() {
    return J.sha512;
  } });
  var C = gp;
  Object.defineProperty(e, "pathToString", { enumerable: !0, get: function() {
    return C.pathToString;
  } }), Object.defineProperty(e, "Slip10", { enumerable: !0, get: function() {
    return C.Slip10;
  } }), Object.defineProperty(e, "Slip10Curve", { enumerable: !0, get: function() {
    return C.Slip10Curve;
  } }), Object.defineProperty(e, "slip10CurveFromString", { enumerable: !0, get: function() {
    return C.slip10CurveFromString;
  } }), Object.defineProperty(e, "Slip10RawIndex", { enumerable: !0, get: function() {
    return C.Slip10RawIndex;
  } }), Object.defineProperty(e, "stringToPath", { enumerable: !0, get: function() {
    return C.stringToPath;
  } });
})(_e);
var bn = {}, xr = {};
Object.defineProperty(xr, "__esModule", { value: !0 });
xr.fromAscii = xr.toAscii = void 0;
function zg(e) {
  const n = (r) => r.split("").map((t) => {
    const i = t.charCodeAt(0);
    if (i < 32 || i > 126)
      throw new Error("Cannot encode character that is out of printable ASCII range: " + i);
    return i;
  });
  return Uint8Array.from(n(e));
}
xr.toAscii = zg;
function xg(e) {
  return ((r) => r.map((t) => {
    if (t < 32 || t > 126)
      throw new Error("Cannot decode character that is out of printable ASCII range: " + t);
    return String.fromCharCode(t);
  }))(Array.from(e)).join("");
}
xr.fromAscii = xg;
var Zr = {}, Zg = x && x.__createBinding || (Object.create ? function(e, n, r, t) {
  t === void 0 && (t = r);
  var i = Object.getOwnPropertyDescriptor(n, r);
  (!i || ("get" in i ? !n.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return n[r];
  } }), Object.defineProperty(e, t, i);
} : function(e, n, r, t) {
  t === void 0 && (t = r), e[t] = n[r];
}), Yg = x && x.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), Xg = x && x.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var n = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && Zg(n, e, r);
  return Yg(n, e), n;
};
Object.defineProperty(Zr, "__esModule", { value: !0 });
Zr.fromBase64 = Zr.toBase64 = void 0;
const Sp = Xg(Va);
function jg(e) {
  return Sp.fromByteArray(e);
}
Zr.toBase64 = jg;
function eS(e) {
  if (!e.match(/^[a-zA-Z0-9+/]*={0,2}$/))
    throw new Error("Invalid base64 string format");
  return Sp.toByteArray(e);
}
Zr.fromBase64 = eS;
var Ot = {}, nS = x && x.__createBinding || (Object.create ? function(e, n, r, t) {
  t === void 0 && (t = r);
  var i = Object.getOwnPropertyDescriptor(n, r);
  (!i || ("get" in i ? !n.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return n[r];
  } }), Object.defineProperty(e, t, i);
} : function(e, n, r, t) {
  t === void 0 && (t = r), e[t] = n[r];
}), tS = x && x.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), rS = x && x.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var n = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && nS(n, e, r);
  return tS(n, e), n;
};
Object.defineProperty(Ot, "__esModule", { value: !0 });
Ot.normalizeBech32 = Ot.fromBech32 = Ot.toBech32 = void 0;
const ka = rS(Wa);
function kp(e, n, r) {
  return ka.encode(e, ka.toWords(n), r);
}
Ot.toBech32 = kp;
function Pp(e, n = 1 / 0) {
  const r = ka.decode(e, n);
  return {
    prefix: r.prefix,
    data: new Uint8Array(ka.fromWords(r.words))
  };
}
Ot.fromBech32 = Pp;
function iS(e) {
  const { prefix: n, data: r } = Pp(e);
  return kp(n, r);
}
Ot.normalizeBech32 = iS;
var Yr = {};
Object.defineProperty(Yr, "__esModule", { value: !0 });
Yr.fromHex = Yr.toHex = void 0;
function oS(e) {
  let n = "";
  for (const r of e)
    n += ("0" + r.toString(16)).slice(-2);
  return n;
}
Yr.toHex = oS;
function aS(e) {
  if (e.length % 2 !== 0)
    throw new Error("hex string length must be a multiple of 2");
  const n = new Uint8Array(e.length / 2);
  for (let r = 0; r < n.length; r++) {
    const t = 2 * r, i = e.slice(t, t + 2);
    if (!i.match(/[0-9a-f]{2}/i))
      throw new Error("hex string contains invalid characters");
    n[r] = parseInt(i, 16);
  }
  return n;
}
Yr.fromHex = aS;
var Xr = {};
Object.defineProperty(Xr, "__esModule", { value: !0 });
Xr.toRfc3339 = Xr.fromRfc3339 = void 0;
const sS = /^(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(\.\d{1,9})?((?:[+-]\d{2}:\d{2})|Z)$/;
function lr(e, n = 2) {
  return e.toString().padStart(n, "0");
}
function dS(e) {
  const n = sS.exec(e);
  if (!n)
    throw new Error("Date string is not in RFC3339 format");
  const r = +n[1], t = +n[2], i = +n[3], f = +n[4], S = +n[5], w = +n[6], T = n[7] ? Math.floor(+n[7] * 1e3) : 0;
  let J, C, R;
  n[8] === "Z" ? (J = 1, C = 0, R = 0) : (J = n[8].substring(0, 1) === "-" ? -1 : 1, C = +n[8].substring(1, 3), R = +n[8].substring(4, 6));
  const p = J * (C * 60 + R) * 60, m = /* @__PURE__ */ new Date();
  return m.setUTCFullYear(r, t - 1, i), m.setUTCHours(f, S, w, T), new Date(m.getTime() - p * 1e3);
}
Xr.fromRfc3339 = dS;
function uS(e) {
  const n = e.getUTCFullYear(), r = lr(e.getUTCMonth() + 1), t = lr(e.getUTCDate()), i = lr(e.getUTCHours()), f = lr(e.getUTCMinutes()), S = lr(e.getUTCSeconds()), w = lr(e.getUTCMilliseconds(), 3);
  return `${n}-${r}-${t}T${i}:${f}:${S}.${w}Z`;
}
Xr.toRfc3339 = uS;
var jr = {};
Object.defineProperty(jr, "__esModule", { value: !0 });
jr.fromUtf8 = jr.toUtf8 = void 0;
function cS(e) {
  return new TextEncoder().encode(e);
}
jr.toUtf8 = cS;
function lS(e, n = !1) {
  const r = !n;
  return new TextDecoder("utf-8", { fatal: r }).decode(e);
}
jr.fromUtf8 = lS;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.toUtf8 = e.fromUtf8 = e.toRfc3339 = e.fromRfc3339 = e.toHex = e.fromHex = e.toBech32 = e.normalizeBech32 = e.fromBech32 = e.toBase64 = e.fromBase64 = e.toAscii = e.fromAscii = void 0;
  var n = xr;
  Object.defineProperty(e, "fromAscii", { enumerable: !0, get: function() {
    return n.fromAscii;
  } }), Object.defineProperty(e, "toAscii", { enumerable: !0, get: function() {
    return n.toAscii;
  } });
  var r = Zr;
  Object.defineProperty(e, "fromBase64", { enumerable: !0, get: function() {
    return r.fromBase64;
  } }), Object.defineProperty(e, "toBase64", { enumerable: !0, get: function() {
    return r.toBase64;
  } });
  var t = Ot;
  Object.defineProperty(e, "fromBech32", { enumerable: !0, get: function() {
    return t.fromBech32;
  } }), Object.defineProperty(e, "normalizeBech32", { enumerable: !0, get: function() {
    return t.normalizeBech32;
  } }), Object.defineProperty(e, "toBech32", { enumerable: !0, get: function() {
    return t.toBech32;
  } });
  var i = Yr;
  Object.defineProperty(e, "fromHex", { enumerable: !0, get: function() {
    return i.fromHex;
  } }), Object.defineProperty(e, "toHex", { enumerable: !0, get: function() {
    return i.toHex;
  } });
  var f = Xr;
  Object.defineProperty(e, "fromRfc3339", { enumerable: !0, get: function() {
    return f.fromRfc3339;
  } }), Object.defineProperty(e, "toRfc3339", { enumerable: !0, get: function() {
    return f.toRfc3339;
  } });
  var S = jr;
  Object.defineProperty(e, "fromUtf8", { enumerable: !0, get: function() {
    return S.fromUtf8;
  } }), Object.defineProperty(e, "toUtf8", { enumerable: !0, get: function() {
    return S.toUtf8;
  } });
})(bn);
var Le = {}, bo = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.isMultisigThresholdPubkey = e.isSinglePubkey = e.pubkeyType = e.isSecp256k1Pubkey = e.isEd25519Pubkey = void 0;
  function n(f) {
    return f.type === "tendermint/PubKeyEd25519";
  }
  e.isEd25519Pubkey = n;
  function r(f) {
    return f.type === "tendermint/PubKeySecp256k1";
  }
  e.isSecp256k1Pubkey = r, e.pubkeyType = {
    /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/ed25519/ed25519.go#L22 */
    secp256k1: "tendermint/PubKeySecp256k1",
    /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/secp256k1/secp256k1.go#L23 */
    ed25519: "tendermint/PubKeyEd25519",
    /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/sr25519/codec.go#L12 */
    sr25519: "tendermint/PubKeySr25519",
    multisigThreshold: "tendermint/PubKeyMultisigThreshold"
  };
  function t(f) {
    return [e.pubkeyType.ed25519, e.pubkeyType.secp256k1, e.pubkeyType.sr25519].includes(f.type);
  }
  e.isSinglePubkey = t;
  function i(f) {
    return f.type === "tendermint/PubKeyMultisigThreshold";
  }
  e.isMultisigThresholdPubkey = i;
})(bo);
Object.defineProperty(Le, "__esModule", { value: !0 });
Le.encodeBech32Pubkey = Le.encodeAminoPubkey = Le.decodeBech32Pubkey = Le.decodeAminoPubkey = Le.encodeEd25519Pubkey = Le.encodeSecp256k1Pubkey = void 0;
const dn = bn, fS = Ie, oo = Te, ut = bo;
function pS(e) {
  if (e.length !== 33 || e[0] !== 2 && e[0] !== 3)
    throw new Error("Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03");
  return {
    type: ut.pubkeyType.secp256k1,
    value: (0, dn.toBase64)(e)
  };
}
Le.encodeSecp256k1Pubkey = pS;
function hS(e) {
  if (e.length !== 32)
    throw new Error("Ed25519 public key must be 32 bytes long");
  return {
    type: ut.pubkeyType.ed25519,
    value: (0, dn.toBase64)(e)
  };
}
Le.encodeEd25519Pubkey = hS;
const Vu = (0, dn.fromHex)(
  "eb5ae98721"
  /* fixed length */
), Wu = (0, dn.fromHex)(
  "1624de6420"
  /* fixed length */
), Tl = (0, dn.fromHex)(
  "0dfb100520"
  /* fixed length */
), Pa = (0, dn.fromHex)(
  "22c1f7e2"
  /* variable length not included */
);
function Ic(e) {
  if ((0, oo.arrayContentStartsWith)(e, Vu)) {
    const n = e.slice(Vu.length);
    if (n.length !== 33)
      throw new Error("Invalid rest data length. Expected 33 bytes (compressed secp256k1 pubkey).");
    return {
      type: ut.pubkeyType.secp256k1,
      value: (0, dn.toBase64)(n)
    };
  } else if ((0, oo.arrayContentStartsWith)(e, Wu)) {
    const n = e.slice(Wu.length);
    if (n.length !== 32)
      throw new Error("Invalid rest data length. Expected 32 bytes (Ed25519 pubkey).");
    return {
      type: ut.pubkeyType.ed25519,
      value: (0, dn.toBase64)(n)
    };
  } else if ((0, oo.arrayContentStartsWith)(e, Tl)) {
    const n = e.slice(Tl.length);
    if (n.length !== 32)
      throw new Error("Invalid rest data length. Expected 32 bytes (Sr25519 pubkey).");
    return {
      type: ut.pubkeyType.sr25519,
      value: (0, dn.toBase64)(n)
    };
  } else {
    if ((0, oo.arrayContentStartsWith)(e, Pa))
      return mS(e);
    throw new Error("Unsupported public key type. Amino data starts with: " + (0, dn.toHex)(e.slice(0, 5)));
  }
}
Le.decodeAminoPubkey = Ic;
function yS(e) {
  const { data: n } = (0, dn.fromBech32)(e);
  return Ic(n);
}
Le.decodeBech32Pubkey = yS;
function wl(e) {
  if (e.length < 1)
    throw new Error("Can't decode varint. EOF");
  if (e[0] > 127)
    throw new Error("Decoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.Varint implementation from the Go standard library and write some tests.");
  return [e[0], 1];
}
function mS(e) {
  const n = Array.from(e), r = n.splice(0, Pa.length);
  if (!(0, oo.arrayContentStartsWith)(r, Pa))
    throw new Error("Invalid multisig prefix.");
  if (n.shift() != 8)
    throw new Error("Invalid multisig data. Expecting 0x08 prefix before threshold.");
  const [t, i] = wl(n);
  n.splice(0, i);
  const f = [];
  for (; n.length > 0; ) {
    if (n.shift() != 18)
      throw new Error("Invalid multisig data. Expecting 0x12 prefix before participant pubkey length.");
    const [S, w] = wl(n);
    if (n.splice(0, w), n.length < S)
      throw new Error("Invalid multisig data length.");
    const T = n.splice(0, S), J = Ic(Uint8Array.from(T));
    f.push(J);
  }
  return {
    type: ut.pubkeyType.multisigThreshold,
    value: {
      threshold: t.toString(),
      pubkeys: f
    }
  };
}
function Cl(e) {
  const n = fS.Uint53.fromString(e.toString()).toNumber();
  if (n > 127)
    throw new Error("Encoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.PutUvarint implementation from the Go standard library and write some tests.");
  return [n];
}
function Tc(e) {
  if ((0, ut.isMultisigThresholdPubkey)(e)) {
    const n = Array.from(Pa);
    n.push(8), n.push(...Cl(e.value.threshold));
    for (const r of e.value.pubkeys.map((t) => Tc(t)))
      n.push(18), n.push(...Cl(r.length)), n.push(...r);
    return new Uint8Array(n);
  } else {
    if ((0, ut.isEd25519Pubkey)(e))
      return new Uint8Array([...Wu, ...(0, dn.fromBase64)(e.value)]);
    if ((0, ut.isSecp256k1Pubkey)(e))
      return new Uint8Array([...Vu, ...(0, dn.fromBase64)(e.value)]);
    throw new Error("Unsupported pubkey type");
  }
}
Le.encodeAminoPubkey = Tc;
function gS(e, n) {
  return (0, dn.toBech32)(n, Tc(e));
}
Le.encodeBech32Pubkey = gS;
Object.defineProperty(Sn, "__esModule", { value: !0 });
Sn.pubkeyToAddress = Sn.pubkeyToRawAddress = Sn.rawSecp256k1PubkeyToRawAddress = Sn.rawEd25519PubkeyToRawAddress = void 0;
const va = _e, Qu = bn, SS = Le, Md = bo;
function vp(e) {
  if (e.length !== 32)
    throw new Error(`Invalid Ed25519 pubkey length: ${e.length}`);
  return (0, va.sha256)(e).slice(0, 20);
}
Sn.rawEd25519PubkeyToRawAddress = vp;
function bp(e) {
  if (e.length !== 33)
    throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${e.length}`);
  return (0, va.ripemd160)((0, va.sha256)(e));
}
Sn.rawSecp256k1PubkeyToRawAddress = bp;
function Rp(e) {
  if ((0, Md.isSecp256k1Pubkey)(e)) {
    const n = (0, Qu.fromBase64)(e.value);
    return bp(n);
  } else if ((0, Md.isEd25519Pubkey)(e)) {
    const n = (0, Qu.fromBase64)(e.value);
    return vp(n);
  } else if ((0, Md.isMultisigThresholdPubkey)(e)) {
    const n = (0, SS.encodeAminoPubkey)(e);
    return (0, va.sha256)(n).slice(0, 20);
  } else
    throw new Error("Unsupported public key type");
}
Sn.pubkeyToRawAddress = Rp;
function kS(e, n) {
  return (0, Qu.toBech32)(n, Rp(e));
}
Sn.pubkeyToAddress = kS;
var jn = {};
Object.defineProperty(jn, "__esModule", { value: !0 });
jn.addCoins = jn.parseCoins = jn.coins = jn.coin = void 0;
const Fu = Ie;
function Bp(e, n) {
  let r;
  if (typeof e == "number")
    try {
      r = new Fu.Uint53(e).toString();
    } catch {
      throw new Error("Given amount is not a safe integer. Consider using a string instead to overcome the limitations of JS numbers.");
    }
  else {
    if (!e.match(/^[0-9]+$/))
      throw new Error("Invalid unsigned integer string format");
    r = e.replace(/^0*/, "") || "0";
  }
  return {
    amount: r,
    denom: n
  };
}
jn.coin = Bp;
function PS(e, n) {
  return [Bp(e, n)];
}
jn.coins = PS;
function vS(e) {
  return e.replace(/\s/g, "").split(",").filter(Boolean).map((n) => {
    const r = n.match(/^([0-9]+)([a-zA-Z][a-zA-Z0-9/]{2,127})$/);
    if (!r)
      throw new Error("Got an invalid coin string");
    return {
      amount: r[1].replace(/^0+/, "") || "0",
      denom: r[2]
    };
  });
}
jn.parseCoins = vS;
function bS(e, n) {
  if (e.denom !== n.denom)
    throw new Error("Trying to add two coins with different denoms");
  return {
    amount: Fu.Decimal.fromAtomics(e.amount, 0).plus(Fu.Decimal.fromAtomics(n.amount, 0)).atomics,
    denom: e.denom
  };
}
jn.addCoins = bS;
var ei = {};
Object.defineProperty(ei, "__esModule", { value: !0 });
ei.createMultisigThresholdPubkey = ei.compareArrays = void 0;
const Nl = bn, RS = Ie, _l = Sn;
function Op(e, n) {
  const r = (0, Nl.toHex)(e), t = (0, Nl.toHex)(n);
  return r === t ? 0 : r < t ? -1 : 1;
}
ei.compareArrays = Op;
function BS(e, n, r = !1) {
  const t = new RS.Uint53(n);
  if (t.toNumber() > e.length)
    throw new Error(`Threshold k = ${t.toNumber()} exceeds number of keys n = ${e.length}`);
  const i = r ? e : Array.from(e).sort((f, S) => {
    const w = (0, _l.pubkeyToRawAddress)(f), T = (0, _l.pubkeyToRawAddress)(S);
    return Op(w, T);
  });
  return {
    type: "tendermint/PubKeyMultisigThreshold",
    value: {
      threshold: t.toString(),
      pubkeys: i
    }
  };
}
ei.createMultisigThresholdPubkey = BS;
var Za = {};
Object.defineProperty(Za, "__esModule", { value: !0 });
Za.omitDefault = void 0;
function OS(e) {
  switch (typeof e) {
    case "string":
      return e === "" ? void 0 : e;
    case "number":
      return e === 0 ? void 0 : e;
    case "bigint":
      return e === BigInt(0) ? void 0 : e;
    case "boolean":
      return e || void 0;
    default:
      throw new Error(`Got unsupported type '${typeof e}'`);
  }
}
Za.omitDefault = OS;
var Ro = {};
Object.defineProperty(Ro, "__esModule", { value: !0 });
Ro.makeCosmoshubPath = void 0;
const Vi = _e;
function AS(e) {
  return [
    Vi.Slip10RawIndex.hardened(44),
    Vi.Slip10RawIndex.hardened(118),
    Vi.Slip10RawIndex.hardened(0),
    Vi.Slip10RawIndex.normal(0),
    Vi.Slip10RawIndex.normal(e)
  ];
}
Ro.makeCosmoshubPath = AS;
var ni = {}, Vt = {};
Object.defineProperty(Vt, "__esModule", { value: !0 });
Vt.decodeSignature = Vt.encodeSecp256k1Signature = void 0;
const $u = bn, IS = Le, TS = bo;
function wS(e, n) {
  if (n.length !== 64)
    throw new Error("Signature must be 64 bytes long. Cosmos SDK uses a 2x32 byte fixed length encoding for the secp256k1 signature integers r and s.");
  return {
    pub_key: (0, IS.encodeSecp256k1Pubkey)(e),
    signature: (0, $u.toBase64)(n)
  };
}
Vt.encodeSecp256k1Signature = wS;
function CS(e) {
  switch (e.pub_key.type) {
    case TS.pubkeyType.secp256k1:
      return {
        pubkey: (0, $u.fromBase64)(e.pub_key.value),
        signature: (0, $u.fromBase64)(e.signature)
      };
    default:
      throw new Error("Unsupported pubkey type");
  }
}
Vt.decodeSignature = CS;
var Dn = {};
Object.defineProperty(Dn, "__esModule", { value: !0 });
Dn.serializeSignDoc = Dn.escapeCharacters = Dn.makeSignDoc = Dn.sortedJsonStringify = void 0;
const NS = bn, El = Ie;
function Lu(e) {
  if (typeof e != "object" || e === null)
    return e;
  if (Array.isArray(e))
    return e.map(Lu);
  const n = Object.keys(e).sort(), r = {};
  return n.forEach((t) => {
    r[t] = Lu(e[t]);
  }), r;
}
function Ap(e) {
  return JSON.stringify(Lu(e));
}
Dn.sortedJsonStringify = Ap;
function _S(e, n, r, t, i, f, S) {
  return {
    chain_id: r,
    account_number: El.Uint53.fromString(i.toString()).toString(),
    sequence: El.Uint53.fromString(f.toString()).toString(),
    fee: n,
    msgs: e,
    memo: t || "",
    ...S && { timeout_height: S.toString() }
  };
}
Dn.makeSignDoc = _S;
function Ip(e) {
  const n = /&/g, r = /</g, t = />/g;
  return e.replace(n, "\\u0026").replace(r, "\\u003c").replace(t, "\\u003e");
}
Dn.escapeCharacters = Ip;
function ES(e) {
  const n = Ip(Ap(e));
  return (0, NS.toUtf8)(n);
}
Dn.serializeSignDoc = ES;
var wc = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.decrypt = e.encrypt = e.supportedAlgorithms = e.executeKdf = e.cosmjsSalt = void 0;
  const n = _e, r = bn;
  e.cosmjsSalt = (0, r.toAscii)("The CosmJS salt.");
  async function t(S, w) {
    switch (w.algorithm) {
      case "argon2id": {
        const T = w.params;
        if (!(0, n.isArgon2idOptions)(T))
          throw new Error("Invalid format of argon2id params");
        return n.Argon2id.execute(S, e.cosmjsSalt, T);
      }
      default:
        throw new Error("Unsupported KDF algorithm");
    }
  }
  e.executeKdf = t, e.supportedAlgorithms = {
    xchacha20poly1305Ietf: "xchacha20poly1305-ietf"
  };
  async function i(S, w, T) {
    switch (T.algorithm) {
      case e.supportedAlgorithms.xchacha20poly1305Ietf: {
        const J = n.Random.getBytes(n.xchacha20NonceLength);
        return new Uint8Array([
          ...J,
          ...await n.Xchacha20poly1305Ietf.encrypt(S, w, J)
        ]);
      }
      default:
        throw new Error(`Unsupported encryption algorithm: '${T.algorithm}'`);
    }
  }
  e.encrypt = i;
  async function f(S, w, T) {
    switch (T.algorithm) {
      case e.supportedAlgorithms.xchacha20poly1305Ietf: {
        const J = S.slice(0, n.xchacha20NonceLength);
        return n.Xchacha20poly1305Ietf.decrypt(S.slice(n.xchacha20NonceLength), w, J);
      }
      default:
        throw new Error(`Unsupported encryption algorithm: '${T.algorithm}'`);
    }
  }
  e.decrypt = f;
})(wc);
Object.defineProperty(ni, "__esModule", { value: !0 });
ni.Secp256k1HdWallet = ni.extractKdfConfiguration = void 0;
const Rn = _e, Wi = bn, Or = Te, US = Sn, JS = Ro, DS = Vt, MS = Dn, Qi = wc, sa = "secp256k1wallet-v1", HS = {
  algorithm: "argon2id",
  params: {
    outputLength: 32,
    opsLimit: 24,
    memLimitKib: 12 * 1024
  }
};
function qS(e) {
  return !(!(0, Or.isNonNullObject)(e) || typeof e.hdPath != "string" || typeof e.prefix != "string");
}
function VS(e) {
  return e.kdf;
}
function WS(e) {
  const n = JSON.parse(e);
  if (!(0, Or.isNonNullObject)(n))
    throw new Error("Root document is not an object.");
  switch (n.type) {
    case sa:
      return VS(n);
    default:
      throw new Error("Unsupported serialization type");
  }
}
ni.extractKdfConfiguration = WS;
const Ul = {
  bip39Password: "",
  hdPaths: [(0, JS.makeCosmoshubPath)(0)],
  prefix: "cosmos"
};
let QS = class Sr {
  /**
   * Restores a wallet from the given BIP39 mnemonic.
   *
   * @param mnemonic Any valid English mnemonic.
   * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
   */
  static async fromMnemonic(n, r = {}) {
    const t = new Rn.EnglishMnemonic(n), i = await Rn.Bip39.mnemonicToSeed(t, r.bip39Password);
    return new Sr(t, {
      ...r,
      seed: i
    });
  }
  /**
   * Generates a new wallet with a BIP39 mnemonic of the given length.
   *
   * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
   * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
   */
  static async generate(n = 12, r = {}) {
    const t = 4 * Math.floor(11 * n / 33), i = Rn.Random.getBytes(t), f = Rn.Bip39.encode(i);
    return Sr.fromMnemonic(f.toString(), r);
  }
  /**
   * Restores a wallet from an encrypted serialization.
   *
   * @param password The user provided password used to generate an encryption key via a KDF.
   *                 This is not normalized internally (see "Unicode normalization" to learn more).
   */
  static async deserialize(n, r) {
    const t = JSON.parse(n);
    if (!(0, Or.isNonNullObject)(t))
      throw new Error("Root document is not an object.");
    switch (t.type) {
      case sa:
        return Sr.deserializeTypeV1(n, r);
      default:
        throw new Error("Unsupported serialization type");
    }
  }
  /**
   * Restores a wallet from an encrypted serialization.
   *
   * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
   * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
   *
   * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
   * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
   */
  static async deserializeWithEncryptionKey(n, r) {
    const t = JSON.parse(n);
    if (!(0, Or.isNonNullObject)(t))
      throw new Error("Root document is not an object.");
    const i = t;
    switch (i.type) {
      case sa: {
        const f = await (0, Qi.decrypt)((0, Wi.fromBase64)(i.data), r, i.encryption), S = JSON.parse((0, Wi.fromUtf8)(f)), { mnemonic: w, accounts: T } = S;
        if ((0, Or.assert)(typeof w == "string"), !Array.isArray(T))
          throw new Error("Property 'accounts' is not an array");
        if (!T.every((R) => qS(R)))
          throw new Error("Account is not in the correct format.");
        const J = T[0].prefix;
        if (!T.every(({ prefix: R }) => R === J))
          throw new Error("Accounts do not all have the same prefix");
        const C = T.map(({ hdPath: R }) => (0, Rn.stringToPath)(R));
        return Sr.fromMnemonic(w, {
          hdPaths: C,
          prefix: J
        });
      }
      default:
        throw new Error("Unsupported serialization type");
    }
  }
  static async deserializeTypeV1(n, r) {
    const t = JSON.parse(n);
    if (!(0, Or.isNonNullObject)(t))
      throw new Error("Root document is not an object.");
    const i = await (0, Qi.executeKdf)(r, t.kdf);
    return Sr.deserializeWithEncryptionKey(n, i);
  }
  constructor(n, r) {
    const t = r.hdPaths ?? Ul.hdPaths, i = r.prefix ?? Ul.prefix;
    this.secret = n, this.seed = r.seed, this.accounts = t.map((f) => ({
      hdPath: f,
      prefix: i
    }));
  }
  get mnemonic() {
    return this.secret.toString();
  }
  async getAccounts() {
    return (await this.getAccountsWithPrivkeys()).map(({ algo: r, pubkey: t, address: i }) => ({
      algo: r,
      pubkey: t,
      address: i
    }));
  }
  async signAmino(n, r) {
    const i = (await this.getAccountsWithPrivkeys()).find(({ address: C }) => C === n);
    if (i === void 0)
      throw new Error(`Address ${n} not found in wallet`);
    const { privkey: f, pubkey: S } = i, w = (0, Rn.sha256)((0, MS.serializeSignDoc)(r)), T = await Rn.Secp256k1.createSignature(w, f), J = new Uint8Array([...T.r(32), ...T.s(32)]);
    return {
      signed: r,
      signature: (0, DS.encodeSecp256k1Signature)(S, J)
    };
  }
  /**
   * Generates an encrypted serialization of this wallet.
   *
   * @param password The user provided password used to generate an encryption key via a KDF.
   *                 This is not normalized internally (see "Unicode normalization" to learn more).
   */
  async serialize(n) {
    const r = HS, t = await (0, Qi.executeKdf)(n, r);
    return this.serializeWithEncryptionKey(t, r);
  }
  /**
   * Generates an encrypted serialization of this wallet.
   *
   * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
   * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
   *
   * The caller is responsible for ensuring the key was derived with the given KDF options. If this
   * is not the case, the wallet cannot be restored with the original password.
   */
  async serializeWithEncryptionKey(n, r) {
    const t = {
      mnemonic: this.mnemonic,
      accounts: this.accounts.map(({ hdPath: T, prefix: J }) => ({
        hdPath: (0, Rn.pathToString)(T),
        prefix: J
      }))
    }, i = (0, Wi.toUtf8)(JSON.stringify(t)), f = {
      algorithm: Qi.supportedAlgorithms.xchacha20poly1305Ietf
    }, S = await (0, Qi.encrypt)(i, n, f), w = {
      type: sa,
      kdf: r,
      encryption: f,
      data: (0, Wi.toBase64)(S)
    };
    return JSON.stringify(w);
  }
  async getKeyPair(n) {
    const { privkey: r } = Rn.Slip10.derivePath(Rn.Slip10Curve.Secp256k1, this.seed, n), { pubkey: t } = await Rn.Secp256k1.makeKeypair(r);
    return {
      privkey: r,
      pubkey: Rn.Secp256k1.compressPubkey(t)
    };
  }
  async getAccountsWithPrivkeys() {
    return Promise.all(this.accounts.map(async ({ hdPath: n, prefix: r }) => {
      const { privkey: t, pubkey: i } = await this.getKeyPair(n), f = (0, Wi.toBech32)(r, (0, US.rawSecp256k1PubkeyToRawAddress)(i));
      return {
        algo: "secp256k1",
        privkey: t,
        pubkey: i,
        address: f
      };
    }));
  }
};
ni.Secp256k1HdWallet = QS;
var Ya = {};
Object.defineProperty(Ya, "__esModule", { value: !0 });
Ya.Secp256k1Wallet = void 0;
const Wo = _e, FS = bn, $S = Sn, LS = Vt, GS = Dn;
let KS = class Tp {
  /**
   * Creates a Secp256k1Wallet from the given private key
   *
   * @param privkey The private key.
   * @param prefix The bech32 address prefix (human readable part). Defaults to "cosmos".
   */
  static async fromKey(n, r = "cosmos") {
    const t = (await Wo.Secp256k1.makeKeypair(n)).pubkey;
    return new Tp(n, Wo.Secp256k1.compressPubkey(t), r);
  }
  constructor(n, r, t) {
    this.privkey = n, this.pubkey = r, this.prefix = t;
  }
  get address() {
    return (0, FS.toBech32)(this.prefix, (0, $S.rawSecp256k1PubkeyToRawAddress)(this.pubkey));
  }
  async getAccounts() {
    return [
      {
        algo: "secp256k1",
        address: this.address,
        pubkey: this.pubkey
      }
    ];
  }
  async signAmino(n, r) {
    if (n !== this.address)
      throw new Error(`Address ${n} not found in wallet`);
    const t = new Wo.Sha256((0, GS.serializeSignDoc)(r)).digest(), i = await Wo.Secp256k1.createSignature(t, this.privkey), f = new Uint8Array([...i.r(32), ...i.s(32)]);
    return {
      signed: r,
      signature: (0, LS.encodeSecp256k1Signature)(this.pubkey, f)
    };
  }
};
Ya.Secp256k1Wallet = KS;
var ti = {};
Object.defineProperty(ti, "__esModule", { value: !0 });
ti.makeStdTx = ti.isStdTx = void 0;
function zS(e) {
  const { memo: n, msg: r, fee: t, signatures: i } = e;
  return typeof n == "string" && Array.isArray(r) && typeof t == "object" && Array.isArray(i);
}
ti.isStdTx = zS;
function xS(e, n) {
  return {
    msg: e.msgs,
    fee: e.fee,
    memo: e.memo,
    signatures: Array.isArray(n) ? n : [n]
  };
}
ti.makeStdTx = xS;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.executeKdf = e.makeStdTx = e.isStdTx = e.serializeSignDoc = e.makeSignDoc = e.encodeSecp256k1Signature = e.decodeSignature = e.Secp256k1Wallet = e.Secp256k1HdWallet = e.extractKdfConfiguration = e.pubkeyType = e.isSinglePubkey = e.isSecp256k1Pubkey = e.isMultisigThresholdPubkey = e.isEd25519Pubkey = e.makeCosmoshubPath = e.omitDefault = e.createMultisigThresholdPubkey = e.encodeSecp256k1Pubkey = e.encodeEd25519Pubkey = e.encodeBech32Pubkey = e.encodeAminoPubkey = e.decodeBech32Pubkey = e.decodeAminoPubkey = e.parseCoins = e.coins = e.coin = e.addCoins = e.rawSecp256k1PubkeyToRawAddress = e.rawEd25519PubkeyToRawAddress = e.pubkeyToRawAddress = e.pubkeyToAddress = void 0;
  var n = Sn;
  Object.defineProperty(e, "pubkeyToAddress", { enumerable: !0, get: function() {
    return n.pubkeyToAddress;
  } }), Object.defineProperty(e, "pubkeyToRawAddress", { enumerable: !0, get: function() {
    return n.pubkeyToRawAddress;
  } }), Object.defineProperty(e, "rawEd25519PubkeyToRawAddress", { enumerable: !0, get: function() {
    return n.rawEd25519PubkeyToRawAddress;
  } }), Object.defineProperty(e, "rawSecp256k1PubkeyToRawAddress", { enumerable: !0, get: function() {
    return n.rawSecp256k1PubkeyToRawAddress;
  } });
  var r = jn;
  Object.defineProperty(e, "addCoins", { enumerable: !0, get: function() {
    return r.addCoins;
  } }), Object.defineProperty(e, "coin", { enumerable: !0, get: function() {
    return r.coin;
  } }), Object.defineProperty(e, "coins", { enumerable: !0, get: function() {
    return r.coins;
  } }), Object.defineProperty(e, "parseCoins", { enumerable: !0, get: function() {
    return r.parseCoins;
  } });
  var t = Le;
  Object.defineProperty(e, "decodeAminoPubkey", { enumerable: !0, get: function() {
    return t.decodeAminoPubkey;
  } }), Object.defineProperty(e, "decodeBech32Pubkey", { enumerable: !0, get: function() {
    return t.decodeBech32Pubkey;
  } }), Object.defineProperty(e, "encodeAminoPubkey", { enumerable: !0, get: function() {
    return t.encodeAminoPubkey;
  } }), Object.defineProperty(e, "encodeBech32Pubkey", { enumerable: !0, get: function() {
    return t.encodeBech32Pubkey;
  } }), Object.defineProperty(e, "encodeEd25519Pubkey", { enumerable: !0, get: function() {
    return t.encodeEd25519Pubkey;
  } }), Object.defineProperty(e, "encodeSecp256k1Pubkey", { enumerable: !0, get: function() {
    return t.encodeSecp256k1Pubkey;
  } });
  var i = ei;
  Object.defineProperty(e, "createMultisigThresholdPubkey", { enumerable: !0, get: function() {
    return i.createMultisigThresholdPubkey;
  } });
  var f = Za;
  Object.defineProperty(e, "omitDefault", { enumerable: !0, get: function() {
    return f.omitDefault;
  } });
  var S = Ro;
  Object.defineProperty(e, "makeCosmoshubPath", { enumerable: !0, get: function() {
    return S.makeCosmoshubPath;
  } });
  var w = bo;
  Object.defineProperty(e, "isEd25519Pubkey", { enumerable: !0, get: function() {
    return w.isEd25519Pubkey;
  } }), Object.defineProperty(e, "isMultisigThresholdPubkey", { enumerable: !0, get: function() {
    return w.isMultisigThresholdPubkey;
  } }), Object.defineProperty(e, "isSecp256k1Pubkey", { enumerable: !0, get: function() {
    return w.isSecp256k1Pubkey;
  } }), Object.defineProperty(e, "isSinglePubkey", { enumerable: !0, get: function() {
    return w.isSinglePubkey;
  } }), Object.defineProperty(e, "pubkeyType", { enumerable: !0, get: function() {
    return w.pubkeyType;
  } });
  var T = ni;
  Object.defineProperty(e, "extractKdfConfiguration", { enumerable: !0, get: function() {
    return T.extractKdfConfiguration;
  } }), Object.defineProperty(e, "Secp256k1HdWallet", { enumerable: !0, get: function() {
    return T.Secp256k1HdWallet;
  } });
  var J = Ya;
  Object.defineProperty(e, "Secp256k1Wallet", { enumerable: !0, get: function() {
    return J.Secp256k1Wallet;
  } });
  var C = Vt;
  Object.defineProperty(e, "decodeSignature", { enumerable: !0, get: function() {
    return C.decodeSignature;
  } }), Object.defineProperty(e, "encodeSecp256k1Signature", { enumerable: !0, get: function() {
    return C.encodeSecp256k1Signature;
  } });
  var R = Dn;
  Object.defineProperty(e, "makeSignDoc", { enumerable: !0, get: function() {
    return R.makeSignDoc;
  } }), Object.defineProperty(e, "serializeSignDoc", { enumerable: !0, get: function() {
    return R.serializeSignDoc;
  } });
  var p = ti;
  Object.defineProperty(e, "isStdTx", { enumerable: !0, get: function() {
    return p.isStdTx;
  } }), Object.defineProperty(e, "makeStdTx", { enumerable: !0, get: function() {
    return p.makeStdTx;
  } });
  var m = wc;
  Object.defineProperty(e, "executeKdf", { enumerable: !0, get: function() {
    return m.executeKdf;
  } });
})(Po);
var st = {};
Object.defineProperty(st, "__esModule", { value: !0 });
st.makeSignBytes = st.makeSignDoc = st.makeAuthInfoBytes = void 0;
const Jl = Te, ZS = Qa, ba = Qt;
function YS(e, n) {
  return e.map(({ pubkey: r, sequence: t }) => ({
    publicKey: r,
    modeInfo: {
      single: { mode: n }
    },
    sequence: BigInt(t)
  }));
}
function XS(e, n, r, t, i, f = ZS.SignMode.SIGN_MODE_DIRECT) {
  (0, Jl.assert)(t === void 0 || typeof t == "string", "feeGranter must be undefined or string"), (0, Jl.assert)(i === void 0 || typeof i == "string", "feePayer must be undefined or string");
  const S = ba.AuthInfo.fromPartial({
    signerInfos: YS(e, f),
    fee: {
      amount: [...n],
      gasLimit: BigInt(r),
      granter: t,
      payer: i
    }
  });
  return ba.AuthInfo.encode(S).finish();
}
st.makeAuthInfoBytes = XS;
function jS(e, n, r, t) {
  return {
    bodyBytes: e,
    authInfoBytes: n,
    chainId: r,
    accountNumber: BigInt(t)
  };
}
st.makeSignDoc = jS;
function ek({ accountNumber: e, authInfoBytes: n, bodyBytes: r, chainId: t }) {
  const i = ba.SignDoc.fromPartial({
    accountNumber: e,
    authInfoBytes: n,
    bodyBytes: r,
    chainId: t
  });
  return ba.SignDoc.encode(i).finish();
}
st.makeSignBytes = ek;
var Cc = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.decrypt = e.encrypt = e.supportedAlgorithms = e.executeKdf = e.cosmjsSalt = void 0;
  const n = _e, r = bn;
  e.cosmjsSalt = (0, r.toAscii)("The CosmJS salt.");
  async function t(S, w) {
    switch (w.algorithm) {
      case "argon2id": {
        const T = w.params;
        if (!(0, n.isArgon2idOptions)(T))
          throw new Error("Invalid format of argon2id params");
        return n.Argon2id.execute(S, e.cosmjsSalt, T);
      }
      default:
        throw new Error("Unsupported KDF algorithm");
    }
  }
  e.executeKdf = t, e.supportedAlgorithms = {
    xchacha20poly1305Ietf: "xchacha20poly1305-ietf"
  };
  async function i(S, w, T) {
    switch (T.algorithm) {
      case e.supportedAlgorithms.xchacha20poly1305Ietf: {
        const J = n.Random.getBytes(n.xchacha20NonceLength);
        return new Uint8Array([
          ...J,
          ...await n.Xchacha20poly1305Ietf.encrypt(S, w, J)
        ]);
      }
      default:
        throw new Error(`Unsupported encryption algorithm: '${T.algorithm}'`);
    }
  }
  e.encrypt = i;
  async function f(S, w, T) {
    switch (T.algorithm) {
      case e.supportedAlgorithms.xchacha20poly1305Ietf: {
        const J = S.slice(0, n.xchacha20NonceLength);
        return n.Xchacha20poly1305Ietf.decrypt(S.slice(n.xchacha20NonceLength), w, J);
      }
      default:
        throw new Error(`Unsupported encryption algorithm: '${T.algorithm}'`);
    }
  }
  e.decrypt = f;
})(Cc);
Object.defineProperty(Vr, "__esModule", { value: !0 });
Vr.DirectSecp256k1HdWallet = Vr.extractKdfConfiguration = void 0;
const Gu = Po, Bn = _e, Fi = bn, Ar = Te, nk = st, $i = Cc, da = "directsecp256k1hdwallet-v1", tk = {
  algorithm: "argon2id",
  params: {
    outputLength: 32,
    opsLimit: 24,
    memLimitKib: 12 * 1024
  }
};
function rk(e) {
  return !(!(0, Ar.isNonNullObject)(e) || typeof e.hdPath != "string" || typeof e.prefix != "string");
}
function ik(e) {
  return e.kdf;
}
function ok(e) {
  const n = JSON.parse(e);
  if (!(0, Ar.isNonNullObject)(n))
    throw new Error("Root document is not an object.");
  switch (n.type) {
    case da:
      return ik(n);
    default:
      throw new Error("Unsupported serialization type");
  }
}
Vr.extractKdfConfiguration = ok;
const Dl = {
  bip39Password: "",
  hdPaths: [(0, Gu.makeCosmoshubPath)(0)],
  prefix: "cosmos"
};
class zt {
  /**
   * Restores a wallet from the given BIP39 mnemonic.
   *
   * @param mnemonic Any valid English mnemonic.
   * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
   */
  static async fromMnemonic(n, r = {}) {
    const t = new Bn.EnglishMnemonic(n), i = await Bn.Bip39.mnemonicToSeed(t, r.bip39Password);
    return new zt(t, {
      ...r,
      seed: i
    });
  }
  /**
   * Generates a new wallet with a BIP39 mnemonic of the given length.
   *
   * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
   * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
   */
  static async generate(n = 12, r = {}) {
    const t = 4 * Math.floor(11 * n / 33), i = Bn.Random.getBytes(t), f = Bn.Bip39.encode(i);
    return zt.fromMnemonic(f.toString(), r);
  }
  /**
   * Restores a wallet from an encrypted serialization.
   *
   * @param password The user provided password used to generate an encryption key via a KDF.
   *                 This is not normalized internally (see "Unicode normalization" to learn more).
   */
  static async deserialize(n, r) {
    const t = JSON.parse(n);
    if (!(0, Ar.isNonNullObject)(t))
      throw new Error("Root document is not an object.");
    switch (t.type) {
      case da:
        return zt.deserializeTypeV1(n, r);
      default:
        throw new Error("Unsupported serialization type");
    }
  }
  /**
   * Restores a wallet from an encrypted serialization.
   *
   * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
   * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
   *
   * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
   * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
   */
  static async deserializeWithEncryptionKey(n, r) {
    const t = JSON.parse(n);
    if (!(0, Ar.isNonNullObject)(t))
      throw new Error("Root document is not an object.");
    const i = t;
    switch (i.type) {
      case da: {
        const f = await (0, $i.decrypt)((0, Fi.fromBase64)(i.data), r, i.encryption), S = JSON.parse((0, Fi.fromUtf8)(f)), { mnemonic: w, accounts: T } = S;
        if ((0, Ar.assert)(typeof w == "string"), !Array.isArray(T))
          throw new Error("Property 'accounts' is not an array");
        if (!T.every((R) => rk(R)))
          throw new Error("Account is not in the correct format.");
        const J = T[0].prefix;
        if (!T.every(({ prefix: R }) => R === J))
          throw new Error("Accounts do not all have the same prefix");
        const C = T.map(({ hdPath: R }) => (0, Bn.stringToPath)(R));
        return zt.fromMnemonic(w, {
          hdPaths: C,
          prefix: J
        });
      }
      default:
        throw new Error("Unsupported serialization type");
    }
  }
  static async deserializeTypeV1(n, r) {
    const t = JSON.parse(n);
    if (!(0, Ar.isNonNullObject)(t))
      throw new Error("Root document is not an object.");
    const i = await (0, $i.executeKdf)(r, t.kdf);
    return zt.deserializeWithEncryptionKey(n, i);
  }
  constructor(n, r) {
    const t = r.prefix ?? Dl.prefix, i = r.hdPaths ?? Dl.hdPaths;
    this.secret = n, this.seed = r.seed, this.accounts = i.map((f) => ({
      hdPath: f,
      prefix: t
    }));
  }
  get mnemonic() {
    return this.secret.toString();
  }
  async getAccounts() {
    return (await this.getAccountsWithPrivkeys()).map(({ algo: r, pubkey: t, address: i }) => ({
      algo: r,
      pubkey: t,
      address: i
    }));
  }
  async signDirect(n, r) {
    const i = (await this.getAccountsWithPrivkeys()).find(({ address: p }) => p === n);
    if (i === void 0)
      throw new Error(`Address ${n} not found in wallet`);
    const { privkey: f, pubkey: S } = i, w = (0, nk.makeSignBytes)(r), T = (0, Bn.sha256)(w), J = await Bn.Secp256k1.createSignature(T, f), C = new Uint8Array([...J.r(32), ...J.s(32)]), R = (0, Gu.encodeSecp256k1Signature)(S, C);
    return {
      signed: r,
      signature: R
    };
  }
  /**
   * Generates an encrypted serialization of this wallet.
   *
   * @param password The user provided password used to generate an encryption key via a KDF.
   *                 This is not normalized internally (see "Unicode normalization" to learn more).
   */
  async serialize(n) {
    const r = tk, t = await (0, $i.executeKdf)(n, r);
    return this.serializeWithEncryptionKey(t, r);
  }
  /**
   * Generates an encrypted serialization of this wallet.
   *
   * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
   * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
   *
   * The caller is responsible for ensuring the key was derived with the given KDF options. If this
   * is not the case, the wallet cannot be restored with the original password.
   */
  async serializeWithEncryptionKey(n, r) {
    const t = {
      mnemonic: this.mnemonic,
      accounts: this.accounts.map(({ hdPath: T, prefix: J }) => ({
        hdPath: (0, Bn.pathToString)(T),
        prefix: J
      }))
    }, i = (0, Fi.toUtf8)(JSON.stringify(t)), f = {
      algorithm: $i.supportedAlgorithms.xchacha20poly1305Ietf
    }, S = await (0, $i.encrypt)(i, n, f), w = {
      type: da,
      kdf: r,
      encryption: f,
      data: (0, Fi.toBase64)(S)
    };
    return JSON.stringify(w);
  }
  async getKeyPair(n) {
    const { privkey: r } = Bn.Slip10.derivePath(Bn.Slip10Curve.Secp256k1, this.seed, n), { pubkey: t } = await Bn.Secp256k1.makeKeypair(r);
    return {
      privkey: r,
      pubkey: Bn.Secp256k1.compressPubkey(t)
    };
  }
  async getAccountsWithPrivkeys() {
    return Promise.all(this.accounts.map(async ({ hdPath: n, prefix: r }) => {
      const { privkey: t, pubkey: i } = await this.getKeyPair(n), f = (0, Fi.toBech32)(r, (0, Gu.rawSecp256k1PubkeyToRawAddress)(i));
      return {
        algo: "secp256k1",
        privkey: t,
        pubkey: i,
        address: f
      };
    }));
  }
}
Vr.DirectSecp256k1HdWallet = zt;
var Xa = {};
Object.defineProperty(Xa, "__esModule", { value: !0 });
Xa.DirectSecp256k1Wallet = void 0;
const Ml = Po, Qo = _e, ak = bn, sk = st;
class Nc {
  /**
   * Creates a DirectSecp256k1Wallet from the given private key
   *
   * @param privkey The private key.
   * @param prefix The bech32 address prefix (human readable part). Defaults to "cosmos".
   */
  static async fromKey(n, r = "cosmos") {
    const t = (await Qo.Secp256k1.makeKeypair(n)).pubkey;
    return new Nc(n, Qo.Secp256k1.compressPubkey(t), r);
  }
  constructor(n, r, t) {
    this.privkey = n, this.pubkey = r, this.prefix = t;
  }
  get address() {
    return (0, ak.toBech32)(this.prefix, (0, Ml.rawSecp256k1PubkeyToRawAddress)(this.pubkey));
  }
  async getAccounts() {
    return [
      {
        algo: "secp256k1",
        address: this.address,
        pubkey: this.pubkey
      }
    ];
  }
  async signDirect(n, r) {
    const t = (0, sk.makeSignBytes)(r);
    if (n !== this.address)
      throw new Error(`Address ${n} not found in wallet`);
    const i = (0, Qo.sha256)(t), f = await Qo.Secp256k1.createSignature(i, this.privkey), S = new Uint8Array([...f.r(32), ...f.s(32)]), w = (0, Ml.encodeSecp256k1Signature)(this.pubkey, S);
    return {
      signed: r,
      signature: w
    };
  }
}
Xa.DirectSecp256k1Wallet = Nc;
var ja = {};
Object.defineProperty(ja, "__esModule", { value: !0 });
ja.makeCosmoshubPath = void 0;
const Li = _e;
function dk(e) {
  return [
    Li.Slip10RawIndex.hardened(44),
    Li.Slip10RawIndex.hardened(118),
    Li.Slip10RawIndex.hardened(0),
    Li.Slip10RawIndex.normal(0),
    Li.Slip10RawIndex.normal(e)
  ];
}
ja.makeCosmoshubPath = dk;
var et = {}, At = {};
Object.defineProperty(At, "__esModule", { value: !0 });
At.PrivKey = At.PubKey = At.protobufPackage = void 0;
const Tr = re, wr = ie;
At.protobufPackage = "cosmos.crypto.ed25519";
function Hd() {
  return {
    key: new Uint8Array()
  };
}
At.PubKey = {
  typeUrl: "/cosmos.crypto.ed25519.PubKey",
  encode(e, n = Tr.BinaryWriter.create()) {
    return e.key.length !== 0 && n.uint32(10).bytes(e.key), n;
  },
  decode(e, n) {
    const r = e instanceof Tr.BinaryReader ? e : new Tr.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = Hd();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.key = r.bytes();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = Hd();
    return (0, wr.isSet)(e.key) && (n.key = (0, wr.bytesFromBase64)(e.key)), n;
  },
  toJSON(e) {
    const n = {};
    return e.key !== void 0 && (n.key = (0, wr.base64FromBytes)(e.key !== void 0 ? e.key : new Uint8Array())), n;
  },
  fromPartial(e) {
    const n = Hd();
    return n.key = e.key ?? new Uint8Array(), n;
  }
};
function qd() {
  return {
    key: new Uint8Array()
  };
}
At.PrivKey = {
  typeUrl: "/cosmos.crypto.ed25519.PrivKey",
  encode(e, n = Tr.BinaryWriter.create()) {
    return e.key.length !== 0 && n.uint32(10).bytes(e.key), n;
  },
  decode(e, n) {
    const r = e instanceof Tr.BinaryReader ? e : new Tr.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = qd();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.key = r.bytes();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = qd();
    return (0, wr.isSet)(e.key) && (n.key = (0, wr.bytesFromBase64)(e.key)), n;
  },
  toJSON(e) {
    const n = {};
    return e.key !== void 0 && (n.key = (0, wr.base64FromBytes)(e.key !== void 0 ? e.key : new Uint8Array())), n;
  },
  fromPartial(e) {
    const n = qd();
    return n.key = e.key ?? new Uint8Array(), n;
  }
};
var ri = {};
Object.defineProperty(ri, "__esModule", { value: !0 });
ri.LegacyAminoPubKey = ri.protobufPackage = void 0;
const Gi = Pe, Vd = re, uk = ie;
ri.protobufPackage = "cosmos.crypto.multisig";
function Wd() {
  return {
    threshold: 0,
    publicKeys: []
  };
}
ri.LegacyAminoPubKey = {
  typeUrl: "/cosmos.crypto.multisig.LegacyAminoPubKey",
  encode(e, n = Vd.BinaryWriter.create()) {
    e.threshold !== 0 && n.uint32(8).uint32(e.threshold);
    for (const r of e.publicKeys)
      Gi.Any.encode(r, n.uint32(18).fork()).ldelim();
    return n;
  },
  decode(e, n) {
    const r = e instanceof Vd.BinaryReader ? e : new Vd.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = Wd();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.threshold = r.uint32();
          break;
        case 2:
          i.publicKeys.push(Gi.Any.decode(r, r.uint32()));
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = Wd();
    return (0, uk.isSet)(e.threshold) && (n.threshold = Number(e.threshold)), Array.isArray(e == null ? void 0 : e.publicKeys) && (n.publicKeys = e.publicKeys.map((r) => Gi.Any.fromJSON(r))), n;
  },
  toJSON(e) {
    const n = {};
    return e.threshold !== void 0 && (n.threshold = Math.round(e.threshold)), e.publicKeys ? n.publicKeys = e.publicKeys.map((r) => r ? Gi.Any.toJSON(r) : void 0) : n.publicKeys = [], n;
  },
  fromPartial(e) {
    var r;
    const n = Wd();
    return n.threshold = e.threshold ?? 0, n.publicKeys = ((r = e.publicKeys) == null ? void 0 : r.map((t) => Gi.Any.fromPartial(t))) || [], n;
  }
};
var It = {};
Object.defineProperty(It, "__esModule", { value: !0 });
It.PrivKey = It.PubKey = It.protobufPackage = void 0;
const Cr = re, Nr = ie;
It.protobufPackage = "cosmos.crypto.secp256k1";
function Qd() {
  return {
    key: new Uint8Array()
  };
}
It.PubKey = {
  typeUrl: "/cosmos.crypto.secp256k1.PubKey",
  encode(e, n = Cr.BinaryWriter.create()) {
    return e.key.length !== 0 && n.uint32(10).bytes(e.key), n;
  },
  decode(e, n) {
    const r = e instanceof Cr.BinaryReader ? e : new Cr.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = Qd();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.key = r.bytes();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = Qd();
    return (0, Nr.isSet)(e.key) && (n.key = (0, Nr.bytesFromBase64)(e.key)), n;
  },
  toJSON(e) {
    const n = {};
    return e.key !== void 0 && (n.key = (0, Nr.base64FromBytes)(e.key !== void 0 ? e.key : new Uint8Array())), n;
  },
  fromPartial(e) {
    const n = Qd();
    return n.key = e.key ?? new Uint8Array(), n;
  }
};
function Fd() {
  return {
    key: new Uint8Array()
  };
}
It.PrivKey = {
  typeUrl: "/cosmos.crypto.secp256k1.PrivKey",
  encode(e, n = Cr.BinaryWriter.create()) {
    return e.key.length !== 0 && n.uint32(10).bytes(e.key), n;
  },
  decode(e, n) {
    const r = e instanceof Cr.BinaryReader ? e : new Cr.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = Fd();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.key = r.bytes();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = Fd();
    return (0, Nr.isSet)(e.key) && (n.key = (0, Nr.bytesFromBase64)(e.key)), n;
  },
  toJSON(e) {
    const n = {};
    return e.key !== void 0 && (n.key = (0, Nr.base64FromBytes)(e.key !== void 0 ? e.key : new Uint8Array())), n;
  },
  fromPartial(e) {
    const n = Fd();
    return n.key = e.key ?? new Uint8Array(), n;
  }
};
Object.defineProperty(et, "__esModule", { value: !0 });
et.decodeOptionalPubkey = et.decodePubkey = et.anyToSinglePubkey = et.encodePubkey = void 0;
const co = Po, Hl = bn, ck = Ie, Ku = At, zu = ri, xu = It, $d = Pe;
function wp(e) {
  if ((0, co.isSecp256k1Pubkey)(e)) {
    const n = xu.PubKey.fromPartial({
      key: (0, Hl.fromBase64)(e.value)
    });
    return $d.Any.fromPartial({
      typeUrl: "/cosmos.crypto.secp256k1.PubKey",
      value: Uint8Array.from(xu.PubKey.encode(n).finish())
    });
  } else if ((0, co.isEd25519Pubkey)(e)) {
    const n = Ku.PubKey.fromPartial({
      key: (0, Hl.fromBase64)(e.value)
    });
    return $d.Any.fromPartial({
      typeUrl: "/cosmos.crypto.ed25519.PubKey",
      value: Uint8Array.from(Ku.PubKey.encode(n).finish())
    });
  } else if ((0, co.isMultisigThresholdPubkey)(e)) {
    const n = zu.LegacyAminoPubKey.fromPartial({
      threshold: ck.Uint53.fromString(e.value.threshold).toNumber(),
      publicKeys: e.value.pubkeys.map(wp)
    });
    return $d.Any.fromPartial({
      typeUrl: "/cosmos.crypto.multisig.LegacyAminoPubKey",
      value: Uint8Array.from(zu.LegacyAminoPubKey.encode(n).finish())
    });
  } else
    throw new Error(`Pubkey type ${e.type} not recognized`);
}
et.encodePubkey = wp;
function Zu(e) {
  switch (e.typeUrl) {
    case "/cosmos.crypto.secp256k1.PubKey": {
      const { key: n } = xu.PubKey.decode(e.value);
      return (0, co.encodeSecp256k1Pubkey)(n);
    }
    case "/cosmos.crypto.ed25519.PubKey": {
      const { key: n } = Ku.PubKey.decode(e.value);
      return (0, co.encodeEd25519Pubkey)(n);
    }
    default:
      throw new Error(`Pubkey type_url ${e.typeUrl} not recognized as single public key type`);
  }
}
et.anyToSinglePubkey = Zu;
function Cp(e) {
  switch (e.typeUrl) {
    case "/cosmos.crypto.secp256k1.PubKey":
    case "/cosmos.crypto.ed25519.PubKey":
      return Zu(e);
    case "/cosmos.crypto.multisig.LegacyAminoPubKey": {
      const { threshold: n, publicKeys: r } = zu.LegacyAminoPubKey.decode(e.value);
      return {
        type: "tendermint/PubKeyMultisigThreshold",
        value: {
          threshold: n.toString(),
          pubkeys: r.map(Zu)
        }
      };
    }
    default:
      throw new Error(`Pubkey type URL '${e.typeUrl}' not recognized`);
  }
}
et.decodePubkey = Cp;
function lk(e) {
  if (!e)
    return null;
  if (e.typeUrl) {
    if (e.value.length)
      return Cp(e);
    throw new Error(`Pubkey is an Any with type URL '${e.typeUrl}' but an empty value`);
  } else {
    if (e.value.length)
      throw new Error("Pubkey is an Any with an empty type URL but a value set");
    return null;
  }
}
et.decodeOptionalPubkey = lk;
var An = {}, _c = {}, Ec = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Metadata = e.DenomUnit = e.Supply = e.Output = e.Input = e.SendEnabled = e.Params = e.protobufPackage = void 0;
  const n = De, r = re, t = ie;
  e.protobufPackage = "cosmos.bank.v1beta1";
  function i() {
    return {
      sendEnabled: [],
      defaultSendEnabled: !1
    };
  }
  e.Params = {
    typeUrl: "/cosmos.bank.v1beta1.Params",
    encode(R, p = r.BinaryWriter.create()) {
      for (const m of R.sendEnabled)
        e.SendEnabled.encode(m, p.uint32(10).fork()).ldelim();
      return R.defaultSendEnabled === !0 && p.uint32(16).bool(R.defaultSendEnabled), p;
    },
    decode(R, p) {
      const m = R instanceof r.BinaryReader ? R : new r.BinaryReader(R);
      let v = p === void 0 ? m.len : m.pos + p;
      const a = i();
      for (; m.pos < v; ) {
        const d = m.uint32();
        switch (d >>> 3) {
          case 1:
            a.sendEnabled.push(e.SendEnabled.decode(m, m.uint32()));
            break;
          case 2:
            a.defaultSendEnabled = m.bool();
            break;
          default:
            m.skipType(d & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(R) {
      const p = i();
      return Array.isArray(R == null ? void 0 : R.sendEnabled) && (p.sendEnabled = R.sendEnabled.map((m) => e.SendEnabled.fromJSON(m))), (0, t.isSet)(R.defaultSendEnabled) && (p.defaultSendEnabled = !!R.defaultSendEnabled), p;
    },
    toJSON(R) {
      const p = {};
      return R.sendEnabled ? p.sendEnabled = R.sendEnabled.map((m) => m ? e.SendEnabled.toJSON(m) : void 0) : p.sendEnabled = [], R.defaultSendEnabled !== void 0 && (p.defaultSendEnabled = R.defaultSendEnabled), p;
    },
    fromPartial(R) {
      var m;
      const p = i();
      return p.sendEnabled = ((m = R.sendEnabled) == null ? void 0 : m.map((v) => e.SendEnabled.fromPartial(v))) || [], p.defaultSendEnabled = R.defaultSendEnabled ?? !1, p;
    }
  };
  function f() {
    return {
      denom: "",
      enabled: !1
    };
  }
  e.SendEnabled = {
    typeUrl: "/cosmos.bank.v1beta1.SendEnabled",
    encode(R, p = r.BinaryWriter.create()) {
      return R.denom !== "" && p.uint32(10).string(R.denom), R.enabled === !0 && p.uint32(16).bool(R.enabled), p;
    },
    decode(R, p) {
      const m = R instanceof r.BinaryReader ? R : new r.BinaryReader(R);
      let v = p === void 0 ? m.len : m.pos + p;
      const a = f();
      for (; m.pos < v; ) {
        const d = m.uint32();
        switch (d >>> 3) {
          case 1:
            a.denom = m.string();
            break;
          case 2:
            a.enabled = m.bool();
            break;
          default:
            m.skipType(d & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(R) {
      const p = f();
      return (0, t.isSet)(R.denom) && (p.denom = String(R.denom)), (0, t.isSet)(R.enabled) && (p.enabled = !!R.enabled), p;
    },
    toJSON(R) {
      const p = {};
      return R.denom !== void 0 && (p.denom = R.denom), R.enabled !== void 0 && (p.enabled = R.enabled), p;
    },
    fromPartial(R) {
      const p = f();
      return p.denom = R.denom ?? "", p.enabled = R.enabled ?? !1, p;
    }
  };
  function S() {
    return {
      address: "",
      coins: []
    };
  }
  e.Input = {
    typeUrl: "/cosmos.bank.v1beta1.Input",
    encode(R, p = r.BinaryWriter.create()) {
      R.address !== "" && p.uint32(10).string(R.address);
      for (const m of R.coins)
        n.Coin.encode(m, p.uint32(18).fork()).ldelim();
      return p;
    },
    decode(R, p) {
      const m = R instanceof r.BinaryReader ? R : new r.BinaryReader(R);
      let v = p === void 0 ? m.len : m.pos + p;
      const a = S();
      for (; m.pos < v; ) {
        const d = m.uint32();
        switch (d >>> 3) {
          case 1:
            a.address = m.string();
            break;
          case 2:
            a.coins.push(n.Coin.decode(m, m.uint32()));
            break;
          default:
            m.skipType(d & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(R) {
      const p = S();
      return (0, t.isSet)(R.address) && (p.address = String(R.address)), Array.isArray(R == null ? void 0 : R.coins) && (p.coins = R.coins.map((m) => n.Coin.fromJSON(m))), p;
    },
    toJSON(R) {
      const p = {};
      return R.address !== void 0 && (p.address = R.address), R.coins ? p.coins = R.coins.map((m) => m ? n.Coin.toJSON(m) : void 0) : p.coins = [], p;
    },
    fromPartial(R) {
      var m;
      const p = S();
      return p.address = R.address ?? "", p.coins = ((m = R.coins) == null ? void 0 : m.map((v) => n.Coin.fromPartial(v))) || [], p;
    }
  };
  function w() {
    return {
      address: "",
      coins: []
    };
  }
  e.Output = {
    typeUrl: "/cosmos.bank.v1beta1.Output",
    encode(R, p = r.BinaryWriter.create()) {
      R.address !== "" && p.uint32(10).string(R.address);
      for (const m of R.coins)
        n.Coin.encode(m, p.uint32(18).fork()).ldelim();
      return p;
    },
    decode(R, p) {
      const m = R instanceof r.BinaryReader ? R : new r.BinaryReader(R);
      let v = p === void 0 ? m.len : m.pos + p;
      const a = w();
      for (; m.pos < v; ) {
        const d = m.uint32();
        switch (d >>> 3) {
          case 1:
            a.address = m.string();
            break;
          case 2:
            a.coins.push(n.Coin.decode(m, m.uint32()));
            break;
          default:
            m.skipType(d & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(R) {
      const p = w();
      return (0, t.isSet)(R.address) && (p.address = String(R.address)), Array.isArray(R == null ? void 0 : R.coins) && (p.coins = R.coins.map((m) => n.Coin.fromJSON(m))), p;
    },
    toJSON(R) {
      const p = {};
      return R.address !== void 0 && (p.address = R.address), R.coins ? p.coins = R.coins.map((m) => m ? n.Coin.toJSON(m) : void 0) : p.coins = [], p;
    },
    fromPartial(R) {
      var m;
      const p = w();
      return p.address = R.address ?? "", p.coins = ((m = R.coins) == null ? void 0 : m.map((v) => n.Coin.fromPartial(v))) || [], p;
    }
  };
  function T() {
    return {
      total: []
    };
  }
  e.Supply = {
    typeUrl: "/cosmos.bank.v1beta1.Supply",
    encode(R, p = r.BinaryWriter.create()) {
      for (const m of R.total)
        n.Coin.encode(m, p.uint32(10).fork()).ldelim();
      return p;
    },
    decode(R, p) {
      const m = R instanceof r.BinaryReader ? R : new r.BinaryReader(R);
      let v = p === void 0 ? m.len : m.pos + p;
      const a = T();
      for (; m.pos < v; ) {
        const d = m.uint32();
        switch (d >>> 3) {
          case 1:
            a.total.push(n.Coin.decode(m, m.uint32()));
            break;
          default:
            m.skipType(d & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(R) {
      const p = T();
      return Array.isArray(R == null ? void 0 : R.total) && (p.total = R.total.map((m) => n.Coin.fromJSON(m))), p;
    },
    toJSON(R) {
      const p = {};
      return R.total ? p.total = R.total.map((m) => m ? n.Coin.toJSON(m) : void 0) : p.total = [], p;
    },
    fromPartial(R) {
      var m;
      const p = T();
      return p.total = ((m = R.total) == null ? void 0 : m.map((v) => n.Coin.fromPartial(v))) || [], p;
    }
  };
  function J() {
    return {
      denom: "",
      exponent: 0,
      aliases: []
    };
  }
  e.DenomUnit = {
    typeUrl: "/cosmos.bank.v1beta1.DenomUnit",
    encode(R, p = r.BinaryWriter.create()) {
      R.denom !== "" && p.uint32(10).string(R.denom), R.exponent !== 0 && p.uint32(16).uint32(R.exponent);
      for (const m of R.aliases)
        p.uint32(26).string(m);
      return p;
    },
    decode(R, p) {
      const m = R instanceof r.BinaryReader ? R : new r.BinaryReader(R);
      let v = p === void 0 ? m.len : m.pos + p;
      const a = J();
      for (; m.pos < v; ) {
        const d = m.uint32();
        switch (d >>> 3) {
          case 1:
            a.denom = m.string();
            break;
          case 2:
            a.exponent = m.uint32();
            break;
          case 3:
            a.aliases.push(m.string());
            break;
          default:
            m.skipType(d & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(R) {
      const p = J();
      return (0, t.isSet)(R.denom) && (p.denom = String(R.denom)), (0, t.isSet)(R.exponent) && (p.exponent = Number(R.exponent)), Array.isArray(R == null ? void 0 : R.aliases) && (p.aliases = R.aliases.map((m) => String(m))), p;
    },
    toJSON(R) {
      const p = {};
      return R.denom !== void 0 && (p.denom = R.denom), R.exponent !== void 0 && (p.exponent = Math.round(R.exponent)), R.aliases ? p.aliases = R.aliases.map((m) => m) : p.aliases = [], p;
    },
    fromPartial(R) {
      var m;
      const p = J();
      return p.denom = R.denom ?? "", p.exponent = R.exponent ?? 0, p.aliases = ((m = R.aliases) == null ? void 0 : m.map((v) => v)) || [], p;
    }
  };
  function C() {
    return {
      description: "",
      denomUnits: [],
      base: "",
      display: "",
      name: "",
      symbol: "",
      uri: "",
      uriHash: ""
    };
  }
  e.Metadata = {
    typeUrl: "/cosmos.bank.v1beta1.Metadata",
    encode(R, p = r.BinaryWriter.create()) {
      R.description !== "" && p.uint32(10).string(R.description);
      for (const m of R.denomUnits)
        e.DenomUnit.encode(m, p.uint32(18).fork()).ldelim();
      return R.base !== "" && p.uint32(26).string(R.base), R.display !== "" && p.uint32(34).string(R.display), R.name !== "" && p.uint32(42).string(R.name), R.symbol !== "" && p.uint32(50).string(R.symbol), R.uri !== "" && p.uint32(58).string(R.uri), R.uriHash !== "" && p.uint32(66).string(R.uriHash), p;
    },
    decode(R, p) {
      const m = R instanceof r.BinaryReader ? R : new r.BinaryReader(R);
      let v = p === void 0 ? m.len : m.pos + p;
      const a = C();
      for (; m.pos < v; ) {
        const d = m.uint32();
        switch (d >>> 3) {
          case 1:
            a.description = m.string();
            break;
          case 2:
            a.denomUnits.push(e.DenomUnit.decode(m, m.uint32()));
            break;
          case 3:
            a.base = m.string();
            break;
          case 4:
            a.display = m.string();
            break;
          case 5:
            a.name = m.string();
            break;
          case 6:
            a.symbol = m.string();
            break;
          case 7:
            a.uri = m.string();
            break;
          case 8:
            a.uriHash = m.string();
            break;
          default:
            m.skipType(d & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(R) {
      const p = C();
      return (0, t.isSet)(R.description) && (p.description = String(R.description)), Array.isArray(R == null ? void 0 : R.denomUnits) && (p.denomUnits = R.denomUnits.map((m) => e.DenomUnit.fromJSON(m))), (0, t.isSet)(R.base) && (p.base = String(R.base)), (0, t.isSet)(R.display) && (p.display = String(R.display)), (0, t.isSet)(R.name) && (p.name = String(R.name)), (0, t.isSet)(R.symbol) && (p.symbol = String(R.symbol)), (0, t.isSet)(R.uri) && (p.uri = String(R.uri)), (0, t.isSet)(R.uriHash) && (p.uriHash = String(R.uriHash)), p;
    },
    toJSON(R) {
      const p = {};
      return R.description !== void 0 && (p.description = R.description), R.denomUnits ? p.denomUnits = R.denomUnits.map((m) => m ? e.DenomUnit.toJSON(m) : void 0) : p.denomUnits = [], R.base !== void 0 && (p.base = R.base), R.display !== void 0 && (p.display = R.display), R.name !== void 0 && (p.name = R.name), R.symbol !== void 0 && (p.symbol = R.symbol), R.uri !== void 0 && (p.uri = R.uri), R.uriHash !== void 0 && (p.uriHash = R.uriHash), p;
    },
    fromPartial(R) {
      var m;
      const p = C();
      return p.description = R.description ?? "", p.denomUnits = ((m = R.denomUnits) == null ? void 0 : m.map((v) => e.DenomUnit.fromPartial(v))) || [], p.base = R.base ?? "", p.display = R.display ?? "", p.name = R.name ?? "", p.symbol = R.symbol ?? "", p.uri = R.uri ?? "", p.uriHash = R.uriHash ?? "", p;
    }
  };
})(Ec);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgSetSendEnabledResponse = e.MsgSetSendEnabled = e.MsgUpdateParamsResponse = e.MsgUpdateParams = e.MsgMultiSendResponse = e.MsgMultiSend = e.MsgSendResponse = e.MsgSend = e.protobufPackage = void 0;
  const n = De, r = Ec, t = re, i = ie;
  e.protobufPackage = "cosmos.bank.v1beta1";
  function f() {
    return {
      fromAddress: "",
      toAddress: "",
      amount: []
    };
  }
  e.MsgSend = {
    typeUrl: "/cosmos.bank.v1beta1.MsgSend",
    encode(v, a = t.BinaryWriter.create()) {
      v.fromAddress !== "" && a.uint32(10).string(v.fromAddress), v.toAddress !== "" && a.uint32(18).string(v.toAddress);
      for (const d of v.amount)
        n.Coin.encode(d, a.uint32(26).fork()).ldelim();
      return a;
    },
    decode(v, a) {
      const d = v instanceof t.BinaryReader ? v : new t.BinaryReader(v);
      let y = a === void 0 ? d.len : d.pos + a;
      const _ = f();
      for (; d.pos < y; ) {
        const E = d.uint32();
        switch (E >>> 3) {
          case 1:
            _.fromAddress = d.string();
            break;
          case 2:
            _.toAddress = d.string();
            break;
          case 3:
            _.amount.push(n.Coin.decode(d, d.uint32()));
            break;
          default:
            d.skipType(E & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(v) {
      const a = f();
      return (0, i.isSet)(v.fromAddress) && (a.fromAddress = String(v.fromAddress)), (0, i.isSet)(v.toAddress) && (a.toAddress = String(v.toAddress)), Array.isArray(v == null ? void 0 : v.amount) && (a.amount = v.amount.map((d) => n.Coin.fromJSON(d))), a;
    },
    toJSON(v) {
      const a = {};
      return v.fromAddress !== void 0 && (a.fromAddress = v.fromAddress), v.toAddress !== void 0 && (a.toAddress = v.toAddress), v.amount ? a.amount = v.amount.map((d) => d ? n.Coin.toJSON(d) : void 0) : a.amount = [], a;
    },
    fromPartial(v) {
      var d;
      const a = f();
      return a.fromAddress = v.fromAddress ?? "", a.toAddress = v.toAddress ?? "", a.amount = ((d = v.amount) == null ? void 0 : d.map((y) => n.Coin.fromPartial(y))) || [], a;
    }
  };
  function S() {
    return {};
  }
  e.MsgSendResponse = {
    typeUrl: "/cosmos.bank.v1beta1.MsgSendResponse",
    encode(v, a = t.BinaryWriter.create()) {
      return a;
    },
    decode(v, a) {
      const d = v instanceof t.BinaryReader ? v : new t.BinaryReader(v);
      let y = a === void 0 ? d.len : d.pos + a;
      const _ = S();
      for (; d.pos < y; ) {
        const E = d.uint32();
        switch (E >>> 3) {
          default:
            d.skipType(E & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(v) {
      return S();
    },
    toJSON(v) {
      return {};
    },
    fromPartial(v) {
      return S();
    }
  };
  function w() {
    return {
      inputs: [],
      outputs: []
    };
  }
  e.MsgMultiSend = {
    typeUrl: "/cosmos.bank.v1beta1.MsgMultiSend",
    encode(v, a = t.BinaryWriter.create()) {
      for (const d of v.inputs)
        r.Input.encode(d, a.uint32(10).fork()).ldelim();
      for (const d of v.outputs)
        r.Output.encode(d, a.uint32(18).fork()).ldelim();
      return a;
    },
    decode(v, a) {
      const d = v instanceof t.BinaryReader ? v : new t.BinaryReader(v);
      let y = a === void 0 ? d.len : d.pos + a;
      const _ = w();
      for (; d.pos < y; ) {
        const E = d.uint32();
        switch (E >>> 3) {
          case 1:
            _.inputs.push(r.Input.decode(d, d.uint32()));
            break;
          case 2:
            _.outputs.push(r.Output.decode(d, d.uint32()));
            break;
          default:
            d.skipType(E & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(v) {
      const a = w();
      return Array.isArray(v == null ? void 0 : v.inputs) && (a.inputs = v.inputs.map((d) => r.Input.fromJSON(d))), Array.isArray(v == null ? void 0 : v.outputs) && (a.outputs = v.outputs.map((d) => r.Output.fromJSON(d))), a;
    },
    toJSON(v) {
      const a = {};
      return v.inputs ? a.inputs = v.inputs.map((d) => d ? r.Input.toJSON(d) : void 0) : a.inputs = [], v.outputs ? a.outputs = v.outputs.map((d) => d ? r.Output.toJSON(d) : void 0) : a.outputs = [], a;
    },
    fromPartial(v) {
      var d, y;
      const a = w();
      return a.inputs = ((d = v.inputs) == null ? void 0 : d.map((_) => r.Input.fromPartial(_))) || [], a.outputs = ((y = v.outputs) == null ? void 0 : y.map((_) => r.Output.fromPartial(_))) || [], a;
    }
  };
  function T() {
    return {};
  }
  e.MsgMultiSendResponse = {
    typeUrl: "/cosmos.bank.v1beta1.MsgMultiSendResponse",
    encode(v, a = t.BinaryWriter.create()) {
      return a;
    },
    decode(v, a) {
      const d = v instanceof t.BinaryReader ? v : new t.BinaryReader(v);
      let y = a === void 0 ? d.len : d.pos + a;
      const _ = T();
      for (; d.pos < y; ) {
        const E = d.uint32();
        switch (E >>> 3) {
          default:
            d.skipType(E & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(v) {
      return T();
    },
    toJSON(v) {
      return {};
    },
    fromPartial(v) {
      return T();
    }
  };
  function J() {
    return {
      authority: "",
      params: r.Params.fromPartial({})
    };
  }
  e.MsgUpdateParams = {
    typeUrl: "/cosmos.bank.v1beta1.MsgUpdateParams",
    encode(v, a = t.BinaryWriter.create()) {
      return v.authority !== "" && a.uint32(10).string(v.authority), v.params !== void 0 && r.Params.encode(v.params, a.uint32(18).fork()).ldelim(), a;
    },
    decode(v, a) {
      const d = v instanceof t.BinaryReader ? v : new t.BinaryReader(v);
      let y = a === void 0 ? d.len : d.pos + a;
      const _ = J();
      for (; d.pos < y; ) {
        const E = d.uint32();
        switch (E >>> 3) {
          case 1:
            _.authority = d.string();
            break;
          case 2:
            _.params = r.Params.decode(d, d.uint32());
            break;
          default:
            d.skipType(E & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(v) {
      const a = J();
      return (0, i.isSet)(v.authority) && (a.authority = String(v.authority)), (0, i.isSet)(v.params) && (a.params = r.Params.fromJSON(v.params)), a;
    },
    toJSON(v) {
      const a = {};
      return v.authority !== void 0 && (a.authority = v.authority), v.params !== void 0 && (a.params = v.params ? r.Params.toJSON(v.params) : void 0), a;
    },
    fromPartial(v) {
      const a = J();
      return a.authority = v.authority ?? "", v.params !== void 0 && v.params !== null && (a.params = r.Params.fromPartial(v.params)), a;
    }
  };
  function C() {
    return {};
  }
  e.MsgUpdateParamsResponse = {
    typeUrl: "/cosmos.bank.v1beta1.MsgUpdateParamsResponse",
    encode(v, a = t.BinaryWriter.create()) {
      return a;
    },
    decode(v, a) {
      const d = v instanceof t.BinaryReader ? v : new t.BinaryReader(v);
      let y = a === void 0 ? d.len : d.pos + a;
      const _ = C();
      for (; d.pos < y; ) {
        const E = d.uint32();
        switch (E >>> 3) {
          default:
            d.skipType(E & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(v) {
      return C();
    },
    toJSON(v) {
      return {};
    },
    fromPartial(v) {
      return C();
    }
  };
  function R() {
    return {
      authority: "",
      sendEnabled: [],
      useDefaultFor: []
    };
  }
  e.MsgSetSendEnabled = {
    typeUrl: "/cosmos.bank.v1beta1.MsgSetSendEnabled",
    encode(v, a = t.BinaryWriter.create()) {
      v.authority !== "" && a.uint32(10).string(v.authority);
      for (const d of v.sendEnabled)
        r.SendEnabled.encode(d, a.uint32(18).fork()).ldelim();
      for (const d of v.useDefaultFor)
        a.uint32(26).string(d);
      return a;
    },
    decode(v, a) {
      const d = v instanceof t.BinaryReader ? v : new t.BinaryReader(v);
      let y = a === void 0 ? d.len : d.pos + a;
      const _ = R();
      for (; d.pos < y; ) {
        const E = d.uint32();
        switch (E >>> 3) {
          case 1:
            _.authority = d.string();
            break;
          case 2:
            _.sendEnabled.push(r.SendEnabled.decode(d, d.uint32()));
            break;
          case 3:
            _.useDefaultFor.push(d.string());
            break;
          default:
            d.skipType(E & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(v) {
      const a = R();
      return (0, i.isSet)(v.authority) && (a.authority = String(v.authority)), Array.isArray(v == null ? void 0 : v.sendEnabled) && (a.sendEnabled = v.sendEnabled.map((d) => r.SendEnabled.fromJSON(d))), Array.isArray(v == null ? void 0 : v.useDefaultFor) && (a.useDefaultFor = v.useDefaultFor.map((d) => String(d))), a;
    },
    toJSON(v) {
      const a = {};
      return v.authority !== void 0 && (a.authority = v.authority), v.sendEnabled ? a.sendEnabled = v.sendEnabled.map((d) => d ? r.SendEnabled.toJSON(d) : void 0) : a.sendEnabled = [], v.useDefaultFor ? a.useDefaultFor = v.useDefaultFor.map((d) => d) : a.useDefaultFor = [], a;
    },
    fromPartial(v) {
      var d, y;
      const a = R();
      return a.authority = v.authority ?? "", a.sendEnabled = ((d = v.sendEnabled) == null ? void 0 : d.map((_) => r.SendEnabled.fromPartial(_))) || [], a.useDefaultFor = ((y = v.useDefaultFor) == null ? void 0 : y.map((_) => _)) || [], a;
    }
  };
  function p() {
    return {};
  }
  e.MsgSetSendEnabledResponse = {
    typeUrl: "/cosmos.bank.v1beta1.MsgSetSendEnabledResponse",
    encode(v, a = t.BinaryWriter.create()) {
      return a;
    },
    decode(v, a) {
      const d = v instanceof t.BinaryReader ? v : new t.BinaryReader(v);
      let y = a === void 0 ? d.len : d.pos + a;
      const _ = p();
      for (; d.pos < y; ) {
        const E = d.uint32();
        switch (E >>> 3) {
          default:
            d.skipType(E & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(v) {
      return p();
    },
    toJSON(v) {
      return {};
    },
    fromPartial(v) {
      return p();
    }
  };
  class m {
    constructor(a) {
      this.rpc = a, this.Send = this.Send.bind(this), this.MultiSend = this.MultiSend.bind(this), this.UpdateParams = this.UpdateParams.bind(this), this.SetSendEnabled = this.SetSendEnabled.bind(this);
    }
    Send(a) {
      const d = e.MsgSend.encode(a).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Msg", "Send", d).then((_) => e.MsgSendResponse.decode(new t.BinaryReader(_)));
    }
    MultiSend(a) {
      const d = e.MsgMultiSend.encode(a).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Msg", "MultiSend", d).then((_) => e.MsgMultiSendResponse.decode(new t.BinaryReader(_)));
    }
    UpdateParams(a) {
      const d = e.MsgUpdateParams.encode(a).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Msg", "UpdateParams", d).then((_) => e.MsgUpdateParamsResponse.decode(new t.BinaryReader(_)));
    }
    SetSendEnabled(a) {
      const d = e.MsgSetSendEnabled.encode(a).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Msg", "SetSendEnabled", d).then((_) => e.MsgSetSendEnabledResponse.decode(new t.BinaryReader(_)));
    }
  }
  e.MsgClientImpl = m;
})(_c);
Object.defineProperty(An, "__esModule", { value: !0 });
An.Registry = An.isTxBodyEncodeObject = An.isPbjsGeneratedType = An.isTsProtoGeneratedType = An.isTelescopeGeneratedType = void 0;
const fk = _c, pk = De, Ld = Qt, hk = Pe;
function Np(e) {
  const n = e;
  return typeof n.fromPartial == "function" && typeof n.typeUrl == "string";
}
An.isTelescopeGeneratedType = Np;
function Uc(e) {
  return typeof e.fromPartial == "function";
}
An.isTsProtoGeneratedType = Uc;
function yk(e) {
  return !Uc(e);
}
An.isPbjsGeneratedType = yk;
const ql = {
  cosmosCoin: "/cosmos.base.v1beta1.Coin",
  cosmosMsgSend: "/cosmos.bank.v1beta1.MsgSend",
  cosmosTxBody: "/cosmos.tx.v1beta1.TxBody",
  googleAny: "/google.protobuf.Any"
};
function _p(e) {
  return e.typeUrl === "/cosmos.tx.v1beta1.TxBody";
}
An.isTxBodyEncodeObject = _p;
class mk {
  /**
   * Creates a new Registry for mapping protobuf type identifiers/type URLs to
   * actual implementations. Those implementations are typically generated with ts-proto
   * but we also support protobuf.js as a type generator.
   *
   * If there is no parameter given, a `new Registry()` adds the types `Coin` and `MsgSend`
   * for historic reasons. Those can be overriden by customTypes.
   *
   * There are currently two methods for adding new types:
   * 1. Passing types to the constructor.
   * 2. Using the `register()` method
   */
  constructor(n) {
    const { cosmosCoin: r, cosmosMsgSend: t } = ql;
    this.types = n ? new Map([...n]) : /* @__PURE__ */ new Map([
      [r, pk.Coin],
      [t, fk.MsgSend]
    ]);
  }
  register(n, r) {
    this.types.set(n, r);
  }
  /**
   * Looks up a type that was previously added to the registry.
   *
   * The generator information (ts-proto or pbjs) gets lost along the way.
   * If you need to work with the result type in TypeScript, you can use:
   *
   * ```
   * import { assert } from "@cosmjs/utils";
   *
   * const Coin = registry.lookupType("/cosmos.base.v1beta1.Coin");
   * assert(Coin); // Ensures not unset
   * assert(isTsProtoGeneratedType(Coin)); // Ensures this is the type we expect
   *
   * // Coin is typed TsProtoGeneratedType now.
   * ```
   */
  lookupType(n) {
    return this.types.get(n);
  }
  lookupTypeWithError(n) {
    const r = this.lookupType(n);
    if (!r)
      throw new Error(`Unregistered type url: ${n}`);
    return r;
  }
  /**
   * Takes a typeUrl/value pair and encodes the value to protobuf if
   * the given type was previously registered.
   *
   * If the value has to be wrapped in an Any, this needs to be done
   * manually after this call. Or use `encodeAsAny` instead.
   */
  encode(n) {
    const { value: r, typeUrl: t } = n;
    if (_p(n))
      return this.encodeTxBody(r);
    const i = this.lookupTypeWithError(t), f = Np(i) || Uc(i) ? i.fromPartial(r) : i.create(r);
    return i.encode(f).finish();
  }
  /**
   * Takes a typeUrl/value pair and encodes the value to an Any if
   * the given type was previously registered.
   */
  encodeAsAny(n) {
    const r = this.encode(n);
    return hk.Any.fromPartial({
      typeUrl: n.typeUrl,
      value: r
    });
  }
  encodeTxBody(n) {
    var i;
    const r = n.messages.map((f) => this.encodeAsAny(f)), t = Ld.TxBody.fromPartial({
      ...n,
      timeoutHeight: BigInt(((i = n.timeoutHeight) == null ? void 0 : i.toString()) ?? "0"),
      messages: r
    });
    return Ld.TxBody.encode(t).finish();
  }
  decode({ typeUrl: n, value: r }) {
    if (n === ql.cosmosTxBody)
      return this.decodeTxBody(r);
    const i = this.lookupTypeWithError(n).decode(r);
    return Object.entries(i).forEach(([f, S]) => {
      typeof jt < "u" && typeof jt.isBuffer < "u" && jt.isBuffer(S) && (i[f] = Uint8Array.from(S));
    }), i;
  }
  decodeTxBody(n) {
    const r = Ld.TxBody.decode(n);
    return {
      ...r,
      messages: r.messages.map(({ typeUrl: t, value: i }) => {
        if (!t)
          throw new Error("Missing type_url in Any");
        if (!i)
          throw new Error("Missing value in Any");
        return this.decode({ typeUrl: t, value: i });
      })
    };
  }
}
An.Registry = mk;
var es = {};
Object.defineProperty(es, "__esModule", { value: !0 });
es.isOfflineDirectSigner = void 0;
function gk(e) {
  return e.signDirect !== void 0;
}
es.isOfflineDirectSigner = gk;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.parseCoins = e.coins = e.coin = e.executeKdf = e.makeSignDoc = e.makeSignBytes = e.makeAuthInfoBytes = e.isOfflineDirectSigner = e.Registry = e.isTxBodyEncodeObject = e.isTsProtoGeneratedType = e.isPbjsGeneratedType = e.encodePubkey = e.decodePubkey = e.decodeOptionalPubkey = e.anyToSinglePubkey = e.makeCosmoshubPath = e.DirectSecp256k1Wallet = e.extractKdfConfiguration = e.DirectSecp256k1HdWallet = e.decodeTxRaw = void 0;
  var n = $a;
  Object.defineProperty(e, "decodeTxRaw", { enumerable: !0, get: function() {
    return n.decodeTxRaw;
  } });
  var r = Vr;
  Object.defineProperty(e, "DirectSecp256k1HdWallet", { enumerable: !0, get: function() {
    return r.DirectSecp256k1HdWallet;
  } }), Object.defineProperty(e, "extractKdfConfiguration", { enumerable: !0, get: function() {
    return r.extractKdfConfiguration;
  } });
  var t = Xa;
  Object.defineProperty(e, "DirectSecp256k1Wallet", { enumerable: !0, get: function() {
    return t.DirectSecp256k1Wallet;
  } });
  var i = ja;
  Object.defineProperty(e, "makeCosmoshubPath", { enumerable: !0, get: function() {
    return i.makeCosmoshubPath;
  } });
  var f = et;
  Object.defineProperty(e, "anyToSinglePubkey", { enumerable: !0, get: function() {
    return f.anyToSinglePubkey;
  } }), Object.defineProperty(e, "decodeOptionalPubkey", { enumerable: !0, get: function() {
    return f.decodeOptionalPubkey;
  } }), Object.defineProperty(e, "decodePubkey", { enumerable: !0, get: function() {
    return f.decodePubkey;
  } }), Object.defineProperty(e, "encodePubkey", { enumerable: !0, get: function() {
    return f.encodePubkey;
  } });
  var S = An;
  Object.defineProperty(e, "isPbjsGeneratedType", { enumerable: !0, get: function() {
    return S.isPbjsGeneratedType;
  } }), Object.defineProperty(e, "isTsProtoGeneratedType", { enumerable: !0, get: function() {
    return S.isTsProtoGeneratedType;
  } }), Object.defineProperty(e, "isTxBodyEncodeObject", { enumerable: !0, get: function() {
    return S.isTxBodyEncodeObject;
  } }), Object.defineProperty(e, "Registry", { enumerable: !0, get: function() {
    return S.Registry;
  } });
  var w = es;
  Object.defineProperty(e, "isOfflineDirectSigner", { enumerable: !0, get: function() {
    return w.isOfflineDirectSigner;
  } });
  var T = st;
  Object.defineProperty(e, "makeAuthInfoBytes", { enumerable: !0, get: function() {
    return T.makeAuthInfoBytes;
  } }), Object.defineProperty(e, "makeSignBytes", { enumerable: !0, get: function() {
    return T.makeSignBytes;
  } }), Object.defineProperty(e, "makeSignDoc", { enumerable: !0, get: function() {
    return T.makeSignDoc;
  } });
  var J = Cc;
  Object.defineProperty(e, "executeKdf", { enumerable: !0, get: function() {
    return J.executeKdf;
  } });
  var C = Po;
  Object.defineProperty(e, "coin", { enumerable: !0, get: function() {
    return C.coin;
  } }), Object.defineProperty(e, "coins", { enumerable: !0, get: function() {
    return C.coins;
  } }), Object.defineProperty(e, "parseCoins", { enumerable: !0, get: function() {
    return C.parseCoins;
  } });
})(Ft);
var ns = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Params = e.ModuleCredential = e.ModuleAccount = e.BaseAccount = e.protobufPackage = void 0;
  const n = Pe, r = re, t = ie;
  e.protobufPackage = "cosmos.auth.v1beta1";
  function i() {
    return {
      address: "",
      pubKey: void 0,
      accountNumber: BigInt(0),
      sequence: BigInt(0)
    };
  }
  e.BaseAccount = {
    typeUrl: "/cosmos.auth.v1beta1.BaseAccount",
    encode(T, J = r.BinaryWriter.create()) {
      return T.address !== "" && J.uint32(10).string(T.address), T.pubKey !== void 0 && n.Any.encode(T.pubKey, J.uint32(18).fork()).ldelim(), T.accountNumber !== BigInt(0) && J.uint32(24).uint64(T.accountNumber), T.sequence !== BigInt(0) && J.uint32(32).uint64(T.sequence), J;
    },
    decode(T, J) {
      const C = T instanceof r.BinaryReader ? T : new r.BinaryReader(T);
      let R = J === void 0 ? C.len : C.pos + J;
      const p = i();
      for (; C.pos < R; ) {
        const m = C.uint32();
        switch (m >>> 3) {
          case 1:
            p.address = C.string();
            break;
          case 2:
            p.pubKey = n.Any.decode(C, C.uint32());
            break;
          case 3:
            p.accountNumber = C.uint64();
            break;
          case 4:
            p.sequence = C.uint64();
            break;
          default:
            C.skipType(m & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(T) {
      const J = i();
      return (0, t.isSet)(T.address) && (J.address = String(T.address)), (0, t.isSet)(T.pubKey) && (J.pubKey = n.Any.fromJSON(T.pubKey)), (0, t.isSet)(T.accountNumber) && (J.accountNumber = BigInt(T.accountNumber.toString())), (0, t.isSet)(T.sequence) && (J.sequence = BigInt(T.sequence.toString())), J;
    },
    toJSON(T) {
      const J = {};
      return T.address !== void 0 && (J.address = T.address), T.pubKey !== void 0 && (J.pubKey = T.pubKey ? n.Any.toJSON(T.pubKey) : void 0), T.accountNumber !== void 0 && (J.accountNumber = (T.accountNumber || BigInt(0)).toString()), T.sequence !== void 0 && (J.sequence = (T.sequence || BigInt(0)).toString()), J;
    },
    fromPartial(T) {
      const J = i();
      return J.address = T.address ?? "", T.pubKey !== void 0 && T.pubKey !== null && (J.pubKey = n.Any.fromPartial(T.pubKey)), T.accountNumber !== void 0 && T.accountNumber !== null && (J.accountNumber = BigInt(T.accountNumber.toString())), T.sequence !== void 0 && T.sequence !== null && (J.sequence = BigInt(T.sequence.toString())), J;
    }
  };
  function f() {
    return {
      baseAccount: void 0,
      name: "",
      permissions: []
    };
  }
  e.ModuleAccount = {
    typeUrl: "/cosmos.auth.v1beta1.ModuleAccount",
    encode(T, J = r.BinaryWriter.create()) {
      T.baseAccount !== void 0 && e.BaseAccount.encode(T.baseAccount, J.uint32(10).fork()).ldelim(), T.name !== "" && J.uint32(18).string(T.name);
      for (const C of T.permissions)
        J.uint32(26).string(C);
      return J;
    },
    decode(T, J) {
      const C = T instanceof r.BinaryReader ? T : new r.BinaryReader(T);
      let R = J === void 0 ? C.len : C.pos + J;
      const p = f();
      for (; C.pos < R; ) {
        const m = C.uint32();
        switch (m >>> 3) {
          case 1:
            p.baseAccount = e.BaseAccount.decode(C, C.uint32());
            break;
          case 2:
            p.name = C.string();
            break;
          case 3:
            p.permissions.push(C.string());
            break;
          default:
            C.skipType(m & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(T) {
      const J = f();
      return (0, t.isSet)(T.baseAccount) && (J.baseAccount = e.BaseAccount.fromJSON(T.baseAccount)), (0, t.isSet)(T.name) && (J.name = String(T.name)), Array.isArray(T == null ? void 0 : T.permissions) && (J.permissions = T.permissions.map((C) => String(C))), J;
    },
    toJSON(T) {
      const J = {};
      return T.baseAccount !== void 0 && (J.baseAccount = T.baseAccount ? e.BaseAccount.toJSON(T.baseAccount) : void 0), T.name !== void 0 && (J.name = T.name), T.permissions ? J.permissions = T.permissions.map((C) => C) : J.permissions = [], J;
    },
    fromPartial(T) {
      var C;
      const J = f();
      return T.baseAccount !== void 0 && T.baseAccount !== null && (J.baseAccount = e.BaseAccount.fromPartial(T.baseAccount)), J.name = T.name ?? "", J.permissions = ((C = T.permissions) == null ? void 0 : C.map((R) => R)) || [], J;
    }
  };
  function S() {
    return {
      moduleName: "",
      derivationKeys: []
    };
  }
  e.ModuleCredential = {
    typeUrl: "/cosmos.auth.v1beta1.ModuleCredential",
    encode(T, J = r.BinaryWriter.create()) {
      T.moduleName !== "" && J.uint32(10).string(T.moduleName);
      for (const C of T.derivationKeys)
        J.uint32(18).bytes(C);
      return J;
    },
    decode(T, J) {
      const C = T instanceof r.BinaryReader ? T : new r.BinaryReader(T);
      let R = J === void 0 ? C.len : C.pos + J;
      const p = S();
      for (; C.pos < R; ) {
        const m = C.uint32();
        switch (m >>> 3) {
          case 1:
            p.moduleName = C.string();
            break;
          case 2:
            p.derivationKeys.push(C.bytes());
            break;
          default:
            C.skipType(m & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(T) {
      const J = S();
      return (0, t.isSet)(T.moduleName) && (J.moduleName = String(T.moduleName)), Array.isArray(T == null ? void 0 : T.derivationKeys) && (J.derivationKeys = T.derivationKeys.map((C) => (0, t.bytesFromBase64)(C))), J;
    },
    toJSON(T) {
      const J = {};
      return T.moduleName !== void 0 && (J.moduleName = T.moduleName), T.derivationKeys ? J.derivationKeys = T.derivationKeys.map((C) => (0, t.base64FromBytes)(C !== void 0 ? C : new Uint8Array())) : J.derivationKeys = [], J;
    },
    fromPartial(T) {
      var C;
      const J = S();
      return J.moduleName = T.moduleName ?? "", J.derivationKeys = ((C = T.derivationKeys) == null ? void 0 : C.map((R) => R)) || [], J;
    }
  };
  function w() {
    return {
      maxMemoCharacters: BigInt(0),
      txSigLimit: BigInt(0),
      txSizeCostPerByte: BigInt(0),
      sigVerifyCostEd25519: BigInt(0),
      sigVerifyCostSecp256k1: BigInt(0)
    };
  }
  e.Params = {
    typeUrl: "/cosmos.auth.v1beta1.Params",
    encode(T, J = r.BinaryWriter.create()) {
      return T.maxMemoCharacters !== BigInt(0) && J.uint32(8).uint64(T.maxMemoCharacters), T.txSigLimit !== BigInt(0) && J.uint32(16).uint64(T.txSigLimit), T.txSizeCostPerByte !== BigInt(0) && J.uint32(24).uint64(T.txSizeCostPerByte), T.sigVerifyCostEd25519 !== BigInt(0) && J.uint32(32).uint64(T.sigVerifyCostEd25519), T.sigVerifyCostSecp256k1 !== BigInt(0) && J.uint32(40).uint64(T.sigVerifyCostSecp256k1), J;
    },
    decode(T, J) {
      const C = T instanceof r.BinaryReader ? T : new r.BinaryReader(T);
      let R = J === void 0 ? C.len : C.pos + J;
      const p = w();
      for (; C.pos < R; ) {
        const m = C.uint32();
        switch (m >>> 3) {
          case 1:
            p.maxMemoCharacters = C.uint64();
            break;
          case 2:
            p.txSigLimit = C.uint64();
            break;
          case 3:
            p.txSizeCostPerByte = C.uint64();
            break;
          case 4:
            p.sigVerifyCostEd25519 = C.uint64();
            break;
          case 5:
            p.sigVerifyCostSecp256k1 = C.uint64();
            break;
          default:
            C.skipType(m & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(T) {
      const J = w();
      return (0, t.isSet)(T.maxMemoCharacters) && (J.maxMemoCharacters = BigInt(T.maxMemoCharacters.toString())), (0, t.isSet)(T.txSigLimit) && (J.txSigLimit = BigInt(T.txSigLimit.toString())), (0, t.isSet)(T.txSizeCostPerByte) && (J.txSizeCostPerByte = BigInt(T.txSizeCostPerByte.toString())), (0, t.isSet)(T.sigVerifyCostEd25519) && (J.sigVerifyCostEd25519 = BigInt(T.sigVerifyCostEd25519.toString())), (0, t.isSet)(T.sigVerifyCostSecp256k1) && (J.sigVerifyCostSecp256k1 = BigInt(T.sigVerifyCostSecp256k1.toString())), J;
    },
    toJSON(T) {
      const J = {};
      return T.maxMemoCharacters !== void 0 && (J.maxMemoCharacters = (T.maxMemoCharacters || BigInt(0)).toString()), T.txSigLimit !== void 0 && (J.txSigLimit = (T.txSigLimit || BigInt(0)).toString()), T.txSizeCostPerByte !== void 0 && (J.txSizeCostPerByte = (T.txSizeCostPerByte || BigInt(0)).toString()), T.sigVerifyCostEd25519 !== void 0 && (J.sigVerifyCostEd25519 = (T.sigVerifyCostEd25519 || BigInt(0)).toString()), T.sigVerifyCostSecp256k1 !== void 0 && (J.sigVerifyCostSecp256k1 = (T.sigVerifyCostSecp256k1 || BigInt(0)).toString()), J;
    },
    fromPartial(T) {
      const J = w();
      return T.maxMemoCharacters !== void 0 && T.maxMemoCharacters !== null && (J.maxMemoCharacters = BigInt(T.maxMemoCharacters.toString())), T.txSigLimit !== void 0 && T.txSigLimit !== null && (J.txSigLimit = BigInt(T.txSigLimit.toString())), T.txSizeCostPerByte !== void 0 && T.txSizeCostPerByte !== null && (J.txSizeCostPerByte = BigInt(T.txSizeCostPerByte.toString())), T.sigVerifyCostEd25519 !== void 0 && T.sigVerifyCostEd25519 !== null && (J.sigVerifyCostEd25519 = BigInt(T.sigVerifyCostEd25519.toString())), T.sigVerifyCostSecp256k1 !== void 0 && T.sigVerifyCostSecp256k1 !== null && (J.sigVerifyCostSecp256k1 = BigInt(T.sigVerifyCostSecp256k1.toString())), J;
    }
  };
})(ns);
var Jc = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.PermanentLockedAccount = e.PeriodicVestingAccount = e.Period = e.DelayedVestingAccount = e.ContinuousVestingAccount = e.BaseVestingAccount = e.protobufPackage = void 0;
  const n = ns, r = De, t = re, i = ie;
  e.protobufPackage = "cosmos.vesting.v1beta1";
  function f() {
    return {
      baseAccount: void 0,
      originalVesting: [],
      delegatedFree: [],
      delegatedVesting: [],
      endTime: BigInt(0)
    };
  }
  e.BaseVestingAccount = {
    typeUrl: "/cosmos.vesting.v1beta1.BaseVestingAccount",
    encode(R, p = t.BinaryWriter.create()) {
      R.baseAccount !== void 0 && n.BaseAccount.encode(R.baseAccount, p.uint32(10).fork()).ldelim();
      for (const m of R.originalVesting)
        r.Coin.encode(m, p.uint32(18).fork()).ldelim();
      for (const m of R.delegatedFree)
        r.Coin.encode(m, p.uint32(26).fork()).ldelim();
      for (const m of R.delegatedVesting)
        r.Coin.encode(m, p.uint32(34).fork()).ldelim();
      return R.endTime !== BigInt(0) && p.uint32(40).int64(R.endTime), p;
    },
    decode(R, p) {
      const m = R instanceof t.BinaryReader ? R : new t.BinaryReader(R);
      let v = p === void 0 ? m.len : m.pos + p;
      const a = f();
      for (; m.pos < v; ) {
        const d = m.uint32();
        switch (d >>> 3) {
          case 1:
            a.baseAccount = n.BaseAccount.decode(m, m.uint32());
            break;
          case 2:
            a.originalVesting.push(r.Coin.decode(m, m.uint32()));
            break;
          case 3:
            a.delegatedFree.push(r.Coin.decode(m, m.uint32()));
            break;
          case 4:
            a.delegatedVesting.push(r.Coin.decode(m, m.uint32()));
            break;
          case 5:
            a.endTime = m.int64();
            break;
          default:
            m.skipType(d & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(R) {
      const p = f();
      return (0, i.isSet)(R.baseAccount) && (p.baseAccount = n.BaseAccount.fromJSON(R.baseAccount)), Array.isArray(R == null ? void 0 : R.originalVesting) && (p.originalVesting = R.originalVesting.map((m) => r.Coin.fromJSON(m))), Array.isArray(R == null ? void 0 : R.delegatedFree) && (p.delegatedFree = R.delegatedFree.map((m) => r.Coin.fromJSON(m))), Array.isArray(R == null ? void 0 : R.delegatedVesting) && (p.delegatedVesting = R.delegatedVesting.map((m) => r.Coin.fromJSON(m))), (0, i.isSet)(R.endTime) && (p.endTime = BigInt(R.endTime.toString())), p;
    },
    toJSON(R) {
      const p = {};
      return R.baseAccount !== void 0 && (p.baseAccount = R.baseAccount ? n.BaseAccount.toJSON(R.baseAccount) : void 0), R.originalVesting ? p.originalVesting = R.originalVesting.map((m) => m ? r.Coin.toJSON(m) : void 0) : p.originalVesting = [], R.delegatedFree ? p.delegatedFree = R.delegatedFree.map((m) => m ? r.Coin.toJSON(m) : void 0) : p.delegatedFree = [], R.delegatedVesting ? p.delegatedVesting = R.delegatedVesting.map((m) => m ? r.Coin.toJSON(m) : void 0) : p.delegatedVesting = [], R.endTime !== void 0 && (p.endTime = (R.endTime || BigInt(0)).toString()), p;
    },
    fromPartial(R) {
      var m, v, a;
      const p = f();
      return R.baseAccount !== void 0 && R.baseAccount !== null && (p.baseAccount = n.BaseAccount.fromPartial(R.baseAccount)), p.originalVesting = ((m = R.originalVesting) == null ? void 0 : m.map((d) => r.Coin.fromPartial(d))) || [], p.delegatedFree = ((v = R.delegatedFree) == null ? void 0 : v.map((d) => r.Coin.fromPartial(d))) || [], p.delegatedVesting = ((a = R.delegatedVesting) == null ? void 0 : a.map((d) => r.Coin.fromPartial(d))) || [], R.endTime !== void 0 && R.endTime !== null && (p.endTime = BigInt(R.endTime.toString())), p;
    }
  };
  function S() {
    return {
      baseVestingAccount: void 0,
      startTime: BigInt(0)
    };
  }
  e.ContinuousVestingAccount = {
    typeUrl: "/cosmos.vesting.v1beta1.ContinuousVestingAccount",
    encode(R, p = t.BinaryWriter.create()) {
      return R.baseVestingAccount !== void 0 && e.BaseVestingAccount.encode(R.baseVestingAccount, p.uint32(10).fork()).ldelim(), R.startTime !== BigInt(0) && p.uint32(16).int64(R.startTime), p;
    },
    decode(R, p) {
      const m = R instanceof t.BinaryReader ? R : new t.BinaryReader(R);
      let v = p === void 0 ? m.len : m.pos + p;
      const a = S();
      for (; m.pos < v; ) {
        const d = m.uint32();
        switch (d >>> 3) {
          case 1:
            a.baseVestingAccount = e.BaseVestingAccount.decode(m, m.uint32());
            break;
          case 2:
            a.startTime = m.int64();
            break;
          default:
            m.skipType(d & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(R) {
      const p = S();
      return (0, i.isSet)(R.baseVestingAccount) && (p.baseVestingAccount = e.BaseVestingAccount.fromJSON(R.baseVestingAccount)), (0, i.isSet)(R.startTime) && (p.startTime = BigInt(R.startTime.toString())), p;
    },
    toJSON(R) {
      const p = {};
      return R.baseVestingAccount !== void 0 && (p.baseVestingAccount = R.baseVestingAccount ? e.BaseVestingAccount.toJSON(R.baseVestingAccount) : void 0), R.startTime !== void 0 && (p.startTime = (R.startTime || BigInt(0)).toString()), p;
    },
    fromPartial(R) {
      const p = S();
      return R.baseVestingAccount !== void 0 && R.baseVestingAccount !== null && (p.baseVestingAccount = e.BaseVestingAccount.fromPartial(R.baseVestingAccount)), R.startTime !== void 0 && R.startTime !== null && (p.startTime = BigInt(R.startTime.toString())), p;
    }
  };
  function w() {
    return {
      baseVestingAccount: void 0
    };
  }
  e.DelayedVestingAccount = {
    typeUrl: "/cosmos.vesting.v1beta1.DelayedVestingAccount",
    encode(R, p = t.BinaryWriter.create()) {
      return R.baseVestingAccount !== void 0 && e.BaseVestingAccount.encode(R.baseVestingAccount, p.uint32(10).fork()).ldelim(), p;
    },
    decode(R, p) {
      const m = R instanceof t.BinaryReader ? R : new t.BinaryReader(R);
      let v = p === void 0 ? m.len : m.pos + p;
      const a = w();
      for (; m.pos < v; ) {
        const d = m.uint32();
        switch (d >>> 3) {
          case 1:
            a.baseVestingAccount = e.BaseVestingAccount.decode(m, m.uint32());
            break;
          default:
            m.skipType(d & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(R) {
      const p = w();
      return (0, i.isSet)(R.baseVestingAccount) && (p.baseVestingAccount = e.BaseVestingAccount.fromJSON(R.baseVestingAccount)), p;
    },
    toJSON(R) {
      const p = {};
      return R.baseVestingAccount !== void 0 && (p.baseVestingAccount = R.baseVestingAccount ? e.BaseVestingAccount.toJSON(R.baseVestingAccount) : void 0), p;
    },
    fromPartial(R) {
      const p = w();
      return R.baseVestingAccount !== void 0 && R.baseVestingAccount !== null && (p.baseVestingAccount = e.BaseVestingAccount.fromPartial(R.baseVestingAccount)), p;
    }
  };
  function T() {
    return {
      length: BigInt(0),
      amount: []
    };
  }
  e.Period = {
    typeUrl: "/cosmos.vesting.v1beta1.Period",
    encode(R, p = t.BinaryWriter.create()) {
      R.length !== BigInt(0) && p.uint32(8).int64(R.length);
      for (const m of R.amount)
        r.Coin.encode(m, p.uint32(18).fork()).ldelim();
      return p;
    },
    decode(R, p) {
      const m = R instanceof t.BinaryReader ? R : new t.BinaryReader(R);
      let v = p === void 0 ? m.len : m.pos + p;
      const a = T();
      for (; m.pos < v; ) {
        const d = m.uint32();
        switch (d >>> 3) {
          case 1:
            a.length = m.int64();
            break;
          case 2:
            a.amount.push(r.Coin.decode(m, m.uint32()));
            break;
          default:
            m.skipType(d & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(R) {
      const p = T();
      return (0, i.isSet)(R.length) && (p.length = BigInt(R.length.toString())), Array.isArray(R == null ? void 0 : R.amount) && (p.amount = R.amount.map((m) => r.Coin.fromJSON(m))), p;
    },
    toJSON(R) {
      const p = {};
      return R.length !== void 0 && (p.length = (R.length || BigInt(0)).toString()), R.amount ? p.amount = R.amount.map((m) => m ? r.Coin.toJSON(m) : void 0) : p.amount = [], p;
    },
    fromPartial(R) {
      var m;
      const p = T();
      return R.length !== void 0 && R.length !== null && (p.length = BigInt(R.length.toString())), p.amount = ((m = R.amount) == null ? void 0 : m.map((v) => r.Coin.fromPartial(v))) || [], p;
    }
  };
  function J() {
    return {
      baseVestingAccount: void 0,
      startTime: BigInt(0),
      vestingPeriods: []
    };
  }
  e.PeriodicVestingAccount = {
    typeUrl: "/cosmos.vesting.v1beta1.PeriodicVestingAccount",
    encode(R, p = t.BinaryWriter.create()) {
      R.baseVestingAccount !== void 0 && e.BaseVestingAccount.encode(R.baseVestingAccount, p.uint32(10).fork()).ldelim(), R.startTime !== BigInt(0) && p.uint32(16).int64(R.startTime);
      for (const m of R.vestingPeriods)
        e.Period.encode(m, p.uint32(26).fork()).ldelim();
      return p;
    },
    decode(R, p) {
      const m = R instanceof t.BinaryReader ? R : new t.BinaryReader(R);
      let v = p === void 0 ? m.len : m.pos + p;
      const a = J();
      for (; m.pos < v; ) {
        const d = m.uint32();
        switch (d >>> 3) {
          case 1:
            a.baseVestingAccount = e.BaseVestingAccount.decode(m, m.uint32());
            break;
          case 2:
            a.startTime = m.int64();
            break;
          case 3:
            a.vestingPeriods.push(e.Period.decode(m, m.uint32()));
            break;
          default:
            m.skipType(d & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(R) {
      const p = J();
      return (0, i.isSet)(R.baseVestingAccount) && (p.baseVestingAccount = e.BaseVestingAccount.fromJSON(R.baseVestingAccount)), (0, i.isSet)(R.startTime) && (p.startTime = BigInt(R.startTime.toString())), Array.isArray(R == null ? void 0 : R.vestingPeriods) && (p.vestingPeriods = R.vestingPeriods.map((m) => e.Period.fromJSON(m))), p;
    },
    toJSON(R) {
      const p = {};
      return R.baseVestingAccount !== void 0 && (p.baseVestingAccount = R.baseVestingAccount ? e.BaseVestingAccount.toJSON(R.baseVestingAccount) : void 0), R.startTime !== void 0 && (p.startTime = (R.startTime || BigInt(0)).toString()), R.vestingPeriods ? p.vestingPeriods = R.vestingPeriods.map((m) => m ? e.Period.toJSON(m) : void 0) : p.vestingPeriods = [], p;
    },
    fromPartial(R) {
      var m;
      const p = J();
      return R.baseVestingAccount !== void 0 && R.baseVestingAccount !== null && (p.baseVestingAccount = e.BaseVestingAccount.fromPartial(R.baseVestingAccount)), R.startTime !== void 0 && R.startTime !== null && (p.startTime = BigInt(R.startTime.toString())), p.vestingPeriods = ((m = R.vestingPeriods) == null ? void 0 : m.map((v) => e.Period.fromPartial(v))) || [], p;
    }
  };
  function C() {
    return {
      baseVestingAccount: void 0
    };
  }
  e.PermanentLockedAccount = {
    typeUrl: "/cosmos.vesting.v1beta1.PermanentLockedAccount",
    encode(R, p = t.BinaryWriter.create()) {
      return R.baseVestingAccount !== void 0 && e.BaseVestingAccount.encode(R.baseVestingAccount, p.uint32(10).fork()).ldelim(), p;
    },
    decode(R, p) {
      const m = R instanceof t.BinaryReader ? R : new t.BinaryReader(R);
      let v = p === void 0 ? m.len : m.pos + p;
      const a = C();
      for (; m.pos < v; ) {
        const d = m.uint32();
        switch (d >>> 3) {
          case 1:
            a.baseVestingAccount = e.BaseVestingAccount.decode(m, m.uint32());
            break;
          default:
            m.skipType(d & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(R) {
      const p = C();
      return (0, i.isSet)(R.baseVestingAccount) && (p.baseVestingAccount = e.BaseVestingAccount.fromJSON(R.baseVestingAccount)), p;
    },
    toJSON(R) {
      const p = {};
      return R.baseVestingAccount !== void 0 && (p.baseVestingAccount = R.baseVestingAccount ? e.BaseVestingAccount.toJSON(R.baseVestingAccount) : void 0), p;
    },
    fromPartial(R) {
      const p = C();
      return R.baseVestingAccount !== void 0 && R.baseVestingAccount !== null && (p.baseVestingAccount = e.BaseVestingAccount.fromPartial(R.baseVestingAccount)), p;
    }
  };
})(Jc);
Object.defineProperty(ko, "__esModule", { value: !0 });
ko.accountFromAny = void 0;
const Sk = Ie, kk = Ft, Ki = Te, Vl = ns, Fo = Jc;
function Wl(e) {
  return Sk.Uint64.fromString(e.toString());
}
function fr(e) {
  const { address: n, pubKey: r, accountNumber: t, sequence: i } = e, f = (0, kk.decodeOptionalPubkey)(r);
  return {
    address: n,
    pubkey: f,
    accountNumber: Wl(t).toNumber(),
    sequence: Wl(i).toNumber()
  };
}
function Pk(e) {
  var t, i, f, S, w, T, J;
  const { typeUrl: n, value: r } = e;
  switch (n) {
    case "/cosmos.auth.v1beta1.BaseAccount":
      return fr(Vl.BaseAccount.decode(r));
    case "/cosmos.auth.v1beta1.ModuleAccount": {
      const C = Vl.ModuleAccount.decode(r).baseAccount;
      return (0, Ki.assert)(C), fr(C);
    }
    case "/cosmos.vesting.v1beta1.BaseVestingAccount": {
      const C = (t = Fo.BaseVestingAccount.decode(r)) == null ? void 0 : t.baseAccount;
      return (0, Ki.assert)(C), fr(C);
    }
    case "/cosmos.vesting.v1beta1.ContinuousVestingAccount": {
      const C = (f = (i = Fo.ContinuousVestingAccount.decode(r)) == null ? void 0 : i.baseVestingAccount) == null ? void 0 : f.baseAccount;
      return (0, Ki.assert)(C), fr(C);
    }
    case "/cosmos.vesting.v1beta1.DelayedVestingAccount": {
      const C = (w = (S = Fo.DelayedVestingAccount.decode(r)) == null ? void 0 : S.baseVestingAccount) == null ? void 0 : w.baseAccount;
      return (0, Ki.assert)(C), fr(C);
    }
    case "/cosmos.vesting.v1beta1.PeriodicVestingAccount": {
      const C = (J = (T = Fo.PeriodicVestingAccount.decode(r)) == null ? void 0 : T.baseVestingAccount) == null ? void 0 : J.baseAccount;
      return (0, Ki.assert)(C), fr(C);
    }
    default:
      throw new Error(`Unsupported type: '${n}'`);
  }
}
ko.accountFromAny = Pk;
var Bo = {};
Object.defineProperty(Bo, "__esModule", { value: !0 });
Bo.AminoTypes = void 0;
class vk {
  constructor(n) {
    this.register = n;
  }
  toAmino({ typeUrl: n, value: r }) {
    const t = this.register[n];
    if (!t)
      throw new Error(`Type URL '${n}' does not exist in the Amino message type register. If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.`);
    return {
      type: t.aminoType,
      value: t.toAmino(r)
    };
  }
  fromAmino({ type: n, value: r }) {
    const t = Object.entries(this.register).filter(([i, { aminoType: f }]) => f === n);
    switch (t.length) {
      case 0:
        throw new Error(`Amino type identifier '${n}' does not exist in the Amino message type register. If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.`);
      case 1: {
        const [i, f] = t[0];
        return {
          typeUrl: i,
          value: f.fromAmino(r)
        };
      }
      default:
        throw new Error(`Multiple types are registered with Amino type identifier '${n}': '` + t.map(([i, f]) => i).sort().join("', '") + "'. Thus fromAmino cannot be performed.");
    }
  }
}
Bo.AminoTypes = vk;
var Oo = {}, Ke = {}, ii = {};
Object.defineProperty(ii, "__esModule", { value: !0 });
ii.fromAscii = ii.toAscii = void 0;
function bk(e) {
  const n = (r) => r.split("").map((t) => {
    const i = t.charCodeAt(0);
    if (i < 32 || i > 126)
      throw new Error("Cannot encode character that is out of printable ASCII range: " + i);
    return i;
  });
  return Uint8Array.from(n(e));
}
ii.toAscii = bk;
function Rk(e) {
  return ((r) => r.map((t) => {
    if (t < 32 || t > 126)
      throw new Error("Cannot decode character that is out of printable ASCII range: " + t);
    return String.fromCharCode(t);
  }))(Array.from(e)).join("");
}
ii.fromAscii = Rk;
var oi = {}, Bk = x && x.__createBinding || (Object.create ? function(e, n, r, t) {
  t === void 0 && (t = r);
  var i = Object.getOwnPropertyDescriptor(n, r);
  (!i || ("get" in i ? !n.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return n[r];
  } }), Object.defineProperty(e, t, i);
} : function(e, n, r, t) {
  t === void 0 && (t = r), e[t] = n[r];
}), Ok = x && x.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), Ak = x && x.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var n = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && Bk(n, e, r);
  return Ok(n, e), n;
};
Object.defineProperty(oi, "__esModule", { value: !0 });
oi.fromBase64 = oi.toBase64 = void 0;
const Ep = Ak(Va);
function Ik(e) {
  return Ep.fromByteArray(e);
}
oi.toBase64 = Ik;
function Tk(e) {
  if (!e.match(/^[a-zA-Z0-9+/]*={0,2}$/))
    throw new Error("Invalid base64 string format");
  return Ep.toByteArray(e);
}
oi.fromBase64 = Tk;
var Tt = {}, wk = x && x.__createBinding || (Object.create ? function(e, n, r, t) {
  t === void 0 && (t = r);
  var i = Object.getOwnPropertyDescriptor(n, r);
  (!i || ("get" in i ? !n.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return n[r];
  } }), Object.defineProperty(e, t, i);
} : function(e, n, r, t) {
  t === void 0 && (t = r), e[t] = n[r];
}), Ck = x && x.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), Nk = x && x.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var n = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && wk(n, e, r);
  return Ck(n, e), n;
};
Object.defineProperty(Tt, "__esModule", { value: !0 });
Tt.normalizeBech32 = Tt.fromBech32 = Tt.toBech32 = void 0;
const Ra = Nk(Wa);
function Up(e, n, r) {
  return Ra.encode(e, Ra.toWords(n), r);
}
Tt.toBech32 = Up;
function Jp(e, n = 1 / 0) {
  const r = Ra.decode(e, n);
  return {
    prefix: r.prefix,
    data: new Uint8Array(Ra.fromWords(r.words))
  };
}
Tt.fromBech32 = Jp;
function _k(e) {
  const { prefix: n, data: r } = Jp(e);
  return Up(n, r);
}
Tt.normalizeBech32 = _k;
var ai = {};
Object.defineProperty(ai, "__esModule", { value: !0 });
ai.fromHex = ai.toHex = void 0;
function Ek(e) {
  let n = "";
  for (const r of e)
    n += ("0" + r.toString(16)).slice(-2);
  return n;
}
ai.toHex = Ek;
function Uk(e) {
  if (e.length % 2 !== 0)
    throw new Error("hex string length must be a multiple of 2");
  const n = new Uint8Array(e.length / 2);
  for (let r = 0; r < n.length; r++) {
    const t = 2 * r, i = e.slice(t, t + 2);
    if (!i.match(/[0-9a-f]{2}/i))
      throw new Error("hex string contains invalid characters");
    n[r] = parseInt(i, 16);
  }
  return n;
}
ai.fromHex = Uk;
var si = {};
Object.defineProperty(si, "__esModule", { value: !0 });
si.toRfc3339 = si.fromRfc3339 = void 0;
const Jk = /^(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(\.\d{1,9})?((?:[+-]\d{2}:\d{2})|Z)$/;
function pr(e, n = 2) {
  return e.toString().padStart(n, "0");
}
function Dk(e) {
  const n = Jk.exec(e);
  if (!n)
    throw new Error("Date string is not in RFC3339 format");
  const r = +n[1], t = +n[2], i = +n[3], f = +n[4], S = +n[5], w = +n[6], T = n[7] ? Math.floor(+n[7] * 1e3) : 0;
  let J, C, R;
  n[8] === "Z" ? (J = 1, C = 0, R = 0) : (J = n[8].substring(0, 1) === "-" ? -1 : 1, C = +n[8].substring(1, 3), R = +n[8].substring(4, 6));
  const p = J * (C * 60 + R) * 60, m = /* @__PURE__ */ new Date();
  return m.setUTCFullYear(r, t - 1, i), m.setUTCHours(f, S, w, T), new Date(m.getTime() - p * 1e3);
}
si.fromRfc3339 = Dk;
function Mk(e) {
  const n = e.getUTCFullYear(), r = pr(e.getUTCMonth() + 1), t = pr(e.getUTCDate()), i = pr(e.getUTCHours()), f = pr(e.getUTCMinutes()), S = pr(e.getUTCSeconds()), w = pr(e.getUTCMilliseconds(), 3);
  return `${n}-${r}-${t}T${i}:${f}:${S}.${w}Z`;
}
si.toRfc3339 = Mk;
var di = {};
Object.defineProperty(di, "__esModule", { value: !0 });
di.fromUtf8 = di.toUtf8 = void 0;
function Hk(e) {
  return new TextEncoder().encode(e);
}
di.toUtf8 = Hk;
function qk(e, n = !1) {
  const r = !n;
  return new TextDecoder("utf-8", { fatal: r }).decode(e);
}
di.fromUtf8 = qk;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.toUtf8 = e.fromUtf8 = e.toRfc3339 = e.fromRfc3339 = e.toHex = e.fromHex = e.toBech32 = e.normalizeBech32 = e.fromBech32 = e.toBase64 = e.fromBase64 = e.toAscii = e.fromAscii = void 0;
  var n = ii;
  Object.defineProperty(e, "fromAscii", { enumerable: !0, get: function() {
    return n.fromAscii;
  } }), Object.defineProperty(e, "toAscii", { enumerable: !0, get: function() {
    return n.toAscii;
  } });
  var r = oi;
  Object.defineProperty(e, "fromBase64", { enumerable: !0, get: function() {
    return r.fromBase64;
  } }), Object.defineProperty(e, "toBase64", { enumerable: !0, get: function() {
    return r.toBase64;
  } });
  var t = Tt;
  Object.defineProperty(e, "fromBech32", { enumerable: !0, get: function() {
    return t.fromBech32;
  } }), Object.defineProperty(e, "normalizeBech32", { enumerable: !0, get: function() {
    return t.normalizeBech32;
  } }), Object.defineProperty(e, "toBech32", { enumerable: !0, get: function() {
    return t.toBech32;
  } });
  var i = ai;
  Object.defineProperty(e, "fromHex", { enumerable: !0, get: function() {
    return i.fromHex;
  } }), Object.defineProperty(e, "toHex", { enumerable: !0, get: function() {
    return i.toHex;
  } });
  var f = si;
  Object.defineProperty(e, "fromRfc3339", { enumerable: !0, get: function() {
    return f.fromRfc3339;
  } }), Object.defineProperty(e, "toRfc3339", { enumerable: !0, get: function() {
    return f.toRfc3339;
  } });
  var S = di;
  Object.defineProperty(e, "fromUtf8", { enumerable: !0, get: function() {
    return S.fromUtf8;
  } }), Object.defineProperty(e, "toUtf8", { enumerable: !0, get: function() {
    return S.toUtf8;
  } });
})(Ke);
Object.defineProperty(Oo, "__esModule", { value: !0 });
Oo.fromTendermintEvent = void 0;
const Ql = Ke;
function Vk(e) {
  return {
    type: e.type,
    attributes: e.attributes.map((n) => ({
      key: typeof n.key == "string" ? n.key : (0, Ql.fromUtf8)(n.key, !0),
      value: typeof n.value == "string" ? n.value : (0, Ql.fromUtf8)(n.value, !0)
    }))
  };
}
Oo.fromTendermintEvent = Vk;
var ir = {};
Object.defineProperty(ir, "__esModule", { value: !0 });
ir.calculateFee = ir.GasPrice = void 0;
const Dp = Ie, Wk = Ft;
function Qk(e) {
  if (e.length < 3 || e.length > 128)
    throw new Error("Denom must be between 3 and 128 characters");
}
class ts {
  constructor(n, r) {
    this.amount = n, this.denom = r;
  }
  /**
   * Parses a gas price formatted as `<amount><denom>`, e.g. `GasPrice.fromString("0.012utoken")`.
   *
   * The denom must match the Cosmos SDK 0.42 pattern (https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/types/coin.go#L599-L601).
   * See `GasPrice` in @cosmjs/stargate for a more generic matcher.
   *
   * Separators are not yet supported.
   */
  static fromString(n) {
    const r = n.match(/^([0-9.]+)([a-zA-Z][a-zA-Z0-9/:._-]*)$/);
    if (!r)
      throw new Error("Invalid gas price string");
    const [t, i, f] = r;
    Qk(f);
    const w = Dp.Decimal.fromUserInput(i, 18);
    return new ts(w, f);
  }
  /**
   * Returns a string representation of this gas price, e.g. "0.025uatom".
   * This can be used as an input to `GasPrice.fromString`.
   */
  toString() {
    return this.amount.toString() + this.denom;
  }
}
ir.GasPrice = ts;
function Fk(e, n) {
  const r = typeof n == "string" ? ts.fromString(n) : n, { denom: t, amount: i } = r, f = i.multiply(new Dp.Uint53(e)).ceil().toString();
  return {
    amount: (0, Wk.coins)(f, t),
    gas: e.toString()
  };
}
ir.calculateFee = Fk;
var an = {};
Object.defineProperty(an, "__esModule", { value: !0 });
an.findAttribute = an.parseRawLog = an.parseLogs = an.parseLog = an.parseEvent = an.parseAttribute = void 0;
const Dc = Te;
function Mp(e) {
  if (!(0, Dc.isNonNullObject)(e))
    throw new Error("Attribute must be a non-null object");
  const { key: n, value: r } = e;
  if (typeof n != "string" || !n)
    throw new Error("Attribute's key must be a non-empty string");
  if (typeof r != "string" && typeof r < "u")
    throw new Error("Attribute's value must be a string or unset");
  return {
    key: n,
    value: r || ""
  };
}
an.parseAttribute = Mp;
function Hp(e) {
  if (!(0, Dc.isNonNullObject)(e))
    throw new Error("Event must be a non-null object");
  const { type: n, attributes: r } = e;
  if (typeof n != "string" || n === "")
    throw new Error("Event type must be a non-empty string");
  if (!Array.isArray(r))
    throw new Error("Event's attributes must be an array");
  return {
    type: n,
    attributes: r.map(Mp)
  };
}
an.parseEvent = Hp;
function qp(e) {
  if (!(0, Dc.isNonNullObject)(e))
    throw new Error("Log must be a non-null object");
  const { msg_index: n, log: r, events: t } = e;
  if (typeof n != "number")
    throw new Error("Log's msg_index must be a number");
  if (typeof r != "string")
    throw new Error("Log's log must be a string");
  if (!Array.isArray(t))
    throw new Error("Log's events must be an array");
  return {
    msg_index: n,
    log: r,
    events: t.map(Hp)
  };
}
an.parseLog = qp;
function Vp(e) {
  if (!Array.isArray(e))
    throw new Error("Logs must be an array");
  return e.map(qp);
}
an.parseLogs = Vp;
function $k(e) {
  if (!e)
    return [];
  const n = JSON.parse(e).map(({ events: r }, t) => ({
    msg_index: t,
    events: r,
    log: ""
  }));
  return Vp(n);
}
an.parseRawLog = $k;
function Lk(e, n, r) {
  var f;
  const t = e.find(() => !0), i = (f = t == null ? void 0 : t.events.find((S) => S.type === n)) == null ? void 0 : f.attributes.find((S) => S.key === r);
  if (!i)
    throw new Error(`Could not find attribute '${r}' in first event of type '${n}' in first log.`);
  return i;
}
an.findAttribute = Lk;
var ho = {}, rs = {}, Wp = {}, Ae = {};
Object.defineProperty(Ae, "__esModule", { value: !0 });
Ae.PageResponse = Ae.PageRequest = Ae.protobufPackage = void 0;
const _r = re, Fn = ie;
Ae.protobufPackage = "cosmos.base.query.v1beta1";
function Gd() {
  return {
    key: new Uint8Array(),
    offset: BigInt(0),
    limit: BigInt(0),
    countTotal: !1,
    reverse: !1
  };
}
Ae.PageRequest = {
  typeUrl: "/cosmos.base.query.v1beta1.PageRequest",
  encode(e, n = _r.BinaryWriter.create()) {
    return e.key.length !== 0 && n.uint32(10).bytes(e.key), e.offset !== BigInt(0) && n.uint32(16).uint64(e.offset), e.limit !== BigInt(0) && n.uint32(24).uint64(e.limit), e.countTotal === !0 && n.uint32(32).bool(e.countTotal), e.reverse === !0 && n.uint32(40).bool(e.reverse), n;
  },
  decode(e, n) {
    const r = e instanceof _r.BinaryReader ? e : new _r.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = Gd();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.key = r.bytes();
          break;
        case 2:
          i.offset = r.uint64();
          break;
        case 3:
          i.limit = r.uint64();
          break;
        case 4:
          i.countTotal = r.bool();
          break;
        case 5:
          i.reverse = r.bool();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = Gd();
    return (0, Fn.isSet)(e.key) && (n.key = (0, Fn.bytesFromBase64)(e.key)), (0, Fn.isSet)(e.offset) && (n.offset = BigInt(e.offset.toString())), (0, Fn.isSet)(e.limit) && (n.limit = BigInt(e.limit.toString())), (0, Fn.isSet)(e.countTotal) && (n.countTotal = !!e.countTotal), (0, Fn.isSet)(e.reverse) && (n.reverse = !!e.reverse), n;
  },
  toJSON(e) {
    const n = {};
    return e.key !== void 0 && (n.key = (0, Fn.base64FromBytes)(e.key !== void 0 ? e.key : new Uint8Array())), e.offset !== void 0 && (n.offset = (e.offset || BigInt(0)).toString()), e.limit !== void 0 && (n.limit = (e.limit || BigInt(0)).toString()), e.countTotal !== void 0 && (n.countTotal = e.countTotal), e.reverse !== void 0 && (n.reverse = e.reverse), n;
  },
  fromPartial(e) {
    const n = Gd();
    return n.key = e.key ?? new Uint8Array(), e.offset !== void 0 && e.offset !== null && (n.offset = BigInt(e.offset.toString())), e.limit !== void 0 && e.limit !== null && (n.limit = BigInt(e.limit.toString())), n.countTotal = e.countTotal ?? !1, n.reverse = e.reverse ?? !1, n;
  }
};
function Kd() {
  return {
    nextKey: new Uint8Array(),
    total: BigInt(0)
  };
}
Ae.PageResponse = {
  typeUrl: "/cosmos.base.query.v1beta1.PageResponse",
  encode(e, n = _r.BinaryWriter.create()) {
    return e.nextKey.length !== 0 && n.uint32(10).bytes(e.nextKey), e.total !== BigInt(0) && n.uint32(16).uint64(e.total), n;
  },
  decode(e, n) {
    const r = e instanceof _r.BinaryReader ? e : new _r.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = Kd();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.nextKey = r.bytes();
          break;
        case 2:
          i.total = r.uint64();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = Kd();
    return (0, Fn.isSet)(e.nextKey) && (n.nextKey = (0, Fn.bytesFromBase64)(e.nextKey)), (0, Fn.isSet)(e.total) && (n.total = BigInt(e.total.toString())), n;
  },
  toJSON(e) {
    const n = {};
    return e.nextKey !== void 0 && (n.nextKey = (0, Fn.base64FromBytes)(e.nextKey !== void 0 ? e.nextKey : new Uint8Array())), e.total !== void 0 && (n.total = (e.total || BigInt(0)).toString()), n;
  },
  fromPartial(e) {
    const n = Kd();
    return n.nextKey = e.nextKey ?? new Uint8Array(), e.total !== void 0 && e.total !== null && (n.total = BigInt(e.total.toString())), n;
  }
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryAccountInfoResponse = e.QueryAccountInfoRequest = e.QueryAccountAddressByIDResponse = e.QueryAccountAddressByIDRequest = e.AddressStringToBytesResponse = e.AddressStringToBytesRequest = e.AddressBytesToStringResponse = e.AddressBytesToStringRequest = e.Bech32PrefixResponse = e.Bech32PrefixRequest = e.QueryModuleAccountByNameResponse = e.QueryModuleAccountByNameRequest = e.QueryModuleAccountsResponse = e.QueryModuleAccountsRequest = e.QueryParamsResponse = e.QueryParamsRequest = e.QueryAccountResponse = e.QueryAccountRequest = e.QueryAccountsResponse = e.QueryAccountsRequest = e.protobufPackage = void 0;
  const n = Ae, r = Pe, t = ns, i = re, f = ie;
  e.protobufPackage = "cosmos.auth.v1beta1";
  function S() {
    return {
      pagination: void 0
    };
  }
  e.QueryAccountsRequest = {
    typeUrl: "/cosmos.auth.v1beta1.QueryAccountsRequest",
    encode(l, I = i.BinaryWriter.create()) {
      return l.pagination !== void 0 && n.PageRequest.encode(l.pagination, I.uint32(10).fork()).ldelim(), I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = S();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.pagination = n.PageRequest.decode(B, B.uint32());
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = S();
      return (0, f.isSet)(l.pagination) && (I.pagination = n.PageRequest.fromJSON(l.pagination)), I;
    },
    toJSON(l) {
      const I = {};
      return l.pagination !== void 0 && (I.pagination = l.pagination ? n.PageRequest.toJSON(l.pagination) : void 0), I;
    },
    fromPartial(l) {
      const I = S();
      return l.pagination !== void 0 && l.pagination !== null && (I.pagination = n.PageRequest.fromPartial(l.pagination)), I;
    }
  };
  function w() {
    return {
      accounts: [],
      pagination: void 0
    };
  }
  e.QueryAccountsResponse = {
    typeUrl: "/cosmos.auth.v1beta1.QueryAccountsResponse",
    encode(l, I = i.BinaryWriter.create()) {
      for (const B of l.accounts)
        r.Any.encode(B, I.uint32(10).fork()).ldelim();
      return l.pagination !== void 0 && n.PageResponse.encode(l.pagination, I.uint32(18).fork()).ldelim(), I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = w();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.accounts.push(r.Any.decode(B, B.uint32()));
            break;
          case 2:
            D.pagination = n.PageResponse.decode(B, B.uint32());
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = w();
      return Array.isArray(l == null ? void 0 : l.accounts) && (I.accounts = l.accounts.map((B) => r.Any.fromJSON(B))), (0, f.isSet)(l.pagination) && (I.pagination = n.PageResponse.fromJSON(l.pagination)), I;
    },
    toJSON(l) {
      const I = {};
      return l.accounts ? I.accounts = l.accounts.map((B) => B ? r.Any.toJSON(B) : void 0) : I.accounts = [], l.pagination !== void 0 && (I.pagination = l.pagination ? n.PageResponse.toJSON(l.pagination) : void 0), I;
    },
    fromPartial(l) {
      var B;
      const I = w();
      return I.accounts = ((B = l.accounts) == null ? void 0 : B.map((b) => r.Any.fromPartial(b))) || [], l.pagination !== void 0 && l.pagination !== null && (I.pagination = n.PageResponse.fromPartial(l.pagination)), I;
    }
  };
  function T() {
    return {
      address: ""
    };
  }
  e.QueryAccountRequest = {
    typeUrl: "/cosmos.auth.v1beta1.QueryAccountRequest",
    encode(l, I = i.BinaryWriter.create()) {
      return l.address !== "" && I.uint32(10).string(l.address), I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = T();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.address = B.string();
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = T();
      return (0, f.isSet)(l.address) && (I.address = String(l.address)), I;
    },
    toJSON(l) {
      const I = {};
      return l.address !== void 0 && (I.address = l.address), I;
    },
    fromPartial(l) {
      const I = T();
      return I.address = l.address ?? "", I;
    }
  };
  function J() {
    return {
      account: void 0
    };
  }
  e.QueryAccountResponse = {
    typeUrl: "/cosmos.auth.v1beta1.QueryAccountResponse",
    encode(l, I = i.BinaryWriter.create()) {
      return l.account !== void 0 && r.Any.encode(l.account, I.uint32(10).fork()).ldelim(), I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = J();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.account = r.Any.decode(B, B.uint32());
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = J();
      return (0, f.isSet)(l.account) && (I.account = r.Any.fromJSON(l.account)), I;
    },
    toJSON(l) {
      const I = {};
      return l.account !== void 0 && (I.account = l.account ? r.Any.toJSON(l.account) : void 0), I;
    },
    fromPartial(l) {
      const I = J();
      return l.account !== void 0 && l.account !== null && (I.account = r.Any.fromPartial(l.account)), I;
    }
  };
  function C() {
    return {};
  }
  e.QueryParamsRequest = {
    typeUrl: "/cosmos.auth.v1beta1.QueryParamsRequest",
    encode(l, I = i.BinaryWriter.create()) {
      return I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = C();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      return C();
    },
    toJSON(l) {
      return {};
    },
    fromPartial(l) {
      return C();
    }
  };
  function R() {
    return {
      params: t.Params.fromPartial({})
    };
  }
  e.QueryParamsResponse = {
    typeUrl: "/cosmos.auth.v1beta1.QueryParamsResponse",
    encode(l, I = i.BinaryWriter.create()) {
      return l.params !== void 0 && t.Params.encode(l.params, I.uint32(10).fork()).ldelim(), I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = R();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.params = t.Params.decode(B, B.uint32());
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = R();
      return (0, f.isSet)(l.params) && (I.params = t.Params.fromJSON(l.params)), I;
    },
    toJSON(l) {
      const I = {};
      return l.params !== void 0 && (I.params = l.params ? t.Params.toJSON(l.params) : void 0), I;
    },
    fromPartial(l) {
      const I = R();
      return l.params !== void 0 && l.params !== null && (I.params = t.Params.fromPartial(l.params)), I;
    }
  };
  function p() {
    return {};
  }
  e.QueryModuleAccountsRequest = {
    typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountsRequest",
    encode(l, I = i.BinaryWriter.create()) {
      return I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = p();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      return p();
    },
    toJSON(l) {
      return {};
    },
    fromPartial(l) {
      return p();
    }
  };
  function m() {
    return {
      accounts: []
    };
  }
  e.QueryModuleAccountsResponse = {
    typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountsResponse",
    encode(l, I = i.BinaryWriter.create()) {
      for (const B of l.accounts)
        r.Any.encode(B, I.uint32(10).fork()).ldelim();
      return I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = m();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.accounts.push(r.Any.decode(B, B.uint32()));
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = m();
      return Array.isArray(l == null ? void 0 : l.accounts) && (I.accounts = l.accounts.map((B) => r.Any.fromJSON(B))), I;
    },
    toJSON(l) {
      const I = {};
      return l.accounts ? I.accounts = l.accounts.map((B) => B ? r.Any.toJSON(B) : void 0) : I.accounts = [], I;
    },
    fromPartial(l) {
      var B;
      const I = m();
      return I.accounts = ((B = l.accounts) == null ? void 0 : B.map((b) => r.Any.fromPartial(b))) || [], I;
    }
  };
  function v() {
    return {
      name: ""
    };
  }
  e.QueryModuleAccountByNameRequest = {
    typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountByNameRequest",
    encode(l, I = i.BinaryWriter.create()) {
      return l.name !== "" && I.uint32(10).string(l.name), I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = v();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.name = B.string();
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = v();
      return (0, f.isSet)(l.name) && (I.name = String(l.name)), I;
    },
    toJSON(l) {
      const I = {};
      return l.name !== void 0 && (I.name = l.name), I;
    },
    fromPartial(l) {
      const I = v();
      return I.name = l.name ?? "", I;
    }
  };
  function a() {
    return {
      account: void 0
    };
  }
  e.QueryModuleAccountByNameResponse = {
    typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountByNameResponse",
    encode(l, I = i.BinaryWriter.create()) {
      return l.account !== void 0 && r.Any.encode(l.account, I.uint32(10).fork()).ldelim(), I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = a();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.account = r.Any.decode(B, B.uint32());
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = a();
      return (0, f.isSet)(l.account) && (I.account = r.Any.fromJSON(l.account)), I;
    },
    toJSON(l) {
      const I = {};
      return l.account !== void 0 && (I.account = l.account ? r.Any.toJSON(l.account) : void 0), I;
    },
    fromPartial(l) {
      const I = a();
      return l.account !== void 0 && l.account !== null && (I.account = r.Any.fromPartial(l.account)), I;
    }
  };
  function d() {
    return {};
  }
  e.Bech32PrefixRequest = {
    typeUrl: "/cosmos.auth.v1beta1.Bech32PrefixRequest",
    encode(l, I = i.BinaryWriter.create()) {
      return I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = d();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      return d();
    },
    toJSON(l) {
      return {};
    },
    fromPartial(l) {
      return d();
    }
  };
  function y() {
    return {
      bech32Prefix: ""
    };
  }
  e.Bech32PrefixResponse = {
    typeUrl: "/cosmos.auth.v1beta1.Bech32PrefixResponse",
    encode(l, I = i.BinaryWriter.create()) {
      return l.bech32Prefix !== "" && I.uint32(10).string(l.bech32Prefix), I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = y();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.bech32Prefix = B.string();
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = y();
      return (0, f.isSet)(l.bech32Prefix) && (I.bech32Prefix = String(l.bech32Prefix)), I;
    },
    toJSON(l) {
      const I = {};
      return l.bech32Prefix !== void 0 && (I.bech32Prefix = l.bech32Prefix), I;
    },
    fromPartial(l) {
      const I = y();
      return I.bech32Prefix = l.bech32Prefix ?? "", I;
    }
  };
  function _() {
    return {
      addressBytes: new Uint8Array()
    };
  }
  e.AddressBytesToStringRequest = {
    typeUrl: "/cosmos.auth.v1beta1.AddressBytesToStringRequest",
    encode(l, I = i.BinaryWriter.create()) {
      return l.addressBytes.length !== 0 && I.uint32(10).bytes(l.addressBytes), I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = _();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.addressBytes = B.bytes();
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = _();
      return (0, f.isSet)(l.addressBytes) && (I.addressBytes = (0, f.bytesFromBase64)(l.addressBytes)), I;
    },
    toJSON(l) {
      const I = {};
      return l.addressBytes !== void 0 && (I.addressBytes = (0, f.base64FromBytes)(l.addressBytes !== void 0 ? l.addressBytes : new Uint8Array())), I;
    },
    fromPartial(l) {
      const I = _();
      return I.addressBytes = l.addressBytes ?? new Uint8Array(), I;
    }
  };
  function E() {
    return {
      addressString: ""
    };
  }
  e.AddressBytesToStringResponse = {
    typeUrl: "/cosmos.auth.v1beta1.AddressBytesToStringResponse",
    encode(l, I = i.BinaryWriter.create()) {
      return l.addressString !== "" && I.uint32(10).string(l.addressString), I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = E();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.addressString = B.string();
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = E();
      return (0, f.isSet)(l.addressString) && (I.addressString = String(l.addressString)), I;
    },
    toJSON(l) {
      const I = {};
      return l.addressString !== void 0 && (I.addressString = l.addressString), I;
    },
    fromPartial(l) {
      const I = E();
      return I.addressString = l.addressString ?? "", I;
    }
  };
  function U() {
    return {
      addressString: ""
    };
  }
  e.AddressStringToBytesRequest = {
    typeUrl: "/cosmos.auth.v1beta1.AddressStringToBytesRequest",
    encode(l, I = i.BinaryWriter.create()) {
      return l.addressString !== "" && I.uint32(10).string(l.addressString), I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = U();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.addressString = B.string();
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = U();
      return (0, f.isSet)(l.addressString) && (I.addressString = String(l.addressString)), I;
    },
    toJSON(l) {
      const I = {};
      return l.addressString !== void 0 && (I.addressString = l.addressString), I;
    },
    fromPartial(l) {
      const I = U();
      return I.addressString = l.addressString ?? "", I;
    }
  };
  function V() {
    return {
      addressBytes: new Uint8Array()
    };
  }
  e.AddressStringToBytesResponse = {
    typeUrl: "/cosmos.auth.v1beta1.AddressStringToBytesResponse",
    encode(l, I = i.BinaryWriter.create()) {
      return l.addressBytes.length !== 0 && I.uint32(10).bytes(l.addressBytes), I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = V();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.addressBytes = B.bytes();
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = V();
      return (0, f.isSet)(l.addressBytes) && (I.addressBytes = (0, f.bytesFromBase64)(l.addressBytes)), I;
    },
    toJSON(l) {
      const I = {};
      return l.addressBytes !== void 0 && (I.addressBytes = (0, f.base64FromBytes)(l.addressBytes !== void 0 ? l.addressBytes : new Uint8Array())), I;
    },
    fromPartial(l) {
      const I = V();
      return I.addressBytes = l.addressBytes ?? new Uint8Array(), I;
    }
  };
  function o() {
    return {
      id: BigInt(0),
      accountId: BigInt(0)
    };
  }
  e.QueryAccountAddressByIDRequest = {
    typeUrl: "/cosmos.auth.v1beta1.QueryAccountAddressByIDRequest",
    encode(l, I = i.BinaryWriter.create()) {
      return l.id !== BigInt(0) && I.uint32(8).int64(l.id), l.accountId !== BigInt(0) && I.uint32(16).uint64(l.accountId), I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = o();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.id = B.int64();
            break;
          case 2:
            D.accountId = B.uint64();
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = o();
      return (0, f.isSet)(l.id) && (I.id = BigInt(l.id.toString())), (0, f.isSet)(l.accountId) && (I.accountId = BigInt(l.accountId.toString())), I;
    },
    toJSON(l) {
      const I = {};
      return l.id !== void 0 && (I.id = (l.id || BigInt(0)).toString()), l.accountId !== void 0 && (I.accountId = (l.accountId || BigInt(0)).toString()), I;
    },
    fromPartial(l) {
      const I = o();
      return l.id !== void 0 && l.id !== null && (I.id = BigInt(l.id.toString())), l.accountId !== void 0 && l.accountId !== null && (I.accountId = BigInt(l.accountId.toString())), I;
    }
  };
  function h() {
    return {
      accountAddress: ""
    };
  }
  e.QueryAccountAddressByIDResponse = {
    typeUrl: "/cosmos.auth.v1beta1.QueryAccountAddressByIDResponse",
    encode(l, I = i.BinaryWriter.create()) {
      return l.accountAddress !== "" && I.uint32(10).string(l.accountAddress), I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = h();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.accountAddress = B.string();
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = h();
      return (0, f.isSet)(l.accountAddress) && (I.accountAddress = String(l.accountAddress)), I;
    },
    toJSON(l) {
      const I = {};
      return l.accountAddress !== void 0 && (I.accountAddress = l.accountAddress), I;
    },
    fromPartial(l) {
      const I = h();
      return I.accountAddress = l.accountAddress ?? "", I;
    }
  };
  function N() {
    return {
      address: ""
    };
  }
  e.QueryAccountInfoRequest = {
    typeUrl: "/cosmos.auth.v1beta1.QueryAccountInfoRequest",
    encode(l, I = i.BinaryWriter.create()) {
      return l.address !== "" && I.uint32(10).string(l.address), I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = N();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.address = B.string();
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = N();
      return (0, f.isSet)(l.address) && (I.address = String(l.address)), I;
    },
    toJSON(l) {
      const I = {};
      return l.address !== void 0 && (I.address = l.address), I;
    },
    fromPartial(l) {
      const I = N();
      return I.address = l.address ?? "", I;
    }
  };
  function q() {
    return {
      info: void 0
    };
  }
  e.QueryAccountInfoResponse = {
    typeUrl: "/cosmos.auth.v1beta1.QueryAccountInfoResponse",
    encode(l, I = i.BinaryWriter.create()) {
      return l.info !== void 0 && t.BaseAccount.encode(l.info, I.uint32(10).fork()).ldelim(), I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = q();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.info = t.BaseAccount.decode(B, B.uint32());
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = q();
      return (0, f.isSet)(l.info) && (I.info = t.BaseAccount.fromJSON(l.info)), I;
    },
    toJSON(l) {
      const I = {};
      return l.info !== void 0 && (I.info = l.info ? t.BaseAccount.toJSON(l.info) : void 0), I;
    },
    fromPartial(l) {
      const I = q();
      return l.info !== void 0 && l.info !== null && (I.info = t.BaseAccount.fromPartial(l.info)), I;
    }
  };
  class u {
    constructor(I) {
      this.rpc = I, this.Accounts = this.Accounts.bind(this), this.Account = this.Account.bind(this), this.AccountAddressByID = this.AccountAddressByID.bind(this), this.Params = this.Params.bind(this), this.ModuleAccounts = this.ModuleAccounts.bind(this), this.ModuleAccountByName = this.ModuleAccountByName.bind(this), this.Bech32Prefix = this.Bech32Prefix.bind(this), this.AddressBytesToString = this.AddressBytesToString.bind(this), this.AddressStringToBytes = this.AddressStringToBytes.bind(this), this.AccountInfo = this.AccountInfo.bind(this);
    }
    Accounts(I = {
      pagination: n.PageRequest.fromPartial({})
    }) {
      const B = e.QueryAccountsRequest.encode(I).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "Accounts", B).then((D) => e.QueryAccountsResponse.decode(new i.BinaryReader(D)));
    }
    Account(I) {
      const B = e.QueryAccountRequest.encode(I).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "Account", B).then((D) => e.QueryAccountResponse.decode(new i.BinaryReader(D)));
    }
    AccountAddressByID(I) {
      const B = e.QueryAccountAddressByIDRequest.encode(I).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "AccountAddressByID", B).then((D) => e.QueryAccountAddressByIDResponse.decode(new i.BinaryReader(D)));
    }
    Params(I = {}) {
      const B = e.QueryParamsRequest.encode(I).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "Params", B).then((D) => e.QueryParamsResponse.decode(new i.BinaryReader(D)));
    }
    ModuleAccounts(I = {}) {
      const B = e.QueryModuleAccountsRequest.encode(I).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "ModuleAccounts", B).then((D) => e.QueryModuleAccountsResponse.decode(new i.BinaryReader(D)));
    }
    ModuleAccountByName(I) {
      const B = e.QueryModuleAccountByNameRequest.encode(I).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "ModuleAccountByName", B).then((D) => e.QueryModuleAccountByNameResponse.decode(new i.BinaryReader(D)));
    }
    Bech32Prefix(I = {}) {
      const B = e.Bech32PrefixRequest.encode(I).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "Bech32Prefix", B).then((D) => e.Bech32PrefixResponse.decode(new i.BinaryReader(D)));
    }
    AddressBytesToString(I) {
      const B = e.AddressBytesToStringRequest.encode(I).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "AddressBytesToString", B).then((D) => e.AddressBytesToStringResponse.decode(new i.BinaryReader(D)));
    }
    AddressStringToBytes(I) {
      const B = e.AddressStringToBytesRequest.encode(I).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "AddressStringToBytes", B).then((D) => e.AddressStringToBytesResponse.decode(new i.BinaryReader(D)));
    }
    AccountInfo(I) {
      const B = e.QueryAccountInfoRequest.encode(I).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "AccountInfo", B).then((D) => e.QueryAccountInfoResponse.decode(new i.BinaryReader(D)));
    }
  }
  e.QueryClientImpl = u;
})(Wp);
var Ye = {}, is = {}, Qp = {}, Ee = Nm, oe = Ee.Reader, pn = Ee.Writer, te = Ee.util, G = Ee.roots.default || (Ee.roots.default = {});
G.ics23 = function() {
  var e = {};
  return e.HashOp = function() {
    var n = {}, r = Object.create(n);
    return r[n[0] = "NO_HASH"] = 0, r[n[1] = "SHA256"] = 1, r[n[2] = "SHA512"] = 2, r[n[3] = "KECCAK"] = 3, r[n[4] = "RIPEMD160"] = 4, r[n[5] = "BITCOIN"] = 5, r[n[6] = "SHA512_256"] = 6, r;
  }(), e.LengthOp = function() {
    var n = {}, r = Object.create(n);
    return r[n[0] = "NO_PREFIX"] = 0, r[n[1] = "VAR_PROTO"] = 1, r[n[2] = "VAR_RLP"] = 2, r[n[3] = "FIXED32_BIG"] = 3, r[n[4] = "FIXED32_LITTLE"] = 4, r[n[5] = "FIXED64_BIG"] = 5, r[n[6] = "FIXED64_LITTLE"] = 6, r[n[7] = "REQUIRE_32_BYTES"] = 7, r[n[8] = "REQUIRE_64_BYTES"] = 8, r;
  }(), e.ExistenceProof = function() {
    function n(r) {
      if (this.path = [], r)
        for (var t = Object.keys(r), i = 0; i < t.length; ++i)
          r[t[i]] != null && (this[t[i]] = r[t[i]]);
    }
    return n.prototype.key = te.newBuffer([]), n.prototype.value = te.newBuffer([]), n.prototype.leaf = null, n.prototype.path = te.emptyArray, n.create = function(t) {
      return new n(t);
    }, n.encode = function(t, i) {
      if (i || (i = pn.create()), t.key != null && t.hasOwnProperty("key") && i.uint32(
        /* id 1, wireType 2 =*/
        10
      ).bytes(t.key), t.value != null && t.hasOwnProperty("value") && i.uint32(
        /* id 2, wireType 2 =*/
        18
      ).bytes(t.value), t.leaf != null && t.hasOwnProperty("leaf") && G.ics23.LeafOp.encode(t.leaf, i.uint32(
        /* id 3, wireType 2 =*/
        26
      ).fork()).ldelim(), t.path != null && t.path.length)
        for (var f = 0; f < t.path.length; ++f)
          G.ics23.InnerOp.encode(t.path[f], i.uint32(
            /* id 4, wireType 2 =*/
            34
          ).fork()).ldelim();
      return i;
    }, n.encodeDelimited = function(t, i) {
      return this.encode(t, i).ldelim();
    }, n.decode = function(t, i) {
      t instanceof oe || (t = oe.create(t));
      for (var f = i === void 0 ? t.len : t.pos + i, S = new G.ics23.ExistenceProof(); t.pos < f; ) {
        var w = t.uint32();
        switch (w >>> 3) {
          case 1:
            S.key = t.bytes();
            break;
          case 2:
            S.value = t.bytes();
            break;
          case 3:
            S.leaf = G.ics23.LeafOp.decode(t, t.uint32());
            break;
          case 4:
            S.path && S.path.length || (S.path = []), S.path.push(G.ics23.InnerOp.decode(t, t.uint32()));
            break;
          default:
            t.skipType(w & 7);
            break;
        }
      }
      return S;
    }, n.decodeDelimited = function(t) {
      return t instanceof oe || (t = new oe(t)), this.decode(t, t.uint32());
    }, n.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.key != null && t.hasOwnProperty("key") && !(t.key && typeof t.key.length == "number" || te.isString(t.key)))
        return "key: buffer expected";
      if (t.value != null && t.hasOwnProperty("value") && !(t.value && typeof t.value.length == "number" || te.isString(t.value)))
        return "value: buffer expected";
      if (t.leaf != null && t.hasOwnProperty("leaf")) {
        var i = G.ics23.LeafOp.verify(t.leaf);
        if (i)
          return "leaf." + i;
      }
      if (t.path != null && t.hasOwnProperty("path")) {
        if (!Array.isArray(t.path))
          return "path: array expected";
        for (var f = 0; f < t.path.length; ++f) {
          var i = G.ics23.InnerOp.verify(t.path[f]);
          if (i)
            return "path." + i;
        }
      }
      return null;
    }, n.fromObject = function(t) {
      if (t instanceof G.ics23.ExistenceProof)
        return t;
      var i = new G.ics23.ExistenceProof();
      if (t.key != null && (typeof t.key == "string" ? te.base64.decode(t.key, i.key = te.newBuffer(te.base64.length(t.key)), 0) : t.key.length && (i.key = t.key)), t.value != null && (typeof t.value == "string" ? te.base64.decode(t.value, i.value = te.newBuffer(te.base64.length(t.value)), 0) : t.value.length && (i.value = t.value)), t.leaf != null) {
        if (typeof t.leaf != "object")
          throw TypeError(".ics23.ExistenceProof.leaf: object expected");
        i.leaf = G.ics23.LeafOp.fromObject(t.leaf);
      }
      if (t.path) {
        if (!Array.isArray(t.path))
          throw TypeError(".ics23.ExistenceProof.path: array expected");
        i.path = [];
        for (var f = 0; f < t.path.length; ++f) {
          if (typeof t.path[f] != "object")
            throw TypeError(".ics23.ExistenceProof.path: object expected");
          i.path[f] = G.ics23.InnerOp.fromObject(t.path[f]);
        }
      }
      return i;
    }, n.toObject = function(t, i) {
      i || (i = {});
      var f = {};
      if ((i.arrays || i.defaults) && (f.path = []), i.defaults && (i.bytes === String ? f.key = "" : (f.key = [], i.bytes !== Array && (f.key = te.newBuffer(f.key))), i.bytes === String ? f.value = "" : (f.value = [], i.bytes !== Array && (f.value = te.newBuffer(f.value))), f.leaf = null), t.key != null && t.hasOwnProperty("key") && (f.key = i.bytes === String ? te.base64.encode(t.key, 0, t.key.length) : i.bytes === Array ? Array.prototype.slice.call(t.key) : t.key), t.value != null && t.hasOwnProperty("value") && (f.value = i.bytes === String ? te.base64.encode(t.value, 0, t.value.length) : i.bytes === Array ? Array.prototype.slice.call(t.value) : t.value), t.leaf != null && t.hasOwnProperty("leaf") && (f.leaf = G.ics23.LeafOp.toObject(t.leaf, i)), t.path && t.path.length) {
        f.path = [];
        for (var S = 0; S < t.path.length; ++S)
          f.path[S] = G.ics23.InnerOp.toObject(t.path[S], i);
      }
      return f;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, Ee.util.toJSONOptions);
    }, n;
  }(), e.NonExistenceProof = function() {
    function n(r) {
      if (r)
        for (var t = Object.keys(r), i = 0; i < t.length; ++i)
          r[t[i]] != null && (this[t[i]] = r[t[i]]);
    }
    return n.prototype.key = te.newBuffer([]), n.prototype.left = null, n.prototype.right = null, n.create = function(t) {
      return new n(t);
    }, n.encode = function(t, i) {
      return i || (i = pn.create()), t.key != null && t.hasOwnProperty("key") && i.uint32(
        /* id 1, wireType 2 =*/
        10
      ).bytes(t.key), t.left != null && t.hasOwnProperty("left") && G.ics23.ExistenceProof.encode(t.left, i.uint32(
        /* id 2, wireType 2 =*/
        18
      ).fork()).ldelim(), t.right != null && t.hasOwnProperty("right") && G.ics23.ExistenceProof.encode(t.right, i.uint32(
        /* id 3, wireType 2 =*/
        26
      ).fork()).ldelim(), i;
    }, n.encodeDelimited = function(t, i) {
      return this.encode(t, i).ldelim();
    }, n.decode = function(t, i) {
      t instanceof oe || (t = oe.create(t));
      for (var f = i === void 0 ? t.len : t.pos + i, S = new G.ics23.NonExistenceProof(); t.pos < f; ) {
        var w = t.uint32();
        switch (w >>> 3) {
          case 1:
            S.key = t.bytes();
            break;
          case 2:
            S.left = G.ics23.ExistenceProof.decode(t, t.uint32());
            break;
          case 3:
            S.right = G.ics23.ExistenceProof.decode(t, t.uint32());
            break;
          default:
            t.skipType(w & 7);
            break;
        }
      }
      return S;
    }, n.decodeDelimited = function(t) {
      return t instanceof oe || (t = new oe(t)), this.decode(t, t.uint32());
    }, n.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.key != null && t.hasOwnProperty("key") && !(t.key && typeof t.key.length == "number" || te.isString(t.key)))
        return "key: buffer expected";
      if (t.left != null && t.hasOwnProperty("left")) {
        var i = G.ics23.ExistenceProof.verify(t.left);
        if (i)
          return "left." + i;
      }
      if (t.right != null && t.hasOwnProperty("right")) {
        var i = G.ics23.ExistenceProof.verify(t.right);
        if (i)
          return "right." + i;
      }
      return null;
    }, n.fromObject = function(t) {
      if (t instanceof G.ics23.NonExistenceProof)
        return t;
      var i = new G.ics23.NonExistenceProof();
      if (t.key != null && (typeof t.key == "string" ? te.base64.decode(t.key, i.key = te.newBuffer(te.base64.length(t.key)), 0) : t.key.length && (i.key = t.key)), t.left != null) {
        if (typeof t.left != "object")
          throw TypeError(".ics23.NonExistenceProof.left: object expected");
        i.left = G.ics23.ExistenceProof.fromObject(t.left);
      }
      if (t.right != null) {
        if (typeof t.right != "object")
          throw TypeError(".ics23.NonExistenceProof.right: object expected");
        i.right = G.ics23.ExistenceProof.fromObject(t.right);
      }
      return i;
    }, n.toObject = function(t, i) {
      i || (i = {});
      var f = {};
      return i.defaults && (i.bytes === String ? f.key = "" : (f.key = [], i.bytes !== Array && (f.key = te.newBuffer(f.key))), f.left = null, f.right = null), t.key != null && t.hasOwnProperty("key") && (f.key = i.bytes === String ? te.base64.encode(t.key, 0, t.key.length) : i.bytes === Array ? Array.prototype.slice.call(t.key) : t.key), t.left != null && t.hasOwnProperty("left") && (f.left = G.ics23.ExistenceProof.toObject(t.left, i)), t.right != null && t.hasOwnProperty("right") && (f.right = G.ics23.ExistenceProof.toObject(t.right, i)), f;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, Ee.util.toJSONOptions);
    }, n;
  }(), e.CommitmentProof = function() {
    function n(t) {
      if (t)
        for (var i = Object.keys(t), f = 0; f < i.length; ++f)
          t[i[f]] != null && (this[i[f]] = t[i[f]]);
    }
    n.prototype.exist = null, n.prototype.nonexist = null, n.prototype.batch = null, n.prototype.compressed = null;
    var r;
    return Object.defineProperty(n.prototype, "proof", {
      get: te.oneOfGetter(r = ["exist", "nonexist", "batch", "compressed"]),
      set: te.oneOfSetter(r)
    }), n.create = function(i) {
      return new n(i);
    }, n.encode = function(i, f) {
      return f || (f = pn.create()), i.exist != null && i.hasOwnProperty("exist") && G.ics23.ExistenceProof.encode(i.exist, f.uint32(
        /* id 1, wireType 2 =*/
        10
      ).fork()).ldelim(), i.nonexist != null && i.hasOwnProperty("nonexist") && G.ics23.NonExistenceProof.encode(i.nonexist, f.uint32(
        /* id 2, wireType 2 =*/
        18
      ).fork()).ldelim(), i.batch != null && i.hasOwnProperty("batch") && G.ics23.BatchProof.encode(i.batch, f.uint32(
        /* id 3, wireType 2 =*/
        26
      ).fork()).ldelim(), i.compressed != null && i.hasOwnProperty("compressed") && G.ics23.CompressedBatchProof.encode(i.compressed, f.uint32(
        /* id 4, wireType 2 =*/
        34
      ).fork()).ldelim(), f;
    }, n.encodeDelimited = function(i, f) {
      return this.encode(i, f).ldelim();
    }, n.decode = function(i, f) {
      i instanceof oe || (i = oe.create(i));
      for (var S = f === void 0 ? i.len : i.pos + f, w = new G.ics23.CommitmentProof(); i.pos < S; ) {
        var T = i.uint32();
        switch (T >>> 3) {
          case 1:
            w.exist = G.ics23.ExistenceProof.decode(i, i.uint32());
            break;
          case 2:
            w.nonexist = G.ics23.NonExistenceProof.decode(i, i.uint32());
            break;
          case 3:
            w.batch = G.ics23.BatchProof.decode(i, i.uint32());
            break;
          case 4:
            w.compressed = G.ics23.CompressedBatchProof.decode(i, i.uint32());
            break;
          default:
            i.skipType(T & 7);
            break;
        }
      }
      return w;
    }, n.decodeDelimited = function(i) {
      return i instanceof oe || (i = new oe(i)), this.decode(i, i.uint32());
    }, n.verify = function(i) {
      if (typeof i != "object" || i === null)
        return "object expected";
      var f = {};
      if (i.exist != null && i.hasOwnProperty("exist")) {
        f.proof = 1;
        {
          var S = G.ics23.ExistenceProof.verify(i.exist);
          if (S)
            return "exist." + S;
        }
      }
      if (i.nonexist != null && i.hasOwnProperty("nonexist")) {
        if (f.proof === 1)
          return "proof: multiple values";
        f.proof = 1;
        {
          var S = G.ics23.NonExistenceProof.verify(i.nonexist);
          if (S)
            return "nonexist." + S;
        }
      }
      if (i.batch != null && i.hasOwnProperty("batch")) {
        if (f.proof === 1)
          return "proof: multiple values";
        f.proof = 1;
        {
          var S = G.ics23.BatchProof.verify(i.batch);
          if (S)
            return "batch." + S;
        }
      }
      if (i.compressed != null && i.hasOwnProperty("compressed")) {
        if (f.proof === 1)
          return "proof: multiple values";
        f.proof = 1;
        {
          var S = G.ics23.CompressedBatchProof.verify(i.compressed);
          if (S)
            return "compressed." + S;
        }
      }
      return null;
    }, n.fromObject = function(i) {
      if (i instanceof G.ics23.CommitmentProof)
        return i;
      var f = new G.ics23.CommitmentProof();
      if (i.exist != null) {
        if (typeof i.exist != "object")
          throw TypeError(".ics23.CommitmentProof.exist: object expected");
        f.exist = G.ics23.ExistenceProof.fromObject(i.exist);
      }
      if (i.nonexist != null) {
        if (typeof i.nonexist != "object")
          throw TypeError(".ics23.CommitmentProof.nonexist: object expected");
        f.nonexist = G.ics23.NonExistenceProof.fromObject(i.nonexist);
      }
      if (i.batch != null) {
        if (typeof i.batch != "object")
          throw TypeError(".ics23.CommitmentProof.batch: object expected");
        f.batch = G.ics23.BatchProof.fromObject(i.batch);
      }
      if (i.compressed != null) {
        if (typeof i.compressed != "object")
          throw TypeError(".ics23.CommitmentProof.compressed: object expected");
        f.compressed = G.ics23.CompressedBatchProof.fromObject(i.compressed);
      }
      return f;
    }, n.toObject = function(i, f) {
      f || (f = {});
      var S = {};
      return i.exist != null && i.hasOwnProperty("exist") && (S.exist = G.ics23.ExistenceProof.toObject(i.exist, f), f.oneofs && (S.proof = "exist")), i.nonexist != null && i.hasOwnProperty("nonexist") && (S.nonexist = G.ics23.NonExistenceProof.toObject(i.nonexist, f), f.oneofs && (S.proof = "nonexist")), i.batch != null && i.hasOwnProperty("batch") && (S.batch = G.ics23.BatchProof.toObject(i.batch, f), f.oneofs && (S.proof = "batch")), i.compressed != null && i.hasOwnProperty("compressed") && (S.compressed = G.ics23.CompressedBatchProof.toObject(i.compressed, f), f.oneofs && (S.proof = "compressed")), S;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, Ee.util.toJSONOptions);
    }, n;
  }(), e.LeafOp = function() {
    function n(r) {
      if (r)
        for (var t = Object.keys(r), i = 0; i < t.length; ++i)
          r[t[i]] != null && (this[t[i]] = r[t[i]]);
    }
    return n.prototype.hash = 0, n.prototype.prehashKey = 0, n.prototype.prehashValue = 0, n.prototype.length = 0, n.prototype.prefix = te.newBuffer([]), n.create = function(t) {
      return new n(t);
    }, n.encode = function(t, i) {
      return i || (i = pn.create()), t.hash != null && t.hasOwnProperty("hash") && i.uint32(
        /* id 1, wireType 0 =*/
        8
      ).int32(t.hash), t.prehashKey != null && t.hasOwnProperty("prehashKey") && i.uint32(
        /* id 2, wireType 0 =*/
        16
      ).int32(t.prehashKey), t.prehashValue != null && t.hasOwnProperty("prehashValue") && i.uint32(
        /* id 3, wireType 0 =*/
        24
      ).int32(t.prehashValue), t.length != null && t.hasOwnProperty("length") && i.uint32(
        /* id 4, wireType 0 =*/
        32
      ).int32(t.length), t.prefix != null && t.hasOwnProperty("prefix") && i.uint32(
        /* id 5, wireType 2 =*/
        42
      ).bytes(t.prefix), i;
    }, n.encodeDelimited = function(t, i) {
      return this.encode(t, i).ldelim();
    }, n.decode = function(t, i) {
      t instanceof oe || (t = oe.create(t));
      for (var f = i === void 0 ? t.len : t.pos + i, S = new G.ics23.LeafOp(); t.pos < f; ) {
        var w = t.uint32();
        switch (w >>> 3) {
          case 1:
            S.hash = t.int32();
            break;
          case 2:
            S.prehashKey = t.int32();
            break;
          case 3:
            S.prehashValue = t.int32();
            break;
          case 4:
            S.length = t.int32();
            break;
          case 5:
            S.prefix = t.bytes();
            break;
          default:
            t.skipType(w & 7);
            break;
        }
      }
      return S;
    }, n.decodeDelimited = function(t) {
      return t instanceof oe || (t = new oe(t)), this.decode(t, t.uint32());
    }, n.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.hash != null && t.hasOwnProperty("hash"))
        switch (t.hash) {
          default:
            return "hash: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
            break;
        }
      if (t.prehashKey != null && t.hasOwnProperty("prehashKey"))
        switch (t.prehashKey) {
          default:
            return "prehashKey: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
            break;
        }
      if (t.prehashValue != null && t.hasOwnProperty("prehashValue"))
        switch (t.prehashValue) {
          default:
            return "prehashValue: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
            break;
        }
      if (t.length != null && t.hasOwnProperty("length"))
        switch (t.length) {
          default:
            return "length: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
            break;
        }
      return t.prefix != null && t.hasOwnProperty("prefix") && !(t.prefix && typeof t.prefix.length == "number" || te.isString(t.prefix)) ? "prefix: buffer expected" : null;
    }, n.fromObject = function(t) {
      if (t instanceof G.ics23.LeafOp)
        return t;
      var i = new G.ics23.LeafOp();
      switch (t.hash) {
        case "NO_HASH":
        case 0:
          i.hash = 0;
          break;
        case "SHA256":
        case 1:
          i.hash = 1;
          break;
        case "SHA512":
        case 2:
          i.hash = 2;
          break;
        case "KECCAK":
        case 3:
          i.hash = 3;
          break;
        case "RIPEMD160":
        case 4:
          i.hash = 4;
          break;
        case "BITCOIN":
        case 5:
          i.hash = 5;
          break;
        case "SHA512_256":
        case 6:
          i.hash = 6;
          break;
      }
      switch (t.prehashKey) {
        case "NO_HASH":
        case 0:
          i.prehashKey = 0;
          break;
        case "SHA256":
        case 1:
          i.prehashKey = 1;
          break;
        case "SHA512":
        case 2:
          i.prehashKey = 2;
          break;
        case "KECCAK":
        case 3:
          i.prehashKey = 3;
          break;
        case "RIPEMD160":
        case 4:
          i.prehashKey = 4;
          break;
        case "BITCOIN":
        case 5:
          i.prehashKey = 5;
          break;
        case "SHA512_256":
        case 6:
          i.prehashKey = 6;
          break;
      }
      switch (t.prehashValue) {
        case "NO_HASH":
        case 0:
          i.prehashValue = 0;
          break;
        case "SHA256":
        case 1:
          i.prehashValue = 1;
          break;
        case "SHA512":
        case 2:
          i.prehashValue = 2;
          break;
        case "KECCAK":
        case 3:
          i.prehashValue = 3;
          break;
        case "RIPEMD160":
        case 4:
          i.prehashValue = 4;
          break;
        case "BITCOIN":
        case 5:
          i.prehashValue = 5;
          break;
        case "SHA512_256":
        case 6:
          i.prehashValue = 6;
          break;
      }
      switch (t.length) {
        case "NO_PREFIX":
        case 0:
          i.length = 0;
          break;
        case "VAR_PROTO":
        case 1:
          i.length = 1;
          break;
        case "VAR_RLP":
        case 2:
          i.length = 2;
          break;
        case "FIXED32_BIG":
        case 3:
          i.length = 3;
          break;
        case "FIXED32_LITTLE":
        case 4:
          i.length = 4;
          break;
        case "FIXED64_BIG":
        case 5:
          i.length = 5;
          break;
        case "FIXED64_LITTLE":
        case 6:
          i.length = 6;
          break;
        case "REQUIRE_32_BYTES":
        case 7:
          i.length = 7;
          break;
        case "REQUIRE_64_BYTES":
        case 8:
          i.length = 8;
          break;
      }
      return t.prefix != null && (typeof t.prefix == "string" ? te.base64.decode(t.prefix, i.prefix = te.newBuffer(te.base64.length(t.prefix)), 0) : t.prefix.length && (i.prefix = t.prefix)), i;
    }, n.toObject = function(t, i) {
      i || (i = {});
      var f = {};
      return i.defaults && (f.hash = i.enums === String ? "NO_HASH" : 0, f.prehashKey = i.enums === String ? "NO_HASH" : 0, f.prehashValue = i.enums === String ? "NO_HASH" : 0, f.length = i.enums === String ? "NO_PREFIX" : 0, i.bytes === String ? f.prefix = "" : (f.prefix = [], i.bytes !== Array && (f.prefix = te.newBuffer(f.prefix)))), t.hash != null && t.hasOwnProperty("hash") && (f.hash = i.enums === String ? G.ics23.HashOp[t.hash] : t.hash), t.prehashKey != null && t.hasOwnProperty("prehashKey") && (f.prehashKey = i.enums === String ? G.ics23.HashOp[t.prehashKey] : t.prehashKey), t.prehashValue != null && t.hasOwnProperty("prehashValue") && (f.prehashValue = i.enums === String ? G.ics23.HashOp[t.prehashValue] : t.prehashValue), t.length != null && t.hasOwnProperty("length") && (f.length = i.enums === String ? G.ics23.LengthOp[t.length] : t.length), t.prefix != null && t.hasOwnProperty("prefix") && (f.prefix = i.bytes === String ? te.base64.encode(t.prefix, 0, t.prefix.length) : i.bytes === Array ? Array.prototype.slice.call(t.prefix) : t.prefix), f;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, Ee.util.toJSONOptions);
    }, n;
  }(), e.InnerOp = function() {
    function n(r) {
      if (r)
        for (var t = Object.keys(r), i = 0; i < t.length; ++i)
          r[t[i]] != null && (this[t[i]] = r[t[i]]);
    }
    return n.prototype.hash = 0, n.prototype.prefix = te.newBuffer([]), n.prototype.suffix = te.newBuffer([]), n.create = function(t) {
      return new n(t);
    }, n.encode = function(t, i) {
      return i || (i = pn.create()), t.hash != null && t.hasOwnProperty("hash") && i.uint32(
        /* id 1, wireType 0 =*/
        8
      ).int32(t.hash), t.prefix != null && t.hasOwnProperty("prefix") && i.uint32(
        /* id 2, wireType 2 =*/
        18
      ).bytes(t.prefix), t.suffix != null && t.hasOwnProperty("suffix") && i.uint32(
        /* id 3, wireType 2 =*/
        26
      ).bytes(t.suffix), i;
    }, n.encodeDelimited = function(t, i) {
      return this.encode(t, i).ldelim();
    }, n.decode = function(t, i) {
      t instanceof oe || (t = oe.create(t));
      for (var f = i === void 0 ? t.len : t.pos + i, S = new G.ics23.InnerOp(); t.pos < f; ) {
        var w = t.uint32();
        switch (w >>> 3) {
          case 1:
            S.hash = t.int32();
            break;
          case 2:
            S.prefix = t.bytes();
            break;
          case 3:
            S.suffix = t.bytes();
            break;
          default:
            t.skipType(w & 7);
            break;
        }
      }
      return S;
    }, n.decodeDelimited = function(t) {
      return t instanceof oe || (t = new oe(t)), this.decode(t, t.uint32());
    }, n.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.hash != null && t.hasOwnProperty("hash"))
        switch (t.hash) {
          default:
            return "hash: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
            break;
        }
      return t.prefix != null && t.hasOwnProperty("prefix") && !(t.prefix && typeof t.prefix.length == "number" || te.isString(t.prefix)) ? "prefix: buffer expected" : t.suffix != null && t.hasOwnProperty("suffix") && !(t.suffix && typeof t.suffix.length == "number" || te.isString(t.suffix)) ? "suffix: buffer expected" : null;
    }, n.fromObject = function(t) {
      if (t instanceof G.ics23.InnerOp)
        return t;
      var i = new G.ics23.InnerOp();
      switch (t.hash) {
        case "NO_HASH":
        case 0:
          i.hash = 0;
          break;
        case "SHA256":
        case 1:
          i.hash = 1;
          break;
        case "SHA512":
        case 2:
          i.hash = 2;
          break;
        case "KECCAK":
        case 3:
          i.hash = 3;
          break;
        case "RIPEMD160":
        case 4:
          i.hash = 4;
          break;
        case "BITCOIN":
        case 5:
          i.hash = 5;
          break;
        case "SHA512_256":
        case 6:
          i.hash = 6;
          break;
      }
      return t.prefix != null && (typeof t.prefix == "string" ? te.base64.decode(t.prefix, i.prefix = te.newBuffer(te.base64.length(t.prefix)), 0) : t.prefix.length && (i.prefix = t.prefix)), t.suffix != null && (typeof t.suffix == "string" ? te.base64.decode(t.suffix, i.suffix = te.newBuffer(te.base64.length(t.suffix)), 0) : t.suffix.length && (i.suffix = t.suffix)), i;
    }, n.toObject = function(t, i) {
      i || (i = {});
      var f = {};
      return i.defaults && (f.hash = i.enums === String ? "NO_HASH" : 0, i.bytes === String ? f.prefix = "" : (f.prefix = [], i.bytes !== Array && (f.prefix = te.newBuffer(f.prefix))), i.bytes === String ? f.suffix = "" : (f.suffix = [], i.bytes !== Array && (f.suffix = te.newBuffer(f.suffix)))), t.hash != null && t.hasOwnProperty("hash") && (f.hash = i.enums === String ? G.ics23.HashOp[t.hash] : t.hash), t.prefix != null && t.hasOwnProperty("prefix") && (f.prefix = i.bytes === String ? te.base64.encode(t.prefix, 0, t.prefix.length) : i.bytes === Array ? Array.prototype.slice.call(t.prefix) : t.prefix), t.suffix != null && t.hasOwnProperty("suffix") && (f.suffix = i.bytes === String ? te.base64.encode(t.suffix, 0, t.suffix.length) : i.bytes === Array ? Array.prototype.slice.call(t.suffix) : t.suffix), f;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, Ee.util.toJSONOptions);
    }, n;
  }(), e.ProofSpec = function() {
    function n(r) {
      if (r)
        for (var t = Object.keys(r), i = 0; i < t.length; ++i)
          r[t[i]] != null && (this[t[i]] = r[t[i]]);
    }
    return n.prototype.leafSpec = null, n.prototype.innerSpec = null, n.prototype.maxDepth = 0, n.prototype.minDepth = 0, n.create = function(t) {
      return new n(t);
    }, n.encode = function(t, i) {
      return i || (i = pn.create()), t.leafSpec != null && t.hasOwnProperty("leafSpec") && G.ics23.LeafOp.encode(t.leafSpec, i.uint32(
        /* id 1, wireType 2 =*/
        10
      ).fork()).ldelim(), t.innerSpec != null && t.hasOwnProperty("innerSpec") && G.ics23.InnerSpec.encode(t.innerSpec, i.uint32(
        /* id 2, wireType 2 =*/
        18
      ).fork()).ldelim(), t.maxDepth != null && t.hasOwnProperty("maxDepth") && i.uint32(
        /* id 3, wireType 0 =*/
        24
      ).int32(t.maxDepth), t.minDepth != null && t.hasOwnProperty("minDepth") && i.uint32(
        /* id 4, wireType 0 =*/
        32
      ).int32(t.minDepth), i;
    }, n.encodeDelimited = function(t, i) {
      return this.encode(t, i).ldelim();
    }, n.decode = function(t, i) {
      t instanceof oe || (t = oe.create(t));
      for (var f = i === void 0 ? t.len : t.pos + i, S = new G.ics23.ProofSpec(); t.pos < f; ) {
        var w = t.uint32();
        switch (w >>> 3) {
          case 1:
            S.leafSpec = G.ics23.LeafOp.decode(t, t.uint32());
            break;
          case 2:
            S.innerSpec = G.ics23.InnerSpec.decode(t, t.uint32());
            break;
          case 3:
            S.maxDepth = t.int32();
            break;
          case 4:
            S.minDepth = t.int32();
            break;
          default:
            t.skipType(w & 7);
            break;
        }
      }
      return S;
    }, n.decodeDelimited = function(t) {
      return t instanceof oe || (t = new oe(t)), this.decode(t, t.uint32());
    }, n.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.leafSpec != null && t.hasOwnProperty("leafSpec")) {
        var i = G.ics23.LeafOp.verify(t.leafSpec);
        if (i)
          return "leafSpec." + i;
      }
      if (t.innerSpec != null && t.hasOwnProperty("innerSpec")) {
        var i = G.ics23.InnerSpec.verify(t.innerSpec);
        if (i)
          return "innerSpec." + i;
      }
      return t.maxDepth != null && t.hasOwnProperty("maxDepth") && !te.isInteger(t.maxDepth) ? "maxDepth: integer expected" : t.minDepth != null && t.hasOwnProperty("minDepth") && !te.isInteger(t.minDepth) ? "minDepth: integer expected" : null;
    }, n.fromObject = function(t) {
      if (t instanceof G.ics23.ProofSpec)
        return t;
      var i = new G.ics23.ProofSpec();
      if (t.leafSpec != null) {
        if (typeof t.leafSpec != "object")
          throw TypeError(".ics23.ProofSpec.leafSpec: object expected");
        i.leafSpec = G.ics23.LeafOp.fromObject(t.leafSpec);
      }
      if (t.innerSpec != null) {
        if (typeof t.innerSpec != "object")
          throw TypeError(".ics23.ProofSpec.innerSpec: object expected");
        i.innerSpec = G.ics23.InnerSpec.fromObject(t.innerSpec);
      }
      return t.maxDepth != null && (i.maxDepth = t.maxDepth | 0), t.minDepth != null && (i.minDepth = t.minDepth | 0), i;
    }, n.toObject = function(t, i) {
      i || (i = {});
      var f = {};
      return i.defaults && (f.leafSpec = null, f.innerSpec = null, f.maxDepth = 0, f.minDepth = 0), t.leafSpec != null && t.hasOwnProperty("leafSpec") && (f.leafSpec = G.ics23.LeafOp.toObject(t.leafSpec, i)), t.innerSpec != null && t.hasOwnProperty("innerSpec") && (f.innerSpec = G.ics23.InnerSpec.toObject(t.innerSpec, i)), t.maxDepth != null && t.hasOwnProperty("maxDepth") && (f.maxDepth = t.maxDepth), t.minDepth != null && t.hasOwnProperty("minDepth") && (f.minDepth = t.minDepth), f;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, Ee.util.toJSONOptions);
    }, n;
  }(), e.InnerSpec = function() {
    function n(r) {
      if (this.childOrder = [], r)
        for (var t = Object.keys(r), i = 0; i < t.length; ++i)
          r[t[i]] != null && (this[t[i]] = r[t[i]]);
    }
    return n.prototype.childOrder = te.emptyArray, n.prototype.childSize = 0, n.prototype.minPrefixLength = 0, n.prototype.maxPrefixLength = 0, n.prototype.emptyChild = te.newBuffer([]), n.prototype.hash = 0, n.create = function(t) {
      return new n(t);
    }, n.encode = function(t, i) {
      if (i || (i = pn.create()), t.childOrder != null && t.childOrder.length) {
        i.uint32(
          /* id 1, wireType 2 =*/
          10
        ).fork();
        for (var f = 0; f < t.childOrder.length; ++f)
          i.int32(t.childOrder[f]);
        i.ldelim();
      }
      return t.childSize != null && t.hasOwnProperty("childSize") && i.uint32(
        /* id 2, wireType 0 =*/
        16
      ).int32(t.childSize), t.minPrefixLength != null && t.hasOwnProperty("minPrefixLength") && i.uint32(
        /* id 3, wireType 0 =*/
        24
      ).int32(t.minPrefixLength), t.maxPrefixLength != null && t.hasOwnProperty("maxPrefixLength") && i.uint32(
        /* id 4, wireType 0 =*/
        32
      ).int32(t.maxPrefixLength), t.emptyChild != null && t.hasOwnProperty("emptyChild") && i.uint32(
        /* id 5, wireType 2 =*/
        42
      ).bytes(t.emptyChild), t.hash != null && t.hasOwnProperty("hash") && i.uint32(
        /* id 6, wireType 0 =*/
        48
      ).int32(t.hash), i;
    }, n.encodeDelimited = function(t, i) {
      return this.encode(t, i).ldelim();
    }, n.decode = function(t, i) {
      t instanceof oe || (t = oe.create(t));
      for (var f = i === void 0 ? t.len : t.pos + i, S = new G.ics23.InnerSpec(); t.pos < f; ) {
        var w = t.uint32();
        switch (w >>> 3) {
          case 1:
            if (S.childOrder && S.childOrder.length || (S.childOrder = []), (w & 7) === 2)
              for (var T = t.uint32() + t.pos; t.pos < T; )
                S.childOrder.push(t.int32());
            else
              S.childOrder.push(t.int32());
            break;
          case 2:
            S.childSize = t.int32();
            break;
          case 3:
            S.minPrefixLength = t.int32();
            break;
          case 4:
            S.maxPrefixLength = t.int32();
            break;
          case 5:
            S.emptyChild = t.bytes();
            break;
          case 6:
            S.hash = t.int32();
            break;
          default:
            t.skipType(w & 7);
            break;
        }
      }
      return S;
    }, n.decodeDelimited = function(t) {
      return t instanceof oe || (t = new oe(t)), this.decode(t, t.uint32());
    }, n.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.childOrder != null && t.hasOwnProperty("childOrder")) {
        if (!Array.isArray(t.childOrder))
          return "childOrder: array expected";
        for (var i = 0; i < t.childOrder.length; ++i)
          if (!te.isInteger(t.childOrder[i]))
            return "childOrder: integer[] expected";
      }
      if (t.childSize != null && t.hasOwnProperty("childSize") && !te.isInteger(t.childSize))
        return "childSize: integer expected";
      if (t.minPrefixLength != null && t.hasOwnProperty("minPrefixLength") && !te.isInteger(t.minPrefixLength))
        return "minPrefixLength: integer expected";
      if (t.maxPrefixLength != null && t.hasOwnProperty("maxPrefixLength") && !te.isInteger(t.maxPrefixLength))
        return "maxPrefixLength: integer expected";
      if (t.emptyChild != null && t.hasOwnProperty("emptyChild") && !(t.emptyChild && typeof t.emptyChild.length == "number" || te.isString(t.emptyChild)))
        return "emptyChild: buffer expected";
      if (t.hash != null && t.hasOwnProperty("hash"))
        switch (t.hash) {
          default:
            return "hash: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
            break;
        }
      return null;
    }, n.fromObject = function(t) {
      if (t instanceof G.ics23.InnerSpec)
        return t;
      var i = new G.ics23.InnerSpec();
      if (t.childOrder) {
        if (!Array.isArray(t.childOrder))
          throw TypeError(".ics23.InnerSpec.childOrder: array expected");
        i.childOrder = [];
        for (var f = 0; f < t.childOrder.length; ++f)
          i.childOrder[f] = t.childOrder[f] | 0;
      }
      switch (t.childSize != null && (i.childSize = t.childSize | 0), t.minPrefixLength != null && (i.minPrefixLength = t.minPrefixLength | 0), t.maxPrefixLength != null && (i.maxPrefixLength = t.maxPrefixLength | 0), t.emptyChild != null && (typeof t.emptyChild == "string" ? te.base64.decode(t.emptyChild, i.emptyChild = te.newBuffer(te.base64.length(t.emptyChild)), 0) : t.emptyChild.length && (i.emptyChild = t.emptyChild)), t.hash) {
        case "NO_HASH":
        case 0:
          i.hash = 0;
          break;
        case "SHA256":
        case 1:
          i.hash = 1;
          break;
        case "SHA512":
        case 2:
          i.hash = 2;
          break;
        case "KECCAK":
        case 3:
          i.hash = 3;
          break;
        case "RIPEMD160":
        case 4:
          i.hash = 4;
          break;
        case "BITCOIN":
        case 5:
          i.hash = 5;
          break;
        case "SHA512_256":
        case 6:
          i.hash = 6;
          break;
      }
      return i;
    }, n.toObject = function(t, i) {
      i || (i = {});
      var f = {};
      if ((i.arrays || i.defaults) && (f.childOrder = []), i.defaults && (f.childSize = 0, f.minPrefixLength = 0, f.maxPrefixLength = 0, i.bytes === String ? f.emptyChild = "" : (f.emptyChild = [], i.bytes !== Array && (f.emptyChild = te.newBuffer(f.emptyChild))), f.hash = i.enums === String ? "NO_HASH" : 0), t.childOrder && t.childOrder.length) {
        f.childOrder = [];
        for (var S = 0; S < t.childOrder.length; ++S)
          f.childOrder[S] = t.childOrder[S];
      }
      return t.childSize != null && t.hasOwnProperty("childSize") && (f.childSize = t.childSize), t.minPrefixLength != null && t.hasOwnProperty("minPrefixLength") && (f.minPrefixLength = t.minPrefixLength), t.maxPrefixLength != null && t.hasOwnProperty("maxPrefixLength") && (f.maxPrefixLength = t.maxPrefixLength), t.emptyChild != null && t.hasOwnProperty("emptyChild") && (f.emptyChild = i.bytes === String ? te.base64.encode(t.emptyChild, 0, t.emptyChild.length) : i.bytes === Array ? Array.prototype.slice.call(t.emptyChild) : t.emptyChild), t.hash != null && t.hasOwnProperty("hash") && (f.hash = i.enums === String ? G.ics23.HashOp[t.hash] : t.hash), f;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, Ee.util.toJSONOptions);
    }, n;
  }(), e.BatchProof = function() {
    function n(r) {
      if (this.entries = [], r)
        for (var t = Object.keys(r), i = 0; i < t.length; ++i)
          r[t[i]] != null && (this[t[i]] = r[t[i]]);
    }
    return n.prototype.entries = te.emptyArray, n.create = function(t) {
      return new n(t);
    }, n.encode = function(t, i) {
      if (i || (i = pn.create()), t.entries != null && t.entries.length)
        for (var f = 0; f < t.entries.length; ++f)
          G.ics23.BatchEntry.encode(t.entries[f], i.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
      return i;
    }, n.encodeDelimited = function(t, i) {
      return this.encode(t, i).ldelim();
    }, n.decode = function(t, i) {
      t instanceof oe || (t = oe.create(t));
      for (var f = i === void 0 ? t.len : t.pos + i, S = new G.ics23.BatchProof(); t.pos < f; ) {
        var w = t.uint32();
        switch (w >>> 3) {
          case 1:
            S.entries && S.entries.length || (S.entries = []), S.entries.push(G.ics23.BatchEntry.decode(t, t.uint32()));
            break;
          default:
            t.skipType(w & 7);
            break;
        }
      }
      return S;
    }, n.decodeDelimited = function(t) {
      return t instanceof oe || (t = new oe(t)), this.decode(t, t.uint32());
    }, n.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.entries != null && t.hasOwnProperty("entries")) {
        if (!Array.isArray(t.entries))
          return "entries: array expected";
        for (var i = 0; i < t.entries.length; ++i) {
          var f = G.ics23.BatchEntry.verify(t.entries[i]);
          if (f)
            return "entries." + f;
        }
      }
      return null;
    }, n.fromObject = function(t) {
      if (t instanceof G.ics23.BatchProof)
        return t;
      var i = new G.ics23.BatchProof();
      if (t.entries) {
        if (!Array.isArray(t.entries))
          throw TypeError(".ics23.BatchProof.entries: array expected");
        i.entries = [];
        for (var f = 0; f < t.entries.length; ++f) {
          if (typeof t.entries[f] != "object")
            throw TypeError(".ics23.BatchProof.entries: object expected");
          i.entries[f] = G.ics23.BatchEntry.fromObject(t.entries[f]);
        }
      }
      return i;
    }, n.toObject = function(t, i) {
      i || (i = {});
      var f = {};
      if ((i.arrays || i.defaults) && (f.entries = []), t.entries && t.entries.length) {
        f.entries = [];
        for (var S = 0; S < t.entries.length; ++S)
          f.entries[S] = G.ics23.BatchEntry.toObject(t.entries[S], i);
      }
      return f;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, Ee.util.toJSONOptions);
    }, n;
  }(), e.BatchEntry = function() {
    function n(t) {
      if (t)
        for (var i = Object.keys(t), f = 0; f < i.length; ++f)
          t[i[f]] != null && (this[i[f]] = t[i[f]]);
    }
    n.prototype.exist = null, n.prototype.nonexist = null;
    var r;
    return Object.defineProperty(n.prototype, "proof", {
      get: te.oneOfGetter(r = ["exist", "nonexist"]),
      set: te.oneOfSetter(r)
    }), n.create = function(i) {
      return new n(i);
    }, n.encode = function(i, f) {
      return f || (f = pn.create()), i.exist != null && i.hasOwnProperty("exist") && G.ics23.ExistenceProof.encode(i.exist, f.uint32(
        /* id 1, wireType 2 =*/
        10
      ).fork()).ldelim(), i.nonexist != null && i.hasOwnProperty("nonexist") && G.ics23.NonExistenceProof.encode(i.nonexist, f.uint32(
        /* id 2, wireType 2 =*/
        18
      ).fork()).ldelim(), f;
    }, n.encodeDelimited = function(i, f) {
      return this.encode(i, f).ldelim();
    }, n.decode = function(i, f) {
      i instanceof oe || (i = oe.create(i));
      for (var S = f === void 0 ? i.len : i.pos + f, w = new G.ics23.BatchEntry(); i.pos < S; ) {
        var T = i.uint32();
        switch (T >>> 3) {
          case 1:
            w.exist = G.ics23.ExistenceProof.decode(i, i.uint32());
            break;
          case 2:
            w.nonexist = G.ics23.NonExistenceProof.decode(i, i.uint32());
            break;
          default:
            i.skipType(T & 7);
            break;
        }
      }
      return w;
    }, n.decodeDelimited = function(i) {
      return i instanceof oe || (i = new oe(i)), this.decode(i, i.uint32());
    }, n.verify = function(i) {
      if (typeof i != "object" || i === null)
        return "object expected";
      var f = {};
      if (i.exist != null && i.hasOwnProperty("exist")) {
        f.proof = 1;
        {
          var S = G.ics23.ExistenceProof.verify(i.exist);
          if (S)
            return "exist." + S;
        }
      }
      if (i.nonexist != null && i.hasOwnProperty("nonexist")) {
        if (f.proof === 1)
          return "proof: multiple values";
        f.proof = 1;
        {
          var S = G.ics23.NonExistenceProof.verify(i.nonexist);
          if (S)
            return "nonexist." + S;
        }
      }
      return null;
    }, n.fromObject = function(i) {
      if (i instanceof G.ics23.BatchEntry)
        return i;
      var f = new G.ics23.BatchEntry();
      if (i.exist != null) {
        if (typeof i.exist != "object")
          throw TypeError(".ics23.BatchEntry.exist: object expected");
        f.exist = G.ics23.ExistenceProof.fromObject(i.exist);
      }
      if (i.nonexist != null) {
        if (typeof i.nonexist != "object")
          throw TypeError(".ics23.BatchEntry.nonexist: object expected");
        f.nonexist = G.ics23.NonExistenceProof.fromObject(i.nonexist);
      }
      return f;
    }, n.toObject = function(i, f) {
      f || (f = {});
      var S = {};
      return i.exist != null && i.hasOwnProperty("exist") && (S.exist = G.ics23.ExistenceProof.toObject(i.exist, f), f.oneofs && (S.proof = "exist")), i.nonexist != null && i.hasOwnProperty("nonexist") && (S.nonexist = G.ics23.NonExistenceProof.toObject(i.nonexist, f), f.oneofs && (S.proof = "nonexist")), S;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, Ee.util.toJSONOptions);
    }, n;
  }(), e.CompressedBatchProof = function() {
    function n(r) {
      if (this.entries = [], this.lookupInners = [], r)
        for (var t = Object.keys(r), i = 0; i < t.length; ++i)
          r[t[i]] != null && (this[t[i]] = r[t[i]]);
    }
    return n.prototype.entries = te.emptyArray, n.prototype.lookupInners = te.emptyArray, n.create = function(t) {
      return new n(t);
    }, n.encode = function(t, i) {
      if (i || (i = pn.create()), t.entries != null && t.entries.length)
        for (var f = 0; f < t.entries.length; ++f)
          G.ics23.CompressedBatchEntry.encode(t.entries[f], i.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
      if (t.lookupInners != null && t.lookupInners.length)
        for (var f = 0; f < t.lookupInners.length; ++f)
          G.ics23.InnerOp.encode(t.lookupInners[f], i.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
      return i;
    }, n.encodeDelimited = function(t, i) {
      return this.encode(t, i).ldelim();
    }, n.decode = function(t, i) {
      t instanceof oe || (t = oe.create(t));
      for (var f = i === void 0 ? t.len : t.pos + i, S = new G.ics23.CompressedBatchProof(); t.pos < f; ) {
        var w = t.uint32();
        switch (w >>> 3) {
          case 1:
            S.entries && S.entries.length || (S.entries = []), S.entries.push(G.ics23.CompressedBatchEntry.decode(t, t.uint32()));
            break;
          case 2:
            S.lookupInners && S.lookupInners.length || (S.lookupInners = []), S.lookupInners.push(G.ics23.InnerOp.decode(t, t.uint32()));
            break;
          default:
            t.skipType(w & 7);
            break;
        }
      }
      return S;
    }, n.decodeDelimited = function(t) {
      return t instanceof oe || (t = new oe(t)), this.decode(t, t.uint32());
    }, n.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.entries != null && t.hasOwnProperty("entries")) {
        if (!Array.isArray(t.entries))
          return "entries: array expected";
        for (var i = 0; i < t.entries.length; ++i) {
          var f = G.ics23.CompressedBatchEntry.verify(t.entries[i]);
          if (f)
            return "entries." + f;
        }
      }
      if (t.lookupInners != null && t.hasOwnProperty("lookupInners")) {
        if (!Array.isArray(t.lookupInners))
          return "lookupInners: array expected";
        for (var i = 0; i < t.lookupInners.length; ++i) {
          var f = G.ics23.InnerOp.verify(t.lookupInners[i]);
          if (f)
            return "lookupInners." + f;
        }
      }
      return null;
    }, n.fromObject = function(t) {
      if (t instanceof G.ics23.CompressedBatchProof)
        return t;
      var i = new G.ics23.CompressedBatchProof();
      if (t.entries) {
        if (!Array.isArray(t.entries))
          throw TypeError(".ics23.CompressedBatchProof.entries: array expected");
        i.entries = [];
        for (var f = 0; f < t.entries.length; ++f) {
          if (typeof t.entries[f] != "object")
            throw TypeError(".ics23.CompressedBatchProof.entries: object expected");
          i.entries[f] = G.ics23.CompressedBatchEntry.fromObject(t.entries[f]);
        }
      }
      if (t.lookupInners) {
        if (!Array.isArray(t.lookupInners))
          throw TypeError(".ics23.CompressedBatchProof.lookupInners: array expected");
        i.lookupInners = [];
        for (var f = 0; f < t.lookupInners.length; ++f) {
          if (typeof t.lookupInners[f] != "object")
            throw TypeError(".ics23.CompressedBatchProof.lookupInners: object expected");
          i.lookupInners[f] = G.ics23.InnerOp.fromObject(t.lookupInners[f]);
        }
      }
      return i;
    }, n.toObject = function(t, i) {
      i || (i = {});
      var f = {};
      if ((i.arrays || i.defaults) && (f.entries = [], f.lookupInners = []), t.entries && t.entries.length) {
        f.entries = [];
        for (var S = 0; S < t.entries.length; ++S)
          f.entries[S] = G.ics23.CompressedBatchEntry.toObject(t.entries[S], i);
      }
      if (t.lookupInners && t.lookupInners.length) {
        f.lookupInners = [];
        for (var S = 0; S < t.lookupInners.length; ++S)
          f.lookupInners[S] = G.ics23.InnerOp.toObject(t.lookupInners[S], i);
      }
      return f;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, Ee.util.toJSONOptions);
    }, n;
  }(), e.CompressedBatchEntry = function() {
    function n(t) {
      if (t)
        for (var i = Object.keys(t), f = 0; f < i.length; ++f)
          t[i[f]] != null && (this[i[f]] = t[i[f]]);
    }
    n.prototype.exist = null, n.prototype.nonexist = null;
    var r;
    return Object.defineProperty(n.prototype, "proof", {
      get: te.oneOfGetter(r = ["exist", "nonexist"]),
      set: te.oneOfSetter(r)
    }), n.create = function(i) {
      return new n(i);
    }, n.encode = function(i, f) {
      return f || (f = pn.create()), i.exist != null && i.hasOwnProperty("exist") && G.ics23.CompressedExistenceProof.encode(i.exist, f.uint32(
        /* id 1, wireType 2 =*/
        10
      ).fork()).ldelim(), i.nonexist != null && i.hasOwnProperty("nonexist") && G.ics23.CompressedNonExistenceProof.encode(i.nonexist, f.uint32(
        /* id 2, wireType 2 =*/
        18
      ).fork()).ldelim(), f;
    }, n.encodeDelimited = function(i, f) {
      return this.encode(i, f).ldelim();
    }, n.decode = function(i, f) {
      i instanceof oe || (i = oe.create(i));
      for (var S = f === void 0 ? i.len : i.pos + f, w = new G.ics23.CompressedBatchEntry(); i.pos < S; ) {
        var T = i.uint32();
        switch (T >>> 3) {
          case 1:
            w.exist = G.ics23.CompressedExistenceProof.decode(i, i.uint32());
            break;
          case 2:
            w.nonexist = G.ics23.CompressedNonExistenceProof.decode(i, i.uint32());
            break;
          default:
            i.skipType(T & 7);
            break;
        }
      }
      return w;
    }, n.decodeDelimited = function(i) {
      return i instanceof oe || (i = new oe(i)), this.decode(i, i.uint32());
    }, n.verify = function(i) {
      if (typeof i != "object" || i === null)
        return "object expected";
      var f = {};
      if (i.exist != null && i.hasOwnProperty("exist")) {
        f.proof = 1;
        {
          var S = G.ics23.CompressedExistenceProof.verify(i.exist);
          if (S)
            return "exist." + S;
        }
      }
      if (i.nonexist != null && i.hasOwnProperty("nonexist")) {
        if (f.proof === 1)
          return "proof: multiple values";
        f.proof = 1;
        {
          var S = G.ics23.CompressedNonExistenceProof.verify(i.nonexist);
          if (S)
            return "nonexist." + S;
        }
      }
      return null;
    }, n.fromObject = function(i) {
      if (i instanceof G.ics23.CompressedBatchEntry)
        return i;
      var f = new G.ics23.CompressedBatchEntry();
      if (i.exist != null) {
        if (typeof i.exist != "object")
          throw TypeError(".ics23.CompressedBatchEntry.exist: object expected");
        f.exist = G.ics23.CompressedExistenceProof.fromObject(i.exist);
      }
      if (i.nonexist != null) {
        if (typeof i.nonexist != "object")
          throw TypeError(".ics23.CompressedBatchEntry.nonexist: object expected");
        f.nonexist = G.ics23.CompressedNonExistenceProof.fromObject(i.nonexist);
      }
      return f;
    }, n.toObject = function(i, f) {
      f || (f = {});
      var S = {};
      return i.exist != null && i.hasOwnProperty("exist") && (S.exist = G.ics23.CompressedExistenceProof.toObject(i.exist, f), f.oneofs && (S.proof = "exist")), i.nonexist != null && i.hasOwnProperty("nonexist") && (S.nonexist = G.ics23.CompressedNonExistenceProof.toObject(i.nonexist, f), f.oneofs && (S.proof = "nonexist")), S;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, Ee.util.toJSONOptions);
    }, n;
  }(), e.CompressedExistenceProof = function() {
    function n(r) {
      if (this.path = [], r)
        for (var t = Object.keys(r), i = 0; i < t.length; ++i)
          r[t[i]] != null && (this[t[i]] = r[t[i]]);
    }
    return n.prototype.key = te.newBuffer([]), n.prototype.value = te.newBuffer([]), n.prototype.leaf = null, n.prototype.path = te.emptyArray, n.create = function(t) {
      return new n(t);
    }, n.encode = function(t, i) {
      if (i || (i = pn.create()), t.key != null && t.hasOwnProperty("key") && i.uint32(
        /* id 1, wireType 2 =*/
        10
      ).bytes(t.key), t.value != null && t.hasOwnProperty("value") && i.uint32(
        /* id 2, wireType 2 =*/
        18
      ).bytes(t.value), t.leaf != null && t.hasOwnProperty("leaf") && G.ics23.LeafOp.encode(t.leaf, i.uint32(
        /* id 3, wireType 2 =*/
        26
      ).fork()).ldelim(), t.path != null && t.path.length) {
        i.uint32(
          /* id 4, wireType 2 =*/
          34
        ).fork();
        for (var f = 0; f < t.path.length; ++f)
          i.int32(t.path[f]);
        i.ldelim();
      }
      return i;
    }, n.encodeDelimited = function(t, i) {
      return this.encode(t, i).ldelim();
    }, n.decode = function(t, i) {
      t instanceof oe || (t = oe.create(t));
      for (var f = i === void 0 ? t.len : t.pos + i, S = new G.ics23.CompressedExistenceProof(); t.pos < f; ) {
        var w = t.uint32();
        switch (w >>> 3) {
          case 1:
            S.key = t.bytes();
            break;
          case 2:
            S.value = t.bytes();
            break;
          case 3:
            S.leaf = G.ics23.LeafOp.decode(t, t.uint32());
            break;
          case 4:
            if (S.path && S.path.length || (S.path = []), (w & 7) === 2)
              for (var T = t.uint32() + t.pos; t.pos < T; )
                S.path.push(t.int32());
            else
              S.path.push(t.int32());
            break;
          default:
            t.skipType(w & 7);
            break;
        }
      }
      return S;
    }, n.decodeDelimited = function(t) {
      return t instanceof oe || (t = new oe(t)), this.decode(t, t.uint32());
    }, n.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.key != null && t.hasOwnProperty("key") && !(t.key && typeof t.key.length == "number" || te.isString(t.key)))
        return "key: buffer expected";
      if (t.value != null && t.hasOwnProperty("value") && !(t.value && typeof t.value.length == "number" || te.isString(t.value)))
        return "value: buffer expected";
      if (t.leaf != null && t.hasOwnProperty("leaf")) {
        var i = G.ics23.LeafOp.verify(t.leaf);
        if (i)
          return "leaf." + i;
      }
      if (t.path != null && t.hasOwnProperty("path")) {
        if (!Array.isArray(t.path))
          return "path: array expected";
        for (var f = 0; f < t.path.length; ++f)
          if (!te.isInteger(t.path[f]))
            return "path: integer[] expected";
      }
      return null;
    }, n.fromObject = function(t) {
      if (t instanceof G.ics23.CompressedExistenceProof)
        return t;
      var i = new G.ics23.CompressedExistenceProof();
      if (t.key != null && (typeof t.key == "string" ? te.base64.decode(t.key, i.key = te.newBuffer(te.base64.length(t.key)), 0) : t.key.length && (i.key = t.key)), t.value != null && (typeof t.value == "string" ? te.base64.decode(t.value, i.value = te.newBuffer(te.base64.length(t.value)), 0) : t.value.length && (i.value = t.value)), t.leaf != null) {
        if (typeof t.leaf != "object")
          throw TypeError(".ics23.CompressedExistenceProof.leaf: object expected");
        i.leaf = G.ics23.LeafOp.fromObject(t.leaf);
      }
      if (t.path) {
        if (!Array.isArray(t.path))
          throw TypeError(".ics23.CompressedExistenceProof.path: array expected");
        i.path = [];
        for (var f = 0; f < t.path.length; ++f)
          i.path[f] = t.path[f] | 0;
      }
      return i;
    }, n.toObject = function(t, i) {
      i || (i = {});
      var f = {};
      if ((i.arrays || i.defaults) && (f.path = []), i.defaults && (i.bytes === String ? f.key = "" : (f.key = [], i.bytes !== Array && (f.key = te.newBuffer(f.key))), i.bytes === String ? f.value = "" : (f.value = [], i.bytes !== Array && (f.value = te.newBuffer(f.value))), f.leaf = null), t.key != null && t.hasOwnProperty("key") && (f.key = i.bytes === String ? te.base64.encode(t.key, 0, t.key.length) : i.bytes === Array ? Array.prototype.slice.call(t.key) : t.key), t.value != null && t.hasOwnProperty("value") && (f.value = i.bytes === String ? te.base64.encode(t.value, 0, t.value.length) : i.bytes === Array ? Array.prototype.slice.call(t.value) : t.value), t.leaf != null && t.hasOwnProperty("leaf") && (f.leaf = G.ics23.LeafOp.toObject(t.leaf, i)), t.path && t.path.length) {
        f.path = [];
        for (var S = 0; S < t.path.length; ++S)
          f.path[S] = t.path[S];
      }
      return f;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, Ee.util.toJSONOptions);
    }, n;
  }(), e.CompressedNonExistenceProof = function() {
    function n(r) {
      if (r)
        for (var t = Object.keys(r), i = 0; i < t.length; ++i)
          r[t[i]] != null && (this[t[i]] = r[t[i]]);
    }
    return n.prototype.key = te.newBuffer([]), n.prototype.left = null, n.prototype.right = null, n.create = function(t) {
      return new n(t);
    }, n.encode = function(t, i) {
      return i || (i = pn.create()), t.key != null && t.hasOwnProperty("key") && i.uint32(
        /* id 1, wireType 2 =*/
        10
      ).bytes(t.key), t.left != null && t.hasOwnProperty("left") && G.ics23.CompressedExistenceProof.encode(t.left, i.uint32(
        /* id 2, wireType 2 =*/
        18
      ).fork()).ldelim(), t.right != null && t.hasOwnProperty("right") && G.ics23.CompressedExistenceProof.encode(t.right, i.uint32(
        /* id 3, wireType 2 =*/
        26
      ).fork()).ldelim(), i;
    }, n.encodeDelimited = function(t, i) {
      return this.encode(t, i).ldelim();
    }, n.decode = function(t, i) {
      t instanceof oe || (t = oe.create(t));
      for (var f = i === void 0 ? t.len : t.pos + i, S = new G.ics23.CompressedNonExistenceProof(); t.pos < f; ) {
        var w = t.uint32();
        switch (w >>> 3) {
          case 1:
            S.key = t.bytes();
            break;
          case 2:
            S.left = G.ics23.CompressedExistenceProof.decode(t, t.uint32());
            break;
          case 3:
            S.right = G.ics23.CompressedExistenceProof.decode(t, t.uint32());
            break;
          default:
            t.skipType(w & 7);
            break;
        }
      }
      return S;
    }, n.decodeDelimited = function(t) {
      return t instanceof oe || (t = new oe(t)), this.decode(t, t.uint32());
    }, n.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.key != null && t.hasOwnProperty("key") && !(t.key && typeof t.key.length == "number" || te.isString(t.key)))
        return "key: buffer expected";
      if (t.left != null && t.hasOwnProperty("left")) {
        var i = G.ics23.CompressedExistenceProof.verify(t.left);
        if (i)
          return "left." + i;
      }
      if (t.right != null && t.hasOwnProperty("right")) {
        var i = G.ics23.CompressedExistenceProof.verify(t.right);
        if (i)
          return "right." + i;
      }
      return null;
    }, n.fromObject = function(t) {
      if (t instanceof G.ics23.CompressedNonExistenceProof)
        return t;
      var i = new G.ics23.CompressedNonExistenceProof();
      if (t.key != null && (typeof t.key == "string" ? te.base64.decode(t.key, i.key = te.newBuffer(te.base64.length(t.key)), 0) : t.key.length && (i.key = t.key)), t.left != null) {
        if (typeof t.left != "object")
          throw TypeError(".ics23.CompressedNonExistenceProof.left: object expected");
        i.left = G.ics23.CompressedExistenceProof.fromObject(t.left);
      }
      if (t.right != null) {
        if (typeof t.right != "object")
          throw TypeError(".ics23.CompressedNonExistenceProof.right: object expected");
        i.right = G.ics23.CompressedExistenceProof.fromObject(t.right);
      }
      return i;
    }, n.toObject = function(t, i) {
      i || (i = {});
      var f = {};
      return i.defaults && (i.bytes === String ? f.key = "" : (f.key = [], i.bytes !== Array && (f.key = te.newBuffer(f.key))), f.left = null, f.right = null), t.key != null && t.hasOwnProperty("key") && (f.key = i.bytes === String ? te.base64.encode(t.key, 0, t.key.length) : i.bytes === Array ? Array.prototype.slice.call(t.key) : t.key), t.left != null && t.hasOwnProperty("left") && (f.left = G.ics23.CompressedExistenceProof.toObject(t.left, i)), t.right != null && t.hasOwnProperty("right") && (f.right = G.ics23.CompressedExistenceProof.toObject(t.right, i)), f;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, Ee.util.toJSONOptions);
    }, n;
  }(), e;
}();
var os = G, nt = {}, ui = {};
Object.defineProperty(ui, "__esModule", { value: !0 });
ui.decompress = ui.compress = void 0;
const Gk = os;
function Kk(e) {
  return e.batch ? { compressed: xk(e.batch) } : e;
}
ui.compress = Kk;
function zk(e) {
  return e.compressed ? { batch: Zk(e.compressed) } : e;
}
ui.decompress = zk;
function xk(e) {
  const n = [], r = [], t = /* @__PURE__ */ new Map();
  for (const i of e.entries)
    if (i.exist) {
      const f = { exist: zd(i.exist, r, t) };
      n.push(f);
    } else if (i.nonexist) {
      const f = i.nonexist, S = {
        nonexist: {
          key: f.key,
          left: zd(f.left, r, t),
          right: zd(f.right, r, t)
        }
      };
      n.push(S);
    } else
      throw new Error("Unexpected batch entry during compress");
  return {
    entries: n,
    lookupInners: r
  };
}
function zd(e, n, r) {
  if (!e)
    return;
  const t = e.path.map((i) => {
    const f = Gk.ics23.InnerOp.encode(i).finish();
    let S = r.get(f);
    return S === void 0 && (S = n.length, n.push(i), r.set(f, S)), S;
  });
  return {
    key: e.key,
    value: e.value,
    leaf: e.leaf,
    path: t
  };
}
function Zk(e) {
  const n = e.lookupInners;
  return {
    entries: e.entries.map((t) => {
      if (t.exist)
        return { exist: xd(t.exist, n) };
      if (t.nonexist) {
        const i = t.nonexist;
        return {
          nonexist: {
            key: i.key,
            left: xd(i.left, n),
            right: xd(i.right, n)
          }
        };
      } else
        throw new Error("Unexpected batch entry during compress");
    })
  };
}
function xd(e, n) {
  if (!e)
    return;
  const { key: r, value: t, leaf: i, path: f } = e, S = (f || []).map((w) => n[w]);
  return { key: r, value: t, leaf: i, path: S };
}
var Ne = {}, wt = {};
Object.defineProperty(wt, "__esModule", { value: !0 });
wt.doHash = wt.applyInner = wt.applyLeaf = void 0;
const Fl = Kf, $l = Gf, Ll = bc, yn = os;
function Yk(e, n, r) {
  if (n.length === 0)
    throw new Error("Missing key");
  if (r.length === 0)
    throw new Error("Missing value");
  const t = Kl(ua(e.prehashKey), Gl(e.length), n), i = Kl(ua(e.prehashValue), Gl(e.length), r), f = new Uint8Array([
    ...Yu(e.prefix),
    ...t,
    ...i
  ]);
  return as(ua(e.hash), f);
}
wt.applyLeaf = Yk;
function Xk(e, n) {
  if (n.length === 0)
    throw new Error("Inner op needs child value");
  const r = new Uint8Array([
    ...Yu(e.prefix),
    ...n,
    ...Yu(e.suffix)
  ]);
  return as(ua(e.hash), r);
}
wt.applyInner = Xk;
function Mc(e, n) {
  return e ?? n;
}
const ua = (e) => Mc(e, yn.ics23.HashOp.NO_HASH), Gl = (e) => Mc(e, yn.ics23.LengthOp.NO_PREFIX), Yu = (e) => Mc(e, new Uint8Array([]));
function Kl(e, n, r) {
  const t = jk(e, r);
  return eP(n, t);
}
function jk(e, n) {
  return e === yn.ics23.HashOp.NO_HASH ? n : as(e, n);
}
function as(e, n) {
  switch (e) {
    case yn.ics23.HashOp.SHA256:
      return (0, $l.sha256)(n);
    case yn.ics23.HashOp.SHA512:
      return (0, Ll.sha512)(n);
    case yn.ics23.HashOp.RIPEMD160:
      return (0, Fl.ripemd160)(n);
    case yn.ics23.HashOp.BITCOIN:
      return (0, Fl.ripemd160)((0, $l.sha256)(n));
    case yn.ics23.HashOp.SHA512_256:
      return (0, Ll.sha512_256)(n);
  }
  throw new Error(`Unsupported hashop: ${e}`);
}
wt.doHash = as;
function eP(e, n) {
  switch (e) {
    case yn.ics23.LengthOp.NO_PREFIX:
      return n;
    case yn.ics23.LengthOp.VAR_PROTO:
      return new Uint8Array([...nP(n.length), ...n]);
    case yn.ics23.LengthOp.REQUIRE_32_BYTES:
      if (n.length !== 32)
        throw new Error(`Length is ${n.length}, not 32 bytes`);
      return n;
    case yn.ics23.LengthOp.REQUIRE_64_BYTES:
      if (n.length !== 64)
        throw new Error(`Length is ${n.length}, not 64 bytes`);
      return n;
    case yn.ics23.LengthOp.FIXED32_LITTLE:
      return new Uint8Array([...tP(n.length), ...n]);
  }
  throw new Error(`Unsupported lengthop: ${e}`);
}
function nP(e) {
  let n = [], r = e;
  for (; r >= 128; ) {
    const t = r % 128 + 128;
    n = [...n, t], r = r / 128;
  }
  return n = [...n, r], new Uint8Array(n);
}
function tP(e) {
  const n = new Uint8Array(4);
  let r = e;
  for (let t = n.length; t > 0; t--)
    n[Math.abs(t - n.length)] = r % 256, r = Math.floor(r / 256);
  return n;
}
var ze = {};
Object.defineProperty(ze, "__esModule", { value: !0 });
ze.bytesBefore = ze.ensureBytesBefore = ze.bytesEqual = ze.ensureBytesEqual = ze.ensureInner = ze.ensureLeaf = void 0;
function rP(e, n) {
  if (e.hash !== n.hash)
    throw new Error(`Unexpected hashOp: ${e.hash}`);
  if (e.prehashKey !== n.prehashKey)
    throw new Error(`Unexpected prehashKey: ${e.prehashKey}`);
  if (e.prehashValue !== n.prehashValue)
    throw new Error(`Unexpected prehashValue: ${e.prehashValue}`);
  if (e.length !== n.length)
    throw new Error(`Unexpected length op: ${e.length}`);
  oP(e.prefix, n.prefix);
}
ze.ensureLeaf = rP;
function iP(e, n, r) {
  if (e.hash !== r.hash)
    throw new Error(`Unexpected hashOp: ${e.hash}`);
  if (!e.prefix)
    throw new Error("No prefix set for inner node");
  if (sP(e.prefix, n))
    throw new Error("Inner node has leaf prefix");
  if (e.prefix.length < (r.minPrefixLength || 0))
    throw new Error(`Prefix too short: ${e.prefix.length} bytes`);
  const t = (r.childOrder.length - 1) * r.childSize;
  if (e.prefix.length > (r.maxPrefixLength || 0) + t)
    throw new Error(`Prefix too long: ${e.prefix.length} bytes`);
}
ze.ensureInner = iP;
function oP(e, n) {
  if (!(!n || n.length === 0)) {
    if (!e)
      throw new Error("Target bytes missing");
    Fp(n, e.slice(0, n.length));
  }
}
function Fp(e, n) {
  if (e.length !== n.length)
    throw new Error(`Different lengths ${e.length} vs ${n.length}`);
  for (let r = 0; r < e.length; r++)
    if (e[r] !== n[r])
      throw new Error(`Arrays differ at index ${r}: ${e[r]} vs ${n[r]}`);
}
ze.ensureBytesEqual = Fp;
function aP(e, n) {
  if (e.length !== n.length)
    return !1;
  for (let r = 0; r < e.length; r++)
    if (e[r] !== n[r])
      return !1;
  return !0;
}
ze.bytesEqual = aP;
function sP(e, n) {
  if (!n || n.length === 0 || !e || e.length <= n.length)
    return !1;
  for (let r = 0; r < n.length; r++)
    if (e[r] !== n[r])
      return !1;
  throw !0;
}
function dP(e, n) {
  if (!$p(e, n))
    throw new Error("first is after last");
}
ze.ensureBytesBefore = dP;
function $p(e, n) {
  const r = e.length < n.length ? e.length : n.length;
  for (let t = 0; t < r; t++) {
    if (e[t] < n[t])
      return !0;
    if (e[t] > n[t])
      return !1;
  }
  return e.length < n.length;
}
ze.bytesBefore = $p;
Object.defineProperty(Ne, "__esModule", { value: !0 });
Ne.ensureLeftNeighbor = Ne.ensureSpec = Ne.calculateExistenceRoot = Ne.verifyNonExistence = Ne.verifyExistence = Ne.smtSpec = Ne.tendermintSpec = Ne.iavlSpec = void 0;
const xe = os, zl = wt, ct = ze;
Ne.iavlSpec = {
  leafSpec: {
    prefix: Uint8Array.from([0]),
    hash: xe.ics23.HashOp.SHA256,
    prehashValue: xe.ics23.HashOp.SHA256,
    prehashKey: xe.ics23.HashOp.NO_HASH,
    length: xe.ics23.LengthOp.VAR_PROTO
  },
  innerSpec: {
    childOrder: [0, 1],
    minPrefixLength: 4,
    maxPrefixLength: 12,
    childSize: 33,
    hash: xe.ics23.HashOp.SHA256
  }
};
Ne.tendermintSpec = {
  leafSpec: {
    prefix: Uint8Array.from([0]),
    hash: xe.ics23.HashOp.SHA256,
    prehashValue: xe.ics23.HashOp.SHA256,
    prehashKey: xe.ics23.HashOp.NO_HASH,
    length: xe.ics23.LengthOp.VAR_PROTO
  },
  innerSpec: {
    childOrder: [0, 1],
    minPrefixLength: 1,
    maxPrefixLength: 1,
    childSize: 32,
    hash: xe.ics23.HashOp.SHA256
  }
};
Ne.smtSpec = {
  leafSpec: {
    hash: xe.ics23.HashOp.SHA256,
    prehashKey: xe.ics23.HashOp.NO_HASH,
    prehashValue: xe.ics23.HashOp.SHA256,
    length: xe.ics23.LengthOp.NO_PREFIX,
    prefix: Uint8Array.from([0])
  },
  innerSpec: {
    childOrder: [0, 1],
    childSize: 32,
    minPrefixLength: 1,
    maxPrefixLength: 1,
    emptyChild: new Uint8Array(32),
    hash: xe.ics23.HashOp.SHA256
  },
  maxDepth: 256
};
function Xu(e, n, r, t, i) {
  Gp(e, n);
  const f = Lp(e);
  (0, ct.ensureBytesEqual)(f, r), (0, ct.ensureBytesEqual)(t, e.key), (0, ct.ensureBytesEqual)(i, e.value);
}
Ne.verifyExistence = Xu;
function uP(e, n, r, t) {
  let i, f;
  if (e.left && (Xu(e.left, n, r, e.left.key, e.left.value), i = e.left.key), e.right && (Xu(e.right, n, r, e.right.key, e.right.value), f = e.right.key), !i && !f)
    throw new Error("neither left nor right proof defined");
  if (i && (0, ct.ensureBytesBefore)(i, t), f && (0, ct.ensureBytesBefore)(t, f), !n.innerSpec)
    throw new Error("no inner spec");
  i ? f ? xp(n.innerSpec, e.left.path, e.right.path) : zp(n.innerSpec, e.left.path) : Kp(n.innerSpec, e.right.path);
}
Ne.verifyNonExistence = uP;
function Lp(e) {
  if (!e.key || !e.value)
    throw new Error("Existence proof needs key and value set");
  if (!e.leaf)
    throw new Error("Existence proof must start with a leaf operation");
  const n = e.path || [];
  let r = (0, zl.applyLeaf)(e.leaf, e.key, e.value);
  for (const t of n)
    r = (0, zl.applyInner)(t, r);
  return r;
}
Ne.calculateExistenceRoot = Lp;
function Gp(e, n) {
  if (!e.leaf)
    throw new Error("Existence proof must start with a leaf operation");
  if (!n.leafSpec)
    throw new Error("Spec must include leafSpec");
  if (!n.innerSpec)
    throw new Error("Spec must include innerSpec");
  (0, ct.ensureLeaf)(e.leaf, n.leafSpec);
  const r = e.path || [];
  if (n.minDepth && r.length < n.minDepth)
    throw new Error(`Too few inner nodes ${r.length}`);
  if (n.maxDepth && r.length > n.maxDepth)
    throw new Error(`Too many inner nodes ${r.length}`);
  for (const t of r)
    (0, ct.ensureInner)(t, n.leafSpec.prefix, n.innerSpec);
}
Ne.ensureSpec = Gp;
function Kp(e, n) {
  const { minPrefix: r, maxPrefix: t, suffix: i } = qc(e, 0);
  for (const f of n)
    if (!Hc(f, r, t, i))
      throw new Error("Step not leftmost");
}
function zp(e, n) {
  const r = e.childOrder.length - 1, { minPrefix: t, maxPrefix: i, suffix: f } = qc(e, r);
  for (const S of n)
    if (!Hc(S, t, i, f))
      throw new Error("Step not leftmost");
}
function xp(e, n, r) {
  const t = [...n], i = [...r];
  let f = t.pop(), S = i.pop();
  for (; (0, ct.bytesEqual)(f.prefix, S.prefix) && (0, ct.bytesEqual)(f.suffix, S.suffix); )
    f = t.pop(), S = i.pop();
  if (!cP(e, f, S))
    throw new Error("Not left neightbor at first divergent step");
  zp(e, t), Kp(e, i);
}
Ne.ensureLeftNeighbor = xp;
function cP(e, n, r) {
  const t = xl(e, n);
  return xl(e, r) === t + 1;
}
function xl(e, n) {
  for (let r = 0; r < e.childOrder.length; r++) {
    const { minPrefix: t, maxPrefix: i, suffix: f } = qc(e, r);
    if (Hc(n, t, i, f))
      return r;
  }
  throw new Error("Cannot find any valid spacing for this node");
}
function Hc(e, n, r, t) {
  return (e.prefix || []).length < n || (e.prefix || []).length > r ? !1 : (e.suffix || []).length === t;
}
function qc(e, n) {
  const r = lP(e.childOrder, n), t = r * e.childSize, i = t + e.minPrefixLength, f = t + e.maxPrefixLength, S = (e.childOrder.length - 1 - r) * e.childSize;
  return { minPrefix: i, maxPrefix: f, suffix: S };
}
function lP(e, n) {
  if (n < 0 || n >= e.length)
    throw new Error(`Invalid branch: ${n}`);
  return e.findIndex((r) => r === n);
}
Object.defineProperty(nt, "__esModule", { value: !0 });
nt.batchVerifyNonMembership = nt.batchVerifyMembership = nt.verifyNonMembership = nt.verifyMembership = void 0;
const ss = ui, Zp = Ne, ju = ze;
function Yp(e, n, r, t, i) {
  const f = (0, ss.decompress)(e), S = hP(f, t);
  if (!S)
    return !1;
  try {
    return (0, Zp.verifyExistence)(S, n, r, t, i), !0;
  } catch {
    return !1;
  }
}
nt.verifyMembership = Yp;
function Xp(e, n, r, t) {
  const i = (0, ss.decompress)(e), f = yP(i, t);
  if (!f)
    return !1;
  try {
    return (0, Zp.verifyNonExistence)(f, n, r, t), !0;
  } catch {
    return !1;
  }
}
nt.verifyNonMembership = Xp;
function fP(e, n, r, t) {
  const i = (0, ss.decompress)(e);
  for (const [f, S] of t.entries())
    if (!Yp(i, n, r, f, S))
      return !1;
  return !0;
}
nt.batchVerifyMembership = fP;
function pP(e, n, r, t) {
  const i = (0, ss.decompress)(e);
  for (const f of t)
    if (!Xp(i, n, r, f))
      return !1;
  return !0;
}
nt.batchVerifyNonMembership = pP;
function hP(e, n) {
  const r = (t) => !!t && (0, ju.bytesEqual)(n, t.key);
  if (r(e.exist))
    return e.exist;
  if (e.batch)
    return e.batch.entries.map((t) => t.exist || null).find(r);
}
function yP(e, n) {
  const r = (t) => !!t && (!t.left || (0, ju.bytesBefore)(t.left.key, n)) && (!t.right || (0, ju.bytesBefore)(n, t.right.key));
  if (r(e.nonexist))
    return e.nonexist;
  if (e.batch)
    return e.batch.entries.map((t) => t.nonexist || null).find(r);
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.verifyNonExistence = e.verifyExistence = e.tendermintSpec = e.iavlSpec = e.calculateExistenceRoot = e.verifyNonMembership = e.verifyMembership = e.ics23 = void 0;
  var n = os;
  Object.defineProperty(e, "ics23", { enumerable: !0, get: function() {
    return n.ics23;
  } });
  var r = nt;
  Object.defineProperty(e, "verifyMembership", { enumerable: !0, get: function() {
    return r.verifyMembership;
  } }), Object.defineProperty(e, "verifyNonMembership", { enumerable: !0, get: function() {
    return r.verifyNonMembership;
  } });
  var t = Ne;
  Object.defineProperty(e, "calculateExistenceRoot", { enumerable: !0, get: function() {
    return t.calculateExistenceRoot;
  } }), Object.defineProperty(e, "iavlSpec", { enumerable: !0, get: function() {
    return t.iavlSpec;
  } }), Object.defineProperty(e, "tendermintSpec", { enumerable: !0, get: function() {
    return t.tendermintSpec;
  } }), Object.defineProperty(e, "verifyExistence", { enumerable: !0, get: function() {
    return t.verifyExistence;
  } }), Object.defineProperty(e, "verifyNonExistence", { enumerable: !0, get: function() {
    return t.verifyNonExistence;
  } });
})(Qp);
var Ao = {}, ds = {}, qe = {}, jp = {};
(function(e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.default = n;
  function n(r) {
    var t, i = r.Symbol;
    if (typeof i == "function")
      if (i.observable)
        t = i.observable;
      else {
        t = i.for("https://github.com/benlesh/symbol-observable");
        try {
          i.observable = t;
        } catch {
        }
      }
    else
      t = "@@observable";
    return t;
  }
})(jp);
var mP = jp, Zl = Object.prototype.toString, eh = function(n) {
  var r = Zl.call(n), t = r === "[object Arguments]";
  return t || (t = r !== "[object Array]" && n !== null && typeof n == "object" && typeof n.length == "number" && n.length >= 0 && Zl.call(n.callee) === "[object Function]"), t;
}, Zd, Yl;
function gP() {
  if (Yl) return Zd;
  Yl = 1;
  var e;
  if (!Object.keys) {
    var n = Object.prototype.hasOwnProperty, r = Object.prototype.toString, t = eh, i = Object.prototype.propertyIsEnumerable, f = !i.call({ toString: null }, "toString"), S = i.call(function() {
    }, "prototype"), w = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ], T = function(p) {
      var m = p.constructor;
      return m && m.prototype === p;
    }, J = {
      $applicationCache: !0,
      $console: !0,
      $external: !0,
      $frame: !0,
      $frameElement: !0,
      $frames: !0,
      $innerHeight: !0,
      $innerWidth: !0,
      $onmozfullscreenchange: !0,
      $onmozfullscreenerror: !0,
      $outerHeight: !0,
      $outerWidth: !0,
      $pageXOffset: !0,
      $pageYOffset: !0,
      $parent: !0,
      $scrollLeft: !0,
      $scrollTop: !0,
      $scrollX: !0,
      $scrollY: !0,
      $self: !0,
      $webkitIndexedDB: !0,
      $webkitStorageInfo: !0,
      $window: !0
    }, C = function() {
      if (typeof window > "u")
        return !1;
      for (var p in window)
        try {
          if (!J["$" + p] && n.call(window, p) && window[p] !== null && typeof window[p] == "object")
            try {
              T(window[p]);
            } catch {
              return !0;
            }
        } catch {
          return !0;
        }
      return !1;
    }(), R = function(p) {
      if (typeof window > "u" || !C)
        return T(p);
      try {
        return T(p);
      } catch {
        return !1;
      }
    };
    e = function(m) {
      var v = m !== null && typeof m == "object", a = r.call(m) === "[object Function]", d = t(m), y = v && r.call(m) === "[object String]", _ = [];
      if (!v && !a && !d)
        throw new TypeError("Object.keys called on a non-object");
      var E = S && a;
      if (y && m.length > 0 && !n.call(m, 0))
        for (var U = 0; U < m.length; ++U)
          _.push(String(U));
      if (d && m.length > 0)
        for (var V = 0; V < m.length; ++V)
          _.push(String(V));
      else
        for (var o in m)
          !(E && o === "prototype") && n.call(m, o) && _.push(String(o));
      if (f)
        for (var h = R(m), N = 0; N < w.length; ++N)
          !(h && w[N] === "constructor") && n.call(m, w[N]) && _.push(w[N]);
      return _;
    };
  }
  return Zd = e, Zd;
}
var SP = Array.prototype.slice, kP = eh, Xl = Object.keys, ca = Xl ? function(n) {
  return Xl(n);
} : gP(), jl = Object.keys;
ca.shim = function() {
  if (Object.keys) {
    var n = function() {
      var r = Object.keys(arguments);
      return r && r.length === arguments.length;
    }(1, 2);
    n || (Object.keys = function(t) {
      return kP(t) ? jl(SP.call(t)) : jl(t);
    });
  } else
    Object.keys = ca;
  return Object.keys || ca;
};
var PP = ca, vP = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var n = {}, r = Symbol("test"), t = Object(r);
  if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(t) !== "[object Symbol]")
    return !1;
  var i = 42;
  n[r] = i;
  for (r in n)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(n).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(n).length !== 0)
    return !1;
  var f = Object.getOwnPropertySymbols(n);
  if (f.length !== 1 || f[0] !== r || !Object.prototype.propertyIsEnumerable.call(n, r))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var S = Object.getOwnPropertyDescriptor(n, r);
    if (S.value !== i || S.enumerable !== !0)
      return !1;
  }
  return !0;
}, ef = typeof Symbol < "u" && Symbol, bP = vP, RP = function() {
  return typeof ef != "function" || typeof Symbol != "function" || typeof ef("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : bP();
}, nf = {
  foo: {}
}, BP = Object, OP = function() {
  return { __proto__: nf }.foo === nf.foo && !({ __proto__: null } instanceof BP);
}, AP = "Function.prototype.bind called on incompatible ", IP = Object.prototype.toString, TP = Math.max, wP = "[object Function]", tf = function(n, r) {
  for (var t = [], i = 0; i < n.length; i += 1)
    t[i] = n[i];
  for (var f = 0; f < r.length; f += 1)
    t[f + n.length] = r[f];
  return t;
}, CP = function(n, r) {
  for (var t = [], i = r, f = 0; i < n.length; i += 1, f += 1)
    t[f] = n[i];
  return t;
}, NP = function(e, n) {
  for (var r = "", t = 0; t < e.length; t += 1)
    r += e[t], t + 1 < e.length && (r += n);
  return r;
}, _P = function(n) {
  var r = this;
  if (typeof r != "function" || IP.apply(r) !== wP)
    throw new TypeError(AP + r);
  for (var t = CP(arguments, 1), i, f = function() {
    if (this instanceof i) {
      var C = r.apply(
        this,
        tf(t, arguments)
      );
      return Object(C) === C ? C : this;
    }
    return r.apply(
      n,
      tf(t, arguments)
    );
  }, S = TP(0, r.length - t.length), w = [], T = 0; T < S; T++)
    w[T] = "$" + T;
  if (i = Function("binder", "return function (" + NP(w, ",") + "){ return binder.apply(this,arguments); }")(f), r.prototype) {
    var J = function() {
    };
    J.prototype = r.prototype, i.prototype = new J(), J.prototype = null;
  }
  return i;
}, EP = _P, nh = Function.prototype.bind || EP, UP = nh, JP = UP.call(Function.call, Object.prototype.hasOwnProperty), ye, ci = SyntaxError, th = Function, Er = TypeError, Yd = function(e) {
  try {
    return th('"use strict"; return (' + e + ").constructor;")();
  } catch {
  }
}, er = Object.getOwnPropertyDescriptor;
if (er)
  try {
    er({}, "");
  } catch {
    er = null;
  }
var Xd = function() {
  throw new Er();
}, DP = er ? function() {
  try {
    return arguments.callee, Xd;
  } catch {
    try {
      return er(arguments, "callee").get;
    } catch {
      return Xd;
    }
  }
}() : Xd, hr = RP(), MP = OP(), Ue = Object.getPrototypeOf || (MP ? function(e) {
  return e.__proto__;
} : null), kr = {}, HP = typeof Uint8Array > "u" || !Ue ? ye : Ue(Uint8Array), nr = {
  "%AggregateError%": typeof AggregateError > "u" ? ye : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? ye : ArrayBuffer,
  "%ArrayIteratorPrototype%": hr && Ue ? Ue([][Symbol.iterator]()) : ye,
  "%AsyncFromSyncIteratorPrototype%": ye,
  "%AsyncFunction%": kr,
  "%AsyncGenerator%": kr,
  "%AsyncGeneratorFunction%": kr,
  "%AsyncIteratorPrototype%": kr,
  "%Atomics%": typeof Atomics > "u" ? ye : Atomics,
  "%BigInt%": typeof BigInt > "u" ? ye : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? ye : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? ye : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? ye : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? ye : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? ye : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? ye : FinalizationRegistry,
  "%Function%": th,
  "%GeneratorFunction%": kr,
  "%Int8Array%": typeof Int8Array > "u" ? ye : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? ye : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? ye : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hr && Ue ? Ue(Ue([][Symbol.iterator]())) : ye,
  "%JSON%": typeof JSON == "object" ? JSON : ye,
  "%Map%": typeof Map > "u" ? ye : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !hr || !Ue ? ye : Ue((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? ye : Promise,
  "%Proxy%": typeof Proxy > "u" ? ye : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? ye : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? ye : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !hr || !Ue ? ye : Ue((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? ye : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hr && Ue ? Ue(""[Symbol.iterator]()) : ye,
  "%Symbol%": hr ? Symbol : ye,
  "%SyntaxError%": ci,
  "%ThrowTypeError%": DP,
  "%TypedArray%": HP,
  "%TypeError%": Er,
  "%Uint8Array%": typeof Uint8Array > "u" ? ye : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? ye : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? ye : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? ye : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap > "u" ? ye : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? ye : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? ye : WeakSet
};
if (Ue)
  try {
    null.error;
  } catch (e) {
    var qP = Ue(Ue(e));
    nr["%Error.prototype%"] = qP;
  }
var VP = function e(n) {
  var r;
  if (n === "%AsyncFunction%")
    r = Yd("async function () {}");
  else if (n === "%GeneratorFunction%")
    r = Yd("function* () {}");
  else if (n === "%AsyncGeneratorFunction%")
    r = Yd("async function* () {}");
  else if (n === "%AsyncGenerator%") {
    var t = e("%AsyncGeneratorFunction%");
    t && (r = t.prototype);
  } else if (n === "%AsyncIteratorPrototype%") {
    var i = e("%AsyncGenerator%");
    i && Ue && (r = Ue(i.prototype));
  }
  return nr[n] = r, r;
}, rf = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, Io = nh, Ba = JP, WP = Io.call(Function.call, Array.prototype.concat), QP = Io.call(Function.apply, Array.prototype.splice), of = Io.call(Function.call, String.prototype.replace), Oa = Io.call(Function.call, String.prototype.slice), FP = Io.call(Function.call, RegExp.prototype.exec), $P = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, LP = /\\(\\)?/g, GP = function(n) {
  var r = Oa(n, 0, 1), t = Oa(n, -1);
  if (r === "%" && t !== "%")
    throw new ci("invalid intrinsic syntax, expected closing `%`");
  if (t === "%" && r !== "%")
    throw new ci("invalid intrinsic syntax, expected opening `%`");
  var i = [];
  return of(n, $P, function(f, S, w, T) {
    i[i.length] = w ? of(T, LP, "$1") : S || f;
  }), i;
}, KP = function(n, r) {
  var t = n, i;
  if (Ba(rf, t) && (i = rf[t], t = "%" + i[0] + "%"), Ba(nr, t)) {
    var f = nr[t];
    if (f === kr && (f = VP(t)), typeof f > "u" && !r)
      throw new Er("intrinsic " + n + " exists, but is not available. Please file an issue!");
    return {
      alias: i,
      name: t,
      value: f
    };
  }
  throw new ci("intrinsic " + n + " does not exist!");
}, zP = function(n, r) {
  if (typeof n != "string" || n.length === 0)
    throw new Er("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof r != "boolean")
    throw new Er('"allowMissing" argument must be a boolean');
  if (FP(/^%?[^%]*%?$/, n) === null)
    throw new ci("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var t = GP(n), i = t.length > 0 ? t[0] : "", f = KP("%" + i + "%", r), S = f.name, w = f.value, T = !1, J = f.alias;
  J && (i = J[0], QP(t, WP([0, 1], J)));
  for (var C = 1, R = !0; C < t.length; C += 1) {
    var p = t[C], m = Oa(p, 0, 1), v = Oa(p, -1);
    if ((m === '"' || m === "'" || m === "`" || v === '"' || v === "'" || v === "`") && m !== v)
      throw new ci("property names with quotes must have matching quotes");
    if ((p === "constructor" || !R) && (T = !0), i += "." + p, S = "%" + i + "%", Ba(nr, S))
      w = nr[S];
    else if (w != null) {
      if (!(p in w)) {
        if (!r)
          throw new Er("base intrinsic for " + n + " exists, but the property is not available.");
        return;
      }
      if (er && C + 1 >= t.length) {
        var a = er(w, p);
        R = !!a, R && "get" in a && !("originalValue" in a.get) ? w = a.get : w = w[p];
      } else
        R = Ba(w, p), w = w[p];
      R && !T && (nr[S] = w);
    }
  }
  return w;
}, xP = zP, ec = xP("%Object.defineProperty%", !0), nc = function() {
  if (ec)
    try {
      return ec({}, "a", { value: 1 }), !0;
    } catch {
      return !1;
    }
  return !1;
};
nc.hasArrayLengthDefineBug = function() {
  if (!nc())
    return null;
  try {
    return ec([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var ZP = nc, YP = PP, XP = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", jP = Object.prototype.toString, ev = Array.prototype.concat, rh = Object.defineProperty, nv = function(e) {
  return typeof e == "function" && jP.call(e) === "[object Function]";
}, tv = ZP(), ih = rh && tv, rv = function(e, n, r, t) {
  if (n in e) {
    if (t === !0) {
      if (e[n] === r)
        return;
    } else if (!nv(t) || !t())
      return;
  }
  ih ? rh(e, n, {
    configurable: !0,
    enumerable: !1,
    value: r,
    writable: !0
  }) : e[n] = r;
}, oh = function(e, n) {
  var r = arguments.length > 2 ? arguments[2] : {}, t = YP(n);
  XP && (t = ev.call(t, Object.getOwnPropertySymbols(n)));
  for (var i = 0; i < t.length; i += 1)
    rv(e, t[i], n[t[i]], r[t[i]]);
};
oh.supportsDescriptors = !!ih;
var ah = oh, la = { exports: {} };
typeof self < "u" ? la.exports = self : typeof window < "u" ? la.exports = window : la.exports = Function("return this")();
var sh = la.exports, iv = sh, dh = function() {
  return typeof x != "object" || !x || x.Math !== Math || x.Array !== Array ? iv : x;
}, ov = ah, av = dh, sv = function() {
  var n = av();
  if (ov.supportsDescriptors) {
    var r = Object.getOwnPropertyDescriptor(n, "globalThis");
    (!r || r.configurable && (r.enumerable || !r.writable || globalThis !== n)) && Object.defineProperty(n, "globalThis", {
      configurable: !0,
      enumerable: !1,
      value: n,
      writable: !0
    });
  } else (typeof globalThis != "object" || globalThis !== n) && (n.globalThis = n);
  return n;
}, dv = ah, uv = sh, uh = dh, cv = sv, lv = uh(), ch = function() {
  return lv;
};
dv(ch, {
  getPolyfill: uh,
  implementation: uv,
  shim: cv
});
var fv = ch, pv = x && x.__extends || /* @__PURE__ */ function() {
  var e = function(n, r) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, i) {
      t.__proto__ = i;
    } || function(t, i) {
      for (var f in i) i.hasOwnProperty(f) && (t[f] = i[f]);
    }, e(n, r);
  };
  return function(n, r) {
    e(n, r);
    function t() {
      this.constructor = n;
    }
    n.prototype = r === null ? Object.create(r) : (t.prototype = r.prototype, new t());
  };
}();
Object.defineProperty(qe, "__esModule", { value: !0 });
qe.NO_IL = qe.NO = qe.MemoryStream = qe.Stream = void 0;
var hv = mP, yv = fv, $o = hv.default(yv.getPolyfill()), ee = {};
qe.NO = ee;
function Fe() {
}
function fa(e) {
  for (var n = e.length, r = Array(n), t = 0; t < n; ++t)
    r[t] = e[t];
  return r;
}
function mv(e, n) {
  return function(t) {
    return e(t) && n(t);
  };
}
function Vc(e, n, r) {
  try {
    return e.f(n);
  } catch (t) {
    return r._e(t), ee;
  }
}
var Xt = {
  _n: Fe,
  _e: Fe,
  _c: Fe
};
qe.NO_IL = Xt;
function af(e) {
  e._start = function(r) {
    r.next = r._n, r.error = r._e, r.complete = r._c, this.start(r);
  }, e._stop = e.stop;
}
var gv = (
  /** @class */
  function() {
    function e(n, r) {
      this._stream = n, this._listener = r;
    }
    return e.prototype.unsubscribe = function() {
      this._stream._remove(this._listener);
    }, e;
  }()
), Sv = (
  /** @class */
  function() {
    function e(n) {
      this._listener = n;
    }
    return e.prototype.next = function(n) {
      this._listener._n(n);
    }, e.prototype.error = function(n) {
      this._listener._e(n);
    }, e.prototype.complete = function() {
      this._listener._c();
    }, e;
  }()
), kv = (
  /** @class */
  function() {
    function e(n) {
      this.type = "fromObservable", this.ins = n, this.active = !1;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.active = !0, this._sub = this.ins.subscribe(new Sv(n)), this.active || this._sub.unsubscribe();
    }, e.prototype._stop = function() {
      this._sub && this._sub.unsubscribe(), this.active = !1;
    }, e;
  }()
), Pv = (
  /** @class */
  function() {
    function e(n) {
      this.type = "merge", this.insArr = n, this.out = ee, this.ac = 0;
    }
    return e.prototype._start = function(n) {
      this.out = n;
      var r = this.insArr, t = r.length;
      this.ac = t;
      for (var i = 0; i < t; i++)
        r[i]._add(this);
    }, e.prototype._stop = function() {
      for (var n = this.insArr, r = n.length, t = 0; t < r; t++)
        n[t]._remove(this);
      this.out = ee;
    }, e.prototype._n = function(n) {
      var r = this.out;
      r !== ee && r._n(n);
    }, e.prototype._e = function(n) {
      var r = this.out;
      r !== ee && r._e(n);
    }, e.prototype._c = function() {
      if (--this.ac <= 0) {
        var n = this.out;
        if (n === ee)
          return;
        n._c();
      }
    }, e;
  }()
), vv = (
  /** @class */
  function() {
    function e(n, r, t) {
      this.i = n, this.out = r, this.p = t, t.ils.push(this);
    }
    return e.prototype._n = function(n) {
      var r = this.p, t = this.out;
      if (t !== ee && r.up(n, this.i)) {
        var i = fa(r.vals);
        t._n(i);
      }
    }, e.prototype._e = function(n) {
      var r = this.out;
      r !== ee && r._e(n);
    }, e.prototype._c = function() {
      var n = this.p;
      n.out !== ee && --n.Nc === 0 && n.out._c();
    }, e;
  }()
), bv = (
  /** @class */
  function() {
    function e(n) {
      this.type = "combine", this.insArr = n, this.out = ee, this.ils = [], this.Nc = this.Nn = 0, this.vals = [];
    }
    return e.prototype.up = function(n, r) {
      var t = this.vals[r], i = this.Nn ? t === ee ? --this.Nn : this.Nn : 0;
      return this.vals[r] = n, i === 0;
    }, e.prototype._start = function(n) {
      this.out = n;
      var r = this.insArr, t = this.Nc = this.Nn = r.length, i = this.vals = new Array(t);
      if (t === 0)
        n._n([]), n._c();
      else
        for (var f = 0; f < t; f++)
          i[f] = ee, r[f]._add(new vv(f, n, this));
    }, e.prototype._stop = function() {
      for (var n = this.insArr, r = n.length, t = this.ils, i = 0; i < r; i++)
        n[i]._remove(t[i]);
      this.out = ee, this.ils = [], this.vals = [];
    }, e;
  }()
), Rv = (
  /** @class */
  function() {
    function e(n) {
      this.type = "fromArray", this.a = n;
    }
    return e.prototype._start = function(n) {
      for (var r = this.a, t = 0, i = r.length; t < i; t++)
        n._n(r[t]);
      n._c();
    }, e.prototype._stop = function() {
    }, e;
  }()
), Bv = (
  /** @class */
  function() {
    function e(n) {
      this.type = "fromPromise", this.on = !1, this.p = n;
    }
    return e.prototype._start = function(n) {
      var r = this;
      this.on = !0, this.p.then(function(t) {
        r.on && (n._n(t), n._c());
      }, function(t) {
        n._e(t);
      }).then(Fe, function(t) {
        setTimeout(function() {
          throw t;
        });
      });
    }, e.prototype._stop = function() {
      this.on = !1;
    }, e;
  }()
), Ov = (
  /** @class */
  function() {
    function e(n) {
      this.type = "periodic", this.period = n, this.intervalID = -1, this.i = 0;
    }
    return e.prototype._start = function(n) {
      var r = this;
      function t() {
        n._n(r.i++);
      }
      this.intervalID = setInterval(t, this.period);
    }, e.prototype._stop = function() {
      this.intervalID !== -1 && clearInterval(this.intervalID), this.intervalID = -1, this.i = 0;
    }, e;
  }()
), Av = (
  /** @class */
  function() {
    function e(n, r) {
      this.type = "debug", this.ins = n, this.out = ee, this.s = Fe, this.l = "", typeof r == "string" ? this.l = r : typeof r == "function" && (this.s = r);
    }
    return e.prototype._start = function(n) {
      this.out = n, this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = ee;
    }, e.prototype._n = function(n) {
      var r = this.out;
      if (r !== ee) {
        var t = this.s, i = this.l;
        if (t !== Fe)
          try {
            t(n);
          } catch (f) {
            r._e(f);
          }
        r._n(n);
      }
    }, e.prototype._e = function(n) {
      var r = this.out;
      r !== ee && r._e(n);
    }, e.prototype._c = function() {
      var n = this.out;
      n !== ee && n._c();
    }, e;
  }()
), Iv = (
  /** @class */
  function() {
    function e(n, r) {
      this.type = "drop", this.ins = r, this.out = ee, this.max = n, this.dropped = 0;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.dropped = 0, this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = ee;
    }, e.prototype._n = function(n) {
      var r = this.out;
      r !== ee && this.dropped++ >= this.max && r._n(n);
    }, e.prototype._e = function(n) {
      var r = this.out;
      r !== ee && r._e(n);
    }, e.prototype._c = function() {
      var n = this.out;
      n !== ee && n._c();
    }, e;
  }()
), Tv = (
  /** @class */
  function() {
    function e(n, r) {
      this.out = n, this.op = r;
    }
    return e.prototype._n = function() {
      this.op.end();
    }, e.prototype._e = function(n) {
      this.out._e(n);
    }, e.prototype._c = function() {
      this.op.end();
    }, e;
  }()
), wv = (
  /** @class */
  function() {
    function e(n, r) {
      this.type = "endWhen", this.ins = r, this.out = ee, this.o = n, this.oil = Xt;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.o._add(this.oil = new Tv(n, this)), this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.o._remove(this.oil), this.out = ee, this.oil = Xt;
    }, e.prototype.end = function() {
      var n = this.out;
      n !== ee && n._c();
    }, e.prototype._n = function(n) {
      var r = this.out;
      r !== ee && r._n(n);
    }, e.prototype._e = function(n) {
      var r = this.out;
      r !== ee && r._e(n);
    }, e.prototype._c = function() {
      this.end();
    }, e;
  }()
), jd = (
  /** @class */
  function() {
    function e(n, r) {
      this.type = "filter", this.ins = r, this.out = ee, this.f = n;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = ee;
    }, e.prototype._n = function(n) {
      var r = this.out;
      if (r !== ee) {
        var t = Vc(this, n, r);
        t === ee || !t || r._n(n);
      }
    }, e.prototype._e = function(n) {
      var r = this.out;
      r !== ee && r._e(n);
    }, e.prototype._c = function() {
      var n = this.out;
      n !== ee && n._c();
    }, e;
  }()
), Cv = (
  /** @class */
  function() {
    function e(n, r) {
      this.out = n, this.op = r;
    }
    return e.prototype._n = function(n) {
      this.out._n(n);
    }, e.prototype._e = function(n) {
      this.out._e(n);
    }, e.prototype._c = function() {
      this.op.inner = ee, this.op.less();
    }, e;
  }()
), Nv = (
  /** @class */
  function() {
    function e(n) {
      this.type = "flatten", this.ins = n, this.out = ee, this.open = !0, this.inner = ee, this.il = Xt;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.open = !0, this.inner = ee, this.il = Xt, this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.inner !== ee && this.inner._remove(this.il), this.out = ee, this.open = !0, this.inner = ee, this.il = Xt;
    }, e.prototype.less = function() {
      var n = this.out;
      n !== ee && !this.open && this.inner === ee && n._c();
    }, e.prototype._n = function(n) {
      var r = this.out;
      if (r !== ee) {
        var t = this, i = t.inner, f = t.il;
        i !== ee && f !== Xt && i._remove(f), (this.inner = n)._add(this.il = new Cv(r, this));
      }
    }, e.prototype._e = function(n) {
      var r = this.out;
      r !== ee && r._e(n);
    }, e.prototype._c = function() {
      this.open = !1, this.less();
    }, e;
  }()
), _v = (
  /** @class */
  function() {
    function e(n, r, t) {
      var i = this;
      this.type = "fold", this.ins = t, this.out = ee, this.f = function(f) {
        return n(i.acc, f);
      }, this.acc = this.seed = r;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.acc = this.seed, n._n(this.acc), this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = ee, this.acc = this.seed;
    }, e.prototype._n = function(n) {
      var r = this.out;
      if (r !== ee) {
        var t = Vc(this, n, r);
        t !== ee && r._n(this.acc = t);
      }
    }, e.prototype._e = function(n) {
      var r = this.out;
      r !== ee && r._e(n);
    }, e.prototype._c = function() {
      var n = this.out;
      n !== ee && n._c();
    }, e;
  }()
), Ev = (
  /** @class */
  function() {
    function e(n) {
      this.type = "last", this.ins = n, this.out = ee, this.has = !1, this.val = ee;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.has = !1, this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = ee, this.val = ee;
    }, e.prototype._n = function(n) {
      this.has = !0, this.val = n;
    }, e.prototype._e = function(n) {
      var r = this.out;
      r !== ee && r._e(n);
    }, e.prototype._c = function() {
      var n = this.out;
      n !== ee && (this.has ? (n._n(this.val), n._c()) : n._e(new Error("last() failed because input stream completed")));
    }, e;
  }()
), Uv = (
  /** @class */
  function() {
    function e(n, r) {
      this.type = "map", this.ins = r, this.out = ee, this.f = n;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = ee;
    }, e.prototype._n = function(n) {
      var r = this.out;
      if (r !== ee) {
        var t = Vc(this, n, r);
        t !== ee && r._n(t);
      }
    }, e.prototype._e = function(n) {
      var r = this.out;
      r !== ee && r._e(n);
    }, e.prototype._c = function() {
      var n = this.out;
      n !== ee && n._c();
    }, e;
  }()
), Jv = (
  /** @class */
  function() {
    function e(n) {
      this.type = "remember", this.ins = n, this.out = ee;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.ins._add(n);
    }, e.prototype._stop = function() {
      this.ins._remove(this.out), this.out = ee;
    }, e;
  }()
), Dv = (
  /** @class */
  function() {
    function e(n, r) {
      this.type = "replaceError", this.ins = r, this.out = ee, this.f = n;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = ee;
    }, e.prototype._n = function(n) {
      var r = this.out;
      r !== ee && r._n(n);
    }, e.prototype._e = function(n) {
      var r = this.out;
      if (r !== ee)
        try {
          this.ins._remove(this), (this.ins = this.f(n))._add(this);
        } catch (t) {
          r._e(t);
        }
    }, e.prototype._c = function() {
      var n = this.out;
      n !== ee && n._c();
    }, e;
  }()
), Mv = (
  /** @class */
  function() {
    function e(n, r) {
      this.type = "startWith", this.ins = n, this.out = ee, this.val = r;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.out._n(this.val), this.ins._add(n);
    }, e.prototype._stop = function() {
      this.ins._remove(this.out), this.out = ee;
    }, e;
  }()
), Hv = (
  /** @class */
  function() {
    function e(n, r) {
      this.type = "take", this.ins = r, this.out = ee, this.max = n, this.taken = 0;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.taken = 0, this.max <= 0 ? n._c() : this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = ee;
    }, e.prototype._n = function(n) {
      var r = this.out;
      if (r !== ee) {
        var t = ++this.taken;
        t < this.max ? r._n(n) : t === this.max && (r._n(n), r._c());
      }
    }, e.prototype._e = function(n) {
      var r = this.out;
      r !== ee && r._e(n);
    }, e.prototype._c = function() {
      var n = this.out;
      n !== ee && n._c();
    }, e;
  }()
), Wc = (
  /** @class */
  function() {
    function e(n) {
      this._prod = n || ee, this._ils = [], this._stopID = ee, this._dl = ee, this._d = !1, this._target = null, this._err = ee;
    }
    return e.prototype._n = function(n) {
      var r = this._ils, t = r.length;
      if (this._d && this._dl._n(n), t == 1)
        r[0]._n(n);
      else {
        if (t == 0)
          return;
        for (var i = fa(r), f = 0; f < t; f++)
          i[f]._n(n);
      }
    }, e.prototype._e = function(n) {
      if (this._err === ee) {
        this._err = n;
        var r = this._ils, t = r.length;
        if (this._x(), this._d && this._dl._e(n), t == 1)
          r[0]._e(n);
        else {
          if (t == 0)
            return;
          for (var i = fa(r), f = 0; f < t; f++)
            i[f]._e(n);
        }
        if (!this._d && t == 0)
          throw this._err;
      }
    }, e.prototype._c = function() {
      var n = this._ils, r = n.length;
      if (this._x(), this._d && this._dl._c(), r == 1)
        n[0]._c();
      else {
        if (r == 0)
          return;
        for (var t = fa(n), i = 0; i < r; i++)
          t[i]._c();
      }
    }, e.prototype._x = function() {
      this._ils.length !== 0 && (this._prod !== ee && this._prod._stop(), this._err = ee, this._ils = []);
    }, e.prototype._stopNow = function() {
      this._prod._stop(), this._err = ee, this._stopID = ee;
    }, e.prototype._add = function(n) {
      var r = this._target;
      if (r)
        return r._add(n);
      var t = this._ils;
      if (t.push(n), !(t.length > 1))
        if (this._stopID !== ee)
          clearTimeout(this._stopID), this._stopID = ee;
        else {
          var i = this._prod;
          i !== ee && i._start(this);
        }
    }, e.prototype._remove = function(n) {
      var r = this, t = this._target;
      if (t)
        return t._remove(n);
      var i = this._ils, f = i.indexOf(n);
      f > -1 && (i.splice(f, 1), this._prod !== ee && i.length <= 0 ? (this._err = ee, this._stopID = setTimeout(function() {
        return r._stopNow();
      })) : i.length === 1 && this._pruneCycles());
    }, e.prototype._pruneCycles = function() {
      this._hasNoSinks(this, []) && this._remove(this._ils[0]);
    }, e.prototype._hasNoSinks = function(n, r) {
      if (r.indexOf(n) !== -1)
        return !0;
      if (n.out === this)
        return !0;
      if (n.out && n.out !== ee)
        return this._hasNoSinks(n.out, r.concat(n));
      if (n._ils) {
        for (var t = 0, i = n._ils.length; t < i; t++)
          if (!this._hasNoSinks(n._ils[t], r.concat(n)))
            return !1;
        return !0;
      } else
        return !1;
    }, e.prototype.ctor = function() {
      return this instanceof Pt ? Pt : e;
    }, e.prototype.addListener = function(n) {
      n._n = n.next || Fe, n._e = n.error || Fe, n._c = n.complete || Fe, this._add(n);
    }, e.prototype.removeListener = function(n) {
      this._remove(n);
    }, e.prototype.subscribe = function(n) {
      return this.addListener(n), new gv(this, n);
    }, e.prototype[$o] = function() {
      return this;
    }, e.create = function(n) {
      if (n) {
        if (typeof n.start != "function" || typeof n.stop != "function")
          throw new Error("producer requires both start and stop functions");
        af(n);
      }
      return new e(n);
    }, e.createWithMemory = function(n) {
      return n && af(n), new Pt(n);
    }, e.never = function() {
      return new e({ _start: Fe, _stop: Fe });
    }, e.empty = function() {
      return new e({
        _start: function(n) {
          n._c();
        },
        _stop: Fe
      });
    }, e.throw = function(n) {
      return new e({
        _start: function(r) {
          r._e(n);
        },
        _stop: Fe
      });
    }, e.from = function(n) {
      if (typeof n[$o] == "function")
        return e.fromObservable(n);
      if (typeof n.then == "function")
        return e.fromPromise(n);
      if (Array.isArray(n))
        return e.fromArray(n);
      throw new TypeError("Type of input to from() must be an Array, Promise, or Observable");
    }, e.of = function() {
      for (var n = [], r = 0; r < arguments.length; r++)
        n[r] = arguments[r];
      return e.fromArray(n);
    }, e.fromArray = function(n) {
      return new e(new Rv(n));
    }, e.fromPromise = function(n) {
      return new e(new Bv(n));
    }, e.fromObservable = function(n) {
      if (n.endWhen !== void 0)
        return n;
      var r = typeof n[$o] == "function" ? n[$o]() : n;
      return new e(new kv(r));
    }, e.periodic = function(n) {
      return new e(new Ov(n));
    }, e.prototype._map = function(n) {
      return new (this.ctor())(new Uv(n, this));
    }, e.prototype.map = function(n) {
      return this._map(n);
    }, e.prototype.mapTo = function(n) {
      var r = this.map(function() {
        return n;
      }), t = r._prod;
      return t.type = "mapTo", r;
    }, e.prototype.filter = function(n) {
      var r = this._prod;
      return r instanceof jd ? new e(new jd(mv(r.f, n), r.ins)) : new e(new jd(n, this));
    }, e.prototype.take = function(n) {
      return new (this.ctor())(new Hv(n, this));
    }, e.prototype.drop = function(n) {
      return new e(new Iv(n, this));
    }, e.prototype.last = function() {
      return new e(new Ev(this));
    }, e.prototype.startWith = function(n) {
      return new Pt(new Mv(this, n));
    }, e.prototype.endWhen = function(n) {
      return new (this.ctor())(new wv(n, this));
    }, e.prototype.fold = function(n, r) {
      return new Pt(new _v(n, r, this));
    }, e.prototype.replaceError = function(n) {
      return new (this.ctor())(new Dv(n, this));
    }, e.prototype.flatten = function() {
      return new e(new Nv(this));
    }, e.prototype.compose = function(n) {
      return n(this);
    }, e.prototype.remember = function() {
      return new Pt(new Jv(this));
    }, e.prototype.debug = function(n) {
      return new (this.ctor())(new Av(this, n));
    }, e.prototype.imitate = function(n) {
      if (n instanceof Pt)
        throw new Error("A MemoryStream was given to imitate(), but it only supports a Stream. Read more about this restriction here: https://github.com/staltz/xstream#faq");
      this._target = n;
      for (var r = this._ils, t = r.length, i = 0; i < t; i++)
        n._add(r[i]);
      this._ils = [];
    }, e.prototype.shamefullySendNext = function(n) {
      this._n(n);
    }, e.prototype.shamefullySendError = function(n) {
      this._e(n);
    }, e.prototype.shamefullySendComplete = function() {
      this._c();
    }, e.prototype.setDebugListener = function(n) {
      n ? (this._d = !0, n._n = n.next || Fe, n._e = n.error || Fe, n._c = n.complete || Fe, this._dl = n) : (this._d = !1, this._dl = ee);
    }, e.merge = function() {
      for (var r = [], t = 0; t < arguments.length; t++)
        r[t] = arguments[t];
      return new e(new Pv(r));
    }, e.combine = function() {
      for (var r = [], t = 0; t < arguments.length; t++)
        r[t] = arguments[t];
      return new e(new bv(r));
    }, e;
  }()
);
qe.Stream = Wc;
var Pt = (
  /** @class */
  function(e) {
    pv(n, e);
    function n(r) {
      var t = e.call(this, r) || this;
      return t._has = !1, t;
    }
    return n.prototype._n = function(r) {
      this._v = r, this._has = !0, e.prototype._n.call(this, r);
    }, n.prototype._add = function(r) {
      var t = this._target;
      if (t)
        return t._add(r);
      var i = this._ils;
      if (i.push(r), i.length > 1) {
        this._has && r._n(this._v);
        return;
      }
      if (this._stopID !== ee)
        this._has && r._n(this._v), clearTimeout(this._stopID), this._stopID = ee;
      else if (this._has)
        r._n(this._v);
      else {
        var f = this._prod;
        f !== ee && f._start(this);
      }
    }, n.prototype._stopNow = function() {
      this._has = !1, e.prototype._stopNow.call(this);
    }, n.prototype._x = function() {
      this._has = !1, e.prototype._x.call(this);
    }, n.prototype.map = function(r) {
      return this._map(r);
    }, n.prototype.mapTo = function(r) {
      return e.prototype.mapTo.call(this, r);
    }, n.prototype.take = function(r) {
      return e.prototype.take.call(this, r);
    }, n.prototype.endWhen = function(r) {
      return e.prototype.endWhen.call(this, r);
    }, n.prototype.replaceError = function(r) {
      return e.prototype.replaceError.call(this, r);
    }, n.prototype.remember = function() {
      return this;
    }, n.prototype.debug = function(r) {
      return e.prototype.debug.call(this, r);
    }, n;
  }(Wc)
);
qe.MemoryStream = Pt;
var qv = Wc;
qe.default = qv;
Object.defineProperty(ds, "__esModule", { value: !0 });
ds.concat = void 0;
const Vv = qe;
function Wv(...e) {
  const n = new Array(), r = new Array(), t = /* @__PURE__ */ new Set();
  let i = 0;
  function f() {
    for (; n.length > 0; )
      n.shift().unsubscribe();
    r.length = 0, t.clear(), i = 0;
  }
  const S = {
    start: (w) => {
      e.forEach((C) => r.push([]));
      function T(C) {
        for (; ; ) {
          const R = r[C].shift();
          if (R === void 0)
            return;
          w.next(R);
        }
      }
      function J() {
        return i >= e.length;
      }
      if (J()) {
        w.complete();
        return;
      }
      e.forEach((C, R) => {
        n.push(C.subscribe({
          next: (p) => {
            R === i ? w.next(p) : r[R].push(p);
          },
          complete: () => {
            for (t.add(R); t.has(i); )
              T(i), i++;
            J() ? w.complete() : T(i);
          },
          error: (p) => {
            w.error(p), f();
          }
        }));
      });
    },
    stop: () => {
      f();
    }
  };
  return Vv.Stream.create(S);
}
ds.concat = Wv;
var us = {};
Object.defineProperty(us, "__esModule", { value: !0 });
us.DefaultValueProducer = void 0;
class Qv {
  get value() {
    return this.internalValue;
  }
  constructor(n, r) {
    this.callbacks = r, this.internalValue = n;
  }
  /**
   * Update the current value.
   *
   * If producer is active (i.e. someone is listening), this emits an event.
   * If not, just the current value is updated.
   */
  update(n) {
    this.internalValue = n, this.listener && this.listener.next(n);
  }
  /**
   * Produce an error
   */
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  error(n) {
    this.listener && this.listener.error(n);
  }
  /**
   * Called by the stream. Do not call this directly.
   */
  start(n) {
    this.listener = n, n.next(this.internalValue), this.callbacks && this.callbacks.onStarted();
  }
  /**
   * Called by the stream. Do not call this directly.
   */
  stop() {
    this.callbacks && this.callbacks.onStop(), this.listener = void 0;
  }
}
us.DefaultValueProducer = Qv;
var cs = {};
Object.defineProperty(cs, "__esModule", { value: !0 });
cs.dropDuplicates = void 0;
function Fv(e) {
  return (r) => {
    const t = /* @__PURE__ */ new Set();
    return r.filter((f) => !t.has(e(f))).debug((f) => t.add(e(f)));
  };
}
cs.dropDuplicates = Fv;
var Ct = {};
Object.defineProperty(Ct, "__esModule", { value: !0 });
Ct.firstEvent = Ct.toListPromise = Ct.fromListPromise = void 0;
const $v = qe;
function Lv(e) {
  const n = {
    start: (r) => {
      e.then((t) => {
        for (const i of t)
          r.next(i);
        r.complete();
      }).catch((t) => r.error(t));
    },
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    stop: () => {
    }
  };
  return $v.Stream.create(n);
}
Ct.fromListPromise = Lv;
async function lh(e, n) {
  return new Promise((r, t) => {
    if (n === 0) {
      r([]);
      return;
    }
    const i = new Array();
    e.take(n).subscribe({
      next: (f) => {
        i.push(f), i.length === n && r(i);
      },
      complete: () => {
        t(`Stream completed before all events could be collected. Collected ${i.length}, expected ${n}`);
      },
      error: (f) => t(f)
    });
  });
}
Ct.toListPromise = lh;
async function Gv(e) {
  return (await lh(e, 1))[0];
}
Ct.firstEvent = Gv;
var tt = {};
Object.defineProperty(tt, "__esModule", { value: !0 });
tt.lastValue = tt.asArray = tt.countStream = tt.Reducer = void 0;
class ls {
  constructor(n, r, t) {
    this.stream = n, this.reducer = r, this.state = t, this.completed = new Promise((i, f) => {
      const S = this.stream.subscribe({
        next: (w) => {
          this.state = this.reducer(this.state, w);
        },
        complete: () => {
          i(), S.unsubscribe();
        },
        error: (w) => {
          f(w), S.unsubscribe();
        }
      });
    });
  }
  // value returns current materialized state
  value() {
    return this.state;
  }
  // finished resolves on completed stream, rejects on stream error
  async finished() {
    return this.completed;
  }
}
tt.Reducer = ls;
function Kv(e, n) {
  return e + 1;
}
function zv(e) {
  return new ls(e, Kv, 0);
}
tt.countStream = zv;
function xv(e, n) {
  return [...e, n];
}
function Zv(e) {
  return new ls(e, xv, []);
}
tt.asArray = Zv;
function Yv(e, n) {
  return n;
}
function Xv(e) {
  return new ls(e, Yv, void 0);
}
tt.lastValue = Xv;
var fs = {};
Object.defineProperty(fs, "__esModule", { value: !0 });
fs.ValueAndUpdates = void 0;
const jv = qe;
class eb {
  get value() {
    return this.producer.value;
  }
  constructor(n) {
    this.producer = n, this.updates = jv.MemoryStream.createWithMemory(this.producer);
  }
  /**
   * Resolves as soon as search value is found.
   *
   * @param search either a value or a function that must return true when found
   * @returns the value of the update that caused the search match
   */
  async waitFor(n) {
    const r = typeof n == "function" ? n : (t) => t === n;
    return new Promise((t, i) => {
      const f = this.updates.subscribe({
        next: (S) => {
          r(S) && (t(S), setTimeout(() => f.unsubscribe(), 0));
        },
        complete: () => {
          f.unsubscribe(), i("Update stream completed without expected value");
        },
        error: (S) => {
          i(S);
        }
      });
    });
  }
}
fs.ValueAndUpdates = eb;
(function(e) {
  var n = x && x.__createBinding || (Object.create ? function(T, J, C, R) {
    R === void 0 && (R = C);
    var p = Object.getOwnPropertyDescriptor(J, C);
    (!p || ("get" in p ? !J.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return J[C];
    } }), Object.defineProperty(T, R, p);
  } : function(T, J, C, R) {
    R === void 0 && (R = C), T[R] = J[C];
  }), r = x && x.__exportStar || function(T, J) {
    for (var C in T) C !== "default" && !Object.prototype.hasOwnProperty.call(J, C) && n(J, T, C);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ValueAndUpdates = e.toListPromise = e.fromListPromise = e.firstEvent = e.dropDuplicates = e.DefaultValueProducer = e.concat = void 0;
  var t = ds;
  Object.defineProperty(e, "concat", { enumerable: !0, get: function() {
    return t.concat;
  } });
  var i = us;
  Object.defineProperty(e, "DefaultValueProducer", { enumerable: !0, get: function() {
    return i.DefaultValueProducer;
  } });
  var f = cs;
  Object.defineProperty(e, "dropDuplicates", { enumerable: !0, get: function() {
    return f.dropDuplicates;
  } });
  var S = Ct;
  Object.defineProperty(e, "firstEvent", { enumerable: !0, get: function() {
    return S.firstEvent;
  } }), Object.defineProperty(e, "fromListPromise", { enumerable: !0, get: function() {
    return S.fromListPromise;
  } }), Object.defineProperty(e, "toListPromise", { enumerable: !0, get: function() {
    return S.toListPromise;
  } }), r(tt, e);
  var w = fs;
  Object.defineProperty(e, "ValueAndUpdates", { enumerable: !0, get: function() {
    return w.ValueAndUpdates;
  } });
})(Ao);
Object.defineProperty(is, "__esModule", { value: !0 });
is.QueryClient = void 0;
const Kt = Qp, xt = Ke, nb = Ao, tn = Te;
function Lo(e, n, r) {
  if (e.type !== n)
    throw new Error(`Op expected to be ${n}, got "${e.type}`);
  if (!(0, tn.arrayContentEquals)(r, e.key))
    throw new Error(`Proven key different than queried key.
Query: ${(0, xt.toHex)(r)}
Proven: ${(0, xt.toHex)(e.key)}`);
  return Kt.ics23.CommitmentProof.decode(e.data);
}
class Qc {
  static withExtensions(n, ...r) {
    const t = new Qc(n), i = r.map((f) => f(t));
    for (const f of i) {
      (0, tn.assert)((0, tn.isNonNullObject)(f), "Extension must be a non-null object");
      for (const [S, w] of Object.entries(f)) {
        (0, tn.assert)((0, tn.isNonNullObject)(w), `Module must be a non-null object. Found type ${typeof w} for module "${S}".`);
        const T = t[S] || {};
        t[S] = {
          ...T,
          ...w
        };
      }
    }
    return t;
  }
  constructor(n) {
    this.cometClient = n;
  }
  /**
   * Queries the database store with a proof, which is then verified.
   *
   * Please note: the current implementation trusts block headers it gets from the PRC endpoint.
   */
  async queryStoreVerified(n, r, t) {
    const { height: i, proof: f, key: S, value: w } = await this.queryRawProof(n, r, t), T = Lo(f.ops[0], "ics23:iavl", r), J = Lo(f.ops[1], "ics23:simple", (0, xt.toAscii)(n));
    (0, tn.assert)(J.exist), (0, tn.assert)(J.exist.value), !w || w.length === 0 ? ((0, tn.assert)(T.nonexist), (0, Kt.verifyNonExistence)(T.nonexist, Kt.iavlSpec, J.exist.value, r)) : ((0, tn.assert)(T.exist), (0, tn.assert)(T.exist.value), (0, Kt.verifyExistence)(T.exist, Kt.iavlSpec, J.exist.value, r, w));
    const C = await this.getNextHeader(i);
    return (0, Kt.verifyExistence)(J.exist, Kt.tendermintSpec, C.appHash, (0, xt.toAscii)(n), J.exist.value), { key: S, value: w, height: i };
  }
  async queryRawProof(n, r, t) {
    const { key: i, value: f, height: S, proof: w, code: T, log: J } = await this.cometClient.abciQuery({
      // we need the StoreKey for the module, not the module name
      // https://github.com/cosmos/cosmos-sdk/blob/8cab43c8120fec5200c3459cbf4a92017bb6f287/x/auth/types/keys.go#L12
      path: `/store/${n}/key`,
      data: r,
      prove: !0,
      height: t
    });
    if (T)
      throw new Error(`Query failed with (${T}): ${J}`);
    if (!(0, tn.arrayContentEquals)(r, i))
      throw new Error(`Response key ${(0, xt.toHex)(i)} doesn't match query key ${(0, xt.toHex)(r)}`);
    if (!S)
      throw new Error("No query height returned");
    if (!w || w.ops.length !== 2)
      throw new Error(`Expected 2 proof ops, got ${(w == null ? void 0 : w.ops.length) ?? 0}. Are you using stargate?`);
    return Lo(w.ops[0], "ics23:iavl", i), Lo(w.ops[1], "ics23:simple", (0, xt.toAscii)(n)), {
      key: i,
      value: f,
      height: S,
      // need to clone this: readonly input / writeable output
      proof: {
        ops: [...w.ops]
      }
    };
  }
  /**
   * Performs an ABCI query to Tendermint without requesting a proof.
   *
   * If the `desiredHeight` is set, a particular height is requested. Otherwise
   * the latest height is requested. The response contains the actual height of
   * the query.
   */
  async queryAbci(n, r, t) {
    const i = await this.cometClient.abciQuery({
      path: n,
      data: r,
      prove: !1,
      height: t
    });
    if (i.code)
      throw new Error(`Query failed with (${i.code}): ${i.log}`);
    if (!i.height)
      throw new Error("No query height returned");
    return {
      value: i.value,
      height: i.height
    };
  }
  // this must return the header for height+1
  // throws an error if height is 0 or undefined
  async getNextHeader(n) {
    if ((0, tn.assertDefined)(n), n === 0)
      throw new Error("Query returned height 0, cannot prove it");
    const r = n + 1;
    let t, i;
    try {
      i = this.cometClient.subscribeNewBlockHeader();
    } catch {
    }
    if (i) {
      const f = await (0, nb.firstEvent)(i);
      f.height === r && (t = f);
    }
    for (; !t; ) {
      const f = (await this.cometClient.blockchain(n, r)).blockMetas.map((S) => S.header).find((S) => S.height === r);
      f ? t = f : await (0, tn.sleep)(1e3);
    }
    return (0, tn.assert)(t.height === r, "Got wrong header. This is a bug in the logic above."), t;
  }
}
is.QueryClient = Qc;
var In = {};
Object.defineProperty(In, "__esModule", { value: !0 });
In.decodeCosmosSdkDecFromProto = In.longify = In.createProtobufRpcClient = In.createPagination = In.toAccAddress = void 0;
const fh = Ke, ph = Ie, sf = Ae;
function tb(e) {
  return (0, fh.fromBech32)(e).data;
}
In.toAccAddress = tb;
function rb(e) {
  return e ? sf.PageRequest.fromPartial({ key: e }) : sf.PageRequest.fromPartial({});
}
In.createPagination = rb;
function ib(e) {
  return {
    request: async (n, r, t) => {
      const i = `/${n}/${r}`;
      return (await e.queryAbci(i, t, void 0)).value;
    }
  };
}
In.createProtobufRpcClient = ib;
function ob(e) {
  const n = ph.Uint64.fromString(e.toString());
  return BigInt(n.toString());
}
In.longify = ob;
function ab(e) {
  const n = typeof e == "string" ? e : (0, fh.fromAscii)(e);
  return ph.Decimal.fromAtomics(n, 18);
}
In.decodeCosmosSdkDecFromProto = ab;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.longify = e.decodeCosmosSdkDecFromProto = e.createProtobufRpcClient = e.createPagination = e.QueryClient = void 0;
  var n = is;
  Object.defineProperty(e, "QueryClient", { enumerable: !0, get: function() {
    return n.QueryClient;
  } });
  var r = In;
  Object.defineProperty(e, "createPagination", { enumerable: !0, get: function() {
    return r.createPagination;
  } }), Object.defineProperty(e, "createProtobufRpcClient", { enumerable: !0, get: function() {
    return r.createProtobufRpcClient;
  } }), Object.defineProperty(e, "decodeCosmosSdkDecFromProto", { enumerable: !0, get: function() {
    return r.decodeCosmosSdkDecFromProto;
  } }), Object.defineProperty(e, "longify", { enumerable: !0, get: function() {
    return r.longify;
  } });
})(Ye);
Object.defineProperty(rs, "__esModule", { value: !0 });
rs.setupAuthExtension = void 0;
const sb = Wp, db = Ye;
function ub(e) {
  const n = (0, db.createProtobufRpcClient)(e), r = new sb.QueryClientImpl(n);
  return {
    auth: {
      account: async (t) => {
        const { account: i } = await r.Account({ address: t });
        return i ?? null;
      }
    }
  };
}
rs.setupAuthExtension = ub;
var ps = {};
Object.defineProperty(ps, "__esModule", { value: !0 });
ps.createAuthzAminoConverters = void 0;
function cb() {
  return {
    // For Cosmos SDK < 0.46 the Amino JSON codec was broken on chain and thus inaccessible.
    // Now this can be implemented for 0.46+ chains, see
    // https://github.com/cosmos/cosmjs/issues/1092
    //
    // "/cosmos.authz.v1beta1.MsgGrant": IMPLEMENT ME,
    // "/cosmos.authz.v1beta1.MsgExec": IMPLEMENT ME,
    // "/cosmos.authz.v1beta1.MsgRevoke": IMPLEMENT ME,
  };
}
ps.createAuthzAminoConverters = cb;
var hs = {}, hh = {}, mn = {}, Je = {};
Object.defineProperty(Je, "__esModule", { value: !0 });
Je.Timestamp = Je.protobufPackage = void 0;
const eu = re, df = ie;
Je.protobufPackage = "google.protobuf";
function nu() {
  return {
    seconds: BigInt(0),
    nanos: 0
  };
}
Je.Timestamp = {
  typeUrl: "/google.protobuf.Timestamp",
  encode(e, n = eu.BinaryWriter.create()) {
    return e.seconds !== BigInt(0) && n.uint32(8).int64(e.seconds), e.nanos !== 0 && n.uint32(16).int32(e.nanos), n;
  },
  decode(e, n) {
    const r = e instanceof eu.BinaryReader ? e : new eu.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = nu();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.seconds = r.int64();
          break;
        case 2:
          i.nanos = r.int32();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = nu();
    return (0, df.isSet)(e.seconds) && (n.seconds = BigInt(e.seconds.toString())), (0, df.isSet)(e.nanos) && (n.nanos = Number(e.nanos)), n;
  },
  toJSON(e) {
    const n = {};
    return e.seconds !== void 0 && (n.seconds = (e.seconds || BigInt(0)).toString()), e.nanos !== void 0 && (n.nanos = Math.round(e.nanos)), n;
  },
  fromPartial(e) {
    const n = nu();
    return e.seconds !== void 0 && e.seconds !== null && (n.seconds = BigInt(e.seconds.toString())), n.nanos = e.nanos ?? 0, n;
  }
};
Object.defineProperty(mn, "__esModule", { value: !0 });
mn.GrantQueueItem = mn.GrantAuthorization = mn.Grant = mn.GenericAuthorization = mn.protobufPackage = void 0;
const Zn = Pe, Ur = Je, Hn = re, $n = ie;
mn.protobufPackage = "cosmos.authz.v1beta1";
function tu() {
  return {
    msg: ""
  };
}
mn.GenericAuthorization = {
  typeUrl: "/cosmos.authz.v1beta1.GenericAuthorization",
  encode(e, n = Hn.BinaryWriter.create()) {
    return e.msg !== "" && n.uint32(10).string(e.msg), n;
  },
  decode(e, n) {
    const r = e instanceof Hn.BinaryReader ? e : new Hn.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = tu();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.msg = r.string();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = tu();
    return (0, $n.isSet)(e.msg) && (n.msg = String(e.msg)), n;
  },
  toJSON(e) {
    const n = {};
    return e.msg !== void 0 && (n.msg = e.msg), n;
  },
  fromPartial(e) {
    const n = tu();
    return n.msg = e.msg ?? "", n;
  }
};
function ru() {
  return {
    authorization: void 0,
    expiration: void 0
  };
}
mn.Grant = {
  typeUrl: "/cosmos.authz.v1beta1.Grant",
  encode(e, n = Hn.BinaryWriter.create()) {
    return e.authorization !== void 0 && Zn.Any.encode(e.authorization, n.uint32(10).fork()).ldelim(), e.expiration !== void 0 && Ur.Timestamp.encode(e.expiration, n.uint32(18).fork()).ldelim(), n;
  },
  decode(e, n) {
    const r = e instanceof Hn.BinaryReader ? e : new Hn.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = ru();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.authorization = Zn.Any.decode(r, r.uint32());
          break;
        case 2:
          i.expiration = Ur.Timestamp.decode(r, r.uint32());
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = ru();
    return (0, $n.isSet)(e.authorization) && (n.authorization = Zn.Any.fromJSON(e.authorization)), (0, $n.isSet)(e.expiration) && (n.expiration = (0, $n.fromJsonTimestamp)(e.expiration)), n;
  },
  toJSON(e) {
    const n = {};
    return e.authorization !== void 0 && (n.authorization = e.authorization ? Zn.Any.toJSON(e.authorization) : void 0), e.expiration !== void 0 && (n.expiration = (0, $n.fromTimestamp)(e.expiration).toISOString()), n;
  },
  fromPartial(e) {
    const n = ru();
    return e.authorization !== void 0 && e.authorization !== null && (n.authorization = Zn.Any.fromPartial(e.authorization)), e.expiration !== void 0 && e.expiration !== null && (n.expiration = Ur.Timestamp.fromPartial(e.expiration)), n;
  }
};
function iu() {
  return {
    granter: "",
    grantee: "",
    authorization: void 0,
    expiration: void 0
  };
}
mn.GrantAuthorization = {
  typeUrl: "/cosmos.authz.v1beta1.GrantAuthorization",
  encode(e, n = Hn.BinaryWriter.create()) {
    return e.granter !== "" && n.uint32(10).string(e.granter), e.grantee !== "" && n.uint32(18).string(e.grantee), e.authorization !== void 0 && Zn.Any.encode(e.authorization, n.uint32(26).fork()).ldelim(), e.expiration !== void 0 && Ur.Timestamp.encode(e.expiration, n.uint32(34).fork()).ldelim(), n;
  },
  decode(e, n) {
    const r = e instanceof Hn.BinaryReader ? e : new Hn.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = iu();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.granter = r.string();
          break;
        case 2:
          i.grantee = r.string();
          break;
        case 3:
          i.authorization = Zn.Any.decode(r, r.uint32());
          break;
        case 4:
          i.expiration = Ur.Timestamp.decode(r, r.uint32());
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = iu();
    return (0, $n.isSet)(e.granter) && (n.granter = String(e.granter)), (0, $n.isSet)(e.grantee) && (n.grantee = String(e.grantee)), (0, $n.isSet)(e.authorization) && (n.authorization = Zn.Any.fromJSON(e.authorization)), (0, $n.isSet)(e.expiration) && (n.expiration = (0, $n.fromJsonTimestamp)(e.expiration)), n;
  },
  toJSON(e) {
    const n = {};
    return e.granter !== void 0 && (n.granter = e.granter), e.grantee !== void 0 && (n.grantee = e.grantee), e.authorization !== void 0 && (n.authorization = e.authorization ? Zn.Any.toJSON(e.authorization) : void 0), e.expiration !== void 0 && (n.expiration = (0, $n.fromTimestamp)(e.expiration).toISOString()), n;
  },
  fromPartial(e) {
    const n = iu();
    return n.granter = e.granter ?? "", n.grantee = e.grantee ?? "", e.authorization !== void 0 && e.authorization !== null && (n.authorization = Zn.Any.fromPartial(e.authorization)), e.expiration !== void 0 && e.expiration !== null && (n.expiration = Ur.Timestamp.fromPartial(e.expiration)), n;
  }
};
function ou() {
  return {
    msgTypeUrls: []
  };
}
mn.GrantQueueItem = {
  typeUrl: "/cosmos.authz.v1beta1.GrantQueueItem",
  encode(e, n = Hn.BinaryWriter.create()) {
    for (const r of e.msgTypeUrls)
      n.uint32(10).string(r);
    return n;
  },
  decode(e, n) {
    const r = e instanceof Hn.BinaryReader ? e : new Hn.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = ou();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.msgTypeUrls.push(r.string());
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = ou();
    return Array.isArray(e == null ? void 0 : e.msgTypeUrls) && (n.msgTypeUrls = e.msgTypeUrls.map((r) => String(r))), n;
  },
  toJSON(e) {
    const n = {};
    return e.msgTypeUrls ? n.msgTypeUrls = e.msgTypeUrls.map((r) => r) : n.msgTypeUrls = [], n;
  },
  fromPartial(e) {
    var r;
    const n = ou();
    return n.msgTypeUrls = ((r = e.msgTypeUrls) == null ? void 0 : r.map((t) => t)) || [], n;
  }
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgRevokeResponse = e.MsgRevoke = e.MsgGrantResponse = e.MsgExec = e.MsgExecResponse = e.MsgGrant = e.protobufPackage = void 0;
  const n = mn, r = Pe, t = re, i = ie;
  e.protobufPackage = "cosmos.authz.v1beta1";
  function f() {
    return {
      granter: "",
      grantee: "",
      grant: n.Grant.fromPartial({})
    };
  }
  e.MsgGrant = {
    typeUrl: "/cosmos.authz.v1beta1.MsgGrant",
    encode(p, m = t.BinaryWriter.create()) {
      return p.granter !== "" && m.uint32(10).string(p.granter), p.grantee !== "" && m.uint32(18).string(p.grantee), p.grant !== void 0 && n.Grant.encode(p.grant, m.uint32(26).fork()).ldelim(), m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = f();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.granter = v.string();
            break;
          case 2:
            d.grantee = v.string();
            break;
          case 3:
            d.grant = n.Grant.decode(v, v.uint32());
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = f();
      return (0, i.isSet)(p.granter) && (m.granter = String(p.granter)), (0, i.isSet)(p.grantee) && (m.grantee = String(p.grantee)), (0, i.isSet)(p.grant) && (m.grant = n.Grant.fromJSON(p.grant)), m;
    },
    toJSON(p) {
      const m = {};
      return p.granter !== void 0 && (m.granter = p.granter), p.grantee !== void 0 && (m.grantee = p.grantee), p.grant !== void 0 && (m.grant = p.grant ? n.Grant.toJSON(p.grant) : void 0), m;
    },
    fromPartial(p) {
      const m = f();
      return m.granter = p.granter ?? "", m.grantee = p.grantee ?? "", p.grant !== void 0 && p.grant !== null && (m.grant = n.Grant.fromPartial(p.grant)), m;
    }
  };
  function S() {
    return {
      results: []
    };
  }
  e.MsgExecResponse = {
    typeUrl: "/cosmos.authz.v1beta1.MsgExecResponse",
    encode(p, m = t.BinaryWriter.create()) {
      for (const v of p.results)
        m.uint32(10).bytes(v);
      return m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = S();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.results.push(v.bytes());
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = S();
      return Array.isArray(p == null ? void 0 : p.results) && (m.results = p.results.map((v) => (0, i.bytesFromBase64)(v))), m;
    },
    toJSON(p) {
      const m = {};
      return p.results ? m.results = p.results.map((v) => (0, i.base64FromBytes)(v !== void 0 ? v : new Uint8Array())) : m.results = [], m;
    },
    fromPartial(p) {
      var v;
      const m = S();
      return m.results = ((v = p.results) == null ? void 0 : v.map((a) => a)) || [], m;
    }
  };
  function w() {
    return {
      grantee: "",
      msgs: []
    };
  }
  e.MsgExec = {
    typeUrl: "/cosmos.authz.v1beta1.MsgExec",
    encode(p, m = t.BinaryWriter.create()) {
      p.grantee !== "" && m.uint32(10).string(p.grantee);
      for (const v of p.msgs)
        r.Any.encode(v, m.uint32(18).fork()).ldelim();
      return m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = w();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.grantee = v.string();
            break;
          case 2:
            d.msgs.push(r.Any.decode(v, v.uint32()));
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = w();
      return (0, i.isSet)(p.grantee) && (m.grantee = String(p.grantee)), Array.isArray(p == null ? void 0 : p.msgs) && (m.msgs = p.msgs.map((v) => r.Any.fromJSON(v))), m;
    },
    toJSON(p) {
      const m = {};
      return p.grantee !== void 0 && (m.grantee = p.grantee), p.msgs ? m.msgs = p.msgs.map((v) => v ? r.Any.toJSON(v) : void 0) : m.msgs = [], m;
    },
    fromPartial(p) {
      var v;
      const m = w();
      return m.grantee = p.grantee ?? "", m.msgs = ((v = p.msgs) == null ? void 0 : v.map((a) => r.Any.fromPartial(a))) || [], m;
    }
  };
  function T() {
    return {};
  }
  e.MsgGrantResponse = {
    typeUrl: "/cosmos.authz.v1beta1.MsgGrantResponse",
    encode(p, m = t.BinaryWriter.create()) {
      return m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = T();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      return T();
    },
    toJSON(p) {
      return {};
    },
    fromPartial(p) {
      return T();
    }
  };
  function J() {
    return {
      granter: "",
      grantee: "",
      msgTypeUrl: ""
    };
  }
  e.MsgRevoke = {
    typeUrl: "/cosmos.authz.v1beta1.MsgRevoke",
    encode(p, m = t.BinaryWriter.create()) {
      return p.granter !== "" && m.uint32(10).string(p.granter), p.grantee !== "" && m.uint32(18).string(p.grantee), p.msgTypeUrl !== "" && m.uint32(26).string(p.msgTypeUrl), m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = J();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.granter = v.string();
            break;
          case 2:
            d.grantee = v.string();
            break;
          case 3:
            d.msgTypeUrl = v.string();
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = J();
      return (0, i.isSet)(p.granter) && (m.granter = String(p.granter)), (0, i.isSet)(p.grantee) && (m.grantee = String(p.grantee)), (0, i.isSet)(p.msgTypeUrl) && (m.msgTypeUrl = String(p.msgTypeUrl)), m;
    },
    toJSON(p) {
      const m = {};
      return p.granter !== void 0 && (m.granter = p.granter), p.grantee !== void 0 && (m.grantee = p.grantee), p.msgTypeUrl !== void 0 && (m.msgTypeUrl = p.msgTypeUrl), m;
    },
    fromPartial(p) {
      const m = J();
      return m.granter = p.granter ?? "", m.grantee = p.grantee ?? "", m.msgTypeUrl = p.msgTypeUrl ?? "", m;
    }
  };
  function C() {
    return {};
  }
  e.MsgRevokeResponse = {
    typeUrl: "/cosmos.authz.v1beta1.MsgRevokeResponse",
    encode(p, m = t.BinaryWriter.create()) {
      return m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = C();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      return C();
    },
    toJSON(p) {
      return {};
    },
    fromPartial(p) {
      return C();
    }
  };
  class R {
    constructor(m) {
      this.rpc = m, this.Grant = this.Grant.bind(this), this.Exec = this.Exec.bind(this), this.Revoke = this.Revoke.bind(this);
    }
    Grant(m) {
      const v = e.MsgGrant.encode(m).finish();
      return this.rpc.request("cosmos.authz.v1beta1.Msg", "Grant", v).then((d) => e.MsgGrantResponse.decode(new t.BinaryReader(d)));
    }
    Exec(m) {
      const v = e.MsgExec.encode(m).finish();
      return this.rpc.request("cosmos.authz.v1beta1.Msg", "Exec", v).then((d) => e.MsgExecResponse.decode(new t.BinaryReader(d)));
    }
    Revoke(m) {
      const v = e.MsgRevoke.encode(m).finish();
      return this.rpc.request("cosmos.authz.v1beta1.Msg", "Revoke", v).then((d) => e.MsgRevokeResponse.decode(new t.BinaryReader(d)));
    }
  }
  e.MsgClientImpl = R;
})(hh);
Object.defineProperty(hs, "__esModule", { value: !0 });
hs.authzTypes = void 0;
const au = hh;
hs.authzTypes = [
  ["/cosmos.authz.v1beta1.MsgExec", au.MsgExec],
  ["/cosmos.authz.v1beta1.MsgGrant", au.MsgGrant],
  ["/cosmos.authz.v1beta1.MsgRevoke", au.MsgRevoke]
];
var ys = {}, yh = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryGranteeGrantsResponse = e.QueryGranteeGrantsRequest = e.QueryGranterGrantsResponse = e.QueryGranterGrantsRequest = e.QueryGrantsResponse = e.QueryGrantsRequest = e.protobufPackage = void 0;
  const n = Ae, r = mn, t = re, i = ie;
  e.protobufPackage = "cosmos.authz.v1beta1";
  function f() {
    return {
      granter: "",
      grantee: "",
      msgTypeUrl: "",
      pagination: void 0
    };
  }
  e.QueryGrantsRequest = {
    typeUrl: "/cosmos.authz.v1beta1.QueryGrantsRequest",
    encode(p, m = t.BinaryWriter.create()) {
      return p.granter !== "" && m.uint32(10).string(p.granter), p.grantee !== "" && m.uint32(18).string(p.grantee), p.msgTypeUrl !== "" && m.uint32(26).string(p.msgTypeUrl), p.pagination !== void 0 && n.PageRequest.encode(p.pagination, m.uint32(34).fork()).ldelim(), m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = f();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.granter = v.string();
            break;
          case 2:
            d.grantee = v.string();
            break;
          case 3:
            d.msgTypeUrl = v.string();
            break;
          case 4:
            d.pagination = n.PageRequest.decode(v, v.uint32());
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = f();
      return (0, i.isSet)(p.granter) && (m.granter = String(p.granter)), (0, i.isSet)(p.grantee) && (m.grantee = String(p.grantee)), (0, i.isSet)(p.msgTypeUrl) && (m.msgTypeUrl = String(p.msgTypeUrl)), (0, i.isSet)(p.pagination) && (m.pagination = n.PageRequest.fromJSON(p.pagination)), m;
    },
    toJSON(p) {
      const m = {};
      return p.granter !== void 0 && (m.granter = p.granter), p.grantee !== void 0 && (m.grantee = p.grantee), p.msgTypeUrl !== void 0 && (m.msgTypeUrl = p.msgTypeUrl), p.pagination !== void 0 && (m.pagination = p.pagination ? n.PageRequest.toJSON(p.pagination) : void 0), m;
    },
    fromPartial(p) {
      const m = f();
      return m.granter = p.granter ?? "", m.grantee = p.grantee ?? "", m.msgTypeUrl = p.msgTypeUrl ?? "", p.pagination !== void 0 && p.pagination !== null && (m.pagination = n.PageRequest.fromPartial(p.pagination)), m;
    }
  };
  function S() {
    return {
      grants: [],
      pagination: void 0
    };
  }
  e.QueryGrantsResponse = {
    typeUrl: "/cosmos.authz.v1beta1.QueryGrantsResponse",
    encode(p, m = t.BinaryWriter.create()) {
      for (const v of p.grants)
        r.Grant.encode(v, m.uint32(10).fork()).ldelim();
      return p.pagination !== void 0 && n.PageResponse.encode(p.pagination, m.uint32(18).fork()).ldelim(), m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = S();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.grants.push(r.Grant.decode(v, v.uint32()));
            break;
          case 2:
            d.pagination = n.PageResponse.decode(v, v.uint32());
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = S();
      return Array.isArray(p == null ? void 0 : p.grants) && (m.grants = p.grants.map((v) => r.Grant.fromJSON(v))), (0, i.isSet)(p.pagination) && (m.pagination = n.PageResponse.fromJSON(p.pagination)), m;
    },
    toJSON(p) {
      const m = {};
      return p.grants ? m.grants = p.grants.map((v) => v ? r.Grant.toJSON(v) : void 0) : m.grants = [], p.pagination !== void 0 && (m.pagination = p.pagination ? n.PageResponse.toJSON(p.pagination) : void 0), m;
    },
    fromPartial(p) {
      var v;
      const m = S();
      return m.grants = ((v = p.grants) == null ? void 0 : v.map((a) => r.Grant.fromPartial(a))) || [], p.pagination !== void 0 && p.pagination !== null && (m.pagination = n.PageResponse.fromPartial(p.pagination)), m;
    }
  };
  function w() {
    return {
      granter: "",
      pagination: void 0
    };
  }
  e.QueryGranterGrantsRequest = {
    typeUrl: "/cosmos.authz.v1beta1.QueryGranterGrantsRequest",
    encode(p, m = t.BinaryWriter.create()) {
      return p.granter !== "" && m.uint32(10).string(p.granter), p.pagination !== void 0 && n.PageRequest.encode(p.pagination, m.uint32(18).fork()).ldelim(), m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = w();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.granter = v.string();
            break;
          case 2:
            d.pagination = n.PageRequest.decode(v, v.uint32());
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = w();
      return (0, i.isSet)(p.granter) && (m.granter = String(p.granter)), (0, i.isSet)(p.pagination) && (m.pagination = n.PageRequest.fromJSON(p.pagination)), m;
    },
    toJSON(p) {
      const m = {};
      return p.granter !== void 0 && (m.granter = p.granter), p.pagination !== void 0 && (m.pagination = p.pagination ? n.PageRequest.toJSON(p.pagination) : void 0), m;
    },
    fromPartial(p) {
      const m = w();
      return m.granter = p.granter ?? "", p.pagination !== void 0 && p.pagination !== null && (m.pagination = n.PageRequest.fromPartial(p.pagination)), m;
    }
  };
  function T() {
    return {
      grants: [],
      pagination: void 0
    };
  }
  e.QueryGranterGrantsResponse = {
    typeUrl: "/cosmos.authz.v1beta1.QueryGranterGrantsResponse",
    encode(p, m = t.BinaryWriter.create()) {
      for (const v of p.grants)
        r.GrantAuthorization.encode(v, m.uint32(10).fork()).ldelim();
      return p.pagination !== void 0 && n.PageResponse.encode(p.pagination, m.uint32(18).fork()).ldelim(), m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = T();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.grants.push(r.GrantAuthorization.decode(v, v.uint32()));
            break;
          case 2:
            d.pagination = n.PageResponse.decode(v, v.uint32());
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = T();
      return Array.isArray(p == null ? void 0 : p.grants) && (m.grants = p.grants.map((v) => r.GrantAuthorization.fromJSON(v))), (0, i.isSet)(p.pagination) && (m.pagination = n.PageResponse.fromJSON(p.pagination)), m;
    },
    toJSON(p) {
      const m = {};
      return p.grants ? m.grants = p.grants.map((v) => v ? r.GrantAuthorization.toJSON(v) : void 0) : m.grants = [], p.pagination !== void 0 && (m.pagination = p.pagination ? n.PageResponse.toJSON(p.pagination) : void 0), m;
    },
    fromPartial(p) {
      var v;
      const m = T();
      return m.grants = ((v = p.grants) == null ? void 0 : v.map((a) => r.GrantAuthorization.fromPartial(a))) || [], p.pagination !== void 0 && p.pagination !== null && (m.pagination = n.PageResponse.fromPartial(p.pagination)), m;
    }
  };
  function J() {
    return {
      grantee: "",
      pagination: void 0
    };
  }
  e.QueryGranteeGrantsRequest = {
    typeUrl: "/cosmos.authz.v1beta1.QueryGranteeGrantsRequest",
    encode(p, m = t.BinaryWriter.create()) {
      return p.grantee !== "" && m.uint32(10).string(p.grantee), p.pagination !== void 0 && n.PageRequest.encode(p.pagination, m.uint32(18).fork()).ldelim(), m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = J();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.grantee = v.string();
            break;
          case 2:
            d.pagination = n.PageRequest.decode(v, v.uint32());
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = J();
      return (0, i.isSet)(p.grantee) && (m.grantee = String(p.grantee)), (0, i.isSet)(p.pagination) && (m.pagination = n.PageRequest.fromJSON(p.pagination)), m;
    },
    toJSON(p) {
      const m = {};
      return p.grantee !== void 0 && (m.grantee = p.grantee), p.pagination !== void 0 && (m.pagination = p.pagination ? n.PageRequest.toJSON(p.pagination) : void 0), m;
    },
    fromPartial(p) {
      const m = J();
      return m.grantee = p.grantee ?? "", p.pagination !== void 0 && p.pagination !== null && (m.pagination = n.PageRequest.fromPartial(p.pagination)), m;
    }
  };
  function C() {
    return {
      grants: [],
      pagination: void 0
    };
  }
  e.QueryGranteeGrantsResponse = {
    typeUrl: "/cosmos.authz.v1beta1.QueryGranteeGrantsResponse",
    encode(p, m = t.BinaryWriter.create()) {
      for (const v of p.grants)
        r.GrantAuthorization.encode(v, m.uint32(10).fork()).ldelim();
      return p.pagination !== void 0 && n.PageResponse.encode(p.pagination, m.uint32(18).fork()).ldelim(), m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = C();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.grants.push(r.GrantAuthorization.decode(v, v.uint32()));
            break;
          case 2:
            d.pagination = n.PageResponse.decode(v, v.uint32());
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = C();
      return Array.isArray(p == null ? void 0 : p.grants) && (m.grants = p.grants.map((v) => r.GrantAuthorization.fromJSON(v))), (0, i.isSet)(p.pagination) && (m.pagination = n.PageResponse.fromJSON(p.pagination)), m;
    },
    toJSON(p) {
      const m = {};
      return p.grants ? m.grants = p.grants.map((v) => v ? r.GrantAuthorization.toJSON(v) : void 0) : m.grants = [], p.pagination !== void 0 && (m.pagination = p.pagination ? n.PageResponse.toJSON(p.pagination) : void 0), m;
    },
    fromPartial(p) {
      var v;
      const m = C();
      return m.grants = ((v = p.grants) == null ? void 0 : v.map((a) => r.GrantAuthorization.fromPartial(a))) || [], p.pagination !== void 0 && p.pagination !== null && (m.pagination = n.PageResponse.fromPartial(p.pagination)), m;
    }
  };
  class R {
    constructor(m) {
      this.rpc = m, this.Grants = this.Grants.bind(this), this.GranterGrants = this.GranterGrants.bind(this), this.GranteeGrants = this.GranteeGrants.bind(this);
    }
    Grants(m) {
      const v = e.QueryGrantsRequest.encode(m).finish();
      return this.rpc.request("cosmos.authz.v1beta1.Query", "Grants", v).then((d) => e.QueryGrantsResponse.decode(new t.BinaryReader(d)));
    }
    GranterGrants(m) {
      const v = e.QueryGranterGrantsRequest.encode(m).finish();
      return this.rpc.request("cosmos.authz.v1beta1.Query", "GranterGrants", v).then((d) => e.QueryGranterGrantsResponse.decode(new t.BinaryReader(d)));
    }
    GranteeGrants(m) {
      const v = e.QueryGranteeGrantsRequest.encode(m).finish();
      return this.rpc.request("cosmos.authz.v1beta1.Query", "GranteeGrants", v).then((d) => e.QueryGranteeGrantsResponse.decode(new t.BinaryReader(d)));
    }
  }
  e.QueryClientImpl = R;
})(yh);
Object.defineProperty(ys, "__esModule", { value: !0 });
ys.setupAuthzExtension = void 0;
const lb = yh, Go = Ye;
function fb(e) {
  const n = (0, Go.createProtobufRpcClient)(e), r = new lb.QueryClientImpl(n);
  return {
    authz: {
      grants: async (t, i, f, S) => await r.Grants({
        granter: t,
        grantee: i,
        msgTypeUrl: f,
        pagination: (0, Go.createPagination)(S)
      }),
      granteeGrants: async (t, i) => await r.GranteeGrants({
        grantee: t,
        pagination: (0, Go.createPagination)(i)
      }),
      granterGrants: async (t, i) => await r.GranterGrants({
        granter: t,
        pagination: (0, Go.createPagination)(i)
      })
    }
  };
}
ys.setupAuthzExtension = fb;
var Nt = {};
Object.defineProperty(Nt, "__esModule", { value: !0 });
Nt.createBankAminoConverters = Nt.isAminoMsgMultiSend = Nt.isAminoMsgSend = void 0;
function pb(e) {
  return e.type === "cosmos-sdk/MsgSend";
}
Nt.isAminoMsgSend = pb;
function hb(e) {
  return e.type === "cosmos-sdk/MsgMultiSend";
}
Nt.isAminoMsgMultiSend = hb;
function yb() {
  return {
    "/cosmos.bank.v1beta1.MsgSend": {
      aminoType: "cosmos-sdk/MsgSend",
      toAmino: ({ fromAddress: e, toAddress: n, amount: r }) => ({
        from_address: e,
        to_address: n,
        amount: [...r]
      }),
      fromAmino: ({ from_address: e, to_address: n, amount: r }) => ({
        fromAddress: e,
        toAddress: n,
        amount: [...r]
      })
    },
    "/cosmos.bank.v1beta1.MsgMultiSend": {
      aminoType: "cosmos-sdk/MsgMultiSend",
      toAmino: ({ inputs: e, outputs: n }) => ({
        inputs: e.map((r) => ({
          address: r.address,
          coins: [...r.coins]
        })),
        outputs: n.map((r) => ({
          address: r.address,
          coins: [...r.coins]
        }))
      }),
      fromAmino: ({ inputs: e, outputs: n }) => ({
        inputs: e.map((r) => ({
          address: r.address,
          coins: [...r.coins]
        })),
        outputs: n.map((r) => ({
          address: r.address,
          coins: [...r.coins]
        }))
      })
    }
  };
}
Nt.createBankAminoConverters = yb;
var li = {};
Object.defineProperty(li, "__esModule", { value: !0 });
li.isMsgSendEncodeObject = li.bankTypes = void 0;
const uf = _c;
li.bankTypes = [
  ["/cosmos.bank.v1beta1.MsgMultiSend", uf.MsgMultiSend],
  ["/cosmos.bank.v1beta1.MsgSend", uf.MsgSend]
];
function mb(e) {
  return e.typeUrl === "/cosmos.bank.v1beta1.MsgSend";
}
li.isMsgSendEncodeObject = mb;
var ms = {}, mh = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QuerySendEnabledResponse = e.QuerySendEnabledRequest = e.QueryDenomOwnersResponse = e.DenomOwner = e.QueryDenomOwnersRequest = e.QueryDenomMetadataResponse = e.QueryDenomMetadataRequest = e.QueryDenomsMetadataResponse = e.QueryDenomsMetadataRequest = e.QueryParamsResponse = e.QueryParamsRequest = e.QuerySupplyOfResponse = e.QuerySupplyOfRequest = e.QueryTotalSupplyResponse = e.QueryTotalSupplyRequest = e.QuerySpendableBalanceByDenomResponse = e.QuerySpendableBalanceByDenomRequest = e.QuerySpendableBalancesResponse = e.QuerySpendableBalancesRequest = e.QueryAllBalancesResponse = e.QueryAllBalancesRequest = e.QueryBalanceResponse = e.QueryBalanceRequest = e.protobufPackage = void 0;
  const n = Ae, r = De, t = Ec, i = re, f = ie;
  e.protobufPackage = "cosmos.bank.v1beta1";
  function S() {
    return {
      address: "",
      denom: ""
    };
  }
  e.QueryBalanceRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QueryBalanceRequest",
    encode(b, D = i.BinaryWriter.create()) {
      return b.address !== "" && D.uint32(10).string(b.address), b.denom !== "" && D.uint32(18).string(b.denom), D;
    },
    decode(b, D) {
      const Q = b instanceof i.BinaryReader ? b : new i.BinaryReader(b);
      let H = D === void 0 ? Q.len : Q.pos + D;
      const s = S();
      for (; Q.pos < H; ) {
        const k = Q.uint32();
        switch (k >>> 3) {
          case 1:
            s.address = Q.string();
            break;
          case 2:
            s.denom = Q.string();
            break;
          default:
            Q.skipType(k & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(b) {
      const D = S();
      return (0, f.isSet)(b.address) && (D.address = String(b.address)), (0, f.isSet)(b.denom) && (D.denom = String(b.denom)), D;
    },
    toJSON(b) {
      const D = {};
      return b.address !== void 0 && (D.address = b.address), b.denom !== void 0 && (D.denom = b.denom), D;
    },
    fromPartial(b) {
      const D = S();
      return D.address = b.address ?? "", D.denom = b.denom ?? "", D;
    }
  };
  function w() {
    return {
      balance: void 0
    };
  }
  e.QueryBalanceResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QueryBalanceResponse",
    encode(b, D = i.BinaryWriter.create()) {
      return b.balance !== void 0 && r.Coin.encode(b.balance, D.uint32(10).fork()).ldelim(), D;
    },
    decode(b, D) {
      const Q = b instanceof i.BinaryReader ? b : new i.BinaryReader(b);
      let H = D === void 0 ? Q.len : Q.pos + D;
      const s = w();
      for (; Q.pos < H; ) {
        const k = Q.uint32();
        switch (k >>> 3) {
          case 1:
            s.balance = r.Coin.decode(Q, Q.uint32());
            break;
          default:
            Q.skipType(k & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(b) {
      const D = w();
      return (0, f.isSet)(b.balance) && (D.balance = r.Coin.fromJSON(b.balance)), D;
    },
    toJSON(b) {
      const D = {};
      return b.balance !== void 0 && (D.balance = b.balance ? r.Coin.toJSON(b.balance) : void 0), D;
    },
    fromPartial(b) {
      const D = w();
      return b.balance !== void 0 && b.balance !== null && (D.balance = r.Coin.fromPartial(b.balance)), D;
    }
  };
  function T() {
    return {
      address: "",
      pagination: void 0
    };
  }
  e.QueryAllBalancesRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QueryAllBalancesRequest",
    encode(b, D = i.BinaryWriter.create()) {
      return b.address !== "" && D.uint32(10).string(b.address), b.pagination !== void 0 && n.PageRequest.encode(b.pagination, D.uint32(18).fork()).ldelim(), D;
    },
    decode(b, D) {
      const Q = b instanceof i.BinaryReader ? b : new i.BinaryReader(b);
      let H = D === void 0 ? Q.len : Q.pos + D;
      const s = T();
      for (; Q.pos < H; ) {
        const k = Q.uint32();
        switch (k >>> 3) {
          case 1:
            s.address = Q.string();
            break;
          case 2:
            s.pagination = n.PageRequest.decode(Q, Q.uint32());
            break;
          default:
            Q.skipType(k & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(b) {
      const D = T();
      return (0, f.isSet)(b.address) && (D.address = String(b.address)), (0, f.isSet)(b.pagination) && (D.pagination = n.PageRequest.fromJSON(b.pagination)), D;
    },
    toJSON(b) {
      const D = {};
      return b.address !== void 0 && (D.address = b.address), b.pagination !== void 0 && (D.pagination = b.pagination ? n.PageRequest.toJSON(b.pagination) : void 0), D;
    },
    fromPartial(b) {
      const D = T();
      return D.address = b.address ?? "", b.pagination !== void 0 && b.pagination !== null && (D.pagination = n.PageRequest.fromPartial(b.pagination)), D;
    }
  };
  function J() {
    return {
      balances: [],
      pagination: void 0
    };
  }
  e.QueryAllBalancesResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QueryAllBalancesResponse",
    encode(b, D = i.BinaryWriter.create()) {
      for (const Q of b.balances)
        r.Coin.encode(Q, D.uint32(10).fork()).ldelim();
      return b.pagination !== void 0 && n.PageResponse.encode(b.pagination, D.uint32(18).fork()).ldelim(), D;
    },
    decode(b, D) {
      const Q = b instanceof i.BinaryReader ? b : new i.BinaryReader(b);
      let H = D === void 0 ? Q.len : Q.pos + D;
      const s = J();
      for (; Q.pos < H; ) {
        const k = Q.uint32();
        switch (k >>> 3) {
          case 1:
            s.balances.push(r.Coin.decode(Q, Q.uint32()));
            break;
          case 2:
            s.pagination = n.PageResponse.decode(Q, Q.uint32());
            break;
          default:
            Q.skipType(k & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(b) {
      const D = J();
      return Array.isArray(b == null ? void 0 : b.balances) && (D.balances = b.balances.map((Q) => r.Coin.fromJSON(Q))), (0, f.isSet)(b.pagination) && (D.pagination = n.PageResponse.fromJSON(b.pagination)), D;
    },
    toJSON(b) {
      const D = {};
      return b.balances ? D.balances = b.balances.map((Q) => Q ? r.Coin.toJSON(Q) : void 0) : D.balances = [], b.pagination !== void 0 && (D.pagination = b.pagination ? n.PageResponse.toJSON(b.pagination) : void 0), D;
    },
    fromPartial(b) {
      var Q;
      const D = J();
      return D.balances = ((Q = b.balances) == null ? void 0 : Q.map((H) => r.Coin.fromPartial(H))) || [], b.pagination !== void 0 && b.pagination !== null && (D.pagination = n.PageResponse.fromPartial(b.pagination)), D;
    }
  };
  function C() {
    return {
      address: "",
      pagination: void 0
    };
  }
  e.QuerySpendableBalancesRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalancesRequest",
    encode(b, D = i.BinaryWriter.create()) {
      return b.address !== "" && D.uint32(10).string(b.address), b.pagination !== void 0 && n.PageRequest.encode(b.pagination, D.uint32(18).fork()).ldelim(), D;
    },
    decode(b, D) {
      const Q = b instanceof i.BinaryReader ? b : new i.BinaryReader(b);
      let H = D === void 0 ? Q.len : Q.pos + D;
      const s = C();
      for (; Q.pos < H; ) {
        const k = Q.uint32();
        switch (k >>> 3) {
          case 1:
            s.address = Q.string();
            break;
          case 2:
            s.pagination = n.PageRequest.decode(Q, Q.uint32());
            break;
          default:
            Q.skipType(k & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(b) {
      const D = C();
      return (0, f.isSet)(b.address) && (D.address = String(b.address)), (0, f.isSet)(b.pagination) && (D.pagination = n.PageRequest.fromJSON(b.pagination)), D;
    },
    toJSON(b) {
      const D = {};
      return b.address !== void 0 && (D.address = b.address), b.pagination !== void 0 && (D.pagination = b.pagination ? n.PageRequest.toJSON(b.pagination) : void 0), D;
    },
    fromPartial(b) {
      const D = C();
      return D.address = b.address ?? "", b.pagination !== void 0 && b.pagination !== null && (D.pagination = n.PageRequest.fromPartial(b.pagination)), D;
    }
  };
  function R() {
    return {
      balances: [],
      pagination: void 0
    };
  }
  e.QuerySpendableBalancesResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalancesResponse",
    encode(b, D = i.BinaryWriter.create()) {
      for (const Q of b.balances)
        r.Coin.encode(Q, D.uint32(10).fork()).ldelim();
      return b.pagination !== void 0 && n.PageResponse.encode(b.pagination, D.uint32(18).fork()).ldelim(), D;
    },
    decode(b, D) {
      const Q = b instanceof i.BinaryReader ? b : new i.BinaryReader(b);
      let H = D === void 0 ? Q.len : Q.pos + D;
      const s = R();
      for (; Q.pos < H; ) {
        const k = Q.uint32();
        switch (k >>> 3) {
          case 1:
            s.balances.push(r.Coin.decode(Q, Q.uint32()));
            break;
          case 2:
            s.pagination = n.PageResponse.decode(Q, Q.uint32());
            break;
          default:
            Q.skipType(k & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(b) {
      const D = R();
      return Array.isArray(b == null ? void 0 : b.balances) && (D.balances = b.balances.map((Q) => r.Coin.fromJSON(Q))), (0, f.isSet)(b.pagination) && (D.pagination = n.PageResponse.fromJSON(b.pagination)), D;
    },
    toJSON(b) {
      const D = {};
      return b.balances ? D.balances = b.balances.map((Q) => Q ? r.Coin.toJSON(Q) : void 0) : D.balances = [], b.pagination !== void 0 && (D.pagination = b.pagination ? n.PageResponse.toJSON(b.pagination) : void 0), D;
    },
    fromPartial(b) {
      var Q;
      const D = R();
      return D.balances = ((Q = b.balances) == null ? void 0 : Q.map((H) => r.Coin.fromPartial(H))) || [], b.pagination !== void 0 && b.pagination !== null && (D.pagination = n.PageResponse.fromPartial(b.pagination)), D;
    }
  };
  function p() {
    return {
      address: "",
      denom: ""
    };
  }
  e.QuerySpendableBalanceByDenomRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalanceByDenomRequest",
    encode(b, D = i.BinaryWriter.create()) {
      return b.address !== "" && D.uint32(10).string(b.address), b.denom !== "" && D.uint32(18).string(b.denom), D;
    },
    decode(b, D) {
      const Q = b instanceof i.BinaryReader ? b : new i.BinaryReader(b);
      let H = D === void 0 ? Q.len : Q.pos + D;
      const s = p();
      for (; Q.pos < H; ) {
        const k = Q.uint32();
        switch (k >>> 3) {
          case 1:
            s.address = Q.string();
            break;
          case 2:
            s.denom = Q.string();
            break;
          default:
            Q.skipType(k & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(b) {
      const D = p();
      return (0, f.isSet)(b.address) && (D.address = String(b.address)), (0, f.isSet)(b.denom) && (D.denom = String(b.denom)), D;
    },
    toJSON(b) {
      const D = {};
      return b.address !== void 0 && (D.address = b.address), b.denom !== void 0 && (D.denom = b.denom), D;
    },
    fromPartial(b) {
      const D = p();
      return D.address = b.address ?? "", D.denom = b.denom ?? "", D;
    }
  };
  function m() {
    return {
      balance: void 0
    };
  }
  e.QuerySpendableBalanceByDenomResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalanceByDenomResponse",
    encode(b, D = i.BinaryWriter.create()) {
      return b.balance !== void 0 && r.Coin.encode(b.balance, D.uint32(10).fork()).ldelim(), D;
    },
    decode(b, D) {
      const Q = b instanceof i.BinaryReader ? b : new i.BinaryReader(b);
      let H = D === void 0 ? Q.len : Q.pos + D;
      const s = m();
      for (; Q.pos < H; ) {
        const k = Q.uint32();
        switch (k >>> 3) {
          case 1:
            s.balance = r.Coin.decode(Q, Q.uint32());
            break;
          default:
            Q.skipType(k & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(b) {
      const D = m();
      return (0, f.isSet)(b.balance) && (D.balance = r.Coin.fromJSON(b.balance)), D;
    },
    toJSON(b) {
      const D = {};
      return b.balance !== void 0 && (D.balance = b.balance ? r.Coin.toJSON(b.balance) : void 0), D;
    },
    fromPartial(b) {
      const D = m();
      return b.balance !== void 0 && b.balance !== null && (D.balance = r.Coin.fromPartial(b.balance)), D;
    }
  };
  function v() {
    return {
      pagination: void 0
    };
  }
  e.QueryTotalSupplyRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QueryTotalSupplyRequest",
    encode(b, D = i.BinaryWriter.create()) {
      return b.pagination !== void 0 && n.PageRequest.encode(b.pagination, D.uint32(10).fork()).ldelim(), D;
    },
    decode(b, D) {
      const Q = b instanceof i.BinaryReader ? b : new i.BinaryReader(b);
      let H = D === void 0 ? Q.len : Q.pos + D;
      const s = v();
      for (; Q.pos < H; ) {
        const k = Q.uint32();
        switch (k >>> 3) {
          case 1:
            s.pagination = n.PageRequest.decode(Q, Q.uint32());
            break;
          default:
            Q.skipType(k & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(b) {
      const D = v();
      return (0, f.isSet)(b.pagination) && (D.pagination = n.PageRequest.fromJSON(b.pagination)), D;
    },
    toJSON(b) {
      const D = {};
      return b.pagination !== void 0 && (D.pagination = b.pagination ? n.PageRequest.toJSON(b.pagination) : void 0), D;
    },
    fromPartial(b) {
      const D = v();
      return b.pagination !== void 0 && b.pagination !== null && (D.pagination = n.PageRequest.fromPartial(b.pagination)), D;
    }
  };
  function a() {
    return {
      supply: [],
      pagination: void 0
    };
  }
  e.QueryTotalSupplyResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QueryTotalSupplyResponse",
    encode(b, D = i.BinaryWriter.create()) {
      for (const Q of b.supply)
        r.Coin.encode(Q, D.uint32(10).fork()).ldelim();
      return b.pagination !== void 0 && n.PageResponse.encode(b.pagination, D.uint32(18).fork()).ldelim(), D;
    },
    decode(b, D) {
      const Q = b instanceof i.BinaryReader ? b : new i.BinaryReader(b);
      let H = D === void 0 ? Q.len : Q.pos + D;
      const s = a();
      for (; Q.pos < H; ) {
        const k = Q.uint32();
        switch (k >>> 3) {
          case 1:
            s.supply.push(r.Coin.decode(Q, Q.uint32()));
            break;
          case 2:
            s.pagination = n.PageResponse.decode(Q, Q.uint32());
            break;
          default:
            Q.skipType(k & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(b) {
      const D = a();
      return Array.isArray(b == null ? void 0 : b.supply) && (D.supply = b.supply.map((Q) => r.Coin.fromJSON(Q))), (0, f.isSet)(b.pagination) && (D.pagination = n.PageResponse.fromJSON(b.pagination)), D;
    },
    toJSON(b) {
      const D = {};
      return b.supply ? D.supply = b.supply.map((Q) => Q ? r.Coin.toJSON(Q) : void 0) : D.supply = [], b.pagination !== void 0 && (D.pagination = b.pagination ? n.PageResponse.toJSON(b.pagination) : void 0), D;
    },
    fromPartial(b) {
      var Q;
      const D = a();
      return D.supply = ((Q = b.supply) == null ? void 0 : Q.map((H) => r.Coin.fromPartial(H))) || [], b.pagination !== void 0 && b.pagination !== null && (D.pagination = n.PageResponse.fromPartial(b.pagination)), D;
    }
  };
  function d() {
    return {
      denom: ""
    };
  }
  e.QuerySupplyOfRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QuerySupplyOfRequest",
    encode(b, D = i.BinaryWriter.create()) {
      return b.denom !== "" && D.uint32(10).string(b.denom), D;
    },
    decode(b, D) {
      const Q = b instanceof i.BinaryReader ? b : new i.BinaryReader(b);
      let H = D === void 0 ? Q.len : Q.pos + D;
      const s = d();
      for (; Q.pos < H; ) {
        const k = Q.uint32();
        switch (k >>> 3) {
          case 1:
            s.denom = Q.string();
            break;
          default:
            Q.skipType(k & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(b) {
      const D = d();
      return (0, f.isSet)(b.denom) && (D.denom = String(b.denom)), D;
    },
    toJSON(b) {
      const D = {};
      return b.denom !== void 0 && (D.denom = b.denom), D;
    },
    fromPartial(b) {
      const D = d();
      return D.denom = b.denom ?? "", D;
    }
  };
  function y() {
    return {
      amount: r.Coin.fromPartial({})
    };
  }
  e.QuerySupplyOfResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QuerySupplyOfResponse",
    encode(b, D = i.BinaryWriter.create()) {
      return b.amount !== void 0 && r.Coin.encode(b.amount, D.uint32(10).fork()).ldelim(), D;
    },
    decode(b, D) {
      const Q = b instanceof i.BinaryReader ? b : new i.BinaryReader(b);
      let H = D === void 0 ? Q.len : Q.pos + D;
      const s = y();
      for (; Q.pos < H; ) {
        const k = Q.uint32();
        switch (k >>> 3) {
          case 1:
            s.amount = r.Coin.decode(Q, Q.uint32());
            break;
          default:
            Q.skipType(k & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(b) {
      const D = y();
      return (0, f.isSet)(b.amount) && (D.amount = r.Coin.fromJSON(b.amount)), D;
    },
    toJSON(b) {
      const D = {};
      return b.amount !== void 0 && (D.amount = b.amount ? r.Coin.toJSON(b.amount) : void 0), D;
    },
    fromPartial(b) {
      const D = y();
      return b.amount !== void 0 && b.amount !== null && (D.amount = r.Coin.fromPartial(b.amount)), D;
    }
  };
  function _() {
    return {};
  }
  e.QueryParamsRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QueryParamsRequest",
    encode(b, D = i.BinaryWriter.create()) {
      return D;
    },
    decode(b, D) {
      const Q = b instanceof i.BinaryReader ? b : new i.BinaryReader(b);
      let H = D === void 0 ? Q.len : Q.pos + D;
      const s = _();
      for (; Q.pos < H; ) {
        const k = Q.uint32();
        switch (k >>> 3) {
          default:
            Q.skipType(k & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(b) {
      return _();
    },
    toJSON(b) {
      return {};
    },
    fromPartial(b) {
      return _();
    }
  };
  function E() {
    return {
      params: t.Params.fromPartial({})
    };
  }
  e.QueryParamsResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QueryParamsResponse",
    encode(b, D = i.BinaryWriter.create()) {
      return b.params !== void 0 && t.Params.encode(b.params, D.uint32(10).fork()).ldelim(), D;
    },
    decode(b, D) {
      const Q = b instanceof i.BinaryReader ? b : new i.BinaryReader(b);
      let H = D === void 0 ? Q.len : Q.pos + D;
      const s = E();
      for (; Q.pos < H; ) {
        const k = Q.uint32();
        switch (k >>> 3) {
          case 1:
            s.params = t.Params.decode(Q, Q.uint32());
            break;
          default:
            Q.skipType(k & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(b) {
      const D = E();
      return (0, f.isSet)(b.params) && (D.params = t.Params.fromJSON(b.params)), D;
    },
    toJSON(b) {
      const D = {};
      return b.params !== void 0 && (D.params = b.params ? t.Params.toJSON(b.params) : void 0), D;
    },
    fromPartial(b) {
      const D = E();
      return b.params !== void 0 && b.params !== null && (D.params = t.Params.fromPartial(b.params)), D;
    }
  };
  function U() {
    return {
      pagination: void 0
    };
  }
  e.QueryDenomsMetadataRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QueryDenomsMetadataRequest",
    encode(b, D = i.BinaryWriter.create()) {
      return b.pagination !== void 0 && n.PageRequest.encode(b.pagination, D.uint32(10).fork()).ldelim(), D;
    },
    decode(b, D) {
      const Q = b instanceof i.BinaryReader ? b : new i.BinaryReader(b);
      let H = D === void 0 ? Q.len : Q.pos + D;
      const s = U();
      for (; Q.pos < H; ) {
        const k = Q.uint32();
        switch (k >>> 3) {
          case 1:
            s.pagination = n.PageRequest.decode(Q, Q.uint32());
            break;
          default:
            Q.skipType(k & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(b) {
      const D = U();
      return (0, f.isSet)(b.pagination) && (D.pagination = n.PageRequest.fromJSON(b.pagination)), D;
    },
    toJSON(b) {
      const D = {};
      return b.pagination !== void 0 && (D.pagination = b.pagination ? n.PageRequest.toJSON(b.pagination) : void 0), D;
    },
    fromPartial(b) {
      const D = U();
      return b.pagination !== void 0 && b.pagination !== null && (D.pagination = n.PageRequest.fromPartial(b.pagination)), D;
    }
  };
  function V() {
    return {
      metadatas: [],
      pagination: void 0
    };
  }
  e.QueryDenomsMetadataResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QueryDenomsMetadataResponse",
    encode(b, D = i.BinaryWriter.create()) {
      for (const Q of b.metadatas)
        t.Metadata.encode(Q, D.uint32(10).fork()).ldelim();
      return b.pagination !== void 0 && n.PageResponse.encode(b.pagination, D.uint32(18).fork()).ldelim(), D;
    },
    decode(b, D) {
      const Q = b instanceof i.BinaryReader ? b : new i.BinaryReader(b);
      let H = D === void 0 ? Q.len : Q.pos + D;
      const s = V();
      for (; Q.pos < H; ) {
        const k = Q.uint32();
        switch (k >>> 3) {
          case 1:
            s.metadatas.push(t.Metadata.decode(Q, Q.uint32()));
            break;
          case 2:
            s.pagination = n.PageResponse.decode(Q, Q.uint32());
            break;
          default:
            Q.skipType(k & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(b) {
      const D = V();
      return Array.isArray(b == null ? void 0 : b.metadatas) && (D.metadatas = b.metadatas.map((Q) => t.Metadata.fromJSON(Q))), (0, f.isSet)(b.pagination) && (D.pagination = n.PageResponse.fromJSON(b.pagination)), D;
    },
    toJSON(b) {
      const D = {};
      return b.metadatas ? D.metadatas = b.metadatas.map((Q) => Q ? t.Metadata.toJSON(Q) : void 0) : D.metadatas = [], b.pagination !== void 0 && (D.pagination = b.pagination ? n.PageResponse.toJSON(b.pagination) : void 0), D;
    },
    fromPartial(b) {
      var Q;
      const D = V();
      return D.metadatas = ((Q = b.metadatas) == null ? void 0 : Q.map((H) => t.Metadata.fromPartial(H))) || [], b.pagination !== void 0 && b.pagination !== null && (D.pagination = n.PageResponse.fromPartial(b.pagination)), D;
    }
  };
  function o() {
    return {
      denom: ""
    };
  }
  e.QueryDenomMetadataRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QueryDenomMetadataRequest",
    encode(b, D = i.BinaryWriter.create()) {
      return b.denom !== "" && D.uint32(10).string(b.denom), D;
    },
    decode(b, D) {
      const Q = b instanceof i.BinaryReader ? b : new i.BinaryReader(b);
      let H = D === void 0 ? Q.len : Q.pos + D;
      const s = o();
      for (; Q.pos < H; ) {
        const k = Q.uint32();
        switch (k >>> 3) {
          case 1:
            s.denom = Q.string();
            break;
          default:
            Q.skipType(k & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(b) {
      const D = o();
      return (0, f.isSet)(b.denom) && (D.denom = String(b.denom)), D;
    },
    toJSON(b) {
      const D = {};
      return b.denom !== void 0 && (D.denom = b.denom), D;
    },
    fromPartial(b) {
      const D = o();
      return D.denom = b.denom ?? "", D;
    }
  };
  function h() {
    return {
      metadata: t.Metadata.fromPartial({})
    };
  }
  e.QueryDenomMetadataResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QueryDenomMetadataResponse",
    encode(b, D = i.BinaryWriter.create()) {
      return b.metadata !== void 0 && t.Metadata.encode(b.metadata, D.uint32(10).fork()).ldelim(), D;
    },
    decode(b, D) {
      const Q = b instanceof i.BinaryReader ? b : new i.BinaryReader(b);
      let H = D === void 0 ? Q.len : Q.pos + D;
      const s = h();
      for (; Q.pos < H; ) {
        const k = Q.uint32();
        switch (k >>> 3) {
          case 1:
            s.metadata = t.Metadata.decode(Q, Q.uint32());
            break;
          default:
            Q.skipType(k & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(b) {
      const D = h();
      return (0, f.isSet)(b.metadata) && (D.metadata = t.Metadata.fromJSON(b.metadata)), D;
    },
    toJSON(b) {
      const D = {};
      return b.metadata !== void 0 && (D.metadata = b.metadata ? t.Metadata.toJSON(b.metadata) : void 0), D;
    },
    fromPartial(b) {
      const D = h();
      return b.metadata !== void 0 && b.metadata !== null && (D.metadata = t.Metadata.fromPartial(b.metadata)), D;
    }
  };
  function N() {
    return {
      denom: "",
      pagination: void 0
    };
  }
  e.QueryDenomOwnersRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QueryDenomOwnersRequest",
    encode(b, D = i.BinaryWriter.create()) {
      return b.denom !== "" && D.uint32(10).string(b.denom), b.pagination !== void 0 && n.PageRequest.encode(b.pagination, D.uint32(18).fork()).ldelim(), D;
    },
    decode(b, D) {
      const Q = b instanceof i.BinaryReader ? b : new i.BinaryReader(b);
      let H = D === void 0 ? Q.len : Q.pos + D;
      const s = N();
      for (; Q.pos < H; ) {
        const k = Q.uint32();
        switch (k >>> 3) {
          case 1:
            s.denom = Q.string();
            break;
          case 2:
            s.pagination = n.PageRequest.decode(Q, Q.uint32());
            break;
          default:
            Q.skipType(k & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(b) {
      const D = N();
      return (0, f.isSet)(b.denom) && (D.denom = String(b.denom)), (0, f.isSet)(b.pagination) && (D.pagination = n.PageRequest.fromJSON(b.pagination)), D;
    },
    toJSON(b) {
      const D = {};
      return b.denom !== void 0 && (D.denom = b.denom), b.pagination !== void 0 && (D.pagination = b.pagination ? n.PageRequest.toJSON(b.pagination) : void 0), D;
    },
    fromPartial(b) {
      const D = N();
      return D.denom = b.denom ?? "", b.pagination !== void 0 && b.pagination !== null && (D.pagination = n.PageRequest.fromPartial(b.pagination)), D;
    }
  };
  function q() {
    return {
      address: "",
      balance: r.Coin.fromPartial({})
    };
  }
  e.DenomOwner = {
    typeUrl: "/cosmos.bank.v1beta1.DenomOwner",
    encode(b, D = i.BinaryWriter.create()) {
      return b.address !== "" && D.uint32(10).string(b.address), b.balance !== void 0 && r.Coin.encode(b.balance, D.uint32(18).fork()).ldelim(), D;
    },
    decode(b, D) {
      const Q = b instanceof i.BinaryReader ? b : new i.BinaryReader(b);
      let H = D === void 0 ? Q.len : Q.pos + D;
      const s = q();
      for (; Q.pos < H; ) {
        const k = Q.uint32();
        switch (k >>> 3) {
          case 1:
            s.address = Q.string();
            break;
          case 2:
            s.balance = r.Coin.decode(Q, Q.uint32());
            break;
          default:
            Q.skipType(k & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(b) {
      const D = q();
      return (0, f.isSet)(b.address) && (D.address = String(b.address)), (0, f.isSet)(b.balance) && (D.balance = r.Coin.fromJSON(b.balance)), D;
    },
    toJSON(b) {
      const D = {};
      return b.address !== void 0 && (D.address = b.address), b.balance !== void 0 && (D.balance = b.balance ? r.Coin.toJSON(b.balance) : void 0), D;
    },
    fromPartial(b) {
      const D = q();
      return D.address = b.address ?? "", b.balance !== void 0 && b.balance !== null && (D.balance = r.Coin.fromPartial(b.balance)), D;
    }
  };
  function u() {
    return {
      denomOwners: [],
      pagination: void 0
    };
  }
  e.QueryDenomOwnersResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QueryDenomOwnersResponse",
    encode(b, D = i.BinaryWriter.create()) {
      for (const Q of b.denomOwners)
        e.DenomOwner.encode(Q, D.uint32(10).fork()).ldelim();
      return b.pagination !== void 0 && n.PageResponse.encode(b.pagination, D.uint32(18).fork()).ldelim(), D;
    },
    decode(b, D) {
      const Q = b instanceof i.BinaryReader ? b : new i.BinaryReader(b);
      let H = D === void 0 ? Q.len : Q.pos + D;
      const s = u();
      for (; Q.pos < H; ) {
        const k = Q.uint32();
        switch (k >>> 3) {
          case 1:
            s.denomOwners.push(e.DenomOwner.decode(Q, Q.uint32()));
            break;
          case 2:
            s.pagination = n.PageResponse.decode(Q, Q.uint32());
            break;
          default:
            Q.skipType(k & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(b) {
      const D = u();
      return Array.isArray(b == null ? void 0 : b.denomOwners) && (D.denomOwners = b.denomOwners.map((Q) => e.DenomOwner.fromJSON(Q))), (0, f.isSet)(b.pagination) && (D.pagination = n.PageResponse.fromJSON(b.pagination)), D;
    },
    toJSON(b) {
      const D = {};
      return b.denomOwners ? D.denomOwners = b.denomOwners.map((Q) => Q ? e.DenomOwner.toJSON(Q) : void 0) : D.denomOwners = [], b.pagination !== void 0 && (D.pagination = b.pagination ? n.PageResponse.toJSON(b.pagination) : void 0), D;
    },
    fromPartial(b) {
      var Q;
      const D = u();
      return D.denomOwners = ((Q = b.denomOwners) == null ? void 0 : Q.map((H) => e.DenomOwner.fromPartial(H))) || [], b.pagination !== void 0 && b.pagination !== null && (D.pagination = n.PageResponse.fromPartial(b.pagination)), D;
    }
  };
  function l() {
    return {
      denoms: [],
      pagination: void 0
    };
  }
  e.QuerySendEnabledRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QuerySendEnabledRequest",
    encode(b, D = i.BinaryWriter.create()) {
      for (const Q of b.denoms)
        D.uint32(10).string(Q);
      return b.pagination !== void 0 && n.PageRequest.encode(b.pagination, D.uint32(794).fork()).ldelim(), D;
    },
    decode(b, D) {
      const Q = b instanceof i.BinaryReader ? b : new i.BinaryReader(b);
      let H = D === void 0 ? Q.len : Q.pos + D;
      const s = l();
      for (; Q.pos < H; ) {
        const k = Q.uint32();
        switch (k >>> 3) {
          case 1:
            s.denoms.push(Q.string());
            break;
          case 99:
            s.pagination = n.PageRequest.decode(Q, Q.uint32());
            break;
          default:
            Q.skipType(k & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(b) {
      const D = l();
      return Array.isArray(b == null ? void 0 : b.denoms) && (D.denoms = b.denoms.map((Q) => String(Q))), (0, f.isSet)(b.pagination) && (D.pagination = n.PageRequest.fromJSON(b.pagination)), D;
    },
    toJSON(b) {
      const D = {};
      return b.denoms ? D.denoms = b.denoms.map((Q) => Q) : D.denoms = [], b.pagination !== void 0 && (D.pagination = b.pagination ? n.PageRequest.toJSON(b.pagination) : void 0), D;
    },
    fromPartial(b) {
      var Q;
      const D = l();
      return D.denoms = ((Q = b.denoms) == null ? void 0 : Q.map((H) => H)) || [], b.pagination !== void 0 && b.pagination !== null && (D.pagination = n.PageRequest.fromPartial(b.pagination)), D;
    }
  };
  function I() {
    return {
      sendEnabled: [],
      pagination: void 0
    };
  }
  e.QuerySendEnabledResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QuerySendEnabledResponse",
    encode(b, D = i.BinaryWriter.create()) {
      for (const Q of b.sendEnabled)
        t.SendEnabled.encode(Q, D.uint32(10).fork()).ldelim();
      return b.pagination !== void 0 && n.PageResponse.encode(b.pagination, D.uint32(794).fork()).ldelim(), D;
    },
    decode(b, D) {
      const Q = b instanceof i.BinaryReader ? b : new i.BinaryReader(b);
      let H = D === void 0 ? Q.len : Q.pos + D;
      const s = I();
      for (; Q.pos < H; ) {
        const k = Q.uint32();
        switch (k >>> 3) {
          case 1:
            s.sendEnabled.push(t.SendEnabled.decode(Q, Q.uint32()));
            break;
          case 99:
            s.pagination = n.PageResponse.decode(Q, Q.uint32());
            break;
          default:
            Q.skipType(k & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(b) {
      const D = I();
      return Array.isArray(b == null ? void 0 : b.sendEnabled) && (D.sendEnabled = b.sendEnabled.map((Q) => t.SendEnabled.fromJSON(Q))), (0, f.isSet)(b.pagination) && (D.pagination = n.PageResponse.fromJSON(b.pagination)), D;
    },
    toJSON(b) {
      const D = {};
      return b.sendEnabled ? D.sendEnabled = b.sendEnabled.map((Q) => Q ? t.SendEnabled.toJSON(Q) : void 0) : D.sendEnabled = [], b.pagination !== void 0 && (D.pagination = b.pagination ? n.PageResponse.toJSON(b.pagination) : void 0), D;
    },
    fromPartial(b) {
      var Q;
      const D = I();
      return D.sendEnabled = ((Q = b.sendEnabled) == null ? void 0 : Q.map((H) => t.SendEnabled.fromPartial(H))) || [], b.pagination !== void 0 && b.pagination !== null && (D.pagination = n.PageResponse.fromPartial(b.pagination)), D;
    }
  };
  class B {
    constructor(D) {
      this.rpc = D, this.Balance = this.Balance.bind(this), this.AllBalances = this.AllBalances.bind(this), this.SpendableBalances = this.SpendableBalances.bind(this), this.SpendableBalanceByDenom = this.SpendableBalanceByDenom.bind(this), this.TotalSupply = this.TotalSupply.bind(this), this.SupplyOf = this.SupplyOf.bind(this), this.Params = this.Params.bind(this), this.DenomMetadata = this.DenomMetadata.bind(this), this.DenomsMetadata = this.DenomsMetadata.bind(this), this.DenomOwners = this.DenomOwners.bind(this), this.SendEnabled = this.SendEnabled.bind(this);
    }
    Balance(D) {
      const Q = e.QueryBalanceRequest.encode(D).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "Balance", Q).then((s) => e.QueryBalanceResponse.decode(new i.BinaryReader(s)));
    }
    AllBalances(D) {
      const Q = e.QueryAllBalancesRequest.encode(D).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "AllBalances", Q).then((s) => e.QueryAllBalancesResponse.decode(new i.BinaryReader(s)));
    }
    SpendableBalances(D) {
      const Q = e.QuerySpendableBalancesRequest.encode(D).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "SpendableBalances", Q).then((s) => e.QuerySpendableBalancesResponse.decode(new i.BinaryReader(s)));
    }
    SpendableBalanceByDenom(D) {
      const Q = e.QuerySpendableBalanceByDenomRequest.encode(D).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "SpendableBalanceByDenom", Q).then((s) => e.QuerySpendableBalanceByDenomResponse.decode(new i.BinaryReader(s)));
    }
    TotalSupply(D = {
      pagination: n.PageRequest.fromPartial({})
    }) {
      const Q = e.QueryTotalSupplyRequest.encode(D).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "TotalSupply", Q).then((s) => e.QueryTotalSupplyResponse.decode(new i.BinaryReader(s)));
    }
    SupplyOf(D) {
      const Q = e.QuerySupplyOfRequest.encode(D).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "SupplyOf", Q).then((s) => e.QuerySupplyOfResponse.decode(new i.BinaryReader(s)));
    }
    Params(D = {}) {
      const Q = e.QueryParamsRequest.encode(D).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "Params", Q).then((s) => e.QueryParamsResponse.decode(new i.BinaryReader(s)));
    }
    DenomMetadata(D) {
      const Q = e.QueryDenomMetadataRequest.encode(D).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "DenomMetadata", Q).then((s) => e.QueryDenomMetadataResponse.decode(new i.BinaryReader(s)));
    }
    DenomsMetadata(D = {
      pagination: n.PageRequest.fromPartial({})
    }) {
      const Q = e.QueryDenomsMetadataRequest.encode(D).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "DenomsMetadata", Q).then((s) => e.QueryDenomsMetadataResponse.decode(new i.BinaryReader(s)));
    }
    DenomOwners(D) {
      const Q = e.QueryDenomOwnersRequest.encode(D).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "DenomOwners", Q).then((s) => e.QueryDenomOwnersResponse.decode(new i.BinaryReader(s)));
    }
    SendEnabled(D) {
      const Q = e.QuerySendEnabledRequest.encode(D).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "SendEnabled", Q).then((s) => e.QuerySendEnabledResponse.decode(new i.BinaryReader(s)));
    }
  }
  e.QueryClientImpl = B;
})(mh);
Object.defineProperty(ms, "__esModule", { value: !0 });
ms.setupBankExtension = void 0;
const su = Te, du = mh, cf = Ye;
function gb(e) {
  const n = (0, cf.createProtobufRpcClient)(e), r = new du.QueryClientImpl(n);
  return {
    bank: {
      balance: async (t, i) => {
        const { balance: f } = await r.Balance({ address: t, denom: i });
        return (0, su.assert)(f), f;
      },
      allBalances: async (t) => {
        const { balances: i } = await r.AllBalances(du.QueryAllBalancesRequest.fromPartial({ address: t }));
        return i;
      },
      totalSupply: async (t) => await r.TotalSupply({
        pagination: (0, cf.createPagination)(t)
      }),
      supplyOf: async (t) => {
        const { amount: i } = await r.SupplyOf({ denom: t });
        return (0, su.assert)(i), i;
      },
      denomMetadata: async (t) => {
        const { metadata: i } = await r.DenomMetadata({ denom: t });
        return (0, su.assert)(i), i;
      },
      denomsMetadata: async () => {
        const { metadatas: t } = await r.DenomsMetadata(du.QueryDenomsMetadataRequest.fromPartial({
          pagination: void 0
          // Not implemented
        }));
        return t;
      }
    }
  };
}
ms.setupBankExtension = gb;
var fi = {};
Object.defineProperty(fi, "__esModule", { value: !0 });
fi.createCrysisAminoConverters = fi.isAminoMsgVerifyInvariant = void 0;
function Sb(e) {
  return e.type === "cosmos-sdk/MsgVerifyInvariant";
}
fi.isAminoMsgVerifyInvariant = Sb;
function kb() {
  throw new Error("Not implemented");
}
fi.createCrysisAminoConverters = kb;
var Tn = {};
Object.defineProperty(Tn, "__esModule", { value: !0 });
Tn.createDistributionAminoConverters = Tn.isAminoMsgFundCommunityPool = Tn.isAminoMsgWithdrawValidatorCommission = Tn.isAminoMsgWithdrawDelegatorReward = Tn.isAminoMsgSetWithdrawAddress = void 0;
function Pb(e) {
  return e.type === "cosmos-sdk/MsgModifyWithdrawAddress";
}
Tn.isAminoMsgSetWithdrawAddress = Pb;
function vb(e) {
  return e.type === "cosmos-sdk/MsgWithdrawDelegationReward";
}
Tn.isAminoMsgWithdrawDelegatorReward = vb;
function bb(e) {
  return e.type === "cosmos-sdk/MsgWithdrawValidatorCommission";
}
Tn.isAminoMsgWithdrawValidatorCommission = bb;
function Rb(e) {
  return e.type === "cosmos-sdk/MsgFundCommunityPool";
}
Tn.isAminoMsgFundCommunityPool = Rb;
function Bb() {
  return {
    "/cosmos.distribution.v1beta1.MsgFundCommunityPool": {
      aminoType: "cosmos-sdk/MsgFundCommunityPool",
      toAmino: ({ amount: e, depositor: n }) => ({
        amount: [...e],
        depositor: n
      }),
      fromAmino: ({ amount: e, depositor: n }) => ({
        amount: [...e],
        depositor: n
      })
    },
    "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress": {
      aminoType: "cosmos-sdk/MsgModifyWithdrawAddress",
      toAmino: ({ delegatorAddress: e, withdrawAddress: n }) => ({
        delegator_address: e,
        withdraw_address: n
      }),
      fromAmino: ({ delegator_address: e, withdraw_address: n }) => ({
        delegatorAddress: e,
        withdrawAddress: n
      })
    },
    "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward": {
      aminoType: "cosmos-sdk/MsgWithdrawDelegationReward",
      toAmino: ({ delegatorAddress: e, validatorAddress: n }) => ({
        delegator_address: e,
        validator_address: n
      }),
      fromAmino: ({ delegator_address: e, validator_address: n }) => ({
        delegatorAddress: e,
        validatorAddress: n
      })
    },
    "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission": {
      aminoType: "cosmos-sdk/MsgWithdrawValidatorCommission",
      toAmino: ({ validatorAddress: e }) => ({
        validator_address: e
      }),
      fromAmino: ({ validator_address: e }) => ({
        validatorAddress: e
      })
    }
  };
}
Tn.createDistributionAminoConverters = Bb;
var pi = {}, Fc = {}, $c = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CommunityPoolSpendProposalWithDeposit = e.DelegationDelegatorReward = e.DelegatorStartingInfo = e.CommunityPoolSpendProposal = e.FeePool = e.ValidatorSlashEvents = e.ValidatorSlashEvent = e.ValidatorOutstandingRewards = e.ValidatorAccumulatedCommission = e.ValidatorCurrentRewards = e.ValidatorHistoricalRewards = e.Params = e.protobufPackage = void 0;
  const n = De, r = re, t = ie;
  e.protobufPackage = "cosmos.distribution.v1beta1";
  function i() {
    return {
      communityTax: "",
      baseProposerReward: "",
      bonusProposerReward: "",
      withdrawAddrEnabled: !1
    };
  }
  e.Params = {
    typeUrl: "/cosmos.distribution.v1beta1.Params",
    encode(d, y = r.BinaryWriter.create()) {
      return d.communityTax !== "" && y.uint32(10).string(d.communityTax), d.baseProposerReward !== "" && y.uint32(18).string(d.baseProposerReward), d.bonusProposerReward !== "" && y.uint32(26).string(d.bonusProposerReward), d.withdrawAddrEnabled === !0 && y.uint32(32).bool(d.withdrawAddrEnabled), y;
    },
    decode(d, y) {
      const _ = d instanceof r.BinaryReader ? d : new r.BinaryReader(d);
      let E = y === void 0 ? _.len : _.pos + y;
      const U = i();
      for (; _.pos < E; ) {
        const V = _.uint32();
        switch (V >>> 3) {
          case 1:
            U.communityTax = _.string();
            break;
          case 2:
            U.baseProposerReward = _.string();
            break;
          case 3:
            U.bonusProposerReward = _.string();
            break;
          case 4:
            U.withdrawAddrEnabled = _.bool();
            break;
          default:
            _.skipType(V & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(d) {
      const y = i();
      return (0, t.isSet)(d.communityTax) && (y.communityTax = String(d.communityTax)), (0, t.isSet)(d.baseProposerReward) && (y.baseProposerReward = String(d.baseProposerReward)), (0, t.isSet)(d.bonusProposerReward) && (y.bonusProposerReward = String(d.bonusProposerReward)), (0, t.isSet)(d.withdrawAddrEnabled) && (y.withdrawAddrEnabled = !!d.withdrawAddrEnabled), y;
    },
    toJSON(d) {
      const y = {};
      return d.communityTax !== void 0 && (y.communityTax = d.communityTax), d.baseProposerReward !== void 0 && (y.baseProposerReward = d.baseProposerReward), d.bonusProposerReward !== void 0 && (y.bonusProposerReward = d.bonusProposerReward), d.withdrawAddrEnabled !== void 0 && (y.withdrawAddrEnabled = d.withdrawAddrEnabled), y;
    },
    fromPartial(d) {
      const y = i();
      return y.communityTax = d.communityTax ?? "", y.baseProposerReward = d.baseProposerReward ?? "", y.bonusProposerReward = d.bonusProposerReward ?? "", y.withdrawAddrEnabled = d.withdrawAddrEnabled ?? !1, y;
    }
  };
  function f() {
    return {
      cumulativeRewardRatio: [],
      referenceCount: 0
    };
  }
  e.ValidatorHistoricalRewards = {
    typeUrl: "/cosmos.distribution.v1beta1.ValidatorHistoricalRewards",
    encode(d, y = r.BinaryWriter.create()) {
      for (const _ of d.cumulativeRewardRatio)
        n.DecCoin.encode(_, y.uint32(10).fork()).ldelim();
      return d.referenceCount !== 0 && y.uint32(16).uint32(d.referenceCount), y;
    },
    decode(d, y) {
      const _ = d instanceof r.BinaryReader ? d : new r.BinaryReader(d);
      let E = y === void 0 ? _.len : _.pos + y;
      const U = f();
      for (; _.pos < E; ) {
        const V = _.uint32();
        switch (V >>> 3) {
          case 1:
            U.cumulativeRewardRatio.push(n.DecCoin.decode(_, _.uint32()));
            break;
          case 2:
            U.referenceCount = _.uint32();
            break;
          default:
            _.skipType(V & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(d) {
      const y = f();
      return Array.isArray(d == null ? void 0 : d.cumulativeRewardRatio) && (y.cumulativeRewardRatio = d.cumulativeRewardRatio.map((_) => n.DecCoin.fromJSON(_))), (0, t.isSet)(d.referenceCount) && (y.referenceCount = Number(d.referenceCount)), y;
    },
    toJSON(d) {
      const y = {};
      return d.cumulativeRewardRatio ? y.cumulativeRewardRatio = d.cumulativeRewardRatio.map((_) => _ ? n.DecCoin.toJSON(_) : void 0) : y.cumulativeRewardRatio = [], d.referenceCount !== void 0 && (y.referenceCount = Math.round(d.referenceCount)), y;
    },
    fromPartial(d) {
      var _;
      const y = f();
      return y.cumulativeRewardRatio = ((_ = d.cumulativeRewardRatio) == null ? void 0 : _.map((E) => n.DecCoin.fromPartial(E))) || [], y.referenceCount = d.referenceCount ?? 0, y;
    }
  };
  function S() {
    return {
      rewards: [],
      period: BigInt(0)
    };
  }
  e.ValidatorCurrentRewards = {
    typeUrl: "/cosmos.distribution.v1beta1.ValidatorCurrentRewards",
    encode(d, y = r.BinaryWriter.create()) {
      for (const _ of d.rewards)
        n.DecCoin.encode(_, y.uint32(10).fork()).ldelim();
      return d.period !== BigInt(0) && y.uint32(16).uint64(d.period), y;
    },
    decode(d, y) {
      const _ = d instanceof r.BinaryReader ? d : new r.BinaryReader(d);
      let E = y === void 0 ? _.len : _.pos + y;
      const U = S();
      for (; _.pos < E; ) {
        const V = _.uint32();
        switch (V >>> 3) {
          case 1:
            U.rewards.push(n.DecCoin.decode(_, _.uint32()));
            break;
          case 2:
            U.period = _.uint64();
            break;
          default:
            _.skipType(V & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(d) {
      const y = S();
      return Array.isArray(d == null ? void 0 : d.rewards) && (y.rewards = d.rewards.map((_) => n.DecCoin.fromJSON(_))), (0, t.isSet)(d.period) && (y.period = BigInt(d.period.toString())), y;
    },
    toJSON(d) {
      const y = {};
      return d.rewards ? y.rewards = d.rewards.map((_) => _ ? n.DecCoin.toJSON(_) : void 0) : y.rewards = [], d.period !== void 0 && (y.period = (d.period || BigInt(0)).toString()), y;
    },
    fromPartial(d) {
      var _;
      const y = S();
      return y.rewards = ((_ = d.rewards) == null ? void 0 : _.map((E) => n.DecCoin.fromPartial(E))) || [], d.period !== void 0 && d.period !== null && (y.period = BigInt(d.period.toString())), y;
    }
  };
  function w() {
    return {
      commission: []
    };
  }
  e.ValidatorAccumulatedCommission = {
    typeUrl: "/cosmos.distribution.v1beta1.ValidatorAccumulatedCommission",
    encode(d, y = r.BinaryWriter.create()) {
      for (const _ of d.commission)
        n.DecCoin.encode(_, y.uint32(10).fork()).ldelim();
      return y;
    },
    decode(d, y) {
      const _ = d instanceof r.BinaryReader ? d : new r.BinaryReader(d);
      let E = y === void 0 ? _.len : _.pos + y;
      const U = w();
      for (; _.pos < E; ) {
        const V = _.uint32();
        switch (V >>> 3) {
          case 1:
            U.commission.push(n.DecCoin.decode(_, _.uint32()));
            break;
          default:
            _.skipType(V & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(d) {
      const y = w();
      return Array.isArray(d == null ? void 0 : d.commission) && (y.commission = d.commission.map((_) => n.DecCoin.fromJSON(_))), y;
    },
    toJSON(d) {
      const y = {};
      return d.commission ? y.commission = d.commission.map((_) => _ ? n.DecCoin.toJSON(_) : void 0) : y.commission = [], y;
    },
    fromPartial(d) {
      var _;
      const y = w();
      return y.commission = ((_ = d.commission) == null ? void 0 : _.map((E) => n.DecCoin.fromPartial(E))) || [], y;
    }
  };
  function T() {
    return {
      rewards: []
    };
  }
  e.ValidatorOutstandingRewards = {
    typeUrl: "/cosmos.distribution.v1beta1.ValidatorOutstandingRewards",
    encode(d, y = r.BinaryWriter.create()) {
      for (const _ of d.rewards)
        n.DecCoin.encode(_, y.uint32(10).fork()).ldelim();
      return y;
    },
    decode(d, y) {
      const _ = d instanceof r.BinaryReader ? d : new r.BinaryReader(d);
      let E = y === void 0 ? _.len : _.pos + y;
      const U = T();
      for (; _.pos < E; ) {
        const V = _.uint32();
        switch (V >>> 3) {
          case 1:
            U.rewards.push(n.DecCoin.decode(_, _.uint32()));
            break;
          default:
            _.skipType(V & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(d) {
      const y = T();
      return Array.isArray(d == null ? void 0 : d.rewards) && (y.rewards = d.rewards.map((_) => n.DecCoin.fromJSON(_))), y;
    },
    toJSON(d) {
      const y = {};
      return d.rewards ? y.rewards = d.rewards.map((_) => _ ? n.DecCoin.toJSON(_) : void 0) : y.rewards = [], y;
    },
    fromPartial(d) {
      var _;
      const y = T();
      return y.rewards = ((_ = d.rewards) == null ? void 0 : _.map((E) => n.DecCoin.fromPartial(E))) || [], y;
    }
  };
  function J() {
    return {
      validatorPeriod: BigInt(0),
      fraction: ""
    };
  }
  e.ValidatorSlashEvent = {
    typeUrl: "/cosmos.distribution.v1beta1.ValidatorSlashEvent",
    encode(d, y = r.BinaryWriter.create()) {
      return d.validatorPeriod !== BigInt(0) && y.uint32(8).uint64(d.validatorPeriod), d.fraction !== "" && y.uint32(18).string(d.fraction), y;
    },
    decode(d, y) {
      const _ = d instanceof r.BinaryReader ? d : new r.BinaryReader(d);
      let E = y === void 0 ? _.len : _.pos + y;
      const U = J();
      for (; _.pos < E; ) {
        const V = _.uint32();
        switch (V >>> 3) {
          case 1:
            U.validatorPeriod = _.uint64();
            break;
          case 2:
            U.fraction = _.string();
            break;
          default:
            _.skipType(V & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(d) {
      const y = J();
      return (0, t.isSet)(d.validatorPeriod) && (y.validatorPeriod = BigInt(d.validatorPeriod.toString())), (0, t.isSet)(d.fraction) && (y.fraction = String(d.fraction)), y;
    },
    toJSON(d) {
      const y = {};
      return d.validatorPeriod !== void 0 && (y.validatorPeriod = (d.validatorPeriod || BigInt(0)).toString()), d.fraction !== void 0 && (y.fraction = d.fraction), y;
    },
    fromPartial(d) {
      const y = J();
      return d.validatorPeriod !== void 0 && d.validatorPeriod !== null && (y.validatorPeriod = BigInt(d.validatorPeriod.toString())), y.fraction = d.fraction ?? "", y;
    }
  };
  function C() {
    return {
      validatorSlashEvents: []
    };
  }
  e.ValidatorSlashEvents = {
    typeUrl: "/cosmos.distribution.v1beta1.ValidatorSlashEvents",
    encode(d, y = r.BinaryWriter.create()) {
      for (const _ of d.validatorSlashEvents)
        e.ValidatorSlashEvent.encode(_, y.uint32(10).fork()).ldelim();
      return y;
    },
    decode(d, y) {
      const _ = d instanceof r.BinaryReader ? d : new r.BinaryReader(d);
      let E = y === void 0 ? _.len : _.pos + y;
      const U = C();
      for (; _.pos < E; ) {
        const V = _.uint32();
        switch (V >>> 3) {
          case 1:
            U.validatorSlashEvents.push(e.ValidatorSlashEvent.decode(_, _.uint32()));
            break;
          default:
            _.skipType(V & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(d) {
      const y = C();
      return Array.isArray(d == null ? void 0 : d.validatorSlashEvents) && (y.validatorSlashEvents = d.validatorSlashEvents.map((_) => e.ValidatorSlashEvent.fromJSON(_))), y;
    },
    toJSON(d) {
      const y = {};
      return d.validatorSlashEvents ? y.validatorSlashEvents = d.validatorSlashEvents.map((_) => _ ? e.ValidatorSlashEvent.toJSON(_) : void 0) : y.validatorSlashEvents = [], y;
    },
    fromPartial(d) {
      var _;
      const y = C();
      return y.validatorSlashEvents = ((_ = d.validatorSlashEvents) == null ? void 0 : _.map((E) => e.ValidatorSlashEvent.fromPartial(E))) || [], y;
    }
  };
  function R() {
    return {
      communityPool: []
    };
  }
  e.FeePool = {
    typeUrl: "/cosmos.distribution.v1beta1.FeePool",
    encode(d, y = r.BinaryWriter.create()) {
      for (const _ of d.communityPool)
        n.DecCoin.encode(_, y.uint32(10).fork()).ldelim();
      return y;
    },
    decode(d, y) {
      const _ = d instanceof r.BinaryReader ? d : new r.BinaryReader(d);
      let E = y === void 0 ? _.len : _.pos + y;
      const U = R();
      for (; _.pos < E; ) {
        const V = _.uint32();
        switch (V >>> 3) {
          case 1:
            U.communityPool.push(n.DecCoin.decode(_, _.uint32()));
            break;
          default:
            _.skipType(V & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(d) {
      const y = R();
      return Array.isArray(d == null ? void 0 : d.communityPool) && (y.communityPool = d.communityPool.map((_) => n.DecCoin.fromJSON(_))), y;
    },
    toJSON(d) {
      const y = {};
      return d.communityPool ? y.communityPool = d.communityPool.map((_) => _ ? n.DecCoin.toJSON(_) : void 0) : y.communityPool = [], y;
    },
    fromPartial(d) {
      var _;
      const y = R();
      return y.communityPool = ((_ = d.communityPool) == null ? void 0 : _.map((E) => n.DecCoin.fromPartial(E))) || [], y;
    }
  };
  function p() {
    return {
      title: "",
      description: "",
      recipient: "",
      amount: []
    };
  }
  e.CommunityPoolSpendProposal = {
    typeUrl: "/cosmos.distribution.v1beta1.CommunityPoolSpendProposal",
    encode(d, y = r.BinaryWriter.create()) {
      d.title !== "" && y.uint32(10).string(d.title), d.description !== "" && y.uint32(18).string(d.description), d.recipient !== "" && y.uint32(26).string(d.recipient);
      for (const _ of d.amount)
        n.Coin.encode(_, y.uint32(34).fork()).ldelim();
      return y;
    },
    decode(d, y) {
      const _ = d instanceof r.BinaryReader ? d : new r.BinaryReader(d);
      let E = y === void 0 ? _.len : _.pos + y;
      const U = p();
      for (; _.pos < E; ) {
        const V = _.uint32();
        switch (V >>> 3) {
          case 1:
            U.title = _.string();
            break;
          case 2:
            U.description = _.string();
            break;
          case 3:
            U.recipient = _.string();
            break;
          case 4:
            U.amount.push(n.Coin.decode(_, _.uint32()));
            break;
          default:
            _.skipType(V & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(d) {
      const y = p();
      return (0, t.isSet)(d.title) && (y.title = String(d.title)), (0, t.isSet)(d.description) && (y.description = String(d.description)), (0, t.isSet)(d.recipient) && (y.recipient = String(d.recipient)), Array.isArray(d == null ? void 0 : d.amount) && (y.amount = d.amount.map((_) => n.Coin.fromJSON(_))), y;
    },
    toJSON(d) {
      const y = {};
      return d.title !== void 0 && (y.title = d.title), d.description !== void 0 && (y.description = d.description), d.recipient !== void 0 && (y.recipient = d.recipient), d.amount ? y.amount = d.amount.map((_) => _ ? n.Coin.toJSON(_) : void 0) : y.amount = [], y;
    },
    fromPartial(d) {
      var _;
      const y = p();
      return y.title = d.title ?? "", y.description = d.description ?? "", y.recipient = d.recipient ?? "", y.amount = ((_ = d.amount) == null ? void 0 : _.map((E) => n.Coin.fromPartial(E))) || [], y;
    }
  };
  function m() {
    return {
      previousPeriod: BigInt(0),
      stake: "",
      height: BigInt(0)
    };
  }
  e.DelegatorStartingInfo = {
    typeUrl: "/cosmos.distribution.v1beta1.DelegatorStartingInfo",
    encode(d, y = r.BinaryWriter.create()) {
      return d.previousPeriod !== BigInt(0) && y.uint32(8).uint64(d.previousPeriod), d.stake !== "" && y.uint32(18).string(d.stake), d.height !== BigInt(0) && y.uint32(24).uint64(d.height), y;
    },
    decode(d, y) {
      const _ = d instanceof r.BinaryReader ? d : new r.BinaryReader(d);
      let E = y === void 0 ? _.len : _.pos + y;
      const U = m();
      for (; _.pos < E; ) {
        const V = _.uint32();
        switch (V >>> 3) {
          case 1:
            U.previousPeriod = _.uint64();
            break;
          case 2:
            U.stake = _.string();
            break;
          case 3:
            U.height = _.uint64();
            break;
          default:
            _.skipType(V & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(d) {
      const y = m();
      return (0, t.isSet)(d.previousPeriod) && (y.previousPeriod = BigInt(d.previousPeriod.toString())), (0, t.isSet)(d.stake) && (y.stake = String(d.stake)), (0, t.isSet)(d.height) && (y.height = BigInt(d.height.toString())), y;
    },
    toJSON(d) {
      const y = {};
      return d.previousPeriod !== void 0 && (y.previousPeriod = (d.previousPeriod || BigInt(0)).toString()), d.stake !== void 0 && (y.stake = d.stake), d.height !== void 0 && (y.height = (d.height || BigInt(0)).toString()), y;
    },
    fromPartial(d) {
      const y = m();
      return d.previousPeriod !== void 0 && d.previousPeriod !== null && (y.previousPeriod = BigInt(d.previousPeriod.toString())), y.stake = d.stake ?? "", d.height !== void 0 && d.height !== null && (y.height = BigInt(d.height.toString())), y;
    }
  };
  function v() {
    return {
      validatorAddress: "",
      reward: []
    };
  }
  e.DelegationDelegatorReward = {
    typeUrl: "/cosmos.distribution.v1beta1.DelegationDelegatorReward",
    encode(d, y = r.BinaryWriter.create()) {
      d.validatorAddress !== "" && y.uint32(10).string(d.validatorAddress);
      for (const _ of d.reward)
        n.DecCoin.encode(_, y.uint32(18).fork()).ldelim();
      return y;
    },
    decode(d, y) {
      const _ = d instanceof r.BinaryReader ? d : new r.BinaryReader(d);
      let E = y === void 0 ? _.len : _.pos + y;
      const U = v();
      for (; _.pos < E; ) {
        const V = _.uint32();
        switch (V >>> 3) {
          case 1:
            U.validatorAddress = _.string();
            break;
          case 2:
            U.reward.push(n.DecCoin.decode(_, _.uint32()));
            break;
          default:
            _.skipType(V & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(d) {
      const y = v();
      return (0, t.isSet)(d.validatorAddress) && (y.validatorAddress = String(d.validatorAddress)), Array.isArray(d == null ? void 0 : d.reward) && (y.reward = d.reward.map((_) => n.DecCoin.fromJSON(_))), y;
    },
    toJSON(d) {
      const y = {};
      return d.validatorAddress !== void 0 && (y.validatorAddress = d.validatorAddress), d.reward ? y.reward = d.reward.map((_) => _ ? n.DecCoin.toJSON(_) : void 0) : y.reward = [], y;
    },
    fromPartial(d) {
      var _;
      const y = v();
      return y.validatorAddress = d.validatorAddress ?? "", y.reward = ((_ = d.reward) == null ? void 0 : _.map((E) => n.DecCoin.fromPartial(E))) || [], y;
    }
  };
  function a() {
    return {
      title: "",
      description: "",
      recipient: "",
      amount: "",
      deposit: ""
    };
  }
  e.CommunityPoolSpendProposalWithDeposit = {
    typeUrl: "/cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit",
    encode(d, y = r.BinaryWriter.create()) {
      return d.title !== "" && y.uint32(10).string(d.title), d.description !== "" && y.uint32(18).string(d.description), d.recipient !== "" && y.uint32(26).string(d.recipient), d.amount !== "" && y.uint32(34).string(d.amount), d.deposit !== "" && y.uint32(42).string(d.deposit), y;
    },
    decode(d, y) {
      const _ = d instanceof r.BinaryReader ? d : new r.BinaryReader(d);
      let E = y === void 0 ? _.len : _.pos + y;
      const U = a();
      for (; _.pos < E; ) {
        const V = _.uint32();
        switch (V >>> 3) {
          case 1:
            U.title = _.string();
            break;
          case 2:
            U.description = _.string();
            break;
          case 3:
            U.recipient = _.string();
            break;
          case 4:
            U.amount = _.string();
            break;
          case 5:
            U.deposit = _.string();
            break;
          default:
            _.skipType(V & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(d) {
      const y = a();
      return (0, t.isSet)(d.title) && (y.title = String(d.title)), (0, t.isSet)(d.description) && (y.description = String(d.description)), (0, t.isSet)(d.recipient) && (y.recipient = String(d.recipient)), (0, t.isSet)(d.amount) && (y.amount = String(d.amount)), (0, t.isSet)(d.deposit) && (y.deposit = String(d.deposit)), y;
    },
    toJSON(d) {
      const y = {};
      return d.title !== void 0 && (y.title = d.title), d.description !== void 0 && (y.description = d.description), d.recipient !== void 0 && (y.recipient = d.recipient), d.amount !== void 0 && (y.amount = d.amount), d.deposit !== void 0 && (y.deposit = d.deposit), y;
    },
    fromPartial(d) {
      const y = a();
      return y.title = d.title ?? "", y.description = d.description ?? "", y.recipient = d.recipient ?? "", y.amount = d.amount ?? "", y.deposit = d.deposit ?? "", y;
    }
  };
})($c);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgCommunityPoolSpendResponse = e.MsgCommunityPoolSpend = e.MsgUpdateParamsResponse = e.MsgUpdateParams = e.MsgFundCommunityPoolResponse = e.MsgFundCommunityPool = e.MsgWithdrawValidatorCommissionResponse = e.MsgWithdrawValidatorCommission = e.MsgWithdrawDelegatorRewardResponse = e.MsgWithdrawDelegatorReward = e.MsgSetWithdrawAddressResponse = e.MsgSetWithdrawAddress = e.protobufPackage = void 0;
  const n = De, r = $c, t = re, i = ie;
  e.protobufPackage = "cosmos.distribution.v1beta1";
  function f() {
    return {
      delegatorAddress: "",
      withdrawAddress: ""
    };
  }
  e.MsgSetWithdrawAddress = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress",
    encode(_, E = t.BinaryWriter.create()) {
      return _.delegatorAddress !== "" && E.uint32(10).string(_.delegatorAddress), _.withdrawAddress !== "" && E.uint32(18).string(_.withdrawAddress), E;
    },
    decode(_, E) {
      const U = _ instanceof t.BinaryReader ? _ : new t.BinaryReader(_);
      let V = E === void 0 ? U.len : U.pos + E;
      const o = f();
      for (; U.pos < V; ) {
        const h = U.uint32();
        switch (h >>> 3) {
          case 1:
            o.delegatorAddress = U.string();
            break;
          case 2:
            o.withdrawAddress = U.string();
            break;
          default:
            U.skipType(h & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(_) {
      const E = f();
      return (0, i.isSet)(_.delegatorAddress) && (E.delegatorAddress = String(_.delegatorAddress)), (0, i.isSet)(_.withdrawAddress) && (E.withdrawAddress = String(_.withdrawAddress)), E;
    },
    toJSON(_) {
      const E = {};
      return _.delegatorAddress !== void 0 && (E.delegatorAddress = _.delegatorAddress), _.withdrawAddress !== void 0 && (E.withdrawAddress = _.withdrawAddress), E;
    },
    fromPartial(_) {
      const E = f();
      return E.delegatorAddress = _.delegatorAddress ?? "", E.withdrawAddress = _.withdrawAddress ?? "", E;
    }
  };
  function S() {
    return {};
  }
  e.MsgSetWithdrawAddressResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgSetWithdrawAddressResponse",
    encode(_, E = t.BinaryWriter.create()) {
      return E;
    },
    decode(_, E) {
      const U = _ instanceof t.BinaryReader ? _ : new t.BinaryReader(_);
      let V = E === void 0 ? U.len : U.pos + E;
      const o = S();
      for (; U.pos < V; ) {
        const h = U.uint32();
        switch (h >>> 3) {
          default:
            U.skipType(h & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(_) {
      return S();
    },
    toJSON(_) {
      return {};
    },
    fromPartial(_) {
      return S();
    }
  };
  function w() {
    return {
      delegatorAddress: "",
      validatorAddress: ""
    };
  }
  e.MsgWithdrawDelegatorReward = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
    encode(_, E = t.BinaryWriter.create()) {
      return _.delegatorAddress !== "" && E.uint32(10).string(_.delegatorAddress), _.validatorAddress !== "" && E.uint32(18).string(_.validatorAddress), E;
    },
    decode(_, E) {
      const U = _ instanceof t.BinaryReader ? _ : new t.BinaryReader(_);
      let V = E === void 0 ? U.len : U.pos + E;
      const o = w();
      for (; U.pos < V; ) {
        const h = U.uint32();
        switch (h >>> 3) {
          case 1:
            o.delegatorAddress = U.string();
            break;
          case 2:
            o.validatorAddress = U.string();
            break;
          default:
            U.skipType(h & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(_) {
      const E = w();
      return (0, i.isSet)(_.delegatorAddress) && (E.delegatorAddress = String(_.delegatorAddress)), (0, i.isSet)(_.validatorAddress) && (E.validatorAddress = String(_.validatorAddress)), E;
    },
    toJSON(_) {
      const E = {};
      return _.delegatorAddress !== void 0 && (E.delegatorAddress = _.delegatorAddress), _.validatorAddress !== void 0 && (E.validatorAddress = _.validatorAddress), E;
    },
    fromPartial(_) {
      const E = w();
      return E.delegatorAddress = _.delegatorAddress ?? "", E.validatorAddress = _.validatorAddress ?? "", E;
    }
  };
  function T() {
    return {
      amount: []
    };
  }
  e.MsgWithdrawDelegatorRewardResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorRewardResponse",
    encode(_, E = t.BinaryWriter.create()) {
      for (const U of _.amount)
        n.Coin.encode(U, E.uint32(10).fork()).ldelim();
      return E;
    },
    decode(_, E) {
      const U = _ instanceof t.BinaryReader ? _ : new t.BinaryReader(_);
      let V = E === void 0 ? U.len : U.pos + E;
      const o = T();
      for (; U.pos < V; ) {
        const h = U.uint32();
        switch (h >>> 3) {
          case 1:
            o.amount.push(n.Coin.decode(U, U.uint32()));
            break;
          default:
            U.skipType(h & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(_) {
      const E = T();
      return Array.isArray(_ == null ? void 0 : _.amount) && (E.amount = _.amount.map((U) => n.Coin.fromJSON(U))), E;
    },
    toJSON(_) {
      const E = {};
      return _.amount ? E.amount = _.amount.map((U) => U ? n.Coin.toJSON(U) : void 0) : E.amount = [], E;
    },
    fromPartial(_) {
      var U;
      const E = T();
      return E.amount = ((U = _.amount) == null ? void 0 : U.map((V) => n.Coin.fromPartial(V))) || [], E;
    }
  };
  function J() {
    return {
      validatorAddress: ""
    };
  }
  e.MsgWithdrawValidatorCommission = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission",
    encode(_, E = t.BinaryWriter.create()) {
      return _.validatorAddress !== "" && E.uint32(10).string(_.validatorAddress), E;
    },
    decode(_, E) {
      const U = _ instanceof t.BinaryReader ? _ : new t.BinaryReader(_);
      let V = E === void 0 ? U.len : U.pos + E;
      const o = J();
      for (; U.pos < V; ) {
        const h = U.uint32();
        switch (h >>> 3) {
          case 1:
            o.validatorAddress = U.string();
            break;
          default:
            U.skipType(h & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(_) {
      const E = J();
      return (0, i.isSet)(_.validatorAddress) && (E.validatorAddress = String(_.validatorAddress)), E;
    },
    toJSON(_) {
      const E = {};
      return _.validatorAddress !== void 0 && (E.validatorAddress = _.validatorAddress), E;
    },
    fromPartial(_) {
      const E = J();
      return E.validatorAddress = _.validatorAddress ?? "", E;
    }
  };
  function C() {
    return {
      amount: []
    };
  }
  e.MsgWithdrawValidatorCommissionResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommissionResponse",
    encode(_, E = t.BinaryWriter.create()) {
      for (const U of _.amount)
        n.Coin.encode(U, E.uint32(10).fork()).ldelim();
      return E;
    },
    decode(_, E) {
      const U = _ instanceof t.BinaryReader ? _ : new t.BinaryReader(_);
      let V = E === void 0 ? U.len : U.pos + E;
      const o = C();
      for (; U.pos < V; ) {
        const h = U.uint32();
        switch (h >>> 3) {
          case 1:
            o.amount.push(n.Coin.decode(U, U.uint32()));
            break;
          default:
            U.skipType(h & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(_) {
      const E = C();
      return Array.isArray(_ == null ? void 0 : _.amount) && (E.amount = _.amount.map((U) => n.Coin.fromJSON(U))), E;
    },
    toJSON(_) {
      const E = {};
      return _.amount ? E.amount = _.amount.map((U) => U ? n.Coin.toJSON(U) : void 0) : E.amount = [], E;
    },
    fromPartial(_) {
      var U;
      const E = C();
      return E.amount = ((U = _.amount) == null ? void 0 : U.map((V) => n.Coin.fromPartial(V))) || [], E;
    }
  };
  function R() {
    return {
      amount: [],
      depositor: ""
    };
  }
  e.MsgFundCommunityPool = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgFundCommunityPool",
    encode(_, E = t.BinaryWriter.create()) {
      for (const U of _.amount)
        n.Coin.encode(U, E.uint32(10).fork()).ldelim();
      return _.depositor !== "" && E.uint32(18).string(_.depositor), E;
    },
    decode(_, E) {
      const U = _ instanceof t.BinaryReader ? _ : new t.BinaryReader(_);
      let V = E === void 0 ? U.len : U.pos + E;
      const o = R();
      for (; U.pos < V; ) {
        const h = U.uint32();
        switch (h >>> 3) {
          case 1:
            o.amount.push(n.Coin.decode(U, U.uint32()));
            break;
          case 2:
            o.depositor = U.string();
            break;
          default:
            U.skipType(h & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(_) {
      const E = R();
      return Array.isArray(_ == null ? void 0 : _.amount) && (E.amount = _.amount.map((U) => n.Coin.fromJSON(U))), (0, i.isSet)(_.depositor) && (E.depositor = String(_.depositor)), E;
    },
    toJSON(_) {
      const E = {};
      return _.amount ? E.amount = _.amount.map((U) => U ? n.Coin.toJSON(U) : void 0) : E.amount = [], _.depositor !== void 0 && (E.depositor = _.depositor), E;
    },
    fromPartial(_) {
      var U;
      const E = R();
      return E.amount = ((U = _.amount) == null ? void 0 : U.map((V) => n.Coin.fromPartial(V))) || [], E.depositor = _.depositor ?? "", E;
    }
  };
  function p() {
    return {};
  }
  e.MsgFundCommunityPoolResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgFundCommunityPoolResponse",
    encode(_, E = t.BinaryWriter.create()) {
      return E;
    },
    decode(_, E) {
      const U = _ instanceof t.BinaryReader ? _ : new t.BinaryReader(_);
      let V = E === void 0 ? U.len : U.pos + E;
      const o = p();
      for (; U.pos < V; ) {
        const h = U.uint32();
        switch (h >>> 3) {
          default:
            U.skipType(h & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(_) {
      return p();
    },
    toJSON(_) {
      return {};
    },
    fromPartial(_) {
      return p();
    }
  };
  function m() {
    return {
      authority: "",
      params: r.Params.fromPartial({})
    };
  }
  e.MsgUpdateParams = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgUpdateParams",
    encode(_, E = t.BinaryWriter.create()) {
      return _.authority !== "" && E.uint32(10).string(_.authority), _.params !== void 0 && r.Params.encode(_.params, E.uint32(18).fork()).ldelim(), E;
    },
    decode(_, E) {
      const U = _ instanceof t.BinaryReader ? _ : new t.BinaryReader(_);
      let V = E === void 0 ? U.len : U.pos + E;
      const o = m();
      for (; U.pos < V; ) {
        const h = U.uint32();
        switch (h >>> 3) {
          case 1:
            o.authority = U.string();
            break;
          case 2:
            o.params = r.Params.decode(U, U.uint32());
            break;
          default:
            U.skipType(h & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(_) {
      const E = m();
      return (0, i.isSet)(_.authority) && (E.authority = String(_.authority)), (0, i.isSet)(_.params) && (E.params = r.Params.fromJSON(_.params)), E;
    },
    toJSON(_) {
      const E = {};
      return _.authority !== void 0 && (E.authority = _.authority), _.params !== void 0 && (E.params = _.params ? r.Params.toJSON(_.params) : void 0), E;
    },
    fromPartial(_) {
      const E = m();
      return E.authority = _.authority ?? "", _.params !== void 0 && _.params !== null && (E.params = r.Params.fromPartial(_.params)), E;
    }
  };
  function v() {
    return {};
  }
  e.MsgUpdateParamsResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgUpdateParamsResponse",
    encode(_, E = t.BinaryWriter.create()) {
      return E;
    },
    decode(_, E) {
      const U = _ instanceof t.BinaryReader ? _ : new t.BinaryReader(_);
      let V = E === void 0 ? U.len : U.pos + E;
      const o = v();
      for (; U.pos < V; ) {
        const h = U.uint32();
        switch (h >>> 3) {
          default:
            U.skipType(h & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(_) {
      return v();
    },
    toJSON(_) {
      return {};
    },
    fromPartial(_) {
      return v();
    }
  };
  function a() {
    return {
      authority: "",
      recipient: "",
      amount: []
    };
  }
  e.MsgCommunityPoolSpend = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgCommunityPoolSpend",
    encode(_, E = t.BinaryWriter.create()) {
      _.authority !== "" && E.uint32(10).string(_.authority), _.recipient !== "" && E.uint32(18).string(_.recipient);
      for (const U of _.amount)
        n.Coin.encode(U, E.uint32(26).fork()).ldelim();
      return E;
    },
    decode(_, E) {
      const U = _ instanceof t.BinaryReader ? _ : new t.BinaryReader(_);
      let V = E === void 0 ? U.len : U.pos + E;
      const o = a();
      for (; U.pos < V; ) {
        const h = U.uint32();
        switch (h >>> 3) {
          case 1:
            o.authority = U.string();
            break;
          case 2:
            o.recipient = U.string();
            break;
          case 3:
            o.amount.push(n.Coin.decode(U, U.uint32()));
            break;
          default:
            U.skipType(h & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(_) {
      const E = a();
      return (0, i.isSet)(_.authority) && (E.authority = String(_.authority)), (0, i.isSet)(_.recipient) && (E.recipient = String(_.recipient)), Array.isArray(_ == null ? void 0 : _.amount) && (E.amount = _.amount.map((U) => n.Coin.fromJSON(U))), E;
    },
    toJSON(_) {
      const E = {};
      return _.authority !== void 0 && (E.authority = _.authority), _.recipient !== void 0 && (E.recipient = _.recipient), _.amount ? E.amount = _.amount.map((U) => U ? n.Coin.toJSON(U) : void 0) : E.amount = [], E;
    },
    fromPartial(_) {
      var U;
      const E = a();
      return E.authority = _.authority ?? "", E.recipient = _.recipient ?? "", E.amount = ((U = _.amount) == null ? void 0 : U.map((V) => n.Coin.fromPartial(V))) || [], E;
    }
  };
  function d() {
    return {};
  }
  e.MsgCommunityPoolSpendResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgCommunityPoolSpendResponse",
    encode(_, E = t.BinaryWriter.create()) {
      return E;
    },
    decode(_, E) {
      const U = _ instanceof t.BinaryReader ? _ : new t.BinaryReader(_);
      let V = E === void 0 ? U.len : U.pos + E;
      const o = d();
      for (; U.pos < V; ) {
        const h = U.uint32();
        switch (h >>> 3) {
          default:
            U.skipType(h & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(_) {
      return d();
    },
    toJSON(_) {
      return {};
    },
    fromPartial(_) {
      return d();
    }
  };
  class y {
    constructor(E) {
      this.rpc = E, this.SetWithdrawAddress = this.SetWithdrawAddress.bind(this), this.WithdrawDelegatorReward = this.WithdrawDelegatorReward.bind(this), this.WithdrawValidatorCommission = this.WithdrawValidatorCommission.bind(this), this.FundCommunityPool = this.FundCommunityPool.bind(this), this.UpdateParams = this.UpdateParams.bind(this), this.CommunityPoolSpend = this.CommunityPoolSpend.bind(this);
    }
    SetWithdrawAddress(E) {
      const U = e.MsgSetWithdrawAddress.encode(E).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Msg", "SetWithdrawAddress", U).then((o) => e.MsgSetWithdrawAddressResponse.decode(new t.BinaryReader(o)));
    }
    WithdrawDelegatorReward(E) {
      const U = e.MsgWithdrawDelegatorReward.encode(E).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Msg", "WithdrawDelegatorReward", U).then((o) => e.MsgWithdrawDelegatorRewardResponse.decode(new t.BinaryReader(o)));
    }
    WithdrawValidatorCommission(E) {
      const U = e.MsgWithdrawValidatorCommission.encode(E).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Msg", "WithdrawValidatorCommission", U).then((o) => e.MsgWithdrawValidatorCommissionResponse.decode(new t.BinaryReader(o)));
    }
    FundCommunityPool(E) {
      const U = e.MsgFundCommunityPool.encode(E).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Msg", "FundCommunityPool", U).then((o) => e.MsgFundCommunityPoolResponse.decode(new t.BinaryReader(o)));
    }
    UpdateParams(E) {
      const U = e.MsgUpdateParams.encode(E).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Msg", "UpdateParams", U).then((o) => e.MsgUpdateParamsResponse.decode(new t.BinaryReader(o)));
    }
    CommunityPoolSpend(E) {
      const U = e.MsgCommunityPoolSpend.encode(E).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Msg", "CommunityPoolSpend", U).then((o) => e.MsgCommunityPoolSpendResponse.decode(new t.BinaryReader(o)));
    }
  }
  e.MsgClientImpl = y;
})(Fc);
Object.defineProperty(pi, "__esModule", { value: !0 });
pi.isMsgWithdrawDelegatorRewardEncodeObject = pi.distributionTypes = void 0;
const Ko = Fc;
pi.distributionTypes = [
  ["/cosmos.distribution.v1beta1.MsgFundCommunityPool", Ko.MsgFundCommunityPool],
  ["/cosmos.distribution.v1beta1.MsgSetWithdrawAddress", Ko.MsgSetWithdrawAddress],
  ["/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward", Ko.MsgWithdrawDelegatorReward],
  ["/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission", Ko.MsgWithdrawValidatorCommission]
];
function Ob(e) {
  return e.typeUrl === "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward";
}
pi.isMsgWithdrawDelegatorRewardEncodeObject = Ob;
var gs = {}, gh = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryCommunityPoolResponse = e.QueryCommunityPoolRequest = e.QueryDelegatorWithdrawAddressResponse = e.QueryDelegatorWithdrawAddressRequest = e.QueryDelegatorValidatorsResponse = e.QueryDelegatorValidatorsRequest = e.QueryDelegationTotalRewardsResponse = e.QueryDelegationTotalRewardsRequest = e.QueryDelegationRewardsResponse = e.QueryDelegationRewardsRequest = e.QueryValidatorSlashesResponse = e.QueryValidatorSlashesRequest = e.QueryValidatorCommissionResponse = e.QueryValidatorCommissionRequest = e.QueryValidatorOutstandingRewardsResponse = e.QueryValidatorOutstandingRewardsRequest = e.QueryValidatorDistributionInfoResponse = e.QueryValidatorDistributionInfoRequest = e.QueryParamsResponse = e.QueryParamsRequest = e.protobufPackage = void 0;
  const n = Ae, r = $c, t = De, i = re, f = ie;
  e.protobufPackage = "cosmos.distribution.v1beta1";
  function S() {
    return {};
  }
  e.QueryParamsRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryParamsRequest",
    encode(l, I = i.BinaryWriter.create()) {
      return I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = S();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      return S();
    },
    toJSON(l) {
      return {};
    },
    fromPartial(l) {
      return S();
    }
  };
  function w() {
    return {
      params: r.Params.fromPartial({})
    };
  }
  e.QueryParamsResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryParamsResponse",
    encode(l, I = i.BinaryWriter.create()) {
      return l.params !== void 0 && r.Params.encode(l.params, I.uint32(10).fork()).ldelim(), I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = w();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.params = r.Params.decode(B, B.uint32());
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = w();
      return (0, f.isSet)(l.params) && (I.params = r.Params.fromJSON(l.params)), I;
    },
    toJSON(l) {
      const I = {};
      return l.params !== void 0 && (I.params = l.params ? r.Params.toJSON(l.params) : void 0), I;
    },
    fromPartial(l) {
      const I = w();
      return l.params !== void 0 && l.params !== null && (I.params = r.Params.fromPartial(l.params)), I;
    }
  };
  function T() {
    return {
      validatorAddress: ""
    };
  }
  e.QueryValidatorDistributionInfoRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorDistributionInfoRequest",
    encode(l, I = i.BinaryWriter.create()) {
      return l.validatorAddress !== "" && I.uint32(10).string(l.validatorAddress), I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = T();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.validatorAddress = B.string();
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = T();
      return (0, f.isSet)(l.validatorAddress) && (I.validatorAddress = String(l.validatorAddress)), I;
    },
    toJSON(l) {
      const I = {};
      return l.validatorAddress !== void 0 && (I.validatorAddress = l.validatorAddress), I;
    },
    fromPartial(l) {
      const I = T();
      return I.validatorAddress = l.validatorAddress ?? "", I;
    }
  };
  function J() {
    return {
      operatorAddress: "",
      selfBondRewards: [],
      commission: []
    };
  }
  e.QueryValidatorDistributionInfoResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorDistributionInfoResponse",
    encode(l, I = i.BinaryWriter.create()) {
      l.operatorAddress !== "" && I.uint32(10).string(l.operatorAddress);
      for (const B of l.selfBondRewards)
        t.DecCoin.encode(B, I.uint32(18).fork()).ldelim();
      for (const B of l.commission)
        t.DecCoin.encode(B, I.uint32(26).fork()).ldelim();
      return I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = J();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.operatorAddress = B.string();
            break;
          case 2:
            D.selfBondRewards.push(t.DecCoin.decode(B, B.uint32()));
            break;
          case 3:
            D.commission.push(t.DecCoin.decode(B, B.uint32()));
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = J();
      return (0, f.isSet)(l.operatorAddress) && (I.operatorAddress = String(l.operatorAddress)), Array.isArray(l == null ? void 0 : l.selfBondRewards) && (I.selfBondRewards = l.selfBondRewards.map((B) => t.DecCoin.fromJSON(B))), Array.isArray(l == null ? void 0 : l.commission) && (I.commission = l.commission.map((B) => t.DecCoin.fromJSON(B))), I;
    },
    toJSON(l) {
      const I = {};
      return l.operatorAddress !== void 0 && (I.operatorAddress = l.operatorAddress), l.selfBondRewards ? I.selfBondRewards = l.selfBondRewards.map((B) => B ? t.DecCoin.toJSON(B) : void 0) : I.selfBondRewards = [], l.commission ? I.commission = l.commission.map((B) => B ? t.DecCoin.toJSON(B) : void 0) : I.commission = [], I;
    },
    fromPartial(l) {
      var B, b;
      const I = J();
      return I.operatorAddress = l.operatorAddress ?? "", I.selfBondRewards = ((B = l.selfBondRewards) == null ? void 0 : B.map((D) => t.DecCoin.fromPartial(D))) || [], I.commission = ((b = l.commission) == null ? void 0 : b.map((D) => t.DecCoin.fromPartial(D))) || [], I;
    }
  };
  function C() {
    return {
      validatorAddress: ""
    };
  }
  e.QueryValidatorOutstandingRewardsRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsRequest",
    encode(l, I = i.BinaryWriter.create()) {
      return l.validatorAddress !== "" && I.uint32(10).string(l.validatorAddress), I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = C();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.validatorAddress = B.string();
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = C();
      return (0, f.isSet)(l.validatorAddress) && (I.validatorAddress = String(l.validatorAddress)), I;
    },
    toJSON(l) {
      const I = {};
      return l.validatorAddress !== void 0 && (I.validatorAddress = l.validatorAddress), I;
    },
    fromPartial(l) {
      const I = C();
      return I.validatorAddress = l.validatorAddress ?? "", I;
    }
  };
  function R() {
    return {
      rewards: r.ValidatorOutstandingRewards.fromPartial({})
    };
  }
  e.QueryValidatorOutstandingRewardsResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsResponse",
    encode(l, I = i.BinaryWriter.create()) {
      return l.rewards !== void 0 && r.ValidatorOutstandingRewards.encode(l.rewards, I.uint32(10).fork()).ldelim(), I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = R();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.rewards = r.ValidatorOutstandingRewards.decode(B, B.uint32());
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = R();
      return (0, f.isSet)(l.rewards) && (I.rewards = r.ValidatorOutstandingRewards.fromJSON(l.rewards)), I;
    },
    toJSON(l) {
      const I = {};
      return l.rewards !== void 0 && (I.rewards = l.rewards ? r.ValidatorOutstandingRewards.toJSON(l.rewards) : void 0), I;
    },
    fromPartial(l) {
      const I = R();
      return l.rewards !== void 0 && l.rewards !== null && (I.rewards = r.ValidatorOutstandingRewards.fromPartial(l.rewards)), I;
    }
  };
  function p() {
    return {
      validatorAddress: ""
    };
  }
  e.QueryValidatorCommissionRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorCommissionRequest",
    encode(l, I = i.BinaryWriter.create()) {
      return l.validatorAddress !== "" && I.uint32(10).string(l.validatorAddress), I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = p();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.validatorAddress = B.string();
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = p();
      return (0, f.isSet)(l.validatorAddress) && (I.validatorAddress = String(l.validatorAddress)), I;
    },
    toJSON(l) {
      const I = {};
      return l.validatorAddress !== void 0 && (I.validatorAddress = l.validatorAddress), I;
    },
    fromPartial(l) {
      const I = p();
      return I.validatorAddress = l.validatorAddress ?? "", I;
    }
  };
  function m() {
    return {
      commission: r.ValidatorAccumulatedCommission.fromPartial({})
    };
  }
  e.QueryValidatorCommissionResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorCommissionResponse",
    encode(l, I = i.BinaryWriter.create()) {
      return l.commission !== void 0 && r.ValidatorAccumulatedCommission.encode(l.commission, I.uint32(10).fork()).ldelim(), I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = m();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.commission = r.ValidatorAccumulatedCommission.decode(B, B.uint32());
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = m();
      return (0, f.isSet)(l.commission) && (I.commission = r.ValidatorAccumulatedCommission.fromJSON(l.commission)), I;
    },
    toJSON(l) {
      const I = {};
      return l.commission !== void 0 && (I.commission = l.commission ? r.ValidatorAccumulatedCommission.toJSON(l.commission) : void 0), I;
    },
    fromPartial(l) {
      const I = m();
      return l.commission !== void 0 && l.commission !== null && (I.commission = r.ValidatorAccumulatedCommission.fromPartial(l.commission)), I;
    }
  };
  function v() {
    return {
      validatorAddress: "",
      startingHeight: BigInt(0),
      endingHeight: BigInt(0),
      pagination: void 0
    };
  }
  e.QueryValidatorSlashesRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorSlashesRequest",
    encode(l, I = i.BinaryWriter.create()) {
      return l.validatorAddress !== "" && I.uint32(10).string(l.validatorAddress), l.startingHeight !== BigInt(0) && I.uint32(16).uint64(l.startingHeight), l.endingHeight !== BigInt(0) && I.uint32(24).uint64(l.endingHeight), l.pagination !== void 0 && n.PageRequest.encode(l.pagination, I.uint32(34).fork()).ldelim(), I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = v();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.validatorAddress = B.string();
            break;
          case 2:
            D.startingHeight = B.uint64();
            break;
          case 3:
            D.endingHeight = B.uint64();
            break;
          case 4:
            D.pagination = n.PageRequest.decode(B, B.uint32());
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = v();
      return (0, f.isSet)(l.validatorAddress) && (I.validatorAddress = String(l.validatorAddress)), (0, f.isSet)(l.startingHeight) && (I.startingHeight = BigInt(l.startingHeight.toString())), (0, f.isSet)(l.endingHeight) && (I.endingHeight = BigInt(l.endingHeight.toString())), (0, f.isSet)(l.pagination) && (I.pagination = n.PageRequest.fromJSON(l.pagination)), I;
    },
    toJSON(l) {
      const I = {};
      return l.validatorAddress !== void 0 && (I.validatorAddress = l.validatorAddress), l.startingHeight !== void 0 && (I.startingHeight = (l.startingHeight || BigInt(0)).toString()), l.endingHeight !== void 0 && (I.endingHeight = (l.endingHeight || BigInt(0)).toString()), l.pagination !== void 0 && (I.pagination = l.pagination ? n.PageRequest.toJSON(l.pagination) : void 0), I;
    },
    fromPartial(l) {
      const I = v();
      return I.validatorAddress = l.validatorAddress ?? "", l.startingHeight !== void 0 && l.startingHeight !== null && (I.startingHeight = BigInt(l.startingHeight.toString())), l.endingHeight !== void 0 && l.endingHeight !== null && (I.endingHeight = BigInt(l.endingHeight.toString())), l.pagination !== void 0 && l.pagination !== null && (I.pagination = n.PageRequest.fromPartial(l.pagination)), I;
    }
  };
  function a() {
    return {
      slashes: [],
      pagination: void 0
    };
  }
  e.QueryValidatorSlashesResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorSlashesResponse",
    encode(l, I = i.BinaryWriter.create()) {
      for (const B of l.slashes)
        r.ValidatorSlashEvent.encode(B, I.uint32(10).fork()).ldelim();
      return l.pagination !== void 0 && n.PageResponse.encode(l.pagination, I.uint32(18).fork()).ldelim(), I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = a();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.slashes.push(r.ValidatorSlashEvent.decode(B, B.uint32()));
            break;
          case 2:
            D.pagination = n.PageResponse.decode(B, B.uint32());
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = a();
      return Array.isArray(l == null ? void 0 : l.slashes) && (I.slashes = l.slashes.map((B) => r.ValidatorSlashEvent.fromJSON(B))), (0, f.isSet)(l.pagination) && (I.pagination = n.PageResponse.fromJSON(l.pagination)), I;
    },
    toJSON(l) {
      const I = {};
      return l.slashes ? I.slashes = l.slashes.map((B) => B ? r.ValidatorSlashEvent.toJSON(B) : void 0) : I.slashes = [], l.pagination !== void 0 && (I.pagination = l.pagination ? n.PageResponse.toJSON(l.pagination) : void 0), I;
    },
    fromPartial(l) {
      var B;
      const I = a();
      return I.slashes = ((B = l.slashes) == null ? void 0 : B.map((b) => r.ValidatorSlashEvent.fromPartial(b))) || [], l.pagination !== void 0 && l.pagination !== null && (I.pagination = n.PageResponse.fromPartial(l.pagination)), I;
    }
  };
  function d() {
    return {
      delegatorAddress: "",
      validatorAddress: ""
    };
  }
  e.QueryDelegationRewardsRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationRewardsRequest",
    encode(l, I = i.BinaryWriter.create()) {
      return l.delegatorAddress !== "" && I.uint32(10).string(l.delegatorAddress), l.validatorAddress !== "" && I.uint32(18).string(l.validatorAddress), I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = d();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.delegatorAddress = B.string();
            break;
          case 2:
            D.validatorAddress = B.string();
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = d();
      return (0, f.isSet)(l.delegatorAddress) && (I.delegatorAddress = String(l.delegatorAddress)), (0, f.isSet)(l.validatorAddress) && (I.validatorAddress = String(l.validatorAddress)), I;
    },
    toJSON(l) {
      const I = {};
      return l.delegatorAddress !== void 0 && (I.delegatorAddress = l.delegatorAddress), l.validatorAddress !== void 0 && (I.validatorAddress = l.validatorAddress), I;
    },
    fromPartial(l) {
      const I = d();
      return I.delegatorAddress = l.delegatorAddress ?? "", I.validatorAddress = l.validatorAddress ?? "", I;
    }
  };
  function y() {
    return {
      rewards: []
    };
  }
  e.QueryDelegationRewardsResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationRewardsResponse",
    encode(l, I = i.BinaryWriter.create()) {
      for (const B of l.rewards)
        t.DecCoin.encode(B, I.uint32(10).fork()).ldelim();
      return I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = y();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.rewards.push(t.DecCoin.decode(B, B.uint32()));
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = y();
      return Array.isArray(l == null ? void 0 : l.rewards) && (I.rewards = l.rewards.map((B) => t.DecCoin.fromJSON(B))), I;
    },
    toJSON(l) {
      const I = {};
      return l.rewards ? I.rewards = l.rewards.map((B) => B ? t.DecCoin.toJSON(B) : void 0) : I.rewards = [], I;
    },
    fromPartial(l) {
      var B;
      const I = y();
      return I.rewards = ((B = l.rewards) == null ? void 0 : B.map((b) => t.DecCoin.fromPartial(b))) || [], I;
    }
  };
  function _() {
    return {
      delegatorAddress: ""
    };
  }
  e.QueryDelegationTotalRewardsRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationTotalRewardsRequest",
    encode(l, I = i.BinaryWriter.create()) {
      return l.delegatorAddress !== "" && I.uint32(10).string(l.delegatorAddress), I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = _();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.delegatorAddress = B.string();
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = _();
      return (0, f.isSet)(l.delegatorAddress) && (I.delegatorAddress = String(l.delegatorAddress)), I;
    },
    toJSON(l) {
      const I = {};
      return l.delegatorAddress !== void 0 && (I.delegatorAddress = l.delegatorAddress), I;
    },
    fromPartial(l) {
      const I = _();
      return I.delegatorAddress = l.delegatorAddress ?? "", I;
    }
  };
  function E() {
    return {
      rewards: [],
      total: []
    };
  }
  e.QueryDelegationTotalRewardsResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationTotalRewardsResponse",
    encode(l, I = i.BinaryWriter.create()) {
      for (const B of l.rewards)
        r.DelegationDelegatorReward.encode(B, I.uint32(10).fork()).ldelim();
      for (const B of l.total)
        t.DecCoin.encode(B, I.uint32(18).fork()).ldelim();
      return I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = E();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.rewards.push(r.DelegationDelegatorReward.decode(B, B.uint32()));
            break;
          case 2:
            D.total.push(t.DecCoin.decode(B, B.uint32()));
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = E();
      return Array.isArray(l == null ? void 0 : l.rewards) && (I.rewards = l.rewards.map((B) => r.DelegationDelegatorReward.fromJSON(B))), Array.isArray(l == null ? void 0 : l.total) && (I.total = l.total.map((B) => t.DecCoin.fromJSON(B))), I;
    },
    toJSON(l) {
      const I = {};
      return l.rewards ? I.rewards = l.rewards.map((B) => B ? r.DelegationDelegatorReward.toJSON(B) : void 0) : I.rewards = [], l.total ? I.total = l.total.map((B) => B ? t.DecCoin.toJSON(B) : void 0) : I.total = [], I;
    },
    fromPartial(l) {
      var B, b;
      const I = E();
      return I.rewards = ((B = l.rewards) == null ? void 0 : B.map((D) => r.DelegationDelegatorReward.fromPartial(D))) || [], I.total = ((b = l.total) == null ? void 0 : b.map((D) => t.DecCoin.fromPartial(D))) || [], I;
    }
  };
  function U() {
    return {
      delegatorAddress: ""
    };
  }
  e.QueryDelegatorValidatorsRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorValidatorsRequest",
    encode(l, I = i.BinaryWriter.create()) {
      return l.delegatorAddress !== "" && I.uint32(10).string(l.delegatorAddress), I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = U();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.delegatorAddress = B.string();
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = U();
      return (0, f.isSet)(l.delegatorAddress) && (I.delegatorAddress = String(l.delegatorAddress)), I;
    },
    toJSON(l) {
      const I = {};
      return l.delegatorAddress !== void 0 && (I.delegatorAddress = l.delegatorAddress), I;
    },
    fromPartial(l) {
      const I = U();
      return I.delegatorAddress = l.delegatorAddress ?? "", I;
    }
  };
  function V() {
    return {
      validators: []
    };
  }
  e.QueryDelegatorValidatorsResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorValidatorsResponse",
    encode(l, I = i.BinaryWriter.create()) {
      for (const B of l.validators)
        I.uint32(10).string(B);
      return I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = V();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.validators.push(B.string());
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = V();
      return Array.isArray(l == null ? void 0 : l.validators) && (I.validators = l.validators.map((B) => String(B))), I;
    },
    toJSON(l) {
      const I = {};
      return l.validators ? I.validators = l.validators.map((B) => B) : I.validators = [], I;
    },
    fromPartial(l) {
      var B;
      const I = V();
      return I.validators = ((B = l.validators) == null ? void 0 : B.map((b) => b)) || [], I;
    }
  };
  function o() {
    return {
      delegatorAddress: ""
    };
  }
  e.QueryDelegatorWithdrawAddressRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressRequest",
    encode(l, I = i.BinaryWriter.create()) {
      return l.delegatorAddress !== "" && I.uint32(10).string(l.delegatorAddress), I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = o();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.delegatorAddress = B.string();
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = o();
      return (0, f.isSet)(l.delegatorAddress) && (I.delegatorAddress = String(l.delegatorAddress)), I;
    },
    toJSON(l) {
      const I = {};
      return l.delegatorAddress !== void 0 && (I.delegatorAddress = l.delegatorAddress), I;
    },
    fromPartial(l) {
      const I = o();
      return I.delegatorAddress = l.delegatorAddress ?? "", I;
    }
  };
  function h() {
    return {
      withdrawAddress: ""
    };
  }
  e.QueryDelegatorWithdrawAddressResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressResponse",
    encode(l, I = i.BinaryWriter.create()) {
      return l.withdrawAddress !== "" && I.uint32(10).string(l.withdrawAddress), I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = h();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.withdrawAddress = B.string();
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = h();
      return (0, f.isSet)(l.withdrawAddress) && (I.withdrawAddress = String(l.withdrawAddress)), I;
    },
    toJSON(l) {
      const I = {};
      return l.withdrawAddress !== void 0 && (I.withdrawAddress = l.withdrawAddress), I;
    },
    fromPartial(l) {
      const I = h();
      return I.withdrawAddress = l.withdrawAddress ?? "", I;
    }
  };
  function N() {
    return {};
  }
  e.QueryCommunityPoolRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryCommunityPoolRequest",
    encode(l, I = i.BinaryWriter.create()) {
      return I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = N();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      return N();
    },
    toJSON(l) {
      return {};
    },
    fromPartial(l) {
      return N();
    }
  };
  function q() {
    return {
      pool: []
    };
  }
  e.QueryCommunityPoolResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryCommunityPoolResponse",
    encode(l, I = i.BinaryWriter.create()) {
      for (const B of l.pool)
        t.DecCoin.encode(B, I.uint32(10).fork()).ldelim();
      return I;
    },
    decode(l, I) {
      const B = l instanceof i.BinaryReader ? l : new i.BinaryReader(l);
      let b = I === void 0 ? B.len : B.pos + I;
      const D = q();
      for (; B.pos < b; ) {
        const Q = B.uint32();
        switch (Q >>> 3) {
          case 1:
            D.pool.push(t.DecCoin.decode(B, B.uint32()));
            break;
          default:
            B.skipType(Q & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(l) {
      const I = q();
      return Array.isArray(l == null ? void 0 : l.pool) && (I.pool = l.pool.map((B) => t.DecCoin.fromJSON(B))), I;
    },
    toJSON(l) {
      const I = {};
      return l.pool ? I.pool = l.pool.map((B) => B ? t.DecCoin.toJSON(B) : void 0) : I.pool = [], I;
    },
    fromPartial(l) {
      var B;
      const I = q();
      return I.pool = ((B = l.pool) == null ? void 0 : B.map((b) => t.DecCoin.fromPartial(b))) || [], I;
    }
  };
  class u {
    constructor(I) {
      this.rpc = I, this.Params = this.Params.bind(this), this.ValidatorDistributionInfo = this.ValidatorDistributionInfo.bind(this), this.ValidatorOutstandingRewards = this.ValidatorOutstandingRewards.bind(this), this.ValidatorCommission = this.ValidatorCommission.bind(this), this.ValidatorSlashes = this.ValidatorSlashes.bind(this), this.DelegationRewards = this.DelegationRewards.bind(this), this.DelegationTotalRewards = this.DelegationTotalRewards.bind(this), this.DelegatorValidators = this.DelegatorValidators.bind(this), this.DelegatorWithdrawAddress = this.DelegatorWithdrawAddress.bind(this), this.CommunityPool = this.CommunityPool.bind(this);
    }
    Params(I = {}) {
      const B = e.QueryParamsRequest.encode(I).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "Params", B).then((D) => e.QueryParamsResponse.decode(new i.BinaryReader(D)));
    }
    ValidatorDistributionInfo(I) {
      const B = e.QueryValidatorDistributionInfoRequest.encode(I).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorDistributionInfo", B).then((D) => e.QueryValidatorDistributionInfoResponse.decode(new i.BinaryReader(D)));
    }
    ValidatorOutstandingRewards(I) {
      const B = e.QueryValidatorOutstandingRewardsRequest.encode(I).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorOutstandingRewards", B).then((D) => e.QueryValidatorOutstandingRewardsResponse.decode(new i.BinaryReader(D)));
    }
    ValidatorCommission(I) {
      const B = e.QueryValidatorCommissionRequest.encode(I).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorCommission", B).then((D) => e.QueryValidatorCommissionResponse.decode(new i.BinaryReader(D)));
    }
    ValidatorSlashes(I) {
      const B = e.QueryValidatorSlashesRequest.encode(I).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorSlashes", B).then((D) => e.QueryValidatorSlashesResponse.decode(new i.BinaryReader(D)));
    }
    DelegationRewards(I) {
      const B = e.QueryDelegationRewardsRequest.encode(I).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegationRewards", B).then((D) => e.QueryDelegationRewardsResponse.decode(new i.BinaryReader(D)));
    }
    DelegationTotalRewards(I) {
      const B = e.QueryDelegationTotalRewardsRequest.encode(I).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegationTotalRewards", B).then((D) => e.QueryDelegationTotalRewardsResponse.decode(new i.BinaryReader(D)));
    }
    DelegatorValidators(I) {
      const B = e.QueryDelegatorValidatorsRequest.encode(I).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegatorValidators", B).then((D) => e.QueryDelegatorValidatorsResponse.decode(new i.BinaryReader(D)));
    }
    DelegatorWithdrawAddress(I) {
      const B = e.QueryDelegatorWithdrawAddressRequest.encode(I).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegatorWithdrawAddress", B).then((D) => e.QueryDelegatorWithdrawAddressResponse.decode(new i.BinaryReader(D)));
    }
    CommunityPool(I = {}) {
      const B = e.QueryCommunityPoolRequest.encode(I).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "CommunityPool", B).then((D) => e.QueryCommunityPoolResponse.decode(new i.BinaryReader(D)));
    }
  }
  e.QueryClientImpl = u;
})(gh);
Object.defineProperty(gs, "__esModule", { value: !0 });
gs.setupDistributionExtension = void 0;
const Ab = gh, lf = Ye;
function Ib(e) {
  const n = (0, lf.createProtobufRpcClient)(e), r = new Ab.QueryClientImpl(n);
  return {
    distribution: {
      communityPool: async () => await r.CommunityPool({}),
      delegationRewards: async (t, i) => await r.DelegationRewards({
        delegatorAddress: t,
        validatorAddress: i
      }),
      delegationTotalRewards: async (t) => await r.DelegationTotalRewards({
        delegatorAddress: t
      }),
      delegatorValidators: async (t) => await r.DelegatorValidators({
        delegatorAddress: t
      }),
      delegatorWithdrawAddress: async (t) => await r.DelegatorWithdrawAddress({
        delegatorAddress: t
      }),
      params: async () => await r.Params({}),
      validatorCommission: async (t) => await r.ValidatorCommission({
        validatorAddress: t
      }),
      validatorOutstandingRewards: async (t) => await r.ValidatorOutstandingRewards({
        validatorAddress: t
      }),
      validatorSlashes: async (t, i, f, S) => await r.ValidatorSlashes({
        validatorAddress: t,
        startingHeight: BigInt(i),
        endingHeight: BigInt(f),
        pagination: (0, lf.createPagination)(S)
      })
    }
  };
}
gs.setupDistributionExtension = Ib;
var hi = {};
Object.defineProperty(hi, "__esModule", { value: !0 });
hi.createEvidenceAminoConverters = hi.isAminoMsgSubmitEvidence = void 0;
function Tb(e) {
  return e.type === "cosmos-sdk/MsgSubmitEvidence";
}
hi.isAminoMsgSubmitEvidence = Tb;
function wb() {
  throw new Error("Not implemented");
}
hi.createEvidenceAminoConverters = wb;
var Ss = {};
Object.defineProperty(Ss, "__esModule", { value: !0 });
Ss.createFeegrantAminoConverters = void 0;
function Cb() {
  return {
    // For Cosmos SDK < 0.46 the Amino JSON codec was broken on chain and thus inaccessible.
    // Now this can be implemented for 0.46+ chains, see
    // https://github.com/cosmos/cosmjs/issues/1092
    //
    // "/cosmos.feegrant.v1beta1.MsgGrantAllowance": IMPLEMENT_ME,
    // "/cosmos.feegrant.v1beta1.MsgRevokeAllowance": IMPLEMENT_ME,
  };
}
Ss.createFeegrantAminoConverters = Cb;
var ks = {}, Sh = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgRevokeAllowanceResponse = e.MsgRevokeAllowance = e.MsgGrantAllowanceResponse = e.MsgGrantAllowance = e.protobufPackage = void 0;
  const n = Pe, r = re, t = ie;
  e.protobufPackage = "cosmos.feegrant.v1beta1";
  function i() {
    return {
      granter: "",
      grantee: "",
      allowance: void 0
    };
  }
  e.MsgGrantAllowance = {
    typeUrl: "/cosmos.feegrant.v1beta1.MsgGrantAllowance",
    encode(J, C = r.BinaryWriter.create()) {
      return J.granter !== "" && C.uint32(10).string(J.granter), J.grantee !== "" && C.uint32(18).string(J.grantee), J.allowance !== void 0 && n.Any.encode(J.allowance, C.uint32(26).fork()).ldelim(), C;
    },
    decode(J, C) {
      const R = J instanceof r.BinaryReader ? J : new r.BinaryReader(J);
      let p = C === void 0 ? R.len : R.pos + C;
      const m = i();
      for (; R.pos < p; ) {
        const v = R.uint32();
        switch (v >>> 3) {
          case 1:
            m.granter = R.string();
            break;
          case 2:
            m.grantee = R.string();
            break;
          case 3:
            m.allowance = n.Any.decode(R, R.uint32());
            break;
          default:
            R.skipType(v & 7);
            break;
        }
      }
      return m;
    },
    fromJSON(J) {
      const C = i();
      return (0, t.isSet)(J.granter) && (C.granter = String(J.granter)), (0, t.isSet)(J.grantee) && (C.grantee = String(J.grantee)), (0, t.isSet)(J.allowance) && (C.allowance = n.Any.fromJSON(J.allowance)), C;
    },
    toJSON(J) {
      const C = {};
      return J.granter !== void 0 && (C.granter = J.granter), J.grantee !== void 0 && (C.grantee = J.grantee), J.allowance !== void 0 && (C.allowance = J.allowance ? n.Any.toJSON(J.allowance) : void 0), C;
    },
    fromPartial(J) {
      const C = i();
      return C.granter = J.granter ?? "", C.grantee = J.grantee ?? "", J.allowance !== void 0 && J.allowance !== null && (C.allowance = n.Any.fromPartial(J.allowance)), C;
    }
  };
  function f() {
    return {};
  }
  e.MsgGrantAllowanceResponse = {
    typeUrl: "/cosmos.feegrant.v1beta1.MsgGrantAllowanceResponse",
    encode(J, C = r.BinaryWriter.create()) {
      return C;
    },
    decode(J, C) {
      const R = J instanceof r.BinaryReader ? J : new r.BinaryReader(J);
      let p = C === void 0 ? R.len : R.pos + C;
      const m = f();
      for (; R.pos < p; ) {
        const v = R.uint32();
        switch (v >>> 3) {
          default:
            R.skipType(v & 7);
            break;
        }
      }
      return m;
    },
    fromJSON(J) {
      return f();
    },
    toJSON(J) {
      return {};
    },
    fromPartial(J) {
      return f();
    }
  };
  function S() {
    return {
      granter: "",
      grantee: ""
    };
  }
  e.MsgRevokeAllowance = {
    typeUrl: "/cosmos.feegrant.v1beta1.MsgRevokeAllowance",
    encode(J, C = r.BinaryWriter.create()) {
      return J.granter !== "" && C.uint32(10).string(J.granter), J.grantee !== "" && C.uint32(18).string(J.grantee), C;
    },
    decode(J, C) {
      const R = J instanceof r.BinaryReader ? J : new r.BinaryReader(J);
      let p = C === void 0 ? R.len : R.pos + C;
      const m = S();
      for (; R.pos < p; ) {
        const v = R.uint32();
        switch (v >>> 3) {
          case 1:
            m.granter = R.string();
            break;
          case 2:
            m.grantee = R.string();
            break;
          default:
            R.skipType(v & 7);
            break;
        }
      }
      return m;
    },
    fromJSON(J) {
      const C = S();
      return (0, t.isSet)(J.granter) && (C.granter = String(J.granter)), (0, t.isSet)(J.grantee) && (C.grantee = String(J.grantee)), C;
    },
    toJSON(J) {
      const C = {};
      return J.granter !== void 0 && (C.granter = J.granter), J.grantee !== void 0 && (C.grantee = J.grantee), C;
    },
    fromPartial(J) {
      const C = S();
      return C.granter = J.granter ?? "", C.grantee = J.grantee ?? "", C;
    }
  };
  function w() {
    return {};
  }
  e.MsgRevokeAllowanceResponse = {
    typeUrl: "/cosmos.feegrant.v1beta1.MsgRevokeAllowanceResponse",
    encode(J, C = r.BinaryWriter.create()) {
      return C;
    },
    decode(J, C) {
      const R = J instanceof r.BinaryReader ? J : new r.BinaryReader(J);
      let p = C === void 0 ? R.len : R.pos + C;
      const m = w();
      for (; R.pos < p; ) {
        const v = R.uint32();
        switch (v >>> 3) {
          default:
            R.skipType(v & 7);
            break;
        }
      }
      return m;
    },
    fromJSON(J) {
      return w();
    },
    toJSON(J) {
      return {};
    },
    fromPartial(J) {
      return w();
    }
  };
  class T {
    constructor(C) {
      this.rpc = C, this.GrantAllowance = this.GrantAllowance.bind(this), this.RevokeAllowance = this.RevokeAllowance.bind(this);
    }
    GrantAllowance(C) {
      const R = e.MsgGrantAllowance.encode(C).finish();
      return this.rpc.request("cosmos.feegrant.v1beta1.Msg", "GrantAllowance", R).then((m) => e.MsgGrantAllowanceResponse.decode(new r.BinaryReader(m)));
    }
    RevokeAllowance(C) {
      const R = e.MsgRevokeAllowance.encode(C).finish();
      return this.rpc.request("cosmos.feegrant.v1beta1.Msg", "RevokeAllowance", R).then((m) => e.MsgRevokeAllowanceResponse.decode(new r.BinaryReader(m)));
    }
  }
  e.MsgClientImpl = T;
})(Sh);
Object.defineProperty(ks, "__esModule", { value: !0 });
ks.feegrantTypes = void 0;
const ff = Sh;
ks.feegrantTypes = [
  ["/cosmos.feegrant.v1beta1.MsgGrantAllowance", ff.MsgGrantAllowance],
  ["/cosmos.feegrant.v1beta1.MsgRevokeAllowance", ff.MsgRevokeAllowance]
];
var Ps = {}, kh = {}, Ph = {}, vn = {};
Object.defineProperty(vn, "__esModule", { value: !0 });
vn.Duration = vn.protobufPackage = void 0;
const uu = re, pf = ie;
vn.protobufPackage = "google.protobuf";
function cu() {
  return {
    seconds: BigInt(0),
    nanos: 0
  };
}
vn.Duration = {
  typeUrl: "/google.protobuf.Duration",
  encode(e, n = uu.BinaryWriter.create()) {
    return e.seconds !== BigInt(0) && n.uint32(8).int64(e.seconds), e.nanos !== 0 && n.uint32(16).int32(e.nanos), n;
  },
  decode(e, n) {
    const r = e instanceof uu.BinaryReader ? e : new uu.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = cu();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.seconds = r.int64();
          break;
        case 2:
          i.nanos = r.int32();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = cu();
    return (0, pf.isSet)(e.seconds) && (n.seconds = BigInt(e.seconds.toString())), (0, pf.isSet)(e.nanos) && (n.nanos = Number(e.nanos)), n;
  },
  toJSON(e) {
    const n = {};
    return e.seconds !== void 0 && (n.seconds = (e.seconds || BigInt(0)).toString()), e.nanos !== void 0 && (n.nanos = Math.round(e.nanos)), n;
  },
  fromPartial(e) {
    const n = cu();
    return e.seconds !== void 0 && e.seconds !== null && (n.seconds = BigInt(e.seconds.toString())), n.nanos = e.nanos ?? 0, n;
  }
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Grant = e.AllowedMsgAllowance = e.PeriodicAllowance = e.BasicAllowance = e.protobufPackage = void 0;
  const n = De, r = Je, t = vn, i = Pe, f = re, S = ie;
  e.protobufPackage = "cosmos.feegrant.v1beta1";
  function w() {
    return {
      spendLimit: [],
      expiration: void 0
    };
  }
  e.BasicAllowance = {
    typeUrl: "/cosmos.feegrant.v1beta1.BasicAllowance",
    encode(R, p = f.BinaryWriter.create()) {
      for (const m of R.spendLimit)
        n.Coin.encode(m, p.uint32(10).fork()).ldelim();
      return R.expiration !== void 0 && r.Timestamp.encode(R.expiration, p.uint32(18).fork()).ldelim(), p;
    },
    decode(R, p) {
      const m = R instanceof f.BinaryReader ? R : new f.BinaryReader(R);
      let v = p === void 0 ? m.len : m.pos + p;
      const a = w();
      for (; m.pos < v; ) {
        const d = m.uint32();
        switch (d >>> 3) {
          case 1:
            a.spendLimit.push(n.Coin.decode(m, m.uint32()));
            break;
          case 2:
            a.expiration = r.Timestamp.decode(m, m.uint32());
            break;
          default:
            m.skipType(d & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(R) {
      const p = w();
      return Array.isArray(R == null ? void 0 : R.spendLimit) && (p.spendLimit = R.spendLimit.map((m) => n.Coin.fromJSON(m))), (0, S.isSet)(R.expiration) && (p.expiration = (0, S.fromJsonTimestamp)(R.expiration)), p;
    },
    toJSON(R) {
      const p = {};
      return R.spendLimit ? p.spendLimit = R.spendLimit.map((m) => m ? n.Coin.toJSON(m) : void 0) : p.spendLimit = [], R.expiration !== void 0 && (p.expiration = (0, S.fromTimestamp)(R.expiration).toISOString()), p;
    },
    fromPartial(R) {
      var m;
      const p = w();
      return p.spendLimit = ((m = R.spendLimit) == null ? void 0 : m.map((v) => n.Coin.fromPartial(v))) || [], R.expiration !== void 0 && R.expiration !== null && (p.expiration = r.Timestamp.fromPartial(R.expiration)), p;
    }
  };
  function T() {
    return {
      basic: e.BasicAllowance.fromPartial({}),
      period: t.Duration.fromPartial({}),
      periodSpendLimit: [],
      periodCanSpend: [],
      periodReset: r.Timestamp.fromPartial({})
    };
  }
  e.PeriodicAllowance = {
    typeUrl: "/cosmos.feegrant.v1beta1.PeriodicAllowance",
    encode(R, p = f.BinaryWriter.create()) {
      R.basic !== void 0 && e.BasicAllowance.encode(R.basic, p.uint32(10).fork()).ldelim(), R.period !== void 0 && t.Duration.encode(R.period, p.uint32(18).fork()).ldelim();
      for (const m of R.periodSpendLimit)
        n.Coin.encode(m, p.uint32(26).fork()).ldelim();
      for (const m of R.periodCanSpend)
        n.Coin.encode(m, p.uint32(34).fork()).ldelim();
      return R.periodReset !== void 0 && r.Timestamp.encode(R.periodReset, p.uint32(42).fork()).ldelim(), p;
    },
    decode(R, p) {
      const m = R instanceof f.BinaryReader ? R : new f.BinaryReader(R);
      let v = p === void 0 ? m.len : m.pos + p;
      const a = T();
      for (; m.pos < v; ) {
        const d = m.uint32();
        switch (d >>> 3) {
          case 1:
            a.basic = e.BasicAllowance.decode(m, m.uint32());
            break;
          case 2:
            a.period = t.Duration.decode(m, m.uint32());
            break;
          case 3:
            a.periodSpendLimit.push(n.Coin.decode(m, m.uint32()));
            break;
          case 4:
            a.periodCanSpend.push(n.Coin.decode(m, m.uint32()));
            break;
          case 5:
            a.periodReset = r.Timestamp.decode(m, m.uint32());
            break;
          default:
            m.skipType(d & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(R) {
      const p = T();
      return (0, S.isSet)(R.basic) && (p.basic = e.BasicAllowance.fromJSON(R.basic)), (0, S.isSet)(R.period) && (p.period = t.Duration.fromJSON(R.period)), Array.isArray(R == null ? void 0 : R.periodSpendLimit) && (p.periodSpendLimit = R.periodSpendLimit.map((m) => n.Coin.fromJSON(m))), Array.isArray(R == null ? void 0 : R.periodCanSpend) && (p.periodCanSpend = R.periodCanSpend.map((m) => n.Coin.fromJSON(m))), (0, S.isSet)(R.periodReset) && (p.periodReset = (0, S.fromJsonTimestamp)(R.periodReset)), p;
    },
    toJSON(R) {
      const p = {};
      return R.basic !== void 0 && (p.basic = R.basic ? e.BasicAllowance.toJSON(R.basic) : void 0), R.period !== void 0 && (p.period = R.period ? t.Duration.toJSON(R.period) : void 0), R.periodSpendLimit ? p.periodSpendLimit = R.periodSpendLimit.map((m) => m ? n.Coin.toJSON(m) : void 0) : p.periodSpendLimit = [], R.periodCanSpend ? p.periodCanSpend = R.periodCanSpend.map((m) => m ? n.Coin.toJSON(m) : void 0) : p.periodCanSpend = [], R.periodReset !== void 0 && (p.periodReset = (0, S.fromTimestamp)(R.periodReset).toISOString()), p;
    },
    fromPartial(R) {
      var m, v;
      const p = T();
      return R.basic !== void 0 && R.basic !== null && (p.basic = e.BasicAllowance.fromPartial(R.basic)), R.period !== void 0 && R.period !== null && (p.period = t.Duration.fromPartial(R.period)), p.periodSpendLimit = ((m = R.periodSpendLimit) == null ? void 0 : m.map((a) => n.Coin.fromPartial(a))) || [], p.periodCanSpend = ((v = R.periodCanSpend) == null ? void 0 : v.map((a) => n.Coin.fromPartial(a))) || [], R.periodReset !== void 0 && R.periodReset !== null && (p.periodReset = r.Timestamp.fromPartial(R.periodReset)), p;
    }
  };
  function J() {
    return {
      allowance: void 0,
      allowedMessages: []
    };
  }
  e.AllowedMsgAllowance = {
    typeUrl: "/cosmos.feegrant.v1beta1.AllowedMsgAllowance",
    encode(R, p = f.BinaryWriter.create()) {
      R.allowance !== void 0 && i.Any.encode(R.allowance, p.uint32(10).fork()).ldelim();
      for (const m of R.allowedMessages)
        p.uint32(18).string(m);
      return p;
    },
    decode(R, p) {
      const m = R instanceof f.BinaryReader ? R : new f.BinaryReader(R);
      let v = p === void 0 ? m.len : m.pos + p;
      const a = J();
      for (; m.pos < v; ) {
        const d = m.uint32();
        switch (d >>> 3) {
          case 1:
            a.allowance = i.Any.decode(m, m.uint32());
            break;
          case 2:
            a.allowedMessages.push(m.string());
            break;
          default:
            m.skipType(d & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(R) {
      const p = J();
      return (0, S.isSet)(R.allowance) && (p.allowance = i.Any.fromJSON(R.allowance)), Array.isArray(R == null ? void 0 : R.allowedMessages) && (p.allowedMessages = R.allowedMessages.map((m) => String(m))), p;
    },
    toJSON(R) {
      const p = {};
      return R.allowance !== void 0 && (p.allowance = R.allowance ? i.Any.toJSON(R.allowance) : void 0), R.allowedMessages ? p.allowedMessages = R.allowedMessages.map((m) => m) : p.allowedMessages = [], p;
    },
    fromPartial(R) {
      var m;
      const p = J();
      return R.allowance !== void 0 && R.allowance !== null && (p.allowance = i.Any.fromPartial(R.allowance)), p.allowedMessages = ((m = R.allowedMessages) == null ? void 0 : m.map((v) => v)) || [], p;
    }
  };
  function C() {
    return {
      granter: "",
      grantee: "",
      allowance: void 0
    };
  }
  e.Grant = {
    typeUrl: "/cosmos.feegrant.v1beta1.Grant",
    encode(R, p = f.BinaryWriter.create()) {
      return R.granter !== "" && p.uint32(10).string(R.granter), R.grantee !== "" && p.uint32(18).string(R.grantee), R.allowance !== void 0 && i.Any.encode(R.allowance, p.uint32(26).fork()).ldelim(), p;
    },
    decode(R, p) {
      const m = R instanceof f.BinaryReader ? R : new f.BinaryReader(R);
      let v = p === void 0 ? m.len : m.pos + p;
      const a = C();
      for (; m.pos < v; ) {
        const d = m.uint32();
        switch (d >>> 3) {
          case 1:
            a.granter = m.string();
            break;
          case 2:
            a.grantee = m.string();
            break;
          case 3:
            a.allowance = i.Any.decode(m, m.uint32());
            break;
          default:
            m.skipType(d & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(R) {
      const p = C();
      return (0, S.isSet)(R.granter) && (p.granter = String(R.granter)), (0, S.isSet)(R.grantee) && (p.grantee = String(R.grantee)), (0, S.isSet)(R.allowance) && (p.allowance = i.Any.fromJSON(R.allowance)), p;
    },
    toJSON(R) {
      const p = {};
      return R.granter !== void 0 && (p.granter = R.granter), R.grantee !== void 0 && (p.grantee = R.grantee), R.allowance !== void 0 && (p.allowance = R.allowance ? i.Any.toJSON(R.allowance) : void 0), p;
    },
    fromPartial(R) {
      const p = C();
      return p.granter = R.granter ?? "", p.grantee = R.grantee ?? "", R.allowance !== void 0 && R.allowance !== null && (p.allowance = i.Any.fromPartial(R.allowance)), p;
    }
  };
})(Ph);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryAllowancesByGranterResponse = e.QueryAllowancesByGranterRequest = e.QueryAllowancesResponse = e.QueryAllowancesRequest = e.QueryAllowanceResponse = e.QueryAllowanceRequest = e.protobufPackage = void 0;
  const n = Ae, r = Ph, t = re, i = ie;
  e.protobufPackage = "cosmos.feegrant.v1beta1";
  function f() {
    return {
      granter: "",
      grantee: ""
    };
  }
  e.QueryAllowanceRequest = {
    typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowanceRequest",
    encode(p, m = t.BinaryWriter.create()) {
      return p.granter !== "" && m.uint32(10).string(p.granter), p.grantee !== "" && m.uint32(18).string(p.grantee), m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = f();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.granter = v.string();
            break;
          case 2:
            d.grantee = v.string();
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = f();
      return (0, i.isSet)(p.granter) && (m.granter = String(p.granter)), (0, i.isSet)(p.grantee) && (m.grantee = String(p.grantee)), m;
    },
    toJSON(p) {
      const m = {};
      return p.granter !== void 0 && (m.granter = p.granter), p.grantee !== void 0 && (m.grantee = p.grantee), m;
    },
    fromPartial(p) {
      const m = f();
      return m.granter = p.granter ?? "", m.grantee = p.grantee ?? "", m;
    }
  };
  function S() {
    return {
      allowance: void 0
    };
  }
  e.QueryAllowanceResponse = {
    typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowanceResponse",
    encode(p, m = t.BinaryWriter.create()) {
      return p.allowance !== void 0 && r.Grant.encode(p.allowance, m.uint32(10).fork()).ldelim(), m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = S();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.allowance = r.Grant.decode(v, v.uint32());
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = S();
      return (0, i.isSet)(p.allowance) && (m.allowance = r.Grant.fromJSON(p.allowance)), m;
    },
    toJSON(p) {
      const m = {};
      return p.allowance !== void 0 && (m.allowance = p.allowance ? r.Grant.toJSON(p.allowance) : void 0), m;
    },
    fromPartial(p) {
      const m = S();
      return p.allowance !== void 0 && p.allowance !== null && (m.allowance = r.Grant.fromPartial(p.allowance)), m;
    }
  };
  function w() {
    return {
      grantee: "",
      pagination: void 0
    };
  }
  e.QueryAllowancesRequest = {
    typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesRequest",
    encode(p, m = t.BinaryWriter.create()) {
      return p.grantee !== "" && m.uint32(10).string(p.grantee), p.pagination !== void 0 && n.PageRequest.encode(p.pagination, m.uint32(18).fork()).ldelim(), m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = w();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.grantee = v.string();
            break;
          case 2:
            d.pagination = n.PageRequest.decode(v, v.uint32());
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = w();
      return (0, i.isSet)(p.grantee) && (m.grantee = String(p.grantee)), (0, i.isSet)(p.pagination) && (m.pagination = n.PageRequest.fromJSON(p.pagination)), m;
    },
    toJSON(p) {
      const m = {};
      return p.grantee !== void 0 && (m.grantee = p.grantee), p.pagination !== void 0 && (m.pagination = p.pagination ? n.PageRequest.toJSON(p.pagination) : void 0), m;
    },
    fromPartial(p) {
      const m = w();
      return m.grantee = p.grantee ?? "", p.pagination !== void 0 && p.pagination !== null && (m.pagination = n.PageRequest.fromPartial(p.pagination)), m;
    }
  };
  function T() {
    return {
      allowances: [],
      pagination: void 0
    };
  }
  e.QueryAllowancesResponse = {
    typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesResponse",
    encode(p, m = t.BinaryWriter.create()) {
      for (const v of p.allowances)
        r.Grant.encode(v, m.uint32(10).fork()).ldelim();
      return p.pagination !== void 0 && n.PageResponse.encode(p.pagination, m.uint32(18).fork()).ldelim(), m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = T();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.allowances.push(r.Grant.decode(v, v.uint32()));
            break;
          case 2:
            d.pagination = n.PageResponse.decode(v, v.uint32());
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = T();
      return Array.isArray(p == null ? void 0 : p.allowances) && (m.allowances = p.allowances.map((v) => r.Grant.fromJSON(v))), (0, i.isSet)(p.pagination) && (m.pagination = n.PageResponse.fromJSON(p.pagination)), m;
    },
    toJSON(p) {
      const m = {};
      return p.allowances ? m.allowances = p.allowances.map((v) => v ? r.Grant.toJSON(v) : void 0) : m.allowances = [], p.pagination !== void 0 && (m.pagination = p.pagination ? n.PageResponse.toJSON(p.pagination) : void 0), m;
    },
    fromPartial(p) {
      var v;
      const m = T();
      return m.allowances = ((v = p.allowances) == null ? void 0 : v.map((a) => r.Grant.fromPartial(a))) || [], p.pagination !== void 0 && p.pagination !== null && (m.pagination = n.PageResponse.fromPartial(p.pagination)), m;
    }
  };
  function J() {
    return {
      granter: "",
      pagination: void 0
    };
  }
  e.QueryAllowancesByGranterRequest = {
    typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesByGranterRequest",
    encode(p, m = t.BinaryWriter.create()) {
      return p.granter !== "" && m.uint32(10).string(p.granter), p.pagination !== void 0 && n.PageRequest.encode(p.pagination, m.uint32(18).fork()).ldelim(), m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = J();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.granter = v.string();
            break;
          case 2:
            d.pagination = n.PageRequest.decode(v, v.uint32());
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = J();
      return (0, i.isSet)(p.granter) && (m.granter = String(p.granter)), (0, i.isSet)(p.pagination) && (m.pagination = n.PageRequest.fromJSON(p.pagination)), m;
    },
    toJSON(p) {
      const m = {};
      return p.granter !== void 0 && (m.granter = p.granter), p.pagination !== void 0 && (m.pagination = p.pagination ? n.PageRequest.toJSON(p.pagination) : void 0), m;
    },
    fromPartial(p) {
      const m = J();
      return m.granter = p.granter ?? "", p.pagination !== void 0 && p.pagination !== null && (m.pagination = n.PageRequest.fromPartial(p.pagination)), m;
    }
  };
  function C() {
    return {
      allowances: [],
      pagination: void 0
    };
  }
  e.QueryAllowancesByGranterResponse = {
    typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesByGranterResponse",
    encode(p, m = t.BinaryWriter.create()) {
      for (const v of p.allowances)
        r.Grant.encode(v, m.uint32(10).fork()).ldelim();
      return p.pagination !== void 0 && n.PageResponse.encode(p.pagination, m.uint32(18).fork()).ldelim(), m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = C();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.allowances.push(r.Grant.decode(v, v.uint32()));
            break;
          case 2:
            d.pagination = n.PageResponse.decode(v, v.uint32());
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = C();
      return Array.isArray(p == null ? void 0 : p.allowances) && (m.allowances = p.allowances.map((v) => r.Grant.fromJSON(v))), (0, i.isSet)(p.pagination) && (m.pagination = n.PageResponse.fromJSON(p.pagination)), m;
    },
    toJSON(p) {
      const m = {};
      return p.allowances ? m.allowances = p.allowances.map((v) => v ? r.Grant.toJSON(v) : void 0) : m.allowances = [], p.pagination !== void 0 && (m.pagination = p.pagination ? n.PageResponse.toJSON(p.pagination) : void 0), m;
    },
    fromPartial(p) {
      var v;
      const m = C();
      return m.allowances = ((v = p.allowances) == null ? void 0 : v.map((a) => r.Grant.fromPartial(a))) || [], p.pagination !== void 0 && p.pagination !== null && (m.pagination = n.PageResponse.fromPartial(p.pagination)), m;
    }
  };
  class R {
    constructor(m) {
      this.rpc = m, this.Allowance = this.Allowance.bind(this), this.Allowances = this.Allowances.bind(this), this.AllowancesByGranter = this.AllowancesByGranter.bind(this);
    }
    Allowance(m) {
      const v = e.QueryAllowanceRequest.encode(m).finish();
      return this.rpc.request("cosmos.feegrant.v1beta1.Query", "Allowance", v).then((d) => e.QueryAllowanceResponse.decode(new t.BinaryReader(d)));
    }
    Allowances(m) {
      const v = e.QueryAllowancesRequest.encode(m).finish();
      return this.rpc.request("cosmos.feegrant.v1beta1.Query", "Allowances", v).then((d) => e.QueryAllowancesResponse.decode(new t.BinaryReader(d)));
    }
    AllowancesByGranter(m) {
      const v = e.QueryAllowancesByGranterRequest.encode(m).finish();
      return this.rpc.request("cosmos.feegrant.v1beta1.Query", "AllowancesByGranter", v).then((d) => e.QueryAllowancesByGranterResponse.decode(new t.BinaryReader(d)));
    }
  }
  e.QueryClientImpl = R;
})(kh);
Object.defineProperty(Ps, "__esModule", { value: !0 });
Ps.setupFeegrantExtension = void 0;
const Nb = kh, hf = Ye;
function _b(e) {
  const n = (0, hf.createProtobufRpcClient)(e), r = new Nb.QueryClientImpl(n);
  return {
    feegrant: {
      allowance: async (t, i) => await r.Allowance({
        granter: t,
        grantee: i
      }),
      allowances: async (t, i) => await r.Allowances({
        grantee: t,
        pagination: (0, hf.createPagination)(i)
      })
    }
  };
}
Ps.setupFeegrantExtension = _b;
var wn = {}, vs = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.TallyParams = e.VotingParams = e.DepositParams = e.Vote = e.TallyResult = e.Proposal = e.Deposit = e.TextProposal = e.WeightedVoteOption = e.proposalStatusToJSON = e.proposalStatusFromJSON = e.ProposalStatus = e.voteOptionToJSON = e.voteOptionFromJSON = e.VoteOption = e.protobufPackage = void 0;
  const n = De, r = Pe, t = Je, i = vn, f = re, S = ie;
  e.protobufPackage = "cosmos.gov.v1beta1";
  var w;
  (function(o) {
    o[o.VOTE_OPTION_UNSPECIFIED = 0] = "VOTE_OPTION_UNSPECIFIED", o[o.VOTE_OPTION_YES = 1] = "VOTE_OPTION_YES", o[o.VOTE_OPTION_ABSTAIN = 2] = "VOTE_OPTION_ABSTAIN", o[o.VOTE_OPTION_NO = 3] = "VOTE_OPTION_NO", o[o.VOTE_OPTION_NO_WITH_VETO = 4] = "VOTE_OPTION_NO_WITH_VETO", o[o.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(w || (e.VoteOption = w = {}));
  function T(o) {
    switch (o) {
      case 0:
      case "VOTE_OPTION_UNSPECIFIED":
        return w.VOTE_OPTION_UNSPECIFIED;
      case 1:
      case "VOTE_OPTION_YES":
        return w.VOTE_OPTION_YES;
      case 2:
      case "VOTE_OPTION_ABSTAIN":
        return w.VOTE_OPTION_ABSTAIN;
      case 3:
      case "VOTE_OPTION_NO":
        return w.VOTE_OPTION_NO;
      case 4:
      case "VOTE_OPTION_NO_WITH_VETO":
        return w.VOTE_OPTION_NO_WITH_VETO;
      case -1:
      case "UNRECOGNIZED":
      default:
        return w.UNRECOGNIZED;
    }
  }
  e.voteOptionFromJSON = T;
  function J(o) {
    switch (o) {
      case w.VOTE_OPTION_UNSPECIFIED:
        return "VOTE_OPTION_UNSPECIFIED";
      case w.VOTE_OPTION_YES:
        return "VOTE_OPTION_YES";
      case w.VOTE_OPTION_ABSTAIN:
        return "VOTE_OPTION_ABSTAIN";
      case w.VOTE_OPTION_NO:
        return "VOTE_OPTION_NO";
      case w.VOTE_OPTION_NO_WITH_VETO:
        return "VOTE_OPTION_NO_WITH_VETO";
      case w.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.voteOptionToJSON = J;
  var C;
  (function(o) {
    o[o.PROPOSAL_STATUS_UNSPECIFIED = 0] = "PROPOSAL_STATUS_UNSPECIFIED", o[o.PROPOSAL_STATUS_DEPOSIT_PERIOD = 1] = "PROPOSAL_STATUS_DEPOSIT_PERIOD", o[o.PROPOSAL_STATUS_VOTING_PERIOD = 2] = "PROPOSAL_STATUS_VOTING_PERIOD", o[o.PROPOSAL_STATUS_PASSED = 3] = "PROPOSAL_STATUS_PASSED", o[o.PROPOSAL_STATUS_REJECTED = 4] = "PROPOSAL_STATUS_REJECTED", o[o.PROPOSAL_STATUS_FAILED = 5] = "PROPOSAL_STATUS_FAILED", o[o.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(C || (e.ProposalStatus = C = {}));
  function R(o) {
    switch (o) {
      case 0:
      case "PROPOSAL_STATUS_UNSPECIFIED":
        return C.PROPOSAL_STATUS_UNSPECIFIED;
      case 1:
      case "PROPOSAL_STATUS_DEPOSIT_PERIOD":
        return C.PROPOSAL_STATUS_DEPOSIT_PERIOD;
      case 2:
      case "PROPOSAL_STATUS_VOTING_PERIOD":
        return C.PROPOSAL_STATUS_VOTING_PERIOD;
      case 3:
      case "PROPOSAL_STATUS_PASSED":
        return C.PROPOSAL_STATUS_PASSED;
      case 4:
      case "PROPOSAL_STATUS_REJECTED":
        return C.PROPOSAL_STATUS_REJECTED;
      case 5:
      case "PROPOSAL_STATUS_FAILED":
        return C.PROPOSAL_STATUS_FAILED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return C.UNRECOGNIZED;
    }
  }
  e.proposalStatusFromJSON = R;
  function p(o) {
    switch (o) {
      case C.PROPOSAL_STATUS_UNSPECIFIED:
        return "PROPOSAL_STATUS_UNSPECIFIED";
      case C.PROPOSAL_STATUS_DEPOSIT_PERIOD:
        return "PROPOSAL_STATUS_DEPOSIT_PERIOD";
      case C.PROPOSAL_STATUS_VOTING_PERIOD:
        return "PROPOSAL_STATUS_VOTING_PERIOD";
      case C.PROPOSAL_STATUS_PASSED:
        return "PROPOSAL_STATUS_PASSED";
      case C.PROPOSAL_STATUS_REJECTED:
        return "PROPOSAL_STATUS_REJECTED";
      case C.PROPOSAL_STATUS_FAILED:
        return "PROPOSAL_STATUS_FAILED";
      case C.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.proposalStatusToJSON = p;
  function m() {
    return {
      option: 0,
      weight: ""
    };
  }
  e.WeightedVoteOption = {
    typeUrl: "/cosmos.gov.v1beta1.WeightedVoteOption",
    encode(o, h = f.BinaryWriter.create()) {
      return o.option !== 0 && h.uint32(8).int32(o.option), o.weight !== "" && h.uint32(18).string(o.weight), h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = m();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.option = N.int32();
            break;
          case 2:
            u.weight = N.string();
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = m();
      return (0, S.isSet)(o.option) && (h.option = T(o.option)), (0, S.isSet)(o.weight) && (h.weight = String(o.weight)), h;
    },
    toJSON(o) {
      const h = {};
      return o.option !== void 0 && (h.option = J(o.option)), o.weight !== void 0 && (h.weight = o.weight), h;
    },
    fromPartial(o) {
      const h = m();
      return h.option = o.option ?? 0, h.weight = o.weight ?? "", h;
    }
  };
  function v() {
    return {
      title: "",
      description: ""
    };
  }
  e.TextProposal = {
    typeUrl: "/cosmos.gov.v1beta1.TextProposal",
    encode(o, h = f.BinaryWriter.create()) {
      return o.title !== "" && h.uint32(10).string(o.title), o.description !== "" && h.uint32(18).string(o.description), h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = v();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.title = N.string();
            break;
          case 2:
            u.description = N.string();
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = v();
      return (0, S.isSet)(o.title) && (h.title = String(o.title)), (0, S.isSet)(o.description) && (h.description = String(o.description)), h;
    },
    toJSON(o) {
      const h = {};
      return o.title !== void 0 && (h.title = o.title), o.description !== void 0 && (h.description = o.description), h;
    },
    fromPartial(o) {
      const h = v();
      return h.title = o.title ?? "", h.description = o.description ?? "", h;
    }
  };
  function a() {
    return {
      proposalId: BigInt(0),
      depositor: "",
      amount: []
    };
  }
  e.Deposit = {
    typeUrl: "/cosmos.gov.v1beta1.Deposit",
    encode(o, h = f.BinaryWriter.create()) {
      o.proposalId !== BigInt(0) && h.uint32(8).uint64(o.proposalId), o.depositor !== "" && h.uint32(18).string(o.depositor);
      for (const N of o.amount)
        n.Coin.encode(N, h.uint32(26).fork()).ldelim();
      return h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = a();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.proposalId = N.uint64();
            break;
          case 2:
            u.depositor = N.string();
            break;
          case 3:
            u.amount.push(n.Coin.decode(N, N.uint32()));
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = a();
      return (0, S.isSet)(o.proposalId) && (h.proposalId = BigInt(o.proposalId.toString())), (0, S.isSet)(o.depositor) && (h.depositor = String(o.depositor)), Array.isArray(o == null ? void 0 : o.amount) && (h.amount = o.amount.map((N) => n.Coin.fromJSON(N))), h;
    },
    toJSON(o) {
      const h = {};
      return o.proposalId !== void 0 && (h.proposalId = (o.proposalId || BigInt(0)).toString()), o.depositor !== void 0 && (h.depositor = o.depositor), o.amount ? h.amount = o.amount.map((N) => N ? n.Coin.toJSON(N) : void 0) : h.amount = [], h;
    },
    fromPartial(o) {
      var N;
      const h = a();
      return o.proposalId !== void 0 && o.proposalId !== null && (h.proposalId = BigInt(o.proposalId.toString())), h.depositor = o.depositor ?? "", h.amount = ((N = o.amount) == null ? void 0 : N.map((q) => n.Coin.fromPartial(q))) || [], h;
    }
  };
  function d() {
    return {
      proposalId: BigInt(0),
      content: void 0,
      status: 0,
      finalTallyResult: e.TallyResult.fromPartial({}),
      submitTime: t.Timestamp.fromPartial({}),
      depositEndTime: t.Timestamp.fromPartial({}),
      totalDeposit: [],
      votingStartTime: t.Timestamp.fromPartial({}),
      votingEndTime: t.Timestamp.fromPartial({})
    };
  }
  e.Proposal = {
    typeUrl: "/cosmos.gov.v1beta1.Proposal",
    encode(o, h = f.BinaryWriter.create()) {
      o.proposalId !== BigInt(0) && h.uint32(8).uint64(o.proposalId), o.content !== void 0 && r.Any.encode(o.content, h.uint32(18).fork()).ldelim(), o.status !== 0 && h.uint32(24).int32(o.status), o.finalTallyResult !== void 0 && e.TallyResult.encode(o.finalTallyResult, h.uint32(34).fork()).ldelim(), o.submitTime !== void 0 && t.Timestamp.encode(o.submitTime, h.uint32(42).fork()).ldelim(), o.depositEndTime !== void 0 && t.Timestamp.encode(o.depositEndTime, h.uint32(50).fork()).ldelim();
      for (const N of o.totalDeposit)
        n.Coin.encode(N, h.uint32(58).fork()).ldelim();
      return o.votingStartTime !== void 0 && t.Timestamp.encode(o.votingStartTime, h.uint32(66).fork()).ldelim(), o.votingEndTime !== void 0 && t.Timestamp.encode(o.votingEndTime, h.uint32(74).fork()).ldelim(), h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = d();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.proposalId = N.uint64();
            break;
          case 2:
            u.content = r.Any.decode(N, N.uint32());
            break;
          case 3:
            u.status = N.int32();
            break;
          case 4:
            u.finalTallyResult = e.TallyResult.decode(N, N.uint32());
            break;
          case 5:
            u.submitTime = t.Timestamp.decode(N, N.uint32());
            break;
          case 6:
            u.depositEndTime = t.Timestamp.decode(N, N.uint32());
            break;
          case 7:
            u.totalDeposit.push(n.Coin.decode(N, N.uint32()));
            break;
          case 8:
            u.votingStartTime = t.Timestamp.decode(N, N.uint32());
            break;
          case 9:
            u.votingEndTime = t.Timestamp.decode(N, N.uint32());
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = d();
      return (0, S.isSet)(o.proposalId) && (h.proposalId = BigInt(o.proposalId.toString())), (0, S.isSet)(o.content) && (h.content = r.Any.fromJSON(o.content)), (0, S.isSet)(o.status) && (h.status = R(o.status)), (0, S.isSet)(o.finalTallyResult) && (h.finalTallyResult = e.TallyResult.fromJSON(o.finalTallyResult)), (0, S.isSet)(o.submitTime) && (h.submitTime = (0, S.fromJsonTimestamp)(o.submitTime)), (0, S.isSet)(o.depositEndTime) && (h.depositEndTime = (0, S.fromJsonTimestamp)(o.depositEndTime)), Array.isArray(o == null ? void 0 : o.totalDeposit) && (h.totalDeposit = o.totalDeposit.map((N) => n.Coin.fromJSON(N))), (0, S.isSet)(o.votingStartTime) && (h.votingStartTime = (0, S.fromJsonTimestamp)(o.votingStartTime)), (0, S.isSet)(o.votingEndTime) && (h.votingEndTime = (0, S.fromJsonTimestamp)(o.votingEndTime)), h;
    },
    toJSON(o) {
      const h = {};
      return o.proposalId !== void 0 && (h.proposalId = (o.proposalId || BigInt(0)).toString()), o.content !== void 0 && (h.content = o.content ? r.Any.toJSON(o.content) : void 0), o.status !== void 0 && (h.status = p(o.status)), o.finalTallyResult !== void 0 && (h.finalTallyResult = o.finalTallyResult ? e.TallyResult.toJSON(o.finalTallyResult) : void 0), o.submitTime !== void 0 && (h.submitTime = (0, S.fromTimestamp)(o.submitTime).toISOString()), o.depositEndTime !== void 0 && (h.depositEndTime = (0, S.fromTimestamp)(o.depositEndTime).toISOString()), o.totalDeposit ? h.totalDeposit = o.totalDeposit.map((N) => N ? n.Coin.toJSON(N) : void 0) : h.totalDeposit = [], o.votingStartTime !== void 0 && (h.votingStartTime = (0, S.fromTimestamp)(o.votingStartTime).toISOString()), o.votingEndTime !== void 0 && (h.votingEndTime = (0, S.fromTimestamp)(o.votingEndTime).toISOString()), h;
    },
    fromPartial(o) {
      var N;
      const h = d();
      return o.proposalId !== void 0 && o.proposalId !== null && (h.proposalId = BigInt(o.proposalId.toString())), o.content !== void 0 && o.content !== null && (h.content = r.Any.fromPartial(o.content)), h.status = o.status ?? 0, o.finalTallyResult !== void 0 && o.finalTallyResult !== null && (h.finalTallyResult = e.TallyResult.fromPartial(o.finalTallyResult)), o.submitTime !== void 0 && o.submitTime !== null && (h.submitTime = t.Timestamp.fromPartial(o.submitTime)), o.depositEndTime !== void 0 && o.depositEndTime !== null && (h.depositEndTime = t.Timestamp.fromPartial(o.depositEndTime)), h.totalDeposit = ((N = o.totalDeposit) == null ? void 0 : N.map((q) => n.Coin.fromPartial(q))) || [], o.votingStartTime !== void 0 && o.votingStartTime !== null && (h.votingStartTime = t.Timestamp.fromPartial(o.votingStartTime)), o.votingEndTime !== void 0 && o.votingEndTime !== null && (h.votingEndTime = t.Timestamp.fromPartial(o.votingEndTime)), h;
    }
  };
  function y() {
    return {
      yes: "",
      abstain: "",
      no: "",
      noWithVeto: ""
    };
  }
  e.TallyResult = {
    typeUrl: "/cosmos.gov.v1beta1.TallyResult",
    encode(o, h = f.BinaryWriter.create()) {
      return o.yes !== "" && h.uint32(10).string(o.yes), o.abstain !== "" && h.uint32(18).string(o.abstain), o.no !== "" && h.uint32(26).string(o.no), o.noWithVeto !== "" && h.uint32(34).string(o.noWithVeto), h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = y();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.yes = N.string();
            break;
          case 2:
            u.abstain = N.string();
            break;
          case 3:
            u.no = N.string();
            break;
          case 4:
            u.noWithVeto = N.string();
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = y();
      return (0, S.isSet)(o.yes) && (h.yes = String(o.yes)), (0, S.isSet)(o.abstain) && (h.abstain = String(o.abstain)), (0, S.isSet)(o.no) && (h.no = String(o.no)), (0, S.isSet)(o.noWithVeto) && (h.noWithVeto = String(o.noWithVeto)), h;
    },
    toJSON(o) {
      const h = {};
      return o.yes !== void 0 && (h.yes = o.yes), o.abstain !== void 0 && (h.abstain = o.abstain), o.no !== void 0 && (h.no = o.no), o.noWithVeto !== void 0 && (h.noWithVeto = o.noWithVeto), h;
    },
    fromPartial(o) {
      const h = y();
      return h.yes = o.yes ?? "", h.abstain = o.abstain ?? "", h.no = o.no ?? "", h.noWithVeto = o.noWithVeto ?? "", h;
    }
  };
  function _() {
    return {
      proposalId: BigInt(0),
      voter: "",
      option: 0,
      options: []
    };
  }
  e.Vote = {
    typeUrl: "/cosmos.gov.v1beta1.Vote",
    encode(o, h = f.BinaryWriter.create()) {
      o.proposalId !== BigInt(0) && h.uint32(8).uint64(o.proposalId), o.voter !== "" && h.uint32(18).string(o.voter), o.option !== 0 && h.uint32(24).int32(o.option);
      for (const N of o.options)
        e.WeightedVoteOption.encode(N, h.uint32(34).fork()).ldelim();
      return h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = _();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.proposalId = N.uint64();
            break;
          case 2:
            u.voter = N.string();
            break;
          case 3:
            u.option = N.int32();
            break;
          case 4:
            u.options.push(e.WeightedVoteOption.decode(N, N.uint32()));
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = _();
      return (0, S.isSet)(o.proposalId) && (h.proposalId = BigInt(o.proposalId.toString())), (0, S.isSet)(o.voter) && (h.voter = String(o.voter)), (0, S.isSet)(o.option) && (h.option = T(o.option)), Array.isArray(o == null ? void 0 : o.options) && (h.options = o.options.map((N) => e.WeightedVoteOption.fromJSON(N))), h;
    },
    toJSON(o) {
      const h = {};
      return o.proposalId !== void 0 && (h.proposalId = (o.proposalId || BigInt(0)).toString()), o.voter !== void 0 && (h.voter = o.voter), o.option !== void 0 && (h.option = J(o.option)), o.options ? h.options = o.options.map((N) => N ? e.WeightedVoteOption.toJSON(N) : void 0) : h.options = [], h;
    },
    fromPartial(o) {
      var N;
      const h = _();
      return o.proposalId !== void 0 && o.proposalId !== null && (h.proposalId = BigInt(o.proposalId.toString())), h.voter = o.voter ?? "", h.option = o.option ?? 0, h.options = ((N = o.options) == null ? void 0 : N.map((q) => e.WeightedVoteOption.fromPartial(q))) || [], h;
    }
  };
  function E() {
    return {
      minDeposit: [],
      maxDepositPeriod: i.Duration.fromPartial({})
    };
  }
  e.DepositParams = {
    typeUrl: "/cosmos.gov.v1beta1.DepositParams",
    encode(o, h = f.BinaryWriter.create()) {
      for (const N of o.minDeposit)
        n.Coin.encode(N, h.uint32(10).fork()).ldelim();
      return o.maxDepositPeriod !== void 0 && i.Duration.encode(o.maxDepositPeriod, h.uint32(18).fork()).ldelim(), h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = E();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.minDeposit.push(n.Coin.decode(N, N.uint32()));
            break;
          case 2:
            u.maxDepositPeriod = i.Duration.decode(N, N.uint32());
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = E();
      return Array.isArray(o == null ? void 0 : o.minDeposit) && (h.minDeposit = o.minDeposit.map((N) => n.Coin.fromJSON(N))), (0, S.isSet)(o.maxDepositPeriod) && (h.maxDepositPeriod = i.Duration.fromJSON(o.maxDepositPeriod)), h;
    },
    toJSON(o) {
      const h = {};
      return o.minDeposit ? h.minDeposit = o.minDeposit.map((N) => N ? n.Coin.toJSON(N) : void 0) : h.minDeposit = [], o.maxDepositPeriod !== void 0 && (h.maxDepositPeriod = o.maxDepositPeriod ? i.Duration.toJSON(o.maxDepositPeriod) : void 0), h;
    },
    fromPartial(o) {
      var N;
      const h = E();
      return h.minDeposit = ((N = o.minDeposit) == null ? void 0 : N.map((q) => n.Coin.fromPartial(q))) || [], o.maxDepositPeriod !== void 0 && o.maxDepositPeriod !== null && (h.maxDepositPeriod = i.Duration.fromPartial(o.maxDepositPeriod)), h;
    }
  };
  function U() {
    return {
      votingPeriod: i.Duration.fromPartial({})
    };
  }
  e.VotingParams = {
    typeUrl: "/cosmos.gov.v1beta1.VotingParams",
    encode(o, h = f.BinaryWriter.create()) {
      return o.votingPeriod !== void 0 && i.Duration.encode(o.votingPeriod, h.uint32(10).fork()).ldelim(), h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = U();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.votingPeriod = i.Duration.decode(N, N.uint32());
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = U();
      return (0, S.isSet)(o.votingPeriod) && (h.votingPeriod = i.Duration.fromJSON(o.votingPeriod)), h;
    },
    toJSON(o) {
      const h = {};
      return o.votingPeriod !== void 0 && (h.votingPeriod = o.votingPeriod ? i.Duration.toJSON(o.votingPeriod) : void 0), h;
    },
    fromPartial(o) {
      const h = U();
      return o.votingPeriod !== void 0 && o.votingPeriod !== null && (h.votingPeriod = i.Duration.fromPartial(o.votingPeriod)), h;
    }
  };
  function V() {
    return {
      quorum: new Uint8Array(),
      threshold: new Uint8Array(),
      vetoThreshold: new Uint8Array()
    };
  }
  e.TallyParams = {
    typeUrl: "/cosmos.gov.v1beta1.TallyParams",
    encode(o, h = f.BinaryWriter.create()) {
      return o.quorum.length !== 0 && h.uint32(10).bytes(o.quorum), o.threshold.length !== 0 && h.uint32(18).bytes(o.threshold), o.vetoThreshold.length !== 0 && h.uint32(26).bytes(o.vetoThreshold), h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = V();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.quorum = N.bytes();
            break;
          case 2:
            u.threshold = N.bytes();
            break;
          case 3:
            u.vetoThreshold = N.bytes();
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = V();
      return (0, S.isSet)(o.quorum) && (h.quorum = (0, S.bytesFromBase64)(o.quorum)), (0, S.isSet)(o.threshold) && (h.threshold = (0, S.bytesFromBase64)(o.threshold)), (0, S.isSet)(o.vetoThreshold) && (h.vetoThreshold = (0, S.bytesFromBase64)(o.vetoThreshold)), h;
    },
    toJSON(o) {
      const h = {};
      return o.quorum !== void 0 && (h.quorum = (0, S.base64FromBytes)(o.quorum !== void 0 ? o.quorum : new Uint8Array())), o.threshold !== void 0 && (h.threshold = (0, S.base64FromBytes)(o.threshold !== void 0 ? o.threshold : new Uint8Array())), o.vetoThreshold !== void 0 && (h.vetoThreshold = (0, S.base64FromBytes)(o.vetoThreshold !== void 0 ? o.vetoThreshold : new Uint8Array())), h;
    },
    fromPartial(o) {
      const h = V();
      return h.quorum = o.quorum ?? new Uint8Array(), h.threshold = o.threshold ?? new Uint8Array(), h.vetoThreshold = o.vetoThreshold ?? new Uint8Array(), h;
    }
  };
})(vs);
Object.defineProperty(wn, "__esModule", { value: !0 });
wn.createGovAminoConverters = wn.isAminoMsgDeposit = wn.isAminoMsgVoteWeighted = wn.isAminoMsgVote = wn.isAminoMsgSubmitProposal = void 0;
const Eb = Ie, zi = Te, xi = vs, Ub = Pe, Jb = Ye;
function Db(e) {
  return e.type === "cosmos-sdk/MsgSubmitProposal";
}
wn.isAminoMsgSubmitProposal = Db;
function Mb(e) {
  return e.type === "cosmos-sdk/MsgVote";
}
wn.isAminoMsgVote = Mb;
function Hb(e) {
  return e.type === "cosmos-sdk/MsgVoteWeighted";
}
wn.isAminoMsgVoteWeighted = Hb;
function qb(e) {
  return e.type === "cosmos-sdk/MsgDeposit";
}
wn.isAminoMsgDeposit = qb;
function Vb() {
  return {
    "/cosmos.gov.v1beta1.MsgDeposit": {
      aminoType: "cosmos-sdk/MsgDeposit",
      toAmino: ({ amount: e, depositor: n, proposalId: r }) => ({
        amount: e,
        depositor: n,
        proposal_id: r.toString()
      }),
      fromAmino: ({ amount: e, depositor: n, proposal_id: r }) => ({
        amount: Array.from(e),
        depositor: n,
        proposalId: BigInt(r)
      })
    },
    "/cosmos.gov.v1beta1.MsgVote": {
      aminoType: "cosmos-sdk/MsgVote",
      toAmino: ({ option: e, proposalId: n, voter: r }) => ({
        option: e,
        proposal_id: n.toString(),
        voter: r
      }),
      fromAmino: ({ option: e, proposal_id: n, voter: r }) => ({
        option: (0, xi.voteOptionFromJSON)(e),
        proposalId: BigInt(n),
        voter: r
      })
    },
    "/cosmos.gov.v1beta1.MsgVoteWeighted": {
      aminoType: "cosmos-sdk/MsgVoteWeighted",
      toAmino: ({ options: e, proposalId: n, voter: r }) => ({
        options: e.map((t) => ({
          option: t.option,
          // Weight is between 0 and 1, so we always have 20 characters when printing all trailing
          // zeros (e.g. "0.700000000000000000" or "1.000000000000000000")
          weight: (0, Jb.decodeCosmosSdkDecFromProto)(t.weight).toString().padEnd(20, "0")
        })),
        proposal_id: n.toString(),
        voter: r
      }),
      fromAmino: ({ options: e, proposal_id: n, voter: r }) => ({
        proposalId: BigInt(n),
        voter: r,
        options: e.map((t) => ({
          option: (0, xi.voteOptionFromJSON)(t.option),
          weight: Eb.Decimal.fromUserInput(t.weight, 18).atomics
        }))
      })
    },
    "/cosmos.gov.v1beta1.MsgSubmitProposal": {
      aminoType: "cosmos-sdk/MsgSubmitProposal",
      toAmino: ({ initialDeposit: e, proposer: n, content: r }) => {
        (0, zi.assertDefinedAndNotNull)(r);
        let t;
        switch (r.typeUrl) {
          case "/cosmos.gov.v1beta1.TextProposal": {
            const i = xi.TextProposal.decode(r.value);
            t = {
              type: "cosmos-sdk/TextProposal",
              value: {
                description: i.description,
                title: i.title
              }
            };
            break;
          }
          default:
            throw new Error(`Unsupported proposal type: '${r.typeUrl}'`);
        }
        return {
          initial_deposit: e,
          proposer: n,
          content: t
        };
      },
      fromAmino: ({ initial_deposit: e, proposer: n, content: r }) => {
        let t;
        switch (r.type) {
          case "cosmos-sdk/TextProposal": {
            const { value: i } = r;
            (0, zi.assert)((0, zi.isNonNullObject)(i));
            const { title: f, description: S } = i;
            (0, zi.assert)(typeof f == "string"), (0, zi.assert)(typeof S == "string"), t = Ub.Any.fromPartial({
              typeUrl: "/cosmos.gov.v1beta1.TextProposal",
              value: xi.TextProposal.encode(xi.TextProposal.fromPartial({
                title: f,
                description: S
              })).finish()
            });
            break;
          }
          default:
            throw new Error(`Unsupported proposal type: '${r.type}'`);
        }
        return {
          initialDeposit: Array.from(e),
          proposer: n,
          content: t
        };
      }
    }
  };
}
wn.createGovAminoConverters = Vb;
var Cn = {}, vh = {}, bh = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Params = e.TallyParams = e.VotingParams = e.DepositParams = e.Vote = e.TallyResult = e.Proposal = e.Deposit = e.WeightedVoteOption = e.proposalStatusToJSON = e.proposalStatusFromJSON = e.ProposalStatus = e.voteOptionToJSON = e.voteOptionFromJSON = e.VoteOption = e.protobufPackage = void 0;
  const n = De, r = Pe, t = Je, i = vn, f = re, S = ie;
  e.protobufPackage = "cosmos.gov.v1";
  var w;
  (function(o) {
    o[o.VOTE_OPTION_UNSPECIFIED = 0] = "VOTE_OPTION_UNSPECIFIED", o[o.VOTE_OPTION_YES = 1] = "VOTE_OPTION_YES", o[o.VOTE_OPTION_ABSTAIN = 2] = "VOTE_OPTION_ABSTAIN", o[o.VOTE_OPTION_NO = 3] = "VOTE_OPTION_NO", o[o.VOTE_OPTION_NO_WITH_VETO = 4] = "VOTE_OPTION_NO_WITH_VETO", o[o.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(w || (e.VoteOption = w = {}));
  function T(o) {
    switch (o) {
      case 0:
      case "VOTE_OPTION_UNSPECIFIED":
        return w.VOTE_OPTION_UNSPECIFIED;
      case 1:
      case "VOTE_OPTION_YES":
        return w.VOTE_OPTION_YES;
      case 2:
      case "VOTE_OPTION_ABSTAIN":
        return w.VOTE_OPTION_ABSTAIN;
      case 3:
      case "VOTE_OPTION_NO":
        return w.VOTE_OPTION_NO;
      case 4:
      case "VOTE_OPTION_NO_WITH_VETO":
        return w.VOTE_OPTION_NO_WITH_VETO;
      case -1:
      case "UNRECOGNIZED":
      default:
        return w.UNRECOGNIZED;
    }
  }
  e.voteOptionFromJSON = T;
  function J(o) {
    switch (o) {
      case w.VOTE_OPTION_UNSPECIFIED:
        return "VOTE_OPTION_UNSPECIFIED";
      case w.VOTE_OPTION_YES:
        return "VOTE_OPTION_YES";
      case w.VOTE_OPTION_ABSTAIN:
        return "VOTE_OPTION_ABSTAIN";
      case w.VOTE_OPTION_NO:
        return "VOTE_OPTION_NO";
      case w.VOTE_OPTION_NO_WITH_VETO:
        return "VOTE_OPTION_NO_WITH_VETO";
      case w.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.voteOptionToJSON = J;
  var C;
  (function(o) {
    o[o.PROPOSAL_STATUS_UNSPECIFIED = 0] = "PROPOSAL_STATUS_UNSPECIFIED", o[o.PROPOSAL_STATUS_DEPOSIT_PERIOD = 1] = "PROPOSAL_STATUS_DEPOSIT_PERIOD", o[o.PROPOSAL_STATUS_VOTING_PERIOD = 2] = "PROPOSAL_STATUS_VOTING_PERIOD", o[o.PROPOSAL_STATUS_PASSED = 3] = "PROPOSAL_STATUS_PASSED", o[o.PROPOSAL_STATUS_REJECTED = 4] = "PROPOSAL_STATUS_REJECTED", o[o.PROPOSAL_STATUS_FAILED = 5] = "PROPOSAL_STATUS_FAILED", o[o.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(C || (e.ProposalStatus = C = {}));
  function R(o) {
    switch (o) {
      case 0:
      case "PROPOSAL_STATUS_UNSPECIFIED":
        return C.PROPOSAL_STATUS_UNSPECIFIED;
      case 1:
      case "PROPOSAL_STATUS_DEPOSIT_PERIOD":
        return C.PROPOSAL_STATUS_DEPOSIT_PERIOD;
      case 2:
      case "PROPOSAL_STATUS_VOTING_PERIOD":
        return C.PROPOSAL_STATUS_VOTING_PERIOD;
      case 3:
      case "PROPOSAL_STATUS_PASSED":
        return C.PROPOSAL_STATUS_PASSED;
      case 4:
      case "PROPOSAL_STATUS_REJECTED":
        return C.PROPOSAL_STATUS_REJECTED;
      case 5:
      case "PROPOSAL_STATUS_FAILED":
        return C.PROPOSAL_STATUS_FAILED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return C.UNRECOGNIZED;
    }
  }
  e.proposalStatusFromJSON = R;
  function p(o) {
    switch (o) {
      case C.PROPOSAL_STATUS_UNSPECIFIED:
        return "PROPOSAL_STATUS_UNSPECIFIED";
      case C.PROPOSAL_STATUS_DEPOSIT_PERIOD:
        return "PROPOSAL_STATUS_DEPOSIT_PERIOD";
      case C.PROPOSAL_STATUS_VOTING_PERIOD:
        return "PROPOSAL_STATUS_VOTING_PERIOD";
      case C.PROPOSAL_STATUS_PASSED:
        return "PROPOSAL_STATUS_PASSED";
      case C.PROPOSAL_STATUS_REJECTED:
        return "PROPOSAL_STATUS_REJECTED";
      case C.PROPOSAL_STATUS_FAILED:
        return "PROPOSAL_STATUS_FAILED";
      case C.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.proposalStatusToJSON = p;
  function m() {
    return {
      option: 0,
      weight: ""
    };
  }
  e.WeightedVoteOption = {
    typeUrl: "/cosmos.gov.v1.WeightedVoteOption",
    encode(o, h = f.BinaryWriter.create()) {
      return o.option !== 0 && h.uint32(8).int32(o.option), o.weight !== "" && h.uint32(18).string(o.weight), h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = m();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.option = N.int32();
            break;
          case 2:
            u.weight = N.string();
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = m();
      return (0, S.isSet)(o.option) && (h.option = T(o.option)), (0, S.isSet)(o.weight) && (h.weight = String(o.weight)), h;
    },
    toJSON(o) {
      const h = {};
      return o.option !== void 0 && (h.option = J(o.option)), o.weight !== void 0 && (h.weight = o.weight), h;
    },
    fromPartial(o) {
      const h = m();
      return h.option = o.option ?? 0, h.weight = o.weight ?? "", h;
    }
  };
  function v() {
    return {
      proposalId: BigInt(0),
      depositor: "",
      amount: []
    };
  }
  e.Deposit = {
    typeUrl: "/cosmos.gov.v1.Deposit",
    encode(o, h = f.BinaryWriter.create()) {
      o.proposalId !== BigInt(0) && h.uint32(8).uint64(o.proposalId), o.depositor !== "" && h.uint32(18).string(o.depositor);
      for (const N of o.amount)
        n.Coin.encode(N, h.uint32(26).fork()).ldelim();
      return h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = v();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.proposalId = N.uint64();
            break;
          case 2:
            u.depositor = N.string();
            break;
          case 3:
            u.amount.push(n.Coin.decode(N, N.uint32()));
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = v();
      return (0, S.isSet)(o.proposalId) && (h.proposalId = BigInt(o.proposalId.toString())), (0, S.isSet)(o.depositor) && (h.depositor = String(o.depositor)), Array.isArray(o == null ? void 0 : o.amount) && (h.amount = o.amount.map((N) => n.Coin.fromJSON(N))), h;
    },
    toJSON(o) {
      const h = {};
      return o.proposalId !== void 0 && (h.proposalId = (o.proposalId || BigInt(0)).toString()), o.depositor !== void 0 && (h.depositor = o.depositor), o.amount ? h.amount = o.amount.map((N) => N ? n.Coin.toJSON(N) : void 0) : h.amount = [], h;
    },
    fromPartial(o) {
      var N;
      const h = v();
      return o.proposalId !== void 0 && o.proposalId !== null && (h.proposalId = BigInt(o.proposalId.toString())), h.depositor = o.depositor ?? "", h.amount = ((N = o.amount) == null ? void 0 : N.map((q) => n.Coin.fromPartial(q))) || [], h;
    }
  };
  function a() {
    return {
      id: BigInt(0),
      messages: [],
      status: 0,
      finalTallyResult: void 0,
      submitTime: void 0,
      depositEndTime: void 0,
      totalDeposit: [],
      votingStartTime: void 0,
      votingEndTime: void 0,
      metadata: "",
      title: "",
      summary: "",
      proposer: ""
    };
  }
  e.Proposal = {
    typeUrl: "/cosmos.gov.v1.Proposal",
    encode(o, h = f.BinaryWriter.create()) {
      o.id !== BigInt(0) && h.uint32(8).uint64(o.id);
      for (const N of o.messages)
        r.Any.encode(N, h.uint32(18).fork()).ldelim();
      o.status !== 0 && h.uint32(24).int32(o.status), o.finalTallyResult !== void 0 && e.TallyResult.encode(o.finalTallyResult, h.uint32(34).fork()).ldelim(), o.submitTime !== void 0 && t.Timestamp.encode(o.submitTime, h.uint32(42).fork()).ldelim(), o.depositEndTime !== void 0 && t.Timestamp.encode(o.depositEndTime, h.uint32(50).fork()).ldelim();
      for (const N of o.totalDeposit)
        n.Coin.encode(N, h.uint32(58).fork()).ldelim();
      return o.votingStartTime !== void 0 && t.Timestamp.encode(o.votingStartTime, h.uint32(66).fork()).ldelim(), o.votingEndTime !== void 0 && t.Timestamp.encode(o.votingEndTime, h.uint32(74).fork()).ldelim(), o.metadata !== "" && h.uint32(82).string(o.metadata), o.title !== "" && h.uint32(90).string(o.title), o.summary !== "" && h.uint32(98).string(o.summary), o.proposer !== "" && h.uint32(106).string(o.proposer), h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = a();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.id = N.uint64();
            break;
          case 2:
            u.messages.push(r.Any.decode(N, N.uint32()));
            break;
          case 3:
            u.status = N.int32();
            break;
          case 4:
            u.finalTallyResult = e.TallyResult.decode(N, N.uint32());
            break;
          case 5:
            u.submitTime = t.Timestamp.decode(N, N.uint32());
            break;
          case 6:
            u.depositEndTime = t.Timestamp.decode(N, N.uint32());
            break;
          case 7:
            u.totalDeposit.push(n.Coin.decode(N, N.uint32()));
            break;
          case 8:
            u.votingStartTime = t.Timestamp.decode(N, N.uint32());
            break;
          case 9:
            u.votingEndTime = t.Timestamp.decode(N, N.uint32());
            break;
          case 10:
            u.metadata = N.string();
            break;
          case 11:
            u.title = N.string();
            break;
          case 12:
            u.summary = N.string();
            break;
          case 13:
            u.proposer = N.string();
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = a();
      return (0, S.isSet)(o.id) && (h.id = BigInt(o.id.toString())), Array.isArray(o == null ? void 0 : o.messages) && (h.messages = o.messages.map((N) => r.Any.fromJSON(N))), (0, S.isSet)(o.status) && (h.status = R(o.status)), (0, S.isSet)(o.finalTallyResult) && (h.finalTallyResult = e.TallyResult.fromJSON(o.finalTallyResult)), (0, S.isSet)(o.submitTime) && (h.submitTime = (0, S.fromJsonTimestamp)(o.submitTime)), (0, S.isSet)(o.depositEndTime) && (h.depositEndTime = (0, S.fromJsonTimestamp)(o.depositEndTime)), Array.isArray(o == null ? void 0 : o.totalDeposit) && (h.totalDeposit = o.totalDeposit.map((N) => n.Coin.fromJSON(N))), (0, S.isSet)(o.votingStartTime) && (h.votingStartTime = (0, S.fromJsonTimestamp)(o.votingStartTime)), (0, S.isSet)(o.votingEndTime) && (h.votingEndTime = (0, S.fromJsonTimestamp)(o.votingEndTime)), (0, S.isSet)(o.metadata) && (h.metadata = String(o.metadata)), (0, S.isSet)(o.title) && (h.title = String(o.title)), (0, S.isSet)(o.summary) && (h.summary = String(o.summary)), (0, S.isSet)(o.proposer) && (h.proposer = String(o.proposer)), h;
    },
    toJSON(o) {
      const h = {};
      return o.id !== void 0 && (h.id = (o.id || BigInt(0)).toString()), o.messages ? h.messages = o.messages.map((N) => N ? r.Any.toJSON(N) : void 0) : h.messages = [], o.status !== void 0 && (h.status = p(o.status)), o.finalTallyResult !== void 0 && (h.finalTallyResult = o.finalTallyResult ? e.TallyResult.toJSON(o.finalTallyResult) : void 0), o.submitTime !== void 0 && (h.submitTime = (0, S.fromTimestamp)(o.submitTime).toISOString()), o.depositEndTime !== void 0 && (h.depositEndTime = (0, S.fromTimestamp)(o.depositEndTime).toISOString()), o.totalDeposit ? h.totalDeposit = o.totalDeposit.map((N) => N ? n.Coin.toJSON(N) : void 0) : h.totalDeposit = [], o.votingStartTime !== void 0 && (h.votingStartTime = (0, S.fromTimestamp)(o.votingStartTime).toISOString()), o.votingEndTime !== void 0 && (h.votingEndTime = (0, S.fromTimestamp)(o.votingEndTime).toISOString()), o.metadata !== void 0 && (h.metadata = o.metadata), o.title !== void 0 && (h.title = o.title), o.summary !== void 0 && (h.summary = o.summary), o.proposer !== void 0 && (h.proposer = o.proposer), h;
    },
    fromPartial(o) {
      var N, q;
      const h = a();
      return o.id !== void 0 && o.id !== null && (h.id = BigInt(o.id.toString())), h.messages = ((N = o.messages) == null ? void 0 : N.map((u) => r.Any.fromPartial(u))) || [], h.status = o.status ?? 0, o.finalTallyResult !== void 0 && o.finalTallyResult !== null && (h.finalTallyResult = e.TallyResult.fromPartial(o.finalTallyResult)), o.submitTime !== void 0 && o.submitTime !== null && (h.submitTime = t.Timestamp.fromPartial(o.submitTime)), o.depositEndTime !== void 0 && o.depositEndTime !== null && (h.depositEndTime = t.Timestamp.fromPartial(o.depositEndTime)), h.totalDeposit = ((q = o.totalDeposit) == null ? void 0 : q.map((u) => n.Coin.fromPartial(u))) || [], o.votingStartTime !== void 0 && o.votingStartTime !== null && (h.votingStartTime = t.Timestamp.fromPartial(o.votingStartTime)), o.votingEndTime !== void 0 && o.votingEndTime !== null && (h.votingEndTime = t.Timestamp.fromPartial(o.votingEndTime)), h.metadata = o.metadata ?? "", h.title = o.title ?? "", h.summary = o.summary ?? "", h.proposer = o.proposer ?? "", h;
    }
  };
  function d() {
    return {
      yesCount: "",
      abstainCount: "",
      noCount: "",
      noWithVetoCount: ""
    };
  }
  e.TallyResult = {
    typeUrl: "/cosmos.gov.v1.TallyResult",
    encode(o, h = f.BinaryWriter.create()) {
      return o.yesCount !== "" && h.uint32(10).string(o.yesCount), o.abstainCount !== "" && h.uint32(18).string(o.abstainCount), o.noCount !== "" && h.uint32(26).string(o.noCount), o.noWithVetoCount !== "" && h.uint32(34).string(o.noWithVetoCount), h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = d();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.yesCount = N.string();
            break;
          case 2:
            u.abstainCount = N.string();
            break;
          case 3:
            u.noCount = N.string();
            break;
          case 4:
            u.noWithVetoCount = N.string();
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = d();
      return (0, S.isSet)(o.yesCount) && (h.yesCount = String(o.yesCount)), (0, S.isSet)(o.abstainCount) && (h.abstainCount = String(o.abstainCount)), (0, S.isSet)(o.noCount) && (h.noCount = String(o.noCount)), (0, S.isSet)(o.noWithVetoCount) && (h.noWithVetoCount = String(o.noWithVetoCount)), h;
    },
    toJSON(o) {
      const h = {};
      return o.yesCount !== void 0 && (h.yesCount = o.yesCount), o.abstainCount !== void 0 && (h.abstainCount = o.abstainCount), o.noCount !== void 0 && (h.noCount = o.noCount), o.noWithVetoCount !== void 0 && (h.noWithVetoCount = o.noWithVetoCount), h;
    },
    fromPartial(o) {
      const h = d();
      return h.yesCount = o.yesCount ?? "", h.abstainCount = o.abstainCount ?? "", h.noCount = o.noCount ?? "", h.noWithVetoCount = o.noWithVetoCount ?? "", h;
    }
  };
  function y() {
    return {
      proposalId: BigInt(0),
      voter: "",
      options: [],
      metadata: ""
    };
  }
  e.Vote = {
    typeUrl: "/cosmos.gov.v1.Vote",
    encode(o, h = f.BinaryWriter.create()) {
      o.proposalId !== BigInt(0) && h.uint32(8).uint64(o.proposalId), o.voter !== "" && h.uint32(18).string(o.voter);
      for (const N of o.options)
        e.WeightedVoteOption.encode(N, h.uint32(34).fork()).ldelim();
      return o.metadata !== "" && h.uint32(42).string(o.metadata), h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = y();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.proposalId = N.uint64();
            break;
          case 2:
            u.voter = N.string();
            break;
          case 4:
            u.options.push(e.WeightedVoteOption.decode(N, N.uint32()));
            break;
          case 5:
            u.metadata = N.string();
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = y();
      return (0, S.isSet)(o.proposalId) && (h.proposalId = BigInt(o.proposalId.toString())), (0, S.isSet)(o.voter) && (h.voter = String(o.voter)), Array.isArray(o == null ? void 0 : o.options) && (h.options = o.options.map((N) => e.WeightedVoteOption.fromJSON(N))), (0, S.isSet)(o.metadata) && (h.metadata = String(o.metadata)), h;
    },
    toJSON(o) {
      const h = {};
      return o.proposalId !== void 0 && (h.proposalId = (o.proposalId || BigInt(0)).toString()), o.voter !== void 0 && (h.voter = o.voter), o.options ? h.options = o.options.map((N) => N ? e.WeightedVoteOption.toJSON(N) : void 0) : h.options = [], o.metadata !== void 0 && (h.metadata = o.metadata), h;
    },
    fromPartial(o) {
      var N;
      const h = y();
      return o.proposalId !== void 0 && o.proposalId !== null && (h.proposalId = BigInt(o.proposalId.toString())), h.voter = o.voter ?? "", h.options = ((N = o.options) == null ? void 0 : N.map((q) => e.WeightedVoteOption.fromPartial(q))) || [], h.metadata = o.metadata ?? "", h;
    }
  };
  function _() {
    return {
      minDeposit: [],
      maxDepositPeriod: void 0
    };
  }
  e.DepositParams = {
    typeUrl: "/cosmos.gov.v1.DepositParams",
    encode(o, h = f.BinaryWriter.create()) {
      for (const N of o.minDeposit)
        n.Coin.encode(N, h.uint32(10).fork()).ldelim();
      return o.maxDepositPeriod !== void 0 && i.Duration.encode(o.maxDepositPeriod, h.uint32(18).fork()).ldelim(), h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = _();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.minDeposit.push(n.Coin.decode(N, N.uint32()));
            break;
          case 2:
            u.maxDepositPeriod = i.Duration.decode(N, N.uint32());
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = _();
      return Array.isArray(o == null ? void 0 : o.minDeposit) && (h.minDeposit = o.minDeposit.map((N) => n.Coin.fromJSON(N))), (0, S.isSet)(o.maxDepositPeriod) && (h.maxDepositPeriod = i.Duration.fromJSON(o.maxDepositPeriod)), h;
    },
    toJSON(o) {
      const h = {};
      return o.minDeposit ? h.minDeposit = o.minDeposit.map((N) => N ? n.Coin.toJSON(N) : void 0) : h.minDeposit = [], o.maxDepositPeriod !== void 0 && (h.maxDepositPeriod = o.maxDepositPeriod ? i.Duration.toJSON(o.maxDepositPeriod) : void 0), h;
    },
    fromPartial(o) {
      var N;
      const h = _();
      return h.minDeposit = ((N = o.minDeposit) == null ? void 0 : N.map((q) => n.Coin.fromPartial(q))) || [], o.maxDepositPeriod !== void 0 && o.maxDepositPeriod !== null && (h.maxDepositPeriod = i.Duration.fromPartial(o.maxDepositPeriod)), h;
    }
  };
  function E() {
    return {
      votingPeriod: void 0
    };
  }
  e.VotingParams = {
    typeUrl: "/cosmos.gov.v1.VotingParams",
    encode(o, h = f.BinaryWriter.create()) {
      return o.votingPeriod !== void 0 && i.Duration.encode(o.votingPeriod, h.uint32(10).fork()).ldelim(), h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = E();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.votingPeriod = i.Duration.decode(N, N.uint32());
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = E();
      return (0, S.isSet)(o.votingPeriod) && (h.votingPeriod = i.Duration.fromJSON(o.votingPeriod)), h;
    },
    toJSON(o) {
      const h = {};
      return o.votingPeriod !== void 0 && (h.votingPeriod = o.votingPeriod ? i.Duration.toJSON(o.votingPeriod) : void 0), h;
    },
    fromPartial(o) {
      const h = E();
      return o.votingPeriod !== void 0 && o.votingPeriod !== null && (h.votingPeriod = i.Duration.fromPartial(o.votingPeriod)), h;
    }
  };
  function U() {
    return {
      quorum: "",
      threshold: "",
      vetoThreshold: ""
    };
  }
  e.TallyParams = {
    typeUrl: "/cosmos.gov.v1.TallyParams",
    encode(o, h = f.BinaryWriter.create()) {
      return o.quorum !== "" && h.uint32(10).string(o.quorum), o.threshold !== "" && h.uint32(18).string(o.threshold), o.vetoThreshold !== "" && h.uint32(26).string(o.vetoThreshold), h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = U();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.quorum = N.string();
            break;
          case 2:
            u.threshold = N.string();
            break;
          case 3:
            u.vetoThreshold = N.string();
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = U();
      return (0, S.isSet)(o.quorum) && (h.quorum = String(o.quorum)), (0, S.isSet)(o.threshold) && (h.threshold = String(o.threshold)), (0, S.isSet)(o.vetoThreshold) && (h.vetoThreshold = String(o.vetoThreshold)), h;
    },
    toJSON(o) {
      const h = {};
      return o.quorum !== void 0 && (h.quorum = o.quorum), o.threshold !== void 0 && (h.threshold = o.threshold), o.vetoThreshold !== void 0 && (h.vetoThreshold = o.vetoThreshold), h;
    },
    fromPartial(o) {
      const h = U();
      return h.quorum = o.quorum ?? "", h.threshold = o.threshold ?? "", h.vetoThreshold = o.vetoThreshold ?? "", h;
    }
  };
  function V() {
    return {
      minDeposit: [],
      maxDepositPeriod: void 0,
      votingPeriod: void 0,
      quorum: "",
      threshold: "",
      vetoThreshold: "",
      minInitialDepositRatio: "",
      burnVoteQuorum: !1,
      burnProposalDepositPrevote: !1,
      burnVoteVeto: !1
    };
  }
  e.Params = {
    typeUrl: "/cosmos.gov.v1.Params",
    encode(o, h = f.BinaryWriter.create()) {
      for (const N of o.minDeposit)
        n.Coin.encode(N, h.uint32(10).fork()).ldelim();
      return o.maxDepositPeriod !== void 0 && i.Duration.encode(o.maxDepositPeriod, h.uint32(18).fork()).ldelim(), o.votingPeriod !== void 0 && i.Duration.encode(o.votingPeriod, h.uint32(26).fork()).ldelim(), o.quorum !== "" && h.uint32(34).string(o.quorum), o.threshold !== "" && h.uint32(42).string(o.threshold), o.vetoThreshold !== "" && h.uint32(50).string(o.vetoThreshold), o.minInitialDepositRatio !== "" && h.uint32(58).string(o.minInitialDepositRatio), o.burnVoteQuorum === !0 && h.uint32(104).bool(o.burnVoteQuorum), o.burnProposalDepositPrevote === !0 && h.uint32(112).bool(o.burnProposalDepositPrevote), o.burnVoteVeto === !0 && h.uint32(120).bool(o.burnVoteVeto), h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = V();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.minDeposit.push(n.Coin.decode(N, N.uint32()));
            break;
          case 2:
            u.maxDepositPeriod = i.Duration.decode(N, N.uint32());
            break;
          case 3:
            u.votingPeriod = i.Duration.decode(N, N.uint32());
            break;
          case 4:
            u.quorum = N.string();
            break;
          case 5:
            u.threshold = N.string();
            break;
          case 6:
            u.vetoThreshold = N.string();
            break;
          case 7:
            u.minInitialDepositRatio = N.string();
            break;
          case 13:
            u.burnVoteQuorum = N.bool();
            break;
          case 14:
            u.burnProposalDepositPrevote = N.bool();
            break;
          case 15:
            u.burnVoteVeto = N.bool();
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = V();
      return Array.isArray(o == null ? void 0 : o.minDeposit) && (h.minDeposit = o.minDeposit.map((N) => n.Coin.fromJSON(N))), (0, S.isSet)(o.maxDepositPeriod) && (h.maxDepositPeriod = i.Duration.fromJSON(o.maxDepositPeriod)), (0, S.isSet)(o.votingPeriod) && (h.votingPeriod = i.Duration.fromJSON(o.votingPeriod)), (0, S.isSet)(o.quorum) && (h.quorum = String(o.quorum)), (0, S.isSet)(o.threshold) && (h.threshold = String(o.threshold)), (0, S.isSet)(o.vetoThreshold) && (h.vetoThreshold = String(o.vetoThreshold)), (0, S.isSet)(o.minInitialDepositRatio) && (h.minInitialDepositRatio = String(o.minInitialDepositRatio)), (0, S.isSet)(o.burnVoteQuorum) && (h.burnVoteQuorum = !!o.burnVoteQuorum), (0, S.isSet)(o.burnProposalDepositPrevote) && (h.burnProposalDepositPrevote = !!o.burnProposalDepositPrevote), (0, S.isSet)(o.burnVoteVeto) && (h.burnVoteVeto = !!o.burnVoteVeto), h;
    },
    toJSON(o) {
      const h = {};
      return o.minDeposit ? h.minDeposit = o.minDeposit.map((N) => N ? n.Coin.toJSON(N) : void 0) : h.minDeposit = [], o.maxDepositPeriod !== void 0 && (h.maxDepositPeriod = o.maxDepositPeriod ? i.Duration.toJSON(o.maxDepositPeriod) : void 0), o.votingPeriod !== void 0 && (h.votingPeriod = o.votingPeriod ? i.Duration.toJSON(o.votingPeriod) : void 0), o.quorum !== void 0 && (h.quorum = o.quorum), o.threshold !== void 0 && (h.threshold = o.threshold), o.vetoThreshold !== void 0 && (h.vetoThreshold = o.vetoThreshold), o.minInitialDepositRatio !== void 0 && (h.minInitialDepositRatio = o.minInitialDepositRatio), o.burnVoteQuorum !== void 0 && (h.burnVoteQuorum = o.burnVoteQuorum), o.burnProposalDepositPrevote !== void 0 && (h.burnProposalDepositPrevote = o.burnProposalDepositPrevote), o.burnVoteVeto !== void 0 && (h.burnVoteVeto = o.burnVoteVeto), h;
    },
    fromPartial(o) {
      var N;
      const h = V();
      return h.minDeposit = ((N = o.minDeposit) == null ? void 0 : N.map((q) => n.Coin.fromPartial(q))) || [], o.maxDepositPeriod !== void 0 && o.maxDepositPeriod !== null && (h.maxDepositPeriod = i.Duration.fromPartial(o.maxDepositPeriod)), o.votingPeriod !== void 0 && o.votingPeriod !== null && (h.votingPeriod = i.Duration.fromPartial(o.votingPeriod)), h.quorum = o.quorum ?? "", h.threshold = o.threshold ?? "", h.vetoThreshold = o.vetoThreshold ?? "", h.minInitialDepositRatio = o.minInitialDepositRatio ?? "", h.burnVoteQuorum = o.burnVoteQuorum ?? !1, h.burnProposalDepositPrevote = o.burnProposalDepositPrevote ?? !1, h.burnVoteVeto = o.burnVoteVeto ?? !1, h;
    }
  };
})(bh);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgUpdateParamsResponse = e.MsgUpdateParams = e.MsgDepositResponse = e.MsgDeposit = e.MsgVoteWeightedResponse = e.MsgVoteWeighted = e.MsgVoteResponse = e.MsgVote = e.MsgExecLegacyContentResponse = e.MsgExecLegacyContent = e.MsgSubmitProposalResponse = e.MsgSubmitProposal = e.protobufPackage = void 0;
  const n = Pe, r = De, t = bh, i = re, f = ie;
  e.protobufPackage = "cosmos.gov.v1";
  function S() {
    return {
      messages: [],
      initialDeposit: [],
      proposer: "",
      metadata: "",
      title: "",
      summary: ""
    };
  }
  e.MsgSubmitProposal = {
    typeUrl: "/cosmos.gov.v1.MsgSubmitProposal",
    encode(E, U = i.BinaryWriter.create()) {
      for (const V of E.messages)
        n.Any.encode(V, U.uint32(10).fork()).ldelim();
      for (const V of E.initialDeposit)
        r.Coin.encode(V, U.uint32(18).fork()).ldelim();
      return E.proposer !== "" && U.uint32(26).string(E.proposer), E.metadata !== "" && U.uint32(34).string(E.metadata), E.title !== "" && U.uint32(42).string(E.title), E.summary !== "" && U.uint32(50).string(E.summary), U;
    },
    decode(E, U) {
      const V = E instanceof i.BinaryReader ? E : new i.BinaryReader(E);
      let o = U === void 0 ? V.len : V.pos + U;
      const h = S();
      for (; V.pos < o; ) {
        const N = V.uint32();
        switch (N >>> 3) {
          case 1:
            h.messages.push(n.Any.decode(V, V.uint32()));
            break;
          case 2:
            h.initialDeposit.push(r.Coin.decode(V, V.uint32()));
            break;
          case 3:
            h.proposer = V.string();
            break;
          case 4:
            h.metadata = V.string();
            break;
          case 5:
            h.title = V.string();
            break;
          case 6:
            h.summary = V.string();
            break;
          default:
            V.skipType(N & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(E) {
      const U = S();
      return Array.isArray(E == null ? void 0 : E.messages) && (U.messages = E.messages.map((V) => n.Any.fromJSON(V))), Array.isArray(E == null ? void 0 : E.initialDeposit) && (U.initialDeposit = E.initialDeposit.map((V) => r.Coin.fromJSON(V))), (0, f.isSet)(E.proposer) && (U.proposer = String(E.proposer)), (0, f.isSet)(E.metadata) && (U.metadata = String(E.metadata)), (0, f.isSet)(E.title) && (U.title = String(E.title)), (0, f.isSet)(E.summary) && (U.summary = String(E.summary)), U;
    },
    toJSON(E) {
      const U = {};
      return E.messages ? U.messages = E.messages.map((V) => V ? n.Any.toJSON(V) : void 0) : U.messages = [], E.initialDeposit ? U.initialDeposit = E.initialDeposit.map((V) => V ? r.Coin.toJSON(V) : void 0) : U.initialDeposit = [], E.proposer !== void 0 && (U.proposer = E.proposer), E.metadata !== void 0 && (U.metadata = E.metadata), E.title !== void 0 && (U.title = E.title), E.summary !== void 0 && (U.summary = E.summary), U;
    },
    fromPartial(E) {
      var V, o;
      const U = S();
      return U.messages = ((V = E.messages) == null ? void 0 : V.map((h) => n.Any.fromPartial(h))) || [], U.initialDeposit = ((o = E.initialDeposit) == null ? void 0 : o.map((h) => r.Coin.fromPartial(h))) || [], U.proposer = E.proposer ?? "", U.metadata = E.metadata ?? "", U.title = E.title ?? "", U.summary = E.summary ?? "", U;
    }
  };
  function w() {
    return {
      proposalId: BigInt(0)
    };
  }
  e.MsgSubmitProposalResponse = {
    typeUrl: "/cosmos.gov.v1.MsgSubmitProposalResponse",
    encode(E, U = i.BinaryWriter.create()) {
      return E.proposalId !== BigInt(0) && U.uint32(8).uint64(E.proposalId), U;
    },
    decode(E, U) {
      const V = E instanceof i.BinaryReader ? E : new i.BinaryReader(E);
      let o = U === void 0 ? V.len : V.pos + U;
      const h = w();
      for (; V.pos < o; ) {
        const N = V.uint32();
        switch (N >>> 3) {
          case 1:
            h.proposalId = V.uint64();
            break;
          default:
            V.skipType(N & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(E) {
      const U = w();
      return (0, f.isSet)(E.proposalId) && (U.proposalId = BigInt(E.proposalId.toString())), U;
    },
    toJSON(E) {
      const U = {};
      return E.proposalId !== void 0 && (U.proposalId = (E.proposalId || BigInt(0)).toString()), U;
    },
    fromPartial(E) {
      const U = w();
      return E.proposalId !== void 0 && E.proposalId !== null && (U.proposalId = BigInt(E.proposalId.toString())), U;
    }
  };
  function T() {
    return {
      content: void 0,
      authority: ""
    };
  }
  e.MsgExecLegacyContent = {
    typeUrl: "/cosmos.gov.v1.MsgExecLegacyContent",
    encode(E, U = i.BinaryWriter.create()) {
      return E.content !== void 0 && n.Any.encode(E.content, U.uint32(10).fork()).ldelim(), E.authority !== "" && U.uint32(18).string(E.authority), U;
    },
    decode(E, U) {
      const V = E instanceof i.BinaryReader ? E : new i.BinaryReader(E);
      let o = U === void 0 ? V.len : V.pos + U;
      const h = T();
      for (; V.pos < o; ) {
        const N = V.uint32();
        switch (N >>> 3) {
          case 1:
            h.content = n.Any.decode(V, V.uint32());
            break;
          case 2:
            h.authority = V.string();
            break;
          default:
            V.skipType(N & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(E) {
      const U = T();
      return (0, f.isSet)(E.content) && (U.content = n.Any.fromJSON(E.content)), (0, f.isSet)(E.authority) && (U.authority = String(E.authority)), U;
    },
    toJSON(E) {
      const U = {};
      return E.content !== void 0 && (U.content = E.content ? n.Any.toJSON(E.content) : void 0), E.authority !== void 0 && (U.authority = E.authority), U;
    },
    fromPartial(E) {
      const U = T();
      return E.content !== void 0 && E.content !== null && (U.content = n.Any.fromPartial(E.content)), U.authority = E.authority ?? "", U;
    }
  };
  function J() {
    return {};
  }
  e.MsgExecLegacyContentResponse = {
    typeUrl: "/cosmos.gov.v1.MsgExecLegacyContentResponse",
    encode(E, U = i.BinaryWriter.create()) {
      return U;
    },
    decode(E, U) {
      const V = E instanceof i.BinaryReader ? E : new i.BinaryReader(E);
      let o = U === void 0 ? V.len : V.pos + U;
      const h = J();
      for (; V.pos < o; ) {
        const N = V.uint32();
        switch (N >>> 3) {
          default:
            V.skipType(N & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(E) {
      return J();
    },
    toJSON(E) {
      return {};
    },
    fromPartial(E) {
      return J();
    }
  };
  function C() {
    return {
      proposalId: BigInt(0),
      voter: "",
      option: 0,
      metadata: ""
    };
  }
  e.MsgVote = {
    typeUrl: "/cosmos.gov.v1.MsgVote",
    encode(E, U = i.BinaryWriter.create()) {
      return E.proposalId !== BigInt(0) && U.uint32(8).uint64(E.proposalId), E.voter !== "" && U.uint32(18).string(E.voter), E.option !== 0 && U.uint32(24).int32(E.option), E.metadata !== "" && U.uint32(34).string(E.metadata), U;
    },
    decode(E, U) {
      const V = E instanceof i.BinaryReader ? E : new i.BinaryReader(E);
      let o = U === void 0 ? V.len : V.pos + U;
      const h = C();
      for (; V.pos < o; ) {
        const N = V.uint32();
        switch (N >>> 3) {
          case 1:
            h.proposalId = V.uint64();
            break;
          case 2:
            h.voter = V.string();
            break;
          case 3:
            h.option = V.int32();
            break;
          case 4:
            h.metadata = V.string();
            break;
          default:
            V.skipType(N & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(E) {
      const U = C();
      return (0, f.isSet)(E.proposalId) && (U.proposalId = BigInt(E.proposalId.toString())), (0, f.isSet)(E.voter) && (U.voter = String(E.voter)), (0, f.isSet)(E.option) && (U.option = (0, t.voteOptionFromJSON)(E.option)), (0, f.isSet)(E.metadata) && (U.metadata = String(E.metadata)), U;
    },
    toJSON(E) {
      const U = {};
      return E.proposalId !== void 0 && (U.proposalId = (E.proposalId || BigInt(0)).toString()), E.voter !== void 0 && (U.voter = E.voter), E.option !== void 0 && (U.option = (0, t.voteOptionToJSON)(E.option)), E.metadata !== void 0 && (U.metadata = E.metadata), U;
    },
    fromPartial(E) {
      const U = C();
      return E.proposalId !== void 0 && E.proposalId !== null && (U.proposalId = BigInt(E.proposalId.toString())), U.voter = E.voter ?? "", U.option = E.option ?? 0, U.metadata = E.metadata ?? "", U;
    }
  };
  function R() {
    return {};
  }
  e.MsgVoteResponse = {
    typeUrl: "/cosmos.gov.v1.MsgVoteResponse",
    encode(E, U = i.BinaryWriter.create()) {
      return U;
    },
    decode(E, U) {
      const V = E instanceof i.BinaryReader ? E : new i.BinaryReader(E);
      let o = U === void 0 ? V.len : V.pos + U;
      const h = R();
      for (; V.pos < o; ) {
        const N = V.uint32();
        switch (N >>> 3) {
          default:
            V.skipType(N & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(E) {
      return R();
    },
    toJSON(E) {
      return {};
    },
    fromPartial(E) {
      return R();
    }
  };
  function p() {
    return {
      proposalId: BigInt(0),
      voter: "",
      options: [],
      metadata: ""
    };
  }
  e.MsgVoteWeighted = {
    typeUrl: "/cosmos.gov.v1.MsgVoteWeighted",
    encode(E, U = i.BinaryWriter.create()) {
      E.proposalId !== BigInt(0) && U.uint32(8).uint64(E.proposalId), E.voter !== "" && U.uint32(18).string(E.voter);
      for (const V of E.options)
        t.WeightedVoteOption.encode(V, U.uint32(26).fork()).ldelim();
      return E.metadata !== "" && U.uint32(34).string(E.metadata), U;
    },
    decode(E, U) {
      const V = E instanceof i.BinaryReader ? E : new i.BinaryReader(E);
      let o = U === void 0 ? V.len : V.pos + U;
      const h = p();
      for (; V.pos < o; ) {
        const N = V.uint32();
        switch (N >>> 3) {
          case 1:
            h.proposalId = V.uint64();
            break;
          case 2:
            h.voter = V.string();
            break;
          case 3:
            h.options.push(t.WeightedVoteOption.decode(V, V.uint32()));
            break;
          case 4:
            h.metadata = V.string();
            break;
          default:
            V.skipType(N & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(E) {
      const U = p();
      return (0, f.isSet)(E.proposalId) && (U.proposalId = BigInt(E.proposalId.toString())), (0, f.isSet)(E.voter) && (U.voter = String(E.voter)), Array.isArray(E == null ? void 0 : E.options) && (U.options = E.options.map((V) => t.WeightedVoteOption.fromJSON(V))), (0, f.isSet)(E.metadata) && (U.metadata = String(E.metadata)), U;
    },
    toJSON(E) {
      const U = {};
      return E.proposalId !== void 0 && (U.proposalId = (E.proposalId || BigInt(0)).toString()), E.voter !== void 0 && (U.voter = E.voter), E.options ? U.options = E.options.map((V) => V ? t.WeightedVoteOption.toJSON(V) : void 0) : U.options = [], E.metadata !== void 0 && (U.metadata = E.metadata), U;
    },
    fromPartial(E) {
      var V;
      const U = p();
      return E.proposalId !== void 0 && E.proposalId !== null && (U.proposalId = BigInt(E.proposalId.toString())), U.voter = E.voter ?? "", U.options = ((V = E.options) == null ? void 0 : V.map((o) => t.WeightedVoteOption.fromPartial(o))) || [], U.metadata = E.metadata ?? "", U;
    }
  };
  function m() {
    return {};
  }
  e.MsgVoteWeightedResponse = {
    typeUrl: "/cosmos.gov.v1.MsgVoteWeightedResponse",
    encode(E, U = i.BinaryWriter.create()) {
      return U;
    },
    decode(E, U) {
      const V = E instanceof i.BinaryReader ? E : new i.BinaryReader(E);
      let o = U === void 0 ? V.len : V.pos + U;
      const h = m();
      for (; V.pos < o; ) {
        const N = V.uint32();
        switch (N >>> 3) {
          default:
            V.skipType(N & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(E) {
      return m();
    },
    toJSON(E) {
      return {};
    },
    fromPartial(E) {
      return m();
    }
  };
  function v() {
    return {
      proposalId: BigInt(0),
      depositor: "",
      amount: []
    };
  }
  e.MsgDeposit = {
    typeUrl: "/cosmos.gov.v1.MsgDeposit",
    encode(E, U = i.BinaryWriter.create()) {
      E.proposalId !== BigInt(0) && U.uint32(8).uint64(E.proposalId), E.depositor !== "" && U.uint32(18).string(E.depositor);
      for (const V of E.amount)
        r.Coin.encode(V, U.uint32(26).fork()).ldelim();
      return U;
    },
    decode(E, U) {
      const V = E instanceof i.BinaryReader ? E : new i.BinaryReader(E);
      let o = U === void 0 ? V.len : V.pos + U;
      const h = v();
      for (; V.pos < o; ) {
        const N = V.uint32();
        switch (N >>> 3) {
          case 1:
            h.proposalId = V.uint64();
            break;
          case 2:
            h.depositor = V.string();
            break;
          case 3:
            h.amount.push(r.Coin.decode(V, V.uint32()));
            break;
          default:
            V.skipType(N & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(E) {
      const U = v();
      return (0, f.isSet)(E.proposalId) && (U.proposalId = BigInt(E.proposalId.toString())), (0, f.isSet)(E.depositor) && (U.depositor = String(E.depositor)), Array.isArray(E == null ? void 0 : E.amount) && (U.amount = E.amount.map((V) => r.Coin.fromJSON(V))), U;
    },
    toJSON(E) {
      const U = {};
      return E.proposalId !== void 0 && (U.proposalId = (E.proposalId || BigInt(0)).toString()), E.depositor !== void 0 && (U.depositor = E.depositor), E.amount ? U.amount = E.amount.map((V) => V ? r.Coin.toJSON(V) : void 0) : U.amount = [], U;
    },
    fromPartial(E) {
      var V;
      const U = v();
      return E.proposalId !== void 0 && E.proposalId !== null && (U.proposalId = BigInt(E.proposalId.toString())), U.depositor = E.depositor ?? "", U.amount = ((V = E.amount) == null ? void 0 : V.map((o) => r.Coin.fromPartial(o))) || [], U;
    }
  };
  function a() {
    return {};
  }
  e.MsgDepositResponse = {
    typeUrl: "/cosmos.gov.v1.MsgDepositResponse",
    encode(E, U = i.BinaryWriter.create()) {
      return U;
    },
    decode(E, U) {
      const V = E instanceof i.BinaryReader ? E : new i.BinaryReader(E);
      let o = U === void 0 ? V.len : V.pos + U;
      const h = a();
      for (; V.pos < o; ) {
        const N = V.uint32();
        switch (N >>> 3) {
          default:
            V.skipType(N & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(E) {
      return a();
    },
    toJSON(E) {
      return {};
    },
    fromPartial(E) {
      return a();
    }
  };
  function d() {
    return {
      authority: "",
      params: t.Params.fromPartial({})
    };
  }
  e.MsgUpdateParams = {
    typeUrl: "/cosmos.gov.v1.MsgUpdateParams",
    encode(E, U = i.BinaryWriter.create()) {
      return E.authority !== "" && U.uint32(10).string(E.authority), E.params !== void 0 && t.Params.encode(E.params, U.uint32(18).fork()).ldelim(), U;
    },
    decode(E, U) {
      const V = E instanceof i.BinaryReader ? E : new i.BinaryReader(E);
      let o = U === void 0 ? V.len : V.pos + U;
      const h = d();
      for (; V.pos < o; ) {
        const N = V.uint32();
        switch (N >>> 3) {
          case 1:
            h.authority = V.string();
            break;
          case 2:
            h.params = t.Params.decode(V, V.uint32());
            break;
          default:
            V.skipType(N & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(E) {
      const U = d();
      return (0, f.isSet)(E.authority) && (U.authority = String(E.authority)), (0, f.isSet)(E.params) && (U.params = t.Params.fromJSON(E.params)), U;
    },
    toJSON(E) {
      const U = {};
      return E.authority !== void 0 && (U.authority = E.authority), E.params !== void 0 && (U.params = E.params ? t.Params.toJSON(E.params) : void 0), U;
    },
    fromPartial(E) {
      const U = d();
      return U.authority = E.authority ?? "", E.params !== void 0 && E.params !== null && (U.params = t.Params.fromPartial(E.params)), U;
    }
  };
  function y() {
    return {};
  }
  e.MsgUpdateParamsResponse = {
    typeUrl: "/cosmos.gov.v1.MsgUpdateParamsResponse",
    encode(E, U = i.BinaryWriter.create()) {
      return U;
    },
    decode(E, U) {
      const V = E instanceof i.BinaryReader ? E : new i.BinaryReader(E);
      let o = U === void 0 ? V.len : V.pos + U;
      const h = y();
      for (; V.pos < o; ) {
        const N = V.uint32();
        switch (N >>> 3) {
          default:
            V.skipType(N & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(E) {
      return y();
    },
    toJSON(E) {
      return {};
    },
    fromPartial(E) {
      return y();
    }
  };
  class _ {
    constructor(U) {
      this.rpc = U, this.SubmitProposal = this.SubmitProposal.bind(this), this.ExecLegacyContent = this.ExecLegacyContent.bind(this), this.Vote = this.Vote.bind(this), this.VoteWeighted = this.VoteWeighted.bind(this), this.Deposit = this.Deposit.bind(this), this.UpdateParams = this.UpdateParams.bind(this);
    }
    SubmitProposal(U) {
      const V = e.MsgSubmitProposal.encode(U).finish();
      return this.rpc.request("cosmos.gov.v1.Msg", "SubmitProposal", V).then((h) => e.MsgSubmitProposalResponse.decode(new i.BinaryReader(h)));
    }
    ExecLegacyContent(U) {
      const V = e.MsgExecLegacyContent.encode(U).finish();
      return this.rpc.request("cosmos.gov.v1.Msg", "ExecLegacyContent", V).then((h) => e.MsgExecLegacyContentResponse.decode(new i.BinaryReader(h)));
    }
    Vote(U) {
      const V = e.MsgVote.encode(U).finish();
      return this.rpc.request("cosmos.gov.v1.Msg", "Vote", V).then((h) => e.MsgVoteResponse.decode(new i.BinaryReader(h)));
    }
    VoteWeighted(U) {
      const V = e.MsgVoteWeighted.encode(U).finish();
      return this.rpc.request("cosmos.gov.v1.Msg", "VoteWeighted", V).then((h) => e.MsgVoteWeightedResponse.decode(new i.BinaryReader(h)));
    }
    Deposit(U) {
      const V = e.MsgDeposit.encode(U).finish();
      return this.rpc.request("cosmos.gov.v1.Msg", "Deposit", V).then((h) => e.MsgDepositResponse.decode(new i.BinaryReader(h)));
    }
    UpdateParams(U) {
      const V = e.MsgUpdateParams.encode(U).finish();
      return this.rpc.request("cosmos.gov.v1.Msg", "UpdateParams", V).then((h) => e.MsgUpdateParamsResponse.decode(new i.BinaryReader(h)));
    }
  }
  e.MsgClientImpl = _;
})(vh);
var Rh = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgDepositResponse = e.MsgDeposit = e.MsgVoteWeightedResponse = e.MsgVoteWeighted = e.MsgVoteResponse = e.MsgVote = e.MsgSubmitProposalResponse = e.MsgSubmitProposal = e.protobufPackage = void 0;
  const n = Pe, r = De, t = vs, i = re, f = ie;
  e.protobufPackage = "cosmos.gov.v1beta1";
  function S() {
    return {
      content: void 0,
      initialDeposit: [],
      proposer: ""
    };
  }
  e.MsgSubmitProposal = {
    typeUrl: "/cosmos.gov.v1beta1.MsgSubmitProposal",
    encode(a, d = i.BinaryWriter.create()) {
      a.content !== void 0 && n.Any.encode(a.content, d.uint32(10).fork()).ldelim();
      for (const y of a.initialDeposit)
        r.Coin.encode(y, d.uint32(18).fork()).ldelim();
      return a.proposer !== "" && d.uint32(26).string(a.proposer), d;
    },
    decode(a, d) {
      const y = a instanceof i.BinaryReader ? a : new i.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = S();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          case 1:
            E.content = n.Any.decode(y, y.uint32());
            break;
          case 2:
            E.initialDeposit.push(r.Coin.decode(y, y.uint32()));
            break;
          case 3:
            E.proposer = y.string();
            break;
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      const d = S();
      return (0, f.isSet)(a.content) && (d.content = n.Any.fromJSON(a.content)), Array.isArray(a == null ? void 0 : a.initialDeposit) && (d.initialDeposit = a.initialDeposit.map((y) => r.Coin.fromJSON(y))), (0, f.isSet)(a.proposer) && (d.proposer = String(a.proposer)), d;
    },
    toJSON(a) {
      const d = {};
      return a.content !== void 0 && (d.content = a.content ? n.Any.toJSON(a.content) : void 0), a.initialDeposit ? d.initialDeposit = a.initialDeposit.map((y) => y ? r.Coin.toJSON(y) : void 0) : d.initialDeposit = [], a.proposer !== void 0 && (d.proposer = a.proposer), d;
    },
    fromPartial(a) {
      var y;
      const d = S();
      return a.content !== void 0 && a.content !== null && (d.content = n.Any.fromPartial(a.content)), d.initialDeposit = ((y = a.initialDeposit) == null ? void 0 : y.map((_) => r.Coin.fromPartial(_))) || [], d.proposer = a.proposer ?? "", d;
    }
  };
  function w() {
    return {
      proposalId: BigInt(0)
    };
  }
  e.MsgSubmitProposalResponse = {
    typeUrl: "/cosmos.gov.v1beta1.MsgSubmitProposalResponse",
    encode(a, d = i.BinaryWriter.create()) {
      return a.proposalId !== BigInt(0) && d.uint32(8).uint64(a.proposalId), d;
    },
    decode(a, d) {
      const y = a instanceof i.BinaryReader ? a : new i.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = w();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          case 1:
            E.proposalId = y.uint64();
            break;
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      const d = w();
      return (0, f.isSet)(a.proposalId) && (d.proposalId = BigInt(a.proposalId.toString())), d;
    },
    toJSON(a) {
      const d = {};
      return a.proposalId !== void 0 && (d.proposalId = (a.proposalId || BigInt(0)).toString()), d;
    },
    fromPartial(a) {
      const d = w();
      return a.proposalId !== void 0 && a.proposalId !== null && (d.proposalId = BigInt(a.proposalId.toString())), d;
    }
  };
  function T() {
    return {
      proposalId: BigInt(0),
      voter: "",
      option: 0
    };
  }
  e.MsgVote = {
    typeUrl: "/cosmos.gov.v1beta1.MsgVote",
    encode(a, d = i.BinaryWriter.create()) {
      return a.proposalId !== BigInt(0) && d.uint32(8).uint64(a.proposalId), a.voter !== "" && d.uint32(18).string(a.voter), a.option !== 0 && d.uint32(24).int32(a.option), d;
    },
    decode(a, d) {
      const y = a instanceof i.BinaryReader ? a : new i.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = T();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          case 1:
            E.proposalId = y.uint64();
            break;
          case 2:
            E.voter = y.string();
            break;
          case 3:
            E.option = y.int32();
            break;
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      const d = T();
      return (0, f.isSet)(a.proposalId) && (d.proposalId = BigInt(a.proposalId.toString())), (0, f.isSet)(a.voter) && (d.voter = String(a.voter)), (0, f.isSet)(a.option) && (d.option = (0, t.voteOptionFromJSON)(a.option)), d;
    },
    toJSON(a) {
      const d = {};
      return a.proposalId !== void 0 && (d.proposalId = (a.proposalId || BigInt(0)).toString()), a.voter !== void 0 && (d.voter = a.voter), a.option !== void 0 && (d.option = (0, t.voteOptionToJSON)(a.option)), d;
    },
    fromPartial(a) {
      const d = T();
      return a.proposalId !== void 0 && a.proposalId !== null && (d.proposalId = BigInt(a.proposalId.toString())), d.voter = a.voter ?? "", d.option = a.option ?? 0, d;
    }
  };
  function J() {
    return {};
  }
  e.MsgVoteResponse = {
    typeUrl: "/cosmos.gov.v1beta1.MsgVoteResponse",
    encode(a, d = i.BinaryWriter.create()) {
      return d;
    },
    decode(a, d) {
      const y = a instanceof i.BinaryReader ? a : new i.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = J();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      return J();
    },
    toJSON(a) {
      return {};
    },
    fromPartial(a) {
      return J();
    }
  };
  function C() {
    return {
      proposalId: BigInt(0),
      voter: "",
      options: []
    };
  }
  e.MsgVoteWeighted = {
    typeUrl: "/cosmos.gov.v1beta1.MsgVoteWeighted",
    encode(a, d = i.BinaryWriter.create()) {
      a.proposalId !== BigInt(0) && d.uint32(8).uint64(a.proposalId), a.voter !== "" && d.uint32(18).string(a.voter);
      for (const y of a.options)
        t.WeightedVoteOption.encode(y, d.uint32(26).fork()).ldelim();
      return d;
    },
    decode(a, d) {
      const y = a instanceof i.BinaryReader ? a : new i.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = C();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          case 1:
            E.proposalId = y.uint64();
            break;
          case 2:
            E.voter = y.string();
            break;
          case 3:
            E.options.push(t.WeightedVoteOption.decode(y, y.uint32()));
            break;
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      const d = C();
      return (0, f.isSet)(a.proposalId) && (d.proposalId = BigInt(a.proposalId.toString())), (0, f.isSet)(a.voter) && (d.voter = String(a.voter)), Array.isArray(a == null ? void 0 : a.options) && (d.options = a.options.map((y) => t.WeightedVoteOption.fromJSON(y))), d;
    },
    toJSON(a) {
      const d = {};
      return a.proposalId !== void 0 && (d.proposalId = (a.proposalId || BigInt(0)).toString()), a.voter !== void 0 && (d.voter = a.voter), a.options ? d.options = a.options.map((y) => y ? t.WeightedVoteOption.toJSON(y) : void 0) : d.options = [], d;
    },
    fromPartial(a) {
      var y;
      const d = C();
      return a.proposalId !== void 0 && a.proposalId !== null && (d.proposalId = BigInt(a.proposalId.toString())), d.voter = a.voter ?? "", d.options = ((y = a.options) == null ? void 0 : y.map((_) => t.WeightedVoteOption.fromPartial(_))) || [], d;
    }
  };
  function R() {
    return {};
  }
  e.MsgVoteWeightedResponse = {
    typeUrl: "/cosmos.gov.v1beta1.MsgVoteWeightedResponse",
    encode(a, d = i.BinaryWriter.create()) {
      return d;
    },
    decode(a, d) {
      const y = a instanceof i.BinaryReader ? a : new i.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = R();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      return R();
    },
    toJSON(a) {
      return {};
    },
    fromPartial(a) {
      return R();
    }
  };
  function p() {
    return {
      proposalId: BigInt(0),
      depositor: "",
      amount: []
    };
  }
  e.MsgDeposit = {
    typeUrl: "/cosmos.gov.v1beta1.MsgDeposit",
    encode(a, d = i.BinaryWriter.create()) {
      a.proposalId !== BigInt(0) && d.uint32(8).uint64(a.proposalId), a.depositor !== "" && d.uint32(18).string(a.depositor);
      for (const y of a.amount)
        r.Coin.encode(y, d.uint32(26).fork()).ldelim();
      return d;
    },
    decode(a, d) {
      const y = a instanceof i.BinaryReader ? a : new i.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = p();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          case 1:
            E.proposalId = y.uint64();
            break;
          case 2:
            E.depositor = y.string();
            break;
          case 3:
            E.amount.push(r.Coin.decode(y, y.uint32()));
            break;
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      const d = p();
      return (0, f.isSet)(a.proposalId) && (d.proposalId = BigInt(a.proposalId.toString())), (0, f.isSet)(a.depositor) && (d.depositor = String(a.depositor)), Array.isArray(a == null ? void 0 : a.amount) && (d.amount = a.amount.map((y) => r.Coin.fromJSON(y))), d;
    },
    toJSON(a) {
      const d = {};
      return a.proposalId !== void 0 && (d.proposalId = (a.proposalId || BigInt(0)).toString()), a.depositor !== void 0 && (d.depositor = a.depositor), a.amount ? d.amount = a.amount.map((y) => y ? r.Coin.toJSON(y) : void 0) : d.amount = [], d;
    },
    fromPartial(a) {
      var y;
      const d = p();
      return a.proposalId !== void 0 && a.proposalId !== null && (d.proposalId = BigInt(a.proposalId.toString())), d.depositor = a.depositor ?? "", d.amount = ((y = a.amount) == null ? void 0 : y.map((_) => r.Coin.fromPartial(_))) || [], d;
    }
  };
  function m() {
    return {};
  }
  e.MsgDepositResponse = {
    typeUrl: "/cosmos.gov.v1beta1.MsgDepositResponse",
    encode(a, d = i.BinaryWriter.create()) {
      return d;
    },
    decode(a, d) {
      const y = a instanceof i.BinaryReader ? a : new i.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = m();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      return m();
    },
    toJSON(a) {
      return {};
    },
    fromPartial(a) {
      return m();
    }
  };
  class v {
    constructor(d) {
      this.rpc = d, this.SubmitProposal = this.SubmitProposal.bind(this), this.Vote = this.Vote.bind(this), this.VoteWeighted = this.VoteWeighted.bind(this), this.Deposit = this.Deposit.bind(this);
    }
    SubmitProposal(d) {
      const y = e.MsgSubmitProposal.encode(d).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Msg", "SubmitProposal", y).then((E) => e.MsgSubmitProposalResponse.decode(new i.BinaryReader(E)));
    }
    Vote(d) {
      const y = e.MsgVote.encode(d).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Msg", "Vote", y).then((E) => e.MsgVoteResponse.decode(new i.BinaryReader(E)));
    }
    VoteWeighted(d) {
      const y = e.MsgVoteWeighted.encode(d).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Msg", "VoteWeighted", y).then((E) => e.MsgVoteWeightedResponse.decode(new i.BinaryReader(E)));
    }
    Deposit(d) {
      const y = e.MsgDeposit.encode(d).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Msg", "Deposit", y).then((E) => e.MsgDepositResponse.decode(new i.BinaryReader(E)));
    }
  }
  e.MsgClientImpl = v;
})(Rh);
Object.defineProperty(Cn, "__esModule", { value: !0 });
Cn.isMsgVoteWeightedEncodeObject = Cn.isMsgVoteEncodeObject = Cn.isMsgSubmitProposalEncodeObject = Cn.isMsgDepositEncodeObject = Cn.govTypes = void 0;
const Zi = vh, zo = Rh;
Cn.govTypes = [
  ["/cosmos.gov.v1.MsgDeposit", Zi.MsgDeposit],
  ["/cosmos.gov.v1.MsgSubmitProposal", Zi.MsgSubmitProposal],
  ["/cosmos.gov.v1.MsgUpdateParams", Zi.MsgUpdateParams],
  ["/cosmos.gov.v1.MsgVote", Zi.MsgVote],
  ["/cosmos.gov.v1.MsgVoteWeighted", Zi.MsgVoteWeighted],
  ["/cosmos.gov.v1beta1.MsgDeposit", zo.MsgDeposit],
  ["/cosmos.gov.v1beta1.MsgSubmitProposal", zo.MsgSubmitProposal],
  ["/cosmos.gov.v1beta1.MsgVote", zo.MsgVote],
  ["/cosmos.gov.v1beta1.MsgVoteWeighted", zo.MsgVoteWeighted]
];
function Wb(e) {
  return e.typeUrl === "/cosmos.gov.v1beta1.MsgDeposit";
}
Cn.isMsgDepositEncodeObject = Wb;
function Qb(e) {
  return e.typeUrl === "/cosmos.gov.v1beta1.MsgSubmitProposal";
}
Cn.isMsgSubmitProposalEncodeObject = Qb;
function Fb(e) {
  return e.typeUrl === "/cosmos.gov.v1beta1.MsgVote";
}
Cn.isMsgVoteEncodeObject = Fb;
function $b(e) {
  return e.typeUrl === "/cosmos.gov.v1beta1.MsgVoteWeighted";
}
Cn.isMsgVoteWeightedEncodeObject = $b;
var bs = {}, Bh = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryTallyResultResponse = e.QueryTallyResultRequest = e.QueryDepositsResponse = e.QueryDepositsRequest = e.QueryDepositResponse = e.QueryDepositRequest = e.QueryParamsResponse = e.QueryParamsRequest = e.QueryVotesResponse = e.QueryVotesRequest = e.QueryVoteResponse = e.QueryVoteRequest = e.QueryProposalsResponse = e.QueryProposalsRequest = e.QueryProposalResponse = e.QueryProposalRequest = e.protobufPackage = void 0;
  const n = vs, r = Ae, t = re, i = ie;
  e.protobufPackage = "cosmos.gov.v1beta1";
  function f() {
    return {
      proposalId: BigInt(0)
    };
  }
  e.QueryProposalRequest = {
    typeUrl: "/cosmos.gov.v1beta1.QueryProposalRequest",
    encode(o, h = t.BinaryWriter.create()) {
      return o.proposalId !== BigInt(0) && h.uint32(8).uint64(o.proposalId), h;
    },
    decode(o, h) {
      const N = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = f();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.proposalId = N.uint64();
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = f();
      return (0, i.isSet)(o.proposalId) && (h.proposalId = BigInt(o.proposalId.toString())), h;
    },
    toJSON(o) {
      const h = {};
      return o.proposalId !== void 0 && (h.proposalId = (o.proposalId || BigInt(0)).toString()), h;
    },
    fromPartial(o) {
      const h = f();
      return o.proposalId !== void 0 && o.proposalId !== null && (h.proposalId = BigInt(o.proposalId.toString())), h;
    }
  };
  function S() {
    return {
      proposal: n.Proposal.fromPartial({})
    };
  }
  e.QueryProposalResponse = {
    typeUrl: "/cosmos.gov.v1beta1.QueryProposalResponse",
    encode(o, h = t.BinaryWriter.create()) {
      return o.proposal !== void 0 && n.Proposal.encode(o.proposal, h.uint32(10).fork()).ldelim(), h;
    },
    decode(o, h) {
      const N = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = S();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.proposal = n.Proposal.decode(N, N.uint32());
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = S();
      return (0, i.isSet)(o.proposal) && (h.proposal = n.Proposal.fromJSON(o.proposal)), h;
    },
    toJSON(o) {
      const h = {};
      return o.proposal !== void 0 && (h.proposal = o.proposal ? n.Proposal.toJSON(o.proposal) : void 0), h;
    },
    fromPartial(o) {
      const h = S();
      return o.proposal !== void 0 && o.proposal !== null && (h.proposal = n.Proposal.fromPartial(o.proposal)), h;
    }
  };
  function w() {
    return {
      proposalStatus: 0,
      voter: "",
      depositor: "",
      pagination: void 0
    };
  }
  e.QueryProposalsRequest = {
    typeUrl: "/cosmos.gov.v1beta1.QueryProposalsRequest",
    encode(o, h = t.BinaryWriter.create()) {
      return o.proposalStatus !== 0 && h.uint32(8).int32(o.proposalStatus), o.voter !== "" && h.uint32(18).string(o.voter), o.depositor !== "" && h.uint32(26).string(o.depositor), o.pagination !== void 0 && r.PageRequest.encode(o.pagination, h.uint32(34).fork()).ldelim(), h;
    },
    decode(o, h) {
      const N = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = w();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.proposalStatus = N.int32();
            break;
          case 2:
            u.voter = N.string();
            break;
          case 3:
            u.depositor = N.string();
            break;
          case 4:
            u.pagination = r.PageRequest.decode(N, N.uint32());
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = w();
      return (0, i.isSet)(o.proposalStatus) && (h.proposalStatus = (0, n.proposalStatusFromJSON)(o.proposalStatus)), (0, i.isSet)(o.voter) && (h.voter = String(o.voter)), (0, i.isSet)(o.depositor) && (h.depositor = String(o.depositor)), (0, i.isSet)(o.pagination) && (h.pagination = r.PageRequest.fromJSON(o.pagination)), h;
    },
    toJSON(o) {
      const h = {};
      return o.proposalStatus !== void 0 && (h.proposalStatus = (0, n.proposalStatusToJSON)(o.proposalStatus)), o.voter !== void 0 && (h.voter = o.voter), o.depositor !== void 0 && (h.depositor = o.depositor), o.pagination !== void 0 && (h.pagination = o.pagination ? r.PageRequest.toJSON(o.pagination) : void 0), h;
    },
    fromPartial(o) {
      const h = w();
      return h.proposalStatus = o.proposalStatus ?? 0, h.voter = o.voter ?? "", h.depositor = o.depositor ?? "", o.pagination !== void 0 && o.pagination !== null && (h.pagination = r.PageRequest.fromPartial(o.pagination)), h;
    }
  };
  function T() {
    return {
      proposals: [],
      pagination: void 0
    };
  }
  e.QueryProposalsResponse = {
    typeUrl: "/cosmos.gov.v1beta1.QueryProposalsResponse",
    encode(o, h = t.BinaryWriter.create()) {
      for (const N of o.proposals)
        n.Proposal.encode(N, h.uint32(10).fork()).ldelim();
      return o.pagination !== void 0 && r.PageResponse.encode(o.pagination, h.uint32(18).fork()).ldelim(), h;
    },
    decode(o, h) {
      const N = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = T();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.proposals.push(n.Proposal.decode(N, N.uint32()));
            break;
          case 2:
            u.pagination = r.PageResponse.decode(N, N.uint32());
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = T();
      return Array.isArray(o == null ? void 0 : o.proposals) && (h.proposals = o.proposals.map((N) => n.Proposal.fromJSON(N))), (0, i.isSet)(o.pagination) && (h.pagination = r.PageResponse.fromJSON(o.pagination)), h;
    },
    toJSON(o) {
      const h = {};
      return o.proposals ? h.proposals = o.proposals.map((N) => N ? n.Proposal.toJSON(N) : void 0) : h.proposals = [], o.pagination !== void 0 && (h.pagination = o.pagination ? r.PageResponse.toJSON(o.pagination) : void 0), h;
    },
    fromPartial(o) {
      var N;
      const h = T();
      return h.proposals = ((N = o.proposals) == null ? void 0 : N.map((q) => n.Proposal.fromPartial(q))) || [], o.pagination !== void 0 && o.pagination !== null && (h.pagination = r.PageResponse.fromPartial(o.pagination)), h;
    }
  };
  function J() {
    return {
      proposalId: BigInt(0),
      voter: ""
    };
  }
  e.QueryVoteRequest = {
    typeUrl: "/cosmos.gov.v1beta1.QueryVoteRequest",
    encode(o, h = t.BinaryWriter.create()) {
      return o.proposalId !== BigInt(0) && h.uint32(8).uint64(o.proposalId), o.voter !== "" && h.uint32(18).string(o.voter), h;
    },
    decode(o, h) {
      const N = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = J();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.proposalId = N.uint64();
            break;
          case 2:
            u.voter = N.string();
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = J();
      return (0, i.isSet)(o.proposalId) && (h.proposalId = BigInt(o.proposalId.toString())), (0, i.isSet)(o.voter) && (h.voter = String(o.voter)), h;
    },
    toJSON(o) {
      const h = {};
      return o.proposalId !== void 0 && (h.proposalId = (o.proposalId || BigInt(0)).toString()), o.voter !== void 0 && (h.voter = o.voter), h;
    },
    fromPartial(o) {
      const h = J();
      return o.proposalId !== void 0 && o.proposalId !== null && (h.proposalId = BigInt(o.proposalId.toString())), h.voter = o.voter ?? "", h;
    }
  };
  function C() {
    return {
      vote: n.Vote.fromPartial({})
    };
  }
  e.QueryVoteResponse = {
    typeUrl: "/cosmos.gov.v1beta1.QueryVoteResponse",
    encode(o, h = t.BinaryWriter.create()) {
      return o.vote !== void 0 && n.Vote.encode(o.vote, h.uint32(10).fork()).ldelim(), h;
    },
    decode(o, h) {
      const N = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = C();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.vote = n.Vote.decode(N, N.uint32());
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = C();
      return (0, i.isSet)(o.vote) && (h.vote = n.Vote.fromJSON(o.vote)), h;
    },
    toJSON(o) {
      const h = {};
      return o.vote !== void 0 && (h.vote = o.vote ? n.Vote.toJSON(o.vote) : void 0), h;
    },
    fromPartial(o) {
      const h = C();
      return o.vote !== void 0 && o.vote !== null && (h.vote = n.Vote.fromPartial(o.vote)), h;
    }
  };
  function R() {
    return {
      proposalId: BigInt(0),
      pagination: void 0
    };
  }
  e.QueryVotesRequest = {
    typeUrl: "/cosmos.gov.v1beta1.QueryVotesRequest",
    encode(o, h = t.BinaryWriter.create()) {
      return o.proposalId !== BigInt(0) && h.uint32(8).uint64(o.proposalId), o.pagination !== void 0 && r.PageRequest.encode(o.pagination, h.uint32(18).fork()).ldelim(), h;
    },
    decode(o, h) {
      const N = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = R();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.proposalId = N.uint64();
            break;
          case 2:
            u.pagination = r.PageRequest.decode(N, N.uint32());
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = R();
      return (0, i.isSet)(o.proposalId) && (h.proposalId = BigInt(o.proposalId.toString())), (0, i.isSet)(o.pagination) && (h.pagination = r.PageRequest.fromJSON(o.pagination)), h;
    },
    toJSON(o) {
      const h = {};
      return o.proposalId !== void 0 && (h.proposalId = (o.proposalId || BigInt(0)).toString()), o.pagination !== void 0 && (h.pagination = o.pagination ? r.PageRequest.toJSON(o.pagination) : void 0), h;
    },
    fromPartial(o) {
      const h = R();
      return o.proposalId !== void 0 && o.proposalId !== null && (h.proposalId = BigInt(o.proposalId.toString())), o.pagination !== void 0 && o.pagination !== null && (h.pagination = r.PageRequest.fromPartial(o.pagination)), h;
    }
  };
  function p() {
    return {
      votes: [],
      pagination: void 0
    };
  }
  e.QueryVotesResponse = {
    typeUrl: "/cosmos.gov.v1beta1.QueryVotesResponse",
    encode(o, h = t.BinaryWriter.create()) {
      for (const N of o.votes)
        n.Vote.encode(N, h.uint32(10).fork()).ldelim();
      return o.pagination !== void 0 && r.PageResponse.encode(o.pagination, h.uint32(18).fork()).ldelim(), h;
    },
    decode(o, h) {
      const N = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = p();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.votes.push(n.Vote.decode(N, N.uint32()));
            break;
          case 2:
            u.pagination = r.PageResponse.decode(N, N.uint32());
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = p();
      return Array.isArray(o == null ? void 0 : o.votes) && (h.votes = o.votes.map((N) => n.Vote.fromJSON(N))), (0, i.isSet)(o.pagination) && (h.pagination = r.PageResponse.fromJSON(o.pagination)), h;
    },
    toJSON(o) {
      const h = {};
      return o.votes ? h.votes = o.votes.map((N) => N ? n.Vote.toJSON(N) : void 0) : h.votes = [], o.pagination !== void 0 && (h.pagination = o.pagination ? r.PageResponse.toJSON(o.pagination) : void 0), h;
    },
    fromPartial(o) {
      var N;
      const h = p();
      return h.votes = ((N = o.votes) == null ? void 0 : N.map((q) => n.Vote.fromPartial(q))) || [], o.pagination !== void 0 && o.pagination !== null && (h.pagination = r.PageResponse.fromPartial(o.pagination)), h;
    }
  };
  function m() {
    return {
      paramsType: ""
    };
  }
  e.QueryParamsRequest = {
    typeUrl: "/cosmos.gov.v1beta1.QueryParamsRequest",
    encode(o, h = t.BinaryWriter.create()) {
      return o.paramsType !== "" && h.uint32(10).string(o.paramsType), h;
    },
    decode(o, h) {
      const N = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = m();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.paramsType = N.string();
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = m();
      return (0, i.isSet)(o.paramsType) && (h.paramsType = String(o.paramsType)), h;
    },
    toJSON(o) {
      const h = {};
      return o.paramsType !== void 0 && (h.paramsType = o.paramsType), h;
    },
    fromPartial(o) {
      const h = m();
      return h.paramsType = o.paramsType ?? "", h;
    }
  };
  function v() {
    return {
      votingParams: n.VotingParams.fromPartial({}),
      depositParams: n.DepositParams.fromPartial({}),
      tallyParams: n.TallyParams.fromPartial({})
    };
  }
  e.QueryParamsResponse = {
    typeUrl: "/cosmos.gov.v1beta1.QueryParamsResponse",
    encode(o, h = t.BinaryWriter.create()) {
      return o.votingParams !== void 0 && n.VotingParams.encode(o.votingParams, h.uint32(10).fork()).ldelim(), o.depositParams !== void 0 && n.DepositParams.encode(o.depositParams, h.uint32(18).fork()).ldelim(), o.tallyParams !== void 0 && n.TallyParams.encode(o.tallyParams, h.uint32(26).fork()).ldelim(), h;
    },
    decode(o, h) {
      const N = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = v();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.votingParams = n.VotingParams.decode(N, N.uint32());
            break;
          case 2:
            u.depositParams = n.DepositParams.decode(N, N.uint32());
            break;
          case 3:
            u.tallyParams = n.TallyParams.decode(N, N.uint32());
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = v();
      return (0, i.isSet)(o.votingParams) && (h.votingParams = n.VotingParams.fromJSON(o.votingParams)), (0, i.isSet)(o.depositParams) && (h.depositParams = n.DepositParams.fromJSON(o.depositParams)), (0, i.isSet)(o.tallyParams) && (h.tallyParams = n.TallyParams.fromJSON(o.tallyParams)), h;
    },
    toJSON(o) {
      const h = {};
      return o.votingParams !== void 0 && (h.votingParams = o.votingParams ? n.VotingParams.toJSON(o.votingParams) : void 0), o.depositParams !== void 0 && (h.depositParams = o.depositParams ? n.DepositParams.toJSON(o.depositParams) : void 0), o.tallyParams !== void 0 && (h.tallyParams = o.tallyParams ? n.TallyParams.toJSON(o.tallyParams) : void 0), h;
    },
    fromPartial(o) {
      const h = v();
      return o.votingParams !== void 0 && o.votingParams !== null && (h.votingParams = n.VotingParams.fromPartial(o.votingParams)), o.depositParams !== void 0 && o.depositParams !== null && (h.depositParams = n.DepositParams.fromPartial(o.depositParams)), o.tallyParams !== void 0 && o.tallyParams !== null && (h.tallyParams = n.TallyParams.fromPartial(o.tallyParams)), h;
    }
  };
  function a() {
    return {
      proposalId: BigInt(0),
      depositor: ""
    };
  }
  e.QueryDepositRequest = {
    typeUrl: "/cosmos.gov.v1beta1.QueryDepositRequest",
    encode(o, h = t.BinaryWriter.create()) {
      return o.proposalId !== BigInt(0) && h.uint32(8).uint64(o.proposalId), o.depositor !== "" && h.uint32(18).string(o.depositor), h;
    },
    decode(o, h) {
      const N = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = a();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.proposalId = N.uint64();
            break;
          case 2:
            u.depositor = N.string();
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = a();
      return (0, i.isSet)(o.proposalId) && (h.proposalId = BigInt(o.proposalId.toString())), (0, i.isSet)(o.depositor) && (h.depositor = String(o.depositor)), h;
    },
    toJSON(o) {
      const h = {};
      return o.proposalId !== void 0 && (h.proposalId = (o.proposalId || BigInt(0)).toString()), o.depositor !== void 0 && (h.depositor = o.depositor), h;
    },
    fromPartial(o) {
      const h = a();
      return o.proposalId !== void 0 && o.proposalId !== null && (h.proposalId = BigInt(o.proposalId.toString())), h.depositor = o.depositor ?? "", h;
    }
  };
  function d() {
    return {
      deposit: n.Deposit.fromPartial({})
    };
  }
  e.QueryDepositResponse = {
    typeUrl: "/cosmos.gov.v1beta1.QueryDepositResponse",
    encode(o, h = t.BinaryWriter.create()) {
      return o.deposit !== void 0 && n.Deposit.encode(o.deposit, h.uint32(10).fork()).ldelim(), h;
    },
    decode(o, h) {
      const N = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = d();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.deposit = n.Deposit.decode(N, N.uint32());
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = d();
      return (0, i.isSet)(o.deposit) && (h.deposit = n.Deposit.fromJSON(o.deposit)), h;
    },
    toJSON(o) {
      const h = {};
      return o.deposit !== void 0 && (h.deposit = o.deposit ? n.Deposit.toJSON(o.deposit) : void 0), h;
    },
    fromPartial(o) {
      const h = d();
      return o.deposit !== void 0 && o.deposit !== null && (h.deposit = n.Deposit.fromPartial(o.deposit)), h;
    }
  };
  function y() {
    return {
      proposalId: BigInt(0),
      pagination: void 0
    };
  }
  e.QueryDepositsRequest = {
    typeUrl: "/cosmos.gov.v1beta1.QueryDepositsRequest",
    encode(o, h = t.BinaryWriter.create()) {
      return o.proposalId !== BigInt(0) && h.uint32(8).uint64(o.proposalId), o.pagination !== void 0 && r.PageRequest.encode(o.pagination, h.uint32(18).fork()).ldelim(), h;
    },
    decode(o, h) {
      const N = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = y();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.proposalId = N.uint64();
            break;
          case 2:
            u.pagination = r.PageRequest.decode(N, N.uint32());
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = y();
      return (0, i.isSet)(o.proposalId) && (h.proposalId = BigInt(o.proposalId.toString())), (0, i.isSet)(o.pagination) && (h.pagination = r.PageRequest.fromJSON(o.pagination)), h;
    },
    toJSON(o) {
      const h = {};
      return o.proposalId !== void 0 && (h.proposalId = (o.proposalId || BigInt(0)).toString()), o.pagination !== void 0 && (h.pagination = o.pagination ? r.PageRequest.toJSON(o.pagination) : void 0), h;
    },
    fromPartial(o) {
      const h = y();
      return o.proposalId !== void 0 && o.proposalId !== null && (h.proposalId = BigInt(o.proposalId.toString())), o.pagination !== void 0 && o.pagination !== null && (h.pagination = r.PageRequest.fromPartial(o.pagination)), h;
    }
  };
  function _() {
    return {
      deposits: [],
      pagination: void 0
    };
  }
  e.QueryDepositsResponse = {
    typeUrl: "/cosmos.gov.v1beta1.QueryDepositsResponse",
    encode(o, h = t.BinaryWriter.create()) {
      for (const N of o.deposits)
        n.Deposit.encode(N, h.uint32(10).fork()).ldelim();
      return o.pagination !== void 0 && r.PageResponse.encode(o.pagination, h.uint32(18).fork()).ldelim(), h;
    },
    decode(o, h) {
      const N = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = _();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.deposits.push(n.Deposit.decode(N, N.uint32()));
            break;
          case 2:
            u.pagination = r.PageResponse.decode(N, N.uint32());
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = _();
      return Array.isArray(o == null ? void 0 : o.deposits) && (h.deposits = o.deposits.map((N) => n.Deposit.fromJSON(N))), (0, i.isSet)(o.pagination) && (h.pagination = r.PageResponse.fromJSON(o.pagination)), h;
    },
    toJSON(o) {
      const h = {};
      return o.deposits ? h.deposits = o.deposits.map((N) => N ? n.Deposit.toJSON(N) : void 0) : h.deposits = [], o.pagination !== void 0 && (h.pagination = o.pagination ? r.PageResponse.toJSON(o.pagination) : void 0), h;
    },
    fromPartial(o) {
      var N;
      const h = _();
      return h.deposits = ((N = o.deposits) == null ? void 0 : N.map((q) => n.Deposit.fromPartial(q))) || [], o.pagination !== void 0 && o.pagination !== null && (h.pagination = r.PageResponse.fromPartial(o.pagination)), h;
    }
  };
  function E() {
    return {
      proposalId: BigInt(0)
    };
  }
  e.QueryTallyResultRequest = {
    typeUrl: "/cosmos.gov.v1beta1.QueryTallyResultRequest",
    encode(o, h = t.BinaryWriter.create()) {
      return o.proposalId !== BigInt(0) && h.uint32(8).uint64(o.proposalId), h;
    },
    decode(o, h) {
      const N = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = E();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.proposalId = N.uint64();
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = E();
      return (0, i.isSet)(o.proposalId) && (h.proposalId = BigInt(o.proposalId.toString())), h;
    },
    toJSON(o) {
      const h = {};
      return o.proposalId !== void 0 && (h.proposalId = (o.proposalId || BigInt(0)).toString()), h;
    },
    fromPartial(o) {
      const h = E();
      return o.proposalId !== void 0 && o.proposalId !== null && (h.proposalId = BigInt(o.proposalId.toString())), h;
    }
  };
  function U() {
    return {
      tally: n.TallyResult.fromPartial({})
    };
  }
  e.QueryTallyResultResponse = {
    typeUrl: "/cosmos.gov.v1beta1.QueryTallyResultResponse",
    encode(o, h = t.BinaryWriter.create()) {
      return o.tally !== void 0 && n.TallyResult.encode(o.tally, h.uint32(10).fork()).ldelim(), h;
    },
    decode(o, h) {
      const N = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = U();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.tally = n.TallyResult.decode(N, N.uint32());
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = U();
      return (0, i.isSet)(o.tally) && (h.tally = n.TallyResult.fromJSON(o.tally)), h;
    },
    toJSON(o) {
      const h = {};
      return o.tally !== void 0 && (h.tally = o.tally ? n.TallyResult.toJSON(o.tally) : void 0), h;
    },
    fromPartial(o) {
      const h = U();
      return o.tally !== void 0 && o.tally !== null && (h.tally = n.TallyResult.fromPartial(o.tally)), h;
    }
  };
  class V {
    constructor(h) {
      this.rpc = h, this.Proposal = this.Proposal.bind(this), this.Proposals = this.Proposals.bind(this), this.Vote = this.Vote.bind(this), this.Votes = this.Votes.bind(this), this.Params = this.Params.bind(this), this.Deposit = this.Deposit.bind(this), this.Deposits = this.Deposits.bind(this), this.TallyResult = this.TallyResult.bind(this);
    }
    Proposal(h) {
      const N = e.QueryProposalRequest.encode(h).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "Proposal", N).then((u) => e.QueryProposalResponse.decode(new t.BinaryReader(u)));
    }
    Proposals(h) {
      const N = e.QueryProposalsRequest.encode(h).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "Proposals", N).then((u) => e.QueryProposalsResponse.decode(new t.BinaryReader(u)));
    }
    Vote(h) {
      const N = e.QueryVoteRequest.encode(h).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "Vote", N).then((u) => e.QueryVoteResponse.decode(new t.BinaryReader(u)));
    }
    Votes(h) {
      const N = e.QueryVotesRequest.encode(h).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "Votes", N).then((u) => e.QueryVotesResponse.decode(new t.BinaryReader(u)));
    }
    Params(h) {
      const N = e.QueryParamsRequest.encode(h).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "Params", N).then((u) => e.QueryParamsResponse.decode(new t.BinaryReader(u)));
    }
    Deposit(h) {
      const N = e.QueryDepositRequest.encode(h).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "Deposit", N).then((u) => e.QueryDepositResponse.decode(new t.BinaryReader(u)));
    }
    Deposits(h) {
      const N = e.QueryDepositsRequest.encode(h).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "Deposits", N).then((u) => e.QueryDepositsResponse.decode(new t.BinaryReader(u)));
    }
    TallyResult(h) {
      const N = e.QueryTallyResultRequest.encode(h).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "TallyResult", N).then((u) => e.QueryTallyResultResponse.decode(new t.BinaryReader(u)));
    }
  }
  e.QueryClientImpl = V;
})(Bh);
Object.defineProperty(bs, "__esModule", { value: !0 });
bs.setupGovExtension = void 0;
const Lb = Bh, zn = Ye;
function Gb(e) {
  const n = (0, zn.createProtobufRpcClient)(e), r = new Lb.QueryClientImpl(n);
  return {
    gov: {
      params: async (t) => await r.Params({ paramsType: t }),
      proposals: async (t, i, f, S) => await r.Proposals({
        proposalStatus: t,
        depositor: i,
        voter: f,
        pagination: (0, zn.createPagination)(S)
      }),
      proposal: async (t) => await r.Proposal({ proposalId: (0, zn.longify)(t) }),
      deposits: async (t, i) => await r.Deposits({
        proposalId: (0, zn.longify)(t),
        pagination: (0, zn.createPagination)(i)
      }),
      deposit: async (t, i) => await r.Deposit({
        proposalId: (0, zn.longify)(t),
        depositor: i
      }),
      tally: async (t) => await r.TallyResult({
        proposalId: (0, zn.longify)(t)
      }),
      votes: async (t, i) => await r.Votes({
        proposalId: (0, zn.longify)(t),
        pagination: (0, zn.createPagination)(i)
      }),
      vote: async (t, i) => await r.Vote({
        proposalId: (0, zn.longify)(t),
        voter: i
      })
    }
  };
}
bs.setupGovExtension = Gb;
var Rs = {};
Object.defineProperty(Rs, "__esModule", { value: !0 });
Rs.createGroupAminoConverters = void 0;
function Kb() {
  return {};
}
Rs.createGroupAminoConverters = Kb;
var Bs = {}, Oh = {}, Ah = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Vote = e.TallyResult = e.Proposal = e.GroupPolicyInfo = e.GroupMember = e.GroupInfo = e.DecisionPolicyWindows = e.PercentageDecisionPolicy = e.ThresholdDecisionPolicy = e.MemberRequest = e.Member = e.proposalExecutorResultToJSON = e.proposalExecutorResultFromJSON = e.ProposalExecutorResult = e.proposalStatusToJSON = e.proposalStatusFromJSON = e.ProposalStatus = e.voteOptionToJSON = e.voteOptionFromJSON = e.VoteOption = e.protobufPackage = void 0;
  const n = Je, r = vn, t = Pe, i = re, f = ie;
  e.protobufPackage = "cosmos.group.v1";
  var S;
  (function(u) {
    u[u.VOTE_OPTION_UNSPECIFIED = 0] = "VOTE_OPTION_UNSPECIFIED", u[u.VOTE_OPTION_YES = 1] = "VOTE_OPTION_YES", u[u.VOTE_OPTION_ABSTAIN = 2] = "VOTE_OPTION_ABSTAIN", u[u.VOTE_OPTION_NO = 3] = "VOTE_OPTION_NO", u[u.VOTE_OPTION_NO_WITH_VETO = 4] = "VOTE_OPTION_NO_WITH_VETO", u[u.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(S || (e.VoteOption = S = {}));
  function w(u) {
    switch (u) {
      case 0:
      case "VOTE_OPTION_UNSPECIFIED":
        return S.VOTE_OPTION_UNSPECIFIED;
      case 1:
      case "VOTE_OPTION_YES":
        return S.VOTE_OPTION_YES;
      case 2:
      case "VOTE_OPTION_ABSTAIN":
        return S.VOTE_OPTION_ABSTAIN;
      case 3:
      case "VOTE_OPTION_NO":
        return S.VOTE_OPTION_NO;
      case 4:
      case "VOTE_OPTION_NO_WITH_VETO":
        return S.VOTE_OPTION_NO_WITH_VETO;
      case -1:
      case "UNRECOGNIZED":
      default:
        return S.UNRECOGNIZED;
    }
  }
  e.voteOptionFromJSON = w;
  function T(u) {
    switch (u) {
      case S.VOTE_OPTION_UNSPECIFIED:
        return "VOTE_OPTION_UNSPECIFIED";
      case S.VOTE_OPTION_YES:
        return "VOTE_OPTION_YES";
      case S.VOTE_OPTION_ABSTAIN:
        return "VOTE_OPTION_ABSTAIN";
      case S.VOTE_OPTION_NO:
        return "VOTE_OPTION_NO";
      case S.VOTE_OPTION_NO_WITH_VETO:
        return "VOTE_OPTION_NO_WITH_VETO";
      case S.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.voteOptionToJSON = T;
  var J;
  (function(u) {
    u[u.PROPOSAL_STATUS_UNSPECIFIED = 0] = "PROPOSAL_STATUS_UNSPECIFIED", u[u.PROPOSAL_STATUS_SUBMITTED = 1] = "PROPOSAL_STATUS_SUBMITTED", u[u.PROPOSAL_STATUS_ACCEPTED = 2] = "PROPOSAL_STATUS_ACCEPTED", u[u.PROPOSAL_STATUS_REJECTED = 3] = "PROPOSAL_STATUS_REJECTED", u[u.PROPOSAL_STATUS_ABORTED = 4] = "PROPOSAL_STATUS_ABORTED", u[u.PROPOSAL_STATUS_WITHDRAWN = 5] = "PROPOSAL_STATUS_WITHDRAWN", u[u.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(J || (e.ProposalStatus = J = {}));
  function C(u) {
    switch (u) {
      case 0:
      case "PROPOSAL_STATUS_UNSPECIFIED":
        return J.PROPOSAL_STATUS_UNSPECIFIED;
      case 1:
      case "PROPOSAL_STATUS_SUBMITTED":
        return J.PROPOSAL_STATUS_SUBMITTED;
      case 2:
      case "PROPOSAL_STATUS_ACCEPTED":
        return J.PROPOSAL_STATUS_ACCEPTED;
      case 3:
      case "PROPOSAL_STATUS_REJECTED":
        return J.PROPOSAL_STATUS_REJECTED;
      case 4:
      case "PROPOSAL_STATUS_ABORTED":
        return J.PROPOSAL_STATUS_ABORTED;
      case 5:
      case "PROPOSAL_STATUS_WITHDRAWN":
        return J.PROPOSAL_STATUS_WITHDRAWN;
      case -1:
      case "UNRECOGNIZED":
      default:
        return J.UNRECOGNIZED;
    }
  }
  e.proposalStatusFromJSON = C;
  function R(u) {
    switch (u) {
      case J.PROPOSAL_STATUS_UNSPECIFIED:
        return "PROPOSAL_STATUS_UNSPECIFIED";
      case J.PROPOSAL_STATUS_SUBMITTED:
        return "PROPOSAL_STATUS_SUBMITTED";
      case J.PROPOSAL_STATUS_ACCEPTED:
        return "PROPOSAL_STATUS_ACCEPTED";
      case J.PROPOSAL_STATUS_REJECTED:
        return "PROPOSAL_STATUS_REJECTED";
      case J.PROPOSAL_STATUS_ABORTED:
        return "PROPOSAL_STATUS_ABORTED";
      case J.PROPOSAL_STATUS_WITHDRAWN:
        return "PROPOSAL_STATUS_WITHDRAWN";
      case J.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.proposalStatusToJSON = R;
  var p;
  (function(u) {
    u[u.PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED = 0] = "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED", u[u.PROPOSAL_EXECUTOR_RESULT_NOT_RUN = 1] = "PROPOSAL_EXECUTOR_RESULT_NOT_RUN", u[u.PROPOSAL_EXECUTOR_RESULT_SUCCESS = 2] = "PROPOSAL_EXECUTOR_RESULT_SUCCESS", u[u.PROPOSAL_EXECUTOR_RESULT_FAILURE = 3] = "PROPOSAL_EXECUTOR_RESULT_FAILURE", u[u.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(p || (e.ProposalExecutorResult = p = {}));
  function m(u) {
    switch (u) {
      case 0:
      case "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED":
        return p.PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED;
      case 1:
      case "PROPOSAL_EXECUTOR_RESULT_NOT_RUN":
        return p.PROPOSAL_EXECUTOR_RESULT_NOT_RUN;
      case 2:
      case "PROPOSAL_EXECUTOR_RESULT_SUCCESS":
        return p.PROPOSAL_EXECUTOR_RESULT_SUCCESS;
      case 3:
      case "PROPOSAL_EXECUTOR_RESULT_FAILURE":
        return p.PROPOSAL_EXECUTOR_RESULT_FAILURE;
      case -1:
      case "UNRECOGNIZED":
      default:
        return p.UNRECOGNIZED;
    }
  }
  e.proposalExecutorResultFromJSON = m;
  function v(u) {
    switch (u) {
      case p.PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED:
        return "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED";
      case p.PROPOSAL_EXECUTOR_RESULT_NOT_RUN:
        return "PROPOSAL_EXECUTOR_RESULT_NOT_RUN";
      case p.PROPOSAL_EXECUTOR_RESULT_SUCCESS:
        return "PROPOSAL_EXECUTOR_RESULT_SUCCESS";
      case p.PROPOSAL_EXECUTOR_RESULT_FAILURE:
        return "PROPOSAL_EXECUTOR_RESULT_FAILURE";
      case p.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.proposalExecutorResultToJSON = v;
  function a() {
    return {
      address: "",
      weight: "",
      metadata: "",
      addedAt: n.Timestamp.fromPartial({})
    };
  }
  e.Member = {
    typeUrl: "/cosmos.group.v1.Member",
    encode(u, l = i.BinaryWriter.create()) {
      return u.address !== "" && l.uint32(10).string(u.address), u.weight !== "" && l.uint32(18).string(u.weight), u.metadata !== "" && l.uint32(26).string(u.metadata), u.addedAt !== void 0 && n.Timestamp.encode(u.addedAt, l.uint32(34).fork()).ldelim(), l;
    },
    decode(u, l) {
      const I = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let B = l === void 0 ? I.len : I.pos + l;
      const b = a();
      for (; I.pos < B; ) {
        const D = I.uint32();
        switch (D >>> 3) {
          case 1:
            b.address = I.string();
            break;
          case 2:
            b.weight = I.string();
            break;
          case 3:
            b.metadata = I.string();
            break;
          case 4:
            b.addedAt = n.Timestamp.decode(I, I.uint32());
            break;
          default:
            I.skipType(D & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(u) {
      const l = a();
      return (0, f.isSet)(u.address) && (l.address = String(u.address)), (0, f.isSet)(u.weight) && (l.weight = String(u.weight)), (0, f.isSet)(u.metadata) && (l.metadata = String(u.metadata)), (0, f.isSet)(u.addedAt) && (l.addedAt = (0, f.fromJsonTimestamp)(u.addedAt)), l;
    },
    toJSON(u) {
      const l = {};
      return u.address !== void 0 && (l.address = u.address), u.weight !== void 0 && (l.weight = u.weight), u.metadata !== void 0 && (l.metadata = u.metadata), u.addedAt !== void 0 && (l.addedAt = (0, f.fromTimestamp)(u.addedAt).toISOString()), l;
    },
    fromPartial(u) {
      const l = a();
      return l.address = u.address ?? "", l.weight = u.weight ?? "", l.metadata = u.metadata ?? "", u.addedAt !== void 0 && u.addedAt !== null && (l.addedAt = n.Timestamp.fromPartial(u.addedAt)), l;
    }
  };
  function d() {
    return {
      address: "",
      weight: "",
      metadata: ""
    };
  }
  e.MemberRequest = {
    typeUrl: "/cosmos.group.v1.MemberRequest",
    encode(u, l = i.BinaryWriter.create()) {
      return u.address !== "" && l.uint32(10).string(u.address), u.weight !== "" && l.uint32(18).string(u.weight), u.metadata !== "" && l.uint32(26).string(u.metadata), l;
    },
    decode(u, l) {
      const I = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let B = l === void 0 ? I.len : I.pos + l;
      const b = d();
      for (; I.pos < B; ) {
        const D = I.uint32();
        switch (D >>> 3) {
          case 1:
            b.address = I.string();
            break;
          case 2:
            b.weight = I.string();
            break;
          case 3:
            b.metadata = I.string();
            break;
          default:
            I.skipType(D & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(u) {
      const l = d();
      return (0, f.isSet)(u.address) && (l.address = String(u.address)), (0, f.isSet)(u.weight) && (l.weight = String(u.weight)), (0, f.isSet)(u.metadata) && (l.metadata = String(u.metadata)), l;
    },
    toJSON(u) {
      const l = {};
      return u.address !== void 0 && (l.address = u.address), u.weight !== void 0 && (l.weight = u.weight), u.metadata !== void 0 && (l.metadata = u.metadata), l;
    },
    fromPartial(u) {
      const l = d();
      return l.address = u.address ?? "", l.weight = u.weight ?? "", l.metadata = u.metadata ?? "", l;
    }
  };
  function y() {
    return {
      threshold: "",
      windows: void 0
    };
  }
  e.ThresholdDecisionPolicy = {
    typeUrl: "/cosmos.group.v1.ThresholdDecisionPolicy",
    encode(u, l = i.BinaryWriter.create()) {
      return u.threshold !== "" && l.uint32(10).string(u.threshold), u.windows !== void 0 && e.DecisionPolicyWindows.encode(u.windows, l.uint32(18).fork()).ldelim(), l;
    },
    decode(u, l) {
      const I = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let B = l === void 0 ? I.len : I.pos + l;
      const b = y();
      for (; I.pos < B; ) {
        const D = I.uint32();
        switch (D >>> 3) {
          case 1:
            b.threshold = I.string();
            break;
          case 2:
            b.windows = e.DecisionPolicyWindows.decode(I, I.uint32());
            break;
          default:
            I.skipType(D & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(u) {
      const l = y();
      return (0, f.isSet)(u.threshold) && (l.threshold = String(u.threshold)), (0, f.isSet)(u.windows) && (l.windows = e.DecisionPolicyWindows.fromJSON(u.windows)), l;
    },
    toJSON(u) {
      const l = {};
      return u.threshold !== void 0 && (l.threshold = u.threshold), u.windows !== void 0 && (l.windows = u.windows ? e.DecisionPolicyWindows.toJSON(u.windows) : void 0), l;
    },
    fromPartial(u) {
      const l = y();
      return l.threshold = u.threshold ?? "", u.windows !== void 0 && u.windows !== null && (l.windows = e.DecisionPolicyWindows.fromPartial(u.windows)), l;
    }
  };
  function _() {
    return {
      percentage: "",
      windows: void 0
    };
  }
  e.PercentageDecisionPolicy = {
    typeUrl: "/cosmos.group.v1.PercentageDecisionPolicy",
    encode(u, l = i.BinaryWriter.create()) {
      return u.percentage !== "" && l.uint32(10).string(u.percentage), u.windows !== void 0 && e.DecisionPolicyWindows.encode(u.windows, l.uint32(18).fork()).ldelim(), l;
    },
    decode(u, l) {
      const I = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let B = l === void 0 ? I.len : I.pos + l;
      const b = _();
      for (; I.pos < B; ) {
        const D = I.uint32();
        switch (D >>> 3) {
          case 1:
            b.percentage = I.string();
            break;
          case 2:
            b.windows = e.DecisionPolicyWindows.decode(I, I.uint32());
            break;
          default:
            I.skipType(D & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(u) {
      const l = _();
      return (0, f.isSet)(u.percentage) && (l.percentage = String(u.percentage)), (0, f.isSet)(u.windows) && (l.windows = e.DecisionPolicyWindows.fromJSON(u.windows)), l;
    },
    toJSON(u) {
      const l = {};
      return u.percentage !== void 0 && (l.percentage = u.percentage), u.windows !== void 0 && (l.windows = u.windows ? e.DecisionPolicyWindows.toJSON(u.windows) : void 0), l;
    },
    fromPartial(u) {
      const l = _();
      return l.percentage = u.percentage ?? "", u.windows !== void 0 && u.windows !== null && (l.windows = e.DecisionPolicyWindows.fromPartial(u.windows)), l;
    }
  };
  function E() {
    return {
      votingPeriod: r.Duration.fromPartial({}),
      minExecutionPeriod: r.Duration.fromPartial({})
    };
  }
  e.DecisionPolicyWindows = {
    typeUrl: "/cosmos.group.v1.DecisionPolicyWindows",
    encode(u, l = i.BinaryWriter.create()) {
      return u.votingPeriod !== void 0 && r.Duration.encode(u.votingPeriod, l.uint32(10).fork()).ldelim(), u.minExecutionPeriod !== void 0 && r.Duration.encode(u.minExecutionPeriod, l.uint32(18).fork()).ldelim(), l;
    },
    decode(u, l) {
      const I = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let B = l === void 0 ? I.len : I.pos + l;
      const b = E();
      for (; I.pos < B; ) {
        const D = I.uint32();
        switch (D >>> 3) {
          case 1:
            b.votingPeriod = r.Duration.decode(I, I.uint32());
            break;
          case 2:
            b.minExecutionPeriod = r.Duration.decode(I, I.uint32());
            break;
          default:
            I.skipType(D & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(u) {
      const l = E();
      return (0, f.isSet)(u.votingPeriod) && (l.votingPeriod = r.Duration.fromJSON(u.votingPeriod)), (0, f.isSet)(u.minExecutionPeriod) && (l.minExecutionPeriod = r.Duration.fromJSON(u.minExecutionPeriod)), l;
    },
    toJSON(u) {
      const l = {};
      return u.votingPeriod !== void 0 && (l.votingPeriod = u.votingPeriod ? r.Duration.toJSON(u.votingPeriod) : void 0), u.minExecutionPeriod !== void 0 && (l.minExecutionPeriod = u.minExecutionPeriod ? r.Duration.toJSON(u.minExecutionPeriod) : void 0), l;
    },
    fromPartial(u) {
      const l = E();
      return u.votingPeriod !== void 0 && u.votingPeriod !== null && (l.votingPeriod = r.Duration.fromPartial(u.votingPeriod)), u.minExecutionPeriod !== void 0 && u.minExecutionPeriod !== null && (l.minExecutionPeriod = r.Duration.fromPartial(u.minExecutionPeriod)), l;
    }
  };
  function U() {
    return {
      id: BigInt(0),
      admin: "",
      metadata: "",
      version: BigInt(0),
      totalWeight: "",
      createdAt: n.Timestamp.fromPartial({})
    };
  }
  e.GroupInfo = {
    typeUrl: "/cosmos.group.v1.GroupInfo",
    encode(u, l = i.BinaryWriter.create()) {
      return u.id !== BigInt(0) && l.uint32(8).uint64(u.id), u.admin !== "" && l.uint32(18).string(u.admin), u.metadata !== "" && l.uint32(26).string(u.metadata), u.version !== BigInt(0) && l.uint32(32).uint64(u.version), u.totalWeight !== "" && l.uint32(42).string(u.totalWeight), u.createdAt !== void 0 && n.Timestamp.encode(u.createdAt, l.uint32(50).fork()).ldelim(), l;
    },
    decode(u, l) {
      const I = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let B = l === void 0 ? I.len : I.pos + l;
      const b = U();
      for (; I.pos < B; ) {
        const D = I.uint32();
        switch (D >>> 3) {
          case 1:
            b.id = I.uint64();
            break;
          case 2:
            b.admin = I.string();
            break;
          case 3:
            b.metadata = I.string();
            break;
          case 4:
            b.version = I.uint64();
            break;
          case 5:
            b.totalWeight = I.string();
            break;
          case 6:
            b.createdAt = n.Timestamp.decode(I, I.uint32());
            break;
          default:
            I.skipType(D & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(u) {
      const l = U();
      return (0, f.isSet)(u.id) && (l.id = BigInt(u.id.toString())), (0, f.isSet)(u.admin) && (l.admin = String(u.admin)), (0, f.isSet)(u.metadata) && (l.metadata = String(u.metadata)), (0, f.isSet)(u.version) && (l.version = BigInt(u.version.toString())), (0, f.isSet)(u.totalWeight) && (l.totalWeight = String(u.totalWeight)), (0, f.isSet)(u.createdAt) && (l.createdAt = (0, f.fromJsonTimestamp)(u.createdAt)), l;
    },
    toJSON(u) {
      const l = {};
      return u.id !== void 0 && (l.id = (u.id || BigInt(0)).toString()), u.admin !== void 0 && (l.admin = u.admin), u.metadata !== void 0 && (l.metadata = u.metadata), u.version !== void 0 && (l.version = (u.version || BigInt(0)).toString()), u.totalWeight !== void 0 && (l.totalWeight = u.totalWeight), u.createdAt !== void 0 && (l.createdAt = (0, f.fromTimestamp)(u.createdAt).toISOString()), l;
    },
    fromPartial(u) {
      const l = U();
      return u.id !== void 0 && u.id !== null && (l.id = BigInt(u.id.toString())), l.admin = u.admin ?? "", l.metadata = u.metadata ?? "", u.version !== void 0 && u.version !== null && (l.version = BigInt(u.version.toString())), l.totalWeight = u.totalWeight ?? "", u.createdAt !== void 0 && u.createdAt !== null && (l.createdAt = n.Timestamp.fromPartial(u.createdAt)), l;
    }
  };
  function V() {
    return {
      groupId: BigInt(0),
      member: void 0
    };
  }
  e.GroupMember = {
    typeUrl: "/cosmos.group.v1.GroupMember",
    encode(u, l = i.BinaryWriter.create()) {
      return u.groupId !== BigInt(0) && l.uint32(8).uint64(u.groupId), u.member !== void 0 && e.Member.encode(u.member, l.uint32(18).fork()).ldelim(), l;
    },
    decode(u, l) {
      const I = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let B = l === void 0 ? I.len : I.pos + l;
      const b = V();
      for (; I.pos < B; ) {
        const D = I.uint32();
        switch (D >>> 3) {
          case 1:
            b.groupId = I.uint64();
            break;
          case 2:
            b.member = e.Member.decode(I, I.uint32());
            break;
          default:
            I.skipType(D & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(u) {
      const l = V();
      return (0, f.isSet)(u.groupId) && (l.groupId = BigInt(u.groupId.toString())), (0, f.isSet)(u.member) && (l.member = e.Member.fromJSON(u.member)), l;
    },
    toJSON(u) {
      const l = {};
      return u.groupId !== void 0 && (l.groupId = (u.groupId || BigInt(0)).toString()), u.member !== void 0 && (l.member = u.member ? e.Member.toJSON(u.member) : void 0), l;
    },
    fromPartial(u) {
      const l = V();
      return u.groupId !== void 0 && u.groupId !== null && (l.groupId = BigInt(u.groupId.toString())), u.member !== void 0 && u.member !== null && (l.member = e.Member.fromPartial(u.member)), l;
    }
  };
  function o() {
    return {
      address: "",
      groupId: BigInt(0),
      admin: "",
      metadata: "",
      version: BigInt(0),
      decisionPolicy: void 0,
      createdAt: n.Timestamp.fromPartial({})
    };
  }
  e.GroupPolicyInfo = {
    typeUrl: "/cosmos.group.v1.GroupPolicyInfo",
    encode(u, l = i.BinaryWriter.create()) {
      return u.address !== "" && l.uint32(10).string(u.address), u.groupId !== BigInt(0) && l.uint32(16).uint64(u.groupId), u.admin !== "" && l.uint32(26).string(u.admin), u.metadata !== "" && l.uint32(34).string(u.metadata), u.version !== BigInt(0) && l.uint32(40).uint64(u.version), u.decisionPolicy !== void 0 && t.Any.encode(u.decisionPolicy, l.uint32(50).fork()).ldelim(), u.createdAt !== void 0 && n.Timestamp.encode(u.createdAt, l.uint32(58).fork()).ldelim(), l;
    },
    decode(u, l) {
      const I = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let B = l === void 0 ? I.len : I.pos + l;
      const b = o();
      for (; I.pos < B; ) {
        const D = I.uint32();
        switch (D >>> 3) {
          case 1:
            b.address = I.string();
            break;
          case 2:
            b.groupId = I.uint64();
            break;
          case 3:
            b.admin = I.string();
            break;
          case 4:
            b.metadata = I.string();
            break;
          case 5:
            b.version = I.uint64();
            break;
          case 6:
            b.decisionPolicy = t.Any.decode(I, I.uint32());
            break;
          case 7:
            b.createdAt = n.Timestamp.decode(I, I.uint32());
            break;
          default:
            I.skipType(D & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(u) {
      const l = o();
      return (0, f.isSet)(u.address) && (l.address = String(u.address)), (0, f.isSet)(u.groupId) && (l.groupId = BigInt(u.groupId.toString())), (0, f.isSet)(u.admin) && (l.admin = String(u.admin)), (0, f.isSet)(u.metadata) && (l.metadata = String(u.metadata)), (0, f.isSet)(u.version) && (l.version = BigInt(u.version.toString())), (0, f.isSet)(u.decisionPolicy) && (l.decisionPolicy = t.Any.fromJSON(u.decisionPolicy)), (0, f.isSet)(u.createdAt) && (l.createdAt = (0, f.fromJsonTimestamp)(u.createdAt)), l;
    },
    toJSON(u) {
      const l = {};
      return u.address !== void 0 && (l.address = u.address), u.groupId !== void 0 && (l.groupId = (u.groupId || BigInt(0)).toString()), u.admin !== void 0 && (l.admin = u.admin), u.metadata !== void 0 && (l.metadata = u.metadata), u.version !== void 0 && (l.version = (u.version || BigInt(0)).toString()), u.decisionPolicy !== void 0 && (l.decisionPolicy = u.decisionPolicy ? t.Any.toJSON(u.decisionPolicy) : void 0), u.createdAt !== void 0 && (l.createdAt = (0, f.fromTimestamp)(u.createdAt).toISOString()), l;
    },
    fromPartial(u) {
      const l = o();
      return l.address = u.address ?? "", u.groupId !== void 0 && u.groupId !== null && (l.groupId = BigInt(u.groupId.toString())), l.admin = u.admin ?? "", l.metadata = u.metadata ?? "", u.version !== void 0 && u.version !== null && (l.version = BigInt(u.version.toString())), u.decisionPolicy !== void 0 && u.decisionPolicy !== null && (l.decisionPolicy = t.Any.fromPartial(u.decisionPolicy)), u.createdAt !== void 0 && u.createdAt !== null && (l.createdAt = n.Timestamp.fromPartial(u.createdAt)), l;
    }
  };
  function h() {
    return {
      id: BigInt(0),
      groupPolicyAddress: "",
      metadata: "",
      proposers: [],
      submitTime: n.Timestamp.fromPartial({}),
      groupVersion: BigInt(0),
      groupPolicyVersion: BigInt(0),
      status: 0,
      finalTallyResult: e.TallyResult.fromPartial({}),
      votingPeriodEnd: n.Timestamp.fromPartial({}),
      executorResult: 0,
      messages: [],
      title: "",
      summary: ""
    };
  }
  e.Proposal = {
    typeUrl: "/cosmos.group.v1.Proposal",
    encode(u, l = i.BinaryWriter.create()) {
      u.id !== BigInt(0) && l.uint32(8).uint64(u.id), u.groupPolicyAddress !== "" && l.uint32(18).string(u.groupPolicyAddress), u.metadata !== "" && l.uint32(26).string(u.metadata);
      for (const I of u.proposers)
        l.uint32(34).string(I);
      u.submitTime !== void 0 && n.Timestamp.encode(u.submitTime, l.uint32(42).fork()).ldelim(), u.groupVersion !== BigInt(0) && l.uint32(48).uint64(u.groupVersion), u.groupPolicyVersion !== BigInt(0) && l.uint32(56).uint64(u.groupPolicyVersion), u.status !== 0 && l.uint32(64).int32(u.status), u.finalTallyResult !== void 0 && e.TallyResult.encode(u.finalTallyResult, l.uint32(74).fork()).ldelim(), u.votingPeriodEnd !== void 0 && n.Timestamp.encode(u.votingPeriodEnd, l.uint32(82).fork()).ldelim(), u.executorResult !== 0 && l.uint32(88).int32(u.executorResult);
      for (const I of u.messages)
        t.Any.encode(I, l.uint32(98).fork()).ldelim();
      return u.title !== "" && l.uint32(106).string(u.title), u.summary !== "" && l.uint32(114).string(u.summary), l;
    },
    decode(u, l) {
      const I = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let B = l === void 0 ? I.len : I.pos + l;
      const b = h();
      for (; I.pos < B; ) {
        const D = I.uint32();
        switch (D >>> 3) {
          case 1:
            b.id = I.uint64();
            break;
          case 2:
            b.groupPolicyAddress = I.string();
            break;
          case 3:
            b.metadata = I.string();
            break;
          case 4:
            b.proposers.push(I.string());
            break;
          case 5:
            b.submitTime = n.Timestamp.decode(I, I.uint32());
            break;
          case 6:
            b.groupVersion = I.uint64();
            break;
          case 7:
            b.groupPolicyVersion = I.uint64();
            break;
          case 8:
            b.status = I.int32();
            break;
          case 9:
            b.finalTallyResult = e.TallyResult.decode(I, I.uint32());
            break;
          case 10:
            b.votingPeriodEnd = n.Timestamp.decode(I, I.uint32());
            break;
          case 11:
            b.executorResult = I.int32();
            break;
          case 12:
            b.messages.push(t.Any.decode(I, I.uint32()));
            break;
          case 13:
            b.title = I.string();
            break;
          case 14:
            b.summary = I.string();
            break;
          default:
            I.skipType(D & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(u) {
      const l = h();
      return (0, f.isSet)(u.id) && (l.id = BigInt(u.id.toString())), (0, f.isSet)(u.groupPolicyAddress) && (l.groupPolicyAddress = String(u.groupPolicyAddress)), (0, f.isSet)(u.metadata) && (l.metadata = String(u.metadata)), Array.isArray(u == null ? void 0 : u.proposers) && (l.proposers = u.proposers.map((I) => String(I))), (0, f.isSet)(u.submitTime) && (l.submitTime = (0, f.fromJsonTimestamp)(u.submitTime)), (0, f.isSet)(u.groupVersion) && (l.groupVersion = BigInt(u.groupVersion.toString())), (0, f.isSet)(u.groupPolicyVersion) && (l.groupPolicyVersion = BigInt(u.groupPolicyVersion.toString())), (0, f.isSet)(u.status) && (l.status = C(u.status)), (0, f.isSet)(u.finalTallyResult) && (l.finalTallyResult = e.TallyResult.fromJSON(u.finalTallyResult)), (0, f.isSet)(u.votingPeriodEnd) && (l.votingPeriodEnd = (0, f.fromJsonTimestamp)(u.votingPeriodEnd)), (0, f.isSet)(u.executorResult) && (l.executorResult = m(u.executorResult)), Array.isArray(u == null ? void 0 : u.messages) && (l.messages = u.messages.map((I) => t.Any.fromJSON(I))), (0, f.isSet)(u.title) && (l.title = String(u.title)), (0, f.isSet)(u.summary) && (l.summary = String(u.summary)), l;
    },
    toJSON(u) {
      const l = {};
      return u.id !== void 0 && (l.id = (u.id || BigInt(0)).toString()), u.groupPolicyAddress !== void 0 && (l.groupPolicyAddress = u.groupPolicyAddress), u.metadata !== void 0 && (l.metadata = u.metadata), u.proposers ? l.proposers = u.proposers.map((I) => I) : l.proposers = [], u.submitTime !== void 0 && (l.submitTime = (0, f.fromTimestamp)(u.submitTime).toISOString()), u.groupVersion !== void 0 && (l.groupVersion = (u.groupVersion || BigInt(0)).toString()), u.groupPolicyVersion !== void 0 && (l.groupPolicyVersion = (u.groupPolicyVersion || BigInt(0)).toString()), u.status !== void 0 && (l.status = R(u.status)), u.finalTallyResult !== void 0 && (l.finalTallyResult = u.finalTallyResult ? e.TallyResult.toJSON(u.finalTallyResult) : void 0), u.votingPeriodEnd !== void 0 && (l.votingPeriodEnd = (0, f.fromTimestamp)(u.votingPeriodEnd).toISOString()), u.executorResult !== void 0 && (l.executorResult = v(u.executorResult)), u.messages ? l.messages = u.messages.map((I) => I ? t.Any.toJSON(I) : void 0) : l.messages = [], u.title !== void 0 && (l.title = u.title), u.summary !== void 0 && (l.summary = u.summary), l;
    },
    fromPartial(u) {
      var I, B;
      const l = h();
      return u.id !== void 0 && u.id !== null && (l.id = BigInt(u.id.toString())), l.groupPolicyAddress = u.groupPolicyAddress ?? "", l.metadata = u.metadata ?? "", l.proposers = ((I = u.proposers) == null ? void 0 : I.map((b) => b)) || [], u.submitTime !== void 0 && u.submitTime !== null && (l.submitTime = n.Timestamp.fromPartial(u.submitTime)), u.groupVersion !== void 0 && u.groupVersion !== null && (l.groupVersion = BigInt(u.groupVersion.toString())), u.groupPolicyVersion !== void 0 && u.groupPolicyVersion !== null && (l.groupPolicyVersion = BigInt(u.groupPolicyVersion.toString())), l.status = u.status ?? 0, u.finalTallyResult !== void 0 && u.finalTallyResult !== null && (l.finalTallyResult = e.TallyResult.fromPartial(u.finalTallyResult)), u.votingPeriodEnd !== void 0 && u.votingPeriodEnd !== null && (l.votingPeriodEnd = n.Timestamp.fromPartial(u.votingPeriodEnd)), l.executorResult = u.executorResult ?? 0, l.messages = ((B = u.messages) == null ? void 0 : B.map((b) => t.Any.fromPartial(b))) || [], l.title = u.title ?? "", l.summary = u.summary ?? "", l;
    }
  };
  function N() {
    return {
      yesCount: "",
      abstainCount: "",
      noCount: "",
      noWithVetoCount: ""
    };
  }
  e.TallyResult = {
    typeUrl: "/cosmos.group.v1.TallyResult",
    encode(u, l = i.BinaryWriter.create()) {
      return u.yesCount !== "" && l.uint32(10).string(u.yesCount), u.abstainCount !== "" && l.uint32(18).string(u.abstainCount), u.noCount !== "" && l.uint32(26).string(u.noCount), u.noWithVetoCount !== "" && l.uint32(34).string(u.noWithVetoCount), l;
    },
    decode(u, l) {
      const I = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let B = l === void 0 ? I.len : I.pos + l;
      const b = N();
      for (; I.pos < B; ) {
        const D = I.uint32();
        switch (D >>> 3) {
          case 1:
            b.yesCount = I.string();
            break;
          case 2:
            b.abstainCount = I.string();
            break;
          case 3:
            b.noCount = I.string();
            break;
          case 4:
            b.noWithVetoCount = I.string();
            break;
          default:
            I.skipType(D & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(u) {
      const l = N();
      return (0, f.isSet)(u.yesCount) && (l.yesCount = String(u.yesCount)), (0, f.isSet)(u.abstainCount) && (l.abstainCount = String(u.abstainCount)), (0, f.isSet)(u.noCount) && (l.noCount = String(u.noCount)), (0, f.isSet)(u.noWithVetoCount) && (l.noWithVetoCount = String(u.noWithVetoCount)), l;
    },
    toJSON(u) {
      const l = {};
      return u.yesCount !== void 0 && (l.yesCount = u.yesCount), u.abstainCount !== void 0 && (l.abstainCount = u.abstainCount), u.noCount !== void 0 && (l.noCount = u.noCount), u.noWithVetoCount !== void 0 && (l.noWithVetoCount = u.noWithVetoCount), l;
    },
    fromPartial(u) {
      const l = N();
      return l.yesCount = u.yesCount ?? "", l.abstainCount = u.abstainCount ?? "", l.noCount = u.noCount ?? "", l.noWithVetoCount = u.noWithVetoCount ?? "", l;
    }
  };
  function q() {
    return {
      proposalId: BigInt(0),
      voter: "",
      option: 0,
      metadata: "",
      submitTime: n.Timestamp.fromPartial({})
    };
  }
  e.Vote = {
    typeUrl: "/cosmos.group.v1.Vote",
    encode(u, l = i.BinaryWriter.create()) {
      return u.proposalId !== BigInt(0) && l.uint32(8).uint64(u.proposalId), u.voter !== "" && l.uint32(18).string(u.voter), u.option !== 0 && l.uint32(24).int32(u.option), u.metadata !== "" && l.uint32(34).string(u.metadata), u.submitTime !== void 0 && n.Timestamp.encode(u.submitTime, l.uint32(42).fork()).ldelim(), l;
    },
    decode(u, l) {
      const I = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let B = l === void 0 ? I.len : I.pos + l;
      const b = q();
      for (; I.pos < B; ) {
        const D = I.uint32();
        switch (D >>> 3) {
          case 1:
            b.proposalId = I.uint64();
            break;
          case 2:
            b.voter = I.string();
            break;
          case 3:
            b.option = I.int32();
            break;
          case 4:
            b.metadata = I.string();
            break;
          case 5:
            b.submitTime = n.Timestamp.decode(I, I.uint32());
            break;
          default:
            I.skipType(D & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(u) {
      const l = q();
      return (0, f.isSet)(u.proposalId) && (l.proposalId = BigInt(u.proposalId.toString())), (0, f.isSet)(u.voter) && (l.voter = String(u.voter)), (0, f.isSet)(u.option) && (l.option = w(u.option)), (0, f.isSet)(u.metadata) && (l.metadata = String(u.metadata)), (0, f.isSet)(u.submitTime) && (l.submitTime = (0, f.fromJsonTimestamp)(u.submitTime)), l;
    },
    toJSON(u) {
      const l = {};
      return u.proposalId !== void 0 && (l.proposalId = (u.proposalId || BigInt(0)).toString()), u.voter !== void 0 && (l.voter = u.voter), u.option !== void 0 && (l.option = T(u.option)), u.metadata !== void 0 && (l.metadata = u.metadata), u.submitTime !== void 0 && (l.submitTime = (0, f.fromTimestamp)(u.submitTime).toISOString()), l;
    },
    fromPartial(u) {
      const l = q();
      return u.proposalId !== void 0 && u.proposalId !== null && (l.proposalId = BigInt(u.proposalId.toString())), l.voter = u.voter ?? "", l.option = u.option ?? 0, l.metadata = u.metadata ?? "", u.submitTime !== void 0 && u.submitTime !== null && (l.submitTime = n.Timestamp.fromPartial(u.submitTime)), l;
    }
  };
})(Ah);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgLeaveGroupResponse = e.MsgLeaveGroup = e.MsgExecResponse = e.MsgExec = e.MsgVoteResponse = e.MsgVote = e.MsgWithdrawProposalResponse = e.MsgWithdrawProposal = e.MsgSubmitProposalResponse = e.MsgSubmitProposal = e.MsgUpdateGroupPolicyMetadataResponse = e.MsgUpdateGroupPolicyMetadata = e.MsgUpdateGroupPolicyDecisionPolicyResponse = e.MsgUpdateGroupPolicyDecisionPolicy = e.MsgCreateGroupWithPolicyResponse = e.MsgCreateGroupWithPolicy = e.MsgUpdateGroupPolicyAdminResponse = e.MsgUpdateGroupPolicyAdmin = e.MsgCreateGroupPolicyResponse = e.MsgCreateGroupPolicy = e.MsgUpdateGroupMetadataResponse = e.MsgUpdateGroupMetadata = e.MsgUpdateGroupAdminResponse = e.MsgUpdateGroupAdmin = e.MsgUpdateGroupMembersResponse = e.MsgUpdateGroupMembers = e.MsgCreateGroupResponse = e.MsgCreateGroup = e.execToJSON = e.execFromJSON = e.Exec = e.protobufPackage = void 0;
  const n = Ah, r = Pe, t = re, i = ie;
  e.protobufPackage = "cosmos.group.v1";
  var f;
  (function(P) {
    P[P.EXEC_UNSPECIFIED = 0] = "EXEC_UNSPECIFIED", P[P.EXEC_TRY = 1] = "EXEC_TRY", P[P.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(f || (e.Exec = f = {}));
  function S(P) {
    switch (P) {
      case 0:
      case "EXEC_UNSPECIFIED":
        return f.EXEC_UNSPECIFIED;
      case 1:
      case "EXEC_TRY":
        return f.EXEC_TRY;
      case -1:
      case "UNRECOGNIZED":
      default:
        return f.UNRECOGNIZED;
    }
  }
  e.execFromJSON = S;
  function w(P) {
    switch (P) {
      case f.EXEC_UNSPECIFIED:
        return "EXEC_UNSPECIFIED";
      case f.EXEC_TRY:
        return "EXEC_TRY";
      case f.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.execToJSON = w;
  function T() {
    return {
      admin: "",
      members: [],
      metadata: ""
    };
  }
  e.MsgCreateGroup = {
    typeUrl: "/cosmos.group.v1.MsgCreateGroup",
    encode(P, A = t.BinaryWriter.create()) {
      P.admin !== "" && A.uint32(10).string(P.admin);
      for (const W of P.members)
        n.MemberRequest.encode(W, A.uint32(18).fork()).ldelim();
      return P.metadata !== "" && A.uint32(26).string(P.metadata), A;
    },
    decode(P, A) {
      const W = P instanceof t.BinaryReader ? P : new t.BinaryReader(P);
      let L = A === void 0 ? W.len : W.pos + A;
      const $ = T();
      for (; W.pos < L; ) {
        const ne = W.uint32();
        switch (ne >>> 3) {
          case 1:
            $.admin = W.string();
            break;
          case 2:
            $.members.push(n.MemberRequest.decode(W, W.uint32()));
            break;
          case 3:
            $.metadata = W.string();
            break;
          default:
            W.skipType(ne & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(P) {
      const A = T();
      return (0, i.isSet)(P.admin) && (A.admin = String(P.admin)), Array.isArray(P == null ? void 0 : P.members) && (A.members = P.members.map((W) => n.MemberRequest.fromJSON(W))), (0, i.isSet)(P.metadata) && (A.metadata = String(P.metadata)), A;
    },
    toJSON(P) {
      const A = {};
      return P.admin !== void 0 && (A.admin = P.admin), P.members ? A.members = P.members.map((W) => W ? n.MemberRequest.toJSON(W) : void 0) : A.members = [], P.metadata !== void 0 && (A.metadata = P.metadata), A;
    },
    fromPartial(P) {
      var W;
      const A = T();
      return A.admin = P.admin ?? "", A.members = ((W = P.members) == null ? void 0 : W.map((L) => n.MemberRequest.fromPartial(L))) || [], A.metadata = P.metadata ?? "", A;
    }
  };
  function J() {
    return {
      groupId: BigInt(0)
    };
  }
  e.MsgCreateGroupResponse = {
    typeUrl: "/cosmos.group.v1.MsgCreateGroupResponse",
    encode(P, A = t.BinaryWriter.create()) {
      return P.groupId !== BigInt(0) && A.uint32(8).uint64(P.groupId), A;
    },
    decode(P, A) {
      const W = P instanceof t.BinaryReader ? P : new t.BinaryReader(P);
      let L = A === void 0 ? W.len : W.pos + A;
      const $ = J();
      for (; W.pos < L; ) {
        const ne = W.uint32();
        switch (ne >>> 3) {
          case 1:
            $.groupId = W.uint64();
            break;
          default:
            W.skipType(ne & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(P) {
      const A = J();
      return (0, i.isSet)(P.groupId) && (A.groupId = BigInt(P.groupId.toString())), A;
    },
    toJSON(P) {
      const A = {};
      return P.groupId !== void 0 && (A.groupId = (P.groupId || BigInt(0)).toString()), A;
    },
    fromPartial(P) {
      const A = J();
      return P.groupId !== void 0 && P.groupId !== null && (A.groupId = BigInt(P.groupId.toString())), A;
    }
  };
  function C() {
    return {
      admin: "",
      groupId: BigInt(0),
      memberUpdates: []
    };
  }
  e.MsgUpdateGroupMembers = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupMembers",
    encode(P, A = t.BinaryWriter.create()) {
      P.admin !== "" && A.uint32(10).string(P.admin), P.groupId !== BigInt(0) && A.uint32(16).uint64(P.groupId);
      for (const W of P.memberUpdates)
        n.MemberRequest.encode(W, A.uint32(26).fork()).ldelim();
      return A;
    },
    decode(P, A) {
      const W = P instanceof t.BinaryReader ? P : new t.BinaryReader(P);
      let L = A === void 0 ? W.len : W.pos + A;
      const $ = C();
      for (; W.pos < L; ) {
        const ne = W.uint32();
        switch (ne >>> 3) {
          case 1:
            $.admin = W.string();
            break;
          case 2:
            $.groupId = W.uint64();
            break;
          case 3:
            $.memberUpdates.push(n.MemberRequest.decode(W, W.uint32()));
            break;
          default:
            W.skipType(ne & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(P) {
      const A = C();
      return (0, i.isSet)(P.admin) && (A.admin = String(P.admin)), (0, i.isSet)(P.groupId) && (A.groupId = BigInt(P.groupId.toString())), Array.isArray(P == null ? void 0 : P.memberUpdates) && (A.memberUpdates = P.memberUpdates.map((W) => n.MemberRequest.fromJSON(W))), A;
    },
    toJSON(P) {
      const A = {};
      return P.admin !== void 0 && (A.admin = P.admin), P.groupId !== void 0 && (A.groupId = (P.groupId || BigInt(0)).toString()), P.memberUpdates ? A.memberUpdates = P.memberUpdates.map((W) => W ? n.MemberRequest.toJSON(W) : void 0) : A.memberUpdates = [], A;
    },
    fromPartial(P) {
      var W;
      const A = C();
      return A.admin = P.admin ?? "", P.groupId !== void 0 && P.groupId !== null && (A.groupId = BigInt(P.groupId.toString())), A.memberUpdates = ((W = P.memberUpdates) == null ? void 0 : W.map((L) => n.MemberRequest.fromPartial(L))) || [], A;
    }
  };
  function R() {
    return {};
  }
  e.MsgUpdateGroupMembersResponse = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupMembersResponse",
    encode(P, A = t.BinaryWriter.create()) {
      return A;
    },
    decode(P, A) {
      const W = P instanceof t.BinaryReader ? P : new t.BinaryReader(P);
      let L = A === void 0 ? W.len : W.pos + A;
      const $ = R();
      for (; W.pos < L; ) {
        const ne = W.uint32();
        switch (ne >>> 3) {
          default:
            W.skipType(ne & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(P) {
      return R();
    },
    toJSON(P) {
      return {};
    },
    fromPartial(P) {
      return R();
    }
  };
  function p() {
    return {
      admin: "",
      groupId: BigInt(0),
      newAdmin: ""
    };
  }
  e.MsgUpdateGroupAdmin = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupAdmin",
    encode(P, A = t.BinaryWriter.create()) {
      return P.admin !== "" && A.uint32(10).string(P.admin), P.groupId !== BigInt(0) && A.uint32(16).uint64(P.groupId), P.newAdmin !== "" && A.uint32(26).string(P.newAdmin), A;
    },
    decode(P, A) {
      const W = P instanceof t.BinaryReader ? P : new t.BinaryReader(P);
      let L = A === void 0 ? W.len : W.pos + A;
      const $ = p();
      for (; W.pos < L; ) {
        const ne = W.uint32();
        switch (ne >>> 3) {
          case 1:
            $.admin = W.string();
            break;
          case 2:
            $.groupId = W.uint64();
            break;
          case 3:
            $.newAdmin = W.string();
            break;
          default:
            W.skipType(ne & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(P) {
      const A = p();
      return (0, i.isSet)(P.admin) && (A.admin = String(P.admin)), (0, i.isSet)(P.groupId) && (A.groupId = BigInt(P.groupId.toString())), (0, i.isSet)(P.newAdmin) && (A.newAdmin = String(P.newAdmin)), A;
    },
    toJSON(P) {
      const A = {};
      return P.admin !== void 0 && (A.admin = P.admin), P.groupId !== void 0 && (A.groupId = (P.groupId || BigInt(0)).toString()), P.newAdmin !== void 0 && (A.newAdmin = P.newAdmin), A;
    },
    fromPartial(P) {
      const A = p();
      return A.admin = P.admin ?? "", P.groupId !== void 0 && P.groupId !== null && (A.groupId = BigInt(P.groupId.toString())), A.newAdmin = P.newAdmin ?? "", A;
    }
  };
  function m() {
    return {};
  }
  e.MsgUpdateGroupAdminResponse = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupAdminResponse",
    encode(P, A = t.BinaryWriter.create()) {
      return A;
    },
    decode(P, A) {
      const W = P instanceof t.BinaryReader ? P : new t.BinaryReader(P);
      let L = A === void 0 ? W.len : W.pos + A;
      const $ = m();
      for (; W.pos < L; ) {
        const ne = W.uint32();
        switch (ne >>> 3) {
          default:
            W.skipType(ne & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(P) {
      return m();
    },
    toJSON(P) {
      return {};
    },
    fromPartial(P) {
      return m();
    }
  };
  function v() {
    return {
      admin: "",
      groupId: BigInt(0),
      metadata: ""
    };
  }
  e.MsgUpdateGroupMetadata = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupMetadata",
    encode(P, A = t.BinaryWriter.create()) {
      return P.admin !== "" && A.uint32(10).string(P.admin), P.groupId !== BigInt(0) && A.uint32(16).uint64(P.groupId), P.metadata !== "" && A.uint32(26).string(P.metadata), A;
    },
    decode(P, A) {
      const W = P instanceof t.BinaryReader ? P : new t.BinaryReader(P);
      let L = A === void 0 ? W.len : W.pos + A;
      const $ = v();
      for (; W.pos < L; ) {
        const ne = W.uint32();
        switch (ne >>> 3) {
          case 1:
            $.admin = W.string();
            break;
          case 2:
            $.groupId = W.uint64();
            break;
          case 3:
            $.metadata = W.string();
            break;
          default:
            W.skipType(ne & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(P) {
      const A = v();
      return (0, i.isSet)(P.admin) && (A.admin = String(P.admin)), (0, i.isSet)(P.groupId) && (A.groupId = BigInt(P.groupId.toString())), (0, i.isSet)(P.metadata) && (A.metadata = String(P.metadata)), A;
    },
    toJSON(P) {
      const A = {};
      return P.admin !== void 0 && (A.admin = P.admin), P.groupId !== void 0 && (A.groupId = (P.groupId || BigInt(0)).toString()), P.metadata !== void 0 && (A.metadata = P.metadata), A;
    },
    fromPartial(P) {
      const A = v();
      return A.admin = P.admin ?? "", P.groupId !== void 0 && P.groupId !== null && (A.groupId = BigInt(P.groupId.toString())), A.metadata = P.metadata ?? "", A;
    }
  };
  function a() {
    return {};
  }
  e.MsgUpdateGroupMetadataResponse = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupMetadataResponse",
    encode(P, A = t.BinaryWriter.create()) {
      return A;
    },
    decode(P, A) {
      const W = P instanceof t.BinaryReader ? P : new t.BinaryReader(P);
      let L = A === void 0 ? W.len : W.pos + A;
      const $ = a();
      for (; W.pos < L; ) {
        const ne = W.uint32();
        switch (ne >>> 3) {
          default:
            W.skipType(ne & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(P) {
      return a();
    },
    toJSON(P) {
      return {};
    },
    fromPartial(P) {
      return a();
    }
  };
  function d() {
    return {
      admin: "",
      groupId: BigInt(0),
      metadata: "",
      decisionPolicy: void 0
    };
  }
  e.MsgCreateGroupPolicy = {
    typeUrl: "/cosmos.group.v1.MsgCreateGroupPolicy",
    encode(P, A = t.BinaryWriter.create()) {
      return P.admin !== "" && A.uint32(10).string(P.admin), P.groupId !== BigInt(0) && A.uint32(16).uint64(P.groupId), P.metadata !== "" && A.uint32(26).string(P.metadata), P.decisionPolicy !== void 0 && r.Any.encode(P.decisionPolicy, A.uint32(34).fork()).ldelim(), A;
    },
    decode(P, A) {
      const W = P instanceof t.BinaryReader ? P : new t.BinaryReader(P);
      let L = A === void 0 ? W.len : W.pos + A;
      const $ = d();
      for (; W.pos < L; ) {
        const ne = W.uint32();
        switch (ne >>> 3) {
          case 1:
            $.admin = W.string();
            break;
          case 2:
            $.groupId = W.uint64();
            break;
          case 3:
            $.metadata = W.string();
            break;
          case 4:
            $.decisionPolicy = r.Any.decode(W, W.uint32());
            break;
          default:
            W.skipType(ne & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(P) {
      const A = d();
      return (0, i.isSet)(P.admin) && (A.admin = String(P.admin)), (0, i.isSet)(P.groupId) && (A.groupId = BigInt(P.groupId.toString())), (0, i.isSet)(P.metadata) && (A.metadata = String(P.metadata)), (0, i.isSet)(P.decisionPolicy) && (A.decisionPolicy = r.Any.fromJSON(P.decisionPolicy)), A;
    },
    toJSON(P) {
      const A = {};
      return P.admin !== void 0 && (A.admin = P.admin), P.groupId !== void 0 && (A.groupId = (P.groupId || BigInt(0)).toString()), P.metadata !== void 0 && (A.metadata = P.metadata), P.decisionPolicy !== void 0 && (A.decisionPolicy = P.decisionPolicy ? r.Any.toJSON(P.decisionPolicy) : void 0), A;
    },
    fromPartial(P) {
      const A = d();
      return A.admin = P.admin ?? "", P.groupId !== void 0 && P.groupId !== null && (A.groupId = BigInt(P.groupId.toString())), A.metadata = P.metadata ?? "", P.decisionPolicy !== void 0 && P.decisionPolicy !== null && (A.decisionPolicy = r.Any.fromPartial(P.decisionPolicy)), A;
    }
  };
  function y() {
    return {
      address: ""
    };
  }
  e.MsgCreateGroupPolicyResponse = {
    typeUrl: "/cosmos.group.v1.MsgCreateGroupPolicyResponse",
    encode(P, A = t.BinaryWriter.create()) {
      return P.address !== "" && A.uint32(10).string(P.address), A;
    },
    decode(P, A) {
      const W = P instanceof t.BinaryReader ? P : new t.BinaryReader(P);
      let L = A === void 0 ? W.len : W.pos + A;
      const $ = y();
      for (; W.pos < L; ) {
        const ne = W.uint32();
        switch (ne >>> 3) {
          case 1:
            $.address = W.string();
            break;
          default:
            W.skipType(ne & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(P) {
      const A = y();
      return (0, i.isSet)(P.address) && (A.address = String(P.address)), A;
    },
    toJSON(P) {
      const A = {};
      return P.address !== void 0 && (A.address = P.address), A;
    },
    fromPartial(P) {
      const A = y();
      return A.address = P.address ?? "", A;
    }
  };
  function _() {
    return {
      admin: "",
      groupPolicyAddress: "",
      newAdmin: ""
    };
  }
  e.MsgUpdateGroupPolicyAdmin = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyAdmin",
    encode(P, A = t.BinaryWriter.create()) {
      return P.admin !== "" && A.uint32(10).string(P.admin), P.groupPolicyAddress !== "" && A.uint32(18).string(P.groupPolicyAddress), P.newAdmin !== "" && A.uint32(26).string(P.newAdmin), A;
    },
    decode(P, A) {
      const W = P instanceof t.BinaryReader ? P : new t.BinaryReader(P);
      let L = A === void 0 ? W.len : W.pos + A;
      const $ = _();
      for (; W.pos < L; ) {
        const ne = W.uint32();
        switch (ne >>> 3) {
          case 1:
            $.admin = W.string();
            break;
          case 2:
            $.groupPolicyAddress = W.string();
            break;
          case 3:
            $.newAdmin = W.string();
            break;
          default:
            W.skipType(ne & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(P) {
      const A = _();
      return (0, i.isSet)(P.admin) && (A.admin = String(P.admin)), (0, i.isSet)(P.groupPolicyAddress) && (A.groupPolicyAddress = String(P.groupPolicyAddress)), (0, i.isSet)(P.newAdmin) && (A.newAdmin = String(P.newAdmin)), A;
    },
    toJSON(P) {
      const A = {};
      return P.admin !== void 0 && (A.admin = P.admin), P.groupPolicyAddress !== void 0 && (A.groupPolicyAddress = P.groupPolicyAddress), P.newAdmin !== void 0 && (A.newAdmin = P.newAdmin), A;
    },
    fromPartial(P) {
      const A = _();
      return A.admin = P.admin ?? "", A.groupPolicyAddress = P.groupPolicyAddress ?? "", A.newAdmin = P.newAdmin ?? "", A;
    }
  };
  function E() {
    return {};
  }
  e.MsgUpdateGroupPolicyAdminResponse = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyAdminResponse",
    encode(P, A = t.BinaryWriter.create()) {
      return A;
    },
    decode(P, A) {
      const W = P instanceof t.BinaryReader ? P : new t.BinaryReader(P);
      let L = A === void 0 ? W.len : W.pos + A;
      const $ = E();
      for (; W.pos < L; ) {
        const ne = W.uint32();
        switch (ne >>> 3) {
          default:
            W.skipType(ne & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(P) {
      return E();
    },
    toJSON(P) {
      return {};
    },
    fromPartial(P) {
      return E();
    }
  };
  function U() {
    return {
      admin: "",
      members: [],
      groupMetadata: "",
      groupPolicyMetadata: "",
      groupPolicyAsAdmin: !1,
      decisionPolicy: void 0
    };
  }
  e.MsgCreateGroupWithPolicy = {
    typeUrl: "/cosmos.group.v1.MsgCreateGroupWithPolicy",
    encode(P, A = t.BinaryWriter.create()) {
      P.admin !== "" && A.uint32(10).string(P.admin);
      for (const W of P.members)
        n.MemberRequest.encode(W, A.uint32(18).fork()).ldelim();
      return P.groupMetadata !== "" && A.uint32(26).string(P.groupMetadata), P.groupPolicyMetadata !== "" && A.uint32(34).string(P.groupPolicyMetadata), P.groupPolicyAsAdmin === !0 && A.uint32(40).bool(P.groupPolicyAsAdmin), P.decisionPolicy !== void 0 && r.Any.encode(P.decisionPolicy, A.uint32(50).fork()).ldelim(), A;
    },
    decode(P, A) {
      const W = P instanceof t.BinaryReader ? P : new t.BinaryReader(P);
      let L = A === void 0 ? W.len : W.pos + A;
      const $ = U();
      for (; W.pos < L; ) {
        const ne = W.uint32();
        switch (ne >>> 3) {
          case 1:
            $.admin = W.string();
            break;
          case 2:
            $.members.push(n.MemberRequest.decode(W, W.uint32()));
            break;
          case 3:
            $.groupMetadata = W.string();
            break;
          case 4:
            $.groupPolicyMetadata = W.string();
            break;
          case 5:
            $.groupPolicyAsAdmin = W.bool();
            break;
          case 6:
            $.decisionPolicy = r.Any.decode(W, W.uint32());
            break;
          default:
            W.skipType(ne & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(P) {
      const A = U();
      return (0, i.isSet)(P.admin) && (A.admin = String(P.admin)), Array.isArray(P == null ? void 0 : P.members) && (A.members = P.members.map((W) => n.MemberRequest.fromJSON(W))), (0, i.isSet)(P.groupMetadata) && (A.groupMetadata = String(P.groupMetadata)), (0, i.isSet)(P.groupPolicyMetadata) && (A.groupPolicyMetadata = String(P.groupPolicyMetadata)), (0, i.isSet)(P.groupPolicyAsAdmin) && (A.groupPolicyAsAdmin = !!P.groupPolicyAsAdmin), (0, i.isSet)(P.decisionPolicy) && (A.decisionPolicy = r.Any.fromJSON(P.decisionPolicy)), A;
    },
    toJSON(P) {
      const A = {};
      return P.admin !== void 0 && (A.admin = P.admin), P.members ? A.members = P.members.map((W) => W ? n.MemberRequest.toJSON(W) : void 0) : A.members = [], P.groupMetadata !== void 0 && (A.groupMetadata = P.groupMetadata), P.groupPolicyMetadata !== void 0 && (A.groupPolicyMetadata = P.groupPolicyMetadata), P.groupPolicyAsAdmin !== void 0 && (A.groupPolicyAsAdmin = P.groupPolicyAsAdmin), P.decisionPolicy !== void 0 && (A.decisionPolicy = P.decisionPolicy ? r.Any.toJSON(P.decisionPolicy) : void 0), A;
    },
    fromPartial(P) {
      var W;
      const A = U();
      return A.admin = P.admin ?? "", A.members = ((W = P.members) == null ? void 0 : W.map((L) => n.MemberRequest.fromPartial(L))) || [], A.groupMetadata = P.groupMetadata ?? "", A.groupPolicyMetadata = P.groupPolicyMetadata ?? "", A.groupPolicyAsAdmin = P.groupPolicyAsAdmin ?? !1, P.decisionPolicy !== void 0 && P.decisionPolicy !== null && (A.decisionPolicy = r.Any.fromPartial(P.decisionPolicy)), A;
    }
  };
  function V() {
    return {
      groupId: BigInt(0),
      groupPolicyAddress: ""
    };
  }
  e.MsgCreateGroupWithPolicyResponse = {
    typeUrl: "/cosmos.group.v1.MsgCreateGroupWithPolicyResponse",
    encode(P, A = t.BinaryWriter.create()) {
      return P.groupId !== BigInt(0) && A.uint32(8).uint64(P.groupId), P.groupPolicyAddress !== "" && A.uint32(18).string(P.groupPolicyAddress), A;
    },
    decode(P, A) {
      const W = P instanceof t.BinaryReader ? P : new t.BinaryReader(P);
      let L = A === void 0 ? W.len : W.pos + A;
      const $ = V();
      for (; W.pos < L; ) {
        const ne = W.uint32();
        switch (ne >>> 3) {
          case 1:
            $.groupId = W.uint64();
            break;
          case 2:
            $.groupPolicyAddress = W.string();
            break;
          default:
            W.skipType(ne & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(P) {
      const A = V();
      return (0, i.isSet)(P.groupId) && (A.groupId = BigInt(P.groupId.toString())), (0, i.isSet)(P.groupPolicyAddress) && (A.groupPolicyAddress = String(P.groupPolicyAddress)), A;
    },
    toJSON(P) {
      const A = {};
      return P.groupId !== void 0 && (A.groupId = (P.groupId || BigInt(0)).toString()), P.groupPolicyAddress !== void 0 && (A.groupPolicyAddress = P.groupPolicyAddress), A;
    },
    fromPartial(P) {
      const A = V();
      return P.groupId !== void 0 && P.groupId !== null && (A.groupId = BigInt(P.groupId.toString())), A.groupPolicyAddress = P.groupPolicyAddress ?? "", A;
    }
  };
  function o() {
    return {
      admin: "",
      groupPolicyAddress: "",
      decisionPolicy: void 0
    };
  }
  e.MsgUpdateGroupPolicyDecisionPolicy = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy",
    encode(P, A = t.BinaryWriter.create()) {
      return P.admin !== "" && A.uint32(10).string(P.admin), P.groupPolicyAddress !== "" && A.uint32(18).string(P.groupPolicyAddress), P.decisionPolicy !== void 0 && r.Any.encode(P.decisionPolicy, A.uint32(26).fork()).ldelim(), A;
    },
    decode(P, A) {
      const W = P instanceof t.BinaryReader ? P : new t.BinaryReader(P);
      let L = A === void 0 ? W.len : W.pos + A;
      const $ = o();
      for (; W.pos < L; ) {
        const ne = W.uint32();
        switch (ne >>> 3) {
          case 1:
            $.admin = W.string();
            break;
          case 2:
            $.groupPolicyAddress = W.string();
            break;
          case 3:
            $.decisionPolicy = r.Any.decode(W, W.uint32());
            break;
          default:
            W.skipType(ne & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(P) {
      const A = o();
      return (0, i.isSet)(P.admin) && (A.admin = String(P.admin)), (0, i.isSet)(P.groupPolicyAddress) && (A.groupPolicyAddress = String(P.groupPolicyAddress)), (0, i.isSet)(P.decisionPolicy) && (A.decisionPolicy = r.Any.fromJSON(P.decisionPolicy)), A;
    },
    toJSON(P) {
      const A = {};
      return P.admin !== void 0 && (A.admin = P.admin), P.groupPolicyAddress !== void 0 && (A.groupPolicyAddress = P.groupPolicyAddress), P.decisionPolicy !== void 0 && (A.decisionPolicy = P.decisionPolicy ? r.Any.toJSON(P.decisionPolicy) : void 0), A;
    },
    fromPartial(P) {
      const A = o();
      return A.admin = P.admin ?? "", A.groupPolicyAddress = P.groupPolicyAddress ?? "", P.decisionPolicy !== void 0 && P.decisionPolicy !== null && (A.decisionPolicy = r.Any.fromPartial(P.decisionPolicy)), A;
    }
  };
  function h() {
    return {};
  }
  e.MsgUpdateGroupPolicyDecisionPolicyResponse = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicyResponse",
    encode(P, A = t.BinaryWriter.create()) {
      return A;
    },
    decode(P, A) {
      const W = P instanceof t.BinaryReader ? P : new t.BinaryReader(P);
      let L = A === void 0 ? W.len : W.pos + A;
      const $ = h();
      for (; W.pos < L; ) {
        const ne = W.uint32();
        switch (ne >>> 3) {
          default:
            W.skipType(ne & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(P) {
      return h();
    },
    toJSON(P) {
      return {};
    },
    fromPartial(P) {
      return h();
    }
  };
  function N() {
    return {
      admin: "",
      groupPolicyAddress: "",
      metadata: ""
    };
  }
  e.MsgUpdateGroupPolicyMetadata = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyMetadata",
    encode(P, A = t.BinaryWriter.create()) {
      return P.admin !== "" && A.uint32(10).string(P.admin), P.groupPolicyAddress !== "" && A.uint32(18).string(P.groupPolicyAddress), P.metadata !== "" && A.uint32(26).string(P.metadata), A;
    },
    decode(P, A) {
      const W = P instanceof t.BinaryReader ? P : new t.BinaryReader(P);
      let L = A === void 0 ? W.len : W.pos + A;
      const $ = N();
      for (; W.pos < L; ) {
        const ne = W.uint32();
        switch (ne >>> 3) {
          case 1:
            $.admin = W.string();
            break;
          case 2:
            $.groupPolicyAddress = W.string();
            break;
          case 3:
            $.metadata = W.string();
            break;
          default:
            W.skipType(ne & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(P) {
      const A = N();
      return (0, i.isSet)(P.admin) && (A.admin = String(P.admin)), (0, i.isSet)(P.groupPolicyAddress) && (A.groupPolicyAddress = String(P.groupPolicyAddress)), (0, i.isSet)(P.metadata) && (A.metadata = String(P.metadata)), A;
    },
    toJSON(P) {
      const A = {};
      return P.admin !== void 0 && (A.admin = P.admin), P.groupPolicyAddress !== void 0 && (A.groupPolicyAddress = P.groupPolicyAddress), P.metadata !== void 0 && (A.metadata = P.metadata), A;
    },
    fromPartial(P) {
      const A = N();
      return A.admin = P.admin ?? "", A.groupPolicyAddress = P.groupPolicyAddress ?? "", A.metadata = P.metadata ?? "", A;
    }
  };
  function q() {
    return {};
  }
  e.MsgUpdateGroupPolicyMetadataResponse = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyMetadataResponse",
    encode(P, A = t.BinaryWriter.create()) {
      return A;
    },
    decode(P, A) {
      const W = P instanceof t.BinaryReader ? P : new t.BinaryReader(P);
      let L = A === void 0 ? W.len : W.pos + A;
      const $ = q();
      for (; W.pos < L; ) {
        const ne = W.uint32();
        switch (ne >>> 3) {
          default:
            W.skipType(ne & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(P) {
      return q();
    },
    toJSON(P) {
      return {};
    },
    fromPartial(P) {
      return q();
    }
  };
  function u() {
    return {
      groupPolicyAddress: "",
      proposers: [],
      metadata: "",
      messages: [],
      exec: 0,
      title: "",
      summary: ""
    };
  }
  e.MsgSubmitProposal = {
    typeUrl: "/cosmos.group.v1.MsgSubmitProposal",
    encode(P, A = t.BinaryWriter.create()) {
      P.groupPolicyAddress !== "" && A.uint32(10).string(P.groupPolicyAddress);
      for (const W of P.proposers)
        A.uint32(18).string(W);
      P.metadata !== "" && A.uint32(26).string(P.metadata);
      for (const W of P.messages)
        r.Any.encode(W, A.uint32(34).fork()).ldelim();
      return P.exec !== 0 && A.uint32(40).int32(P.exec), P.title !== "" && A.uint32(50).string(P.title), P.summary !== "" && A.uint32(58).string(P.summary), A;
    },
    decode(P, A) {
      const W = P instanceof t.BinaryReader ? P : new t.BinaryReader(P);
      let L = A === void 0 ? W.len : W.pos + A;
      const $ = u();
      for (; W.pos < L; ) {
        const ne = W.uint32();
        switch (ne >>> 3) {
          case 1:
            $.groupPolicyAddress = W.string();
            break;
          case 2:
            $.proposers.push(W.string());
            break;
          case 3:
            $.metadata = W.string();
            break;
          case 4:
            $.messages.push(r.Any.decode(W, W.uint32()));
            break;
          case 5:
            $.exec = W.int32();
            break;
          case 6:
            $.title = W.string();
            break;
          case 7:
            $.summary = W.string();
            break;
          default:
            W.skipType(ne & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(P) {
      const A = u();
      return (0, i.isSet)(P.groupPolicyAddress) && (A.groupPolicyAddress = String(P.groupPolicyAddress)), Array.isArray(P == null ? void 0 : P.proposers) && (A.proposers = P.proposers.map((W) => String(W))), (0, i.isSet)(P.metadata) && (A.metadata = String(P.metadata)), Array.isArray(P == null ? void 0 : P.messages) && (A.messages = P.messages.map((W) => r.Any.fromJSON(W))), (0, i.isSet)(P.exec) && (A.exec = S(P.exec)), (0, i.isSet)(P.title) && (A.title = String(P.title)), (0, i.isSet)(P.summary) && (A.summary = String(P.summary)), A;
    },
    toJSON(P) {
      const A = {};
      return P.groupPolicyAddress !== void 0 && (A.groupPolicyAddress = P.groupPolicyAddress), P.proposers ? A.proposers = P.proposers.map((W) => W) : A.proposers = [], P.metadata !== void 0 && (A.metadata = P.metadata), P.messages ? A.messages = P.messages.map((W) => W ? r.Any.toJSON(W) : void 0) : A.messages = [], P.exec !== void 0 && (A.exec = w(P.exec)), P.title !== void 0 && (A.title = P.title), P.summary !== void 0 && (A.summary = P.summary), A;
    },
    fromPartial(P) {
      var W, L;
      const A = u();
      return A.groupPolicyAddress = P.groupPolicyAddress ?? "", A.proposers = ((W = P.proposers) == null ? void 0 : W.map(($) => $)) || [], A.metadata = P.metadata ?? "", A.messages = ((L = P.messages) == null ? void 0 : L.map(($) => r.Any.fromPartial($))) || [], A.exec = P.exec ?? 0, A.title = P.title ?? "", A.summary = P.summary ?? "", A;
    }
  };
  function l() {
    return {
      proposalId: BigInt(0)
    };
  }
  e.MsgSubmitProposalResponse = {
    typeUrl: "/cosmos.group.v1.MsgSubmitProposalResponse",
    encode(P, A = t.BinaryWriter.create()) {
      return P.proposalId !== BigInt(0) && A.uint32(8).uint64(P.proposalId), A;
    },
    decode(P, A) {
      const W = P instanceof t.BinaryReader ? P : new t.BinaryReader(P);
      let L = A === void 0 ? W.len : W.pos + A;
      const $ = l();
      for (; W.pos < L; ) {
        const ne = W.uint32();
        switch (ne >>> 3) {
          case 1:
            $.proposalId = W.uint64();
            break;
          default:
            W.skipType(ne & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(P) {
      const A = l();
      return (0, i.isSet)(P.proposalId) && (A.proposalId = BigInt(P.proposalId.toString())), A;
    },
    toJSON(P) {
      const A = {};
      return P.proposalId !== void 0 && (A.proposalId = (P.proposalId || BigInt(0)).toString()), A;
    },
    fromPartial(P) {
      const A = l();
      return P.proposalId !== void 0 && P.proposalId !== null && (A.proposalId = BigInt(P.proposalId.toString())), A;
    }
  };
  function I() {
    return {
      proposalId: BigInt(0),
      address: ""
    };
  }
  e.MsgWithdrawProposal = {
    typeUrl: "/cosmos.group.v1.MsgWithdrawProposal",
    encode(P, A = t.BinaryWriter.create()) {
      return P.proposalId !== BigInt(0) && A.uint32(8).uint64(P.proposalId), P.address !== "" && A.uint32(18).string(P.address), A;
    },
    decode(P, A) {
      const W = P instanceof t.BinaryReader ? P : new t.BinaryReader(P);
      let L = A === void 0 ? W.len : W.pos + A;
      const $ = I();
      for (; W.pos < L; ) {
        const ne = W.uint32();
        switch (ne >>> 3) {
          case 1:
            $.proposalId = W.uint64();
            break;
          case 2:
            $.address = W.string();
            break;
          default:
            W.skipType(ne & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(P) {
      const A = I();
      return (0, i.isSet)(P.proposalId) && (A.proposalId = BigInt(P.proposalId.toString())), (0, i.isSet)(P.address) && (A.address = String(P.address)), A;
    },
    toJSON(P) {
      const A = {};
      return P.proposalId !== void 0 && (A.proposalId = (P.proposalId || BigInt(0)).toString()), P.address !== void 0 && (A.address = P.address), A;
    },
    fromPartial(P) {
      const A = I();
      return P.proposalId !== void 0 && P.proposalId !== null && (A.proposalId = BigInt(P.proposalId.toString())), A.address = P.address ?? "", A;
    }
  };
  function B() {
    return {};
  }
  e.MsgWithdrawProposalResponse = {
    typeUrl: "/cosmos.group.v1.MsgWithdrawProposalResponse",
    encode(P, A = t.BinaryWriter.create()) {
      return A;
    },
    decode(P, A) {
      const W = P instanceof t.BinaryReader ? P : new t.BinaryReader(P);
      let L = A === void 0 ? W.len : W.pos + A;
      const $ = B();
      for (; W.pos < L; ) {
        const ne = W.uint32();
        switch (ne >>> 3) {
          default:
            W.skipType(ne & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(P) {
      return B();
    },
    toJSON(P) {
      return {};
    },
    fromPartial(P) {
      return B();
    }
  };
  function b() {
    return {
      proposalId: BigInt(0),
      voter: "",
      option: 0,
      metadata: "",
      exec: 0
    };
  }
  e.MsgVote = {
    typeUrl: "/cosmos.group.v1.MsgVote",
    encode(P, A = t.BinaryWriter.create()) {
      return P.proposalId !== BigInt(0) && A.uint32(8).uint64(P.proposalId), P.voter !== "" && A.uint32(18).string(P.voter), P.option !== 0 && A.uint32(24).int32(P.option), P.metadata !== "" && A.uint32(34).string(P.metadata), P.exec !== 0 && A.uint32(40).int32(P.exec), A;
    },
    decode(P, A) {
      const W = P instanceof t.BinaryReader ? P : new t.BinaryReader(P);
      let L = A === void 0 ? W.len : W.pos + A;
      const $ = b();
      for (; W.pos < L; ) {
        const ne = W.uint32();
        switch (ne >>> 3) {
          case 1:
            $.proposalId = W.uint64();
            break;
          case 2:
            $.voter = W.string();
            break;
          case 3:
            $.option = W.int32();
            break;
          case 4:
            $.metadata = W.string();
            break;
          case 5:
            $.exec = W.int32();
            break;
          default:
            W.skipType(ne & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(P) {
      const A = b();
      return (0, i.isSet)(P.proposalId) && (A.proposalId = BigInt(P.proposalId.toString())), (0, i.isSet)(P.voter) && (A.voter = String(P.voter)), (0, i.isSet)(P.option) && (A.option = (0, n.voteOptionFromJSON)(P.option)), (0, i.isSet)(P.metadata) && (A.metadata = String(P.metadata)), (0, i.isSet)(P.exec) && (A.exec = S(P.exec)), A;
    },
    toJSON(P) {
      const A = {};
      return P.proposalId !== void 0 && (A.proposalId = (P.proposalId || BigInt(0)).toString()), P.voter !== void 0 && (A.voter = P.voter), P.option !== void 0 && (A.option = (0, n.voteOptionToJSON)(P.option)), P.metadata !== void 0 && (A.metadata = P.metadata), P.exec !== void 0 && (A.exec = w(P.exec)), A;
    },
    fromPartial(P) {
      const A = b();
      return P.proposalId !== void 0 && P.proposalId !== null && (A.proposalId = BigInt(P.proposalId.toString())), A.voter = P.voter ?? "", A.option = P.option ?? 0, A.metadata = P.metadata ?? "", A.exec = P.exec ?? 0, A;
    }
  };
  function D() {
    return {};
  }
  e.MsgVoteResponse = {
    typeUrl: "/cosmos.group.v1.MsgVoteResponse",
    encode(P, A = t.BinaryWriter.create()) {
      return A;
    },
    decode(P, A) {
      const W = P instanceof t.BinaryReader ? P : new t.BinaryReader(P);
      let L = A === void 0 ? W.len : W.pos + A;
      const $ = D();
      for (; W.pos < L; ) {
        const ne = W.uint32();
        switch (ne >>> 3) {
          default:
            W.skipType(ne & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(P) {
      return D();
    },
    toJSON(P) {
      return {};
    },
    fromPartial(P) {
      return D();
    }
  };
  function Q() {
    return {
      proposalId: BigInt(0),
      executor: ""
    };
  }
  e.MsgExec = {
    typeUrl: "/cosmos.group.v1.MsgExec",
    encode(P, A = t.BinaryWriter.create()) {
      return P.proposalId !== BigInt(0) && A.uint32(8).uint64(P.proposalId), P.executor !== "" && A.uint32(18).string(P.executor), A;
    },
    decode(P, A) {
      const W = P instanceof t.BinaryReader ? P : new t.BinaryReader(P);
      let L = A === void 0 ? W.len : W.pos + A;
      const $ = Q();
      for (; W.pos < L; ) {
        const ne = W.uint32();
        switch (ne >>> 3) {
          case 1:
            $.proposalId = W.uint64();
            break;
          case 2:
            $.executor = W.string();
            break;
          default:
            W.skipType(ne & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(P) {
      const A = Q();
      return (0, i.isSet)(P.proposalId) && (A.proposalId = BigInt(P.proposalId.toString())), (0, i.isSet)(P.executor) && (A.executor = String(P.executor)), A;
    },
    toJSON(P) {
      const A = {};
      return P.proposalId !== void 0 && (A.proposalId = (P.proposalId || BigInt(0)).toString()), P.executor !== void 0 && (A.executor = P.executor), A;
    },
    fromPartial(P) {
      const A = Q();
      return P.proposalId !== void 0 && P.proposalId !== null && (A.proposalId = BigInt(P.proposalId.toString())), A.executor = P.executor ?? "", A;
    }
  };
  function H() {
    return {
      result: 0
    };
  }
  e.MsgExecResponse = {
    typeUrl: "/cosmos.group.v1.MsgExecResponse",
    encode(P, A = t.BinaryWriter.create()) {
      return P.result !== 0 && A.uint32(16).int32(P.result), A;
    },
    decode(P, A) {
      const W = P instanceof t.BinaryReader ? P : new t.BinaryReader(P);
      let L = A === void 0 ? W.len : W.pos + A;
      const $ = H();
      for (; W.pos < L; ) {
        const ne = W.uint32();
        switch (ne >>> 3) {
          case 2:
            $.result = W.int32();
            break;
          default:
            W.skipType(ne & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(P) {
      const A = H();
      return (0, i.isSet)(P.result) && (A.result = (0, n.proposalExecutorResultFromJSON)(P.result)), A;
    },
    toJSON(P) {
      const A = {};
      return P.result !== void 0 && (A.result = (0, n.proposalExecutorResultToJSON)(P.result)), A;
    },
    fromPartial(P) {
      const A = H();
      return A.result = P.result ?? 0, A;
    }
  };
  function s() {
    return {
      address: "",
      groupId: BigInt(0)
    };
  }
  e.MsgLeaveGroup = {
    typeUrl: "/cosmos.group.v1.MsgLeaveGroup",
    encode(P, A = t.BinaryWriter.create()) {
      return P.address !== "" && A.uint32(10).string(P.address), P.groupId !== BigInt(0) && A.uint32(16).uint64(P.groupId), A;
    },
    decode(P, A) {
      const W = P instanceof t.BinaryReader ? P : new t.BinaryReader(P);
      let L = A === void 0 ? W.len : W.pos + A;
      const $ = s();
      for (; W.pos < L; ) {
        const ne = W.uint32();
        switch (ne >>> 3) {
          case 1:
            $.address = W.string();
            break;
          case 2:
            $.groupId = W.uint64();
            break;
          default:
            W.skipType(ne & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(P) {
      const A = s();
      return (0, i.isSet)(P.address) && (A.address = String(P.address)), (0, i.isSet)(P.groupId) && (A.groupId = BigInt(P.groupId.toString())), A;
    },
    toJSON(P) {
      const A = {};
      return P.address !== void 0 && (A.address = P.address), P.groupId !== void 0 && (A.groupId = (P.groupId || BigInt(0)).toString()), A;
    },
    fromPartial(P) {
      const A = s();
      return A.address = P.address ?? "", P.groupId !== void 0 && P.groupId !== null && (A.groupId = BigInt(P.groupId.toString())), A;
    }
  };
  function k() {
    return {};
  }
  e.MsgLeaveGroupResponse = {
    typeUrl: "/cosmos.group.v1.MsgLeaveGroupResponse",
    encode(P, A = t.BinaryWriter.create()) {
      return A;
    },
    decode(P, A) {
      const W = P instanceof t.BinaryReader ? P : new t.BinaryReader(P);
      let L = A === void 0 ? W.len : W.pos + A;
      const $ = k();
      for (; W.pos < L; ) {
        const ne = W.uint32();
        switch (ne >>> 3) {
          default:
            W.skipType(ne & 7);
            break;
        }
      }
      return $;
    },
    fromJSON(P) {
      return k();
    },
    toJSON(P) {
      return {};
    },
    fromPartial(P) {
      return k();
    }
  };
  class g {
    constructor(A) {
      this.rpc = A, this.CreateGroup = this.CreateGroup.bind(this), this.UpdateGroupMembers = this.UpdateGroupMembers.bind(this), this.UpdateGroupAdmin = this.UpdateGroupAdmin.bind(this), this.UpdateGroupMetadata = this.UpdateGroupMetadata.bind(this), this.CreateGroupPolicy = this.CreateGroupPolicy.bind(this), this.CreateGroupWithPolicy = this.CreateGroupWithPolicy.bind(this), this.UpdateGroupPolicyAdmin = this.UpdateGroupPolicyAdmin.bind(this), this.UpdateGroupPolicyDecisionPolicy = this.UpdateGroupPolicyDecisionPolicy.bind(this), this.UpdateGroupPolicyMetadata = this.UpdateGroupPolicyMetadata.bind(this), this.SubmitProposal = this.SubmitProposal.bind(this), this.WithdrawProposal = this.WithdrawProposal.bind(this), this.Vote = this.Vote.bind(this), this.Exec = this.Exec.bind(this), this.LeaveGroup = this.LeaveGroup.bind(this);
    }
    CreateGroup(A) {
      const W = e.MsgCreateGroup.encode(A).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "CreateGroup", W).then(($) => e.MsgCreateGroupResponse.decode(new t.BinaryReader($)));
    }
    UpdateGroupMembers(A) {
      const W = e.MsgUpdateGroupMembers.encode(A).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupMembers", W).then(($) => e.MsgUpdateGroupMembersResponse.decode(new t.BinaryReader($)));
    }
    UpdateGroupAdmin(A) {
      const W = e.MsgUpdateGroupAdmin.encode(A).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupAdmin", W).then(($) => e.MsgUpdateGroupAdminResponse.decode(new t.BinaryReader($)));
    }
    UpdateGroupMetadata(A) {
      const W = e.MsgUpdateGroupMetadata.encode(A).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupMetadata", W).then(($) => e.MsgUpdateGroupMetadataResponse.decode(new t.BinaryReader($)));
    }
    CreateGroupPolicy(A) {
      const W = e.MsgCreateGroupPolicy.encode(A).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "CreateGroupPolicy", W).then(($) => e.MsgCreateGroupPolicyResponse.decode(new t.BinaryReader($)));
    }
    CreateGroupWithPolicy(A) {
      const W = e.MsgCreateGroupWithPolicy.encode(A).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "CreateGroupWithPolicy", W).then(($) => e.MsgCreateGroupWithPolicyResponse.decode(new t.BinaryReader($)));
    }
    UpdateGroupPolicyAdmin(A) {
      const W = e.MsgUpdateGroupPolicyAdmin.encode(A).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyAdmin", W).then(($) => e.MsgUpdateGroupPolicyAdminResponse.decode(new t.BinaryReader($)));
    }
    UpdateGroupPolicyDecisionPolicy(A) {
      const W = e.MsgUpdateGroupPolicyDecisionPolicy.encode(A).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyDecisionPolicy", W).then(($) => e.MsgUpdateGroupPolicyDecisionPolicyResponse.decode(new t.BinaryReader($)));
    }
    UpdateGroupPolicyMetadata(A) {
      const W = e.MsgUpdateGroupPolicyMetadata.encode(A).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyMetadata", W).then(($) => e.MsgUpdateGroupPolicyMetadataResponse.decode(new t.BinaryReader($)));
    }
    SubmitProposal(A) {
      const W = e.MsgSubmitProposal.encode(A).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "SubmitProposal", W).then(($) => e.MsgSubmitProposalResponse.decode(new t.BinaryReader($)));
    }
    WithdrawProposal(A) {
      const W = e.MsgWithdrawProposal.encode(A).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "WithdrawProposal", W).then(($) => e.MsgWithdrawProposalResponse.decode(new t.BinaryReader($)));
    }
    Vote(A) {
      const W = e.MsgVote.encode(A).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "Vote", W).then(($) => e.MsgVoteResponse.decode(new t.BinaryReader($)));
    }
    Exec(A) {
      const W = e.MsgExec.encode(A).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "Exec", W).then(($) => e.MsgExecResponse.decode(new t.BinaryReader($)));
    }
    LeaveGroup(A) {
      const W = e.MsgLeaveGroup.encode(A).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "LeaveGroup", W).then(($) => e.MsgLeaveGroupResponse.decode(new t.BinaryReader($)));
    }
  }
  e.MsgClientImpl = g;
})(Oh);
Object.defineProperty(Bs, "__esModule", { value: !0 });
Bs.groupTypes = void 0;
const Xe = Oh;
Bs.groupTypes = [
  ["/cosmos.group.v1.MsgCreateGroup", Xe.MsgCreateGroup],
  ["/cosmos.group.v1.MsgCreateGroupPolicy", Xe.MsgCreateGroupPolicy],
  ["/cosmos.group.v1.MsgCreateGroupWithPolicy", Xe.MsgCreateGroupWithPolicy],
  ["/cosmos.group.v1.MsgExec", Xe.MsgExec],
  ["/cosmos.group.v1.MsgLeaveGroup", Xe.MsgLeaveGroup],
  ["/cosmos.group.v1.MsgSubmitProposal", Xe.MsgSubmitProposal],
  ["/cosmos.group.v1.MsgUpdateGroupAdmin", Xe.MsgUpdateGroupAdmin],
  ["/cosmos.group.v1.MsgUpdateGroupMembers", Xe.MsgUpdateGroupMembers],
  ["/cosmos.group.v1.MsgUpdateGroupMetadata", Xe.MsgUpdateGroupMetadata],
  ["/cosmos.group.v1.MsgUpdateGroupPolicyAdmin", Xe.MsgUpdateGroupPolicyAdmin],
  ["/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy", Xe.MsgUpdateGroupPolicyDecisionPolicy],
  ["/cosmos.group.v1.MsgUpdateGroupPolicyMetadata", Xe.MsgUpdateGroupPolicyMetadata],
  ["/cosmos.group.v1.MsgVote", Xe.MsgVote],
  ["/cosmos.group.v1.MsgWithdrawProposal", Xe.MsgWithdrawProposal]
];
var yi = {}, To = {}, kn = {}, Ge = {}, wo = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.isMultisigThresholdPubkey = e.isSinglePubkey = e.pubkeyType = e.isSecp256k1Pubkey = e.isEd25519Pubkey = void 0;
  function n(f) {
    return f.type === "tendermint/PubKeyEd25519";
  }
  e.isEd25519Pubkey = n;
  function r(f) {
    return f.type === "tendermint/PubKeySecp256k1";
  }
  e.isSecp256k1Pubkey = r, e.pubkeyType = {
    /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/ed25519/ed25519.go#L22 */
    secp256k1: "tendermint/PubKeySecp256k1",
    /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/secp256k1/secp256k1.go#L23 */
    ed25519: "tendermint/PubKeyEd25519",
    /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/sr25519/codec.go#L12 */
    sr25519: "tendermint/PubKeySr25519",
    multisigThreshold: "tendermint/PubKeyMultisigThreshold"
  };
  function t(f) {
    return [e.pubkeyType.ed25519, e.pubkeyType.secp256k1, e.pubkeyType.sr25519].includes(f.type);
  }
  e.isSinglePubkey = t;
  function i(f) {
    return f.type === "tendermint/PubKeyMultisigThreshold";
  }
  e.isMultisigThresholdPubkey = i;
})(wo);
Object.defineProperty(Ge, "__esModule", { value: !0 });
Ge.encodeBech32Pubkey = Ge.encodeAminoPubkey = Ge.decodeBech32Pubkey = Ge.decodeAminoPubkey = Ge.encodeEd25519Pubkey = Ge.encodeSecp256k1Pubkey = void 0;
const un = Ke, zb = Ie, ao = Te, lt = wo;
function xb(e) {
  if (e.length !== 33 || e[0] !== 2 && e[0] !== 3)
    throw new Error("Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03");
  return {
    type: lt.pubkeyType.secp256k1,
    value: (0, un.toBase64)(e)
  };
}
Ge.encodeSecp256k1Pubkey = xb;
function Zb(e) {
  if (e.length !== 32)
    throw new Error("Ed25519 public key must be 32 bytes long");
  return {
    type: lt.pubkeyType.ed25519,
    value: (0, un.toBase64)(e)
  };
}
Ge.encodeEd25519Pubkey = Zb;
const tc = (0, un.fromHex)(
  "eb5ae98721"
  /* fixed length */
), rc = (0, un.fromHex)(
  "1624de6420"
  /* fixed length */
), yf = (0, un.fromHex)(
  "0dfb100520"
  /* fixed length */
), Aa = (0, un.fromHex)(
  "22c1f7e2"
  /* variable length not included */
);
function Lc(e) {
  if ((0, ao.arrayContentStartsWith)(e, tc)) {
    const n = e.slice(tc.length);
    if (n.length !== 33)
      throw new Error("Invalid rest data length. Expected 33 bytes (compressed secp256k1 pubkey).");
    return {
      type: lt.pubkeyType.secp256k1,
      value: (0, un.toBase64)(n)
    };
  } else if ((0, ao.arrayContentStartsWith)(e, rc)) {
    const n = e.slice(rc.length);
    if (n.length !== 32)
      throw new Error("Invalid rest data length. Expected 32 bytes (Ed25519 pubkey).");
    return {
      type: lt.pubkeyType.ed25519,
      value: (0, un.toBase64)(n)
    };
  } else if ((0, ao.arrayContentStartsWith)(e, yf)) {
    const n = e.slice(yf.length);
    if (n.length !== 32)
      throw new Error("Invalid rest data length. Expected 32 bytes (Sr25519 pubkey).");
    return {
      type: lt.pubkeyType.sr25519,
      value: (0, un.toBase64)(n)
    };
  } else {
    if ((0, ao.arrayContentStartsWith)(e, Aa))
      return Xb(e);
    throw new Error("Unsupported public key type. Amino data starts with: " + (0, un.toHex)(e.slice(0, 5)));
  }
}
Ge.decodeAminoPubkey = Lc;
function Yb(e) {
  const { data: n } = (0, un.fromBech32)(e);
  return Lc(n);
}
Ge.decodeBech32Pubkey = Yb;
function mf(e) {
  if (e.length < 1)
    throw new Error("Can't decode varint. EOF");
  if (e[0] > 127)
    throw new Error("Decoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.Varint implementation from the Go standard library and write some tests.");
  return [e[0], 1];
}
function Xb(e) {
  const n = Array.from(e), r = n.splice(0, Aa.length);
  if (!(0, ao.arrayContentStartsWith)(r, Aa))
    throw new Error("Invalid multisig prefix.");
  if (n.shift() != 8)
    throw new Error("Invalid multisig data. Expecting 0x08 prefix before threshold.");
  const [t, i] = mf(n);
  n.splice(0, i);
  const f = [];
  for (; n.length > 0; ) {
    if (n.shift() != 18)
      throw new Error("Invalid multisig data. Expecting 0x12 prefix before participant pubkey length.");
    const [S, w] = mf(n);
    if (n.splice(0, w), n.length < S)
      throw new Error("Invalid multisig data length.");
    const T = n.splice(0, S), J = Lc(Uint8Array.from(T));
    f.push(J);
  }
  return {
    type: lt.pubkeyType.multisigThreshold,
    value: {
      threshold: t.toString(),
      pubkeys: f
    }
  };
}
function gf(e) {
  const n = zb.Uint53.fromString(e.toString()).toNumber();
  if (n > 127)
    throw new Error("Encoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.PutUvarint implementation from the Go standard library and write some tests.");
  return [n];
}
function Gc(e) {
  if ((0, lt.isMultisigThresholdPubkey)(e)) {
    const n = Array.from(Aa);
    n.push(8), n.push(...gf(e.value.threshold));
    for (const r of e.value.pubkeys.map((t) => Gc(t)))
      n.push(18), n.push(...gf(r.length)), n.push(...r);
    return new Uint8Array(n);
  } else {
    if ((0, lt.isEd25519Pubkey)(e))
      return new Uint8Array([...rc, ...(0, un.fromBase64)(e.value)]);
    if ((0, lt.isSecp256k1Pubkey)(e))
      return new Uint8Array([...tc, ...(0, un.fromBase64)(e.value)]);
    throw new Error("Unsupported pubkey type");
  }
}
Ge.encodeAminoPubkey = Gc;
function jb(e, n) {
  return (0, un.toBech32)(n, Gc(e));
}
Ge.encodeBech32Pubkey = jb;
Object.defineProperty(kn, "__esModule", { value: !0 });
kn.pubkeyToAddress = kn.pubkeyToRawAddress = kn.rawSecp256k1PubkeyToRawAddress = kn.rawEd25519PubkeyToRawAddress = void 0;
const Ia = _e, ic = Ke, eR = Ge, lu = wo;
function Ih(e) {
  if (e.length !== 32)
    throw new Error(`Invalid Ed25519 pubkey length: ${e.length}`);
  return (0, Ia.sha256)(e).slice(0, 20);
}
kn.rawEd25519PubkeyToRawAddress = Ih;
function Th(e) {
  if (e.length !== 33)
    throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${e.length}`);
  return (0, Ia.ripemd160)((0, Ia.sha256)(e));
}
kn.rawSecp256k1PubkeyToRawAddress = Th;
function wh(e) {
  if ((0, lu.isSecp256k1Pubkey)(e)) {
    const n = (0, ic.fromBase64)(e.value);
    return Th(n);
  } else if ((0, lu.isEd25519Pubkey)(e)) {
    const n = (0, ic.fromBase64)(e.value);
    return Ih(n);
  } else if ((0, lu.isMultisigThresholdPubkey)(e)) {
    const n = (0, eR.encodeAminoPubkey)(e);
    return (0, Ia.sha256)(n).slice(0, 20);
  } else
    throw new Error("Unsupported public key type");
}
kn.pubkeyToRawAddress = wh;
function nR(e, n) {
  return (0, ic.toBech32)(n, wh(e));
}
kn.pubkeyToAddress = nR;
var rt = {};
Object.defineProperty(rt, "__esModule", { value: !0 });
rt.addCoins = rt.parseCoins = rt.coins = rt.coin = void 0;
const oc = Ie;
function Ch(e, n) {
  let r;
  if (typeof e == "number")
    try {
      r = new oc.Uint53(e).toString();
    } catch {
      throw new Error("Given amount is not a safe integer. Consider using a string instead to overcome the limitations of JS numbers.");
    }
  else {
    if (!e.match(/^[0-9]+$/))
      throw new Error("Invalid unsigned integer string format");
    r = e.replace(/^0*/, "") || "0";
  }
  return {
    amount: r,
    denom: n
  };
}
rt.coin = Ch;
function tR(e, n) {
  return [Ch(e, n)];
}
rt.coins = tR;
function rR(e) {
  return e.replace(/\s/g, "").split(",").filter(Boolean).map((n) => {
    const r = n.match(/^([0-9]+)([a-zA-Z][a-zA-Z0-9/]{2,127})$/);
    if (!r)
      throw new Error("Got an invalid coin string");
    return {
      amount: r[1].replace(/^0+/, "") || "0",
      denom: r[2]
    };
  });
}
rt.parseCoins = rR;
function iR(e, n) {
  if (e.denom !== n.denom)
    throw new Error("Trying to add two coins with different denoms");
  return {
    amount: oc.Decimal.fromAtomics(e.amount, 0).plus(oc.Decimal.fromAtomics(n.amount, 0)).atomics,
    denom: e.denom
  };
}
rt.addCoins = iR;
var mi = {};
Object.defineProperty(mi, "__esModule", { value: !0 });
mi.createMultisigThresholdPubkey = mi.compareArrays = void 0;
const Sf = Ke, oR = Ie, kf = kn;
function Nh(e, n) {
  const r = (0, Sf.toHex)(e), t = (0, Sf.toHex)(n);
  return r === t ? 0 : r < t ? -1 : 1;
}
mi.compareArrays = Nh;
function aR(e, n, r = !1) {
  const t = new oR.Uint53(n);
  if (t.toNumber() > e.length)
    throw new Error(`Threshold k = ${t.toNumber()} exceeds number of keys n = ${e.length}`);
  const i = r ? e : Array.from(e).sort((f, S) => {
    const w = (0, kf.pubkeyToRawAddress)(f), T = (0, kf.pubkeyToRawAddress)(S);
    return Nh(w, T);
  });
  return {
    type: "tendermint/PubKeyMultisigThreshold",
    value: {
      threshold: t.toString(),
      pubkeys: i
    }
  };
}
mi.createMultisigThresholdPubkey = aR;
var Os = {};
Object.defineProperty(Os, "__esModule", { value: !0 });
Os.omitDefault = void 0;
function sR(e) {
  switch (typeof e) {
    case "string":
      return e === "" ? void 0 : e;
    case "number":
      return e === 0 ? void 0 : e;
    case "bigint":
      return e === BigInt(0) ? void 0 : e;
    case "boolean":
      return e || void 0;
    default:
      throw new Error(`Got unsupported type '${typeof e}'`);
  }
}
Os.omitDefault = sR;
var Co = {};
Object.defineProperty(Co, "__esModule", { value: !0 });
Co.makeCosmoshubPath = void 0;
const Yi = _e;
function dR(e) {
  return [
    Yi.Slip10RawIndex.hardened(44),
    Yi.Slip10RawIndex.hardened(118),
    Yi.Slip10RawIndex.hardened(0),
    Yi.Slip10RawIndex.normal(0),
    Yi.Slip10RawIndex.normal(e)
  ];
}
Co.makeCosmoshubPath = dR;
var gi = {}, Wt = {};
Object.defineProperty(Wt, "__esModule", { value: !0 });
Wt.decodeSignature = Wt.encodeSecp256k1Signature = void 0;
const ac = Ke, uR = Ge, cR = wo;
function lR(e, n) {
  if (n.length !== 64)
    throw new Error("Signature must be 64 bytes long. Cosmos SDK uses a 2x32 byte fixed length encoding for the secp256k1 signature integers r and s.");
  return {
    pub_key: (0, uR.encodeSecp256k1Pubkey)(e),
    signature: (0, ac.toBase64)(n)
  };
}
Wt.encodeSecp256k1Signature = lR;
function fR(e) {
  switch (e.pub_key.type) {
    case cR.pubkeyType.secp256k1:
      return {
        pubkey: (0, ac.fromBase64)(e.pub_key.value),
        signature: (0, ac.fromBase64)(e.signature)
      };
    default:
      throw new Error("Unsupported pubkey type");
  }
}
Wt.decodeSignature = fR;
var Mn = {};
Object.defineProperty(Mn, "__esModule", { value: !0 });
Mn.serializeSignDoc = Mn.escapeCharacters = Mn.makeSignDoc = Mn.sortedJsonStringify = void 0;
const pR = Ke, Pf = Ie;
function sc(e) {
  if (typeof e != "object" || e === null)
    return e;
  if (Array.isArray(e))
    return e.map(sc);
  const n = Object.keys(e).sort(), r = {};
  return n.forEach((t) => {
    r[t] = sc(e[t]);
  }), r;
}
function _h(e) {
  return JSON.stringify(sc(e));
}
Mn.sortedJsonStringify = _h;
function hR(e, n, r, t, i, f, S) {
  return {
    chain_id: r,
    account_number: Pf.Uint53.fromString(i.toString()).toString(),
    sequence: Pf.Uint53.fromString(f.toString()).toString(),
    fee: n,
    msgs: e,
    memo: t || "",
    ...S && { timeout_height: S.toString() }
  };
}
Mn.makeSignDoc = hR;
function Eh(e) {
  const n = /&/g, r = /</g, t = />/g;
  return e.replace(n, "\\u0026").replace(r, "\\u003c").replace(t, "\\u003e");
}
Mn.escapeCharacters = Eh;
function yR(e) {
  const n = Eh(_h(e));
  return (0, pR.toUtf8)(n);
}
Mn.serializeSignDoc = yR;
var Kc = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.decrypt = e.encrypt = e.supportedAlgorithms = e.executeKdf = e.cosmjsSalt = void 0;
  const n = _e, r = Ke;
  e.cosmjsSalt = (0, r.toAscii)("The CosmJS salt.");
  async function t(S, w) {
    switch (w.algorithm) {
      case "argon2id": {
        const T = w.params;
        if (!(0, n.isArgon2idOptions)(T))
          throw new Error("Invalid format of argon2id params");
        return n.Argon2id.execute(S, e.cosmjsSalt, T);
      }
      default:
        throw new Error("Unsupported KDF algorithm");
    }
  }
  e.executeKdf = t, e.supportedAlgorithms = {
    xchacha20poly1305Ietf: "xchacha20poly1305-ietf"
  };
  async function i(S, w, T) {
    switch (T.algorithm) {
      case e.supportedAlgorithms.xchacha20poly1305Ietf: {
        const J = n.Random.getBytes(n.xchacha20NonceLength);
        return new Uint8Array([
          ...J,
          ...await n.Xchacha20poly1305Ietf.encrypt(S, w, J)
        ]);
      }
      default:
        throw new Error(`Unsupported encryption algorithm: '${T.algorithm}'`);
    }
  }
  e.encrypt = i;
  async function f(S, w, T) {
    switch (T.algorithm) {
      case e.supportedAlgorithms.xchacha20poly1305Ietf: {
        const J = S.slice(0, n.xchacha20NonceLength);
        return n.Xchacha20poly1305Ietf.decrypt(S.slice(n.xchacha20NonceLength), w, J);
      }
      default:
        throw new Error(`Unsupported encryption algorithm: '${T.algorithm}'`);
    }
  }
  e.decrypt = f;
})(Kc);
Object.defineProperty(gi, "__esModule", { value: !0 });
gi.Secp256k1HdWallet = gi.extractKdfConfiguration = void 0;
const On = _e, Xi = Ke, Ir = Te, mR = kn, gR = Co, SR = Wt, kR = Mn, ji = Kc, pa = "secp256k1wallet-v1", PR = {
  algorithm: "argon2id",
  params: {
    outputLength: 32,
    opsLimit: 24,
    memLimitKib: 12 * 1024
  }
};
function vR(e) {
  return !(!(0, Ir.isNonNullObject)(e) || typeof e.hdPath != "string" || typeof e.prefix != "string");
}
function bR(e) {
  return e.kdf;
}
function RR(e) {
  const n = JSON.parse(e);
  if (!(0, Ir.isNonNullObject)(n))
    throw new Error("Root document is not an object.");
  switch (n.type) {
    case pa:
      return bR(n);
    default:
      throw new Error("Unsupported serialization type");
  }
}
gi.extractKdfConfiguration = RR;
const vf = {
  bip39Password: "",
  hdPaths: [(0, gR.makeCosmoshubPath)(0)],
  prefix: "cosmos"
};
class Zt {
  /**
   * Restores a wallet from the given BIP39 mnemonic.
   *
   * @param mnemonic Any valid English mnemonic.
   * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
   */
  static async fromMnemonic(n, r = {}) {
    const t = new On.EnglishMnemonic(n), i = await On.Bip39.mnemonicToSeed(t, r.bip39Password);
    return new Zt(t, {
      ...r,
      seed: i
    });
  }
  /**
   * Generates a new wallet with a BIP39 mnemonic of the given length.
   *
   * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
   * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
   */
  static async generate(n = 12, r = {}) {
    const t = 4 * Math.floor(11 * n / 33), i = On.Random.getBytes(t), f = On.Bip39.encode(i);
    return Zt.fromMnemonic(f.toString(), r);
  }
  /**
   * Restores a wallet from an encrypted serialization.
   *
   * @param password The user provided password used to generate an encryption key via a KDF.
   *                 This is not normalized internally (see "Unicode normalization" to learn more).
   */
  static async deserialize(n, r) {
    const t = JSON.parse(n);
    if (!(0, Ir.isNonNullObject)(t))
      throw new Error("Root document is not an object.");
    switch (t.type) {
      case pa:
        return Zt.deserializeTypeV1(n, r);
      default:
        throw new Error("Unsupported serialization type");
    }
  }
  /**
   * Restores a wallet from an encrypted serialization.
   *
   * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
   * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
   *
   * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
   * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
   */
  static async deserializeWithEncryptionKey(n, r) {
    const t = JSON.parse(n);
    if (!(0, Ir.isNonNullObject)(t))
      throw new Error("Root document is not an object.");
    const i = t;
    switch (i.type) {
      case pa: {
        const f = await (0, ji.decrypt)((0, Xi.fromBase64)(i.data), r, i.encryption), S = JSON.parse((0, Xi.fromUtf8)(f)), { mnemonic: w, accounts: T } = S;
        if ((0, Ir.assert)(typeof w == "string"), !Array.isArray(T))
          throw new Error("Property 'accounts' is not an array");
        if (!T.every((R) => vR(R)))
          throw new Error("Account is not in the correct format.");
        const J = T[0].prefix;
        if (!T.every(({ prefix: R }) => R === J))
          throw new Error("Accounts do not all have the same prefix");
        const C = T.map(({ hdPath: R }) => (0, On.stringToPath)(R));
        return Zt.fromMnemonic(w, {
          hdPaths: C,
          prefix: J
        });
      }
      default:
        throw new Error("Unsupported serialization type");
    }
  }
  static async deserializeTypeV1(n, r) {
    const t = JSON.parse(n);
    if (!(0, Ir.isNonNullObject)(t))
      throw new Error("Root document is not an object.");
    const i = await (0, ji.executeKdf)(r, t.kdf);
    return Zt.deserializeWithEncryptionKey(n, i);
  }
  constructor(n, r) {
    const t = r.hdPaths ?? vf.hdPaths, i = r.prefix ?? vf.prefix;
    this.secret = n, this.seed = r.seed, this.accounts = t.map((f) => ({
      hdPath: f,
      prefix: i
    }));
  }
  get mnemonic() {
    return this.secret.toString();
  }
  async getAccounts() {
    return (await this.getAccountsWithPrivkeys()).map(({ algo: r, pubkey: t, address: i }) => ({
      algo: r,
      pubkey: t,
      address: i
    }));
  }
  async signAmino(n, r) {
    const i = (await this.getAccountsWithPrivkeys()).find(({ address: C }) => C === n);
    if (i === void 0)
      throw new Error(`Address ${n} not found in wallet`);
    const { privkey: f, pubkey: S } = i, w = (0, On.sha256)((0, kR.serializeSignDoc)(r)), T = await On.Secp256k1.createSignature(w, f), J = new Uint8Array([...T.r(32), ...T.s(32)]);
    return {
      signed: r,
      signature: (0, SR.encodeSecp256k1Signature)(S, J)
    };
  }
  /**
   * Generates an encrypted serialization of this wallet.
   *
   * @param password The user provided password used to generate an encryption key via a KDF.
   *                 This is not normalized internally (see "Unicode normalization" to learn more).
   */
  async serialize(n) {
    const r = PR, t = await (0, ji.executeKdf)(n, r);
    return this.serializeWithEncryptionKey(t, r);
  }
  /**
   * Generates an encrypted serialization of this wallet.
   *
   * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
   * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
   *
   * The caller is responsible for ensuring the key was derived with the given KDF options. If this
   * is not the case, the wallet cannot be restored with the original password.
   */
  async serializeWithEncryptionKey(n, r) {
    const t = {
      mnemonic: this.mnemonic,
      accounts: this.accounts.map(({ hdPath: T, prefix: J }) => ({
        hdPath: (0, On.pathToString)(T),
        prefix: J
      }))
    }, i = (0, Xi.toUtf8)(JSON.stringify(t)), f = {
      algorithm: ji.supportedAlgorithms.xchacha20poly1305Ietf
    }, S = await (0, ji.encrypt)(i, n, f), w = {
      type: pa,
      kdf: r,
      encryption: f,
      data: (0, Xi.toBase64)(S)
    };
    return JSON.stringify(w);
  }
  async getKeyPair(n) {
    const { privkey: r } = On.Slip10.derivePath(On.Slip10Curve.Secp256k1, this.seed, n), { pubkey: t } = await On.Secp256k1.makeKeypair(r);
    return {
      privkey: r,
      pubkey: On.Secp256k1.compressPubkey(t)
    };
  }
  async getAccountsWithPrivkeys() {
    return Promise.all(this.accounts.map(async ({ hdPath: n, prefix: r }) => {
      const { privkey: t, pubkey: i } = await this.getKeyPair(n), f = (0, Xi.toBech32)(r, (0, mR.rawSecp256k1PubkeyToRawAddress)(i));
      return {
        algo: "secp256k1",
        privkey: t,
        pubkey: i,
        address: f
      };
    }));
  }
}
gi.Secp256k1HdWallet = Zt;
var As = {};
Object.defineProperty(As, "__esModule", { value: !0 });
As.Secp256k1Wallet = void 0;
const xo = _e, BR = Ke, OR = kn, AR = Wt, IR = Mn;
class zc {
  /**
   * Creates a Secp256k1Wallet from the given private key
   *
   * @param privkey The private key.
   * @param prefix The bech32 address prefix (human readable part). Defaults to "cosmos".
   */
  static async fromKey(n, r = "cosmos") {
    const t = (await xo.Secp256k1.makeKeypair(n)).pubkey;
    return new zc(n, xo.Secp256k1.compressPubkey(t), r);
  }
  constructor(n, r, t) {
    this.privkey = n, this.pubkey = r, this.prefix = t;
  }
  get address() {
    return (0, BR.toBech32)(this.prefix, (0, OR.rawSecp256k1PubkeyToRawAddress)(this.pubkey));
  }
  async getAccounts() {
    return [
      {
        algo: "secp256k1",
        address: this.address,
        pubkey: this.pubkey
      }
    ];
  }
  async signAmino(n, r) {
    if (n !== this.address)
      throw new Error(`Address ${n} not found in wallet`);
    const t = new xo.Sha256((0, IR.serializeSignDoc)(r)).digest(), i = await xo.Secp256k1.createSignature(t, this.privkey), f = new Uint8Array([...i.r(32), ...i.s(32)]);
    return {
      signed: r,
      signature: (0, AR.encodeSecp256k1Signature)(this.pubkey, f)
    };
  }
}
As.Secp256k1Wallet = zc;
var Si = {};
Object.defineProperty(Si, "__esModule", { value: !0 });
Si.makeStdTx = Si.isStdTx = void 0;
function TR(e) {
  const { memo: n, msg: r, fee: t, signatures: i } = e;
  return typeof n == "string" && Array.isArray(r) && typeof t == "object" && Array.isArray(i);
}
Si.isStdTx = TR;
function wR(e, n) {
  return {
    msg: e.msgs,
    fee: e.fee,
    memo: e.memo,
    signatures: Array.isArray(n) ? n : [n]
  };
}
Si.makeStdTx = wR;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.executeKdf = e.makeStdTx = e.isStdTx = e.serializeSignDoc = e.makeSignDoc = e.encodeSecp256k1Signature = e.decodeSignature = e.Secp256k1Wallet = e.Secp256k1HdWallet = e.extractKdfConfiguration = e.pubkeyType = e.isSinglePubkey = e.isSecp256k1Pubkey = e.isMultisigThresholdPubkey = e.isEd25519Pubkey = e.makeCosmoshubPath = e.omitDefault = e.createMultisigThresholdPubkey = e.encodeSecp256k1Pubkey = e.encodeEd25519Pubkey = e.encodeBech32Pubkey = e.encodeAminoPubkey = e.decodeBech32Pubkey = e.decodeAminoPubkey = e.parseCoins = e.coins = e.coin = e.addCoins = e.rawSecp256k1PubkeyToRawAddress = e.rawEd25519PubkeyToRawAddress = e.pubkeyToRawAddress = e.pubkeyToAddress = void 0;
  var n = kn;
  Object.defineProperty(e, "pubkeyToAddress", { enumerable: !0, get: function() {
    return n.pubkeyToAddress;
  } }), Object.defineProperty(e, "pubkeyToRawAddress", { enumerable: !0, get: function() {
    return n.pubkeyToRawAddress;
  } }), Object.defineProperty(e, "rawEd25519PubkeyToRawAddress", { enumerable: !0, get: function() {
    return n.rawEd25519PubkeyToRawAddress;
  } }), Object.defineProperty(e, "rawSecp256k1PubkeyToRawAddress", { enumerable: !0, get: function() {
    return n.rawSecp256k1PubkeyToRawAddress;
  } });
  var r = rt;
  Object.defineProperty(e, "addCoins", { enumerable: !0, get: function() {
    return r.addCoins;
  } }), Object.defineProperty(e, "coin", { enumerable: !0, get: function() {
    return r.coin;
  } }), Object.defineProperty(e, "coins", { enumerable: !0, get: function() {
    return r.coins;
  } }), Object.defineProperty(e, "parseCoins", { enumerable: !0, get: function() {
    return r.parseCoins;
  } });
  var t = Ge;
  Object.defineProperty(e, "decodeAminoPubkey", { enumerable: !0, get: function() {
    return t.decodeAminoPubkey;
  } }), Object.defineProperty(e, "decodeBech32Pubkey", { enumerable: !0, get: function() {
    return t.decodeBech32Pubkey;
  } }), Object.defineProperty(e, "encodeAminoPubkey", { enumerable: !0, get: function() {
    return t.encodeAminoPubkey;
  } }), Object.defineProperty(e, "encodeBech32Pubkey", { enumerable: !0, get: function() {
    return t.encodeBech32Pubkey;
  } }), Object.defineProperty(e, "encodeEd25519Pubkey", { enumerable: !0, get: function() {
    return t.encodeEd25519Pubkey;
  } }), Object.defineProperty(e, "encodeSecp256k1Pubkey", { enumerable: !0, get: function() {
    return t.encodeSecp256k1Pubkey;
  } });
  var i = mi;
  Object.defineProperty(e, "createMultisigThresholdPubkey", { enumerable: !0, get: function() {
    return i.createMultisigThresholdPubkey;
  } });
  var f = Os;
  Object.defineProperty(e, "omitDefault", { enumerable: !0, get: function() {
    return f.omitDefault;
  } });
  var S = Co;
  Object.defineProperty(e, "makeCosmoshubPath", { enumerable: !0, get: function() {
    return S.makeCosmoshubPath;
  } });
  var w = wo;
  Object.defineProperty(e, "isEd25519Pubkey", { enumerable: !0, get: function() {
    return w.isEd25519Pubkey;
  } }), Object.defineProperty(e, "isMultisigThresholdPubkey", { enumerable: !0, get: function() {
    return w.isMultisigThresholdPubkey;
  } }), Object.defineProperty(e, "isSecp256k1Pubkey", { enumerable: !0, get: function() {
    return w.isSecp256k1Pubkey;
  } }), Object.defineProperty(e, "isSinglePubkey", { enumerable: !0, get: function() {
    return w.isSinglePubkey;
  } }), Object.defineProperty(e, "pubkeyType", { enumerable: !0, get: function() {
    return w.pubkeyType;
  } });
  var T = gi;
  Object.defineProperty(e, "extractKdfConfiguration", { enumerable: !0, get: function() {
    return T.extractKdfConfiguration;
  } }), Object.defineProperty(e, "Secp256k1HdWallet", { enumerable: !0, get: function() {
    return T.Secp256k1HdWallet;
  } });
  var J = As;
  Object.defineProperty(e, "Secp256k1Wallet", { enumerable: !0, get: function() {
    return J.Secp256k1Wallet;
  } });
  var C = Wt;
  Object.defineProperty(e, "decodeSignature", { enumerable: !0, get: function() {
    return C.decodeSignature;
  } }), Object.defineProperty(e, "encodeSecp256k1Signature", { enumerable: !0, get: function() {
    return C.encodeSecp256k1Signature;
  } });
  var R = Mn;
  Object.defineProperty(e, "makeSignDoc", { enumerable: !0, get: function() {
    return R.makeSignDoc;
  } }), Object.defineProperty(e, "serializeSignDoc", { enumerable: !0, get: function() {
    return R.serializeSignDoc;
  } });
  var p = Si;
  Object.defineProperty(e, "isStdTx", { enumerable: !0, get: function() {
    return p.isStdTx;
  } }), Object.defineProperty(e, "makeStdTx", { enumerable: !0, get: function() {
    return p.makeStdTx;
  } });
  var m = Kc;
  Object.defineProperty(e, "executeKdf", { enumerable: !0, get: function() {
    return m.executeKdf;
  } });
})(To);
var Is = {}, yt = {}, Uh = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ModuleVersion = e.CancelSoftwareUpgradeProposal = e.SoftwareUpgradeProposal = e.Plan = e.protobufPackage = void 0;
  const n = Je, r = Pe, t = re, i = ie;
  e.protobufPackage = "cosmos.upgrade.v1beta1";
  function f() {
    return {
      name: "",
      time: n.Timestamp.fromPartial({}),
      height: BigInt(0),
      info: "",
      upgradedClientState: void 0
    };
  }
  e.Plan = {
    typeUrl: "/cosmos.upgrade.v1beta1.Plan",
    encode(J, C = t.BinaryWriter.create()) {
      return J.name !== "" && C.uint32(10).string(J.name), J.time !== void 0 && n.Timestamp.encode(J.time, C.uint32(18).fork()).ldelim(), J.height !== BigInt(0) && C.uint32(24).int64(J.height), J.info !== "" && C.uint32(34).string(J.info), J.upgradedClientState !== void 0 && r.Any.encode(J.upgradedClientState, C.uint32(42).fork()).ldelim(), C;
    },
    decode(J, C) {
      const R = J instanceof t.BinaryReader ? J : new t.BinaryReader(J);
      let p = C === void 0 ? R.len : R.pos + C;
      const m = f();
      for (; R.pos < p; ) {
        const v = R.uint32();
        switch (v >>> 3) {
          case 1:
            m.name = R.string();
            break;
          case 2:
            m.time = n.Timestamp.decode(R, R.uint32());
            break;
          case 3:
            m.height = R.int64();
            break;
          case 4:
            m.info = R.string();
            break;
          case 5:
            m.upgradedClientState = r.Any.decode(R, R.uint32());
            break;
          default:
            R.skipType(v & 7);
            break;
        }
      }
      return m;
    },
    fromJSON(J) {
      const C = f();
      return (0, i.isSet)(J.name) && (C.name = String(J.name)), (0, i.isSet)(J.time) && (C.time = (0, i.fromJsonTimestamp)(J.time)), (0, i.isSet)(J.height) && (C.height = BigInt(J.height.toString())), (0, i.isSet)(J.info) && (C.info = String(J.info)), (0, i.isSet)(J.upgradedClientState) && (C.upgradedClientState = r.Any.fromJSON(J.upgradedClientState)), C;
    },
    toJSON(J) {
      const C = {};
      return J.name !== void 0 && (C.name = J.name), J.time !== void 0 && (C.time = (0, i.fromTimestamp)(J.time).toISOString()), J.height !== void 0 && (C.height = (J.height || BigInt(0)).toString()), J.info !== void 0 && (C.info = J.info), J.upgradedClientState !== void 0 && (C.upgradedClientState = J.upgradedClientState ? r.Any.toJSON(J.upgradedClientState) : void 0), C;
    },
    fromPartial(J) {
      const C = f();
      return C.name = J.name ?? "", J.time !== void 0 && J.time !== null && (C.time = n.Timestamp.fromPartial(J.time)), J.height !== void 0 && J.height !== null && (C.height = BigInt(J.height.toString())), C.info = J.info ?? "", J.upgradedClientState !== void 0 && J.upgradedClientState !== null && (C.upgradedClientState = r.Any.fromPartial(J.upgradedClientState)), C;
    }
  };
  function S() {
    return {
      title: "",
      description: "",
      plan: e.Plan.fromPartial({})
    };
  }
  e.SoftwareUpgradeProposal = {
    typeUrl: "/cosmos.upgrade.v1beta1.SoftwareUpgradeProposal",
    encode(J, C = t.BinaryWriter.create()) {
      return J.title !== "" && C.uint32(10).string(J.title), J.description !== "" && C.uint32(18).string(J.description), J.plan !== void 0 && e.Plan.encode(J.plan, C.uint32(26).fork()).ldelim(), C;
    },
    decode(J, C) {
      const R = J instanceof t.BinaryReader ? J : new t.BinaryReader(J);
      let p = C === void 0 ? R.len : R.pos + C;
      const m = S();
      for (; R.pos < p; ) {
        const v = R.uint32();
        switch (v >>> 3) {
          case 1:
            m.title = R.string();
            break;
          case 2:
            m.description = R.string();
            break;
          case 3:
            m.plan = e.Plan.decode(R, R.uint32());
            break;
          default:
            R.skipType(v & 7);
            break;
        }
      }
      return m;
    },
    fromJSON(J) {
      const C = S();
      return (0, i.isSet)(J.title) && (C.title = String(J.title)), (0, i.isSet)(J.description) && (C.description = String(J.description)), (0, i.isSet)(J.plan) && (C.plan = e.Plan.fromJSON(J.plan)), C;
    },
    toJSON(J) {
      const C = {};
      return J.title !== void 0 && (C.title = J.title), J.description !== void 0 && (C.description = J.description), J.plan !== void 0 && (C.plan = J.plan ? e.Plan.toJSON(J.plan) : void 0), C;
    },
    fromPartial(J) {
      const C = S();
      return C.title = J.title ?? "", C.description = J.description ?? "", J.plan !== void 0 && J.plan !== null && (C.plan = e.Plan.fromPartial(J.plan)), C;
    }
  };
  function w() {
    return {
      title: "",
      description: ""
    };
  }
  e.CancelSoftwareUpgradeProposal = {
    typeUrl: "/cosmos.upgrade.v1beta1.CancelSoftwareUpgradeProposal",
    encode(J, C = t.BinaryWriter.create()) {
      return J.title !== "" && C.uint32(10).string(J.title), J.description !== "" && C.uint32(18).string(J.description), C;
    },
    decode(J, C) {
      const R = J instanceof t.BinaryReader ? J : new t.BinaryReader(J);
      let p = C === void 0 ? R.len : R.pos + C;
      const m = w();
      for (; R.pos < p; ) {
        const v = R.uint32();
        switch (v >>> 3) {
          case 1:
            m.title = R.string();
            break;
          case 2:
            m.description = R.string();
            break;
          default:
            R.skipType(v & 7);
            break;
        }
      }
      return m;
    },
    fromJSON(J) {
      const C = w();
      return (0, i.isSet)(J.title) && (C.title = String(J.title)), (0, i.isSet)(J.description) && (C.description = String(J.description)), C;
    },
    toJSON(J) {
      const C = {};
      return J.title !== void 0 && (C.title = J.title), J.description !== void 0 && (C.description = J.description), C;
    },
    fromPartial(J) {
      const C = w();
      return C.title = J.title ?? "", C.description = J.description ?? "", C;
    }
  };
  function T() {
    return {
      name: "",
      version: BigInt(0)
    };
  }
  e.ModuleVersion = {
    typeUrl: "/cosmos.upgrade.v1beta1.ModuleVersion",
    encode(J, C = t.BinaryWriter.create()) {
      return J.name !== "" && C.uint32(10).string(J.name), J.version !== BigInt(0) && C.uint32(16).uint64(J.version), C;
    },
    decode(J, C) {
      const R = J instanceof t.BinaryReader ? J : new t.BinaryReader(J);
      let p = C === void 0 ? R.len : R.pos + C;
      const m = T();
      for (; R.pos < p; ) {
        const v = R.uint32();
        switch (v >>> 3) {
          case 1:
            m.name = R.string();
            break;
          case 2:
            m.version = R.uint64();
            break;
          default:
            R.skipType(v & 7);
            break;
        }
      }
      return m;
    },
    fromJSON(J) {
      const C = T();
      return (0, i.isSet)(J.name) && (C.name = String(J.name)), (0, i.isSet)(J.version) && (C.version = BigInt(J.version.toString())), C;
    },
    toJSON(J) {
      const C = {};
      return J.name !== void 0 && (C.name = J.name), J.version !== void 0 && (C.version = (J.version || BigInt(0)).toString()), C;
    },
    fromPartial(J) {
      const C = T();
      return C.name = J.name ?? "", J.version !== void 0 && J.version !== null && (C.version = BigInt(J.version.toString())), C;
    }
  };
})(Uh);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Params = e.Height = e.UpgradeProposal = e.ClientUpdateProposal = e.ClientConsensusStates = e.ConsensusStateWithHeight = e.IdentifiedClientState = e.protobufPackage = void 0;
  const n = Pe, r = Uh, t = re, i = ie;
  e.protobufPackage = "ibc.core.client.v1";
  function f() {
    return {
      clientId: "",
      clientState: void 0
    };
  }
  e.IdentifiedClientState = {
    typeUrl: "/ibc.core.client.v1.IdentifiedClientState",
    encode(p, m = t.BinaryWriter.create()) {
      return p.clientId !== "" && m.uint32(10).string(p.clientId), p.clientState !== void 0 && n.Any.encode(p.clientState, m.uint32(18).fork()).ldelim(), m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = f();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.clientId = v.string();
            break;
          case 2:
            d.clientState = n.Any.decode(v, v.uint32());
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = f();
      return (0, i.isSet)(p.clientId) && (m.clientId = String(p.clientId)), (0, i.isSet)(p.clientState) && (m.clientState = n.Any.fromJSON(p.clientState)), m;
    },
    toJSON(p) {
      const m = {};
      return p.clientId !== void 0 && (m.clientId = p.clientId), p.clientState !== void 0 && (m.clientState = p.clientState ? n.Any.toJSON(p.clientState) : void 0), m;
    },
    fromPartial(p) {
      const m = f();
      return m.clientId = p.clientId ?? "", p.clientState !== void 0 && p.clientState !== null && (m.clientState = n.Any.fromPartial(p.clientState)), m;
    }
  };
  function S() {
    return {
      height: e.Height.fromPartial({}),
      consensusState: void 0
    };
  }
  e.ConsensusStateWithHeight = {
    typeUrl: "/ibc.core.client.v1.ConsensusStateWithHeight",
    encode(p, m = t.BinaryWriter.create()) {
      return p.height !== void 0 && e.Height.encode(p.height, m.uint32(10).fork()).ldelim(), p.consensusState !== void 0 && n.Any.encode(p.consensusState, m.uint32(18).fork()).ldelim(), m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = S();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.height = e.Height.decode(v, v.uint32());
            break;
          case 2:
            d.consensusState = n.Any.decode(v, v.uint32());
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = S();
      return (0, i.isSet)(p.height) && (m.height = e.Height.fromJSON(p.height)), (0, i.isSet)(p.consensusState) && (m.consensusState = n.Any.fromJSON(p.consensusState)), m;
    },
    toJSON(p) {
      const m = {};
      return p.height !== void 0 && (m.height = p.height ? e.Height.toJSON(p.height) : void 0), p.consensusState !== void 0 && (m.consensusState = p.consensusState ? n.Any.toJSON(p.consensusState) : void 0), m;
    },
    fromPartial(p) {
      const m = S();
      return p.height !== void 0 && p.height !== null && (m.height = e.Height.fromPartial(p.height)), p.consensusState !== void 0 && p.consensusState !== null && (m.consensusState = n.Any.fromPartial(p.consensusState)), m;
    }
  };
  function w() {
    return {
      clientId: "",
      consensusStates: []
    };
  }
  e.ClientConsensusStates = {
    typeUrl: "/ibc.core.client.v1.ClientConsensusStates",
    encode(p, m = t.BinaryWriter.create()) {
      p.clientId !== "" && m.uint32(10).string(p.clientId);
      for (const v of p.consensusStates)
        e.ConsensusStateWithHeight.encode(v, m.uint32(18).fork()).ldelim();
      return m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = w();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.clientId = v.string();
            break;
          case 2:
            d.consensusStates.push(e.ConsensusStateWithHeight.decode(v, v.uint32()));
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = w();
      return (0, i.isSet)(p.clientId) && (m.clientId = String(p.clientId)), Array.isArray(p == null ? void 0 : p.consensusStates) && (m.consensusStates = p.consensusStates.map((v) => e.ConsensusStateWithHeight.fromJSON(v))), m;
    },
    toJSON(p) {
      const m = {};
      return p.clientId !== void 0 && (m.clientId = p.clientId), p.consensusStates ? m.consensusStates = p.consensusStates.map((v) => v ? e.ConsensusStateWithHeight.toJSON(v) : void 0) : m.consensusStates = [], m;
    },
    fromPartial(p) {
      var v;
      const m = w();
      return m.clientId = p.clientId ?? "", m.consensusStates = ((v = p.consensusStates) == null ? void 0 : v.map((a) => e.ConsensusStateWithHeight.fromPartial(a))) || [], m;
    }
  };
  function T() {
    return {
      title: "",
      description: "",
      subjectClientId: "",
      substituteClientId: ""
    };
  }
  e.ClientUpdateProposal = {
    typeUrl: "/ibc.core.client.v1.ClientUpdateProposal",
    encode(p, m = t.BinaryWriter.create()) {
      return p.title !== "" && m.uint32(10).string(p.title), p.description !== "" && m.uint32(18).string(p.description), p.subjectClientId !== "" && m.uint32(26).string(p.subjectClientId), p.substituteClientId !== "" && m.uint32(34).string(p.substituteClientId), m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = T();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.title = v.string();
            break;
          case 2:
            d.description = v.string();
            break;
          case 3:
            d.subjectClientId = v.string();
            break;
          case 4:
            d.substituteClientId = v.string();
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = T();
      return (0, i.isSet)(p.title) && (m.title = String(p.title)), (0, i.isSet)(p.description) && (m.description = String(p.description)), (0, i.isSet)(p.subjectClientId) && (m.subjectClientId = String(p.subjectClientId)), (0, i.isSet)(p.substituteClientId) && (m.substituteClientId = String(p.substituteClientId)), m;
    },
    toJSON(p) {
      const m = {};
      return p.title !== void 0 && (m.title = p.title), p.description !== void 0 && (m.description = p.description), p.subjectClientId !== void 0 && (m.subjectClientId = p.subjectClientId), p.substituteClientId !== void 0 && (m.substituteClientId = p.substituteClientId), m;
    },
    fromPartial(p) {
      const m = T();
      return m.title = p.title ?? "", m.description = p.description ?? "", m.subjectClientId = p.subjectClientId ?? "", m.substituteClientId = p.substituteClientId ?? "", m;
    }
  };
  function J() {
    return {
      title: "",
      description: "",
      plan: r.Plan.fromPartial({}),
      upgradedClientState: void 0
    };
  }
  e.UpgradeProposal = {
    typeUrl: "/ibc.core.client.v1.UpgradeProposal",
    encode(p, m = t.BinaryWriter.create()) {
      return p.title !== "" && m.uint32(10).string(p.title), p.description !== "" && m.uint32(18).string(p.description), p.plan !== void 0 && r.Plan.encode(p.plan, m.uint32(26).fork()).ldelim(), p.upgradedClientState !== void 0 && n.Any.encode(p.upgradedClientState, m.uint32(34).fork()).ldelim(), m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = J();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.title = v.string();
            break;
          case 2:
            d.description = v.string();
            break;
          case 3:
            d.plan = r.Plan.decode(v, v.uint32());
            break;
          case 4:
            d.upgradedClientState = n.Any.decode(v, v.uint32());
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = J();
      return (0, i.isSet)(p.title) && (m.title = String(p.title)), (0, i.isSet)(p.description) && (m.description = String(p.description)), (0, i.isSet)(p.plan) && (m.plan = r.Plan.fromJSON(p.plan)), (0, i.isSet)(p.upgradedClientState) && (m.upgradedClientState = n.Any.fromJSON(p.upgradedClientState)), m;
    },
    toJSON(p) {
      const m = {};
      return p.title !== void 0 && (m.title = p.title), p.description !== void 0 && (m.description = p.description), p.plan !== void 0 && (m.plan = p.plan ? r.Plan.toJSON(p.plan) : void 0), p.upgradedClientState !== void 0 && (m.upgradedClientState = p.upgradedClientState ? n.Any.toJSON(p.upgradedClientState) : void 0), m;
    },
    fromPartial(p) {
      const m = J();
      return m.title = p.title ?? "", m.description = p.description ?? "", p.plan !== void 0 && p.plan !== null && (m.plan = r.Plan.fromPartial(p.plan)), p.upgradedClientState !== void 0 && p.upgradedClientState !== null && (m.upgradedClientState = n.Any.fromPartial(p.upgradedClientState)), m;
    }
  };
  function C() {
    return {
      revisionNumber: BigInt(0),
      revisionHeight: BigInt(0)
    };
  }
  e.Height = {
    typeUrl: "/ibc.core.client.v1.Height",
    encode(p, m = t.BinaryWriter.create()) {
      return p.revisionNumber !== BigInt(0) && m.uint32(8).uint64(p.revisionNumber), p.revisionHeight !== BigInt(0) && m.uint32(16).uint64(p.revisionHeight), m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = C();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.revisionNumber = v.uint64();
            break;
          case 2:
            d.revisionHeight = v.uint64();
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = C();
      return (0, i.isSet)(p.revisionNumber) && (m.revisionNumber = BigInt(p.revisionNumber.toString())), (0, i.isSet)(p.revisionHeight) && (m.revisionHeight = BigInt(p.revisionHeight.toString())), m;
    },
    toJSON(p) {
      const m = {};
      return p.revisionNumber !== void 0 && (m.revisionNumber = (p.revisionNumber || BigInt(0)).toString()), p.revisionHeight !== void 0 && (m.revisionHeight = (p.revisionHeight || BigInt(0)).toString()), m;
    },
    fromPartial(p) {
      const m = C();
      return p.revisionNumber !== void 0 && p.revisionNumber !== null && (m.revisionNumber = BigInt(p.revisionNumber.toString())), p.revisionHeight !== void 0 && p.revisionHeight !== null && (m.revisionHeight = BigInt(p.revisionHeight.toString())), m;
    }
  };
  function R() {
    return {
      allowedClients: []
    };
  }
  e.Params = {
    typeUrl: "/ibc.core.client.v1.Params",
    encode(p, m = t.BinaryWriter.create()) {
      for (const v of p.allowedClients)
        m.uint32(10).string(v);
      return m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = R();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.allowedClients.push(v.string());
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = R();
      return Array.isArray(p == null ? void 0 : p.allowedClients) && (m.allowedClients = p.allowedClients.map((v) => String(v))), m;
    },
    toJSON(p) {
      const m = {};
      return p.allowedClients ? m.allowedClients = p.allowedClients.map((v) => v) : m.allowedClients = [], m;
    },
    fromPartial(p) {
      var v;
      const m = R();
      return m.allowedClients = ((v = p.allowedClients) == null ? void 0 : v.map((a) => a)) || [], m;
    }
  };
})(yt);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgTransferResponse = e.MsgTransfer = e.protobufPackage = void 0;
  const n = De, r = yt, t = re, i = ie;
  e.protobufPackage = "ibc.applications.transfer.v1";
  function f() {
    return {
      sourcePort: "",
      sourceChannel: "",
      token: n.Coin.fromPartial({}),
      sender: "",
      receiver: "",
      timeoutHeight: r.Height.fromPartial({}),
      timeoutTimestamp: BigInt(0),
      memo: ""
    };
  }
  e.MsgTransfer = {
    typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
    encode(T, J = t.BinaryWriter.create()) {
      return T.sourcePort !== "" && J.uint32(10).string(T.sourcePort), T.sourceChannel !== "" && J.uint32(18).string(T.sourceChannel), T.token !== void 0 && n.Coin.encode(T.token, J.uint32(26).fork()).ldelim(), T.sender !== "" && J.uint32(34).string(T.sender), T.receiver !== "" && J.uint32(42).string(T.receiver), T.timeoutHeight !== void 0 && r.Height.encode(T.timeoutHeight, J.uint32(50).fork()).ldelim(), T.timeoutTimestamp !== BigInt(0) && J.uint32(56).uint64(T.timeoutTimestamp), T.memo !== "" && J.uint32(66).string(T.memo), J;
    },
    decode(T, J) {
      const C = T instanceof t.BinaryReader ? T : new t.BinaryReader(T);
      let R = J === void 0 ? C.len : C.pos + J;
      const p = f();
      for (; C.pos < R; ) {
        const m = C.uint32();
        switch (m >>> 3) {
          case 1:
            p.sourcePort = C.string();
            break;
          case 2:
            p.sourceChannel = C.string();
            break;
          case 3:
            p.token = n.Coin.decode(C, C.uint32());
            break;
          case 4:
            p.sender = C.string();
            break;
          case 5:
            p.receiver = C.string();
            break;
          case 6:
            p.timeoutHeight = r.Height.decode(C, C.uint32());
            break;
          case 7:
            p.timeoutTimestamp = C.uint64();
            break;
          case 8:
            p.memo = C.string();
            break;
          default:
            C.skipType(m & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(T) {
      const J = f();
      return (0, i.isSet)(T.sourcePort) && (J.sourcePort = String(T.sourcePort)), (0, i.isSet)(T.sourceChannel) && (J.sourceChannel = String(T.sourceChannel)), (0, i.isSet)(T.token) && (J.token = n.Coin.fromJSON(T.token)), (0, i.isSet)(T.sender) && (J.sender = String(T.sender)), (0, i.isSet)(T.receiver) && (J.receiver = String(T.receiver)), (0, i.isSet)(T.timeoutHeight) && (J.timeoutHeight = r.Height.fromJSON(T.timeoutHeight)), (0, i.isSet)(T.timeoutTimestamp) && (J.timeoutTimestamp = BigInt(T.timeoutTimestamp.toString())), (0, i.isSet)(T.memo) && (J.memo = String(T.memo)), J;
    },
    toJSON(T) {
      const J = {};
      return T.sourcePort !== void 0 && (J.sourcePort = T.sourcePort), T.sourceChannel !== void 0 && (J.sourceChannel = T.sourceChannel), T.token !== void 0 && (J.token = T.token ? n.Coin.toJSON(T.token) : void 0), T.sender !== void 0 && (J.sender = T.sender), T.receiver !== void 0 && (J.receiver = T.receiver), T.timeoutHeight !== void 0 && (J.timeoutHeight = T.timeoutHeight ? r.Height.toJSON(T.timeoutHeight) : void 0), T.timeoutTimestamp !== void 0 && (J.timeoutTimestamp = (T.timeoutTimestamp || BigInt(0)).toString()), T.memo !== void 0 && (J.memo = T.memo), J;
    },
    fromPartial(T) {
      const J = f();
      return J.sourcePort = T.sourcePort ?? "", J.sourceChannel = T.sourceChannel ?? "", T.token !== void 0 && T.token !== null && (J.token = n.Coin.fromPartial(T.token)), J.sender = T.sender ?? "", J.receiver = T.receiver ?? "", T.timeoutHeight !== void 0 && T.timeoutHeight !== null && (J.timeoutHeight = r.Height.fromPartial(T.timeoutHeight)), T.timeoutTimestamp !== void 0 && T.timeoutTimestamp !== null && (J.timeoutTimestamp = BigInt(T.timeoutTimestamp.toString())), J.memo = T.memo ?? "", J;
    }
  };
  function S() {
    return {
      sequence: BigInt(0)
    };
  }
  e.MsgTransferResponse = {
    typeUrl: "/ibc.applications.transfer.v1.MsgTransferResponse",
    encode(T, J = t.BinaryWriter.create()) {
      return T.sequence !== BigInt(0) && J.uint32(8).uint64(T.sequence), J;
    },
    decode(T, J) {
      const C = T instanceof t.BinaryReader ? T : new t.BinaryReader(T);
      let R = J === void 0 ? C.len : C.pos + J;
      const p = S();
      for (; C.pos < R; ) {
        const m = C.uint32();
        switch (m >>> 3) {
          case 1:
            p.sequence = C.uint64();
            break;
          default:
            C.skipType(m & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(T) {
      const J = S();
      return (0, i.isSet)(T.sequence) && (J.sequence = BigInt(T.sequence.toString())), J;
    },
    toJSON(T) {
      const J = {};
      return T.sequence !== void 0 && (J.sequence = (T.sequence || BigInt(0)).toString()), J;
    },
    fromPartial(T) {
      const J = S();
      return T.sequence !== void 0 && T.sequence !== null && (J.sequence = BigInt(T.sequence.toString())), J;
    }
  };
  class w {
    constructor(J) {
      this.rpc = J, this.Transfer = this.Transfer.bind(this);
    }
    Transfer(J) {
      const C = e.MsgTransfer.encode(J).finish();
      return this.rpc.request("ibc.applications.transfer.v1.Msg", "Transfer", C).then((p) => e.MsgTransferResponse.decode(new t.BinaryReader(p)));
    }
  }
  e.MsgClientImpl = w;
})(Is);
Object.defineProperty(yi, "__esModule", { value: !0 });
yi.createIbcAminoConverters = yi.isAminoMsgTransfer = void 0;
const Zo = To, CR = Is;
function NR(e) {
  return e.type === "cosmos-sdk/MsgTransfer";
}
yi.isAminoMsgTransfer = NR;
function _R() {
  return {
    "/ibc.applications.transfer.v1.MsgTransfer": {
      aminoType: "cosmos-sdk/MsgTransfer",
      toAmino: ({ sourcePort: e, sourceChannel: n, token: r, sender: t, receiver: i, timeoutHeight: f, timeoutTimestamp: S, memo: w }) => {
        var T, J, C;
        return {
          source_port: e,
          source_channel: n,
          token: r,
          sender: t,
          receiver: i,
          timeout_height: f ? {
            revision_height: (T = (0, Zo.omitDefault)(f.revisionHeight)) == null ? void 0 : T.toString(),
            revision_number: (J = (0, Zo.omitDefault)(f.revisionNumber)) == null ? void 0 : J.toString()
          } : {},
          timeout_timestamp: (C = (0, Zo.omitDefault)(S)) == null ? void 0 : C.toString(),
          memo: (0, Zo.omitDefault)(w)
        };
      },
      fromAmino: ({ source_port: e, source_channel: n, token: r, sender: t, receiver: i, timeout_height: f, timeout_timestamp: S, memo: w }) => CR.MsgTransfer.fromPartial({
        sourcePort: e,
        sourceChannel: n,
        token: r,
        sender: t,
        receiver: i,
        timeoutHeight: f ? {
          revisionHeight: BigInt(f.revision_height || "0"),
          revisionNumber: BigInt(f.revision_number || "0")
        } : void 0,
        timeoutTimestamp: BigInt(S || "0"),
        memo: w ?? ""
      })
    }
  };
}
yi.createIbcAminoConverters = _R;
var ki = {}, Jh = {}, Ts = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Acknowledgement = e.PacketId = e.PacketState = e.Packet = e.Counterparty = e.IdentifiedChannel = e.Channel = e.orderToJSON = e.orderFromJSON = e.Order = e.stateToJSON = e.stateFromJSON = e.State = e.protobufPackage = void 0;
  const n = yt, r = re, t = ie;
  e.protobufPackage = "ibc.core.channel.v1";
  var i;
  (function(y) {
    y[y.STATE_UNINITIALIZED_UNSPECIFIED = 0] = "STATE_UNINITIALIZED_UNSPECIFIED", y[y.STATE_INIT = 1] = "STATE_INIT", y[y.STATE_TRYOPEN = 2] = "STATE_TRYOPEN", y[y.STATE_OPEN = 3] = "STATE_OPEN", y[y.STATE_CLOSED = 4] = "STATE_CLOSED", y[y.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(i || (e.State = i = {}));
  function f(y) {
    switch (y) {
      case 0:
      case "STATE_UNINITIALIZED_UNSPECIFIED":
        return i.STATE_UNINITIALIZED_UNSPECIFIED;
      case 1:
      case "STATE_INIT":
        return i.STATE_INIT;
      case 2:
      case "STATE_TRYOPEN":
        return i.STATE_TRYOPEN;
      case 3:
      case "STATE_OPEN":
        return i.STATE_OPEN;
      case 4:
      case "STATE_CLOSED":
        return i.STATE_CLOSED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return i.UNRECOGNIZED;
    }
  }
  e.stateFromJSON = f;
  function S(y) {
    switch (y) {
      case i.STATE_UNINITIALIZED_UNSPECIFIED:
        return "STATE_UNINITIALIZED_UNSPECIFIED";
      case i.STATE_INIT:
        return "STATE_INIT";
      case i.STATE_TRYOPEN:
        return "STATE_TRYOPEN";
      case i.STATE_OPEN:
        return "STATE_OPEN";
      case i.STATE_CLOSED:
        return "STATE_CLOSED";
      case i.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.stateToJSON = S;
  var w;
  (function(y) {
    y[y.ORDER_NONE_UNSPECIFIED = 0] = "ORDER_NONE_UNSPECIFIED", y[y.ORDER_UNORDERED = 1] = "ORDER_UNORDERED", y[y.ORDER_ORDERED = 2] = "ORDER_ORDERED", y[y.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(w || (e.Order = w = {}));
  function T(y) {
    switch (y) {
      case 0:
      case "ORDER_NONE_UNSPECIFIED":
        return w.ORDER_NONE_UNSPECIFIED;
      case 1:
      case "ORDER_UNORDERED":
        return w.ORDER_UNORDERED;
      case 2:
      case "ORDER_ORDERED":
        return w.ORDER_ORDERED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return w.UNRECOGNIZED;
    }
  }
  e.orderFromJSON = T;
  function J(y) {
    switch (y) {
      case w.ORDER_NONE_UNSPECIFIED:
        return "ORDER_NONE_UNSPECIFIED";
      case w.ORDER_UNORDERED:
        return "ORDER_UNORDERED";
      case w.ORDER_ORDERED:
        return "ORDER_ORDERED";
      case w.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.orderToJSON = J;
  function C() {
    return {
      state: 0,
      ordering: 0,
      counterparty: e.Counterparty.fromPartial({}),
      connectionHops: [],
      version: ""
    };
  }
  e.Channel = {
    typeUrl: "/ibc.core.channel.v1.Channel",
    encode(y, _ = r.BinaryWriter.create()) {
      y.state !== 0 && _.uint32(8).int32(y.state), y.ordering !== 0 && _.uint32(16).int32(y.ordering), y.counterparty !== void 0 && e.Counterparty.encode(y.counterparty, _.uint32(26).fork()).ldelim();
      for (const E of y.connectionHops)
        _.uint32(34).string(E);
      return y.version !== "" && _.uint32(42).string(y.version), _;
    },
    decode(y, _) {
      const E = y instanceof r.BinaryReader ? y : new r.BinaryReader(y);
      let U = _ === void 0 ? E.len : E.pos + _;
      const V = C();
      for (; E.pos < U; ) {
        const o = E.uint32();
        switch (o >>> 3) {
          case 1:
            V.state = E.int32();
            break;
          case 2:
            V.ordering = E.int32();
            break;
          case 3:
            V.counterparty = e.Counterparty.decode(E, E.uint32());
            break;
          case 4:
            V.connectionHops.push(E.string());
            break;
          case 5:
            V.version = E.string();
            break;
          default:
            E.skipType(o & 7);
            break;
        }
      }
      return V;
    },
    fromJSON(y) {
      const _ = C();
      return (0, t.isSet)(y.state) && (_.state = f(y.state)), (0, t.isSet)(y.ordering) && (_.ordering = T(y.ordering)), (0, t.isSet)(y.counterparty) && (_.counterparty = e.Counterparty.fromJSON(y.counterparty)), Array.isArray(y == null ? void 0 : y.connectionHops) && (_.connectionHops = y.connectionHops.map((E) => String(E))), (0, t.isSet)(y.version) && (_.version = String(y.version)), _;
    },
    toJSON(y) {
      const _ = {};
      return y.state !== void 0 && (_.state = S(y.state)), y.ordering !== void 0 && (_.ordering = J(y.ordering)), y.counterparty !== void 0 && (_.counterparty = y.counterparty ? e.Counterparty.toJSON(y.counterparty) : void 0), y.connectionHops ? _.connectionHops = y.connectionHops.map((E) => E) : _.connectionHops = [], y.version !== void 0 && (_.version = y.version), _;
    },
    fromPartial(y) {
      var E;
      const _ = C();
      return _.state = y.state ?? 0, _.ordering = y.ordering ?? 0, y.counterparty !== void 0 && y.counterparty !== null && (_.counterparty = e.Counterparty.fromPartial(y.counterparty)), _.connectionHops = ((E = y.connectionHops) == null ? void 0 : E.map((U) => U)) || [], _.version = y.version ?? "", _;
    }
  };
  function R() {
    return {
      state: 0,
      ordering: 0,
      counterparty: e.Counterparty.fromPartial({}),
      connectionHops: [],
      version: "",
      portId: "",
      channelId: ""
    };
  }
  e.IdentifiedChannel = {
    typeUrl: "/ibc.core.channel.v1.IdentifiedChannel",
    encode(y, _ = r.BinaryWriter.create()) {
      y.state !== 0 && _.uint32(8).int32(y.state), y.ordering !== 0 && _.uint32(16).int32(y.ordering), y.counterparty !== void 0 && e.Counterparty.encode(y.counterparty, _.uint32(26).fork()).ldelim();
      for (const E of y.connectionHops)
        _.uint32(34).string(E);
      return y.version !== "" && _.uint32(42).string(y.version), y.portId !== "" && _.uint32(50).string(y.portId), y.channelId !== "" && _.uint32(58).string(y.channelId), _;
    },
    decode(y, _) {
      const E = y instanceof r.BinaryReader ? y : new r.BinaryReader(y);
      let U = _ === void 0 ? E.len : E.pos + _;
      const V = R();
      for (; E.pos < U; ) {
        const o = E.uint32();
        switch (o >>> 3) {
          case 1:
            V.state = E.int32();
            break;
          case 2:
            V.ordering = E.int32();
            break;
          case 3:
            V.counterparty = e.Counterparty.decode(E, E.uint32());
            break;
          case 4:
            V.connectionHops.push(E.string());
            break;
          case 5:
            V.version = E.string();
            break;
          case 6:
            V.portId = E.string();
            break;
          case 7:
            V.channelId = E.string();
            break;
          default:
            E.skipType(o & 7);
            break;
        }
      }
      return V;
    },
    fromJSON(y) {
      const _ = R();
      return (0, t.isSet)(y.state) && (_.state = f(y.state)), (0, t.isSet)(y.ordering) && (_.ordering = T(y.ordering)), (0, t.isSet)(y.counterparty) && (_.counterparty = e.Counterparty.fromJSON(y.counterparty)), Array.isArray(y == null ? void 0 : y.connectionHops) && (_.connectionHops = y.connectionHops.map((E) => String(E))), (0, t.isSet)(y.version) && (_.version = String(y.version)), (0, t.isSet)(y.portId) && (_.portId = String(y.portId)), (0, t.isSet)(y.channelId) && (_.channelId = String(y.channelId)), _;
    },
    toJSON(y) {
      const _ = {};
      return y.state !== void 0 && (_.state = S(y.state)), y.ordering !== void 0 && (_.ordering = J(y.ordering)), y.counterparty !== void 0 && (_.counterparty = y.counterparty ? e.Counterparty.toJSON(y.counterparty) : void 0), y.connectionHops ? _.connectionHops = y.connectionHops.map((E) => E) : _.connectionHops = [], y.version !== void 0 && (_.version = y.version), y.portId !== void 0 && (_.portId = y.portId), y.channelId !== void 0 && (_.channelId = y.channelId), _;
    },
    fromPartial(y) {
      var E;
      const _ = R();
      return _.state = y.state ?? 0, _.ordering = y.ordering ?? 0, y.counterparty !== void 0 && y.counterparty !== null && (_.counterparty = e.Counterparty.fromPartial(y.counterparty)), _.connectionHops = ((E = y.connectionHops) == null ? void 0 : E.map((U) => U)) || [], _.version = y.version ?? "", _.portId = y.portId ?? "", _.channelId = y.channelId ?? "", _;
    }
  };
  function p() {
    return {
      portId: "",
      channelId: ""
    };
  }
  e.Counterparty = {
    typeUrl: "/ibc.core.channel.v1.Counterparty",
    encode(y, _ = r.BinaryWriter.create()) {
      return y.portId !== "" && _.uint32(10).string(y.portId), y.channelId !== "" && _.uint32(18).string(y.channelId), _;
    },
    decode(y, _) {
      const E = y instanceof r.BinaryReader ? y : new r.BinaryReader(y);
      let U = _ === void 0 ? E.len : E.pos + _;
      const V = p();
      for (; E.pos < U; ) {
        const o = E.uint32();
        switch (o >>> 3) {
          case 1:
            V.portId = E.string();
            break;
          case 2:
            V.channelId = E.string();
            break;
          default:
            E.skipType(o & 7);
            break;
        }
      }
      return V;
    },
    fromJSON(y) {
      const _ = p();
      return (0, t.isSet)(y.portId) && (_.portId = String(y.portId)), (0, t.isSet)(y.channelId) && (_.channelId = String(y.channelId)), _;
    },
    toJSON(y) {
      const _ = {};
      return y.portId !== void 0 && (_.portId = y.portId), y.channelId !== void 0 && (_.channelId = y.channelId), _;
    },
    fromPartial(y) {
      const _ = p();
      return _.portId = y.portId ?? "", _.channelId = y.channelId ?? "", _;
    }
  };
  function m() {
    return {
      sequence: BigInt(0),
      sourcePort: "",
      sourceChannel: "",
      destinationPort: "",
      destinationChannel: "",
      data: new Uint8Array(),
      timeoutHeight: n.Height.fromPartial({}),
      timeoutTimestamp: BigInt(0)
    };
  }
  e.Packet = {
    typeUrl: "/ibc.core.channel.v1.Packet",
    encode(y, _ = r.BinaryWriter.create()) {
      return y.sequence !== BigInt(0) && _.uint32(8).uint64(y.sequence), y.sourcePort !== "" && _.uint32(18).string(y.sourcePort), y.sourceChannel !== "" && _.uint32(26).string(y.sourceChannel), y.destinationPort !== "" && _.uint32(34).string(y.destinationPort), y.destinationChannel !== "" && _.uint32(42).string(y.destinationChannel), y.data.length !== 0 && _.uint32(50).bytes(y.data), y.timeoutHeight !== void 0 && n.Height.encode(y.timeoutHeight, _.uint32(58).fork()).ldelim(), y.timeoutTimestamp !== BigInt(0) && _.uint32(64).uint64(y.timeoutTimestamp), _;
    },
    decode(y, _) {
      const E = y instanceof r.BinaryReader ? y : new r.BinaryReader(y);
      let U = _ === void 0 ? E.len : E.pos + _;
      const V = m();
      for (; E.pos < U; ) {
        const o = E.uint32();
        switch (o >>> 3) {
          case 1:
            V.sequence = E.uint64();
            break;
          case 2:
            V.sourcePort = E.string();
            break;
          case 3:
            V.sourceChannel = E.string();
            break;
          case 4:
            V.destinationPort = E.string();
            break;
          case 5:
            V.destinationChannel = E.string();
            break;
          case 6:
            V.data = E.bytes();
            break;
          case 7:
            V.timeoutHeight = n.Height.decode(E, E.uint32());
            break;
          case 8:
            V.timeoutTimestamp = E.uint64();
            break;
          default:
            E.skipType(o & 7);
            break;
        }
      }
      return V;
    },
    fromJSON(y) {
      const _ = m();
      return (0, t.isSet)(y.sequence) && (_.sequence = BigInt(y.sequence.toString())), (0, t.isSet)(y.sourcePort) && (_.sourcePort = String(y.sourcePort)), (0, t.isSet)(y.sourceChannel) && (_.sourceChannel = String(y.sourceChannel)), (0, t.isSet)(y.destinationPort) && (_.destinationPort = String(y.destinationPort)), (0, t.isSet)(y.destinationChannel) && (_.destinationChannel = String(y.destinationChannel)), (0, t.isSet)(y.data) && (_.data = (0, t.bytesFromBase64)(y.data)), (0, t.isSet)(y.timeoutHeight) && (_.timeoutHeight = n.Height.fromJSON(y.timeoutHeight)), (0, t.isSet)(y.timeoutTimestamp) && (_.timeoutTimestamp = BigInt(y.timeoutTimestamp.toString())), _;
    },
    toJSON(y) {
      const _ = {};
      return y.sequence !== void 0 && (_.sequence = (y.sequence || BigInt(0)).toString()), y.sourcePort !== void 0 && (_.sourcePort = y.sourcePort), y.sourceChannel !== void 0 && (_.sourceChannel = y.sourceChannel), y.destinationPort !== void 0 && (_.destinationPort = y.destinationPort), y.destinationChannel !== void 0 && (_.destinationChannel = y.destinationChannel), y.data !== void 0 && (_.data = (0, t.base64FromBytes)(y.data !== void 0 ? y.data : new Uint8Array())), y.timeoutHeight !== void 0 && (_.timeoutHeight = y.timeoutHeight ? n.Height.toJSON(y.timeoutHeight) : void 0), y.timeoutTimestamp !== void 0 && (_.timeoutTimestamp = (y.timeoutTimestamp || BigInt(0)).toString()), _;
    },
    fromPartial(y) {
      const _ = m();
      return y.sequence !== void 0 && y.sequence !== null && (_.sequence = BigInt(y.sequence.toString())), _.sourcePort = y.sourcePort ?? "", _.sourceChannel = y.sourceChannel ?? "", _.destinationPort = y.destinationPort ?? "", _.destinationChannel = y.destinationChannel ?? "", _.data = y.data ?? new Uint8Array(), y.timeoutHeight !== void 0 && y.timeoutHeight !== null && (_.timeoutHeight = n.Height.fromPartial(y.timeoutHeight)), y.timeoutTimestamp !== void 0 && y.timeoutTimestamp !== null && (_.timeoutTimestamp = BigInt(y.timeoutTimestamp.toString())), _;
    }
  };
  function v() {
    return {
      portId: "",
      channelId: "",
      sequence: BigInt(0),
      data: new Uint8Array()
    };
  }
  e.PacketState = {
    typeUrl: "/ibc.core.channel.v1.PacketState",
    encode(y, _ = r.BinaryWriter.create()) {
      return y.portId !== "" && _.uint32(10).string(y.portId), y.channelId !== "" && _.uint32(18).string(y.channelId), y.sequence !== BigInt(0) && _.uint32(24).uint64(y.sequence), y.data.length !== 0 && _.uint32(34).bytes(y.data), _;
    },
    decode(y, _) {
      const E = y instanceof r.BinaryReader ? y : new r.BinaryReader(y);
      let U = _ === void 0 ? E.len : E.pos + _;
      const V = v();
      for (; E.pos < U; ) {
        const o = E.uint32();
        switch (o >>> 3) {
          case 1:
            V.portId = E.string();
            break;
          case 2:
            V.channelId = E.string();
            break;
          case 3:
            V.sequence = E.uint64();
            break;
          case 4:
            V.data = E.bytes();
            break;
          default:
            E.skipType(o & 7);
            break;
        }
      }
      return V;
    },
    fromJSON(y) {
      const _ = v();
      return (0, t.isSet)(y.portId) && (_.portId = String(y.portId)), (0, t.isSet)(y.channelId) && (_.channelId = String(y.channelId)), (0, t.isSet)(y.sequence) && (_.sequence = BigInt(y.sequence.toString())), (0, t.isSet)(y.data) && (_.data = (0, t.bytesFromBase64)(y.data)), _;
    },
    toJSON(y) {
      const _ = {};
      return y.portId !== void 0 && (_.portId = y.portId), y.channelId !== void 0 && (_.channelId = y.channelId), y.sequence !== void 0 && (_.sequence = (y.sequence || BigInt(0)).toString()), y.data !== void 0 && (_.data = (0, t.base64FromBytes)(y.data !== void 0 ? y.data : new Uint8Array())), _;
    },
    fromPartial(y) {
      const _ = v();
      return _.portId = y.portId ?? "", _.channelId = y.channelId ?? "", y.sequence !== void 0 && y.sequence !== null && (_.sequence = BigInt(y.sequence.toString())), _.data = y.data ?? new Uint8Array(), _;
    }
  };
  function a() {
    return {
      portId: "",
      channelId: "",
      sequence: BigInt(0)
    };
  }
  e.PacketId = {
    typeUrl: "/ibc.core.channel.v1.PacketId",
    encode(y, _ = r.BinaryWriter.create()) {
      return y.portId !== "" && _.uint32(10).string(y.portId), y.channelId !== "" && _.uint32(18).string(y.channelId), y.sequence !== BigInt(0) && _.uint32(24).uint64(y.sequence), _;
    },
    decode(y, _) {
      const E = y instanceof r.BinaryReader ? y : new r.BinaryReader(y);
      let U = _ === void 0 ? E.len : E.pos + _;
      const V = a();
      for (; E.pos < U; ) {
        const o = E.uint32();
        switch (o >>> 3) {
          case 1:
            V.portId = E.string();
            break;
          case 2:
            V.channelId = E.string();
            break;
          case 3:
            V.sequence = E.uint64();
            break;
          default:
            E.skipType(o & 7);
            break;
        }
      }
      return V;
    },
    fromJSON(y) {
      const _ = a();
      return (0, t.isSet)(y.portId) && (_.portId = String(y.portId)), (0, t.isSet)(y.channelId) && (_.channelId = String(y.channelId)), (0, t.isSet)(y.sequence) && (_.sequence = BigInt(y.sequence.toString())), _;
    },
    toJSON(y) {
      const _ = {};
      return y.portId !== void 0 && (_.portId = y.portId), y.channelId !== void 0 && (_.channelId = y.channelId), y.sequence !== void 0 && (_.sequence = (y.sequence || BigInt(0)).toString()), _;
    },
    fromPartial(y) {
      const _ = a();
      return _.portId = y.portId ?? "", _.channelId = y.channelId ?? "", y.sequence !== void 0 && y.sequence !== null && (_.sequence = BigInt(y.sequence.toString())), _;
    }
  };
  function d() {
    return {
      result: void 0,
      error: void 0
    };
  }
  e.Acknowledgement = {
    typeUrl: "/ibc.core.channel.v1.Acknowledgement",
    encode(y, _ = r.BinaryWriter.create()) {
      return y.result !== void 0 && _.uint32(170).bytes(y.result), y.error !== void 0 && _.uint32(178).string(y.error), _;
    },
    decode(y, _) {
      const E = y instanceof r.BinaryReader ? y : new r.BinaryReader(y);
      let U = _ === void 0 ? E.len : E.pos + _;
      const V = d();
      for (; E.pos < U; ) {
        const o = E.uint32();
        switch (o >>> 3) {
          case 21:
            V.result = E.bytes();
            break;
          case 22:
            V.error = E.string();
            break;
          default:
            E.skipType(o & 7);
            break;
        }
      }
      return V;
    },
    fromJSON(y) {
      const _ = d();
      return (0, t.isSet)(y.result) && (_.result = (0, t.bytesFromBase64)(y.result)), (0, t.isSet)(y.error) && (_.error = String(y.error)), _;
    },
    toJSON(y) {
      const _ = {};
      return y.result !== void 0 && (_.result = y.result !== void 0 ? (0, t.base64FromBytes)(y.result) : void 0), y.error !== void 0 && (_.error = y.error), _;
    },
    fromPartial(y) {
      const _ = d();
      return _.result = y.result ?? void 0, _.error = y.error ?? void 0, _;
    }
  };
})(Ts);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgAcknowledgementResponse = e.MsgAcknowledgement = e.MsgTimeoutOnCloseResponse = e.MsgTimeoutOnClose = e.MsgTimeoutResponse = e.MsgTimeout = e.MsgRecvPacketResponse = e.MsgRecvPacket = e.MsgChannelCloseConfirmResponse = e.MsgChannelCloseConfirm = e.MsgChannelCloseInitResponse = e.MsgChannelCloseInit = e.MsgChannelOpenConfirmResponse = e.MsgChannelOpenConfirm = e.MsgChannelOpenAckResponse = e.MsgChannelOpenAck = e.MsgChannelOpenTryResponse = e.MsgChannelOpenTry = e.MsgChannelOpenInitResponse = e.MsgChannelOpenInit = e.responseResultTypeToJSON = e.responseResultTypeFromJSON = e.ResponseResultType = e.protobufPackage = void 0;
  const n = Ts, r = yt, t = re, i = ie;
  e.protobufPackage = "ibc.core.channel.v1";
  var f;
  (function(B) {
    B[B.RESPONSE_RESULT_TYPE_UNSPECIFIED = 0] = "RESPONSE_RESULT_TYPE_UNSPECIFIED", B[B.RESPONSE_RESULT_TYPE_NOOP = 1] = "RESPONSE_RESULT_TYPE_NOOP", B[B.RESPONSE_RESULT_TYPE_SUCCESS = 2] = "RESPONSE_RESULT_TYPE_SUCCESS", B[B.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(f || (e.ResponseResultType = f = {}));
  function S(B) {
    switch (B) {
      case 0:
      case "RESPONSE_RESULT_TYPE_UNSPECIFIED":
        return f.RESPONSE_RESULT_TYPE_UNSPECIFIED;
      case 1:
      case "RESPONSE_RESULT_TYPE_NOOP":
        return f.RESPONSE_RESULT_TYPE_NOOP;
      case 2:
      case "RESPONSE_RESULT_TYPE_SUCCESS":
        return f.RESPONSE_RESULT_TYPE_SUCCESS;
      case -1:
      case "UNRECOGNIZED":
      default:
        return f.UNRECOGNIZED;
    }
  }
  e.responseResultTypeFromJSON = S;
  function w(B) {
    switch (B) {
      case f.RESPONSE_RESULT_TYPE_UNSPECIFIED:
        return "RESPONSE_RESULT_TYPE_UNSPECIFIED";
      case f.RESPONSE_RESULT_TYPE_NOOP:
        return "RESPONSE_RESULT_TYPE_NOOP";
      case f.RESPONSE_RESULT_TYPE_SUCCESS:
        return "RESPONSE_RESULT_TYPE_SUCCESS";
      case f.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.responseResultTypeToJSON = w;
  function T() {
    return {
      portId: "",
      channel: n.Channel.fromPartial({}),
      signer: ""
    };
  }
  e.MsgChannelOpenInit = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelOpenInit",
    encode(B, b = t.BinaryWriter.create()) {
      return B.portId !== "" && b.uint32(10).string(B.portId), B.channel !== void 0 && n.Channel.encode(B.channel, b.uint32(18).fork()).ldelim(), B.signer !== "" && b.uint32(26).string(B.signer), b;
    },
    decode(B, b) {
      const D = B instanceof t.BinaryReader ? B : new t.BinaryReader(B);
      let Q = b === void 0 ? D.len : D.pos + b;
      const H = T();
      for (; D.pos < Q; ) {
        const s = D.uint32();
        switch (s >>> 3) {
          case 1:
            H.portId = D.string();
            break;
          case 2:
            H.channel = n.Channel.decode(D, D.uint32());
            break;
          case 3:
            H.signer = D.string();
            break;
          default:
            D.skipType(s & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(B) {
      const b = T();
      return (0, i.isSet)(B.portId) && (b.portId = String(B.portId)), (0, i.isSet)(B.channel) && (b.channel = n.Channel.fromJSON(B.channel)), (0, i.isSet)(B.signer) && (b.signer = String(B.signer)), b;
    },
    toJSON(B) {
      const b = {};
      return B.portId !== void 0 && (b.portId = B.portId), B.channel !== void 0 && (b.channel = B.channel ? n.Channel.toJSON(B.channel) : void 0), B.signer !== void 0 && (b.signer = B.signer), b;
    },
    fromPartial(B) {
      const b = T();
      return b.portId = B.portId ?? "", B.channel !== void 0 && B.channel !== null && (b.channel = n.Channel.fromPartial(B.channel)), b.signer = B.signer ?? "", b;
    }
  };
  function J() {
    return {
      channelId: "",
      version: ""
    };
  }
  e.MsgChannelOpenInitResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelOpenInitResponse",
    encode(B, b = t.BinaryWriter.create()) {
      return B.channelId !== "" && b.uint32(10).string(B.channelId), B.version !== "" && b.uint32(18).string(B.version), b;
    },
    decode(B, b) {
      const D = B instanceof t.BinaryReader ? B : new t.BinaryReader(B);
      let Q = b === void 0 ? D.len : D.pos + b;
      const H = J();
      for (; D.pos < Q; ) {
        const s = D.uint32();
        switch (s >>> 3) {
          case 1:
            H.channelId = D.string();
            break;
          case 2:
            H.version = D.string();
            break;
          default:
            D.skipType(s & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(B) {
      const b = J();
      return (0, i.isSet)(B.channelId) && (b.channelId = String(B.channelId)), (0, i.isSet)(B.version) && (b.version = String(B.version)), b;
    },
    toJSON(B) {
      const b = {};
      return B.channelId !== void 0 && (b.channelId = B.channelId), B.version !== void 0 && (b.version = B.version), b;
    },
    fromPartial(B) {
      const b = J();
      return b.channelId = B.channelId ?? "", b.version = B.version ?? "", b;
    }
  };
  function C() {
    return {
      portId: "",
      previousChannelId: "",
      channel: n.Channel.fromPartial({}),
      counterpartyVersion: "",
      proofInit: new Uint8Array(),
      proofHeight: r.Height.fromPartial({}),
      signer: ""
    };
  }
  e.MsgChannelOpenTry = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelOpenTry",
    encode(B, b = t.BinaryWriter.create()) {
      return B.portId !== "" && b.uint32(10).string(B.portId), B.previousChannelId !== "" && b.uint32(18).string(B.previousChannelId), B.channel !== void 0 && n.Channel.encode(B.channel, b.uint32(26).fork()).ldelim(), B.counterpartyVersion !== "" && b.uint32(34).string(B.counterpartyVersion), B.proofInit.length !== 0 && b.uint32(42).bytes(B.proofInit), B.proofHeight !== void 0 && r.Height.encode(B.proofHeight, b.uint32(50).fork()).ldelim(), B.signer !== "" && b.uint32(58).string(B.signer), b;
    },
    decode(B, b) {
      const D = B instanceof t.BinaryReader ? B : new t.BinaryReader(B);
      let Q = b === void 0 ? D.len : D.pos + b;
      const H = C();
      for (; D.pos < Q; ) {
        const s = D.uint32();
        switch (s >>> 3) {
          case 1:
            H.portId = D.string();
            break;
          case 2:
            H.previousChannelId = D.string();
            break;
          case 3:
            H.channel = n.Channel.decode(D, D.uint32());
            break;
          case 4:
            H.counterpartyVersion = D.string();
            break;
          case 5:
            H.proofInit = D.bytes();
            break;
          case 6:
            H.proofHeight = r.Height.decode(D, D.uint32());
            break;
          case 7:
            H.signer = D.string();
            break;
          default:
            D.skipType(s & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(B) {
      const b = C();
      return (0, i.isSet)(B.portId) && (b.portId = String(B.portId)), (0, i.isSet)(B.previousChannelId) && (b.previousChannelId = String(B.previousChannelId)), (0, i.isSet)(B.channel) && (b.channel = n.Channel.fromJSON(B.channel)), (0, i.isSet)(B.counterpartyVersion) && (b.counterpartyVersion = String(B.counterpartyVersion)), (0, i.isSet)(B.proofInit) && (b.proofInit = (0, i.bytesFromBase64)(B.proofInit)), (0, i.isSet)(B.proofHeight) && (b.proofHeight = r.Height.fromJSON(B.proofHeight)), (0, i.isSet)(B.signer) && (b.signer = String(B.signer)), b;
    },
    toJSON(B) {
      const b = {};
      return B.portId !== void 0 && (b.portId = B.portId), B.previousChannelId !== void 0 && (b.previousChannelId = B.previousChannelId), B.channel !== void 0 && (b.channel = B.channel ? n.Channel.toJSON(B.channel) : void 0), B.counterpartyVersion !== void 0 && (b.counterpartyVersion = B.counterpartyVersion), B.proofInit !== void 0 && (b.proofInit = (0, i.base64FromBytes)(B.proofInit !== void 0 ? B.proofInit : new Uint8Array())), B.proofHeight !== void 0 && (b.proofHeight = B.proofHeight ? r.Height.toJSON(B.proofHeight) : void 0), B.signer !== void 0 && (b.signer = B.signer), b;
    },
    fromPartial(B) {
      const b = C();
      return b.portId = B.portId ?? "", b.previousChannelId = B.previousChannelId ?? "", B.channel !== void 0 && B.channel !== null && (b.channel = n.Channel.fromPartial(B.channel)), b.counterpartyVersion = B.counterpartyVersion ?? "", b.proofInit = B.proofInit ?? new Uint8Array(), B.proofHeight !== void 0 && B.proofHeight !== null && (b.proofHeight = r.Height.fromPartial(B.proofHeight)), b.signer = B.signer ?? "", b;
    }
  };
  function R() {
    return {
      version: ""
    };
  }
  e.MsgChannelOpenTryResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelOpenTryResponse",
    encode(B, b = t.BinaryWriter.create()) {
      return B.version !== "" && b.uint32(10).string(B.version), b;
    },
    decode(B, b) {
      const D = B instanceof t.BinaryReader ? B : new t.BinaryReader(B);
      let Q = b === void 0 ? D.len : D.pos + b;
      const H = R();
      for (; D.pos < Q; ) {
        const s = D.uint32();
        switch (s >>> 3) {
          case 1:
            H.version = D.string();
            break;
          default:
            D.skipType(s & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(B) {
      const b = R();
      return (0, i.isSet)(B.version) && (b.version = String(B.version)), b;
    },
    toJSON(B) {
      const b = {};
      return B.version !== void 0 && (b.version = B.version), b;
    },
    fromPartial(B) {
      const b = R();
      return b.version = B.version ?? "", b;
    }
  };
  function p() {
    return {
      portId: "",
      channelId: "",
      counterpartyChannelId: "",
      counterpartyVersion: "",
      proofTry: new Uint8Array(),
      proofHeight: r.Height.fromPartial({}),
      signer: ""
    };
  }
  e.MsgChannelOpenAck = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelOpenAck",
    encode(B, b = t.BinaryWriter.create()) {
      return B.portId !== "" && b.uint32(10).string(B.portId), B.channelId !== "" && b.uint32(18).string(B.channelId), B.counterpartyChannelId !== "" && b.uint32(26).string(B.counterpartyChannelId), B.counterpartyVersion !== "" && b.uint32(34).string(B.counterpartyVersion), B.proofTry.length !== 0 && b.uint32(42).bytes(B.proofTry), B.proofHeight !== void 0 && r.Height.encode(B.proofHeight, b.uint32(50).fork()).ldelim(), B.signer !== "" && b.uint32(58).string(B.signer), b;
    },
    decode(B, b) {
      const D = B instanceof t.BinaryReader ? B : new t.BinaryReader(B);
      let Q = b === void 0 ? D.len : D.pos + b;
      const H = p();
      for (; D.pos < Q; ) {
        const s = D.uint32();
        switch (s >>> 3) {
          case 1:
            H.portId = D.string();
            break;
          case 2:
            H.channelId = D.string();
            break;
          case 3:
            H.counterpartyChannelId = D.string();
            break;
          case 4:
            H.counterpartyVersion = D.string();
            break;
          case 5:
            H.proofTry = D.bytes();
            break;
          case 6:
            H.proofHeight = r.Height.decode(D, D.uint32());
            break;
          case 7:
            H.signer = D.string();
            break;
          default:
            D.skipType(s & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(B) {
      const b = p();
      return (0, i.isSet)(B.portId) && (b.portId = String(B.portId)), (0, i.isSet)(B.channelId) && (b.channelId = String(B.channelId)), (0, i.isSet)(B.counterpartyChannelId) && (b.counterpartyChannelId = String(B.counterpartyChannelId)), (0, i.isSet)(B.counterpartyVersion) && (b.counterpartyVersion = String(B.counterpartyVersion)), (0, i.isSet)(B.proofTry) && (b.proofTry = (0, i.bytesFromBase64)(B.proofTry)), (0, i.isSet)(B.proofHeight) && (b.proofHeight = r.Height.fromJSON(B.proofHeight)), (0, i.isSet)(B.signer) && (b.signer = String(B.signer)), b;
    },
    toJSON(B) {
      const b = {};
      return B.portId !== void 0 && (b.portId = B.portId), B.channelId !== void 0 && (b.channelId = B.channelId), B.counterpartyChannelId !== void 0 && (b.counterpartyChannelId = B.counterpartyChannelId), B.counterpartyVersion !== void 0 && (b.counterpartyVersion = B.counterpartyVersion), B.proofTry !== void 0 && (b.proofTry = (0, i.base64FromBytes)(B.proofTry !== void 0 ? B.proofTry : new Uint8Array())), B.proofHeight !== void 0 && (b.proofHeight = B.proofHeight ? r.Height.toJSON(B.proofHeight) : void 0), B.signer !== void 0 && (b.signer = B.signer), b;
    },
    fromPartial(B) {
      const b = p();
      return b.portId = B.portId ?? "", b.channelId = B.channelId ?? "", b.counterpartyChannelId = B.counterpartyChannelId ?? "", b.counterpartyVersion = B.counterpartyVersion ?? "", b.proofTry = B.proofTry ?? new Uint8Array(), B.proofHeight !== void 0 && B.proofHeight !== null && (b.proofHeight = r.Height.fromPartial(B.proofHeight)), b.signer = B.signer ?? "", b;
    }
  };
  function m() {
    return {};
  }
  e.MsgChannelOpenAckResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelOpenAckResponse",
    encode(B, b = t.BinaryWriter.create()) {
      return b;
    },
    decode(B, b) {
      const D = B instanceof t.BinaryReader ? B : new t.BinaryReader(B);
      let Q = b === void 0 ? D.len : D.pos + b;
      const H = m();
      for (; D.pos < Q; ) {
        const s = D.uint32();
        switch (s >>> 3) {
          default:
            D.skipType(s & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(B) {
      return m();
    },
    toJSON(B) {
      return {};
    },
    fromPartial(B) {
      return m();
    }
  };
  function v() {
    return {
      portId: "",
      channelId: "",
      proofAck: new Uint8Array(),
      proofHeight: r.Height.fromPartial({}),
      signer: ""
    };
  }
  e.MsgChannelOpenConfirm = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelOpenConfirm",
    encode(B, b = t.BinaryWriter.create()) {
      return B.portId !== "" && b.uint32(10).string(B.portId), B.channelId !== "" && b.uint32(18).string(B.channelId), B.proofAck.length !== 0 && b.uint32(26).bytes(B.proofAck), B.proofHeight !== void 0 && r.Height.encode(B.proofHeight, b.uint32(34).fork()).ldelim(), B.signer !== "" && b.uint32(42).string(B.signer), b;
    },
    decode(B, b) {
      const D = B instanceof t.BinaryReader ? B : new t.BinaryReader(B);
      let Q = b === void 0 ? D.len : D.pos + b;
      const H = v();
      for (; D.pos < Q; ) {
        const s = D.uint32();
        switch (s >>> 3) {
          case 1:
            H.portId = D.string();
            break;
          case 2:
            H.channelId = D.string();
            break;
          case 3:
            H.proofAck = D.bytes();
            break;
          case 4:
            H.proofHeight = r.Height.decode(D, D.uint32());
            break;
          case 5:
            H.signer = D.string();
            break;
          default:
            D.skipType(s & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(B) {
      const b = v();
      return (0, i.isSet)(B.portId) && (b.portId = String(B.portId)), (0, i.isSet)(B.channelId) && (b.channelId = String(B.channelId)), (0, i.isSet)(B.proofAck) && (b.proofAck = (0, i.bytesFromBase64)(B.proofAck)), (0, i.isSet)(B.proofHeight) && (b.proofHeight = r.Height.fromJSON(B.proofHeight)), (0, i.isSet)(B.signer) && (b.signer = String(B.signer)), b;
    },
    toJSON(B) {
      const b = {};
      return B.portId !== void 0 && (b.portId = B.portId), B.channelId !== void 0 && (b.channelId = B.channelId), B.proofAck !== void 0 && (b.proofAck = (0, i.base64FromBytes)(B.proofAck !== void 0 ? B.proofAck : new Uint8Array())), B.proofHeight !== void 0 && (b.proofHeight = B.proofHeight ? r.Height.toJSON(B.proofHeight) : void 0), B.signer !== void 0 && (b.signer = B.signer), b;
    },
    fromPartial(B) {
      const b = v();
      return b.portId = B.portId ?? "", b.channelId = B.channelId ?? "", b.proofAck = B.proofAck ?? new Uint8Array(), B.proofHeight !== void 0 && B.proofHeight !== null && (b.proofHeight = r.Height.fromPartial(B.proofHeight)), b.signer = B.signer ?? "", b;
    }
  };
  function a() {
    return {};
  }
  e.MsgChannelOpenConfirmResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelOpenConfirmResponse",
    encode(B, b = t.BinaryWriter.create()) {
      return b;
    },
    decode(B, b) {
      const D = B instanceof t.BinaryReader ? B : new t.BinaryReader(B);
      let Q = b === void 0 ? D.len : D.pos + b;
      const H = a();
      for (; D.pos < Q; ) {
        const s = D.uint32();
        switch (s >>> 3) {
          default:
            D.skipType(s & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(B) {
      return a();
    },
    toJSON(B) {
      return {};
    },
    fromPartial(B) {
      return a();
    }
  };
  function d() {
    return {
      portId: "",
      channelId: "",
      signer: ""
    };
  }
  e.MsgChannelCloseInit = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelCloseInit",
    encode(B, b = t.BinaryWriter.create()) {
      return B.portId !== "" && b.uint32(10).string(B.portId), B.channelId !== "" && b.uint32(18).string(B.channelId), B.signer !== "" && b.uint32(26).string(B.signer), b;
    },
    decode(B, b) {
      const D = B instanceof t.BinaryReader ? B : new t.BinaryReader(B);
      let Q = b === void 0 ? D.len : D.pos + b;
      const H = d();
      for (; D.pos < Q; ) {
        const s = D.uint32();
        switch (s >>> 3) {
          case 1:
            H.portId = D.string();
            break;
          case 2:
            H.channelId = D.string();
            break;
          case 3:
            H.signer = D.string();
            break;
          default:
            D.skipType(s & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(B) {
      const b = d();
      return (0, i.isSet)(B.portId) && (b.portId = String(B.portId)), (0, i.isSet)(B.channelId) && (b.channelId = String(B.channelId)), (0, i.isSet)(B.signer) && (b.signer = String(B.signer)), b;
    },
    toJSON(B) {
      const b = {};
      return B.portId !== void 0 && (b.portId = B.portId), B.channelId !== void 0 && (b.channelId = B.channelId), B.signer !== void 0 && (b.signer = B.signer), b;
    },
    fromPartial(B) {
      const b = d();
      return b.portId = B.portId ?? "", b.channelId = B.channelId ?? "", b.signer = B.signer ?? "", b;
    }
  };
  function y() {
    return {};
  }
  e.MsgChannelCloseInitResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelCloseInitResponse",
    encode(B, b = t.BinaryWriter.create()) {
      return b;
    },
    decode(B, b) {
      const D = B instanceof t.BinaryReader ? B : new t.BinaryReader(B);
      let Q = b === void 0 ? D.len : D.pos + b;
      const H = y();
      for (; D.pos < Q; ) {
        const s = D.uint32();
        switch (s >>> 3) {
          default:
            D.skipType(s & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(B) {
      return y();
    },
    toJSON(B) {
      return {};
    },
    fromPartial(B) {
      return y();
    }
  };
  function _() {
    return {
      portId: "",
      channelId: "",
      proofInit: new Uint8Array(),
      proofHeight: r.Height.fromPartial({}),
      signer: ""
    };
  }
  e.MsgChannelCloseConfirm = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelCloseConfirm",
    encode(B, b = t.BinaryWriter.create()) {
      return B.portId !== "" && b.uint32(10).string(B.portId), B.channelId !== "" && b.uint32(18).string(B.channelId), B.proofInit.length !== 0 && b.uint32(26).bytes(B.proofInit), B.proofHeight !== void 0 && r.Height.encode(B.proofHeight, b.uint32(34).fork()).ldelim(), B.signer !== "" && b.uint32(42).string(B.signer), b;
    },
    decode(B, b) {
      const D = B instanceof t.BinaryReader ? B : new t.BinaryReader(B);
      let Q = b === void 0 ? D.len : D.pos + b;
      const H = _();
      for (; D.pos < Q; ) {
        const s = D.uint32();
        switch (s >>> 3) {
          case 1:
            H.portId = D.string();
            break;
          case 2:
            H.channelId = D.string();
            break;
          case 3:
            H.proofInit = D.bytes();
            break;
          case 4:
            H.proofHeight = r.Height.decode(D, D.uint32());
            break;
          case 5:
            H.signer = D.string();
            break;
          default:
            D.skipType(s & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(B) {
      const b = _();
      return (0, i.isSet)(B.portId) && (b.portId = String(B.portId)), (0, i.isSet)(B.channelId) && (b.channelId = String(B.channelId)), (0, i.isSet)(B.proofInit) && (b.proofInit = (0, i.bytesFromBase64)(B.proofInit)), (0, i.isSet)(B.proofHeight) && (b.proofHeight = r.Height.fromJSON(B.proofHeight)), (0, i.isSet)(B.signer) && (b.signer = String(B.signer)), b;
    },
    toJSON(B) {
      const b = {};
      return B.portId !== void 0 && (b.portId = B.portId), B.channelId !== void 0 && (b.channelId = B.channelId), B.proofInit !== void 0 && (b.proofInit = (0, i.base64FromBytes)(B.proofInit !== void 0 ? B.proofInit : new Uint8Array())), B.proofHeight !== void 0 && (b.proofHeight = B.proofHeight ? r.Height.toJSON(B.proofHeight) : void 0), B.signer !== void 0 && (b.signer = B.signer), b;
    },
    fromPartial(B) {
      const b = _();
      return b.portId = B.portId ?? "", b.channelId = B.channelId ?? "", b.proofInit = B.proofInit ?? new Uint8Array(), B.proofHeight !== void 0 && B.proofHeight !== null && (b.proofHeight = r.Height.fromPartial(B.proofHeight)), b.signer = B.signer ?? "", b;
    }
  };
  function E() {
    return {};
  }
  e.MsgChannelCloseConfirmResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelCloseConfirmResponse",
    encode(B, b = t.BinaryWriter.create()) {
      return b;
    },
    decode(B, b) {
      const D = B instanceof t.BinaryReader ? B : new t.BinaryReader(B);
      let Q = b === void 0 ? D.len : D.pos + b;
      const H = E();
      for (; D.pos < Q; ) {
        const s = D.uint32();
        switch (s >>> 3) {
          default:
            D.skipType(s & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(B) {
      return E();
    },
    toJSON(B) {
      return {};
    },
    fromPartial(B) {
      return E();
    }
  };
  function U() {
    return {
      packet: n.Packet.fromPartial({}),
      proofCommitment: new Uint8Array(),
      proofHeight: r.Height.fromPartial({}),
      signer: ""
    };
  }
  e.MsgRecvPacket = {
    typeUrl: "/ibc.core.channel.v1.MsgRecvPacket",
    encode(B, b = t.BinaryWriter.create()) {
      return B.packet !== void 0 && n.Packet.encode(B.packet, b.uint32(10).fork()).ldelim(), B.proofCommitment.length !== 0 && b.uint32(18).bytes(B.proofCommitment), B.proofHeight !== void 0 && r.Height.encode(B.proofHeight, b.uint32(26).fork()).ldelim(), B.signer !== "" && b.uint32(34).string(B.signer), b;
    },
    decode(B, b) {
      const D = B instanceof t.BinaryReader ? B : new t.BinaryReader(B);
      let Q = b === void 0 ? D.len : D.pos + b;
      const H = U();
      for (; D.pos < Q; ) {
        const s = D.uint32();
        switch (s >>> 3) {
          case 1:
            H.packet = n.Packet.decode(D, D.uint32());
            break;
          case 2:
            H.proofCommitment = D.bytes();
            break;
          case 3:
            H.proofHeight = r.Height.decode(D, D.uint32());
            break;
          case 4:
            H.signer = D.string();
            break;
          default:
            D.skipType(s & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(B) {
      const b = U();
      return (0, i.isSet)(B.packet) && (b.packet = n.Packet.fromJSON(B.packet)), (0, i.isSet)(B.proofCommitment) && (b.proofCommitment = (0, i.bytesFromBase64)(B.proofCommitment)), (0, i.isSet)(B.proofHeight) && (b.proofHeight = r.Height.fromJSON(B.proofHeight)), (0, i.isSet)(B.signer) && (b.signer = String(B.signer)), b;
    },
    toJSON(B) {
      const b = {};
      return B.packet !== void 0 && (b.packet = B.packet ? n.Packet.toJSON(B.packet) : void 0), B.proofCommitment !== void 0 && (b.proofCommitment = (0, i.base64FromBytes)(B.proofCommitment !== void 0 ? B.proofCommitment : new Uint8Array())), B.proofHeight !== void 0 && (b.proofHeight = B.proofHeight ? r.Height.toJSON(B.proofHeight) : void 0), B.signer !== void 0 && (b.signer = B.signer), b;
    },
    fromPartial(B) {
      const b = U();
      return B.packet !== void 0 && B.packet !== null && (b.packet = n.Packet.fromPartial(B.packet)), b.proofCommitment = B.proofCommitment ?? new Uint8Array(), B.proofHeight !== void 0 && B.proofHeight !== null && (b.proofHeight = r.Height.fromPartial(B.proofHeight)), b.signer = B.signer ?? "", b;
    }
  };
  function V() {
    return {
      result: 0
    };
  }
  e.MsgRecvPacketResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgRecvPacketResponse",
    encode(B, b = t.BinaryWriter.create()) {
      return B.result !== 0 && b.uint32(8).int32(B.result), b;
    },
    decode(B, b) {
      const D = B instanceof t.BinaryReader ? B : new t.BinaryReader(B);
      let Q = b === void 0 ? D.len : D.pos + b;
      const H = V();
      for (; D.pos < Q; ) {
        const s = D.uint32();
        switch (s >>> 3) {
          case 1:
            H.result = D.int32();
            break;
          default:
            D.skipType(s & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(B) {
      const b = V();
      return (0, i.isSet)(B.result) && (b.result = S(B.result)), b;
    },
    toJSON(B) {
      const b = {};
      return B.result !== void 0 && (b.result = w(B.result)), b;
    },
    fromPartial(B) {
      const b = V();
      return b.result = B.result ?? 0, b;
    }
  };
  function o() {
    return {
      packet: n.Packet.fromPartial({}),
      proofUnreceived: new Uint8Array(),
      proofHeight: r.Height.fromPartial({}),
      nextSequenceRecv: BigInt(0),
      signer: ""
    };
  }
  e.MsgTimeout = {
    typeUrl: "/ibc.core.channel.v1.MsgTimeout",
    encode(B, b = t.BinaryWriter.create()) {
      return B.packet !== void 0 && n.Packet.encode(B.packet, b.uint32(10).fork()).ldelim(), B.proofUnreceived.length !== 0 && b.uint32(18).bytes(B.proofUnreceived), B.proofHeight !== void 0 && r.Height.encode(B.proofHeight, b.uint32(26).fork()).ldelim(), B.nextSequenceRecv !== BigInt(0) && b.uint32(32).uint64(B.nextSequenceRecv), B.signer !== "" && b.uint32(42).string(B.signer), b;
    },
    decode(B, b) {
      const D = B instanceof t.BinaryReader ? B : new t.BinaryReader(B);
      let Q = b === void 0 ? D.len : D.pos + b;
      const H = o();
      for (; D.pos < Q; ) {
        const s = D.uint32();
        switch (s >>> 3) {
          case 1:
            H.packet = n.Packet.decode(D, D.uint32());
            break;
          case 2:
            H.proofUnreceived = D.bytes();
            break;
          case 3:
            H.proofHeight = r.Height.decode(D, D.uint32());
            break;
          case 4:
            H.nextSequenceRecv = D.uint64();
            break;
          case 5:
            H.signer = D.string();
            break;
          default:
            D.skipType(s & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(B) {
      const b = o();
      return (0, i.isSet)(B.packet) && (b.packet = n.Packet.fromJSON(B.packet)), (0, i.isSet)(B.proofUnreceived) && (b.proofUnreceived = (0, i.bytesFromBase64)(B.proofUnreceived)), (0, i.isSet)(B.proofHeight) && (b.proofHeight = r.Height.fromJSON(B.proofHeight)), (0, i.isSet)(B.nextSequenceRecv) && (b.nextSequenceRecv = BigInt(B.nextSequenceRecv.toString())), (0, i.isSet)(B.signer) && (b.signer = String(B.signer)), b;
    },
    toJSON(B) {
      const b = {};
      return B.packet !== void 0 && (b.packet = B.packet ? n.Packet.toJSON(B.packet) : void 0), B.proofUnreceived !== void 0 && (b.proofUnreceived = (0, i.base64FromBytes)(B.proofUnreceived !== void 0 ? B.proofUnreceived : new Uint8Array())), B.proofHeight !== void 0 && (b.proofHeight = B.proofHeight ? r.Height.toJSON(B.proofHeight) : void 0), B.nextSequenceRecv !== void 0 && (b.nextSequenceRecv = (B.nextSequenceRecv || BigInt(0)).toString()), B.signer !== void 0 && (b.signer = B.signer), b;
    },
    fromPartial(B) {
      const b = o();
      return B.packet !== void 0 && B.packet !== null && (b.packet = n.Packet.fromPartial(B.packet)), b.proofUnreceived = B.proofUnreceived ?? new Uint8Array(), B.proofHeight !== void 0 && B.proofHeight !== null && (b.proofHeight = r.Height.fromPartial(B.proofHeight)), B.nextSequenceRecv !== void 0 && B.nextSequenceRecv !== null && (b.nextSequenceRecv = BigInt(B.nextSequenceRecv.toString())), b.signer = B.signer ?? "", b;
    }
  };
  function h() {
    return {
      result: 0
    };
  }
  e.MsgTimeoutResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgTimeoutResponse",
    encode(B, b = t.BinaryWriter.create()) {
      return B.result !== 0 && b.uint32(8).int32(B.result), b;
    },
    decode(B, b) {
      const D = B instanceof t.BinaryReader ? B : new t.BinaryReader(B);
      let Q = b === void 0 ? D.len : D.pos + b;
      const H = h();
      for (; D.pos < Q; ) {
        const s = D.uint32();
        switch (s >>> 3) {
          case 1:
            H.result = D.int32();
            break;
          default:
            D.skipType(s & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(B) {
      const b = h();
      return (0, i.isSet)(B.result) && (b.result = S(B.result)), b;
    },
    toJSON(B) {
      const b = {};
      return B.result !== void 0 && (b.result = w(B.result)), b;
    },
    fromPartial(B) {
      const b = h();
      return b.result = B.result ?? 0, b;
    }
  };
  function N() {
    return {
      packet: n.Packet.fromPartial({}),
      proofUnreceived: new Uint8Array(),
      proofClose: new Uint8Array(),
      proofHeight: r.Height.fromPartial({}),
      nextSequenceRecv: BigInt(0),
      signer: ""
    };
  }
  e.MsgTimeoutOnClose = {
    typeUrl: "/ibc.core.channel.v1.MsgTimeoutOnClose",
    encode(B, b = t.BinaryWriter.create()) {
      return B.packet !== void 0 && n.Packet.encode(B.packet, b.uint32(10).fork()).ldelim(), B.proofUnreceived.length !== 0 && b.uint32(18).bytes(B.proofUnreceived), B.proofClose.length !== 0 && b.uint32(26).bytes(B.proofClose), B.proofHeight !== void 0 && r.Height.encode(B.proofHeight, b.uint32(34).fork()).ldelim(), B.nextSequenceRecv !== BigInt(0) && b.uint32(40).uint64(B.nextSequenceRecv), B.signer !== "" && b.uint32(50).string(B.signer), b;
    },
    decode(B, b) {
      const D = B instanceof t.BinaryReader ? B : new t.BinaryReader(B);
      let Q = b === void 0 ? D.len : D.pos + b;
      const H = N();
      for (; D.pos < Q; ) {
        const s = D.uint32();
        switch (s >>> 3) {
          case 1:
            H.packet = n.Packet.decode(D, D.uint32());
            break;
          case 2:
            H.proofUnreceived = D.bytes();
            break;
          case 3:
            H.proofClose = D.bytes();
            break;
          case 4:
            H.proofHeight = r.Height.decode(D, D.uint32());
            break;
          case 5:
            H.nextSequenceRecv = D.uint64();
            break;
          case 6:
            H.signer = D.string();
            break;
          default:
            D.skipType(s & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(B) {
      const b = N();
      return (0, i.isSet)(B.packet) && (b.packet = n.Packet.fromJSON(B.packet)), (0, i.isSet)(B.proofUnreceived) && (b.proofUnreceived = (0, i.bytesFromBase64)(B.proofUnreceived)), (0, i.isSet)(B.proofClose) && (b.proofClose = (0, i.bytesFromBase64)(B.proofClose)), (0, i.isSet)(B.proofHeight) && (b.proofHeight = r.Height.fromJSON(B.proofHeight)), (0, i.isSet)(B.nextSequenceRecv) && (b.nextSequenceRecv = BigInt(B.nextSequenceRecv.toString())), (0, i.isSet)(B.signer) && (b.signer = String(B.signer)), b;
    },
    toJSON(B) {
      const b = {};
      return B.packet !== void 0 && (b.packet = B.packet ? n.Packet.toJSON(B.packet) : void 0), B.proofUnreceived !== void 0 && (b.proofUnreceived = (0, i.base64FromBytes)(B.proofUnreceived !== void 0 ? B.proofUnreceived : new Uint8Array())), B.proofClose !== void 0 && (b.proofClose = (0, i.base64FromBytes)(B.proofClose !== void 0 ? B.proofClose : new Uint8Array())), B.proofHeight !== void 0 && (b.proofHeight = B.proofHeight ? r.Height.toJSON(B.proofHeight) : void 0), B.nextSequenceRecv !== void 0 && (b.nextSequenceRecv = (B.nextSequenceRecv || BigInt(0)).toString()), B.signer !== void 0 && (b.signer = B.signer), b;
    },
    fromPartial(B) {
      const b = N();
      return B.packet !== void 0 && B.packet !== null && (b.packet = n.Packet.fromPartial(B.packet)), b.proofUnreceived = B.proofUnreceived ?? new Uint8Array(), b.proofClose = B.proofClose ?? new Uint8Array(), B.proofHeight !== void 0 && B.proofHeight !== null && (b.proofHeight = r.Height.fromPartial(B.proofHeight)), B.nextSequenceRecv !== void 0 && B.nextSequenceRecv !== null && (b.nextSequenceRecv = BigInt(B.nextSequenceRecv.toString())), b.signer = B.signer ?? "", b;
    }
  };
  function q() {
    return {
      result: 0
    };
  }
  e.MsgTimeoutOnCloseResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgTimeoutOnCloseResponse",
    encode(B, b = t.BinaryWriter.create()) {
      return B.result !== 0 && b.uint32(8).int32(B.result), b;
    },
    decode(B, b) {
      const D = B instanceof t.BinaryReader ? B : new t.BinaryReader(B);
      let Q = b === void 0 ? D.len : D.pos + b;
      const H = q();
      for (; D.pos < Q; ) {
        const s = D.uint32();
        switch (s >>> 3) {
          case 1:
            H.result = D.int32();
            break;
          default:
            D.skipType(s & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(B) {
      const b = q();
      return (0, i.isSet)(B.result) && (b.result = S(B.result)), b;
    },
    toJSON(B) {
      const b = {};
      return B.result !== void 0 && (b.result = w(B.result)), b;
    },
    fromPartial(B) {
      const b = q();
      return b.result = B.result ?? 0, b;
    }
  };
  function u() {
    return {
      packet: n.Packet.fromPartial({}),
      acknowledgement: new Uint8Array(),
      proofAcked: new Uint8Array(),
      proofHeight: r.Height.fromPartial({}),
      signer: ""
    };
  }
  e.MsgAcknowledgement = {
    typeUrl: "/ibc.core.channel.v1.MsgAcknowledgement",
    encode(B, b = t.BinaryWriter.create()) {
      return B.packet !== void 0 && n.Packet.encode(B.packet, b.uint32(10).fork()).ldelim(), B.acknowledgement.length !== 0 && b.uint32(18).bytes(B.acknowledgement), B.proofAcked.length !== 0 && b.uint32(26).bytes(B.proofAcked), B.proofHeight !== void 0 && r.Height.encode(B.proofHeight, b.uint32(34).fork()).ldelim(), B.signer !== "" && b.uint32(42).string(B.signer), b;
    },
    decode(B, b) {
      const D = B instanceof t.BinaryReader ? B : new t.BinaryReader(B);
      let Q = b === void 0 ? D.len : D.pos + b;
      const H = u();
      for (; D.pos < Q; ) {
        const s = D.uint32();
        switch (s >>> 3) {
          case 1:
            H.packet = n.Packet.decode(D, D.uint32());
            break;
          case 2:
            H.acknowledgement = D.bytes();
            break;
          case 3:
            H.proofAcked = D.bytes();
            break;
          case 4:
            H.proofHeight = r.Height.decode(D, D.uint32());
            break;
          case 5:
            H.signer = D.string();
            break;
          default:
            D.skipType(s & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(B) {
      const b = u();
      return (0, i.isSet)(B.packet) && (b.packet = n.Packet.fromJSON(B.packet)), (0, i.isSet)(B.acknowledgement) && (b.acknowledgement = (0, i.bytesFromBase64)(B.acknowledgement)), (0, i.isSet)(B.proofAcked) && (b.proofAcked = (0, i.bytesFromBase64)(B.proofAcked)), (0, i.isSet)(B.proofHeight) && (b.proofHeight = r.Height.fromJSON(B.proofHeight)), (0, i.isSet)(B.signer) && (b.signer = String(B.signer)), b;
    },
    toJSON(B) {
      const b = {};
      return B.packet !== void 0 && (b.packet = B.packet ? n.Packet.toJSON(B.packet) : void 0), B.acknowledgement !== void 0 && (b.acknowledgement = (0, i.base64FromBytes)(B.acknowledgement !== void 0 ? B.acknowledgement : new Uint8Array())), B.proofAcked !== void 0 && (b.proofAcked = (0, i.base64FromBytes)(B.proofAcked !== void 0 ? B.proofAcked : new Uint8Array())), B.proofHeight !== void 0 && (b.proofHeight = B.proofHeight ? r.Height.toJSON(B.proofHeight) : void 0), B.signer !== void 0 && (b.signer = B.signer), b;
    },
    fromPartial(B) {
      const b = u();
      return B.packet !== void 0 && B.packet !== null && (b.packet = n.Packet.fromPartial(B.packet)), b.acknowledgement = B.acknowledgement ?? new Uint8Array(), b.proofAcked = B.proofAcked ?? new Uint8Array(), B.proofHeight !== void 0 && B.proofHeight !== null && (b.proofHeight = r.Height.fromPartial(B.proofHeight)), b.signer = B.signer ?? "", b;
    }
  };
  function l() {
    return {
      result: 0
    };
  }
  e.MsgAcknowledgementResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgAcknowledgementResponse",
    encode(B, b = t.BinaryWriter.create()) {
      return B.result !== 0 && b.uint32(8).int32(B.result), b;
    },
    decode(B, b) {
      const D = B instanceof t.BinaryReader ? B : new t.BinaryReader(B);
      let Q = b === void 0 ? D.len : D.pos + b;
      const H = l();
      for (; D.pos < Q; ) {
        const s = D.uint32();
        switch (s >>> 3) {
          case 1:
            H.result = D.int32();
            break;
          default:
            D.skipType(s & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(B) {
      const b = l();
      return (0, i.isSet)(B.result) && (b.result = S(B.result)), b;
    },
    toJSON(B) {
      const b = {};
      return B.result !== void 0 && (b.result = w(B.result)), b;
    },
    fromPartial(B) {
      const b = l();
      return b.result = B.result ?? 0, b;
    }
  };
  class I {
    constructor(b) {
      this.rpc = b, this.ChannelOpenInit = this.ChannelOpenInit.bind(this), this.ChannelOpenTry = this.ChannelOpenTry.bind(this), this.ChannelOpenAck = this.ChannelOpenAck.bind(this), this.ChannelOpenConfirm = this.ChannelOpenConfirm.bind(this), this.ChannelCloseInit = this.ChannelCloseInit.bind(this), this.ChannelCloseConfirm = this.ChannelCloseConfirm.bind(this), this.RecvPacket = this.RecvPacket.bind(this), this.Timeout = this.Timeout.bind(this), this.TimeoutOnClose = this.TimeoutOnClose.bind(this), this.Acknowledgement = this.Acknowledgement.bind(this);
    }
    ChannelOpenInit(b) {
      const D = e.MsgChannelOpenInit.encode(b).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenInit", D).then((H) => e.MsgChannelOpenInitResponse.decode(new t.BinaryReader(H)));
    }
    ChannelOpenTry(b) {
      const D = e.MsgChannelOpenTry.encode(b).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenTry", D).then((H) => e.MsgChannelOpenTryResponse.decode(new t.BinaryReader(H)));
    }
    ChannelOpenAck(b) {
      const D = e.MsgChannelOpenAck.encode(b).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenAck", D).then((H) => e.MsgChannelOpenAckResponse.decode(new t.BinaryReader(H)));
    }
    ChannelOpenConfirm(b) {
      const D = e.MsgChannelOpenConfirm.encode(b).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenConfirm", D).then((H) => e.MsgChannelOpenConfirmResponse.decode(new t.BinaryReader(H)));
    }
    ChannelCloseInit(b) {
      const D = e.MsgChannelCloseInit.encode(b).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelCloseInit", D).then((H) => e.MsgChannelCloseInitResponse.decode(new t.BinaryReader(H)));
    }
    ChannelCloseConfirm(b) {
      const D = e.MsgChannelCloseConfirm.encode(b).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelCloseConfirm", D).then((H) => e.MsgChannelCloseConfirmResponse.decode(new t.BinaryReader(H)));
    }
    RecvPacket(b) {
      const D = e.MsgRecvPacket.encode(b).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "RecvPacket", D).then((H) => e.MsgRecvPacketResponse.decode(new t.BinaryReader(H)));
    }
    Timeout(b) {
      const D = e.MsgTimeout.encode(b).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "Timeout", D).then((H) => e.MsgTimeoutResponse.decode(new t.BinaryReader(H)));
    }
    TimeoutOnClose(b) {
      const D = e.MsgTimeoutOnClose.encode(b).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "TimeoutOnClose", D).then((H) => e.MsgTimeoutOnCloseResponse.decode(new t.BinaryReader(H)));
    }
    Acknowledgement(b) {
      const D = e.MsgAcknowledgement.encode(b).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "Acknowledgement", D).then((H) => e.MsgAcknowledgementResponse.decode(new t.BinaryReader(H)));
    }
  }
  e.MsgClientImpl = I;
})(Jh);
var Dh = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgSubmitMisbehaviourResponse = e.MsgSubmitMisbehaviour = e.MsgUpgradeClientResponse = e.MsgUpgradeClient = e.MsgUpdateClientResponse = e.MsgUpdateClient = e.MsgCreateClientResponse = e.MsgCreateClient = e.protobufPackage = void 0;
  const n = Pe, r = re, t = ie;
  e.protobufPackage = "ibc.core.client.v1";
  function i() {
    return {
      clientState: void 0,
      consensusState: void 0,
      signer: ""
    };
  }
  e.MsgCreateClient = {
    typeUrl: "/ibc.core.client.v1.MsgCreateClient",
    encode(m, v = r.BinaryWriter.create()) {
      return m.clientState !== void 0 && n.Any.encode(m.clientState, v.uint32(10).fork()).ldelim(), m.consensusState !== void 0 && n.Any.encode(m.consensusState, v.uint32(18).fork()).ldelim(), m.signer !== "" && v.uint32(26).string(m.signer), v;
    },
    decode(m, v) {
      const a = m instanceof r.BinaryReader ? m : new r.BinaryReader(m);
      let d = v === void 0 ? a.len : a.pos + v;
      const y = i();
      for (; a.pos < d; ) {
        const _ = a.uint32();
        switch (_ >>> 3) {
          case 1:
            y.clientState = n.Any.decode(a, a.uint32());
            break;
          case 2:
            y.consensusState = n.Any.decode(a, a.uint32());
            break;
          case 3:
            y.signer = a.string();
            break;
          default:
            a.skipType(_ & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(m) {
      const v = i();
      return (0, t.isSet)(m.clientState) && (v.clientState = n.Any.fromJSON(m.clientState)), (0, t.isSet)(m.consensusState) && (v.consensusState = n.Any.fromJSON(m.consensusState)), (0, t.isSet)(m.signer) && (v.signer = String(m.signer)), v;
    },
    toJSON(m) {
      const v = {};
      return m.clientState !== void 0 && (v.clientState = m.clientState ? n.Any.toJSON(m.clientState) : void 0), m.consensusState !== void 0 && (v.consensusState = m.consensusState ? n.Any.toJSON(m.consensusState) : void 0), m.signer !== void 0 && (v.signer = m.signer), v;
    },
    fromPartial(m) {
      const v = i();
      return m.clientState !== void 0 && m.clientState !== null && (v.clientState = n.Any.fromPartial(m.clientState)), m.consensusState !== void 0 && m.consensusState !== null && (v.consensusState = n.Any.fromPartial(m.consensusState)), v.signer = m.signer ?? "", v;
    }
  };
  function f() {
    return {};
  }
  e.MsgCreateClientResponse = {
    typeUrl: "/ibc.core.client.v1.MsgCreateClientResponse",
    encode(m, v = r.BinaryWriter.create()) {
      return v;
    },
    decode(m, v) {
      const a = m instanceof r.BinaryReader ? m : new r.BinaryReader(m);
      let d = v === void 0 ? a.len : a.pos + v;
      const y = f();
      for (; a.pos < d; ) {
        const _ = a.uint32();
        switch (_ >>> 3) {
          default:
            a.skipType(_ & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(m) {
      return f();
    },
    toJSON(m) {
      return {};
    },
    fromPartial(m) {
      return f();
    }
  };
  function S() {
    return {
      clientId: "",
      clientMessage: void 0,
      signer: ""
    };
  }
  e.MsgUpdateClient = {
    typeUrl: "/ibc.core.client.v1.MsgUpdateClient",
    encode(m, v = r.BinaryWriter.create()) {
      return m.clientId !== "" && v.uint32(10).string(m.clientId), m.clientMessage !== void 0 && n.Any.encode(m.clientMessage, v.uint32(18).fork()).ldelim(), m.signer !== "" && v.uint32(26).string(m.signer), v;
    },
    decode(m, v) {
      const a = m instanceof r.BinaryReader ? m : new r.BinaryReader(m);
      let d = v === void 0 ? a.len : a.pos + v;
      const y = S();
      for (; a.pos < d; ) {
        const _ = a.uint32();
        switch (_ >>> 3) {
          case 1:
            y.clientId = a.string();
            break;
          case 2:
            y.clientMessage = n.Any.decode(a, a.uint32());
            break;
          case 3:
            y.signer = a.string();
            break;
          default:
            a.skipType(_ & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(m) {
      const v = S();
      return (0, t.isSet)(m.clientId) && (v.clientId = String(m.clientId)), (0, t.isSet)(m.clientMessage) && (v.clientMessage = n.Any.fromJSON(m.clientMessage)), (0, t.isSet)(m.signer) && (v.signer = String(m.signer)), v;
    },
    toJSON(m) {
      const v = {};
      return m.clientId !== void 0 && (v.clientId = m.clientId), m.clientMessage !== void 0 && (v.clientMessage = m.clientMessage ? n.Any.toJSON(m.clientMessage) : void 0), m.signer !== void 0 && (v.signer = m.signer), v;
    },
    fromPartial(m) {
      const v = S();
      return v.clientId = m.clientId ?? "", m.clientMessage !== void 0 && m.clientMessage !== null && (v.clientMessage = n.Any.fromPartial(m.clientMessage)), v.signer = m.signer ?? "", v;
    }
  };
  function w() {
    return {};
  }
  e.MsgUpdateClientResponse = {
    typeUrl: "/ibc.core.client.v1.MsgUpdateClientResponse",
    encode(m, v = r.BinaryWriter.create()) {
      return v;
    },
    decode(m, v) {
      const a = m instanceof r.BinaryReader ? m : new r.BinaryReader(m);
      let d = v === void 0 ? a.len : a.pos + v;
      const y = w();
      for (; a.pos < d; ) {
        const _ = a.uint32();
        switch (_ >>> 3) {
          default:
            a.skipType(_ & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(m) {
      return w();
    },
    toJSON(m) {
      return {};
    },
    fromPartial(m) {
      return w();
    }
  };
  function T() {
    return {
      clientId: "",
      clientState: void 0,
      consensusState: void 0,
      proofUpgradeClient: new Uint8Array(),
      proofUpgradeConsensusState: new Uint8Array(),
      signer: ""
    };
  }
  e.MsgUpgradeClient = {
    typeUrl: "/ibc.core.client.v1.MsgUpgradeClient",
    encode(m, v = r.BinaryWriter.create()) {
      return m.clientId !== "" && v.uint32(10).string(m.clientId), m.clientState !== void 0 && n.Any.encode(m.clientState, v.uint32(18).fork()).ldelim(), m.consensusState !== void 0 && n.Any.encode(m.consensusState, v.uint32(26).fork()).ldelim(), m.proofUpgradeClient.length !== 0 && v.uint32(34).bytes(m.proofUpgradeClient), m.proofUpgradeConsensusState.length !== 0 && v.uint32(42).bytes(m.proofUpgradeConsensusState), m.signer !== "" && v.uint32(50).string(m.signer), v;
    },
    decode(m, v) {
      const a = m instanceof r.BinaryReader ? m : new r.BinaryReader(m);
      let d = v === void 0 ? a.len : a.pos + v;
      const y = T();
      for (; a.pos < d; ) {
        const _ = a.uint32();
        switch (_ >>> 3) {
          case 1:
            y.clientId = a.string();
            break;
          case 2:
            y.clientState = n.Any.decode(a, a.uint32());
            break;
          case 3:
            y.consensusState = n.Any.decode(a, a.uint32());
            break;
          case 4:
            y.proofUpgradeClient = a.bytes();
            break;
          case 5:
            y.proofUpgradeConsensusState = a.bytes();
            break;
          case 6:
            y.signer = a.string();
            break;
          default:
            a.skipType(_ & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(m) {
      const v = T();
      return (0, t.isSet)(m.clientId) && (v.clientId = String(m.clientId)), (0, t.isSet)(m.clientState) && (v.clientState = n.Any.fromJSON(m.clientState)), (0, t.isSet)(m.consensusState) && (v.consensusState = n.Any.fromJSON(m.consensusState)), (0, t.isSet)(m.proofUpgradeClient) && (v.proofUpgradeClient = (0, t.bytesFromBase64)(m.proofUpgradeClient)), (0, t.isSet)(m.proofUpgradeConsensusState) && (v.proofUpgradeConsensusState = (0, t.bytesFromBase64)(m.proofUpgradeConsensusState)), (0, t.isSet)(m.signer) && (v.signer = String(m.signer)), v;
    },
    toJSON(m) {
      const v = {};
      return m.clientId !== void 0 && (v.clientId = m.clientId), m.clientState !== void 0 && (v.clientState = m.clientState ? n.Any.toJSON(m.clientState) : void 0), m.consensusState !== void 0 && (v.consensusState = m.consensusState ? n.Any.toJSON(m.consensusState) : void 0), m.proofUpgradeClient !== void 0 && (v.proofUpgradeClient = (0, t.base64FromBytes)(m.proofUpgradeClient !== void 0 ? m.proofUpgradeClient : new Uint8Array())), m.proofUpgradeConsensusState !== void 0 && (v.proofUpgradeConsensusState = (0, t.base64FromBytes)(m.proofUpgradeConsensusState !== void 0 ? m.proofUpgradeConsensusState : new Uint8Array())), m.signer !== void 0 && (v.signer = m.signer), v;
    },
    fromPartial(m) {
      const v = T();
      return v.clientId = m.clientId ?? "", m.clientState !== void 0 && m.clientState !== null && (v.clientState = n.Any.fromPartial(m.clientState)), m.consensusState !== void 0 && m.consensusState !== null && (v.consensusState = n.Any.fromPartial(m.consensusState)), v.proofUpgradeClient = m.proofUpgradeClient ?? new Uint8Array(), v.proofUpgradeConsensusState = m.proofUpgradeConsensusState ?? new Uint8Array(), v.signer = m.signer ?? "", v;
    }
  };
  function J() {
    return {};
  }
  e.MsgUpgradeClientResponse = {
    typeUrl: "/ibc.core.client.v1.MsgUpgradeClientResponse",
    encode(m, v = r.BinaryWriter.create()) {
      return v;
    },
    decode(m, v) {
      const a = m instanceof r.BinaryReader ? m : new r.BinaryReader(m);
      let d = v === void 0 ? a.len : a.pos + v;
      const y = J();
      for (; a.pos < d; ) {
        const _ = a.uint32();
        switch (_ >>> 3) {
          default:
            a.skipType(_ & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(m) {
      return J();
    },
    toJSON(m) {
      return {};
    },
    fromPartial(m) {
      return J();
    }
  };
  function C() {
    return {
      clientId: "",
      misbehaviour: void 0,
      signer: ""
    };
  }
  e.MsgSubmitMisbehaviour = {
    typeUrl: "/ibc.core.client.v1.MsgSubmitMisbehaviour",
    encode(m, v = r.BinaryWriter.create()) {
      return m.clientId !== "" && v.uint32(10).string(m.clientId), m.misbehaviour !== void 0 && n.Any.encode(m.misbehaviour, v.uint32(18).fork()).ldelim(), m.signer !== "" && v.uint32(26).string(m.signer), v;
    },
    decode(m, v) {
      const a = m instanceof r.BinaryReader ? m : new r.BinaryReader(m);
      let d = v === void 0 ? a.len : a.pos + v;
      const y = C();
      for (; a.pos < d; ) {
        const _ = a.uint32();
        switch (_ >>> 3) {
          case 1:
            y.clientId = a.string();
            break;
          case 2:
            y.misbehaviour = n.Any.decode(a, a.uint32());
            break;
          case 3:
            y.signer = a.string();
            break;
          default:
            a.skipType(_ & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(m) {
      const v = C();
      return (0, t.isSet)(m.clientId) && (v.clientId = String(m.clientId)), (0, t.isSet)(m.misbehaviour) && (v.misbehaviour = n.Any.fromJSON(m.misbehaviour)), (0, t.isSet)(m.signer) && (v.signer = String(m.signer)), v;
    },
    toJSON(m) {
      const v = {};
      return m.clientId !== void 0 && (v.clientId = m.clientId), m.misbehaviour !== void 0 && (v.misbehaviour = m.misbehaviour ? n.Any.toJSON(m.misbehaviour) : void 0), m.signer !== void 0 && (v.signer = m.signer), v;
    },
    fromPartial(m) {
      const v = C();
      return v.clientId = m.clientId ?? "", m.misbehaviour !== void 0 && m.misbehaviour !== null && (v.misbehaviour = n.Any.fromPartial(m.misbehaviour)), v.signer = m.signer ?? "", v;
    }
  };
  function R() {
    return {};
  }
  e.MsgSubmitMisbehaviourResponse = {
    typeUrl: "/ibc.core.client.v1.MsgSubmitMisbehaviourResponse",
    encode(m, v = r.BinaryWriter.create()) {
      return v;
    },
    decode(m, v) {
      const a = m instanceof r.BinaryReader ? m : new r.BinaryReader(m);
      let d = v === void 0 ? a.len : a.pos + v;
      const y = R();
      for (; a.pos < d; ) {
        const _ = a.uint32();
        switch (_ >>> 3) {
          default:
            a.skipType(_ & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(m) {
      return R();
    },
    toJSON(m) {
      return {};
    },
    fromPartial(m) {
      return R();
    }
  };
  class p {
    constructor(v) {
      this.rpc = v, this.CreateClient = this.CreateClient.bind(this), this.UpdateClient = this.UpdateClient.bind(this), this.UpgradeClient = this.UpgradeClient.bind(this), this.SubmitMisbehaviour = this.SubmitMisbehaviour.bind(this);
    }
    CreateClient(v) {
      const a = e.MsgCreateClient.encode(v).finish();
      return this.rpc.request("ibc.core.client.v1.Msg", "CreateClient", a).then((y) => e.MsgCreateClientResponse.decode(new r.BinaryReader(y)));
    }
    UpdateClient(v) {
      const a = e.MsgUpdateClient.encode(v).finish();
      return this.rpc.request("ibc.core.client.v1.Msg", "UpdateClient", a).then((y) => e.MsgUpdateClientResponse.decode(new r.BinaryReader(y)));
    }
    UpgradeClient(v) {
      const a = e.MsgUpgradeClient.encode(v).finish();
      return this.rpc.request("ibc.core.client.v1.Msg", "UpgradeClient", a).then((y) => e.MsgUpgradeClientResponse.decode(new r.BinaryReader(y)));
    }
    SubmitMisbehaviour(v) {
      const a = e.MsgSubmitMisbehaviour.encode(v).finish();
      return this.rpc.request("ibc.core.client.v1.Msg", "SubmitMisbehaviour", a).then((y) => e.MsgSubmitMisbehaviourResponse.decode(new r.BinaryReader(y)));
    }
  }
  e.MsgClientImpl = p;
})(Dh);
var Mh = {}, xc = {}, gn = {}, Zc = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CompressedNonExistenceProof = e.CompressedExistenceProof = e.CompressedBatchEntry = e.CompressedBatchProof = e.BatchEntry = e.BatchProof = e.InnerSpec = e.ProofSpec = e.InnerOp = e.LeafOp = e.CommitmentProof = e.NonExistenceProof = e.ExistenceProof = e.lengthOpToJSON = e.lengthOpFromJSON = e.LengthOp = e.hashOpToJSON = e.hashOpFromJSON = e.HashOp = e.protobufPackage = void 0;
  const n = re, r = ie;
  e.protobufPackage = "cosmos.ics23.v1";
  var t;
  (function(o) {
    o[o.NO_HASH = 0] = "NO_HASH", o[o.SHA256 = 1] = "SHA256", o[o.SHA512 = 2] = "SHA512", o[o.KECCAK = 3] = "KECCAK", o[o.RIPEMD160 = 4] = "RIPEMD160", o[o.BITCOIN = 5] = "BITCOIN", o[o.SHA512_256 = 6] = "SHA512_256", o[o.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(t || (e.HashOp = t = {}));
  function i(o) {
    switch (o) {
      case 0:
      case "NO_HASH":
        return t.NO_HASH;
      case 1:
      case "SHA256":
        return t.SHA256;
      case 2:
      case "SHA512":
        return t.SHA512;
      case 3:
      case "KECCAK":
        return t.KECCAK;
      case 4:
      case "RIPEMD160":
        return t.RIPEMD160;
      case 5:
      case "BITCOIN":
        return t.BITCOIN;
      case 6:
      case "SHA512_256":
        return t.SHA512_256;
      case -1:
      case "UNRECOGNIZED":
      default:
        return t.UNRECOGNIZED;
    }
  }
  e.hashOpFromJSON = i;
  function f(o) {
    switch (o) {
      case t.NO_HASH:
        return "NO_HASH";
      case t.SHA256:
        return "SHA256";
      case t.SHA512:
        return "SHA512";
      case t.KECCAK:
        return "KECCAK";
      case t.RIPEMD160:
        return "RIPEMD160";
      case t.BITCOIN:
        return "BITCOIN";
      case t.SHA512_256:
        return "SHA512_256";
      case t.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.hashOpToJSON = f;
  var S;
  (function(o) {
    o[o.NO_PREFIX = 0] = "NO_PREFIX", o[o.VAR_PROTO = 1] = "VAR_PROTO", o[o.VAR_RLP = 2] = "VAR_RLP", o[o.FIXED32_BIG = 3] = "FIXED32_BIG", o[o.FIXED32_LITTLE = 4] = "FIXED32_LITTLE", o[o.FIXED64_BIG = 5] = "FIXED64_BIG", o[o.FIXED64_LITTLE = 6] = "FIXED64_LITTLE", o[o.REQUIRE_32_BYTES = 7] = "REQUIRE_32_BYTES", o[o.REQUIRE_64_BYTES = 8] = "REQUIRE_64_BYTES", o[o.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(S || (e.LengthOp = S = {}));
  function w(o) {
    switch (o) {
      case 0:
      case "NO_PREFIX":
        return S.NO_PREFIX;
      case 1:
      case "VAR_PROTO":
        return S.VAR_PROTO;
      case 2:
      case "VAR_RLP":
        return S.VAR_RLP;
      case 3:
      case "FIXED32_BIG":
        return S.FIXED32_BIG;
      case 4:
      case "FIXED32_LITTLE":
        return S.FIXED32_LITTLE;
      case 5:
      case "FIXED64_BIG":
        return S.FIXED64_BIG;
      case 6:
      case "FIXED64_LITTLE":
        return S.FIXED64_LITTLE;
      case 7:
      case "REQUIRE_32_BYTES":
        return S.REQUIRE_32_BYTES;
      case 8:
      case "REQUIRE_64_BYTES":
        return S.REQUIRE_64_BYTES;
      case -1:
      case "UNRECOGNIZED":
      default:
        return S.UNRECOGNIZED;
    }
  }
  e.lengthOpFromJSON = w;
  function T(o) {
    switch (o) {
      case S.NO_PREFIX:
        return "NO_PREFIX";
      case S.VAR_PROTO:
        return "VAR_PROTO";
      case S.VAR_RLP:
        return "VAR_RLP";
      case S.FIXED32_BIG:
        return "FIXED32_BIG";
      case S.FIXED32_LITTLE:
        return "FIXED32_LITTLE";
      case S.FIXED64_BIG:
        return "FIXED64_BIG";
      case S.FIXED64_LITTLE:
        return "FIXED64_LITTLE";
      case S.REQUIRE_32_BYTES:
        return "REQUIRE_32_BYTES";
      case S.REQUIRE_64_BYTES:
        return "REQUIRE_64_BYTES";
      case S.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.lengthOpToJSON = T;
  function J() {
    return {
      key: new Uint8Array(),
      value: new Uint8Array(),
      leaf: void 0,
      path: []
    };
  }
  e.ExistenceProof = {
    typeUrl: "/cosmos.ics23.v1.ExistenceProof",
    encode(o, h = n.BinaryWriter.create()) {
      o.key.length !== 0 && h.uint32(10).bytes(o.key), o.value.length !== 0 && h.uint32(18).bytes(o.value), o.leaf !== void 0 && e.LeafOp.encode(o.leaf, h.uint32(26).fork()).ldelim();
      for (const N of o.path)
        e.InnerOp.encode(N, h.uint32(34).fork()).ldelim();
      return h;
    },
    decode(o, h) {
      const N = o instanceof n.BinaryReader ? o : new n.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = J();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.key = N.bytes();
            break;
          case 2:
            u.value = N.bytes();
            break;
          case 3:
            u.leaf = e.LeafOp.decode(N, N.uint32());
            break;
          case 4:
            u.path.push(e.InnerOp.decode(N, N.uint32()));
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = J();
      return (0, r.isSet)(o.key) && (h.key = (0, r.bytesFromBase64)(o.key)), (0, r.isSet)(o.value) && (h.value = (0, r.bytesFromBase64)(o.value)), (0, r.isSet)(o.leaf) && (h.leaf = e.LeafOp.fromJSON(o.leaf)), Array.isArray(o == null ? void 0 : o.path) && (h.path = o.path.map((N) => e.InnerOp.fromJSON(N))), h;
    },
    toJSON(o) {
      const h = {};
      return o.key !== void 0 && (h.key = (0, r.base64FromBytes)(o.key !== void 0 ? o.key : new Uint8Array())), o.value !== void 0 && (h.value = (0, r.base64FromBytes)(o.value !== void 0 ? o.value : new Uint8Array())), o.leaf !== void 0 && (h.leaf = o.leaf ? e.LeafOp.toJSON(o.leaf) : void 0), o.path ? h.path = o.path.map((N) => N ? e.InnerOp.toJSON(N) : void 0) : h.path = [], h;
    },
    fromPartial(o) {
      var N;
      const h = J();
      return h.key = o.key ?? new Uint8Array(), h.value = o.value ?? new Uint8Array(), o.leaf !== void 0 && o.leaf !== null && (h.leaf = e.LeafOp.fromPartial(o.leaf)), h.path = ((N = o.path) == null ? void 0 : N.map((q) => e.InnerOp.fromPartial(q))) || [], h;
    }
  };
  function C() {
    return {
      key: new Uint8Array(),
      left: void 0,
      right: void 0
    };
  }
  e.NonExistenceProof = {
    typeUrl: "/cosmos.ics23.v1.NonExistenceProof",
    encode(o, h = n.BinaryWriter.create()) {
      return o.key.length !== 0 && h.uint32(10).bytes(o.key), o.left !== void 0 && e.ExistenceProof.encode(o.left, h.uint32(18).fork()).ldelim(), o.right !== void 0 && e.ExistenceProof.encode(o.right, h.uint32(26).fork()).ldelim(), h;
    },
    decode(o, h) {
      const N = o instanceof n.BinaryReader ? o : new n.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = C();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.key = N.bytes();
            break;
          case 2:
            u.left = e.ExistenceProof.decode(N, N.uint32());
            break;
          case 3:
            u.right = e.ExistenceProof.decode(N, N.uint32());
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = C();
      return (0, r.isSet)(o.key) && (h.key = (0, r.bytesFromBase64)(o.key)), (0, r.isSet)(o.left) && (h.left = e.ExistenceProof.fromJSON(o.left)), (0, r.isSet)(o.right) && (h.right = e.ExistenceProof.fromJSON(o.right)), h;
    },
    toJSON(o) {
      const h = {};
      return o.key !== void 0 && (h.key = (0, r.base64FromBytes)(o.key !== void 0 ? o.key : new Uint8Array())), o.left !== void 0 && (h.left = o.left ? e.ExistenceProof.toJSON(o.left) : void 0), o.right !== void 0 && (h.right = o.right ? e.ExistenceProof.toJSON(o.right) : void 0), h;
    },
    fromPartial(o) {
      const h = C();
      return h.key = o.key ?? new Uint8Array(), o.left !== void 0 && o.left !== null && (h.left = e.ExistenceProof.fromPartial(o.left)), o.right !== void 0 && o.right !== null && (h.right = e.ExistenceProof.fromPartial(o.right)), h;
    }
  };
  function R() {
    return {
      exist: void 0,
      nonexist: void 0,
      batch: void 0,
      compressed: void 0
    };
  }
  e.CommitmentProof = {
    typeUrl: "/cosmos.ics23.v1.CommitmentProof",
    encode(o, h = n.BinaryWriter.create()) {
      return o.exist !== void 0 && e.ExistenceProof.encode(o.exist, h.uint32(10).fork()).ldelim(), o.nonexist !== void 0 && e.NonExistenceProof.encode(o.nonexist, h.uint32(18).fork()).ldelim(), o.batch !== void 0 && e.BatchProof.encode(o.batch, h.uint32(26).fork()).ldelim(), o.compressed !== void 0 && e.CompressedBatchProof.encode(o.compressed, h.uint32(34).fork()).ldelim(), h;
    },
    decode(o, h) {
      const N = o instanceof n.BinaryReader ? o : new n.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = R();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.exist = e.ExistenceProof.decode(N, N.uint32());
            break;
          case 2:
            u.nonexist = e.NonExistenceProof.decode(N, N.uint32());
            break;
          case 3:
            u.batch = e.BatchProof.decode(N, N.uint32());
            break;
          case 4:
            u.compressed = e.CompressedBatchProof.decode(N, N.uint32());
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = R();
      return (0, r.isSet)(o.exist) && (h.exist = e.ExistenceProof.fromJSON(o.exist)), (0, r.isSet)(o.nonexist) && (h.nonexist = e.NonExistenceProof.fromJSON(o.nonexist)), (0, r.isSet)(o.batch) && (h.batch = e.BatchProof.fromJSON(o.batch)), (0, r.isSet)(o.compressed) && (h.compressed = e.CompressedBatchProof.fromJSON(o.compressed)), h;
    },
    toJSON(o) {
      const h = {};
      return o.exist !== void 0 && (h.exist = o.exist ? e.ExistenceProof.toJSON(o.exist) : void 0), o.nonexist !== void 0 && (h.nonexist = o.nonexist ? e.NonExistenceProof.toJSON(o.nonexist) : void 0), o.batch !== void 0 && (h.batch = o.batch ? e.BatchProof.toJSON(o.batch) : void 0), o.compressed !== void 0 && (h.compressed = o.compressed ? e.CompressedBatchProof.toJSON(o.compressed) : void 0), h;
    },
    fromPartial(o) {
      const h = R();
      return o.exist !== void 0 && o.exist !== null && (h.exist = e.ExistenceProof.fromPartial(o.exist)), o.nonexist !== void 0 && o.nonexist !== null && (h.nonexist = e.NonExistenceProof.fromPartial(o.nonexist)), o.batch !== void 0 && o.batch !== null && (h.batch = e.BatchProof.fromPartial(o.batch)), o.compressed !== void 0 && o.compressed !== null && (h.compressed = e.CompressedBatchProof.fromPartial(o.compressed)), h;
    }
  };
  function p() {
    return {
      hash: 0,
      prehashKey: 0,
      prehashValue: 0,
      length: 0,
      prefix: new Uint8Array()
    };
  }
  e.LeafOp = {
    typeUrl: "/cosmos.ics23.v1.LeafOp",
    encode(o, h = n.BinaryWriter.create()) {
      return o.hash !== 0 && h.uint32(8).int32(o.hash), o.prehashKey !== 0 && h.uint32(16).int32(o.prehashKey), o.prehashValue !== 0 && h.uint32(24).int32(o.prehashValue), o.length !== 0 && h.uint32(32).int32(o.length), o.prefix.length !== 0 && h.uint32(42).bytes(o.prefix), h;
    },
    decode(o, h) {
      const N = o instanceof n.BinaryReader ? o : new n.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = p();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.hash = N.int32();
            break;
          case 2:
            u.prehashKey = N.int32();
            break;
          case 3:
            u.prehashValue = N.int32();
            break;
          case 4:
            u.length = N.int32();
            break;
          case 5:
            u.prefix = N.bytes();
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = p();
      return (0, r.isSet)(o.hash) && (h.hash = i(o.hash)), (0, r.isSet)(o.prehashKey) && (h.prehashKey = i(o.prehashKey)), (0, r.isSet)(o.prehashValue) && (h.prehashValue = i(o.prehashValue)), (0, r.isSet)(o.length) && (h.length = w(o.length)), (0, r.isSet)(o.prefix) && (h.prefix = (0, r.bytesFromBase64)(o.prefix)), h;
    },
    toJSON(o) {
      const h = {};
      return o.hash !== void 0 && (h.hash = f(o.hash)), o.prehashKey !== void 0 && (h.prehashKey = f(o.prehashKey)), o.prehashValue !== void 0 && (h.prehashValue = f(o.prehashValue)), o.length !== void 0 && (h.length = T(o.length)), o.prefix !== void 0 && (h.prefix = (0, r.base64FromBytes)(o.prefix !== void 0 ? o.prefix : new Uint8Array())), h;
    },
    fromPartial(o) {
      const h = p();
      return h.hash = o.hash ?? 0, h.prehashKey = o.prehashKey ?? 0, h.prehashValue = o.prehashValue ?? 0, h.length = o.length ?? 0, h.prefix = o.prefix ?? new Uint8Array(), h;
    }
  };
  function m() {
    return {
      hash: 0,
      prefix: new Uint8Array(),
      suffix: new Uint8Array()
    };
  }
  e.InnerOp = {
    typeUrl: "/cosmos.ics23.v1.InnerOp",
    encode(o, h = n.BinaryWriter.create()) {
      return o.hash !== 0 && h.uint32(8).int32(o.hash), o.prefix.length !== 0 && h.uint32(18).bytes(o.prefix), o.suffix.length !== 0 && h.uint32(26).bytes(o.suffix), h;
    },
    decode(o, h) {
      const N = o instanceof n.BinaryReader ? o : new n.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = m();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.hash = N.int32();
            break;
          case 2:
            u.prefix = N.bytes();
            break;
          case 3:
            u.suffix = N.bytes();
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = m();
      return (0, r.isSet)(o.hash) && (h.hash = i(o.hash)), (0, r.isSet)(o.prefix) && (h.prefix = (0, r.bytesFromBase64)(o.prefix)), (0, r.isSet)(o.suffix) && (h.suffix = (0, r.bytesFromBase64)(o.suffix)), h;
    },
    toJSON(o) {
      const h = {};
      return o.hash !== void 0 && (h.hash = f(o.hash)), o.prefix !== void 0 && (h.prefix = (0, r.base64FromBytes)(o.prefix !== void 0 ? o.prefix : new Uint8Array())), o.suffix !== void 0 && (h.suffix = (0, r.base64FromBytes)(o.suffix !== void 0 ? o.suffix : new Uint8Array())), h;
    },
    fromPartial(o) {
      const h = m();
      return h.hash = o.hash ?? 0, h.prefix = o.prefix ?? new Uint8Array(), h.suffix = o.suffix ?? new Uint8Array(), h;
    }
  };
  function v() {
    return {
      leafSpec: void 0,
      innerSpec: void 0,
      maxDepth: 0,
      minDepth: 0
    };
  }
  e.ProofSpec = {
    typeUrl: "/cosmos.ics23.v1.ProofSpec",
    encode(o, h = n.BinaryWriter.create()) {
      return o.leafSpec !== void 0 && e.LeafOp.encode(o.leafSpec, h.uint32(10).fork()).ldelim(), o.innerSpec !== void 0 && e.InnerSpec.encode(o.innerSpec, h.uint32(18).fork()).ldelim(), o.maxDepth !== 0 && h.uint32(24).int32(o.maxDepth), o.minDepth !== 0 && h.uint32(32).int32(o.minDepth), h;
    },
    decode(o, h) {
      const N = o instanceof n.BinaryReader ? o : new n.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = v();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.leafSpec = e.LeafOp.decode(N, N.uint32());
            break;
          case 2:
            u.innerSpec = e.InnerSpec.decode(N, N.uint32());
            break;
          case 3:
            u.maxDepth = N.int32();
            break;
          case 4:
            u.minDepth = N.int32();
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = v();
      return (0, r.isSet)(o.leafSpec) && (h.leafSpec = e.LeafOp.fromJSON(o.leafSpec)), (0, r.isSet)(o.innerSpec) && (h.innerSpec = e.InnerSpec.fromJSON(o.innerSpec)), (0, r.isSet)(o.maxDepth) && (h.maxDepth = Number(o.maxDepth)), (0, r.isSet)(o.minDepth) && (h.minDepth = Number(o.minDepth)), h;
    },
    toJSON(o) {
      const h = {};
      return o.leafSpec !== void 0 && (h.leafSpec = o.leafSpec ? e.LeafOp.toJSON(o.leafSpec) : void 0), o.innerSpec !== void 0 && (h.innerSpec = o.innerSpec ? e.InnerSpec.toJSON(o.innerSpec) : void 0), o.maxDepth !== void 0 && (h.maxDepth = Math.round(o.maxDepth)), o.minDepth !== void 0 && (h.minDepth = Math.round(o.minDepth)), h;
    },
    fromPartial(o) {
      const h = v();
      return o.leafSpec !== void 0 && o.leafSpec !== null && (h.leafSpec = e.LeafOp.fromPartial(o.leafSpec)), o.innerSpec !== void 0 && o.innerSpec !== null && (h.innerSpec = e.InnerSpec.fromPartial(o.innerSpec)), h.maxDepth = o.maxDepth ?? 0, h.minDepth = o.minDepth ?? 0, h;
    }
  };
  function a() {
    return {
      childOrder: [],
      childSize: 0,
      minPrefixLength: 0,
      maxPrefixLength: 0,
      emptyChild: new Uint8Array(),
      hash: 0
    };
  }
  e.InnerSpec = {
    typeUrl: "/cosmos.ics23.v1.InnerSpec",
    encode(o, h = n.BinaryWriter.create()) {
      h.uint32(10).fork();
      for (const N of o.childOrder)
        h.int32(N);
      return h.ldelim(), o.childSize !== 0 && h.uint32(16).int32(o.childSize), o.minPrefixLength !== 0 && h.uint32(24).int32(o.minPrefixLength), o.maxPrefixLength !== 0 && h.uint32(32).int32(o.maxPrefixLength), o.emptyChild.length !== 0 && h.uint32(42).bytes(o.emptyChild), o.hash !== 0 && h.uint32(48).int32(o.hash), h;
    },
    decode(o, h) {
      const N = o instanceof n.BinaryReader ? o : new n.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = a();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            if ((l & 7) === 2) {
              const I = N.uint32() + N.pos;
              for (; N.pos < I; )
                u.childOrder.push(N.int32());
            } else
              u.childOrder.push(N.int32());
            break;
          case 2:
            u.childSize = N.int32();
            break;
          case 3:
            u.minPrefixLength = N.int32();
            break;
          case 4:
            u.maxPrefixLength = N.int32();
            break;
          case 5:
            u.emptyChild = N.bytes();
            break;
          case 6:
            u.hash = N.int32();
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = a();
      return Array.isArray(o == null ? void 0 : o.childOrder) && (h.childOrder = o.childOrder.map((N) => Number(N))), (0, r.isSet)(o.childSize) && (h.childSize = Number(o.childSize)), (0, r.isSet)(o.minPrefixLength) && (h.minPrefixLength = Number(o.minPrefixLength)), (0, r.isSet)(o.maxPrefixLength) && (h.maxPrefixLength = Number(o.maxPrefixLength)), (0, r.isSet)(o.emptyChild) && (h.emptyChild = (0, r.bytesFromBase64)(o.emptyChild)), (0, r.isSet)(o.hash) && (h.hash = i(o.hash)), h;
    },
    toJSON(o) {
      const h = {};
      return o.childOrder ? h.childOrder = o.childOrder.map((N) => Math.round(N)) : h.childOrder = [], o.childSize !== void 0 && (h.childSize = Math.round(o.childSize)), o.minPrefixLength !== void 0 && (h.minPrefixLength = Math.round(o.minPrefixLength)), o.maxPrefixLength !== void 0 && (h.maxPrefixLength = Math.round(o.maxPrefixLength)), o.emptyChild !== void 0 && (h.emptyChild = (0, r.base64FromBytes)(o.emptyChild !== void 0 ? o.emptyChild : new Uint8Array())), o.hash !== void 0 && (h.hash = f(o.hash)), h;
    },
    fromPartial(o) {
      var N;
      const h = a();
      return h.childOrder = ((N = o.childOrder) == null ? void 0 : N.map((q) => q)) || [], h.childSize = o.childSize ?? 0, h.minPrefixLength = o.minPrefixLength ?? 0, h.maxPrefixLength = o.maxPrefixLength ?? 0, h.emptyChild = o.emptyChild ?? new Uint8Array(), h.hash = o.hash ?? 0, h;
    }
  };
  function d() {
    return {
      entries: []
    };
  }
  e.BatchProof = {
    typeUrl: "/cosmos.ics23.v1.BatchProof",
    encode(o, h = n.BinaryWriter.create()) {
      for (const N of o.entries)
        e.BatchEntry.encode(N, h.uint32(10).fork()).ldelim();
      return h;
    },
    decode(o, h) {
      const N = o instanceof n.BinaryReader ? o : new n.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = d();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.entries.push(e.BatchEntry.decode(N, N.uint32()));
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = d();
      return Array.isArray(o == null ? void 0 : o.entries) && (h.entries = o.entries.map((N) => e.BatchEntry.fromJSON(N))), h;
    },
    toJSON(o) {
      const h = {};
      return o.entries ? h.entries = o.entries.map((N) => N ? e.BatchEntry.toJSON(N) : void 0) : h.entries = [], h;
    },
    fromPartial(o) {
      var N;
      const h = d();
      return h.entries = ((N = o.entries) == null ? void 0 : N.map((q) => e.BatchEntry.fromPartial(q))) || [], h;
    }
  };
  function y() {
    return {
      exist: void 0,
      nonexist: void 0
    };
  }
  e.BatchEntry = {
    typeUrl: "/cosmos.ics23.v1.BatchEntry",
    encode(o, h = n.BinaryWriter.create()) {
      return o.exist !== void 0 && e.ExistenceProof.encode(o.exist, h.uint32(10).fork()).ldelim(), o.nonexist !== void 0 && e.NonExistenceProof.encode(o.nonexist, h.uint32(18).fork()).ldelim(), h;
    },
    decode(o, h) {
      const N = o instanceof n.BinaryReader ? o : new n.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = y();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.exist = e.ExistenceProof.decode(N, N.uint32());
            break;
          case 2:
            u.nonexist = e.NonExistenceProof.decode(N, N.uint32());
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = y();
      return (0, r.isSet)(o.exist) && (h.exist = e.ExistenceProof.fromJSON(o.exist)), (0, r.isSet)(o.nonexist) && (h.nonexist = e.NonExistenceProof.fromJSON(o.nonexist)), h;
    },
    toJSON(o) {
      const h = {};
      return o.exist !== void 0 && (h.exist = o.exist ? e.ExistenceProof.toJSON(o.exist) : void 0), o.nonexist !== void 0 && (h.nonexist = o.nonexist ? e.NonExistenceProof.toJSON(o.nonexist) : void 0), h;
    },
    fromPartial(o) {
      const h = y();
      return o.exist !== void 0 && o.exist !== null && (h.exist = e.ExistenceProof.fromPartial(o.exist)), o.nonexist !== void 0 && o.nonexist !== null && (h.nonexist = e.NonExistenceProof.fromPartial(o.nonexist)), h;
    }
  };
  function _() {
    return {
      entries: [],
      lookupInners: []
    };
  }
  e.CompressedBatchProof = {
    typeUrl: "/cosmos.ics23.v1.CompressedBatchProof",
    encode(o, h = n.BinaryWriter.create()) {
      for (const N of o.entries)
        e.CompressedBatchEntry.encode(N, h.uint32(10).fork()).ldelim();
      for (const N of o.lookupInners)
        e.InnerOp.encode(N, h.uint32(18).fork()).ldelim();
      return h;
    },
    decode(o, h) {
      const N = o instanceof n.BinaryReader ? o : new n.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = _();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.entries.push(e.CompressedBatchEntry.decode(N, N.uint32()));
            break;
          case 2:
            u.lookupInners.push(e.InnerOp.decode(N, N.uint32()));
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = _();
      return Array.isArray(o == null ? void 0 : o.entries) && (h.entries = o.entries.map((N) => e.CompressedBatchEntry.fromJSON(N))), Array.isArray(o == null ? void 0 : o.lookupInners) && (h.lookupInners = o.lookupInners.map((N) => e.InnerOp.fromJSON(N))), h;
    },
    toJSON(o) {
      const h = {};
      return o.entries ? h.entries = o.entries.map((N) => N ? e.CompressedBatchEntry.toJSON(N) : void 0) : h.entries = [], o.lookupInners ? h.lookupInners = o.lookupInners.map((N) => N ? e.InnerOp.toJSON(N) : void 0) : h.lookupInners = [], h;
    },
    fromPartial(o) {
      var N, q;
      const h = _();
      return h.entries = ((N = o.entries) == null ? void 0 : N.map((u) => e.CompressedBatchEntry.fromPartial(u))) || [], h.lookupInners = ((q = o.lookupInners) == null ? void 0 : q.map((u) => e.InnerOp.fromPartial(u))) || [], h;
    }
  };
  function E() {
    return {
      exist: void 0,
      nonexist: void 0
    };
  }
  e.CompressedBatchEntry = {
    typeUrl: "/cosmos.ics23.v1.CompressedBatchEntry",
    encode(o, h = n.BinaryWriter.create()) {
      return o.exist !== void 0 && e.CompressedExistenceProof.encode(o.exist, h.uint32(10).fork()).ldelim(), o.nonexist !== void 0 && e.CompressedNonExistenceProof.encode(o.nonexist, h.uint32(18).fork()).ldelim(), h;
    },
    decode(o, h) {
      const N = o instanceof n.BinaryReader ? o : new n.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = E();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.exist = e.CompressedExistenceProof.decode(N, N.uint32());
            break;
          case 2:
            u.nonexist = e.CompressedNonExistenceProof.decode(N, N.uint32());
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = E();
      return (0, r.isSet)(o.exist) && (h.exist = e.CompressedExistenceProof.fromJSON(o.exist)), (0, r.isSet)(o.nonexist) && (h.nonexist = e.CompressedNonExistenceProof.fromJSON(o.nonexist)), h;
    },
    toJSON(o) {
      const h = {};
      return o.exist !== void 0 && (h.exist = o.exist ? e.CompressedExistenceProof.toJSON(o.exist) : void 0), o.nonexist !== void 0 && (h.nonexist = o.nonexist ? e.CompressedNonExistenceProof.toJSON(o.nonexist) : void 0), h;
    },
    fromPartial(o) {
      const h = E();
      return o.exist !== void 0 && o.exist !== null && (h.exist = e.CompressedExistenceProof.fromPartial(o.exist)), o.nonexist !== void 0 && o.nonexist !== null && (h.nonexist = e.CompressedNonExistenceProof.fromPartial(o.nonexist)), h;
    }
  };
  function U() {
    return {
      key: new Uint8Array(),
      value: new Uint8Array(),
      leaf: void 0,
      path: []
    };
  }
  e.CompressedExistenceProof = {
    typeUrl: "/cosmos.ics23.v1.CompressedExistenceProof",
    encode(o, h = n.BinaryWriter.create()) {
      o.key.length !== 0 && h.uint32(10).bytes(o.key), o.value.length !== 0 && h.uint32(18).bytes(o.value), o.leaf !== void 0 && e.LeafOp.encode(o.leaf, h.uint32(26).fork()).ldelim(), h.uint32(34).fork();
      for (const N of o.path)
        h.int32(N);
      return h.ldelim(), h;
    },
    decode(o, h) {
      const N = o instanceof n.BinaryReader ? o : new n.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = U();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.key = N.bytes();
            break;
          case 2:
            u.value = N.bytes();
            break;
          case 3:
            u.leaf = e.LeafOp.decode(N, N.uint32());
            break;
          case 4:
            if ((l & 7) === 2) {
              const I = N.uint32() + N.pos;
              for (; N.pos < I; )
                u.path.push(N.int32());
            } else
              u.path.push(N.int32());
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = U();
      return (0, r.isSet)(o.key) && (h.key = (0, r.bytesFromBase64)(o.key)), (0, r.isSet)(o.value) && (h.value = (0, r.bytesFromBase64)(o.value)), (0, r.isSet)(o.leaf) && (h.leaf = e.LeafOp.fromJSON(o.leaf)), Array.isArray(o == null ? void 0 : o.path) && (h.path = o.path.map((N) => Number(N))), h;
    },
    toJSON(o) {
      const h = {};
      return o.key !== void 0 && (h.key = (0, r.base64FromBytes)(o.key !== void 0 ? o.key : new Uint8Array())), o.value !== void 0 && (h.value = (0, r.base64FromBytes)(o.value !== void 0 ? o.value : new Uint8Array())), o.leaf !== void 0 && (h.leaf = o.leaf ? e.LeafOp.toJSON(o.leaf) : void 0), o.path ? h.path = o.path.map((N) => Math.round(N)) : h.path = [], h;
    },
    fromPartial(o) {
      var N;
      const h = U();
      return h.key = o.key ?? new Uint8Array(), h.value = o.value ?? new Uint8Array(), o.leaf !== void 0 && o.leaf !== null && (h.leaf = e.LeafOp.fromPartial(o.leaf)), h.path = ((N = o.path) == null ? void 0 : N.map((q) => q)) || [], h;
    }
  };
  function V() {
    return {
      key: new Uint8Array(),
      left: void 0,
      right: void 0
    };
  }
  e.CompressedNonExistenceProof = {
    typeUrl: "/cosmos.ics23.v1.CompressedNonExistenceProof",
    encode(o, h = n.BinaryWriter.create()) {
      return o.key.length !== 0 && h.uint32(10).bytes(o.key), o.left !== void 0 && e.CompressedExistenceProof.encode(o.left, h.uint32(18).fork()).ldelim(), o.right !== void 0 && e.CompressedExistenceProof.encode(o.right, h.uint32(26).fork()).ldelim(), h;
    },
    decode(o, h) {
      const N = o instanceof n.BinaryReader ? o : new n.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = V();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.key = N.bytes();
            break;
          case 2:
            u.left = e.CompressedExistenceProof.decode(N, N.uint32());
            break;
          case 3:
            u.right = e.CompressedExistenceProof.decode(N, N.uint32());
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = V();
      return (0, r.isSet)(o.key) && (h.key = (0, r.bytesFromBase64)(o.key)), (0, r.isSet)(o.left) && (h.left = e.CompressedExistenceProof.fromJSON(o.left)), (0, r.isSet)(o.right) && (h.right = e.CompressedExistenceProof.fromJSON(o.right)), h;
    },
    toJSON(o) {
      const h = {};
      return o.key !== void 0 && (h.key = (0, r.base64FromBytes)(o.key !== void 0 ? o.key : new Uint8Array())), o.left !== void 0 && (h.left = o.left ? e.CompressedExistenceProof.toJSON(o.left) : void 0), o.right !== void 0 && (h.right = o.right ? e.CompressedExistenceProof.toJSON(o.right) : void 0), h;
    },
    fromPartial(o) {
      const h = V();
      return h.key = o.key ?? new Uint8Array(), o.left !== void 0 && o.left !== null && (h.left = e.CompressedExistenceProof.fromPartial(o.left)), o.right !== void 0 && o.right !== null && (h.right = e.CompressedExistenceProof.fromPartial(o.right)), h;
    }
  };
})(Zc);
Object.defineProperty(gn, "__esModule", { value: !0 });
gn.MerkleProof = gn.MerklePath = gn.MerklePrefix = gn.MerkleRoot = gn.protobufPackage = void 0;
const eo = Zc, qn = re, Jr = ie;
gn.protobufPackage = "ibc.core.commitment.v1";
function fu() {
  return {
    hash: new Uint8Array()
  };
}
gn.MerkleRoot = {
  typeUrl: "/ibc.core.commitment.v1.MerkleRoot",
  encode(e, n = qn.BinaryWriter.create()) {
    return e.hash.length !== 0 && n.uint32(10).bytes(e.hash), n;
  },
  decode(e, n) {
    const r = e instanceof qn.BinaryReader ? e : new qn.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = fu();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.hash = r.bytes();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = fu();
    return (0, Jr.isSet)(e.hash) && (n.hash = (0, Jr.bytesFromBase64)(e.hash)), n;
  },
  toJSON(e) {
    const n = {};
    return e.hash !== void 0 && (n.hash = (0, Jr.base64FromBytes)(e.hash !== void 0 ? e.hash : new Uint8Array())), n;
  },
  fromPartial(e) {
    const n = fu();
    return n.hash = e.hash ?? new Uint8Array(), n;
  }
};
function pu() {
  return {
    keyPrefix: new Uint8Array()
  };
}
gn.MerklePrefix = {
  typeUrl: "/ibc.core.commitment.v1.MerklePrefix",
  encode(e, n = qn.BinaryWriter.create()) {
    return e.keyPrefix.length !== 0 && n.uint32(10).bytes(e.keyPrefix), n;
  },
  decode(e, n) {
    const r = e instanceof qn.BinaryReader ? e : new qn.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = pu();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.keyPrefix = r.bytes();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = pu();
    return (0, Jr.isSet)(e.keyPrefix) && (n.keyPrefix = (0, Jr.bytesFromBase64)(e.keyPrefix)), n;
  },
  toJSON(e) {
    const n = {};
    return e.keyPrefix !== void 0 && (n.keyPrefix = (0, Jr.base64FromBytes)(e.keyPrefix !== void 0 ? e.keyPrefix : new Uint8Array())), n;
  },
  fromPartial(e) {
    const n = pu();
    return n.keyPrefix = e.keyPrefix ?? new Uint8Array(), n;
  }
};
function hu() {
  return {
    keyPath: []
  };
}
gn.MerklePath = {
  typeUrl: "/ibc.core.commitment.v1.MerklePath",
  encode(e, n = qn.BinaryWriter.create()) {
    for (const r of e.keyPath)
      n.uint32(10).string(r);
    return n;
  },
  decode(e, n) {
    const r = e instanceof qn.BinaryReader ? e : new qn.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = hu();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.keyPath.push(r.string());
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = hu();
    return Array.isArray(e == null ? void 0 : e.keyPath) && (n.keyPath = e.keyPath.map((r) => String(r))), n;
  },
  toJSON(e) {
    const n = {};
    return e.keyPath ? n.keyPath = e.keyPath.map((r) => r) : n.keyPath = [], n;
  },
  fromPartial(e) {
    var r;
    const n = hu();
    return n.keyPath = ((r = e.keyPath) == null ? void 0 : r.map((t) => t)) || [], n;
  }
};
function yu() {
  return {
    proofs: []
  };
}
gn.MerkleProof = {
  typeUrl: "/ibc.core.commitment.v1.MerkleProof",
  encode(e, n = qn.BinaryWriter.create()) {
    for (const r of e.proofs)
      eo.CommitmentProof.encode(r, n.uint32(10).fork()).ldelim();
    return n;
  },
  decode(e, n) {
    const r = e instanceof qn.BinaryReader ? e : new qn.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = yu();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.proofs.push(eo.CommitmentProof.decode(r, r.uint32()));
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = yu();
    return Array.isArray(e == null ? void 0 : e.proofs) && (n.proofs = e.proofs.map((r) => eo.CommitmentProof.fromJSON(r))), n;
  },
  toJSON(e) {
    const n = {};
    return e.proofs ? n.proofs = e.proofs.map((r) => r ? eo.CommitmentProof.toJSON(r) : void 0) : n.proofs = [], n;
  },
  fromPartial(e) {
    var r;
    const n = yu();
    return n.proofs = ((r = e.proofs) == null ? void 0 : r.map((t) => eo.CommitmentProof.fromPartial(t))) || [], n;
  }
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Params = e.Version = e.ConnectionPaths = e.ClientPaths = e.Counterparty = e.IdentifiedConnection = e.ConnectionEnd = e.stateToJSON = e.stateFromJSON = e.State = e.protobufPackage = void 0;
  const n = gn, r = re, t = ie;
  e.protobufPackage = "ibc.core.connection.v1";
  var i;
  (function(v) {
    v[v.STATE_UNINITIALIZED_UNSPECIFIED = 0] = "STATE_UNINITIALIZED_UNSPECIFIED", v[v.STATE_INIT = 1] = "STATE_INIT", v[v.STATE_TRYOPEN = 2] = "STATE_TRYOPEN", v[v.STATE_OPEN = 3] = "STATE_OPEN", v[v.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(i || (e.State = i = {}));
  function f(v) {
    switch (v) {
      case 0:
      case "STATE_UNINITIALIZED_UNSPECIFIED":
        return i.STATE_UNINITIALIZED_UNSPECIFIED;
      case 1:
      case "STATE_INIT":
        return i.STATE_INIT;
      case 2:
      case "STATE_TRYOPEN":
        return i.STATE_TRYOPEN;
      case 3:
      case "STATE_OPEN":
        return i.STATE_OPEN;
      case -1:
      case "UNRECOGNIZED":
      default:
        return i.UNRECOGNIZED;
    }
  }
  e.stateFromJSON = f;
  function S(v) {
    switch (v) {
      case i.STATE_UNINITIALIZED_UNSPECIFIED:
        return "STATE_UNINITIALIZED_UNSPECIFIED";
      case i.STATE_INIT:
        return "STATE_INIT";
      case i.STATE_TRYOPEN:
        return "STATE_TRYOPEN";
      case i.STATE_OPEN:
        return "STATE_OPEN";
      case i.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.stateToJSON = S;
  function w() {
    return {
      clientId: "",
      versions: [],
      state: 0,
      counterparty: e.Counterparty.fromPartial({}),
      delayPeriod: BigInt(0)
    };
  }
  e.ConnectionEnd = {
    typeUrl: "/ibc.core.connection.v1.ConnectionEnd",
    encode(v, a = r.BinaryWriter.create()) {
      v.clientId !== "" && a.uint32(10).string(v.clientId);
      for (const d of v.versions)
        e.Version.encode(d, a.uint32(18).fork()).ldelim();
      return v.state !== 0 && a.uint32(24).int32(v.state), v.counterparty !== void 0 && e.Counterparty.encode(v.counterparty, a.uint32(34).fork()).ldelim(), v.delayPeriod !== BigInt(0) && a.uint32(40).uint64(v.delayPeriod), a;
    },
    decode(v, a) {
      const d = v instanceof r.BinaryReader ? v : new r.BinaryReader(v);
      let y = a === void 0 ? d.len : d.pos + a;
      const _ = w();
      for (; d.pos < y; ) {
        const E = d.uint32();
        switch (E >>> 3) {
          case 1:
            _.clientId = d.string();
            break;
          case 2:
            _.versions.push(e.Version.decode(d, d.uint32()));
            break;
          case 3:
            _.state = d.int32();
            break;
          case 4:
            _.counterparty = e.Counterparty.decode(d, d.uint32());
            break;
          case 5:
            _.delayPeriod = d.uint64();
            break;
          default:
            d.skipType(E & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(v) {
      const a = w();
      return (0, t.isSet)(v.clientId) && (a.clientId = String(v.clientId)), Array.isArray(v == null ? void 0 : v.versions) && (a.versions = v.versions.map((d) => e.Version.fromJSON(d))), (0, t.isSet)(v.state) && (a.state = f(v.state)), (0, t.isSet)(v.counterparty) && (a.counterparty = e.Counterparty.fromJSON(v.counterparty)), (0, t.isSet)(v.delayPeriod) && (a.delayPeriod = BigInt(v.delayPeriod.toString())), a;
    },
    toJSON(v) {
      const a = {};
      return v.clientId !== void 0 && (a.clientId = v.clientId), v.versions ? a.versions = v.versions.map((d) => d ? e.Version.toJSON(d) : void 0) : a.versions = [], v.state !== void 0 && (a.state = S(v.state)), v.counterparty !== void 0 && (a.counterparty = v.counterparty ? e.Counterparty.toJSON(v.counterparty) : void 0), v.delayPeriod !== void 0 && (a.delayPeriod = (v.delayPeriod || BigInt(0)).toString()), a;
    },
    fromPartial(v) {
      var d;
      const a = w();
      return a.clientId = v.clientId ?? "", a.versions = ((d = v.versions) == null ? void 0 : d.map((y) => e.Version.fromPartial(y))) || [], a.state = v.state ?? 0, v.counterparty !== void 0 && v.counterparty !== null && (a.counterparty = e.Counterparty.fromPartial(v.counterparty)), v.delayPeriod !== void 0 && v.delayPeriod !== null && (a.delayPeriod = BigInt(v.delayPeriod.toString())), a;
    }
  };
  function T() {
    return {
      id: "",
      clientId: "",
      versions: [],
      state: 0,
      counterparty: e.Counterparty.fromPartial({}),
      delayPeriod: BigInt(0)
    };
  }
  e.IdentifiedConnection = {
    typeUrl: "/ibc.core.connection.v1.IdentifiedConnection",
    encode(v, a = r.BinaryWriter.create()) {
      v.id !== "" && a.uint32(10).string(v.id), v.clientId !== "" && a.uint32(18).string(v.clientId);
      for (const d of v.versions)
        e.Version.encode(d, a.uint32(26).fork()).ldelim();
      return v.state !== 0 && a.uint32(32).int32(v.state), v.counterparty !== void 0 && e.Counterparty.encode(v.counterparty, a.uint32(42).fork()).ldelim(), v.delayPeriod !== BigInt(0) && a.uint32(48).uint64(v.delayPeriod), a;
    },
    decode(v, a) {
      const d = v instanceof r.BinaryReader ? v : new r.BinaryReader(v);
      let y = a === void 0 ? d.len : d.pos + a;
      const _ = T();
      for (; d.pos < y; ) {
        const E = d.uint32();
        switch (E >>> 3) {
          case 1:
            _.id = d.string();
            break;
          case 2:
            _.clientId = d.string();
            break;
          case 3:
            _.versions.push(e.Version.decode(d, d.uint32()));
            break;
          case 4:
            _.state = d.int32();
            break;
          case 5:
            _.counterparty = e.Counterparty.decode(d, d.uint32());
            break;
          case 6:
            _.delayPeriod = d.uint64();
            break;
          default:
            d.skipType(E & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(v) {
      const a = T();
      return (0, t.isSet)(v.id) && (a.id = String(v.id)), (0, t.isSet)(v.clientId) && (a.clientId = String(v.clientId)), Array.isArray(v == null ? void 0 : v.versions) && (a.versions = v.versions.map((d) => e.Version.fromJSON(d))), (0, t.isSet)(v.state) && (a.state = f(v.state)), (0, t.isSet)(v.counterparty) && (a.counterparty = e.Counterparty.fromJSON(v.counterparty)), (0, t.isSet)(v.delayPeriod) && (a.delayPeriod = BigInt(v.delayPeriod.toString())), a;
    },
    toJSON(v) {
      const a = {};
      return v.id !== void 0 && (a.id = v.id), v.clientId !== void 0 && (a.clientId = v.clientId), v.versions ? a.versions = v.versions.map((d) => d ? e.Version.toJSON(d) : void 0) : a.versions = [], v.state !== void 0 && (a.state = S(v.state)), v.counterparty !== void 0 && (a.counterparty = v.counterparty ? e.Counterparty.toJSON(v.counterparty) : void 0), v.delayPeriod !== void 0 && (a.delayPeriod = (v.delayPeriod || BigInt(0)).toString()), a;
    },
    fromPartial(v) {
      var d;
      const a = T();
      return a.id = v.id ?? "", a.clientId = v.clientId ?? "", a.versions = ((d = v.versions) == null ? void 0 : d.map((y) => e.Version.fromPartial(y))) || [], a.state = v.state ?? 0, v.counterparty !== void 0 && v.counterparty !== null && (a.counterparty = e.Counterparty.fromPartial(v.counterparty)), v.delayPeriod !== void 0 && v.delayPeriod !== null && (a.delayPeriod = BigInt(v.delayPeriod.toString())), a;
    }
  };
  function J() {
    return {
      clientId: "",
      connectionId: "",
      prefix: n.MerklePrefix.fromPartial({})
    };
  }
  e.Counterparty = {
    typeUrl: "/ibc.core.connection.v1.Counterparty",
    encode(v, a = r.BinaryWriter.create()) {
      return v.clientId !== "" && a.uint32(10).string(v.clientId), v.connectionId !== "" && a.uint32(18).string(v.connectionId), v.prefix !== void 0 && n.MerklePrefix.encode(v.prefix, a.uint32(26).fork()).ldelim(), a;
    },
    decode(v, a) {
      const d = v instanceof r.BinaryReader ? v : new r.BinaryReader(v);
      let y = a === void 0 ? d.len : d.pos + a;
      const _ = J();
      for (; d.pos < y; ) {
        const E = d.uint32();
        switch (E >>> 3) {
          case 1:
            _.clientId = d.string();
            break;
          case 2:
            _.connectionId = d.string();
            break;
          case 3:
            _.prefix = n.MerklePrefix.decode(d, d.uint32());
            break;
          default:
            d.skipType(E & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(v) {
      const a = J();
      return (0, t.isSet)(v.clientId) && (a.clientId = String(v.clientId)), (0, t.isSet)(v.connectionId) && (a.connectionId = String(v.connectionId)), (0, t.isSet)(v.prefix) && (a.prefix = n.MerklePrefix.fromJSON(v.prefix)), a;
    },
    toJSON(v) {
      const a = {};
      return v.clientId !== void 0 && (a.clientId = v.clientId), v.connectionId !== void 0 && (a.connectionId = v.connectionId), v.prefix !== void 0 && (a.prefix = v.prefix ? n.MerklePrefix.toJSON(v.prefix) : void 0), a;
    },
    fromPartial(v) {
      const a = J();
      return a.clientId = v.clientId ?? "", a.connectionId = v.connectionId ?? "", v.prefix !== void 0 && v.prefix !== null && (a.prefix = n.MerklePrefix.fromPartial(v.prefix)), a;
    }
  };
  function C() {
    return {
      paths: []
    };
  }
  e.ClientPaths = {
    typeUrl: "/ibc.core.connection.v1.ClientPaths",
    encode(v, a = r.BinaryWriter.create()) {
      for (const d of v.paths)
        a.uint32(10).string(d);
      return a;
    },
    decode(v, a) {
      const d = v instanceof r.BinaryReader ? v : new r.BinaryReader(v);
      let y = a === void 0 ? d.len : d.pos + a;
      const _ = C();
      for (; d.pos < y; ) {
        const E = d.uint32();
        switch (E >>> 3) {
          case 1:
            _.paths.push(d.string());
            break;
          default:
            d.skipType(E & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(v) {
      const a = C();
      return Array.isArray(v == null ? void 0 : v.paths) && (a.paths = v.paths.map((d) => String(d))), a;
    },
    toJSON(v) {
      const a = {};
      return v.paths ? a.paths = v.paths.map((d) => d) : a.paths = [], a;
    },
    fromPartial(v) {
      var d;
      const a = C();
      return a.paths = ((d = v.paths) == null ? void 0 : d.map((y) => y)) || [], a;
    }
  };
  function R() {
    return {
      clientId: "",
      paths: []
    };
  }
  e.ConnectionPaths = {
    typeUrl: "/ibc.core.connection.v1.ConnectionPaths",
    encode(v, a = r.BinaryWriter.create()) {
      v.clientId !== "" && a.uint32(10).string(v.clientId);
      for (const d of v.paths)
        a.uint32(18).string(d);
      return a;
    },
    decode(v, a) {
      const d = v instanceof r.BinaryReader ? v : new r.BinaryReader(v);
      let y = a === void 0 ? d.len : d.pos + a;
      const _ = R();
      for (; d.pos < y; ) {
        const E = d.uint32();
        switch (E >>> 3) {
          case 1:
            _.clientId = d.string();
            break;
          case 2:
            _.paths.push(d.string());
            break;
          default:
            d.skipType(E & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(v) {
      const a = R();
      return (0, t.isSet)(v.clientId) && (a.clientId = String(v.clientId)), Array.isArray(v == null ? void 0 : v.paths) && (a.paths = v.paths.map((d) => String(d))), a;
    },
    toJSON(v) {
      const a = {};
      return v.clientId !== void 0 && (a.clientId = v.clientId), v.paths ? a.paths = v.paths.map((d) => d) : a.paths = [], a;
    },
    fromPartial(v) {
      var d;
      const a = R();
      return a.clientId = v.clientId ?? "", a.paths = ((d = v.paths) == null ? void 0 : d.map((y) => y)) || [], a;
    }
  };
  function p() {
    return {
      identifier: "",
      features: []
    };
  }
  e.Version = {
    typeUrl: "/ibc.core.connection.v1.Version",
    encode(v, a = r.BinaryWriter.create()) {
      v.identifier !== "" && a.uint32(10).string(v.identifier);
      for (const d of v.features)
        a.uint32(18).string(d);
      return a;
    },
    decode(v, a) {
      const d = v instanceof r.BinaryReader ? v : new r.BinaryReader(v);
      let y = a === void 0 ? d.len : d.pos + a;
      const _ = p();
      for (; d.pos < y; ) {
        const E = d.uint32();
        switch (E >>> 3) {
          case 1:
            _.identifier = d.string();
            break;
          case 2:
            _.features.push(d.string());
            break;
          default:
            d.skipType(E & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(v) {
      const a = p();
      return (0, t.isSet)(v.identifier) && (a.identifier = String(v.identifier)), Array.isArray(v == null ? void 0 : v.features) && (a.features = v.features.map((d) => String(d))), a;
    },
    toJSON(v) {
      const a = {};
      return v.identifier !== void 0 && (a.identifier = v.identifier), v.features ? a.features = v.features.map((d) => d) : a.features = [], a;
    },
    fromPartial(v) {
      var d;
      const a = p();
      return a.identifier = v.identifier ?? "", a.features = ((d = v.features) == null ? void 0 : d.map((y) => y)) || [], a;
    }
  };
  function m() {
    return {
      maxExpectedTimePerBlock: BigInt(0)
    };
  }
  e.Params = {
    typeUrl: "/ibc.core.connection.v1.Params",
    encode(v, a = r.BinaryWriter.create()) {
      return v.maxExpectedTimePerBlock !== BigInt(0) && a.uint32(8).uint64(v.maxExpectedTimePerBlock), a;
    },
    decode(v, a) {
      const d = v instanceof r.BinaryReader ? v : new r.BinaryReader(v);
      let y = a === void 0 ? d.len : d.pos + a;
      const _ = m();
      for (; d.pos < y; ) {
        const E = d.uint32();
        switch (E >>> 3) {
          case 1:
            _.maxExpectedTimePerBlock = d.uint64();
            break;
          default:
            d.skipType(E & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(v) {
      const a = m();
      return (0, t.isSet)(v.maxExpectedTimePerBlock) && (a.maxExpectedTimePerBlock = BigInt(v.maxExpectedTimePerBlock.toString())), a;
    },
    toJSON(v) {
      const a = {};
      return v.maxExpectedTimePerBlock !== void 0 && (a.maxExpectedTimePerBlock = (v.maxExpectedTimePerBlock || BigInt(0)).toString()), a;
    },
    fromPartial(v) {
      const a = m();
      return v.maxExpectedTimePerBlock !== void 0 && v.maxExpectedTimePerBlock !== null && (a.maxExpectedTimePerBlock = BigInt(v.maxExpectedTimePerBlock.toString())), a;
    }
  };
})(xc);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgConnectionOpenConfirmResponse = e.MsgConnectionOpenConfirm = e.MsgConnectionOpenAckResponse = e.MsgConnectionOpenAck = e.MsgConnectionOpenTryResponse = e.MsgConnectionOpenTry = e.MsgConnectionOpenInitResponse = e.MsgConnectionOpenInit = e.protobufPackage = void 0;
  const n = xc, r = Pe, t = yt, i = re, f = ie;
  e.protobufPackage = "ibc.core.connection.v1";
  function S() {
    return {
      clientId: "",
      counterparty: n.Counterparty.fromPartial({}),
      version: void 0,
      delayPeriod: BigInt(0),
      signer: ""
    };
  }
  e.MsgConnectionOpenInit = {
    typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenInit",
    encode(a, d = i.BinaryWriter.create()) {
      return a.clientId !== "" && d.uint32(10).string(a.clientId), a.counterparty !== void 0 && n.Counterparty.encode(a.counterparty, d.uint32(18).fork()).ldelim(), a.version !== void 0 && n.Version.encode(a.version, d.uint32(26).fork()).ldelim(), a.delayPeriod !== BigInt(0) && d.uint32(32).uint64(a.delayPeriod), a.signer !== "" && d.uint32(42).string(a.signer), d;
    },
    decode(a, d) {
      const y = a instanceof i.BinaryReader ? a : new i.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = S();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          case 1:
            E.clientId = y.string();
            break;
          case 2:
            E.counterparty = n.Counterparty.decode(y, y.uint32());
            break;
          case 3:
            E.version = n.Version.decode(y, y.uint32());
            break;
          case 4:
            E.delayPeriod = y.uint64();
            break;
          case 5:
            E.signer = y.string();
            break;
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      const d = S();
      return (0, f.isSet)(a.clientId) && (d.clientId = String(a.clientId)), (0, f.isSet)(a.counterparty) && (d.counterparty = n.Counterparty.fromJSON(a.counterparty)), (0, f.isSet)(a.version) && (d.version = n.Version.fromJSON(a.version)), (0, f.isSet)(a.delayPeriod) && (d.delayPeriod = BigInt(a.delayPeriod.toString())), (0, f.isSet)(a.signer) && (d.signer = String(a.signer)), d;
    },
    toJSON(a) {
      const d = {};
      return a.clientId !== void 0 && (d.clientId = a.clientId), a.counterparty !== void 0 && (d.counterparty = a.counterparty ? n.Counterparty.toJSON(a.counterparty) : void 0), a.version !== void 0 && (d.version = a.version ? n.Version.toJSON(a.version) : void 0), a.delayPeriod !== void 0 && (d.delayPeriod = (a.delayPeriod || BigInt(0)).toString()), a.signer !== void 0 && (d.signer = a.signer), d;
    },
    fromPartial(a) {
      const d = S();
      return d.clientId = a.clientId ?? "", a.counterparty !== void 0 && a.counterparty !== null && (d.counterparty = n.Counterparty.fromPartial(a.counterparty)), a.version !== void 0 && a.version !== null && (d.version = n.Version.fromPartial(a.version)), a.delayPeriod !== void 0 && a.delayPeriod !== null && (d.delayPeriod = BigInt(a.delayPeriod.toString())), d.signer = a.signer ?? "", d;
    }
  };
  function w() {
    return {};
  }
  e.MsgConnectionOpenInitResponse = {
    typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenInitResponse",
    encode(a, d = i.BinaryWriter.create()) {
      return d;
    },
    decode(a, d) {
      const y = a instanceof i.BinaryReader ? a : new i.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = w();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      return w();
    },
    toJSON(a) {
      return {};
    },
    fromPartial(a) {
      return w();
    }
  };
  function T() {
    return {
      clientId: "",
      previousConnectionId: "",
      clientState: void 0,
      counterparty: n.Counterparty.fromPartial({}),
      delayPeriod: BigInt(0),
      counterpartyVersions: [],
      proofHeight: t.Height.fromPartial({}),
      proofInit: new Uint8Array(),
      proofClient: new Uint8Array(),
      proofConsensus: new Uint8Array(),
      consensusHeight: t.Height.fromPartial({}),
      signer: "",
      hostConsensusStateProof: new Uint8Array()
    };
  }
  e.MsgConnectionOpenTry = {
    typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenTry",
    encode(a, d = i.BinaryWriter.create()) {
      a.clientId !== "" && d.uint32(10).string(a.clientId), a.previousConnectionId !== "" && d.uint32(18).string(a.previousConnectionId), a.clientState !== void 0 && r.Any.encode(a.clientState, d.uint32(26).fork()).ldelim(), a.counterparty !== void 0 && n.Counterparty.encode(a.counterparty, d.uint32(34).fork()).ldelim(), a.delayPeriod !== BigInt(0) && d.uint32(40).uint64(a.delayPeriod);
      for (const y of a.counterpartyVersions)
        n.Version.encode(y, d.uint32(50).fork()).ldelim();
      return a.proofHeight !== void 0 && t.Height.encode(a.proofHeight, d.uint32(58).fork()).ldelim(), a.proofInit.length !== 0 && d.uint32(66).bytes(a.proofInit), a.proofClient.length !== 0 && d.uint32(74).bytes(a.proofClient), a.proofConsensus.length !== 0 && d.uint32(82).bytes(a.proofConsensus), a.consensusHeight !== void 0 && t.Height.encode(a.consensusHeight, d.uint32(90).fork()).ldelim(), a.signer !== "" && d.uint32(98).string(a.signer), a.hostConsensusStateProof.length !== 0 && d.uint32(106).bytes(a.hostConsensusStateProof), d;
    },
    decode(a, d) {
      const y = a instanceof i.BinaryReader ? a : new i.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = T();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          case 1:
            E.clientId = y.string();
            break;
          case 2:
            E.previousConnectionId = y.string();
            break;
          case 3:
            E.clientState = r.Any.decode(y, y.uint32());
            break;
          case 4:
            E.counterparty = n.Counterparty.decode(y, y.uint32());
            break;
          case 5:
            E.delayPeriod = y.uint64();
            break;
          case 6:
            E.counterpartyVersions.push(n.Version.decode(y, y.uint32()));
            break;
          case 7:
            E.proofHeight = t.Height.decode(y, y.uint32());
            break;
          case 8:
            E.proofInit = y.bytes();
            break;
          case 9:
            E.proofClient = y.bytes();
            break;
          case 10:
            E.proofConsensus = y.bytes();
            break;
          case 11:
            E.consensusHeight = t.Height.decode(y, y.uint32());
            break;
          case 12:
            E.signer = y.string();
            break;
          case 13:
            E.hostConsensusStateProof = y.bytes();
            break;
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      const d = T();
      return (0, f.isSet)(a.clientId) && (d.clientId = String(a.clientId)), (0, f.isSet)(a.previousConnectionId) && (d.previousConnectionId = String(a.previousConnectionId)), (0, f.isSet)(a.clientState) && (d.clientState = r.Any.fromJSON(a.clientState)), (0, f.isSet)(a.counterparty) && (d.counterparty = n.Counterparty.fromJSON(a.counterparty)), (0, f.isSet)(a.delayPeriod) && (d.delayPeriod = BigInt(a.delayPeriod.toString())), Array.isArray(a == null ? void 0 : a.counterpartyVersions) && (d.counterpartyVersions = a.counterpartyVersions.map((y) => n.Version.fromJSON(y))), (0, f.isSet)(a.proofHeight) && (d.proofHeight = t.Height.fromJSON(a.proofHeight)), (0, f.isSet)(a.proofInit) && (d.proofInit = (0, f.bytesFromBase64)(a.proofInit)), (0, f.isSet)(a.proofClient) && (d.proofClient = (0, f.bytesFromBase64)(a.proofClient)), (0, f.isSet)(a.proofConsensus) && (d.proofConsensus = (0, f.bytesFromBase64)(a.proofConsensus)), (0, f.isSet)(a.consensusHeight) && (d.consensusHeight = t.Height.fromJSON(a.consensusHeight)), (0, f.isSet)(a.signer) && (d.signer = String(a.signer)), (0, f.isSet)(a.hostConsensusStateProof) && (d.hostConsensusStateProof = (0, f.bytesFromBase64)(a.hostConsensusStateProof)), d;
    },
    toJSON(a) {
      const d = {};
      return a.clientId !== void 0 && (d.clientId = a.clientId), a.previousConnectionId !== void 0 && (d.previousConnectionId = a.previousConnectionId), a.clientState !== void 0 && (d.clientState = a.clientState ? r.Any.toJSON(a.clientState) : void 0), a.counterparty !== void 0 && (d.counterparty = a.counterparty ? n.Counterparty.toJSON(a.counterparty) : void 0), a.delayPeriod !== void 0 && (d.delayPeriod = (a.delayPeriod || BigInt(0)).toString()), a.counterpartyVersions ? d.counterpartyVersions = a.counterpartyVersions.map((y) => y ? n.Version.toJSON(y) : void 0) : d.counterpartyVersions = [], a.proofHeight !== void 0 && (d.proofHeight = a.proofHeight ? t.Height.toJSON(a.proofHeight) : void 0), a.proofInit !== void 0 && (d.proofInit = (0, f.base64FromBytes)(a.proofInit !== void 0 ? a.proofInit : new Uint8Array())), a.proofClient !== void 0 && (d.proofClient = (0, f.base64FromBytes)(a.proofClient !== void 0 ? a.proofClient : new Uint8Array())), a.proofConsensus !== void 0 && (d.proofConsensus = (0, f.base64FromBytes)(a.proofConsensus !== void 0 ? a.proofConsensus : new Uint8Array())), a.consensusHeight !== void 0 && (d.consensusHeight = a.consensusHeight ? t.Height.toJSON(a.consensusHeight) : void 0), a.signer !== void 0 && (d.signer = a.signer), a.hostConsensusStateProof !== void 0 && (d.hostConsensusStateProof = (0, f.base64FromBytes)(a.hostConsensusStateProof !== void 0 ? a.hostConsensusStateProof : new Uint8Array())), d;
    },
    fromPartial(a) {
      var y;
      const d = T();
      return d.clientId = a.clientId ?? "", d.previousConnectionId = a.previousConnectionId ?? "", a.clientState !== void 0 && a.clientState !== null && (d.clientState = r.Any.fromPartial(a.clientState)), a.counterparty !== void 0 && a.counterparty !== null && (d.counterparty = n.Counterparty.fromPartial(a.counterparty)), a.delayPeriod !== void 0 && a.delayPeriod !== null && (d.delayPeriod = BigInt(a.delayPeriod.toString())), d.counterpartyVersions = ((y = a.counterpartyVersions) == null ? void 0 : y.map((_) => n.Version.fromPartial(_))) || [], a.proofHeight !== void 0 && a.proofHeight !== null && (d.proofHeight = t.Height.fromPartial(a.proofHeight)), d.proofInit = a.proofInit ?? new Uint8Array(), d.proofClient = a.proofClient ?? new Uint8Array(), d.proofConsensus = a.proofConsensus ?? new Uint8Array(), a.consensusHeight !== void 0 && a.consensusHeight !== null && (d.consensusHeight = t.Height.fromPartial(a.consensusHeight)), d.signer = a.signer ?? "", d.hostConsensusStateProof = a.hostConsensusStateProof ?? new Uint8Array(), d;
    }
  };
  function J() {
    return {};
  }
  e.MsgConnectionOpenTryResponse = {
    typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenTryResponse",
    encode(a, d = i.BinaryWriter.create()) {
      return d;
    },
    decode(a, d) {
      const y = a instanceof i.BinaryReader ? a : new i.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = J();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      return J();
    },
    toJSON(a) {
      return {};
    },
    fromPartial(a) {
      return J();
    }
  };
  function C() {
    return {
      connectionId: "",
      counterpartyConnectionId: "",
      version: void 0,
      clientState: void 0,
      proofHeight: t.Height.fromPartial({}),
      proofTry: new Uint8Array(),
      proofClient: new Uint8Array(),
      proofConsensus: new Uint8Array(),
      consensusHeight: t.Height.fromPartial({}),
      signer: "",
      hostConsensusStateProof: new Uint8Array()
    };
  }
  e.MsgConnectionOpenAck = {
    typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenAck",
    encode(a, d = i.BinaryWriter.create()) {
      return a.connectionId !== "" && d.uint32(10).string(a.connectionId), a.counterpartyConnectionId !== "" && d.uint32(18).string(a.counterpartyConnectionId), a.version !== void 0 && n.Version.encode(a.version, d.uint32(26).fork()).ldelim(), a.clientState !== void 0 && r.Any.encode(a.clientState, d.uint32(34).fork()).ldelim(), a.proofHeight !== void 0 && t.Height.encode(a.proofHeight, d.uint32(42).fork()).ldelim(), a.proofTry.length !== 0 && d.uint32(50).bytes(a.proofTry), a.proofClient.length !== 0 && d.uint32(58).bytes(a.proofClient), a.proofConsensus.length !== 0 && d.uint32(66).bytes(a.proofConsensus), a.consensusHeight !== void 0 && t.Height.encode(a.consensusHeight, d.uint32(74).fork()).ldelim(), a.signer !== "" && d.uint32(82).string(a.signer), a.hostConsensusStateProof.length !== 0 && d.uint32(90).bytes(a.hostConsensusStateProof), d;
    },
    decode(a, d) {
      const y = a instanceof i.BinaryReader ? a : new i.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = C();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          case 1:
            E.connectionId = y.string();
            break;
          case 2:
            E.counterpartyConnectionId = y.string();
            break;
          case 3:
            E.version = n.Version.decode(y, y.uint32());
            break;
          case 4:
            E.clientState = r.Any.decode(y, y.uint32());
            break;
          case 5:
            E.proofHeight = t.Height.decode(y, y.uint32());
            break;
          case 6:
            E.proofTry = y.bytes();
            break;
          case 7:
            E.proofClient = y.bytes();
            break;
          case 8:
            E.proofConsensus = y.bytes();
            break;
          case 9:
            E.consensusHeight = t.Height.decode(y, y.uint32());
            break;
          case 10:
            E.signer = y.string();
            break;
          case 11:
            E.hostConsensusStateProof = y.bytes();
            break;
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      const d = C();
      return (0, f.isSet)(a.connectionId) && (d.connectionId = String(a.connectionId)), (0, f.isSet)(a.counterpartyConnectionId) && (d.counterpartyConnectionId = String(a.counterpartyConnectionId)), (0, f.isSet)(a.version) && (d.version = n.Version.fromJSON(a.version)), (0, f.isSet)(a.clientState) && (d.clientState = r.Any.fromJSON(a.clientState)), (0, f.isSet)(a.proofHeight) && (d.proofHeight = t.Height.fromJSON(a.proofHeight)), (0, f.isSet)(a.proofTry) && (d.proofTry = (0, f.bytesFromBase64)(a.proofTry)), (0, f.isSet)(a.proofClient) && (d.proofClient = (0, f.bytesFromBase64)(a.proofClient)), (0, f.isSet)(a.proofConsensus) && (d.proofConsensus = (0, f.bytesFromBase64)(a.proofConsensus)), (0, f.isSet)(a.consensusHeight) && (d.consensusHeight = t.Height.fromJSON(a.consensusHeight)), (0, f.isSet)(a.signer) && (d.signer = String(a.signer)), (0, f.isSet)(a.hostConsensusStateProof) && (d.hostConsensusStateProof = (0, f.bytesFromBase64)(a.hostConsensusStateProof)), d;
    },
    toJSON(a) {
      const d = {};
      return a.connectionId !== void 0 && (d.connectionId = a.connectionId), a.counterpartyConnectionId !== void 0 && (d.counterpartyConnectionId = a.counterpartyConnectionId), a.version !== void 0 && (d.version = a.version ? n.Version.toJSON(a.version) : void 0), a.clientState !== void 0 && (d.clientState = a.clientState ? r.Any.toJSON(a.clientState) : void 0), a.proofHeight !== void 0 && (d.proofHeight = a.proofHeight ? t.Height.toJSON(a.proofHeight) : void 0), a.proofTry !== void 0 && (d.proofTry = (0, f.base64FromBytes)(a.proofTry !== void 0 ? a.proofTry : new Uint8Array())), a.proofClient !== void 0 && (d.proofClient = (0, f.base64FromBytes)(a.proofClient !== void 0 ? a.proofClient : new Uint8Array())), a.proofConsensus !== void 0 && (d.proofConsensus = (0, f.base64FromBytes)(a.proofConsensus !== void 0 ? a.proofConsensus : new Uint8Array())), a.consensusHeight !== void 0 && (d.consensusHeight = a.consensusHeight ? t.Height.toJSON(a.consensusHeight) : void 0), a.signer !== void 0 && (d.signer = a.signer), a.hostConsensusStateProof !== void 0 && (d.hostConsensusStateProof = (0, f.base64FromBytes)(a.hostConsensusStateProof !== void 0 ? a.hostConsensusStateProof : new Uint8Array())), d;
    },
    fromPartial(a) {
      const d = C();
      return d.connectionId = a.connectionId ?? "", d.counterpartyConnectionId = a.counterpartyConnectionId ?? "", a.version !== void 0 && a.version !== null && (d.version = n.Version.fromPartial(a.version)), a.clientState !== void 0 && a.clientState !== null && (d.clientState = r.Any.fromPartial(a.clientState)), a.proofHeight !== void 0 && a.proofHeight !== null && (d.proofHeight = t.Height.fromPartial(a.proofHeight)), d.proofTry = a.proofTry ?? new Uint8Array(), d.proofClient = a.proofClient ?? new Uint8Array(), d.proofConsensus = a.proofConsensus ?? new Uint8Array(), a.consensusHeight !== void 0 && a.consensusHeight !== null && (d.consensusHeight = t.Height.fromPartial(a.consensusHeight)), d.signer = a.signer ?? "", d.hostConsensusStateProof = a.hostConsensusStateProof ?? new Uint8Array(), d;
    }
  };
  function R() {
    return {};
  }
  e.MsgConnectionOpenAckResponse = {
    typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenAckResponse",
    encode(a, d = i.BinaryWriter.create()) {
      return d;
    },
    decode(a, d) {
      const y = a instanceof i.BinaryReader ? a : new i.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = R();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      return R();
    },
    toJSON(a) {
      return {};
    },
    fromPartial(a) {
      return R();
    }
  };
  function p() {
    return {
      connectionId: "",
      proofAck: new Uint8Array(),
      proofHeight: t.Height.fromPartial({}),
      signer: ""
    };
  }
  e.MsgConnectionOpenConfirm = {
    typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenConfirm",
    encode(a, d = i.BinaryWriter.create()) {
      return a.connectionId !== "" && d.uint32(10).string(a.connectionId), a.proofAck.length !== 0 && d.uint32(18).bytes(a.proofAck), a.proofHeight !== void 0 && t.Height.encode(a.proofHeight, d.uint32(26).fork()).ldelim(), a.signer !== "" && d.uint32(34).string(a.signer), d;
    },
    decode(a, d) {
      const y = a instanceof i.BinaryReader ? a : new i.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = p();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          case 1:
            E.connectionId = y.string();
            break;
          case 2:
            E.proofAck = y.bytes();
            break;
          case 3:
            E.proofHeight = t.Height.decode(y, y.uint32());
            break;
          case 4:
            E.signer = y.string();
            break;
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      const d = p();
      return (0, f.isSet)(a.connectionId) && (d.connectionId = String(a.connectionId)), (0, f.isSet)(a.proofAck) && (d.proofAck = (0, f.bytesFromBase64)(a.proofAck)), (0, f.isSet)(a.proofHeight) && (d.proofHeight = t.Height.fromJSON(a.proofHeight)), (0, f.isSet)(a.signer) && (d.signer = String(a.signer)), d;
    },
    toJSON(a) {
      const d = {};
      return a.connectionId !== void 0 && (d.connectionId = a.connectionId), a.proofAck !== void 0 && (d.proofAck = (0, f.base64FromBytes)(a.proofAck !== void 0 ? a.proofAck : new Uint8Array())), a.proofHeight !== void 0 && (d.proofHeight = a.proofHeight ? t.Height.toJSON(a.proofHeight) : void 0), a.signer !== void 0 && (d.signer = a.signer), d;
    },
    fromPartial(a) {
      const d = p();
      return d.connectionId = a.connectionId ?? "", d.proofAck = a.proofAck ?? new Uint8Array(), a.proofHeight !== void 0 && a.proofHeight !== null && (d.proofHeight = t.Height.fromPartial(a.proofHeight)), d.signer = a.signer ?? "", d;
    }
  };
  function m() {
    return {};
  }
  e.MsgConnectionOpenConfirmResponse = {
    typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenConfirmResponse",
    encode(a, d = i.BinaryWriter.create()) {
      return d;
    },
    decode(a, d) {
      const y = a instanceof i.BinaryReader ? a : new i.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = m();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      return m();
    },
    toJSON(a) {
      return {};
    },
    fromPartial(a) {
      return m();
    }
  };
  class v {
    constructor(d) {
      this.rpc = d, this.ConnectionOpenInit = this.ConnectionOpenInit.bind(this), this.ConnectionOpenTry = this.ConnectionOpenTry.bind(this), this.ConnectionOpenAck = this.ConnectionOpenAck.bind(this), this.ConnectionOpenConfirm = this.ConnectionOpenConfirm.bind(this);
    }
    ConnectionOpenInit(d) {
      const y = e.MsgConnectionOpenInit.encode(d).finish();
      return this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenInit", y).then((E) => e.MsgConnectionOpenInitResponse.decode(new i.BinaryReader(E)));
    }
    ConnectionOpenTry(d) {
      const y = e.MsgConnectionOpenTry.encode(d).finish();
      return this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenTry", y).then((E) => e.MsgConnectionOpenTryResponse.decode(new i.BinaryReader(E)));
    }
    ConnectionOpenAck(d) {
      const y = e.MsgConnectionOpenAck.encode(d).finish();
      return this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenAck", y).then((E) => e.MsgConnectionOpenAckResponse.decode(new i.BinaryReader(E)));
    }
    ConnectionOpenConfirm(d) {
      const y = e.MsgConnectionOpenConfirm.encode(d).finish();
      return this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenConfirm", y).then((E) => e.MsgConnectionOpenConfirmResponse.decode(new i.BinaryReader(E)));
    }
  }
  e.MsgClientImpl = v;
})(Mh);
Object.defineProperty(ki, "__esModule", { value: !0 });
ki.isMsgTransferEncodeObject = ki.ibcTypes = void 0;
const ER = Is, xn = Jh, Yo = Dh, Xo = Mh;
ki.ibcTypes = [
  ["/ibc.applications.transfer.v1.MsgTransfer", ER.MsgTransfer],
  ["/ibc.core.channel.v1.MsgAcknowledgement", xn.MsgAcknowledgement],
  ["/ibc.core.channel.v1.MsgChannelCloseConfirm", xn.MsgChannelCloseConfirm],
  ["/ibc.core.channel.v1.MsgChannelCloseInit", xn.MsgChannelCloseInit],
  ["/ibc.core.channel.v1.MsgChannelOpenAck", xn.MsgChannelOpenAck],
  ["/ibc.core.channel.v1.MsgChannelOpenConfirm", xn.MsgChannelOpenConfirm],
  ["/ibc.core.channel.v1.MsgChannelOpenInit", xn.MsgChannelOpenInit],
  ["/ibc.core.channel.v1.MsgChannelOpenTry", xn.MsgChannelOpenTry],
  ["/ibc.core.channel.v1.MsgRecvPacket", xn.MsgRecvPacket],
  ["/ibc.core.channel.v1.MsgTimeout", xn.MsgTimeout],
  ["/ibc.core.channel.v1.MsgTimeoutOnClose", xn.MsgTimeoutOnClose],
  ["/ibc.core.client.v1.MsgCreateClient", Yo.MsgCreateClient],
  ["/ibc.core.client.v1.MsgSubmitMisbehaviour", Yo.MsgSubmitMisbehaviour],
  ["/ibc.core.client.v1.MsgUpdateClient", Yo.MsgUpdateClient],
  ["/ibc.core.client.v1.MsgUpgradeClient", Yo.MsgUpgradeClient],
  ["/ibc.core.connection.v1.MsgConnectionOpenAck", Xo.MsgConnectionOpenAck],
  ["/ibc.core.connection.v1.MsgConnectionOpenConfirm", Xo.MsgConnectionOpenConfirm],
  ["/ibc.core.connection.v1.MsgConnectionOpenInit", Xo.MsgConnectionOpenInit],
  ["/ibc.core.connection.v1.MsgConnectionOpenTry", Xo.MsgConnectionOpenTry]
];
function UR(e) {
  return e.typeUrl === "/ibc.applications.transfer.v1.MsgTransfer";
}
ki.isMsgTransferEncodeObject = UR;
var ws = {}, Hh = {}, _t = {};
Object.defineProperty(_t, "__esModule", { value: !0 });
_t.Params = _t.DenomTrace = _t.protobufPackage = void 0;
const Dr = re, Ta = ie;
_t.protobufPackage = "ibc.applications.transfer.v1";
function mu() {
  return {
    path: "",
    baseDenom: ""
  };
}
_t.DenomTrace = {
  typeUrl: "/ibc.applications.transfer.v1.DenomTrace",
  encode(e, n = Dr.BinaryWriter.create()) {
    return e.path !== "" && n.uint32(10).string(e.path), e.baseDenom !== "" && n.uint32(18).string(e.baseDenom), n;
  },
  decode(e, n) {
    const r = e instanceof Dr.BinaryReader ? e : new Dr.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = mu();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.path = r.string();
          break;
        case 2:
          i.baseDenom = r.string();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = mu();
    return (0, Ta.isSet)(e.path) && (n.path = String(e.path)), (0, Ta.isSet)(e.baseDenom) && (n.baseDenom = String(e.baseDenom)), n;
  },
  toJSON(e) {
    const n = {};
    return e.path !== void 0 && (n.path = e.path), e.baseDenom !== void 0 && (n.baseDenom = e.baseDenom), n;
  },
  fromPartial(e) {
    const n = mu();
    return n.path = e.path ?? "", n.baseDenom = e.baseDenom ?? "", n;
  }
};
function gu() {
  return {
    sendEnabled: !1,
    receiveEnabled: !1
  };
}
_t.Params = {
  typeUrl: "/ibc.applications.transfer.v1.Params",
  encode(e, n = Dr.BinaryWriter.create()) {
    return e.sendEnabled === !0 && n.uint32(8).bool(e.sendEnabled), e.receiveEnabled === !0 && n.uint32(16).bool(e.receiveEnabled), n;
  },
  decode(e, n) {
    const r = e instanceof Dr.BinaryReader ? e : new Dr.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = gu();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.sendEnabled = r.bool();
          break;
        case 2:
          i.receiveEnabled = r.bool();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = gu();
    return (0, Ta.isSet)(e.sendEnabled) && (n.sendEnabled = !!e.sendEnabled), (0, Ta.isSet)(e.receiveEnabled) && (n.receiveEnabled = !!e.receiveEnabled), n;
  },
  toJSON(e) {
    const n = {};
    return e.sendEnabled !== void 0 && (n.sendEnabled = e.sendEnabled), e.receiveEnabled !== void 0 && (n.receiveEnabled = e.receiveEnabled), n;
  },
  fromPartial(e) {
    const n = gu();
    return n.sendEnabled = e.sendEnabled ?? !1, n.receiveEnabled = e.receiveEnabled ?? !1, n;
  }
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryEscrowAddressResponse = e.QueryEscrowAddressRequest = e.QueryDenomHashResponse = e.QueryDenomHashRequest = e.QueryParamsResponse = e.QueryParamsRequest = e.QueryDenomTracesResponse = e.QueryDenomTracesRequest = e.QueryDenomTraceResponse = e.QueryDenomTraceRequest = e.protobufPackage = void 0;
  const n = Ae, r = _t, t = re, i = ie;
  e.protobufPackage = "ibc.applications.transfer.v1";
  function f() {
    return {
      hash: ""
    };
  }
  e.QueryDenomTraceRequest = {
    typeUrl: "/ibc.applications.transfer.v1.QueryDenomTraceRequest",
    encode(d, y = t.BinaryWriter.create()) {
      return d.hash !== "" && y.uint32(10).string(d.hash), y;
    },
    decode(d, y) {
      const _ = d instanceof t.BinaryReader ? d : new t.BinaryReader(d);
      let E = y === void 0 ? _.len : _.pos + y;
      const U = f();
      for (; _.pos < E; ) {
        const V = _.uint32();
        switch (V >>> 3) {
          case 1:
            U.hash = _.string();
            break;
          default:
            _.skipType(V & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(d) {
      const y = f();
      return (0, i.isSet)(d.hash) && (y.hash = String(d.hash)), y;
    },
    toJSON(d) {
      const y = {};
      return d.hash !== void 0 && (y.hash = d.hash), y;
    },
    fromPartial(d) {
      const y = f();
      return y.hash = d.hash ?? "", y;
    }
  };
  function S() {
    return {
      denomTrace: void 0
    };
  }
  e.QueryDenomTraceResponse = {
    typeUrl: "/ibc.applications.transfer.v1.QueryDenomTraceResponse",
    encode(d, y = t.BinaryWriter.create()) {
      return d.denomTrace !== void 0 && r.DenomTrace.encode(d.denomTrace, y.uint32(10).fork()).ldelim(), y;
    },
    decode(d, y) {
      const _ = d instanceof t.BinaryReader ? d : new t.BinaryReader(d);
      let E = y === void 0 ? _.len : _.pos + y;
      const U = S();
      for (; _.pos < E; ) {
        const V = _.uint32();
        switch (V >>> 3) {
          case 1:
            U.denomTrace = r.DenomTrace.decode(_, _.uint32());
            break;
          default:
            _.skipType(V & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(d) {
      const y = S();
      return (0, i.isSet)(d.denomTrace) && (y.denomTrace = r.DenomTrace.fromJSON(d.denomTrace)), y;
    },
    toJSON(d) {
      const y = {};
      return d.denomTrace !== void 0 && (y.denomTrace = d.denomTrace ? r.DenomTrace.toJSON(d.denomTrace) : void 0), y;
    },
    fromPartial(d) {
      const y = S();
      return d.denomTrace !== void 0 && d.denomTrace !== null && (y.denomTrace = r.DenomTrace.fromPartial(d.denomTrace)), y;
    }
  };
  function w() {
    return {
      pagination: void 0
    };
  }
  e.QueryDenomTracesRequest = {
    typeUrl: "/ibc.applications.transfer.v1.QueryDenomTracesRequest",
    encode(d, y = t.BinaryWriter.create()) {
      return d.pagination !== void 0 && n.PageRequest.encode(d.pagination, y.uint32(10).fork()).ldelim(), y;
    },
    decode(d, y) {
      const _ = d instanceof t.BinaryReader ? d : new t.BinaryReader(d);
      let E = y === void 0 ? _.len : _.pos + y;
      const U = w();
      for (; _.pos < E; ) {
        const V = _.uint32();
        switch (V >>> 3) {
          case 1:
            U.pagination = n.PageRequest.decode(_, _.uint32());
            break;
          default:
            _.skipType(V & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(d) {
      const y = w();
      return (0, i.isSet)(d.pagination) && (y.pagination = n.PageRequest.fromJSON(d.pagination)), y;
    },
    toJSON(d) {
      const y = {};
      return d.pagination !== void 0 && (y.pagination = d.pagination ? n.PageRequest.toJSON(d.pagination) : void 0), y;
    },
    fromPartial(d) {
      const y = w();
      return d.pagination !== void 0 && d.pagination !== null && (y.pagination = n.PageRequest.fromPartial(d.pagination)), y;
    }
  };
  function T() {
    return {
      denomTraces: [],
      pagination: void 0
    };
  }
  e.QueryDenomTracesResponse = {
    typeUrl: "/ibc.applications.transfer.v1.QueryDenomTracesResponse",
    encode(d, y = t.BinaryWriter.create()) {
      for (const _ of d.denomTraces)
        r.DenomTrace.encode(_, y.uint32(10).fork()).ldelim();
      return d.pagination !== void 0 && n.PageResponse.encode(d.pagination, y.uint32(18).fork()).ldelim(), y;
    },
    decode(d, y) {
      const _ = d instanceof t.BinaryReader ? d : new t.BinaryReader(d);
      let E = y === void 0 ? _.len : _.pos + y;
      const U = T();
      for (; _.pos < E; ) {
        const V = _.uint32();
        switch (V >>> 3) {
          case 1:
            U.denomTraces.push(r.DenomTrace.decode(_, _.uint32()));
            break;
          case 2:
            U.pagination = n.PageResponse.decode(_, _.uint32());
            break;
          default:
            _.skipType(V & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(d) {
      const y = T();
      return Array.isArray(d == null ? void 0 : d.denomTraces) && (y.denomTraces = d.denomTraces.map((_) => r.DenomTrace.fromJSON(_))), (0, i.isSet)(d.pagination) && (y.pagination = n.PageResponse.fromJSON(d.pagination)), y;
    },
    toJSON(d) {
      const y = {};
      return d.denomTraces ? y.denomTraces = d.denomTraces.map((_) => _ ? r.DenomTrace.toJSON(_) : void 0) : y.denomTraces = [], d.pagination !== void 0 && (y.pagination = d.pagination ? n.PageResponse.toJSON(d.pagination) : void 0), y;
    },
    fromPartial(d) {
      var _;
      const y = T();
      return y.denomTraces = ((_ = d.denomTraces) == null ? void 0 : _.map((E) => r.DenomTrace.fromPartial(E))) || [], d.pagination !== void 0 && d.pagination !== null && (y.pagination = n.PageResponse.fromPartial(d.pagination)), y;
    }
  };
  function J() {
    return {};
  }
  e.QueryParamsRequest = {
    typeUrl: "/ibc.applications.transfer.v1.QueryParamsRequest",
    encode(d, y = t.BinaryWriter.create()) {
      return y;
    },
    decode(d, y) {
      const _ = d instanceof t.BinaryReader ? d : new t.BinaryReader(d);
      let E = y === void 0 ? _.len : _.pos + y;
      const U = J();
      for (; _.pos < E; ) {
        const V = _.uint32();
        switch (V >>> 3) {
          default:
            _.skipType(V & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(d) {
      return J();
    },
    toJSON(d) {
      return {};
    },
    fromPartial(d) {
      return J();
    }
  };
  function C() {
    return {
      params: void 0
    };
  }
  e.QueryParamsResponse = {
    typeUrl: "/ibc.applications.transfer.v1.QueryParamsResponse",
    encode(d, y = t.BinaryWriter.create()) {
      return d.params !== void 0 && r.Params.encode(d.params, y.uint32(10).fork()).ldelim(), y;
    },
    decode(d, y) {
      const _ = d instanceof t.BinaryReader ? d : new t.BinaryReader(d);
      let E = y === void 0 ? _.len : _.pos + y;
      const U = C();
      for (; _.pos < E; ) {
        const V = _.uint32();
        switch (V >>> 3) {
          case 1:
            U.params = r.Params.decode(_, _.uint32());
            break;
          default:
            _.skipType(V & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(d) {
      const y = C();
      return (0, i.isSet)(d.params) && (y.params = r.Params.fromJSON(d.params)), y;
    },
    toJSON(d) {
      const y = {};
      return d.params !== void 0 && (y.params = d.params ? r.Params.toJSON(d.params) : void 0), y;
    },
    fromPartial(d) {
      const y = C();
      return d.params !== void 0 && d.params !== null && (y.params = r.Params.fromPartial(d.params)), y;
    }
  };
  function R() {
    return {
      trace: ""
    };
  }
  e.QueryDenomHashRequest = {
    typeUrl: "/ibc.applications.transfer.v1.QueryDenomHashRequest",
    encode(d, y = t.BinaryWriter.create()) {
      return d.trace !== "" && y.uint32(10).string(d.trace), y;
    },
    decode(d, y) {
      const _ = d instanceof t.BinaryReader ? d : new t.BinaryReader(d);
      let E = y === void 0 ? _.len : _.pos + y;
      const U = R();
      for (; _.pos < E; ) {
        const V = _.uint32();
        switch (V >>> 3) {
          case 1:
            U.trace = _.string();
            break;
          default:
            _.skipType(V & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(d) {
      const y = R();
      return (0, i.isSet)(d.trace) && (y.trace = String(d.trace)), y;
    },
    toJSON(d) {
      const y = {};
      return d.trace !== void 0 && (y.trace = d.trace), y;
    },
    fromPartial(d) {
      const y = R();
      return y.trace = d.trace ?? "", y;
    }
  };
  function p() {
    return {
      hash: ""
    };
  }
  e.QueryDenomHashResponse = {
    typeUrl: "/ibc.applications.transfer.v1.QueryDenomHashResponse",
    encode(d, y = t.BinaryWriter.create()) {
      return d.hash !== "" && y.uint32(10).string(d.hash), y;
    },
    decode(d, y) {
      const _ = d instanceof t.BinaryReader ? d : new t.BinaryReader(d);
      let E = y === void 0 ? _.len : _.pos + y;
      const U = p();
      for (; _.pos < E; ) {
        const V = _.uint32();
        switch (V >>> 3) {
          case 1:
            U.hash = _.string();
            break;
          default:
            _.skipType(V & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(d) {
      const y = p();
      return (0, i.isSet)(d.hash) && (y.hash = String(d.hash)), y;
    },
    toJSON(d) {
      const y = {};
      return d.hash !== void 0 && (y.hash = d.hash), y;
    },
    fromPartial(d) {
      const y = p();
      return y.hash = d.hash ?? "", y;
    }
  };
  function m() {
    return {
      portId: "",
      channelId: ""
    };
  }
  e.QueryEscrowAddressRequest = {
    typeUrl: "/ibc.applications.transfer.v1.QueryEscrowAddressRequest",
    encode(d, y = t.BinaryWriter.create()) {
      return d.portId !== "" && y.uint32(10).string(d.portId), d.channelId !== "" && y.uint32(18).string(d.channelId), y;
    },
    decode(d, y) {
      const _ = d instanceof t.BinaryReader ? d : new t.BinaryReader(d);
      let E = y === void 0 ? _.len : _.pos + y;
      const U = m();
      for (; _.pos < E; ) {
        const V = _.uint32();
        switch (V >>> 3) {
          case 1:
            U.portId = _.string();
            break;
          case 2:
            U.channelId = _.string();
            break;
          default:
            _.skipType(V & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(d) {
      const y = m();
      return (0, i.isSet)(d.portId) && (y.portId = String(d.portId)), (0, i.isSet)(d.channelId) && (y.channelId = String(d.channelId)), y;
    },
    toJSON(d) {
      const y = {};
      return d.portId !== void 0 && (y.portId = d.portId), d.channelId !== void 0 && (y.channelId = d.channelId), y;
    },
    fromPartial(d) {
      const y = m();
      return y.portId = d.portId ?? "", y.channelId = d.channelId ?? "", y;
    }
  };
  function v() {
    return {
      escrowAddress: ""
    };
  }
  e.QueryEscrowAddressResponse = {
    typeUrl: "/ibc.applications.transfer.v1.QueryEscrowAddressResponse",
    encode(d, y = t.BinaryWriter.create()) {
      return d.escrowAddress !== "" && y.uint32(10).string(d.escrowAddress), y;
    },
    decode(d, y) {
      const _ = d instanceof t.BinaryReader ? d : new t.BinaryReader(d);
      let E = y === void 0 ? _.len : _.pos + y;
      const U = v();
      for (; _.pos < E; ) {
        const V = _.uint32();
        switch (V >>> 3) {
          case 1:
            U.escrowAddress = _.string();
            break;
          default:
            _.skipType(V & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(d) {
      const y = v();
      return (0, i.isSet)(d.escrowAddress) && (y.escrowAddress = String(d.escrowAddress)), y;
    },
    toJSON(d) {
      const y = {};
      return d.escrowAddress !== void 0 && (y.escrowAddress = d.escrowAddress), y;
    },
    fromPartial(d) {
      const y = v();
      return y.escrowAddress = d.escrowAddress ?? "", y;
    }
  };
  class a {
    constructor(y) {
      this.rpc = y, this.DenomTrace = this.DenomTrace.bind(this), this.DenomTraces = this.DenomTraces.bind(this), this.Params = this.Params.bind(this), this.DenomHash = this.DenomHash.bind(this), this.EscrowAddress = this.EscrowAddress.bind(this);
    }
    DenomTrace(y) {
      const _ = e.QueryDenomTraceRequest.encode(y).finish();
      return this.rpc.request("ibc.applications.transfer.v1.Query", "DenomTrace", _).then((U) => e.QueryDenomTraceResponse.decode(new t.BinaryReader(U)));
    }
    DenomTraces(y = {
      pagination: n.PageRequest.fromPartial({})
    }) {
      const _ = e.QueryDenomTracesRequest.encode(y).finish();
      return this.rpc.request("ibc.applications.transfer.v1.Query", "DenomTraces", _).then((U) => e.QueryDenomTracesResponse.decode(new t.BinaryReader(U)));
    }
    Params(y = {}) {
      const _ = e.QueryParamsRequest.encode(y).finish();
      return this.rpc.request("ibc.applications.transfer.v1.Query", "Params", _).then((U) => e.QueryParamsResponse.decode(new t.BinaryReader(U)));
    }
    DenomHash(y) {
      const _ = e.QueryDenomHashRequest.encode(y).finish();
      return this.rpc.request("ibc.applications.transfer.v1.Query", "DenomHash", _).then((U) => e.QueryDenomHashResponse.decode(new t.BinaryReader(U)));
    }
    EscrowAddress(y) {
      const _ = e.QueryEscrowAddressRequest.encode(y).finish();
      return this.rpc.request("ibc.applications.transfer.v1.Query", "EscrowAddress", _).then((U) => e.QueryEscrowAddressResponse.decode(new t.BinaryReader(U)));
    }
  }
  e.QueryClientImpl = a;
})(Hh);
var qh = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryNextSequenceReceiveResponse = e.QueryNextSequenceReceiveRequest = e.QueryUnreceivedAcksResponse = e.QueryUnreceivedAcksRequest = e.QueryUnreceivedPacketsResponse = e.QueryUnreceivedPacketsRequest = e.QueryPacketAcknowledgementsResponse = e.QueryPacketAcknowledgementsRequest = e.QueryPacketAcknowledgementResponse = e.QueryPacketAcknowledgementRequest = e.QueryPacketReceiptResponse = e.QueryPacketReceiptRequest = e.QueryPacketCommitmentsResponse = e.QueryPacketCommitmentsRequest = e.QueryPacketCommitmentResponse = e.QueryPacketCommitmentRequest = e.QueryChannelConsensusStateResponse = e.QueryChannelConsensusStateRequest = e.QueryChannelClientStateResponse = e.QueryChannelClientStateRequest = e.QueryConnectionChannelsResponse = e.QueryConnectionChannelsRequest = e.QueryChannelsResponse = e.QueryChannelsRequest = e.QueryChannelResponse = e.QueryChannelRequest = e.protobufPackage = void 0;
  const n = Ae, r = Ts, t = yt, i = Pe, f = re, S = ie;
  e.protobufPackage = "ibc.core.channel.v1";
  function w() {
    return {
      portId: "",
      channelId: ""
    };
  }
  e.QueryChannelRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryChannelRequest",
    encode(s, k = f.BinaryWriter.create()) {
      return s.portId !== "" && k.uint32(10).string(s.portId), s.channelId !== "" && k.uint32(18).string(s.channelId), k;
    },
    decode(s, k) {
      const g = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = w();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.portId = g.string();
            break;
          case 2:
            A.channelId = g.string();
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = w();
      return (0, S.isSet)(s.portId) && (k.portId = String(s.portId)), (0, S.isSet)(s.channelId) && (k.channelId = String(s.channelId)), k;
    },
    toJSON(s) {
      const k = {};
      return s.portId !== void 0 && (k.portId = s.portId), s.channelId !== void 0 && (k.channelId = s.channelId), k;
    },
    fromPartial(s) {
      const k = w();
      return k.portId = s.portId ?? "", k.channelId = s.channelId ?? "", k;
    }
  };
  function T() {
    return {
      channel: void 0,
      proof: new Uint8Array(),
      proofHeight: t.Height.fromPartial({})
    };
  }
  e.QueryChannelResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryChannelResponse",
    encode(s, k = f.BinaryWriter.create()) {
      return s.channel !== void 0 && r.Channel.encode(s.channel, k.uint32(10).fork()).ldelim(), s.proof.length !== 0 && k.uint32(18).bytes(s.proof), s.proofHeight !== void 0 && t.Height.encode(s.proofHeight, k.uint32(26).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = T();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.channel = r.Channel.decode(g, g.uint32());
            break;
          case 2:
            A.proof = g.bytes();
            break;
          case 3:
            A.proofHeight = t.Height.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = T();
      return (0, S.isSet)(s.channel) && (k.channel = r.Channel.fromJSON(s.channel)), (0, S.isSet)(s.proof) && (k.proof = (0, S.bytesFromBase64)(s.proof)), (0, S.isSet)(s.proofHeight) && (k.proofHeight = t.Height.fromJSON(s.proofHeight)), k;
    },
    toJSON(s) {
      const k = {};
      return s.channel !== void 0 && (k.channel = s.channel ? r.Channel.toJSON(s.channel) : void 0), s.proof !== void 0 && (k.proof = (0, S.base64FromBytes)(s.proof !== void 0 ? s.proof : new Uint8Array())), s.proofHeight !== void 0 && (k.proofHeight = s.proofHeight ? t.Height.toJSON(s.proofHeight) : void 0), k;
    },
    fromPartial(s) {
      const k = T();
      return s.channel !== void 0 && s.channel !== null && (k.channel = r.Channel.fromPartial(s.channel)), k.proof = s.proof ?? new Uint8Array(), s.proofHeight !== void 0 && s.proofHeight !== null && (k.proofHeight = t.Height.fromPartial(s.proofHeight)), k;
    }
  };
  function J() {
    return {
      pagination: void 0
    };
  }
  e.QueryChannelsRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryChannelsRequest",
    encode(s, k = f.BinaryWriter.create()) {
      return s.pagination !== void 0 && n.PageRequest.encode(s.pagination, k.uint32(10).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = J();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.pagination = n.PageRequest.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = J();
      return (0, S.isSet)(s.pagination) && (k.pagination = n.PageRequest.fromJSON(s.pagination)), k;
    },
    toJSON(s) {
      const k = {};
      return s.pagination !== void 0 && (k.pagination = s.pagination ? n.PageRequest.toJSON(s.pagination) : void 0), k;
    },
    fromPartial(s) {
      const k = J();
      return s.pagination !== void 0 && s.pagination !== null && (k.pagination = n.PageRequest.fromPartial(s.pagination)), k;
    }
  };
  function C() {
    return {
      channels: [],
      pagination: void 0,
      height: t.Height.fromPartial({})
    };
  }
  e.QueryChannelsResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryChannelsResponse",
    encode(s, k = f.BinaryWriter.create()) {
      for (const g of s.channels)
        r.IdentifiedChannel.encode(g, k.uint32(10).fork()).ldelim();
      return s.pagination !== void 0 && n.PageResponse.encode(s.pagination, k.uint32(18).fork()).ldelim(), s.height !== void 0 && t.Height.encode(s.height, k.uint32(26).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = C();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.channels.push(r.IdentifiedChannel.decode(g, g.uint32()));
            break;
          case 2:
            A.pagination = n.PageResponse.decode(g, g.uint32());
            break;
          case 3:
            A.height = t.Height.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = C();
      return Array.isArray(s == null ? void 0 : s.channels) && (k.channels = s.channels.map((g) => r.IdentifiedChannel.fromJSON(g))), (0, S.isSet)(s.pagination) && (k.pagination = n.PageResponse.fromJSON(s.pagination)), (0, S.isSet)(s.height) && (k.height = t.Height.fromJSON(s.height)), k;
    },
    toJSON(s) {
      const k = {};
      return s.channels ? k.channels = s.channels.map((g) => g ? r.IdentifiedChannel.toJSON(g) : void 0) : k.channels = [], s.pagination !== void 0 && (k.pagination = s.pagination ? n.PageResponse.toJSON(s.pagination) : void 0), s.height !== void 0 && (k.height = s.height ? t.Height.toJSON(s.height) : void 0), k;
    },
    fromPartial(s) {
      var g;
      const k = C();
      return k.channels = ((g = s.channels) == null ? void 0 : g.map((P) => r.IdentifiedChannel.fromPartial(P))) || [], s.pagination !== void 0 && s.pagination !== null && (k.pagination = n.PageResponse.fromPartial(s.pagination)), s.height !== void 0 && s.height !== null && (k.height = t.Height.fromPartial(s.height)), k;
    }
  };
  function R() {
    return {
      connection: "",
      pagination: void 0
    };
  }
  e.QueryConnectionChannelsRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryConnectionChannelsRequest",
    encode(s, k = f.BinaryWriter.create()) {
      return s.connection !== "" && k.uint32(10).string(s.connection), s.pagination !== void 0 && n.PageRequest.encode(s.pagination, k.uint32(18).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = R();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.connection = g.string();
            break;
          case 2:
            A.pagination = n.PageRequest.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = R();
      return (0, S.isSet)(s.connection) && (k.connection = String(s.connection)), (0, S.isSet)(s.pagination) && (k.pagination = n.PageRequest.fromJSON(s.pagination)), k;
    },
    toJSON(s) {
      const k = {};
      return s.connection !== void 0 && (k.connection = s.connection), s.pagination !== void 0 && (k.pagination = s.pagination ? n.PageRequest.toJSON(s.pagination) : void 0), k;
    },
    fromPartial(s) {
      const k = R();
      return k.connection = s.connection ?? "", s.pagination !== void 0 && s.pagination !== null && (k.pagination = n.PageRequest.fromPartial(s.pagination)), k;
    }
  };
  function p() {
    return {
      channels: [],
      pagination: void 0,
      height: t.Height.fromPartial({})
    };
  }
  e.QueryConnectionChannelsResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryConnectionChannelsResponse",
    encode(s, k = f.BinaryWriter.create()) {
      for (const g of s.channels)
        r.IdentifiedChannel.encode(g, k.uint32(10).fork()).ldelim();
      return s.pagination !== void 0 && n.PageResponse.encode(s.pagination, k.uint32(18).fork()).ldelim(), s.height !== void 0 && t.Height.encode(s.height, k.uint32(26).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = p();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.channels.push(r.IdentifiedChannel.decode(g, g.uint32()));
            break;
          case 2:
            A.pagination = n.PageResponse.decode(g, g.uint32());
            break;
          case 3:
            A.height = t.Height.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = p();
      return Array.isArray(s == null ? void 0 : s.channels) && (k.channels = s.channels.map((g) => r.IdentifiedChannel.fromJSON(g))), (0, S.isSet)(s.pagination) && (k.pagination = n.PageResponse.fromJSON(s.pagination)), (0, S.isSet)(s.height) && (k.height = t.Height.fromJSON(s.height)), k;
    },
    toJSON(s) {
      const k = {};
      return s.channels ? k.channels = s.channels.map((g) => g ? r.IdentifiedChannel.toJSON(g) : void 0) : k.channels = [], s.pagination !== void 0 && (k.pagination = s.pagination ? n.PageResponse.toJSON(s.pagination) : void 0), s.height !== void 0 && (k.height = s.height ? t.Height.toJSON(s.height) : void 0), k;
    },
    fromPartial(s) {
      var g;
      const k = p();
      return k.channels = ((g = s.channels) == null ? void 0 : g.map((P) => r.IdentifiedChannel.fromPartial(P))) || [], s.pagination !== void 0 && s.pagination !== null && (k.pagination = n.PageResponse.fromPartial(s.pagination)), s.height !== void 0 && s.height !== null && (k.height = t.Height.fromPartial(s.height)), k;
    }
  };
  function m() {
    return {
      portId: "",
      channelId: ""
    };
  }
  e.QueryChannelClientStateRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryChannelClientStateRequest",
    encode(s, k = f.BinaryWriter.create()) {
      return s.portId !== "" && k.uint32(10).string(s.portId), s.channelId !== "" && k.uint32(18).string(s.channelId), k;
    },
    decode(s, k) {
      const g = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = m();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.portId = g.string();
            break;
          case 2:
            A.channelId = g.string();
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = m();
      return (0, S.isSet)(s.portId) && (k.portId = String(s.portId)), (0, S.isSet)(s.channelId) && (k.channelId = String(s.channelId)), k;
    },
    toJSON(s) {
      const k = {};
      return s.portId !== void 0 && (k.portId = s.portId), s.channelId !== void 0 && (k.channelId = s.channelId), k;
    },
    fromPartial(s) {
      const k = m();
      return k.portId = s.portId ?? "", k.channelId = s.channelId ?? "", k;
    }
  };
  function v() {
    return {
      identifiedClientState: void 0,
      proof: new Uint8Array(),
      proofHeight: t.Height.fromPartial({})
    };
  }
  e.QueryChannelClientStateResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryChannelClientStateResponse",
    encode(s, k = f.BinaryWriter.create()) {
      return s.identifiedClientState !== void 0 && t.IdentifiedClientState.encode(s.identifiedClientState, k.uint32(10).fork()).ldelim(), s.proof.length !== 0 && k.uint32(18).bytes(s.proof), s.proofHeight !== void 0 && t.Height.encode(s.proofHeight, k.uint32(26).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = v();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.identifiedClientState = t.IdentifiedClientState.decode(g, g.uint32());
            break;
          case 2:
            A.proof = g.bytes();
            break;
          case 3:
            A.proofHeight = t.Height.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = v();
      return (0, S.isSet)(s.identifiedClientState) && (k.identifiedClientState = t.IdentifiedClientState.fromJSON(s.identifiedClientState)), (0, S.isSet)(s.proof) && (k.proof = (0, S.bytesFromBase64)(s.proof)), (0, S.isSet)(s.proofHeight) && (k.proofHeight = t.Height.fromJSON(s.proofHeight)), k;
    },
    toJSON(s) {
      const k = {};
      return s.identifiedClientState !== void 0 && (k.identifiedClientState = s.identifiedClientState ? t.IdentifiedClientState.toJSON(s.identifiedClientState) : void 0), s.proof !== void 0 && (k.proof = (0, S.base64FromBytes)(s.proof !== void 0 ? s.proof : new Uint8Array())), s.proofHeight !== void 0 && (k.proofHeight = s.proofHeight ? t.Height.toJSON(s.proofHeight) : void 0), k;
    },
    fromPartial(s) {
      const k = v();
      return s.identifiedClientState !== void 0 && s.identifiedClientState !== null && (k.identifiedClientState = t.IdentifiedClientState.fromPartial(s.identifiedClientState)), k.proof = s.proof ?? new Uint8Array(), s.proofHeight !== void 0 && s.proofHeight !== null && (k.proofHeight = t.Height.fromPartial(s.proofHeight)), k;
    }
  };
  function a() {
    return {
      portId: "",
      channelId: "",
      revisionNumber: BigInt(0),
      revisionHeight: BigInt(0)
    };
  }
  e.QueryChannelConsensusStateRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryChannelConsensusStateRequest",
    encode(s, k = f.BinaryWriter.create()) {
      return s.portId !== "" && k.uint32(10).string(s.portId), s.channelId !== "" && k.uint32(18).string(s.channelId), s.revisionNumber !== BigInt(0) && k.uint32(24).uint64(s.revisionNumber), s.revisionHeight !== BigInt(0) && k.uint32(32).uint64(s.revisionHeight), k;
    },
    decode(s, k) {
      const g = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = a();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.portId = g.string();
            break;
          case 2:
            A.channelId = g.string();
            break;
          case 3:
            A.revisionNumber = g.uint64();
            break;
          case 4:
            A.revisionHeight = g.uint64();
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = a();
      return (0, S.isSet)(s.portId) && (k.portId = String(s.portId)), (0, S.isSet)(s.channelId) && (k.channelId = String(s.channelId)), (0, S.isSet)(s.revisionNumber) && (k.revisionNumber = BigInt(s.revisionNumber.toString())), (0, S.isSet)(s.revisionHeight) && (k.revisionHeight = BigInt(s.revisionHeight.toString())), k;
    },
    toJSON(s) {
      const k = {};
      return s.portId !== void 0 && (k.portId = s.portId), s.channelId !== void 0 && (k.channelId = s.channelId), s.revisionNumber !== void 0 && (k.revisionNumber = (s.revisionNumber || BigInt(0)).toString()), s.revisionHeight !== void 0 && (k.revisionHeight = (s.revisionHeight || BigInt(0)).toString()), k;
    },
    fromPartial(s) {
      const k = a();
      return k.portId = s.portId ?? "", k.channelId = s.channelId ?? "", s.revisionNumber !== void 0 && s.revisionNumber !== null && (k.revisionNumber = BigInt(s.revisionNumber.toString())), s.revisionHeight !== void 0 && s.revisionHeight !== null && (k.revisionHeight = BigInt(s.revisionHeight.toString())), k;
    }
  };
  function d() {
    return {
      consensusState: void 0,
      clientId: "",
      proof: new Uint8Array(),
      proofHeight: t.Height.fromPartial({})
    };
  }
  e.QueryChannelConsensusStateResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryChannelConsensusStateResponse",
    encode(s, k = f.BinaryWriter.create()) {
      return s.consensusState !== void 0 && i.Any.encode(s.consensusState, k.uint32(10).fork()).ldelim(), s.clientId !== "" && k.uint32(18).string(s.clientId), s.proof.length !== 0 && k.uint32(26).bytes(s.proof), s.proofHeight !== void 0 && t.Height.encode(s.proofHeight, k.uint32(34).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = d();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.consensusState = i.Any.decode(g, g.uint32());
            break;
          case 2:
            A.clientId = g.string();
            break;
          case 3:
            A.proof = g.bytes();
            break;
          case 4:
            A.proofHeight = t.Height.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = d();
      return (0, S.isSet)(s.consensusState) && (k.consensusState = i.Any.fromJSON(s.consensusState)), (0, S.isSet)(s.clientId) && (k.clientId = String(s.clientId)), (0, S.isSet)(s.proof) && (k.proof = (0, S.bytesFromBase64)(s.proof)), (0, S.isSet)(s.proofHeight) && (k.proofHeight = t.Height.fromJSON(s.proofHeight)), k;
    },
    toJSON(s) {
      const k = {};
      return s.consensusState !== void 0 && (k.consensusState = s.consensusState ? i.Any.toJSON(s.consensusState) : void 0), s.clientId !== void 0 && (k.clientId = s.clientId), s.proof !== void 0 && (k.proof = (0, S.base64FromBytes)(s.proof !== void 0 ? s.proof : new Uint8Array())), s.proofHeight !== void 0 && (k.proofHeight = s.proofHeight ? t.Height.toJSON(s.proofHeight) : void 0), k;
    },
    fromPartial(s) {
      const k = d();
      return s.consensusState !== void 0 && s.consensusState !== null && (k.consensusState = i.Any.fromPartial(s.consensusState)), k.clientId = s.clientId ?? "", k.proof = s.proof ?? new Uint8Array(), s.proofHeight !== void 0 && s.proofHeight !== null && (k.proofHeight = t.Height.fromPartial(s.proofHeight)), k;
    }
  };
  function y() {
    return {
      portId: "",
      channelId: "",
      sequence: BigInt(0)
    };
  }
  e.QueryPacketCommitmentRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentRequest",
    encode(s, k = f.BinaryWriter.create()) {
      return s.portId !== "" && k.uint32(10).string(s.portId), s.channelId !== "" && k.uint32(18).string(s.channelId), s.sequence !== BigInt(0) && k.uint32(24).uint64(s.sequence), k;
    },
    decode(s, k) {
      const g = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = y();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.portId = g.string();
            break;
          case 2:
            A.channelId = g.string();
            break;
          case 3:
            A.sequence = g.uint64();
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = y();
      return (0, S.isSet)(s.portId) && (k.portId = String(s.portId)), (0, S.isSet)(s.channelId) && (k.channelId = String(s.channelId)), (0, S.isSet)(s.sequence) && (k.sequence = BigInt(s.sequence.toString())), k;
    },
    toJSON(s) {
      const k = {};
      return s.portId !== void 0 && (k.portId = s.portId), s.channelId !== void 0 && (k.channelId = s.channelId), s.sequence !== void 0 && (k.sequence = (s.sequence || BigInt(0)).toString()), k;
    },
    fromPartial(s) {
      const k = y();
      return k.portId = s.portId ?? "", k.channelId = s.channelId ?? "", s.sequence !== void 0 && s.sequence !== null && (k.sequence = BigInt(s.sequence.toString())), k;
    }
  };
  function _() {
    return {
      commitment: new Uint8Array(),
      proof: new Uint8Array(),
      proofHeight: t.Height.fromPartial({})
    };
  }
  e.QueryPacketCommitmentResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentResponse",
    encode(s, k = f.BinaryWriter.create()) {
      return s.commitment.length !== 0 && k.uint32(10).bytes(s.commitment), s.proof.length !== 0 && k.uint32(18).bytes(s.proof), s.proofHeight !== void 0 && t.Height.encode(s.proofHeight, k.uint32(26).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = _();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.commitment = g.bytes();
            break;
          case 2:
            A.proof = g.bytes();
            break;
          case 3:
            A.proofHeight = t.Height.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = _();
      return (0, S.isSet)(s.commitment) && (k.commitment = (0, S.bytesFromBase64)(s.commitment)), (0, S.isSet)(s.proof) && (k.proof = (0, S.bytesFromBase64)(s.proof)), (0, S.isSet)(s.proofHeight) && (k.proofHeight = t.Height.fromJSON(s.proofHeight)), k;
    },
    toJSON(s) {
      const k = {};
      return s.commitment !== void 0 && (k.commitment = (0, S.base64FromBytes)(s.commitment !== void 0 ? s.commitment : new Uint8Array())), s.proof !== void 0 && (k.proof = (0, S.base64FromBytes)(s.proof !== void 0 ? s.proof : new Uint8Array())), s.proofHeight !== void 0 && (k.proofHeight = s.proofHeight ? t.Height.toJSON(s.proofHeight) : void 0), k;
    },
    fromPartial(s) {
      const k = _();
      return k.commitment = s.commitment ?? new Uint8Array(), k.proof = s.proof ?? new Uint8Array(), s.proofHeight !== void 0 && s.proofHeight !== null && (k.proofHeight = t.Height.fromPartial(s.proofHeight)), k;
    }
  };
  function E() {
    return {
      portId: "",
      channelId: "",
      pagination: void 0
    };
  }
  e.QueryPacketCommitmentsRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentsRequest",
    encode(s, k = f.BinaryWriter.create()) {
      return s.portId !== "" && k.uint32(10).string(s.portId), s.channelId !== "" && k.uint32(18).string(s.channelId), s.pagination !== void 0 && n.PageRequest.encode(s.pagination, k.uint32(26).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = E();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.portId = g.string();
            break;
          case 2:
            A.channelId = g.string();
            break;
          case 3:
            A.pagination = n.PageRequest.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = E();
      return (0, S.isSet)(s.portId) && (k.portId = String(s.portId)), (0, S.isSet)(s.channelId) && (k.channelId = String(s.channelId)), (0, S.isSet)(s.pagination) && (k.pagination = n.PageRequest.fromJSON(s.pagination)), k;
    },
    toJSON(s) {
      const k = {};
      return s.portId !== void 0 && (k.portId = s.portId), s.channelId !== void 0 && (k.channelId = s.channelId), s.pagination !== void 0 && (k.pagination = s.pagination ? n.PageRequest.toJSON(s.pagination) : void 0), k;
    },
    fromPartial(s) {
      const k = E();
      return k.portId = s.portId ?? "", k.channelId = s.channelId ?? "", s.pagination !== void 0 && s.pagination !== null && (k.pagination = n.PageRequest.fromPartial(s.pagination)), k;
    }
  };
  function U() {
    return {
      commitments: [],
      pagination: void 0,
      height: t.Height.fromPartial({})
    };
  }
  e.QueryPacketCommitmentsResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentsResponse",
    encode(s, k = f.BinaryWriter.create()) {
      for (const g of s.commitments)
        r.PacketState.encode(g, k.uint32(10).fork()).ldelim();
      return s.pagination !== void 0 && n.PageResponse.encode(s.pagination, k.uint32(18).fork()).ldelim(), s.height !== void 0 && t.Height.encode(s.height, k.uint32(26).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = U();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.commitments.push(r.PacketState.decode(g, g.uint32()));
            break;
          case 2:
            A.pagination = n.PageResponse.decode(g, g.uint32());
            break;
          case 3:
            A.height = t.Height.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = U();
      return Array.isArray(s == null ? void 0 : s.commitments) && (k.commitments = s.commitments.map((g) => r.PacketState.fromJSON(g))), (0, S.isSet)(s.pagination) && (k.pagination = n.PageResponse.fromJSON(s.pagination)), (0, S.isSet)(s.height) && (k.height = t.Height.fromJSON(s.height)), k;
    },
    toJSON(s) {
      const k = {};
      return s.commitments ? k.commitments = s.commitments.map((g) => g ? r.PacketState.toJSON(g) : void 0) : k.commitments = [], s.pagination !== void 0 && (k.pagination = s.pagination ? n.PageResponse.toJSON(s.pagination) : void 0), s.height !== void 0 && (k.height = s.height ? t.Height.toJSON(s.height) : void 0), k;
    },
    fromPartial(s) {
      var g;
      const k = U();
      return k.commitments = ((g = s.commitments) == null ? void 0 : g.map((P) => r.PacketState.fromPartial(P))) || [], s.pagination !== void 0 && s.pagination !== null && (k.pagination = n.PageResponse.fromPartial(s.pagination)), s.height !== void 0 && s.height !== null && (k.height = t.Height.fromPartial(s.height)), k;
    }
  };
  function V() {
    return {
      portId: "",
      channelId: "",
      sequence: BigInt(0)
    };
  }
  e.QueryPacketReceiptRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketReceiptRequest",
    encode(s, k = f.BinaryWriter.create()) {
      return s.portId !== "" && k.uint32(10).string(s.portId), s.channelId !== "" && k.uint32(18).string(s.channelId), s.sequence !== BigInt(0) && k.uint32(24).uint64(s.sequence), k;
    },
    decode(s, k) {
      const g = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = V();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.portId = g.string();
            break;
          case 2:
            A.channelId = g.string();
            break;
          case 3:
            A.sequence = g.uint64();
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = V();
      return (0, S.isSet)(s.portId) && (k.portId = String(s.portId)), (0, S.isSet)(s.channelId) && (k.channelId = String(s.channelId)), (0, S.isSet)(s.sequence) && (k.sequence = BigInt(s.sequence.toString())), k;
    },
    toJSON(s) {
      const k = {};
      return s.portId !== void 0 && (k.portId = s.portId), s.channelId !== void 0 && (k.channelId = s.channelId), s.sequence !== void 0 && (k.sequence = (s.sequence || BigInt(0)).toString()), k;
    },
    fromPartial(s) {
      const k = V();
      return k.portId = s.portId ?? "", k.channelId = s.channelId ?? "", s.sequence !== void 0 && s.sequence !== null && (k.sequence = BigInt(s.sequence.toString())), k;
    }
  };
  function o() {
    return {
      received: !1,
      proof: new Uint8Array(),
      proofHeight: t.Height.fromPartial({})
    };
  }
  e.QueryPacketReceiptResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketReceiptResponse",
    encode(s, k = f.BinaryWriter.create()) {
      return s.received === !0 && k.uint32(16).bool(s.received), s.proof.length !== 0 && k.uint32(26).bytes(s.proof), s.proofHeight !== void 0 && t.Height.encode(s.proofHeight, k.uint32(34).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = o();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 2:
            A.received = g.bool();
            break;
          case 3:
            A.proof = g.bytes();
            break;
          case 4:
            A.proofHeight = t.Height.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = o();
      return (0, S.isSet)(s.received) && (k.received = !!s.received), (0, S.isSet)(s.proof) && (k.proof = (0, S.bytesFromBase64)(s.proof)), (0, S.isSet)(s.proofHeight) && (k.proofHeight = t.Height.fromJSON(s.proofHeight)), k;
    },
    toJSON(s) {
      const k = {};
      return s.received !== void 0 && (k.received = s.received), s.proof !== void 0 && (k.proof = (0, S.base64FromBytes)(s.proof !== void 0 ? s.proof : new Uint8Array())), s.proofHeight !== void 0 && (k.proofHeight = s.proofHeight ? t.Height.toJSON(s.proofHeight) : void 0), k;
    },
    fromPartial(s) {
      const k = o();
      return k.received = s.received ?? !1, k.proof = s.proof ?? new Uint8Array(), s.proofHeight !== void 0 && s.proofHeight !== null && (k.proofHeight = t.Height.fromPartial(s.proofHeight)), k;
    }
  };
  function h() {
    return {
      portId: "",
      channelId: "",
      sequence: BigInt(0)
    };
  }
  e.QueryPacketAcknowledgementRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementRequest",
    encode(s, k = f.BinaryWriter.create()) {
      return s.portId !== "" && k.uint32(10).string(s.portId), s.channelId !== "" && k.uint32(18).string(s.channelId), s.sequence !== BigInt(0) && k.uint32(24).uint64(s.sequence), k;
    },
    decode(s, k) {
      const g = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = h();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.portId = g.string();
            break;
          case 2:
            A.channelId = g.string();
            break;
          case 3:
            A.sequence = g.uint64();
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = h();
      return (0, S.isSet)(s.portId) && (k.portId = String(s.portId)), (0, S.isSet)(s.channelId) && (k.channelId = String(s.channelId)), (0, S.isSet)(s.sequence) && (k.sequence = BigInt(s.sequence.toString())), k;
    },
    toJSON(s) {
      const k = {};
      return s.portId !== void 0 && (k.portId = s.portId), s.channelId !== void 0 && (k.channelId = s.channelId), s.sequence !== void 0 && (k.sequence = (s.sequence || BigInt(0)).toString()), k;
    },
    fromPartial(s) {
      const k = h();
      return k.portId = s.portId ?? "", k.channelId = s.channelId ?? "", s.sequence !== void 0 && s.sequence !== null && (k.sequence = BigInt(s.sequence.toString())), k;
    }
  };
  function N() {
    return {
      acknowledgement: new Uint8Array(),
      proof: new Uint8Array(),
      proofHeight: t.Height.fromPartial({})
    };
  }
  e.QueryPacketAcknowledgementResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementResponse",
    encode(s, k = f.BinaryWriter.create()) {
      return s.acknowledgement.length !== 0 && k.uint32(10).bytes(s.acknowledgement), s.proof.length !== 0 && k.uint32(18).bytes(s.proof), s.proofHeight !== void 0 && t.Height.encode(s.proofHeight, k.uint32(26).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = N();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.acknowledgement = g.bytes();
            break;
          case 2:
            A.proof = g.bytes();
            break;
          case 3:
            A.proofHeight = t.Height.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = N();
      return (0, S.isSet)(s.acknowledgement) && (k.acknowledgement = (0, S.bytesFromBase64)(s.acknowledgement)), (0, S.isSet)(s.proof) && (k.proof = (0, S.bytesFromBase64)(s.proof)), (0, S.isSet)(s.proofHeight) && (k.proofHeight = t.Height.fromJSON(s.proofHeight)), k;
    },
    toJSON(s) {
      const k = {};
      return s.acknowledgement !== void 0 && (k.acknowledgement = (0, S.base64FromBytes)(s.acknowledgement !== void 0 ? s.acknowledgement : new Uint8Array())), s.proof !== void 0 && (k.proof = (0, S.base64FromBytes)(s.proof !== void 0 ? s.proof : new Uint8Array())), s.proofHeight !== void 0 && (k.proofHeight = s.proofHeight ? t.Height.toJSON(s.proofHeight) : void 0), k;
    },
    fromPartial(s) {
      const k = N();
      return k.acknowledgement = s.acknowledgement ?? new Uint8Array(), k.proof = s.proof ?? new Uint8Array(), s.proofHeight !== void 0 && s.proofHeight !== null && (k.proofHeight = t.Height.fromPartial(s.proofHeight)), k;
    }
  };
  function q() {
    return {
      portId: "",
      channelId: "",
      pagination: void 0,
      packetCommitmentSequences: []
    };
  }
  e.QueryPacketAcknowledgementsRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementsRequest",
    encode(s, k = f.BinaryWriter.create()) {
      s.portId !== "" && k.uint32(10).string(s.portId), s.channelId !== "" && k.uint32(18).string(s.channelId), s.pagination !== void 0 && n.PageRequest.encode(s.pagination, k.uint32(26).fork()).ldelim(), k.uint32(34).fork();
      for (const g of s.packetCommitmentSequences)
        k.uint64(g);
      return k.ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = q();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.portId = g.string();
            break;
          case 2:
            A.channelId = g.string();
            break;
          case 3:
            A.pagination = n.PageRequest.decode(g, g.uint32());
            break;
          case 4:
            if ((W & 7) === 2) {
              const L = g.uint32() + g.pos;
              for (; g.pos < L; )
                A.packetCommitmentSequences.push(g.uint64());
            } else
              A.packetCommitmentSequences.push(g.uint64());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = q();
      return (0, S.isSet)(s.portId) && (k.portId = String(s.portId)), (0, S.isSet)(s.channelId) && (k.channelId = String(s.channelId)), (0, S.isSet)(s.pagination) && (k.pagination = n.PageRequest.fromJSON(s.pagination)), Array.isArray(s == null ? void 0 : s.packetCommitmentSequences) && (k.packetCommitmentSequences = s.packetCommitmentSequences.map((g) => BigInt(g.toString()))), k;
    },
    toJSON(s) {
      const k = {};
      return s.portId !== void 0 && (k.portId = s.portId), s.channelId !== void 0 && (k.channelId = s.channelId), s.pagination !== void 0 && (k.pagination = s.pagination ? n.PageRequest.toJSON(s.pagination) : void 0), s.packetCommitmentSequences ? k.packetCommitmentSequences = s.packetCommitmentSequences.map((g) => (g || BigInt(0)).toString()) : k.packetCommitmentSequences = [], k;
    },
    fromPartial(s) {
      var g;
      const k = q();
      return k.portId = s.portId ?? "", k.channelId = s.channelId ?? "", s.pagination !== void 0 && s.pagination !== null && (k.pagination = n.PageRequest.fromPartial(s.pagination)), k.packetCommitmentSequences = ((g = s.packetCommitmentSequences) == null ? void 0 : g.map((P) => BigInt(P.toString()))) || [], k;
    }
  };
  function u() {
    return {
      acknowledgements: [],
      pagination: void 0,
      height: t.Height.fromPartial({})
    };
  }
  e.QueryPacketAcknowledgementsResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementsResponse",
    encode(s, k = f.BinaryWriter.create()) {
      for (const g of s.acknowledgements)
        r.PacketState.encode(g, k.uint32(10).fork()).ldelim();
      return s.pagination !== void 0 && n.PageResponse.encode(s.pagination, k.uint32(18).fork()).ldelim(), s.height !== void 0 && t.Height.encode(s.height, k.uint32(26).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = u();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.acknowledgements.push(r.PacketState.decode(g, g.uint32()));
            break;
          case 2:
            A.pagination = n.PageResponse.decode(g, g.uint32());
            break;
          case 3:
            A.height = t.Height.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = u();
      return Array.isArray(s == null ? void 0 : s.acknowledgements) && (k.acknowledgements = s.acknowledgements.map((g) => r.PacketState.fromJSON(g))), (0, S.isSet)(s.pagination) && (k.pagination = n.PageResponse.fromJSON(s.pagination)), (0, S.isSet)(s.height) && (k.height = t.Height.fromJSON(s.height)), k;
    },
    toJSON(s) {
      const k = {};
      return s.acknowledgements ? k.acknowledgements = s.acknowledgements.map((g) => g ? r.PacketState.toJSON(g) : void 0) : k.acknowledgements = [], s.pagination !== void 0 && (k.pagination = s.pagination ? n.PageResponse.toJSON(s.pagination) : void 0), s.height !== void 0 && (k.height = s.height ? t.Height.toJSON(s.height) : void 0), k;
    },
    fromPartial(s) {
      var g;
      const k = u();
      return k.acknowledgements = ((g = s.acknowledgements) == null ? void 0 : g.map((P) => r.PacketState.fromPartial(P))) || [], s.pagination !== void 0 && s.pagination !== null && (k.pagination = n.PageResponse.fromPartial(s.pagination)), s.height !== void 0 && s.height !== null && (k.height = t.Height.fromPartial(s.height)), k;
    }
  };
  function l() {
    return {
      portId: "",
      channelId: "",
      packetCommitmentSequences: []
    };
  }
  e.QueryUnreceivedPacketsRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryUnreceivedPacketsRequest",
    encode(s, k = f.BinaryWriter.create()) {
      s.portId !== "" && k.uint32(10).string(s.portId), s.channelId !== "" && k.uint32(18).string(s.channelId), k.uint32(26).fork();
      for (const g of s.packetCommitmentSequences)
        k.uint64(g);
      return k.ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = l();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.portId = g.string();
            break;
          case 2:
            A.channelId = g.string();
            break;
          case 3:
            if ((W & 7) === 2) {
              const L = g.uint32() + g.pos;
              for (; g.pos < L; )
                A.packetCommitmentSequences.push(g.uint64());
            } else
              A.packetCommitmentSequences.push(g.uint64());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = l();
      return (0, S.isSet)(s.portId) && (k.portId = String(s.portId)), (0, S.isSet)(s.channelId) && (k.channelId = String(s.channelId)), Array.isArray(s == null ? void 0 : s.packetCommitmentSequences) && (k.packetCommitmentSequences = s.packetCommitmentSequences.map((g) => BigInt(g.toString()))), k;
    },
    toJSON(s) {
      const k = {};
      return s.portId !== void 0 && (k.portId = s.portId), s.channelId !== void 0 && (k.channelId = s.channelId), s.packetCommitmentSequences ? k.packetCommitmentSequences = s.packetCommitmentSequences.map((g) => (g || BigInt(0)).toString()) : k.packetCommitmentSequences = [], k;
    },
    fromPartial(s) {
      var g;
      const k = l();
      return k.portId = s.portId ?? "", k.channelId = s.channelId ?? "", k.packetCommitmentSequences = ((g = s.packetCommitmentSequences) == null ? void 0 : g.map((P) => BigInt(P.toString()))) || [], k;
    }
  };
  function I() {
    return {
      sequences: [],
      height: t.Height.fromPartial({})
    };
  }
  e.QueryUnreceivedPacketsResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryUnreceivedPacketsResponse",
    encode(s, k = f.BinaryWriter.create()) {
      k.uint32(10).fork();
      for (const g of s.sequences)
        k.uint64(g);
      return k.ldelim(), s.height !== void 0 && t.Height.encode(s.height, k.uint32(18).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = I();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            if ((W & 7) === 2) {
              const L = g.uint32() + g.pos;
              for (; g.pos < L; )
                A.sequences.push(g.uint64());
            } else
              A.sequences.push(g.uint64());
            break;
          case 2:
            A.height = t.Height.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = I();
      return Array.isArray(s == null ? void 0 : s.sequences) && (k.sequences = s.sequences.map((g) => BigInt(g.toString()))), (0, S.isSet)(s.height) && (k.height = t.Height.fromJSON(s.height)), k;
    },
    toJSON(s) {
      const k = {};
      return s.sequences ? k.sequences = s.sequences.map((g) => (g || BigInt(0)).toString()) : k.sequences = [], s.height !== void 0 && (k.height = s.height ? t.Height.toJSON(s.height) : void 0), k;
    },
    fromPartial(s) {
      var g;
      const k = I();
      return k.sequences = ((g = s.sequences) == null ? void 0 : g.map((P) => BigInt(P.toString()))) || [], s.height !== void 0 && s.height !== null && (k.height = t.Height.fromPartial(s.height)), k;
    }
  };
  function B() {
    return {
      portId: "",
      channelId: "",
      packetAckSequences: []
    };
  }
  e.QueryUnreceivedAcksRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryUnreceivedAcksRequest",
    encode(s, k = f.BinaryWriter.create()) {
      s.portId !== "" && k.uint32(10).string(s.portId), s.channelId !== "" && k.uint32(18).string(s.channelId), k.uint32(26).fork();
      for (const g of s.packetAckSequences)
        k.uint64(g);
      return k.ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = B();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.portId = g.string();
            break;
          case 2:
            A.channelId = g.string();
            break;
          case 3:
            if ((W & 7) === 2) {
              const L = g.uint32() + g.pos;
              for (; g.pos < L; )
                A.packetAckSequences.push(g.uint64());
            } else
              A.packetAckSequences.push(g.uint64());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = B();
      return (0, S.isSet)(s.portId) && (k.portId = String(s.portId)), (0, S.isSet)(s.channelId) && (k.channelId = String(s.channelId)), Array.isArray(s == null ? void 0 : s.packetAckSequences) && (k.packetAckSequences = s.packetAckSequences.map((g) => BigInt(g.toString()))), k;
    },
    toJSON(s) {
      const k = {};
      return s.portId !== void 0 && (k.portId = s.portId), s.channelId !== void 0 && (k.channelId = s.channelId), s.packetAckSequences ? k.packetAckSequences = s.packetAckSequences.map((g) => (g || BigInt(0)).toString()) : k.packetAckSequences = [], k;
    },
    fromPartial(s) {
      var g;
      const k = B();
      return k.portId = s.portId ?? "", k.channelId = s.channelId ?? "", k.packetAckSequences = ((g = s.packetAckSequences) == null ? void 0 : g.map((P) => BigInt(P.toString()))) || [], k;
    }
  };
  function b() {
    return {
      sequences: [],
      height: t.Height.fromPartial({})
    };
  }
  e.QueryUnreceivedAcksResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryUnreceivedAcksResponse",
    encode(s, k = f.BinaryWriter.create()) {
      k.uint32(10).fork();
      for (const g of s.sequences)
        k.uint64(g);
      return k.ldelim(), s.height !== void 0 && t.Height.encode(s.height, k.uint32(18).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = b();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            if ((W & 7) === 2) {
              const L = g.uint32() + g.pos;
              for (; g.pos < L; )
                A.sequences.push(g.uint64());
            } else
              A.sequences.push(g.uint64());
            break;
          case 2:
            A.height = t.Height.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = b();
      return Array.isArray(s == null ? void 0 : s.sequences) && (k.sequences = s.sequences.map((g) => BigInt(g.toString()))), (0, S.isSet)(s.height) && (k.height = t.Height.fromJSON(s.height)), k;
    },
    toJSON(s) {
      const k = {};
      return s.sequences ? k.sequences = s.sequences.map((g) => (g || BigInt(0)).toString()) : k.sequences = [], s.height !== void 0 && (k.height = s.height ? t.Height.toJSON(s.height) : void 0), k;
    },
    fromPartial(s) {
      var g;
      const k = b();
      return k.sequences = ((g = s.sequences) == null ? void 0 : g.map((P) => BigInt(P.toString()))) || [], s.height !== void 0 && s.height !== null && (k.height = t.Height.fromPartial(s.height)), k;
    }
  };
  function D() {
    return {
      portId: "",
      channelId: ""
    };
  }
  e.QueryNextSequenceReceiveRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryNextSequenceReceiveRequest",
    encode(s, k = f.BinaryWriter.create()) {
      return s.portId !== "" && k.uint32(10).string(s.portId), s.channelId !== "" && k.uint32(18).string(s.channelId), k;
    },
    decode(s, k) {
      const g = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = D();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.portId = g.string();
            break;
          case 2:
            A.channelId = g.string();
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = D();
      return (0, S.isSet)(s.portId) && (k.portId = String(s.portId)), (0, S.isSet)(s.channelId) && (k.channelId = String(s.channelId)), k;
    },
    toJSON(s) {
      const k = {};
      return s.portId !== void 0 && (k.portId = s.portId), s.channelId !== void 0 && (k.channelId = s.channelId), k;
    },
    fromPartial(s) {
      const k = D();
      return k.portId = s.portId ?? "", k.channelId = s.channelId ?? "", k;
    }
  };
  function Q() {
    return {
      nextSequenceReceive: BigInt(0),
      proof: new Uint8Array(),
      proofHeight: t.Height.fromPartial({})
    };
  }
  e.QueryNextSequenceReceiveResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryNextSequenceReceiveResponse",
    encode(s, k = f.BinaryWriter.create()) {
      return s.nextSequenceReceive !== BigInt(0) && k.uint32(8).uint64(s.nextSequenceReceive), s.proof.length !== 0 && k.uint32(18).bytes(s.proof), s.proofHeight !== void 0 && t.Height.encode(s.proofHeight, k.uint32(26).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = Q();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.nextSequenceReceive = g.uint64();
            break;
          case 2:
            A.proof = g.bytes();
            break;
          case 3:
            A.proofHeight = t.Height.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = Q();
      return (0, S.isSet)(s.nextSequenceReceive) && (k.nextSequenceReceive = BigInt(s.nextSequenceReceive.toString())), (0, S.isSet)(s.proof) && (k.proof = (0, S.bytesFromBase64)(s.proof)), (0, S.isSet)(s.proofHeight) && (k.proofHeight = t.Height.fromJSON(s.proofHeight)), k;
    },
    toJSON(s) {
      const k = {};
      return s.nextSequenceReceive !== void 0 && (k.nextSequenceReceive = (s.nextSequenceReceive || BigInt(0)).toString()), s.proof !== void 0 && (k.proof = (0, S.base64FromBytes)(s.proof !== void 0 ? s.proof : new Uint8Array())), s.proofHeight !== void 0 && (k.proofHeight = s.proofHeight ? t.Height.toJSON(s.proofHeight) : void 0), k;
    },
    fromPartial(s) {
      const k = Q();
      return s.nextSequenceReceive !== void 0 && s.nextSequenceReceive !== null && (k.nextSequenceReceive = BigInt(s.nextSequenceReceive.toString())), k.proof = s.proof ?? new Uint8Array(), s.proofHeight !== void 0 && s.proofHeight !== null && (k.proofHeight = t.Height.fromPartial(s.proofHeight)), k;
    }
  };
  class H {
    constructor(k) {
      this.rpc = k, this.Channel = this.Channel.bind(this), this.Channels = this.Channels.bind(this), this.ConnectionChannels = this.ConnectionChannels.bind(this), this.ChannelClientState = this.ChannelClientState.bind(this), this.ChannelConsensusState = this.ChannelConsensusState.bind(this), this.PacketCommitment = this.PacketCommitment.bind(this), this.PacketCommitments = this.PacketCommitments.bind(this), this.PacketReceipt = this.PacketReceipt.bind(this), this.PacketAcknowledgement = this.PacketAcknowledgement.bind(this), this.PacketAcknowledgements = this.PacketAcknowledgements.bind(this), this.UnreceivedPackets = this.UnreceivedPackets.bind(this), this.UnreceivedAcks = this.UnreceivedAcks.bind(this), this.NextSequenceReceive = this.NextSequenceReceive.bind(this);
    }
    Channel(k) {
      const g = e.QueryChannelRequest.encode(k).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "Channel", g).then((A) => e.QueryChannelResponse.decode(new f.BinaryReader(A)));
    }
    Channels(k = {
      pagination: n.PageRequest.fromPartial({})
    }) {
      const g = e.QueryChannelsRequest.encode(k).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "Channels", g).then((A) => e.QueryChannelsResponse.decode(new f.BinaryReader(A)));
    }
    ConnectionChannels(k) {
      const g = e.QueryConnectionChannelsRequest.encode(k).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "ConnectionChannels", g).then((A) => e.QueryConnectionChannelsResponse.decode(new f.BinaryReader(A)));
    }
    ChannelClientState(k) {
      const g = e.QueryChannelClientStateRequest.encode(k).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "ChannelClientState", g).then((A) => e.QueryChannelClientStateResponse.decode(new f.BinaryReader(A)));
    }
    ChannelConsensusState(k) {
      const g = e.QueryChannelConsensusStateRequest.encode(k).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "ChannelConsensusState", g).then((A) => e.QueryChannelConsensusStateResponse.decode(new f.BinaryReader(A)));
    }
    PacketCommitment(k) {
      const g = e.QueryPacketCommitmentRequest.encode(k).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "PacketCommitment", g).then((A) => e.QueryPacketCommitmentResponse.decode(new f.BinaryReader(A)));
    }
    PacketCommitments(k) {
      const g = e.QueryPacketCommitmentsRequest.encode(k).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "PacketCommitments", g).then((A) => e.QueryPacketCommitmentsResponse.decode(new f.BinaryReader(A)));
    }
    PacketReceipt(k) {
      const g = e.QueryPacketReceiptRequest.encode(k).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "PacketReceipt", g).then((A) => e.QueryPacketReceiptResponse.decode(new f.BinaryReader(A)));
    }
    PacketAcknowledgement(k) {
      const g = e.QueryPacketAcknowledgementRequest.encode(k).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "PacketAcknowledgement", g).then((A) => e.QueryPacketAcknowledgementResponse.decode(new f.BinaryReader(A)));
    }
    PacketAcknowledgements(k) {
      const g = e.QueryPacketAcknowledgementsRequest.encode(k).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "PacketAcknowledgements", g).then((A) => e.QueryPacketAcknowledgementsResponse.decode(new f.BinaryReader(A)));
    }
    UnreceivedPackets(k) {
      const g = e.QueryUnreceivedPacketsRequest.encode(k).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "UnreceivedPackets", g).then((A) => e.QueryUnreceivedPacketsResponse.decode(new f.BinaryReader(A)));
    }
    UnreceivedAcks(k) {
      const g = e.QueryUnreceivedAcksRequest.encode(k).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "UnreceivedAcks", g).then((A) => e.QueryUnreceivedAcksResponse.decode(new f.BinaryReader(A)));
    }
    NextSequenceReceive(k) {
      const g = e.QueryNextSequenceReceiveRequest.encode(k).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "NextSequenceReceive", g).then((A) => e.QueryNextSequenceReceiveResponse.decode(new f.BinaryReader(A)));
    }
  }
  e.QueryClientImpl = H;
})(qh);
var Vh = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryUpgradedConsensusStateResponse = e.QueryUpgradedConsensusStateRequest = e.QueryUpgradedClientStateResponse = e.QueryUpgradedClientStateRequest = e.QueryClientParamsResponse = e.QueryClientParamsRequest = e.QueryClientStatusResponse = e.QueryClientStatusRequest = e.QueryConsensusStateHeightsResponse = e.QueryConsensusStateHeightsRequest = e.QueryConsensusStatesResponse = e.QueryConsensusStatesRequest = e.QueryConsensusStateResponse = e.QueryConsensusStateRequest = e.QueryClientStatesResponse = e.QueryClientStatesRequest = e.QueryClientStateResponse = e.QueryClientStateRequest = e.protobufPackage = void 0;
  const n = Ae, r = Pe, t = yt, i = re, f = ie;
  e.protobufPackage = "ibc.core.client.v1";
  function S() {
    return {
      clientId: ""
    };
  }
  e.QueryClientStateRequest = {
    typeUrl: "/ibc.core.client.v1.QueryClientStateRequest",
    encode(q, u = i.BinaryWriter.create()) {
      return q.clientId !== "" && u.uint32(10).string(q.clientId), u;
    },
    decode(q, u) {
      const l = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let I = u === void 0 ? l.len : l.pos + u;
      const B = S();
      for (; l.pos < I; ) {
        const b = l.uint32();
        switch (b >>> 3) {
          case 1:
            B.clientId = l.string();
            break;
          default:
            l.skipType(b & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(q) {
      const u = S();
      return (0, f.isSet)(q.clientId) && (u.clientId = String(q.clientId)), u;
    },
    toJSON(q) {
      const u = {};
      return q.clientId !== void 0 && (u.clientId = q.clientId), u;
    },
    fromPartial(q) {
      const u = S();
      return u.clientId = q.clientId ?? "", u;
    }
  };
  function w() {
    return {
      clientState: void 0,
      proof: new Uint8Array(),
      proofHeight: t.Height.fromPartial({})
    };
  }
  e.QueryClientStateResponse = {
    typeUrl: "/ibc.core.client.v1.QueryClientStateResponse",
    encode(q, u = i.BinaryWriter.create()) {
      return q.clientState !== void 0 && r.Any.encode(q.clientState, u.uint32(10).fork()).ldelim(), q.proof.length !== 0 && u.uint32(18).bytes(q.proof), q.proofHeight !== void 0 && t.Height.encode(q.proofHeight, u.uint32(26).fork()).ldelim(), u;
    },
    decode(q, u) {
      const l = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let I = u === void 0 ? l.len : l.pos + u;
      const B = w();
      for (; l.pos < I; ) {
        const b = l.uint32();
        switch (b >>> 3) {
          case 1:
            B.clientState = r.Any.decode(l, l.uint32());
            break;
          case 2:
            B.proof = l.bytes();
            break;
          case 3:
            B.proofHeight = t.Height.decode(l, l.uint32());
            break;
          default:
            l.skipType(b & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(q) {
      const u = w();
      return (0, f.isSet)(q.clientState) && (u.clientState = r.Any.fromJSON(q.clientState)), (0, f.isSet)(q.proof) && (u.proof = (0, f.bytesFromBase64)(q.proof)), (0, f.isSet)(q.proofHeight) && (u.proofHeight = t.Height.fromJSON(q.proofHeight)), u;
    },
    toJSON(q) {
      const u = {};
      return q.clientState !== void 0 && (u.clientState = q.clientState ? r.Any.toJSON(q.clientState) : void 0), q.proof !== void 0 && (u.proof = (0, f.base64FromBytes)(q.proof !== void 0 ? q.proof : new Uint8Array())), q.proofHeight !== void 0 && (u.proofHeight = q.proofHeight ? t.Height.toJSON(q.proofHeight) : void 0), u;
    },
    fromPartial(q) {
      const u = w();
      return q.clientState !== void 0 && q.clientState !== null && (u.clientState = r.Any.fromPartial(q.clientState)), u.proof = q.proof ?? new Uint8Array(), q.proofHeight !== void 0 && q.proofHeight !== null && (u.proofHeight = t.Height.fromPartial(q.proofHeight)), u;
    }
  };
  function T() {
    return {
      pagination: void 0
    };
  }
  e.QueryClientStatesRequest = {
    typeUrl: "/ibc.core.client.v1.QueryClientStatesRequest",
    encode(q, u = i.BinaryWriter.create()) {
      return q.pagination !== void 0 && n.PageRequest.encode(q.pagination, u.uint32(10).fork()).ldelim(), u;
    },
    decode(q, u) {
      const l = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let I = u === void 0 ? l.len : l.pos + u;
      const B = T();
      for (; l.pos < I; ) {
        const b = l.uint32();
        switch (b >>> 3) {
          case 1:
            B.pagination = n.PageRequest.decode(l, l.uint32());
            break;
          default:
            l.skipType(b & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(q) {
      const u = T();
      return (0, f.isSet)(q.pagination) && (u.pagination = n.PageRequest.fromJSON(q.pagination)), u;
    },
    toJSON(q) {
      const u = {};
      return q.pagination !== void 0 && (u.pagination = q.pagination ? n.PageRequest.toJSON(q.pagination) : void 0), u;
    },
    fromPartial(q) {
      const u = T();
      return q.pagination !== void 0 && q.pagination !== null && (u.pagination = n.PageRequest.fromPartial(q.pagination)), u;
    }
  };
  function J() {
    return {
      clientStates: [],
      pagination: void 0
    };
  }
  e.QueryClientStatesResponse = {
    typeUrl: "/ibc.core.client.v1.QueryClientStatesResponse",
    encode(q, u = i.BinaryWriter.create()) {
      for (const l of q.clientStates)
        t.IdentifiedClientState.encode(l, u.uint32(10).fork()).ldelim();
      return q.pagination !== void 0 && n.PageResponse.encode(q.pagination, u.uint32(18).fork()).ldelim(), u;
    },
    decode(q, u) {
      const l = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let I = u === void 0 ? l.len : l.pos + u;
      const B = J();
      for (; l.pos < I; ) {
        const b = l.uint32();
        switch (b >>> 3) {
          case 1:
            B.clientStates.push(t.IdentifiedClientState.decode(l, l.uint32()));
            break;
          case 2:
            B.pagination = n.PageResponse.decode(l, l.uint32());
            break;
          default:
            l.skipType(b & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(q) {
      const u = J();
      return Array.isArray(q == null ? void 0 : q.clientStates) && (u.clientStates = q.clientStates.map((l) => t.IdentifiedClientState.fromJSON(l))), (0, f.isSet)(q.pagination) && (u.pagination = n.PageResponse.fromJSON(q.pagination)), u;
    },
    toJSON(q) {
      const u = {};
      return q.clientStates ? u.clientStates = q.clientStates.map((l) => l ? t.IdentifiedClientState.toJSON(l) : void 0) : u.clientStates = [], q.pagination !== void 0 && (u.pagination = q.pagination ? n.PageResponse.toJSON(q.pagination) : void 0), u;
    },
    fromPartial(q) {
      var l;
      const u = J();
      return u.clientStates = ((l = q.clientStates) == null ? void 0 : l.map((I) => t.IdentifiedClientState.fromPartial(I))) || [], q.pagination !== void 0 && q.pagination !== null && (u.pagination = n.PageResponse.fromPartial(q.pagination)), u;
    }
  };
  function C() {
    return {
      clientId: "",
      revisionNumber: BigInt(0),
      revisionHeight: BigInt(0),
      latestHeight: !1
    };
  }
  e.QueryConsensusStateRequest = {
    typeUrl: "/ibc.core.client.v1.QueryConsensusStateRequest",
    encode(q, u = i.BinaryWriter.create()) {
      return q.clientId !== "" && u.uint32(10).string(q.clientId), q.revisionNumber !== BigInt(0) && u.uint32(16).uint64(q.revisionNumber), q.revisionHeight !== BigInt(0) && u.uint32(24).uint64(q.revisionHeight), q.latestHeight === !0 && u.uint32(32).bool(q.latestHeight), u;
    },
    decode(q, u) {
      const l = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let I = u === void 0 ? l.len : l.pos + u;
      const B = C();
      for (; l.pos < I; ) {
        const b = l.uint32();
        switch (b >>> 3) {
          case 1:
            B.clientId = l.string();
            break;
          case 2:
            B.revisionNumber = l.uint64();
            break;
          case 3:
            B.revisionHeight = l.uint64();
            break;
          case 4:
            B.latestHeight = l.bool();
            break;
          default:
            l.skipType(b & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(q) {
      const u = C();
      return (0, f.isSet)(q.clientId) && (u.clientId = String(q.clientId)), (0, f.isSet)(q.revisionNumber) && (u.revisionNumber = BigInt(q.revisionNumber.toString())), (0, f.isSet)(q.revisionHeight) && (u.revisionHeight = BigInt(q.revisionHeight.toString())), (0, f.isSet)(q.latestHeight) && (u.latestHeight = !!q.latestHeight), u;
    },
    toJSON(q) {
      const u = {};
      return q.clientId !== void 0 && (u.clientId = q.clientId), q.revisionNumber !== void 0 && (u.revisionNumber = (q.revisionNumber || BigInt(0)).toString()), q.revisionHeight !== void 0 && (u.revisionHeight = (q.revisionHeight || BigInt(0)).toString()), q.latestHeight !== void 0 && (u.latestHeight = q.latestHeight), u;
    },
    fromPartial(q) {
      const u = C();
      return u.clientId = q.clientId ?? "", q.revisionNumber !== void 0 && q.revisionNumber !== null && (u.revisionNumber = BigInt(q.revisionNumber.toString())), q.revisionHeight !== void 0 && q.revisionHeight !== null && (u.revisionHeight = BigInt(q.revisionHeight.toString())), u.latestHeight = q.latestHeight ?? !1, u;
    }
  };
  function R() {
    return {
      consensusState: void 0,
      proof: new Uint8Array(),
      proofHeight: t.Height.fromPartial({})
    };
  }
  e.QueryConsensusStateResponse = {
    typeUrl: "/ibc.core.client.v1.QueryConsensusStateResponse",
    encode(q, u = i.BinaryWriter.create()) {
      return q.consensusState !== void 0 && r.Any.encode(q.consensusState, u.uint32(10).fork()).ldelim(), q.proof.length !== 0 && u.uint32(18).bytes(q.proof), q.proofHeight !== void 0 && t.Height.encode(q.proofHeight, u.uint32(26).fork()).ldelim(), u;
    },
    decode(q, u) {
      const l = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let I = u === void 0 ? l.len : l.pos + u;
      const B = R();
      for (; l.pos < I; ) {
        const b = l.uint32();
        switch (b >>> 3) {
          case 1:
            B.consensusState = r.Any.decode(l, l.uint32());
            break;
          case 2:
            B.proof = l.bytes();
            break;
          case 3:
            B.proofHeight = t.Height.decode(l, l.uint32());
            break;
          default:
            l.skipType(b & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(q) {
      const u = R();
      return (0, f.isSet)(q.consensusState) && (u.consensusState = r.Any.fromJSON(q.consensusState)), (0, f.isSet)(q.proof) && (u.proof = (0, f.bytesFromBase64)(q.proof)), (0, f.isSet)(q.proofHeight) && (u.proofHeight = t.Height.fromJSON(q.proofHeight)), u;
    },
    toJSON(q) {
      const u = {};
      return q.consensusState !== void 0 && (u.consensusState = q.consensusState ? r.Any.toJSON(q.consensusState) : void 0), q.proof !== void 0 && (u.proof = (0, f.base64FromBytes)(q.proof !== void 0 ? q.proof : new Uint8Array())), q.proofHeight !== void 0 && (u.proofHeight = q.proofHeight ? t.Height.toJSON(q.proofHeight) : void 0), u;
    },
    fromPartial(q) {
      const u = R();
      return q.consensusState !== void 0 && q.consensusState !== null && (u.consensusState = r.Any.fromPartial(q.consensusState)), u.proof = q.proof ?? new Uint8Array(), q.proofHeight !== void 0 && q.proofHeight !== null && (u.proofHeight = t.Height.fromPartial(q.proofHeight)), u;
    }
  };
  function p() {
    return {
      clientId: "",
      pagination: void 0
    };
  }
  e.QueryConsensusStatesRequest = {
    typeUrl: "/ibc.core.client.v1.QueryConsensusStatesRequest",
    encode(q, u = i.BinaryWriter.create()) {
      return q.clientId !== "" && u.uint32(10).string(q.clientId), q.pagination !== void 0 && n.PageRequest.encode(q.pagination, u.uint32(18).fork()).ldelim(), u;
    },
    decode(q, u) {
      const l = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let I = u === void 0 ? l.len : l.pos + u;
      const B = p();
      for (; l.pos < I; ) {
        const b = l.uint32();
        switch (b >>> 3) {
          case 1:
            B.clientId = l.string();
            break;
          case 2:
            B.pagination = n.PageRequest.decode(l, l.uint32());
            break;
          default:
            l.skipType(b & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(q) {
      const u = p();
      return (0, f.isSet)(q.clientId) && (u.clientId = String(q.clientId)), (0, f.isSet)(q.pagination) && (u.pagination = n.PageRequest.fromJSON(q.pagination)), u;
    },
    toJSON(q) {
      const u = {};
      return q.clientId !== void 0 && (u.clientId = q.clientId), q.pagination !== void 0 && (u.pagination = q.pagination ? n.PageRequest.toJSON(q.pagination) : void 0), u;
    },
    fromPartial(q) {
      const u = p();
      return u.clientId = q.clientId ?? "", q.pagination !== void 0 && q.pagination !== null && (u.pagination = n.PageRequest.fromPartial(q.pagination)), u;
    }
  };
  function m() {
    return {
      consensusStates: [],
      pagination: void 0
    };
  }
  e.QueryConsensusStatesResponse = {
    typeUrl: "/ibc.core.client.v1.QueryConsensusStatesResponse",
    encode(q, u = i.BinaryWriter.create()) {
      for (const l of q.consensusStates)
        t.ConsensusStateWithHeight.encode(l, u.uint32(10).fork()).ldelim();
      return q.pagination !== void 0 && n.PageResponse.encode(q.pagination, u.uint32(18).fork()).ldelim(), u;
    },
    decode(q, u) {
      const l = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let I = u === void 0 ? l.len : l.pos + u;
      const B = m();
      for (; l.pos < I; ) {
        const b = l.uint32();
        switch (b >>> 3) {
          case 1:
            B.consensusStates.push(t.ConsensusStateWithHeight.decode(l, l.uint32()));
            break;
          case 2:
            B.pagination = n.PageResponse.decode(l, l.uint32());
            break;
          default:
            l.skipType(b & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(q) {
      const u = m();
      return Array.isArray(q == null ? void 0 : q.consensusStates) && (u.consensusStates = q.consensusStates.map((l) => t.ConsensusStateWithHeight.fromJSON(l))), (0, f.isSet)(q.pagination) && (u.pagination = n.PageResponse.fromJSON(q.pagination)), u;
    },
    toJSON(q) {
      const u = {};
      return q.consensusStates ? u.consensusStates = q.consensusStates.map((l) => l ? t.ConsensusStateWithHeight.toJSON(l) : void 0) : u.consensusStates = [], q.pagination !== void 0 && (u.pagination = q.pagination ? n.PageResponse.toJSON(q.pagination) : void 0), u;
    },
    fromPartial(q) {
      var l;
      const u = m();
      return u.consensusStates = ((l = q.consensusStates) == null ? void 0 : l.map((I) => t.ConsensusStateWithHeight.fromPartial(I))) || [], q.pagination !== void 0 && q.pagination !== null && (u.pagination = n.PageResponse.fromPartial(q.pagination)), u;
    }
  };
  function v() {
    return {
      clientId: "",
      pagination: void 0
    };
  }
  e.QueryConsensusStateHeightsRequest = {
    typeUrl: "/ibc.core.client.v1.QueryConsensusStateHeightsRequest",
    encode(q, u = i.BinaryWriter.create()) {
      return q.clientId !== "" && u.uint32(10).string(q.clientId), q.pagination !== void 0 && n.PageRequest.encode(q.pagination, u.uint32(18).fork()).ldelim(), u;
    },
    decode(q, u) {
      const l = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let I = u === void 0 ? l.len : l.pos + u;
      const B = v();
      for (; l.pos < I; ) {
        const b = l.uint32();
        switch (b >>> 3) {
          case 1:
            B.clientId = l.string();
            break;
          case 2:
            B.pagination = n.PageRequest.decode(l, l.uint32());
            break;
          default:
            l.skipType(b & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(q) {
      const u = v();
      return (0, f.isSet)(q.clientId) && (u.clientId = String(q.clientId)), (0, f.isSet)(q.pagination) && (u.pagination = n.PageRequest.fromJSON(q.pagination)), u;
    },
    toJSON(q) {
      const u = {};
      return q.clientId !== void 0 && (u.clientId = q.clientId), q.pagination !== void 0 && (u.pagination = q.pagination ? n.PageRequest.toJSON(q.pagination) : void 0), u;
    },
    fromPartial(q) {
      const u = v();
      return u.clientId = q.clientId ?? "", q.pagination !== void 0 && q.pagination !== null && (u.pagination = n.PageRequest.fromPartial(q.pagination)), u;
    }
  };
  function a() {
    return {
      consensusStateHeights: [],
      pagination: void 0
    };
  }
  e.QueryConsensusStateHeightsResponse = {
    typeUrl: "/ibc.core.client.v1.QueryConsensusStateHeightsResponse",
    encode(q, u = i.BinaryWriter.create()) {
      for (const l of q.consensusStateHeights)
        t.Height.encode(l, u.uint32(10).fork()).ldelim();
      return q.pagination !== void 0 && n.PageResponse.encode(q.pagination, u.uint32(18).fork()).ldelim(), u;
    },
    decode(q, u) {
      const l = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let I = u === void 0 ? l.len : l.pos + u;
      const B = a();
      for (; l.pos < I; ) {
        const b = l.uint32();
        switch (b >>> 3) {
          case 1:
            B.consensusStateHeights.push(t.Height.decode(l, l.uint32()));
            break;
          case 2:
            B.pagination = n.PageResponse.decode(l, l.uint32());
            break;
          default:
            l.skipType(b & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(q) {
      const u = a();
      return Array.isArray(q == null ? void 0 : q.consensusStateHeights) && (u.consensusStateHeights = q.consensusStateHeights.map((l) => t.Height.fromJSON(l))), (0, f.isSet)(q.pagination) && (u.pagination = n.PageResponse.fromJSON(q.pagination)), u;
    },
    toJSON(q) {
      const u = {};
      return q.consensusStateHeights ? u.consensusStateHeights = q.consensusStateHeights.map((l) => l ? t.Height.toJSON(l) : void 0) : u.consensusStateHeights = [], q.pagination !== void 0 && (u.pagination = q.pagination ? n.PageResponse.toJSON(q.pagination) : void 0), u;
    },
    fromPartial(q) {
      var l;
      const u = a();
      return u.consensusStateHeights = ((l = q.consensusStateHeights) == null ? void 0 : l.map((I) => t.Height.fromPartial(I))) || [], q.pagination !== void 0 && q.pagination !== null && (u.pagination = n.PageResponse.fromPartial(q.pagination)), u;
    }
  };
  function d() {
    return {
      clientId: ""
    };
  }
  e.QueryClientStatusRequest = {
    typeUrl: "/ibc.core.client.v1.QueryClientStatusRequest",
    encode(q, u = i.BinaryWriter.create()) {
      return q.clientId !== "" && u.uint32(10).string(q.clientId), u;
    },
    decode(q, u) {
      const l = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let I = u === void 0 ? l.len : l.pos + u;
      const B = d();
      for (; l.pos < I; ) {
        const b = l.uint32();
        switch (b >>> 3) {
          case 1:
            B.clientId = l.string();
            break;
          default:
            l.skipType(b & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(q) {
      const u = d();
      return (0, f.isSet)(q.clientId) && (u.clientId = String(q.clientId)), u;
    },
    toJSON(q) {
      const u = {};
      return q.clientId !== void 0 && (u.clientId = q.clientId), u;
    },
    fromPartial(q) {
      const u = d();
      return u.clientId = q.clientId ?? "", u;
    }
  };
  function y() {
    return {
      status: ""
    };
  }
  e.QueryClientStatusResponse = {
    typeUrl: "/ibc.core.client.v1.QueryClientStatusResponse",
    encode(q, u = i.BinaryWriter.create()) {
      return q.status !== "" && u.uint32(10).string(q.status), u;
    },
    decode(q, u) {
      const l = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let I = u === void 0 ? l.len : l.pos + u;
      const B = y();
      for (; l.pos < I; ) {
        const b = l.uint32();
        switch (b >>> 3) {
          case 1:
            B.status = l.string();
            break;
          default:
            l.skipType(b & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(q) {
      const u = y();
      return (0, f.isSet)(q.status) && (u.status = String(q.status)), u;
    },
    toJSON(q) {
      const u = {};
      return q.status !== void 0 && (u.status = q.status), u;
    },
    fromPartial(q) {
      const u = y();
      return u.status = q.status ?? "", u;
    }
  };
  function _() {
    return {};
  }
  e.QueryClientParamsRequest = {
    typeUrl: "/ibc.core.client.v1.QueryClientParamsRequest",
    encode(q, u = i.BinaryWriter.create()) {
      return u;
    },
    decode(q, u) {
      const l = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let I = u === void 0 ? l.len : l.pos + u;
      const B = _();
      for (; l.pos < I; ) {
        const b = l.uint32();
        switch (b >>> 3) {
          default:
            l.skipType(b & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(q) {
      return _();
    },
    toJSON(q) {
      return {};
    },
    fromPartial(q) {
      return _();
    }
  };
  function E() {
    return {
      params: void 0
    };
  }
  e.QueryClientParamsResponse = {
    typeUrl: "/ibc.core.client.v1.QueryClientParamsResponse",
    encode(q, u = i.BinaryWriter.create()) {
      return q.params !== void 0 && t.Params.encode(q.params, u.uint32(10).fork()).ldelim(), u;
    },
    decode(q, u) {
      const l = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let I = u === void 0 ? l.len : l.pos + u;
      const B = E();
      for (; l.pos < I; ) {
        const b = l.uint32();
        switch (b >>> 3) {
          case 1:
            B.params = t.Params.decode(l, l.uint32());
            break;
          default:
            l.skipType(b & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(q) {
      const u = E();
      return (0, f.isSet)(q.params) && (u.params = t.Params.fromJSON(q.params)), u;
    },
    toJSON(q) {
      const u = {};
      return q.params !== void 0 && (u.params = q.params ? t.Params.toJSON(q.params) : void 0), u;
    },
    fromPartial(q) {
      const u = E();
      return q.params !== void 0 && q.params !== null && (u.params = t.Params.fromPartial(q.params)), u;
    }
  };
  function U() {
    return {};
  }
  e.QueryUpgradedClientStateRequest = {
    typeUrl: "/ibc.core.client.v1.QueryUpgradedClientStateRequest",
    encode(q, u = i.BinaryWriter.create()) {
      return u;
    },
    decode(q, u) {
      const l = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let I = u === void 0 ? l.len : l.pos + u;
      const B = U();
      for (; l.pos < I; ) {
        const b = l.uint32();
        switch (b >>> 3) {
          default:
            l.skipType(b & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(q) {
      return U();
    },
    toJSON(q) {
      return {};
    },
    fromPartial(q) {
      return U();
    }
  };
  function V() {
    return {
      upgradedClientState: void 0
    };
  }
  e.QueryUpgradedClientStateResponse = {
    typeUrl: "/ibc.core.client.v1.QueryUpgradedClientStateResponse",
    encode(q, u = i.BinaryWriter.create()) {
      return q.upgradedClientState !== void 0 && r.Any.encode(q.upgradedClientState, u.uint32(10).fork()).ldelim(), u;
    },
    decode(q, u) {
      const l = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let I = u === void 0 ? l.len : l.pos + u;
      const B = V();
      for (; l.pos < I; ) {
        const b = l.uint32();
        switch (b >>> 3) {
          case 1:
            B.upgradedClientState = r.Any.decode(l, l.uint32());
            break;
          default:
            l.skipType(b & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(q) {
      const u = V();
      return (0, f.isSet)(q.upgradedClientState) && (u.upgradedClientState = r.Any.fromJSON(q.upgradedClientState)), u;
    },
    toJSON(q) {
      const u = {};
      return q.upgradedClientState !== void 0 && (u.upgradedClientState = q.upgradedClientState ? r.Any.toJSON(q.upgradedClientState) : void 0), u;
    },
    fromPartial(q) {
      const u = V();
      return q.upgradedClientState !== void 0 && q.upgradedClientState !== null && (u.upgradedClientState = r.Any.fromPartial(q.upgradedClientState)), u;
    }
  };
  function o() {
    return {};
  }
  e.QueryUpgradedConsensusStateRequest = {
    typeUrl: "/ibc.core.client.v1.QueryUpgradedConsensusStateRequest",
    encode(q, u = i.BinaryWriter.create()) {
      return u;
    },
    decode(q, u) {
      const l = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let I = u === void 0 ? l.len : l.pos + u;
      const B = o();
      for (; l.pos < I; ) {
        const b = l.uint32();
        switch (b >>> 3) {
          default:
            l.skipType(b & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(q) {
      return o();
    },
    toJSON(q) {
      return {};
    },
    fromPartial(q) {
      return o();
    }
  };
  function h() {
    return {
      upgradedConsensusState: void 0
    };
  }
  e.QueryUpgradedConsensusStateResponse = {
    typeUrl: "/ibc.core.client.v1.QueryUpgradedConsensusStateResponse",
    encode(q, u = i.BinaryWriter.create()) {
      return q.upgradedConsensusState !== void 0 && r.Any.encode(q.upgradedConsensusState, u.uint32(10).fork()).ldelim(), u;
    },
    decode(q, u) {
      const l = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let I = u === void 0 ? l.len : l.pos + u;
      const B = h();
      for (; l.pos < I; ) {
        const b = l.uint32();
        switch (b >>> 3) {
          case 1:
            B.upgradedConsensusState = r.Any.decode(l, l.uint32());
            break;
          default:
            l.skipType(b & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(q) {
      const u = h();
      return (0, f.isSet)(q.upgradedConsensusState) && (u.upgradedConsensusState = r.Any.fromJSON(q.upgradedConsensusState)), u;
    },
    toJSON(q) {
      const u = {};
      return q.upgradedConsensusState !== void 0 && (u.upgradedConsensusState = q.upgradedConsensusState ? r.Any.toJSON(q.upgradedConsensusState) : void 0), u;
    },
    fromPartial(q) {
      const u = h();
      return q.upgradedConsensusState !== void 0 && q.upgradedConsensusState !== null && (u.upgradedConsensusState = r.Any.fromPartial(q.upgradedConsensusState)), u;
    }
  };
  class N {
    constructor(u) {
      this.rpc = u, this.ClientState = this.ClientState.bind(this), this.ClientStates = this.ClientStates.bind(this), this.ConsensusState = this.ConsensusState.bind(this), this.ConsensusStates = this.ConsensusStates.bind(this), this.ConsensusStateHeights = this.ConsensusStateHeights.bind(this), this.ClientStatus = this.ClientStatus.bind(this), this.ClientParams = this.ClientParams.bind(this), this.UpgradedClientState = this.UpgradedClientState.bind(this), this.UpgradedConsensusState = this.UpgradedConsensusState.bind(this);
    }
    ClientState(u) {
      const l = e.QueryClientStateRequest.encode(u).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "ClientState", l).then((B) => e.QueryClientStateResponse.decode(new i.BinaryReader(B)));
    }
    ClientStates(u = {
      pagination: n.PageRequest.fromPartial({})
    }) {
      const l = e.QueryClientStatesRequest.encode(u).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "ClientStates", l).then((B) => e.QueryClientStatesResponse.decode(new i.BinaryReader(B)));
    }
    ConsensusState(u) {
      const l = e.QueryConsensusStateRequest.encode(u).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "ConsensusState", l).then((B) => e.QueryConsensusStateResponse.decode(new i.BinaryReader(B)));
    }
    ConsensusStates(u) {
      const l = e.QueryConsensusStatesRequest.encode(u).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "ConsensusStates", l).then((B) => e.QueryConsensusStatesResponse.decode(new i.BinaryReader(B)));
    }
    ConsensusStateHeights(u) {
      const l = e.QueryConsensusStateHeightsRequest.encode(u).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "ConsensusStateHeights", l).then((B) => e.QueryConsensusStateHeightsResponse.decode(new i.BinaryReader(B)));
    }
    ClientStatus(u) {
      const l = e.QueryClientStatusRequest.encode(u).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "ClientStatus", l).then((B) => e.QueryClientStatusResponse.decode(new i.BinaryReader(B)));
    }
    ClientParams(u = {}) {
      const l = e.QueryClientParamsRequest.encode(u).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "ClientParams", l).then((B) => e.QueryClientParamsResponse.decode(new i.BinaryReader(B)));
    }
    UpgradedClientState(u = {}) {
      const l = e.QueryUpgradedClientStateRequest.encode(u).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "UpgradedClientState", l).then((B) => e.QueryUpgradedClientStateResponse.decode(new i.BinaryReader(B)));
    }
    UpgradedConsensusState(u = {}) {
      const l = e.QueryUpgradedConsensusStateRequest.encode(u).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "UpgradedConsensusState", l).then((B) => e.QueryUpgradedConsensusStateResponse.decode(new i.BinaryReader(B)));
    }
  }
  e.QueryClientImpl = N;
})(Vh);
var Wh = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryConnectionParamsResponse = e.QueryConnectionParamsRequest = e.QueryConnectionConsensusStateResponse = e.QueryConnectionConsensusStateRequest = e.QueryConnectionClientStateResponse = e.QueryConnectionClientStateRequest = e.QueryClientConnectionsResponse = e.QueryClientConnectionsRequest = e.QueryConnectionsResponse = e.QueryConnectionsRequest = e.QueryConnectionResponse = e.QueryConnectionRequest = e.protobufPackage = void 0;
  const n = Ae, r = xc, t = yt, i = Pe, f = re, S = ie;
  e.protobufPackage = "ibc.core.connection.v1";
  function w() {
    return {
      connectionId: ""
    };
  }
  e.QueryConnectionRequest = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionRequest",
    encode(U, V = f.BinaryWriter.create()) {
      return U.connectionId !== "" && V.uint32(10).string(U.connectionId), V;
    },
    decode(U, V) {
      const o = U instanceof f.BinaryReader ? U : new f.BinaryReader(U);
      let h = V === void 0 ? o.len : o.pos + V;
      const N = w();
      for (; o.pos < h; ) {
        const q = o.uint32();
        switch (q >>> 3) {
          case 1:
            N.connectionId = o.string();
            break;
          default:
            o.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(U) {
      const V = w();
      return (0, S.isSet)(U.connectionId) && (V.connectionId = String(U.connectionId)), V;
    },
    toJSON(U) {
      const V = {};
      return U.connectionId !== void 0 && (V.connectionId = U.connectionId), V;
    },
    fromPartial(U) {
      const V = w();
      return V.connectionId = U.connectionId ?? "", V;
    }
  };
  function T() {
    return {
      connection: void 0,
      proof: new Uint8Array(),
      proofHeight: t.Height.fromPartial({})
    };
  }
  e.QueryConnectionResponse = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionResponse",
    encode(U, V = f.BinaryWriter.create()) {
      return U.connection !== void 0 && r.ConnectionEnd.encode(U.connection, V.uint32(10).fork()).ldelim(), U.proof.length !== 0 && V.uint32(18).bytes(U.proof), U.proofHeight !== void 0 && t.Height.encode(U.proofHeight, V.uint32(26).fork()).ldelim(), V;
    },
    decode(U, V) {
      const o = U instanceof f.BinaryReader ? U : new f.BinaryReader(U);
      let h = V === void 0 ? o.len : o.pos + V;
      const N = T();
      for (; o.pos < h; ) {
        const q = o.uint32();
        switch (q >>> 3) {
          case 1:
            N.connection = r.ConnectionEnd.decode(o, o.uint32());
            break;
          case 2:
            N.proof = o.bytes();
            break;
          case 3:
            N.proofHeight = t.Height.decode(o, o.uint32());
            break;
          default:
            o.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(U) {
      const V = T();
      return (0, S.isSet)(U.connection) && (V.connection = r.ConnectionEnd.fromJSON(U.connection)), (0, S.isSet)(U.proof) && (V.proof = (0, S.bytesFromBase64)(U.proof)), (0, S.isSet)(U.proofHeight) && (V.proofHeight = t.Height.fromJSON(U.proofHeight)), V;
    },
    toJSON(U) {
      const V = {};
      return U.connection !== void 0 && (V.connection = U.connection ? r.ConnectionEnd.toJSON(U.connection) : void 0), U.proof !== void 0 && (V.proof = (0, S.base64FromBytes)(U.proof !== void 0 ? U.proof : new Uint8Array())), U.proofHeight !== void 0 && (V.proofHeight = U.proofHeight ? t.Height.toJSON(U.proofHeight) : void 0), V;
    },
    fromPartial(U) {
      const V = T();
      return U.connection !== void 0 && U.connection !== null && (V.connection = r.ConnectionEnd.fromPartial(U.connection)), V.proof = U.proof ?? new Uint8Array(), U.proofHeight !== void 0 && U.proofHeight !== null && (V.proofHeight = t.Height.fromPartial(U.proofHeight)), V;
    }
  };
  function J() {
    return {
      pagination: void 0
    };
  }
  e.QueryConnectionsRequest = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionsRequest",
    encode(U, V = f.BinaryWriter.create()) {
      return U.pagination !== void 0 && n.PageRequest.encode(U.pagination, V.uint32(10).fork()).ldelim(), V;
    },
    decode(U, V) {
      const o = U instanceof f.BinaryReader ? U : new f.BinaryReader(U);
      let h = V === void 0 ? o.len : o.pos + V;
      const N = J();
      for (; o.pos < h; ) {
        const q = o.uint32();
        switch (q >>> 3) {
          case 1:
            N.pagination = n.PageRequest.decode(o, o.uint32());
            break;
          default:
            o.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(U) {
      const V = J();
      return (0, S.isSet)(U.pagination) && (V.pagination = n.PageRequest.fromJSON(U.pagination)), V;
    },
    toJSON(U) {
      const V = {};
      return U.pagination !== void 0 && (V.pagination = U.pagination ? n.PageRequest.toJSON(U.pagination) : void 0), V;
    },
    fromPartial(U) {
      const V = J();
      return U.pagination !== void 0 && U.pagination !== null && (V.pagination = n.PageRequest.fromPartial(U.pagination)), V;
    }
  };
  function C() {
    return {
      connections: [],
      pagination: void 0,
      height: t.Height.fromPartial({})
    };
  }
  e.QueryConnectionsResponse = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionsResponse",
    encode(U, V = f.BinaryWriter.create()) {
      for (const o of U.connections)
        r.IdentifiedConnection.encode(o, V.uint32(10).fork()).ldelim();
      return U.pagination !== void 0 && n.PageResponse.encode(U.pagination, V.uint32(18).fork()).ldelim(), U.height !== void 0 && t.Height.encode(U.height, V.uint32(26).fork()).ldelim(), V;
    },
    decode(U, V) {
      const o = U instanceof f.BinaryReader ? U : new f.BinaryReader(U);
      let h = V === void 0 ? o.len : o.pos + V;
      const N = C();
      for (; o.pos < h; ) {
        const q = o.uint32();
        switch (q >>> 3) {
          case 1:
            N.connections.push(r.IdentifiedConnection.decode(o, o.uint32()));
            break;
          case 2:
            N.pagination = n.PageResponse.decode(o, o.uint32());
            break;
          case 3:
            N.height = t.Height.decode(o, o.uint32());
            break;
          default:
            o.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(U) {
      const V = C();
      return Array.isArray(U == null ? void 0 : U.connections) && (V.connections = U.connections.map((o) => r.IdentifiedConnection.fromJSON(o))), (0, S.isSet)(U.pagination) && (V.pagination = n.PageResponse.fromJSON(U.pagination)), (0, S.isSet)(U.height) && (V.height = t.Height.fromJSON(U.height)), V;
    },
    toJSON(U) {
      const V = {};
      return U.connections ? V.connections = U.connections.map((o) => o ? r.IdentifiedConnection.toJSON(o) : void 0) : V.connections = [], U.pagination !== void 0 && (V.pagination = U.pagination ? n.PageResponse.toJSON(U.pagination) : void 0), U.height !== void 0 && (V.height = U.height ? t.Height.toJSON(U.height) : void 0), V;
    },
    fromPartial(U) {
      var o;
      const V = C();
      return V.connections = ((o = U.connections) == null ? void 0 : o.map((h) => r.IdentifiedConnection.fromPartial(h))) || [], U.pagination !== void 0 && U.pagination !== null && (V.pagination = n.PageResponse.fromPartial(U.pagination)), U.height !== void 0 && U.height !== null && (V.height = t.Height.fromPartial(U.height)), V;
    }
  };
  function R() {
    return {
      clientId: ""
    };
  }
  e.QueryClientConnectionsRequest = {
    typeUrl: "/ibc.core.connection.v1.QueryClientConnectionsRequest",
    encode(U, V = f.BinaryWriter.create()) {
      return U.clientId !== "" && V.uint32(10).string(U.clientId), V;
    },
    decode(U, V) {
      const o = U instanceof f.BinaryReader ? U : new f.BinaryReader(U);
      let h = V === void 0 ? o.len : o.pos + V;
      const N = R();
      for (; o.pos < h; ) {
        const q = o.uint32();
        switch (q >>> 3) {
          case 1:
            N.clientId = o.string();
            break;
          default:
            o.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(U) {
      const V = R();
      return (0, S.isSet)(U.clientId) && (V.clientId = String(U.clientId)), V;
    },
    toJSON(U) {
      const V = {};
      return U.clientId !== void 0 && (V.clientId = U.clientId), V;
    },
    fromPartial(U) {
      const V = R();
      return V.clientId = U.clientId ?? "", V;
    }
  };
  function p() {
    return {
      connectionPaths: [],
      proof: new Uint8Array(),
      proofHeight: t.Height.fromPartial({})
    };
  }
  e.QueryClientConnectionsResponse = {
    typeUrl: "/ibc.core.connection.v1.QueryClientConnectionsResponse",
    encode(U, V = f.BinaryWriter.create()) {
      for (const o of U.connectionPaths)
        V.uint32(10).string(o);
      return U.proof.length !== 0 && V.uint32(18).bytes(U.proof), U.proofHeight !== void 0 && t.Height.encode(U.proofHeight, V.uint32(26).fork()).ldelim(), V;
    },
    decode(U, V) {
      const o = U instanceof f.BinaryReader ? U : new f.BinaryReader(U);
      let h = V === void 0 ? o.len : o.pos + V;
      const N = p();
      for (; o.pos < h; ) {
        const q = o.uint32();
        switch (q >>> 3) {
          case 1:
            N.connectionPaths.push(o.string());
            break;
          case 2:
            N.proof = o.bytes();
            break;
          case 3:
            N.proofHeight = t.Height.decode(o, o.uint32());
            break;
          default:
            o.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(U) {
      const V = p();
      return Array.isArray(U == null ? void 0 : U.connectionPaths) && (V.connectionPaths = U.connectionPaths.map((o) => String(o))), (0, S.isSet)(U.proof) && (V.proof = (0, S.bytesFromBase64)(U.proof)), (0, S.isSet)(U.proofHeight) && (V.proofHeight = t.Height.fromJSON(U.proofHeight)), V;
    },
    toJSON(U) {
      const V = {};
      return U.connectionPaths ? V.connectionPaths = U.connectionPaths.map((o) => o) : V.connectionPaths = [], U.proof !== void 0 && (V.proof = (0, S.base64FromBytes)(U.proof !== void 0 ? U.proof : new Uint8Array())), U.proofHeight !== void 0 && (V.proofHeight = U.proofHeight ? t.Height.toJSON(U.proofHeight) : void 0), V;
    },
    fromPartial(U) {
      var o;
      const V = p();
      return V.connectionPaths = ((o = U.connectionPaths) == null ? void 0 : o.map((h) => h)) || [], V.proof = U.proof ?? new Uint8Array(), U.proofHeight !== void 0 && U.proofHeight !== null && (V.proofHeight = t.Height.fromPartial(U.proofHeight)), V;
    }
  };
  function m() {
    return {
      connectionId: ""
    };
  }
  e.QueryConnectionClientStateRequest = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionClientStateRequest",
    encode(U, V = f.BinaryWriter.create()) {
      return U.connectionId !== "" && V.uint32(10).string(U.connectionId), V;
    },
    decode(U, V) {
      const o = U instanceof f.BinaryReader ? U : new f.BinaryReader(U);
      let h = V === void 0 ? o.len : o.pos + V;
      const N = m();
      for (; o.pos < h; ) {
        const q = o.uint32();
        switch (q >>> 3) {
          case 1:
            N.connectionId = o.string();
            break;
          default:
            o.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(U) {
      const V = m();
      return (0, S.isSet)(U.connectionId) && (V.connectionId = String(U.connectionId)), V;
    },
    toJSON(U) {
      const V = {};
      return U.connectionId !== void 0 && (V.connectionId = U.connectionId), V;
    },
    fromPartial(U) {
      const V = m();
      return V.connectionId = U.connectionId ?? "", V;
    }
  };
  function v() {
    return {
      identifiedClientState: void 0,
      proof: new Uint8Array(),
      proofHeight: t.Height.fromPartial({})
    };
  }
  e.QueryConnectionClientStateResponse = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionClientStateResponse",
    encode(U, V = f.BinaryWriter.create()) {
      return U.identifiedClientState !== void 0 && t.IdentifiedClientState.encode(U.identifiedClientState, V.uint32(10).fork()).ldelim(), U.proof.length !== 0 && V.uint32(18).bytes(U.proof), U.proofHeight !== void 0 && t.Height.encode(U.proofHeight, V.uint32(26).fork()).ldelim(), V;
    },
    decode(U, V) {
      const o = U instanceof f.BinaryReader ? U : new f.BinaryReader(U);
      let h = V === void 0 ? o.len : o.pos + V;
      const N = v();
      for (; o.pos < h; ) {
        const q = o.uint32();
        switch (q >>> 3) {
          case 1:
            N.identifiedClientState = t.IdentifiedClientState.decode(o, o.uint32());
            break;
          case 2:
            N.proof = o.bytes();
            break;
          case 3:
            N.proofHeight = t.Height.decode(o, o.uint32());
            break;
          default:
            o.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(U) {
      const V = v();
      return (0, S.isSet)(U.identifiedClientState) && (V.identifiedClientState = t.IdentifiedClientState.fromJSON(U.identifiedClientState)), (0, S.isSet)(U.proof) && (V.proof = (0, S.bytesFromBase64)(U.proof)), (0, S.isSet)(U.proofHeight) && (V.proofHeight = t.Height.fromJSON(U.proofHeight)), V;
    },
    toJSON(U) {
      const V = {};
      return U.identifiedClientState !== void 0 && (V.identifiedClientState = U.identifiedClientState ? t.IdentifiedClientState.toJSON(U.identifiedClientState) : void 0), U.proof !== void 0 && (V.proof = (0, S.base64FromBytes)(U.proof !== void 0 ? U.proof : new Uint8Array())), U.proofHeight !== void 0 && (V.proofHeight = U.proofHeight ? t.Height.toJSON(U.proofHeight) : void 0), V;
    },
    fromPartial(U) {
      const V = v();
      return U.identifiedClientState !== void 0 && U.identifiedClientState !== null && (V.identifiedClientState = t.IdentifiedClientState.fromPartial(U.identifiedClientState)), V.proof = U.proof ?? new Uint8Array(), U.proofHeight !== void 0 && U.proofHeight !== null && (V.proofHeight = t.Height.fromPartial(U.proofHeight)), V;
    }
  };
  function a() {
    return {
      connectionId: "",
      revisionNumber: BigInt(0),
      revisionHeight: BigInt(0)
    };
  }
  e.QueryConnectionConsensusStateRequest = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionConsensusStateRequest",
    encode(U, V = f.BinaryWriter.create()) {
      return U.connectionId !== "" && V.uint32(10).string(U.connectionId), U.revisionNumber !== BigInt(0) && V.uint32(16).uint64(U.revisionNumber), U.revisionHeight !== BigInt(0) && V.uint32(24).uint64(U.revisionHeight), V;
    },
    decode(U, V) {
      const o = U instanceof f.BinaryReader ? U : new f.BinaryReader(U);
      let h = V === void 0 ? o.len : o.pos + V;
      const N = a();
      for (; o.pos < h; ) {
        const q = o.uint32();
        switch (q >>> 3) {
          case 1:
            N.connectionId = o.string();
            break;
          case 2:
            N.revisionNumber = o.uint64();
            break;
          case 3:
            N.revisionHeight = o.uint64();
            break;
          default:
            o.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(U) {
      const V = a();
      return (0, S.isSet)(U.connectionId) && (V.connectionId = String(U.connectionId)), (0, S.isSet)(U.revisionNumber) && (V.revisionNumber = BigInt(U.revisionNumber.toString())), (0, S.isSet)(U.revisionHeight) && (V.revisionHeight = BigInt(U.revisionHeight.toString())), V;
    },
    toJSON(U) {
      const V = {};
      return U.connectionId !== void 0 && (V.connectionId = U.connectionId), U.revisionNumber !== void 0 && (V.revisionNumber = (U.revisionNumber || BigInt(0)).toString()), U.revisionHeight !== void 0 && (V.revisionHeight = (U.revisionHeight || BigInt(0)).toString()), V;
    },
    fromPartial(U) {
      const V = a();
      return V.connectionId = U.connectionId ?? "", U.revisionNumber !== void 0 && U.revisionNumber !== null && (V.revisionNumber = BigInt(U.revisionNumber.toString())), U.revisionHeight !== void 0 && U.revisionHeight !== null && (V.revisionHeight = BigInt(U.revisionHeight.toString())), V;
    }
  };
  function d() {
    return {
      consensusState: void 0,
      clientId: "",
      proof: new Uint8Array(),
      proofHeight: t.Height.fromPartial({})
    };
  }
  e.QueryConnectionConsensusStateResponse = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionConsensusStateResponse",
    encode(U, V = f.BinaryWriter.create()) {
      return U.consensusState !== void 0 && i.Any.encode(U.consensusState, V.uint32(10).fork()).ldelim(), U.clientId !== "" && V.uint32(18).string(U.clientId), U.proof.length !== 0 && V.uint32(26).bytes(U.proof), U.proofHeight !== void 0 && t.Height.encode(U.proofHeight, V.uint32(34).fork()).ldelim(), V;
    },
    decode(U, V) {
      const o = U instanceof f.BinaryReader ? U : new f.BinaryReader(U);
      let h = V === void 0 ? o.len : o.pos + V;
      const N = d();
      for (; o.pos < h; ) {
        const q = o.uint32();
        switch (q >>> 3) {
          case 1:
            N.consensusState = i.Any.decode(o, o.uint32());
            break;
          case 2:
            N.clientId = o.string();
            break;
          case 3:
            N.proof = o.bytes();
            break;
          case 4:
            N.proofHeight = t.Height.decode(o, o.uint32());
            break;
          default:
            o.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(U) {
      const V = d();
      return (0, S.isSet)(U.consensusState) && (V.consensusState = i.Any.fromJSON(U.consensusState)), (0, S.isSet)(U.clientId) && (V.clientId = String(U.clientId)), (0, S.isSet)(U.proof) && (V.proof = (0, S.bytesFromBase64)(U.proof)), (0, S.isSet)(U.proofHeight) && (V.proofHeight = t.Height.fromJSON(U.proofHeight)), V;
    },
    toJSON(U) {
      const V = {};
      return U.consensusState !== void 0 && (V.consensusState = U.consensusState ? i.Any.toJSON(U.consensusState) : void 0), U.clientId !== void 0 && (V.clientId = U.clientId), U.proof !== void 0 && (V.proof = (0, S.base64FromBytes)(U.proof !== void 0 ? U.proof : new Uint8Array())), U.proofHeight !== void 0 && (V.proofHeight = U.proofHeight ? t.Height.toJSON(U.proofHeight) : void 0), V;
    },
    fromPartial(U) {
      const V = d();
      return U.consensusState !== void 0 && U.consensusState !== null && (V.consensusState = i.Any.fromPartial(U.consensusState)), V.clientId = U.clientId ?? "", V.proof = U.proof ?? new Uint8Array(), U.proofHeight !== void 0 && U.proofHeight !== null && (V.proofHeight = t.Height.fromPartial(U.proofHeight)), V;
    }
  };
  function y() {
    return {};
  }
  e.QueryConnectionParamsRequest = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionParamsRequest",
    encode(U, V = f.BinaryWriter.create()) {
      return V;
    },
    decode(U, V) {
      const o = U instanceof f.BinaryReader ? U : new f.BinaryReader(U);
      let h = V === void 0 ? o.len : o.pos + V;
      const N = y();
      for (; o.pos < h; ) {
        const q = o.uint32();
        switch (q >>> 3) {
          default:
            o.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(U) {
      return y();
    },
    toJSON(U) {
      return {};
    },
    fromPartial(U) {
      return y();
    }
  };
  function _() {
    return {
      params: void 0
    };
  }
  e.QueryConnectionParamsResponse = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionParamsResponse",
    encode(U, V = f.BinaryWriter.create()) {
      return U.params !== void 0 && t.Params.encode(U.params, V.uint32(10).fork()).ldelim(), V;
    },
    decode(U, V) {
      const o = U instanceof f.BinaryReader ? U : new f.BinaryReader(U);
      let h = V === void 0 ? o.len : o.pos + V;
      const N = _();
      for (; o.pos < h; ) {
        const q = o.uint32();
        switch (q >>> 3) {
          case 1:
            N.params = t.Params.decode(o, o.uint32());
            break;
          default:
            o.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(U) {
      const V = _();
      return (0, S.isSet)(U.params) && (V.params = t.Params.fromJSON(U.params)), V;
    },
    toJSON(U) {
      const V = {};
      return U.params !== void 0 && (V.params = U.params ? t.Params.toJSON(U.params) : void 0), V;
    },
    fromPartial(U) {
      const V = _();
      return U.params !== void 0 && U.params !== null && (V.params = t.Params.fromPartial(U.params)), V;
    }
  };
  class E {
    constructor(V) {
      this.rpc = V, this.Connection = this.Connection.bind(this), this.Connections = this.Connections.bind(this), this.ClientConnections = this.ClientConnections.bind(this), this.ConnectionClientState = this.ConnectionClientState.bind(this), this.ConnectionConsensusState = this.ConnectionConsensusState.bind(this), this.ConnectionParams = this.ConnectionParams.bind(this);
    }
    Connection(V) {
      const o = e.QueryConnectionRequest.encode(V).finish();
      return this.rpc.request("ibc.core.connection.v1.Query", "Connection", o).then((N) => e.QueryConnectionResponse.decode(new f.BinaryReader(N)));
    }
    Connections(V = {
      pagination: n.PageRequest.fromPartial({})
    }) {
      const o = e.QueryConnectionsRequest.encode(V).finish();
      return this.rpc.request("ibc.core.connection.v1.Query", "Connections", o).then((N) => e.QueryConnectionsResponse.decode(new f.BinaryReader(N)));
    }
    ClientConnections(V) {
      const o = e.QueryClientConnectionsRequest.encode(V).finish();
      return this.rpc.request("ibc.core.connection.v1.Query", "ClientConnections", o).then((N) => e.QueryClientConnectionsResponse.decode(new f.BinaryReader(N)));
    }
    ConnectionClientState(V) {
      const o = e.QueryConnectionClientStateRequest.encode(V).finish();
      return this.rpc.request("ibc.core.connection.v1.Query", "ConnectionClientState", o).then((N) => e.QueryConnectionClientStateResponse.decode(new f.BinaryReader(N)));
    }
    ConnectionConsensusState(V) {
      const o = e.QueryConnectionConsensusStateRequest.encode(V).finish();
      return this.rpc.request("ibc.core.connection.v1.Query", "ConnectionConsensusState", o).then((N) => e.QueryConnectionConsensusStateResponse.decode(new f.BinaryReader(N)));
    }
    ConnectionParams(V = {}) {
      const o = e.QueryConnectionParamsRequest.encode(V).finish();
      return this.rpc.request("ibc.core.connection.v1.Query", "ConnectionParams", o).then((N) => e.QueryConnectionParamsResponse.decode(new f.BinaryReader(N)));
    }
  }
  e.QueryClientImpl = E;
})(Wh);
var Qh = {}, ar = {}, Yc = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ProofOps = e.ProofOp = e.DominoOp = e.ValueOp = e.Proof = e.protobufPackage = void 0;
  const n = re, r = ie;
  e.protobufPackage = "tendermint.crypto";
  function t() {
    return {
      total: BigInt(0),
      index: BigInt(0),
      leafHash: new Uint8Array(),
      aunts: []
    };
  }
  e.Proof = {
    typeUrl: "/tendermint.crypto.Proof",
    encode(T, J = n.BinaryWriter.create()) {
      T.total !== BigInt(0) && J.uint32(8).int64(T.total), T.index !== BigInt(0) && J.uint32(16).int64(T.index), T.leafHash.length !== 0 && J.uint32(26).bytes(T.leafHash);
      for (const C of T.aunts)
        J.uint32(34).bytes(C);
      return J;
    },
    decode(T, J) {
      const C = T instanceof n.BinaryReader ? T : new n.BinaryReader(T);
      let R = J === void 0 ? C.len : C.pos + J;
      const p = t();
      for (; C.pos < R; ) {
        const m = C.uint32();
        switch (m >>> 3) {
          case 1:
            p.total = C.int64();
            break;
          case 2:
            p.index = C.int64();
            break;
          case 3:
            p.leafHash = C.bytes();
            break;
          case 4:
            p.aunts.push(C.bytes());
            break;
          default:
            C.skipType(m & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(T) {
      const J = t();
      return (0, r.isSet)(T.total) && (J.total = BigInt(T.total.toString())), (0, r.isSet)(T.index) && (J.index = BigInt(T.index.toString())), (0, r.isSet)(T.leafHash) && (J.leafHash = (0, r.bytesFromBase64)(T.leafHash)), Array.isArray(T == null ? void 0 : T.aunts) && (J.aunts = T.aunts.map((C) => (0, r.bytesFromBase64)(C))), J;
    },
    toJSON(T) {
      const J = {};
      return T.total !== void 0 && (J.total = (T.total || BigInt(0)).toString()), T.index !== void 0 && (J.index = (T.index || BigInt(0)).toString()), T.leafHash !== void 0 && (J.leafHash = (0, r.base64FromBytes)(T.leafHash !== void 0 ? T.leafHash : new Uint8Array())), T.aunts ? J.aunts = T.aunts.map((C) => (0, r.base64FromBytes)(C !== void 0 ? C : new Uint8Array())) : J.aunts = [], J;
    },
    fromPartial(T) {
      var C;
      const J = t();
      return T.total !== void 0 && T.total !== null && (J.total = BigInt(T.total.toString())), T.index !== void 0 && T.index !== null && (J.index = BigInt(T.index.toString())), J.leafHash = T.leafHash ?? new Uint8Array(), J.aunts = ((C = T.aunts) == null ? void 0 : C.map((R) => R)) || [], J;
    }
  };
  function i() {
    return {
      key: new Uint8Array(),
      proof: void 0
    };
  }
  e.ValueOp = {
    typeUrl: "/tendermint.crypto.ValueOp",
    encode(T, J = n.BinaryWriter.create()) {
      return T.key.length !== 0 && J.uint32(10).bytes(T.key), T.proof !== void 0 && e.Proof.encode(T.proof, J.uint32(18).fork()).ldelim(), J;
    },
    decode(T, J) {
      const C = T instanceof n.BinaryReader ? T : new n.BinaryReader(T);
      let R = J === void 0 ? C.len : C.pos + J;
      const p = i();
      for (; C.pos < R; ) {
        const m = C.uint32();
        switch (m >>> 3) {
          case 1:
            p.key = C.bytes();
            break;
          case 2:
            p.proof = e.Proof.decode(C, C.uint32());
            break;
          default:
            C.skipType(m & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(T) {
      const J = i();
      return (0, r.isSet)(T.key) && (J.key = (0, r.bytesFromBase64)(T.key)), (0, r.isSet)(T.proof) && (J.proof = e.Proof.fromJSON(T.proof)), J;
    },
    toJSON(T) {
      const J = {};
      return T.key !== void 0 && (J.key = (0, r.base64FromBytes)(T.key !== void 0 ? T.key : new Uint8Array())), T.proof !== void 0 && (J.proof = T.proof ? e.Proof.toJSON(T.proof) : void 0), J;
    },
    fromPartial(T) {
      const J = i();
      return J.key = T.key ?? new Uint8Array(), T.proof !== void 0 && T.proof !== null && (J.proof = e.Proof.fromPartial(T.proof)), J;
    }
  };
  function f() {
    return {
      key: "",
      input: "",
      output: ""
    };
  }
  e.DominoOp = {
    typeUrl: "/tendermint.crypto.DominoOp",
    encode(T, J = n.BinaryWriter.create()) {
      return T.key !== "" && J.uint32(10).string(T.key), T.input !== "" && J.uint32(18).string(T.input), T.output !== "" && J.uint32(26).string(T.output), J;
    },
    decode(T, J) {
      const C = T instanceof n.BinaryReader ? T : new n.BinaryReader(T);
      let R = J === void 0 ? C.len : C.pos + J;
      const p = f();
      for (; C.pos < R; ) {
        const m = C.uint32();
        switch (m >>> 3) {
          case 1:
            p.key = C.string();
            break;
          case 2:
            p.input = C.string();
            break;
          case 3:
            p.output = C.string();
            break;
          default:
            C.skipType(m & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(T) {
      const J = f();
      return (0, r.isSet)(T.key) && (J.key = String(T.key)), (0, r.isSet)(T.input) && (J.input = String(T.input)), (0, r.isSet)(T.output) && (J.output = String(T.output)), J;
    },
    toJSON(T) {
      const J = {};
      return T.key !== void 0 && (J.key = T.key), T.input !== void 0 && (J.input = T.input), T.output !== void 0 && (J.output = T.output), J;
    },
    fromPartial(T) {
      const J = f();
      return J.key = T.key ?? "", J.input = T.input ?? "", J.output = T.output ?? "", J;
    }
  };
  function S() {
    return {
      type: "",
      key: new Uint8Array(),
      data: new Uint8Array()
    };
  }
  e.ProofOp = {
    typeUrl: "/tendermint.crypto.ProofOp",
    encode(T, J = n.BinaryWriter.create()) {
      return T.type !== "" && J.uint32(10).string(T.type), T.key.length !== 0 && J.uint32(18).bytes(T.key), T.data.length !== 0 && J.uint32(26).bytes(T.data), J;
    },
    decode(T, J) {
      const C = T instanceof n.BinaryReader ? T : new n.BinaryReader(T);
      let R = J === void 0 ? C.len : C.pos + J;
      const p = S();
      for (; C.pos < R; ) {
        const m = C.uint32();
        switch (m >>> 3) {
          case 1:
            p.type = C.string();
            break;
          case 2:
            p.key = C.bytes();
            break;
          case 3:
            p.data = C.bytes();
            break;
          default:
            C.skipType(m & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(T) {
      const J = S();
      return (0, r.isSet)(T.type) && (J.type = String(T.type)), (0, r.isSet)(T.key) && (J.key = (0, r.bytesFromBase64)(T.key)), (0, r.isSet)(T.data) && (J.data = (0, r.bytesFromBase64)(T.data)), J;
    },
    toJSON(T) {
      const J = {};
      return T.type !== void 0 && (J.type = T.type), T.key !== void 0 && (J.key = (0, r.base64FromBytes)(T.key !== void 0 ? T.key : new Uint8Array())), T.data !== void 0 && (J.data = (0, r.base64FromBytes)(T.data !== void 0 ? T.data : new Uint8Array())), J;
    },
    fromPartial(T) {
      const J = S();
      return J.type = T.type ?? "", J.key = T.key ?? new Uint8Array(), J.data = T.data ?? new Uint8Array(), J;
    }
  };
  function w() {
    return {
      ops: []
    };
  }
  e.ProofOps = {
    typeUrl: "/tendermint.crypto.ProofOps",
    encode(T, J = n.BinaryWriter.create()) {
      for (const C of T.ops)
        e.ProofOp.encode(C, J.uint32(10).fork()).ldelim();
      return J;
    },
    decode(T, J) {
      const C = T instanceof n.BinaryReader ? T : new n.BinaryReader(T);
      let R = J === void 0 ? C.len : C.pos + J;
      const p = w();
      for (; C.pos < R; ) {
        const m = C.uint32();
        switch (m >>> 3) {
          case 1:
            p.ops.push(e.ProofOp.decode(C, C.uint32()));
            break;
          default:
            C.skipType(m & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(T) {
      const J = w();
      return Array.isArray(T == null ? void 0 : T.ops) && (J.ops = T.ops.map((C) => e.ProofOp.fromJSON(C))), J;
    },
    toJSON(T) {
      const J = {};
      return T.ops ? J.ops = T.ops.map((C) => C ? e.ProofOp.toJSON(C) : void 0) : J.ops = [], J;
    },
    fromPartial(T) {
      var C;
      const J = w();
      return J.ops = ((C = T.ops) == null ? void 0 : C.map((R) => e.ProofOp.fromPartial(R))) || [], J;
    }
  };
})(Yc);
var Et = {};
Object.defineProperty(Et, "__esModule", { value: !0 });
Et.Consensus = Et.App = Et.protobufPackage = void 0;
const Mr = re, wa = ie;
Et.protobufPackage = "tendermint.version";
function Su() {
  return {
    protocol: BigInt(0),
    software: ""
  };
}
Et.App = {
  typeUrl: "/tendermint.version.App",
  encode(e, n = Mr.BinaryWriter.create()) {
    return e.protocol !== BigInt(0) && n.uint32(8).uint64(e.protocol), e.software !== "" && n.uint32(18).string(e.software), n;
  },
  decode(e, n) {
    const r = e instanceof Mr.BinaryReader ? e : new Mr.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = Su();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.protocol = r.uint64();
          break;
        case 2:
          i.software = r.string();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = Su();
    return (0, wa.isSet)(e.protocol) && (n.protocol = BigInt(e.protocol.toString())), (0, wa.isSet)(e.software) && (n.software = String(e.software)), n;
  },
  toJSON(e) {
    const n = {};
    return e.protocol !== void 0 && (n.protocol = (e.protocol || BigInt(0)).toString()), e.software !== void 0 && (n.software = e.software), n;
  },
  fromPartial(e) {
    const n = Su();
    return e.protocol !== void 0 && e.protocol !== null && (n.protocol = BigInt(e.protocol.toString())), n.software = e.software ?? "", n;
  }
};
function ku() {
  return {
    block: BigInt(0),
    app: BigInt(0)
  };
}
Et.Consensus = {
  typeUrl: "/tendermint.version.Consensus",
  encode(e, n = Mr.BinaryWriter.create()) {
    return e.block !== BigInt(0) && n.uint32(8).uint64(e.block), e.app !== BigInt(0) && n.uint32(16).uint64(e.app), n;
  },
  decode(e, n) {
    const r = e instanceof Mr.BinaryReader ? e : new Mr.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = ku();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.block = r.uint64();
          break;
        case 2:
          i.app = r.uint64();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = ku();
    return (0, wa.isSet)(e.block) && (n.block = BigInt(e.block.toString())), (0, wa.isSet)(e.app) && (n.app = BigInt(e.app.toString())), n;
  },
  toJSON(e) {
    const n = {};
    return e.block !== void 0 && (n.block = (e.block || BigInt(0)).toString()), e.app !== void 0 && (n.app = (e.app || BigInt(0)).toString()), n;
  },
  fromPartial(e) {
    const n = ku();
    return e.block !== void 0 && e.block !== null && (n.block = BigInt(e.block.toString())), e.app !== void 0 && e.app !== null && (n.app = BigInt(e.app.toString())), n;
  }
};
var Cs = {}, or = {};
Object.defineProperty(or, "__esModule", { value: !0 });
or.PublicKey = or.protobufPackage = void 0;
const Pu = re, yr = ie;
or.protobufPackage = "tendermint.crypto";
function vu() {
  return {
    ed25519: void 0,
    secp256k1: void 0
  };
}
or.PublicKey = {
  typeUrl: "/tendermint.crypto.PublicKey",
  encode(e, n = Pu.BinaryWriter.create()) {
    return e.ed25519 !== void 0 && n.uint32(10).bytes(e.ed25519), e.secp256k1 !== void 0 && n.uint32(18).bytes(e.secp256k1), n;
  },
  decode(e, n) {
    const r = e instanceof Pu.BinaryReader ? e : new Pu.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = vu();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.ed25519 = r.bytes();
          break;
        case 2:
          i.secp256k1 = r.bytes();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = vu();
    return (0, yr.isSet)(e.ed25519) && (n.ed25519 = (0, yr.bytesFromBase64)(e.ed25519)), (0, yr.isSet)(e.secp256k1) && (n.secp256k1 = (0, yr.bytesFromBase64)(e.secp256k1)), n;
  },
  toJSON(e) {
    const n = {};
    return e.ed25519 !== void 0 && (n.ed25519 = e.ed25519 !== void 0 ? (0, yr.base64FromBytes)(e.ed25519) : void 0), e.secp256k1 !== void 0 && (n.secp256k1 = e.secp256k1 !== void 0 ? (0, yr.base64FromBytes)(e.secp256k1) : void 0), n;
  },
  fromPartial(e) {
    const n = vu();
    return n.ed25519 = e.ed25519 ?? void 0, n.secp256k1 = e.secp256k1 ?? void 0, n;
  }
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.SimpleValidator = e.Validator = e.ValidatorSet = e.protobufPackage = void 0;
  const n = or, r = re, t = ie;
  e.protobufPackage = "tendermint.types";
  function i() {
    return {
      validators: [],
      proposer: void 0,
      totalVotingPower: BigInt(0)
    };
  }
  e.ValidatorSet = {
    typeUrl: "/tendermint.types.ValidatorSet",
    encode(w, T = r.BinaryWriter.create()) {
      for (const J of w.validators)
        e.Validator.encode(J, T.uint32(10).fork()).ldelim();
      return w.proposer !== void 0 && e.Validator.encode(w.proposer, T.uint32(18).fork()).ldelim(), w.totalVotingPower !== BigInt(0) && T.uint32(24).int64(w.totalVotingPower), T;
    },
    decode(w, T) {
      const J = w instanceof r.BinaryReader ? w : new r.BinaryReader(w);
      let C = T === void 0 ? J.len : J.pos + T;
      const R = i();
      for (; J.pos < C; ) {
        const p = J.uint32();
        switch (p >>> 3) {
          case 1:
            R.validators.push(e.Validator.decode(J, J.uint32()));
            break;
          case 2:
            R.proposer = e.Validator.decode(J, J.uint32());
            break;
          case 3:
            R.totalVotingPower = J.int64();
            break;
          default:
            J.skipType(p & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(w) {
      const T = i();
      return Array.isArray(w == null ? void 0 : w.validators) && (T.validators = w.validators.map((J) => e.Validator.fromJSON(J))), (0, t.isSet)(w.proposer) && (T.proposer = e.Validator.fromJSON(w.proposer)), (0, t.isSet)(w.totalVotingPower) && (T.totalVotingPower = BigInt(w.totalVotingPower.toString())), T;
    },
    toJSON(w) {
      const T = {};
      return w.validators ? T.validators = w.validators.map((J) => J ? e.Validator.toJSON(J) : void 0) : T.validators = [], w.proposer !== void 0 && (T.proposer = w.proposer ? e.Validator.toJSON(w.proposer) : void 0), w.totalVotingPower !== void 0 && (T.totalVotingPower = (w.totalVotingPower || BigInt(0)).toString()), T;
    },
    fromPartial(w) {
      var J;
      const T = i();
      return T.validators = ((J = w.validators) == null ? void 0 : J.map((C) => e.Validator.fromPartial(C))) || [], w.proposer !== void 0 && w.proposer !== null && (T.proposer = e.Validator.fromPartial(w.proposer)), w.totalVotingPower !== void 0 && w.totalVotingPower !== null && (T.totalVotingPower = BigInt(w.totalVotingPower.toString())), T;
    }
  };
  function f() {
    return {
      address: new Uint8Array(),
      pubKey: n.PublicKey.fromPartial({}),
      votingPower: BigInt(0),
      proposerPriority: BigInt(0)
    };
  }
  e.Validator = {
    typeUrl: "/tendermint.types.Validator",
    encode(w, T = r.BinaryWriter.create()) {
      return w.address.length !== 0 && T.uint32(10).bytes(w.address), w.pubKey !== void 0 && n.PublicKey.encode(w.pubKey, T.uint32(18).fork()).ldelim(), w.votingPower !== BigInt(0) && T.uint32(24).int64(w.votingPower), w.proposerPriority !== BigInt(0) && T.uint32(32).int64(w.proposerPriority), T;
    },
    decode(w, T) {
      const J = w instanceof r.BinaryReader ? w : new r.BinaryReader(w);
      let C = T === void 0 ? J.len : J.pos + T;
      const R = f();
      for (; J.pos < C; ) {
        const p = J.uint32();
        switch (p >>> 3) {
          case 1:
            R.address = J.bytes();
            break;
          case 2:
            R.pubKey = n.PublicKey.decode(J, J.uint32());
            break;
          case 3:
            R.votingPower = J.int64();
            break;
          case 4:
            R.proposerPriority = J.int64();
            break;
          default:
            J.skipType(p & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(w) {
      const T = f();
      return (0, t.isSet)(w.address) && (T.address = (0, t.bytesFromBase64)(w.address)), (0, t.isSet)(w.pubKey) && (T.pubKey = n.PublicKey.fromJSON(w.pubKey)), (0, t.isSet)(w.votingPower) && (T.votingPower = BigInt(w.votingPower.toString())), (0, t.isSet)(w.proposerPriority) && (T.proposerPriority = BigInt(w.proposerPriority.toString())), T;
    },
    toJSON(w) {
      const T = {};
      return w.address !== void 0 && (T.address = (0, t.base64FromBytes)(w.address !== void 0 ? w.address : new Uint8Array())), w.pubKey !== void 0 && (T.pubKey = w.pubKey ? n.PublicKey.toJSON(w.pubKey) : void 0), w.votingPower !== void 0 && (T.votingPower = (w.votingPower || BigInt(0)).toString()), w.proposerPriority !== void 0 && (T.proposerPriority = (w.proposerPriority || BigInt(0)).toString()), T;
    },
    fromPartial(w) {
      const T = f();
      return T.address = w.address ?? new Uint8Array(), w.pubKey !== void 0 && w.pubKey !== null && (T.pubKey = n.PublicKey.fromPartial(w.pubKey)), w.votingPower !== void 0 && w.votingPower !== null && (T.votingPower = BigInt(w.votingPower.toString())), w.proposerPriority !== void 0 && w.proposerPriority !== null && (T.proposerPriority = BigInt(w.proposerPriority.toString())), T;
    }
  };
  function S() {
    return {
      pubKey: void 0,
      votingPower: BigInt(0)
    };
  }
  e.SimpleValidator = {
    typeUrl: "/tendermint.types.SimpleValidator",
    encode(w, T = r.BinaryWriter.create()) {
      return w.pubKey !== void 0 && n.PublicKey.encode(w.pubKey, T.uint32(10).fork()).ldelim(), w.votingPower !== BigInt(0) && T.uint32(16).int64(w.votingPower), T;
    },
    decode(w, T) {
      const J = w instanceof r.BinaryReader ? w : new r.BinaryReader(w);
      let C = T === void 0 ? J.len : J.pos + T;
      const R = S();
      for (; J.pos < C; ) {
        const p = J.uint32();
        switch (p >>> 3) {
          case 1:
            R.pubKey = n.PublicKey.decode(J, J.uint32());
            break;
          case 2:
            R.votingPower = J.int64();
            break;
          default:
            J.skipType(p & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(w) {
      const T = S();
      return (0, t.isSet)(w.pubKey) && (T.pubKey = n.PublicKey.fromJSON(w.pubKey)), (0, t.isSet)(w.votingPower) && (T.votingPower = BigInt(w.votingPower.toString())), T;
    },
    toJSON(w) {
      const T = {};
      return w.pubKey !== void 0 && (T.pubKey = w.pubKey ? n.PublicKey.toJSON(w.pubKey) : void 0), w.votingPower !== void 0 && (T.votingPower = (w.votingPower || BigInt(0)).toString()), T;
    },
    fromPartial(w) {
      const T = S();
      return w.pubKey !== void 0 && w.pubKey !== null && (T.pubKey = n.PublicKey.fromPartial(w.pubKey)), w.votingPower !== void 0 && w.votingPower !== null && (T.votingPower = BigInt(w.votingPower.toString())), T;
    }
  };
})(Cs);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.TxProof = e.BlockMeta = e.LightBlock = e.SignedHeader = e.Proposal = e.CommitSig = e.Commit = e.Vote = e.Data = e.Header = e.BlockID = e.Part = e.PartSetHeader = e.signedMsgTypeToJSON = e.signedMsgTypeFromJSON = e.SignedMsgType = e.blockIDFlagToJSON = e.blockIDFlagFromJSON = e.BlockIDFlag = e.protobufPackage = void 0;
  const n = Yc, r = Et, t = Je, i = Cs, f = re, S = ie;
  e.protobufPackage = "tendermint.types";
  var w;
  (function(u) {
    u[u.BLOCK_ID_FLAG_UNKNOWN = 0] = "BLOCK_ID_FLAG_UNKNOWN", u[u.BLOCK_ID_FLAG_ABSENT = 1] = "BLOCK_ID_FLAG_ABSENT", u[u.BLOCK_ID_FLAG_COMMIT = 2] = "BLOCK_ID_FLAG_COMMIT", u[u.BLOCK_ID_FLAG_NIL = 3] = "BLOCK_ID_FLAG_NIL", u[u.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(w || (e.BlockIDFlag = w = {}));
  function T(u) {
    switch (u) {
      case 0:
      case "BLOCK_ID_FLAG_UNKNOWN":
        return w.BLOCK_ID_FLAG_UNKNOWN;
      case 1:
      case "BLOCK_ID_FLAG_ABSENT":
        return w.BLOCK_ID_FLAG_ABSENT;
      case 2:
      case "BLOCK_ID_FLAG_COMMIT":
        return w.BLOCK_ID_FLAG_COMMIT;
      case 3:
      case "BLOCK_ID_FLAG_NIL":
        return w.BLOCK_ID_FLAG_NIL;
      case -1:
      case "UNRECOGNIZED":
      default:
        return w.UNRECOGNIZED;
    }
  }
  e.blockIDFlagFromJSON = T;
  function J(u) {
    switch (u) {
      case w.BLOCK_ID_FLAG_UNKNOWN:
        return "BLOCK_ID_FLAG_UNKNOWN";
      case w.BLOCK_ID_FLAG_ABSENT:
        return "BLOCK_ID_FLAG_ABSENT";
      case w.BLOCK_ID_FLAG_COMMIT:
        return "BLOCK_ID_FLAG_COMMIT";
      case w.BLOCK_ID_FLAG_NIL:
        return "BLOCK_ID_FLAG_NIL";
      case w.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.blockIDFlagToJSON = J;
  var C;
  (function(u) {
    u[u.SIGNED_MSG_TYPE_UNKNOWN = 0] = "SIGNED_MSG_TYPE_UNKNOWN", u[u.SIGNED_MSG_TYPE_PREVOTE = 1] = "SIGNED_MSG_TYPE_PREVOTE", u[u.SIGNED_MSG_TYPE_PRECOMMIT = 2] = "SIGNED_MSG_TYPE_PRECOMMIT", u[u.SIGNED_MSG_TYPE_PROPOSAL = 32] = "SIGNED_MSG_TYPE_PROPOSAL", u[u.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(C || (e.SignedMsgType = C = {}));
  function R(u) {
    switch (u) {
      case 0:
      case "SIGNED_MSG_TYPE_UNKNOWN":
        return C.SIGNED_MSG_TYPE_UNKNOWN;
      case 1:
      case "SIGNED_MSG_TYPE_PREVOTE":
        return C.SIGNED_MSG_TYPE_PREVOTE;
      case 2:
      case "SIGNED_MSG_TYPE_PRECOMMIT":
        return C.SIGNED_MSG_TYPE_PRECOMMIT;
      case 32:
      case "SIGNED_MSG_TYPE_PROPOSAL":
        return C.SIGNED_MSG_TYPE_PROPOSAL;
      case -1:
      case "UNRECOGNIZED":
      default:
        return C.UNRECOGNIZED;
    }
  }
  e.signedMsgTypeFromJSON = R;
  function p(u) {
    switch (u) {
      case C.SIGNED_MSG_TYPE_UNKNOWN:
        return "SIGNED_MSG_TYPE_UNKNOWN";
      case C.SIGNED_MSG_TYPE_PREVOTE:
        return "SIGNED_MSG_TYPE_PREVOTE";
      case C.SIGNED_MSG_TYPE_PRECOMMIT:
        return "SIGNED_MSG_TYPE_PRECOMMIT";
      case C.SIGNED_MSG_TYPE_PROPOSAL:
        return "SIGNED_MSG_TYPE_PROPOSAL";
      case C.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.signedMsgTypeToJSON = p;
  function m() {
    return {
      total: 0,
      hash: new Uint8Array()
    };
  }
  e.PartSetHeader = {
    typeUrl: "/tendermint.types.PartSetHeader",
    encode(u, l = f.BinaryWriter.create()) {
      return u.total !== 0 && l.uint32(8).uint32(u.total), u.hash.length !== 0 && l.uint32(18).bytes(u.hash), l;
    },
    decode(u, l) {
      const I = u instanceof f.BinaryReader ? u : new f.BinaryReader(u);
      let B = l === void 0 ? I.len : I.pos + l;
      const b = m();
      for (; I.pos < B; ) {
        const D = I.uint32();
        switch (D >>> 3) {
          case 1:
            b.total = I.uint32();
            break;
          case 2:
            b.hash = I.bytes();
            break;
          default:
            I.skipType(D & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(u) {
      const l = m();
      return (0, S.isSet)(u.total) && (l.total = Number(u.total)), (0, S.isSet)(u.hash) && (l.hash = (0, S.bytesFromBase64)(u.hash)), l;
    },
    toJSON(u) {
      const l = {};
      return u.total !== void 0 && (l.total = Math.round(u.total)), u.hash !== void 0 && (l.hash = (0, S.base64FromBytes)(u.hash !== void 0 ? u.hash : new Uint8Array())), l;
    },
    fromPartial(u) {
      const l = m();
      return l.total = u.total ?? 0, l.hash = u.hash ?? new Uint8Array(), l;
    }
  };
  function v() {
    return {
      index: 0,
      bytes: new Uint8Array(),
      proof: n.Proof.fromPartial({})
    };
  }
  e.Part = {
    typeUrl: "/tendermint.types.Part",
    encode(u, l = f.BinaryWriter.create()) {
      return u.index !== 0 && l.uint32(8).uint32(u.index), u.bytes.length !== 0 && l.uint32(18).bytes(u.bytes), u.proof !== void 0 && n.Proof.encode(u.proof, l.uint32(26).fork()).ldelim(), l;
    },
    decode(u, l) {
      const I = u instanceof f.BinaryReader ? u : new f.BinaryReader(u);
      let B = l === void 0 ? I.len : I.pos + l;
      const b = v();
      for (; I.pos < B; ) {
        const D = I.uint32();
        switch (D >>> 3) {
          case 1:
            b.index = I.uint32();
            break;
          case 2:
            b.bytes = I.bytes();
            break;
          case 3:
            b.proof = n.Proof.decode(I, I.uint32());
            break;
          default:
            I.skipType(D & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(u) {
      const l = v();
      return (0, S.isSet)(u.index) && (l.index = Number(u.index)), (0, S.isSet)(u.bytes) && (l.bytes = (0, S.bytesFromBase64)(u.bytes)), (0, S.isSet)(u.proof) && (l.proof = n.Proof.fromJSON(u.proof)), l;
    },
    toJSON(u) {
      const l = {};
      return u.index !== void 0 && (l.index = Math.round(u.index)), u.bytes !== void 0 && (l.bytes = (0, S.base64FromBytes)(u.bytes !== void 0 ? u.bytes : new Uint8Array())), u.proof !== void 0 && (l.proof = u.proof ? n.Proof.toJSON(u.proof) : void 0), l;
    },
    fromPartial(u) {
      const l = v();
      return l.index = u.index ?? 0, l.bytes = u.bytes ?? new Uint8Array(), u.proof !== void 0 && u.proof !== null && (l.proof = n.Proof.fromPartial(u.proof)), l;
    }
  };
  function a() {
    return {
      hash: new Uint8Array(),
      partSetHeader: e.PartSetHeader.fromPartial({})
    };
  }
  e.BlockID = {
    typeUrl: "/tendermint.types.BlockID",
    encode(u, l = f.BinaryWriter.create()) {
      return u.hash.length !== 0 && l.uint32(10).bytes(u.hash), u.partSetHeader !== void 0 && e.PartSetHeader.encode(u.partSetHeader, l.uint32(18).fork()).ldelim(), l;
    },
    decode(u, l) {
      const I = u instanceof f.BinaryReader ? u : new f.BinaryReader(u);
      let B = l === void 0 ? I.len : I.pos + l;
      const b = a();
      for (; I.pos < B; ) {
        const D = I.uint32();
        switch (D >>> 3) {
          case 1:
            b.hash = I.bytes();
            break;
          case 2:
            b.partSetHeader = e.PartSetHeader.decode(I, I.uint32());
            break;
          default:
            I.skipType(D & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(u) {
      const l = a();
      return (0, S.isSet)(u.hash) && (l.hash = (0, S.bytesFromBase64)(u.hash)), (0, S.isSet)(u.partSetHeader) && (l.partSetHeader = e.PartSetHeader.fromJSON(u.partSetHeader)), l;
    },
    toJSON(u) {
      const l = {};
      return u.hash !== void 0 && (l.hash = (0, S.base64FromBytes)(u.hash !== void 0 ? u.hash : new Uint8Array())), u.partSetHeader !== void 0 && (l.partSetHeader = u.partSetHeader ? e.PartSetHeader.toJSON(u.partSetHeader) : void 0), l;
    },
    fromPartial(u) {
      const l = a();
      return l.hash = u.hash ?? new Uint8Array(), u.partSetHeader !== void 0 && u.partSetHeader !== null && (l.partSetHeader = e.PartSetHeader.fromPartial(u.partSetHeader)), l;
    }
  };
  function d() {
    return {
      version: r.Consensus.fromPartial({}),
      chainId: "",
      height: BigInt(0),
      time: t.Timestamp.fromPartial({}),
      lastBlockId: e.BlockID.fromPartial({}),
      lastCommitHash: new Uint8Array(),
      dataHash: new Uint8Array(),
      validatorsHash: new Uint8Array(),
      nextValidatorsHash: new Uint8Array(),
      consensusHash: new Uint8Array(),
      appHash: new Uint8Array(),
      lastResultsHash: new Uint8Array(),
      evidenceHash: new Uint8Array(),
      proposerAddress: new Uint8Array()
    };
  }
  e.Header = {
    typeUrl: "/tendermint.types.Header",
    encode(u, l = f.BinaryWriter.create()) {
      return u.version !== void 0 && r.Consensus.encode(u.version, l.uint32(10).fork()).ldelim(), u.chainId !== "" && l.uint32(18).string(u.chainId), u.height !== BigInt(0) && l.uint32(24).int64(u.height), u.time !== void 0 && t.Timestamp.encode(u.time, l.uint32(34).fork()).ldelim(), u.lastBlockId !== void 0 && e.BlockID.encode(u.lastBlockId, l.uint32(42).fork()).ldelim(), u.lastCommitHash.length !== 0 && l.uint32(50).bytes(u.lastCommitHash), u.dataHash.length !== 0 && l.uint32(58).bytes(u.dataHash), u.validatorsHash.length !== 0 && l.uint32(66).bytes(u.validatorsHash), u.nextValidatorsHash.length !== 0 && l.uint32(74).bytes(u.nextValidatorsHash), u.consensusHash.length !== 0 && l.uint32(82).bytes(u.consensusHash), u.appHash.length !== 0 && l.uint32(90).bytes(u.appHash), u.lastResultsHash.length !== 0 && l.uint32(98).bytes(u.lastResultsHash), u.evidenceHash.length !== 0 && l.uint32(106).bytes(u.evidenceHash), u.proposerAddress.length !== 0 && l.uint32(114).bytes(u.proposerAddress), l;
    },
    decode(u, l) {
      const I = u instanceof f.BinaryReader ? u : new f.BinaryReader(u);
      let B = l === void 0 ? I.len : I.pos + l;
      const b = d();
      for (; I.pos < B; ) {
        const D = I.uint32();
        switch (D >>> 3) {
          case 1:
            b.version = r.Consensus.decode(I, I.uint32());
            break;
          case 2:
            b.chainId = I.string();
            break;
          case 3:
            b.height = I.int64();
            break;
          case 4:
            b.time = t.Timestamp.decode(I, I.uint32());
            break;
          case 5:
            b.lastBlockId = e.BlockID.decode(I, I.uint32());
            break;
          case 6:
            b.lastCommitHash = I.bytes();
            break;
          case 7:
            b.dataHash = I.bytes();
            break;
          case 8:
            b.validatorsHash = I.bytes();
            break;
          case 9:
            b.nextValidatorsHash = I.bytes();
            break;
          case 10:
            b.consensusHash = I.bytes();
            break;
          case 11:
            b.appHash = I.bytes();
            break;
          case 12:
            b.lastResultsHash = I.bytes();
            break;
          case 13:
            b.evidenceHash = I.bytes();
            break;
          case 14:
            b.proposerAddress = I.bytes();
            break;
          default:
            I.skipType(D & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(u) {
      const l = d();
      return (0, S.isSet)(u.version) && (l.version = r.Consensus.fromJSON(u.version)), (0, S.isSet)(u.chainId) && (l.chainId = String(u.chainId)), (0, S.isSet)(u.height) && (l.height = BigInt(u.height.toString())), (0, S.isSet)(u.time) && (l.time = (0, S.fromJsonTimestamp)(u.time)), (0, S.isSet)(u.lastBlockId) && (l.lastBlockId = e.BlockID.fromJSON(u.lastBlockId)), (0, S.isSet)(u.lastCommitHash) && (l.lastCommitHash = (0, S.bytesFromBase64)(u.lastCommitHash)), (0, S.isSet)(u.dataHash) && (l.dataHash = (0, S.bytesFromBase64)(u.dataHash)), (0, S.isSet)(u.validatorsHash) && (l.validatorsHash = (0, S.bytesFromBase64)(u.validatorsHash)), (0, S.isSet)(u.nextValidatorsHash) && (l.nextValidatorsHash = (0, S.bytesFromBase64)(u.nextValidatorsHash)), (0, S.isSet)(u.consensusHash) && (l.consensusHash = (0, S.bytesFromBase64)(u.consensusHash)), (0, S.isSet)(u.appHash) && (l.appHash = (0, S.bytesFromBase64)(u.appHash)), (0, S.isSet)(u.lastResultsHash) && (l.lastResultsHash = (0, S.bytesFromBase64)(u.lastResultsHash)), (0, S.isSet)(u.evidenceHash) && (l.evidenceHash = (0, S.bytesFromBase64)(u.evidenceHash)), (0, S.isSet)(u.proposerAddress) && (l.proposerAddress = (0, S.bytesFromBase64)(u.proposerAddress)), l;
    },
    toJSON(u) {
      const l = {};
      return u.version !== void 0 && (l.version = u.version ? r.Consensus.toJSON(u.version) : void 0), u.chainId !== void 0 && (l.chainId = u.chainId), u.height !== void 0 && (l.height = (u.height || BigInt(0)).toString()), u.time !== void 0 && (l.time = (0, S.fromTimestamp)(u.time).toISOString()), u.lastBlockId !== void 0 && (l.lastBlockId = u.lastBlockId ? e.BlockID.toJSON(u.lastBlockId) : void 0), u.lastCommitHash !== void 0 && (l.lastCommitHash = (0, S.base64FromBytes)(u.lastCommitHash !== void 0 ? u.lastCommitHash : new Uint8Array())), u.dataHash !== void 0 && (l.dataHash = (0, S.base64FromBytes)(u.dataHash !== void 0 ? u.dataHash : new Uint8Array())), u.validatorsHash !== void 0 && (l.validatorsHash = (0, S.base64FromBytes)(u.validatorsHash !== void 0 ? u.validatorsHash : new Uint8Array())), u.nextValidatorsHash !== void 0 && (l.nextValidatorsHash = (0, S.base64FromBytes)(u.nextValidatorsHash !== void 0 ? u.nextValidatorsHash : new Uint8Array())), u.consensusHash !== void 0 && (l.consensusHash = (0, S.base64FromBytes)(u.consensusHash !== void 0 ? u.consensusHash : new Uint8Array())), u.appHash !== void 0 && (l.appHash = (0, S.base64FromBytes)(u.appHash !== void 0 ? u.appHash : new Uint8Array())), u.lastResultsHash !== void 0 && (l.lastResultsHash = (0, S.base64FromBytes)(u.lastResultsHash !== void 0 ? u.lastResultsHash : new Uint8Array())), u.evidenceHash !== void 0 && (l.evidenceHash = (0, S.base64FromBytes)(u.evidenceHash !== void 0 ? u.evidenceHash : new Uint8Array())), u.proposerAddress !== void 0 && (l.proposerAddress = (0, S.base64FromBytes)(u.proposerAddress !== void 0 ? u.proposerAddress : new Uint8Array())), l;
    },
    fromPartial(u) {
      const l = d();
      return u.version !== void 0 && u.version !== null && (l.version = r.Consensus.fromPartial(u.version)), l.chainId = u.chainId ?? "", u.height !== void 0 && u.height !== null && (l.height = BigInt(u.height.toString())), u.time !== void 0 && u.time !== null && (l.time = t.Timestamp.fromPartial(u.time)), u.lastBlockId !== void 0 && u.lastBlockId !== null && (l.lastBlockId = e.BlockID.fromPartial(u.lastBlockId)), l.lastCommitHash = u.lastCommitHash ?? new Uint8Array(), l.dataHash = u.dataHash ?? new Uint8Array(), l.validatorsHash = u.validatorsHash ?? new Uint8Array(), l.nextValidatorsHash = u.nextValidatorsHash ?? new Uint8Array(), l.consensusHash = u.consensusHash ?? new Uint8Array(), l.appHash = u.appHash ?? new Uint8Array(), l.lastResultsHash = u.lastResultsHash ?? new Uint8Array(), l.evidenceHash = u.evidenceHash ?? new Uint8Array(), l.proposerAddress = u.proposerAddress ?? new Uint8Array(), l;
    }
  };
  function y() {
    return {
      txs: []
    };
  }
  e.Data = {
    typeUrl: "/tendermint.types.Data",
    encode(u, l = f.BinaryWriter.create()) {
      for (const I of u.txs)
        l.uint32(10).bytes(I);
      return l;
    },
    decode(u, l) {
      const I = u instanceof f.BinaryReader ? u : new f.BinaryReader(u);
      let B = l === void 0 ? I.len : I.pos + l;
      const b = y();
      for (; I.pos < B; ) {
        const D = I.uint32();
        switch (D >>> 3) {
          case 1:
            b.txs.push(I.bytes());
            break;
          default:
            I.skipType(D & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(u) {
      const l = y();
      return Array.isArray(u == null ? void 0 : u.txs) && (l.txs = u.txs.map((I) => (0, S.bytesFromBase64)(I))), l;
    },
    toJSON(u) {
      const l = {};
      return u.txs ? l.txs = u.txs.map((I) => (0, S.base64FromBytes)(I !== void 0 ? I : new Uint8Array())) : l.txs = [], l;
    },
    fromPartial(u) {
      var I;
      const l = y();
      return l.txs = ((I = u.txs) == null ? void 0 : I.map((B) => B)) || [], l;
    }
  };
  function _() {
    return {
      type: 0,
      height: BigInt(0),
      round: 0,
      blockId: e.BlockID.fromPartial({}),
      timestamp: t.Timestamp.fromPartial({}),
      validatorAddress: new Uint8Array(),
      validatorIndex: 0,
      signature: new Uint8Array()
    };
  }
  e.Vote = {
    typeUrl: "/tendermint.types.Vote",
    encode(u, l = f.BinaryWriter.create()) {
      return u.type !== 0 && l.uint32(8).int32(u.type), u.height !== BigInt(0) && l.uint32(16).int64(u.height), u.round !== 0 && l.uint32(24).int32(u.round), u.blockId !== void 0 && e.BlockID.encode(u.blockId, l.uint32(34).fork()).ldelim(), u.timestamp !== void 0 && t.Timestamp.encode(u.timestamp, l.uint32(42).fork()).ldelim(), u.validatorAddress.length !== 0 && l.uint32(50).bytes(u.validatorAddress), u.validatorIndex !== 0 && l.uint32(56).int32(u.validatorIndex), u.signature.length !== 0 && l.uint32(66).bytes(u.signature), l;
    },
    decode(u, l) {
      const I = u instanceof f.BinaryReader ? u : new f.BinaryReader(u);
      let B = l === void 0 ? I.len : I.pos + l;
      const b = _();
      for (; I.pos < B; ) {
        const D = I.uint32();
        switch (D >>> 3) {
          case 1:
            b.type = I.int32();
            break;
          case 2:
            b.height = I.int64();
            break;
          case 3:
            b.round = I.int32();
            break;
          case 4:
            b.blockId = e.BlockID.decode(I, I.uint32());
            break;
          case 5:
            b.timestamp = t.Timestamp.decode(I, I.uint32());
            break;
          case 6:
            b.validatorAddress = I.bytes();
            break;
          case 7:
            b.validatorIndex = I.int32();
            break;
          case 8:
            b.signature = I.bytes();
            break;
          default:
            I.skipType(D & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(u) {
      const l = _();
      return (0, S.isSet)(u.type) && (l.type = R(u.type)), (0, S.isSet)(u.height) && (l.height = BigInt(u.height.toString())), (0, S.isSet)(u.round) && (l.round = Number(u.round)), (0, S.isSet)(u.blockId) && (l.blockId = e.BlockID.fromJSON(u.blockId)), (0, S.isSet)(u.timestamp) && (l.timestamp = (0, S.fromJsonTimestamp)(u.timestamp)), (0, S.isSet)(u.validatorAddress) && (l.validatorAddress = (0, S.bytesFromBase64)(u.validatorAddress)), (0, S.isSet)(u.validatorIndex) && (l.validatorIndex = Number(u.validatorIndex)), (0, S.isSet)(u.signature) && (l.signature = (0, S.bytesFromBase64)(u.signature)), l;
    },
    toJSON(u) {
      const l = {};
      return u.type !== void 0 && (l.type = p(u.type)), u.height !== void 0 && (l.height = (u.height || BigInt(0)).toString()), u.round !== void 0 && (l.round = Math.round(u.round)), u.blockId !== void 0 && (l.blockId = u.blockId ? e.BlockID.toJSON(u.blockId) : void 0), u.timestamp !== void 0 && (l.timestamp = (0, S.fromTimestamp)(u.timestamp).toISOString()), u.validatorAddress !== void 0 && (l.validatorAddress = (0, S.base64FromBytes)(u.validatorAddress !== void 0 ? u.validatorAddress : new Uint8Array())), u.validatorIndex !== void 0 && (l.validatorIndex = Math.round(u.validatorIndex)), u.signature !== void 0 && (l.signature = (0, S.base64FromBytes)(u.signature !== void 0 ? u.signature : new Uint8Array())), l;
    },
    fromPartial(u) {
      const l = _();
      return l.type = u.type ?? 0, u.height !== void 0 && u.height !== null && (l.height = BigInt(u.height.toString())), l.round = u.round ?? 0, u.blockId !== void 0 && u.blockId !== null && (l.blockId = e.BlockID.fromPartial(u.blockId)), u.timestamp !== void 0 && u.timestamp !== null && (l.timestamp = t.Timestamp.fromPartial(u.timestamp)), l.validatorAddress = u.validatorAddress ?? new Uint8Array(), l.validatorIndex = u.validatorIndex ?? 0, l.signature = u.signature ?? new Uint8Array(), l;
    }
  };
  function E() {
    return {
      height: BigInt(0),
      round: 0,
      blockId: e.BlockID.fromPartial({}),
      signatures: []
    };
  }
  e.Commit = {
    typeUrl: "/tendermint.types.Commit",
    encode(u, l = f.BinaryWriter.create()) {
      u.height !== BigInt(0) && l.uint32(8).int64(u.height), u.round !== 0 && l.uint32(16).int32(u.round), u.blockId !== void 0 && e.BlockID.encode(u.blockId, l.uint32(26).fork()).ldelim();
      for (const I of u.signatures)
        e.CommitSig.encode(I, l.uint32(34).fork()).ldelim();
      return l;
    },
    decode(u, l) {
      const I = u instanceof f.BinaryReader ? u : new f.BinaryReader(u);
      let B = l === void 0 ? I.len : I.pos + l;
      const b = E();
      for (; I.pos < B; ) {
        const D = I.uint32();
        switch (D >>> 3) {
          case 1:
            b.height = I.int64();
            break;
          case 2:
            b.round = I.int32();
            break;
          case 3:
            b.blockId = e.BlockID.decode(I, I.uint32());
            break;
          case 4:
            b.signatures.push(e.CommitSig.decode(I, I.uint32()));
            break;
          default:
            I.skipType(D & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(u) {
      const l = E();
      return (0, S.isSet)(u.height) && (l.height = BigInt(u.height.toString())), (0, S.isSet)(u.round) && (l.round = Number(u.round)), (0, S.isSet)(u.blockId) && (l.blockId = e.BlockID.fromJSON(u.blockId)), Array.isArray(u == null ? void 0 : u.signatures) && (l.signatures = u.signatures.map((I) => e.CommitSig.fromJSON(I))), l;
    },
    toJSON(u) {
      const l = {};
      return u.height !== void 0 && (l.height = (u.height || BigInt(0)).toString()), u.round !== void 0 && (l.round = Math.round(u.round)), u.blockId !== void 0 && (l.blockId = u.blockId ? e.BlockID.toJSON(u.blockId) : void 0), u.signatures ? l.signatures = u.signatures.map((I) => I ? e.CommitSig.toJSON(I) : void 0) : l.signatures = [], l;
    },
    fromPartial(u) {
      var I;
      const l = E();
      return u.height !== void 0 && u.height !== null && (l.height = BigInt(u.height.toString())), l.round = u.round ?? 0, u.blockId !== void 0 && u.blockId !== null && (l.blockId = e.BlockID.fromPartial(u.blockId)), l.signatures = ((I = u.signatures) == null ? void 0 : I.map((B) => e.CommitSig.fromPartial(B))) || [], l;
    }
  };
  function U() {
    return {
      blockIdFlag: 0,
      validatorAddress: new Uint8Array(),
      timestamp: t.Timestamp.fromPartial({}),
      signature: new Uint8Array()
    };
  }
  e.CommitSig = {
    typeUrl: "/tendermint.types.CommitSig",
    encode(u, l = f.BinaryWriter.create()) {
      return u.blockIdFlag !== 0 && l.uint32(8).int32(u.blockIdFlag), u.validatorAddress.length !== 0 && l.uint32(18).bytes(u.validatorAddress), u.timestamp !== void 0 && t.Timestamp.encode(u.timestamp, l.uint32(26).fork()).ldelim(), u.signature.length !== 0 && l.uint32(34).bytes(u.signature), l;
    },
    decode(u, l) {
      const I = u instanceof f.BinaryReader ? u : new f.BinaryReader(u);
      let B = l === void 0 ? I.len : I.pos + l;
      const b = U();
      for (; I.pos < B; ) {
        const D = I.uint32();
        switch (D >>> 3) {
          case 1:
            b.blockIdFlag = I.int32();
            break;
          case 2:
            b.validatorAddress = I.bytes();
            break;
          case 3:
            b.timestamp = t.Timestamp.decode(I, I.uint32());
            break;
          case 4:
            b.signature = I.bytes();
            break;
          default:
            I.skipType(D & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(u) {
      const l = U();
      return (0, S.isSet)(u.blockIdFlag) && (l.blockIdFlag = T(u.blockIdFlag)), (0, S.isSet)(u.validatorAddress) && (l.validatorAddress = (0, S.bytesFromBase64)(u.validatorAddress)), (0, S.isSet)(u.timestamp) && (l.timestamp = (0, S.fromJsonTimestamp)(u.timestamp)), (0, S.isSet)(u.signature) && (l.signature = (0, S.bytesFromBase64)(u.signature)), l;
    },
    toJSON(u) {
      const l = {};
      return u.blockIdFlag !== void 0 && (l.blockIdFlag = J(u.blockIdFlag)), u.validatorAddress !== void 0 && (l.validatorAddress = (0, S.base64FromBytes)(u.validatorAddress !== void 0 ? u.validatorAddress : new Uint8Array())), u.timestamp !== void 0 && (l.timestamp = (0, S.fromTimestamp)(u.timestamp).toISOString()), u.signature !== void 0 && (l.signature = (0, S.base64FromBytes)(u.signature !== void 0 ? u.signature : new Uint8Array())), l;
    },
    fromPartial(u) {
      const l = U();
      return l.blockIdFlag = u.blockIdFlag ?? 0, l.validatorAddress = u.validatorAddress ?? new Uint8Array(), u.timestamp !== void 0 && u.timestamp !== null && (l.timestamp = t.Timestamp.fromPartial(u.timestamp)), l.signature = u.signature ?? new Uint8Array(), l;
    }
  };
  function V() {
    return {
      type: 0,
      height: BigInt(0),
      round: 0,
      polRound: 0,
      blockId: e.BlockID.fromPartial({}),
      timestamp: t.Timestamp.fromPartial({}),
      signature: new Uint8Array()
    };
  }
  e.Proposal = {
    typeUrl: "/tendermint.types.Proposal",
    encode(u, l = f.BinaryWriter.create()) {
      return u.type !== 0 && l.uint32(8).int32(u.type), u.height !== BigInt(0) && l.uint32(16).int64(u.height), u.round !== 0 && l.uint32(24).int32(u.round), u.polRound !== 0 && l.uint32(32).int32(u.polRound), u.blockId !== void 0 && e.BlockID.encode(u.blockId, l.uint32(42).fork()).ldelim(), u.timestamp !== void 0 && t.Timestamp.encode(u.timestamp, l.uint32(50).fork()).ldelim(), u.signature.length !== 0 && l.uint32(58).bytes(u.signature), l;
    },
    decode(u, l) {
      const I = u instanceof f.BinaryReader ? u : new f.BinaryReader(u);
      let B = l === void 0 ? I.len : I.pos + l;
      const b = V();
      for (; I.pos < B; ) {
        const D = I.uint32();
        switch (D >>> 3) {
          case 1:
            b.type = I.int32();
            break;
          case 2:
            b.height = I.int64();
            break;
          case 3:
            b.round = I.int32();
            break;
          case 4:
            b.polRound = I.int32();
            break;
          case 5:
            b.blockId = e.BlockID.decode(I, I.uint32());
            break;
          case 6:
            b.timestamp = t.Timestamp.decode(I, I.uint32());
            break;
          case 7:
            b.signature = I.bytes();
            break;
          default:
            I.skipType(D & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(u) {
      const l = V();
      return (0, S.isSet)(u.type) && (l.type = R(u.type)), (0, S.isSet)(u.height) && (l.height = BigInt(u.height.toString())), (0, S.isSet)(u.round) && (l.round = Number(u.round)), (0, S.isSet)(u.polRound) && (l.polRound = Number(u.polRound)), (0, S.isSet)(u.blockId) && (l.blockId = e.BlockID.fromJSON(u.blockId)), (0, S.isSet)(u.timestamp) && (l.timestamp = (0, S.fromJsonTimestamp)(u.timestamp)), (0, S.isSet)(u.signature) && (l.signature = (0, S.bytesFromBase64)(u.signature)), l;
    },
    toJSON(u) {
      const l = {};
      return u.type !== void 0 && (l.type = p(u.type)), u.height !== void 0 && (l.height = (u.height || BigInt(0)).toString()), u.round !== void 0 && (l.round = Math.round(u.round)), u.polRound !== void 0 && (l.polRound = Math.round(u.polRound)), u.blockId !== void 0 && (l.blockId = u.blockId ? e.BlockID.toJSON(u.blockId) : void 0), u.timestamp !== void 0 && (l.timestamp = (0, S.fromTimestamp)(u.timestamp).toISOString()), u.signature !== void 0 && (l.signature = (0, S.base64FromBytes)(u.signature !== void 0 ? u.signature : new Uint8Array())), l;
    },
    fromPartial(u) {
      const l = V();
      return l.type = u.type ?? 0, u.height !== void 0 && u.height !== null && (l.height = BigInt(u.height.toString())), l.round = u.round ?? 0, l.polRound = u.polRound ?? 0, u.blockId !== void 0 && u.blockId !== null && (l.blockId = e.BlockID.fromPartial(u.blockId)), u.timestamp !== void 0 && u.timestamp !== null && (l.timestamp = t.Timestamp.fromPartial(u.timestamp)), l.signature = u.signature ?? new Uint8Array(), l;
    }
  };
  function o() {
    return {
      header: void 0,
      commit: void 0
    };
  }
  e.SignedHeader = {
    typeUrl: "/tendermint.types.SignedHeader",
    encode(u, l = f.BinaryWriter.create()) {
      return u.header !== void 0 && e.Header.encode(u.header, l.uint32(10).fork()).ldelim(), u.commit !== void 0 && e.Commit.encode(u.commit, l.uint32(18).fork()).ldelim(), l;
    },
    decode(u, l) {
      const I = u instanceof f.BinaryReader ? u : new f.BinaryReader(u);
      let B = l === void 0 ? I.len : I.pos + l;
      const b = o();
      for (; I.pos < B; ) {
        const D = I.uint32();
        switch (D >>> 3) {
          case 1:
            b.header = e.Header.decode(I, I.uint32());
            break;
          case 2:
            b.commit = e.Commit.decode(I, I.uint32());
            break;
          default:
            I.skipType(D & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(u) {
      const l = o();
      return (0, S.isSet)(u.header) && (l.header = e.Header.fromJSON(u.header)), (0, S.isSet)(u.commit) && (l.commit = e.Commit.fromJSON(u.commit)), l;
    },
    toJSON(u) {
      const l = {};
      return u.header !== void 0 && (l.header = u.header ? e.Header.toJSON(u.header) : void 0), u.commit !== void 0 && (l.commit = u.commit ? e.Commit.toJSON(u.commit) : void 0), l;
    },
    fromPartial(u) {
      const l = o();
      return u.header !== void 0 && u.header !== null && (l.header = e.Header.fromPartial(u.header)), u.commit !== void 0 && u.commit !== null && (l.commit = e.Commit.fromPartial(u.commit)), l;
    }
  };
  function h() {
    return {
      signedHeader: void 0,
      validatorSet: void 0
    };
  }
  e.LightBlock = {
    typeUrl: "/tendermint.types.LightBlock",
    encode(u, l = f.BinaryWriter.create()) {
      return u.signedHeader !== void 0 && e.SignedHeader.encode(u.signedHeader, l.uint32(10).fork()).ldelim(), u.validatorSet !== void 0 && i.ValidatorSet.encode(u.validatorSet, l.uint32(18).fork()).ldelim(), l;
    },
    decode(u, l) {
      const I = u instanceof f.BinaryReader ? u : new f.BinaryReader(u);
      let B = l === void 0 ? I.len : I.pos + l;
      const b = h();
      for (; I.pos < B; ) {
        const D = I.uint32();
        switch (D >>> 3) {
          case 1:
            b.signedHeader = e.SignedHeader.decode(I, I.uint32());
            break;
          case 2:
            b.validatorSet = i.ValidatorSet.decode(I, I.uint32());
            break;
          default:
            I.skipType(D & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(u) {
      const l = h();
      return (0, S.isSet)(u.signedHeader) && (l.signedHeader = e.SignedHeader.fromJSON(u.signedHeader)), (0, S.isSet)(u.validatorSet) && (l.validatorSet = i.ValidatorSet.fromJSON(u.validatorSet)), l;
    },
    toJSON(u) {
      const l = {};
      return u.signedHeader !== void 0 && (l.signedHeader = u.signedHeader ? e.SignedHeader.toJSON(u.signedHeader) : void 0), u.validatorSet !== void 0 && (l.validatorSet = u.validatorSet ? i.ValidatorSet.toJSON(u.validatorSet) : void 0), l;
    },
    fromPartial(u) {
      const l = h();
      return u.signedHeader !== void 0 && u.signedHeader !== null && (l.signedHeader = e.SignedHeader.fromPartial(u.signedHeader)), u.validatorSet !== void 0 && u.validatorSet !== null && (l.validatorSet = i.ValidatorSet.fromPartial(u.validatorSet)), l;
    }
  };
  function N() {
    return {
      blockId: e.BlockID.fromPartial({}),
      blockSize: BigInt(0),
      header: e.Header.fromPartial({}),
      numTxs: BigInt(0)
    };
  }
  e.BlockMeta = {
    typeUrl: "/tendermint.types.BlockMeta",
    encode(u, l = f.BinaryWriter.create()) {
      return u.blockId !== void 0 && e.BlockID.encode(u.blockId, l.uint32(10).fork()).ldelim(), u.blockSize !== BigInt(0) && l.uint32(16).int64(u.blockSize), u.header !== void 0 && e.Header.encode(u.header, l.uint32(26).fork()).ldelim(), u.numTxs !== BigInt(0) && l.uint32(32).int64(u.numTxs), l;
    },
    decode(u, l) {
      const I = u instanceof f.BinaryReader ? u : new f.BinaryReader(u);
      let B = l === void 0 ? I.len : I.pos + l;
      const b = N();
      for (; I.pos < B; ) {
        const D = I.uint32();
        switch (D >>> 3) {
          case 1:
            b.blockId = e.BlockID.decode(I, I.uint32());
            break;
          case 2:
            b.blockSize = I.int64();
            break;
          case 3:
            b.header = e.Header.decode(I, I.uint32());
            break;
          case 4:
            b.numTxs = I.int64();
            break;
          default:
            I.skipType(D & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(u) {
      const l = N();
      return (0, S.isSet)(u.blockId) && (l.blockId = e.BlockID.fromJSON(u.blockId)), (0, S.isSet)(u.blockSize) && (l.blockSize = BigInt(u.blockSize.toString())), (0, S.isSet)(u.header) && (l.header = e.Header.fromJSON(u.header)), (0, S.isSet)(u.numTxs) && (l.numTxs = BigInt(u.numTxs.toString())), l;
    },
    toJSON(u) {
      const l = {};
      return u.blockId !== void 0 && (l.blockId = u.blockId ? e.BlockID.toJSON(u.blockId) : void 0), u.blockSize !== void 0 && (l.blockSize = (u.blockSize || BigInt(0)).toString()), u.header !== void 0 && (l.header = u.header ? e.Header.toJSON(u.header) : void 0), u.numTxs !== void 0 && (l.numTxs = (u.numTxs || BigInt(0)).toString()), l;
    },
    fromPartial(u) {
      const l = N();
      return u.blockId !== void 0 && u.blockId !== null && (l.blockId = e.BlockID.fromPartial(u.blockId)), u.blockSize !== void 0 && u.blockSize !== null && (l.blockSize = BigInt(u.blockSize.toString())), u.header !== void 0 && u.header !== null && (l.header = e.Header.fromPartial(u.header)), u.numTxs !== void 0 && u.numTxs !== null && (l.numTxs = BigInt(u.numTxs.toString())), l;
    }
  };
  function q() {
    return {
      rootHash: new Uint8Array(),
      data: new Uint8Array(),
      proof: void 0
    };
  }
  e.TxProof = {
    typeUrl: "/tendermint.types.TxProof",
    encode(u, l = f.BinaryWriter.create()) {
      return u.rootHash.length !== 0 && l.uint32(10).bytes(u.rootHash), u.data.length !== 0 && l.uint32(18).bytes(u.data), u.proof !== void 0 && n.Proof.encode(u.proof, l.uint32(26).fork()).ldelim(), l;
    },
    decode(u, l) {
      const I = u instanceof f.BinaryReader ? u : new f.BinaryReader(u);
      let B = l === void 0 ? I.len : I.pos + l;
      const b = q();
      for (; I.pos < B; ) {
        const D = I.uint32();
        switch (D >>> 3) {
          case 1:
            b.rootHash = I.bytes();
            break;
          case 2:
            b.data = I.bytes();
            break;
          case 3:
            b.proof = n.Proof.decode(I, I.uint32());
            break;
          default:
            I.skipType(D & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(u) {
      const l = q();
      return (0, S.isSet)(u.rootHash) && (l.rootHash = (0, S.bytesFromBase64)(u.rootHash)), (0, S.isSet)(u.data) && (l.data = (0, S.bytesFromBase64)(u.data)), (0, S.isSet)(u.proof) && (l.proof = n.Proof.fromJSON(u.proof)), l;
    },
    toJSON(u) {
      const l = {};
      return u.rootHash !== void 0 && (l.rootHash = (0, S.base64FromBytes)(u.rootHash !== void 0 ? u.rootHash : new Uint8Array())), u.data !== void 0 && (l.data = (0, S.base64FromBytes)(u.data !== void 0 ? u.data : new Uint8Array())), u.proof !== void 0 && (l.proof = u.proof ? n.Proof.toJSON(u.proof) : void 0), l;
    },
    fromPartial(u) {
      const l = q();
      return l.rootHash = u.rootHash ?? new Uint8Array(), l.data = u.data ?? new Uint8Array(), u.proof !== void 0 && u.proof !== null && (l.proof = n.Proof.fromPartial(u.proof)), l;
    }
  };
})(ar);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Fraction = e.Header = e.Misbehaviour = e.ConsensusState = e.ClientState = e.protobufPackage = void 0;
  const n = vn, r = yt, t = Zc, i = Je, f = gn, S = ar, w = Cs, T = re, J = ie;
  e.protobufPackage = "ibc.lightclients.tendermint.v1";
  function C() {
    return {
      chainId: "",
      trustLevel: e.Fraction.fromPartial({}),
      trustingPeriod: n.Duration.fromPartial({}),
      unbondingPeriod: n.Duration.fromPartial({}),
      maxClockDrift: n.Duration.fromPartial({}),
      frozenHeight: r.Height.fromPartial({}),
      latestHeight: r.Height.fromPartial({}),
      proofSpecs: [],
      upgradePath: [],
      allowUpdateAfterExpiry: !1,
      allowUpdateAfterMisbehaviour: !1
    };
  }
  e.ClientState = {
    typeUrl: "/ibc.lightclients.tendermint.v1.ClientState",
    encode(a, d = T.BinaryWriter.create()) {
      a.chainId !== "" && d.uint32(10).string(a.chainId), a.trustLevel !== void 0 && e.Fraction.encode(a.trustLevel, d.uint32(18).fork()).ldelim(), a.trustingPeriod !== void 0 && n.Duration.encode(a.trustingPeriod, d.uint32(26).fork()).ldelim(), a.unbondingPeriod !== void 0 && n.Duration.encode(a.unbondingPeriod, d.uint32(34).fork()).ldelim(), a.maxClockDrift !== void 0 && n.Duration.encode(a.maxClockDrift, d.uint32(42).fork()).ldelim(), a.frozenHeight !== void 0 && r.Height.encode(a.frozenHeight, d.uint32(50).fork()).ldelim(), a.latestHeight !== void 0 && r.Height.encode(a.latestHeight, d.uint32(58).fork()).ldelim();
      for (const y of a.proofSpecs)
        t.ProofSpec.encode(y, d.uint32(66).fork()).ldelim();
      for (const y of a.upgradePath)
        d.uint32(74).string(y);
      return a.allowUpdateAfterExpiry === !0 && d.uint32(80).bool(a.allowUpdateAfterExpiry), a.allowUpdateAfterMisbehaviour === !0 && d.uint32(88).bool(a.allowUpdateAfterMisbehaviour), d;
    },
    decode(a, d) {
      const y = a instanceof T.BinaryReader ? a : new T.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = C();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          case 1:
            E.chainId = y.string();
            break;
          case 2:
            E.trustLevel = e.Fraction.decode(y, y.uint32());
            break;
          case 3:
            E.trustingPeriod = n.Duration.decode(y, y.uint32());
            break;
          case 4:
            E.unbondingPeriod = n.Duration.decode(y, y.uint32());
            break;
          case 5:
            E.maxClockDrift = n.Duration.decode(y, y.uint32());
            break;
          case 6:
            E.frozenHeight = r.Height.decode(y, y.uint32());
            break;
          case 7:
            E.latestHeight = r.Height.decode(y, y.uint32());
            break;
          case 8:
            E.proofSpecs.push(t.ProofSpec.decode(y, y.uint32()));
            break;
          case 9:
            E.upgradePath.push(y.string());
            break;
          case 10:
            E.allowUpdateAfterExpiry = y.bool();
            break;
          case 11:
            E.allowUpdateAfterMisbehaviour = y.bool();
            break;
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      const d = C();
      return (0, J.isSet)(a.chainId) && (d.chainId = String(a.chainId)), (0, J.isSet)(a.trustLevel) && (d.trustLevel = e.Fraction.fromJSON(a.trustLevel)), (0, J.isSet)(a.trustingPeriod) && (d.trustingPeriod = n.Duration.fromJSON(a.trustingPeriod)), (0, J.isSet)(a.unbondingPeriod) && (d.unbondingPeriod = n.Duration.fromJSON(a.unbondingPeriod)), (0, J.isSet)(a.maxClockDrift) && (d.maxClockDrift = n.Duration.fromJSON(a.maxClockDrift)), (0, J.isSet)(a.frozenHeight) && (d.frozenHeight = r.Height.fromJSON(a.frozenHeight)), (0, J.isSet)(a.latestHeight) && (d.latestHeight = r.Height.fromJSON(a.latestHeight)), Array.isArray(a == null ? void 0 : a.proofSpecs) && (d.proofSpecs = a.proofSpecs.map((y) => t.ProofSpec.fromJSON(y))), Array.isArray(a == null ? void 0 : a.upgradePath) && (d.upgradePath = a.upgradePath.map((y) => String(y))), (0, J.isSet)(a.allowUpdateAfterExpiry) && (d.allowUpdateAfterExpiry = !!a.allowUpdateAfterExpiry), (0, J.isSet)(a.allowUpdateAfterMisbehaviour) && (d.allowUpdateAfterMisbehaviour = !!a.allowUpdateAfterMisbehaviour), d;
    },
    toJSON(a) {
      const d = {};
      return a.chainId !== void 0 && (d.chainId = a.chainId), a.trustLevel !== void 0 && (d.trustLevel = a.trustLevel ? e.Fraction.toJSON(a.trustLevel) : void 0), a.trustingPeriod !== void 0 && (d.trustingPeriod = a.trustingPeriod ? n.Duration.toJSON(a.trustingPeriod) : void 0), a.unbondingPeriod !== void 0 && (d.unbondingPeriod = a.unbondingPeriod ? n.Duration.toJSON(a.unbondingPeriod) : void 0), a.maxClockDrift !== void 0 && (d.maxClockDrift = a.maxClockDrift ? n.Duration.toJSON(a.maxClockDrift) : void 0), a.frozenHeight !== void 0 && (d.frozenHeight = a.frozenHeight ? r.Height.toJSON(a.frozenHeight) : void 0), a.latestHeight !== void 0 && (d.latestHeight = a.latestHeight ? r.Height.toJSON(a.latestHeight) : void 0), a.proofSpecs ? d.proofSpecs = a.proofSpecs.map((y) => y ? t.ProofSpec.toJSON(y) : void 0) : d.proofSpecs = [], a.upgradePath ? d.upgradePath = a.upgradePath.map((y) => y) : d.upgradePath = [], a.allowUpdateAfterExpiry !== void 0 && (d.allowUpdateAfterExpiry = a.allowUpdateAfterExpiry), a.allowUpdateAfterMisbehaviour !== void 0 && (d.allowUpdateAfterMisbehaviour = a.allowUpdateAfterMisbehaviour), d;
    },
    fromPartial(a) {
      var y, _;
      const d = C();
      return d.chainId = a.chainId ?? "", a.trustLevel !== void 0 && a.trustLevel !== null && (d.trustLevel = e.Fraction.fromPartial(a.trustLevel)), a.trustingPeriod !== void 0 && a.trustingPeriod !== null && (d.trustingPeriod = n.Duration.fromPartial(a.trustingPeriod)), a.unbondingPeriod !== void 0 && a.unbondingPeriod !== null && (d.unbondingPeriod = n.Duration.fromPartial(a.unbondingPeriod)), a.maxClockDrift !== void 0 && a.maxClockDrift !== null && (d.maxClockDrift = n.Duration.fromPartial(a.maxClockDrift)), a.frozenHeight !== void 0 && a.frozenHeight !== null && (d.frozenHeight = r.Height.fromPartial(a.frozenHeight)), a.latestHeight !== void 0 && a.latestHeight !== null && (d.latestHeight = r.Height.fromPartial(a.latestHeight)), d.proofSpecs = ((y = a.proofSpecs) == null ? void 0 : y.map((E) => t.ProofSpec.fromPartial(E))) || [], d.upgradePath = ((_ = a.upgradePath) == null ? void 0 : _.map((E) => E)) || [], d.allowUpdateAfterExpiry = a.allowUpdateAfterExpiry ?? !1, d.allowUpdateAfterMisbehaviour = a.allowUpdateAfterMisbehaviour ?? !1, d;
    }
  };
  function R() {
    return {
      timestamp: i.Timestamp.fromPartial({}),
      root: f.MerkleRoot.fromPartial({}),
      nextValidatorsHash: new Uint8Array()
    };
  }
  e.ConsensusState = {
    typeUrl: "/ibc.lightclients.tendermint.v1.ConsensusState",
    encode(a, d = T.BinaryWriter.create()) {
      return a.timestamp !== void 0 && i.Timestamp.encode(a.timestamp, d.uint32(10).fork()).ldelim(), a.root !== void 0 && f.MerkleRoot.encode(a.root, d.uint32(18).fork()).ldelim(), a.nextValidatorsHash.length !== 0 && d.uint32(26).bytes(a.nextValidatorsHash), d;
    },
    decode(a, d) {
      const y = a instanceof T.BinaryReader ? a : new T.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = R();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          case 1:
            E.timestamp = i.Timestamp.decode(y, y.uint32());
            break;
          case 2:
            E.root = f.MerkleRoot.decode(y, y.uint32());
            break;
          case 3:
            E.nextValidatorsHash = y.bytes();
            break;
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      const d = R();
      return (0, J.isSet)(a.timestamp) && (d.timestamp = (0, J.fromJsonTimestamp)(a.timestamp)), (0, J.isSet)(a.root) && (d.root = f.MerkleRoot.fromJSON(a.root)), (0, J.isSet)(a.nextValidatorsHash) && (d.nextValidatorsHash = (0, J.bytesFromBase64)(a.nextValidatorsHash)), d;
    },
    toJSON(a) {
      const d = {};
      return a.timestamp !== void 0 && (d.timestamp = (0, J.fromTimestamp)(a.timestamp).toISOString()), a.root !== void 0 && (d.root = a.root ? f.MerkleRoot.toJSON(a.root) : void 0), a.nextValidatorsHash !== void 0 && (d.nextValidatorsHash = (0, J.base64FromBytes)(a.nextValidatorsHash !== void 0 ? a.nextValidatorsHash : new Uint8Array())), d;
    },
    fromPartial(a) {
      const d = R();
      return a.timestamp !== void 0 && a.timestamp !== null && (d.timestamp = i.Timestamp.fromPartial(a.timestamp)), a.root !== void 0 && a.root !== null && (d.root = f.MerkleRoot.fromPartial(a.root)), d.nextValidatorsHash = a.nextValidatorsHash ?? new Uint8Array(), d;
    }
  };
  function p() {
    return {
      clientId: "",
      header1: void 0,
      header2: void 0
    };
  }
  e.Misbehaviour = {
    typeUrl: "/ibc.lightclients.tendermint.v1.Misbehaviour",
    encode(a, d = T.BinaryWriter.create()) {
      return a.clientId !== "" && d.uint32(10).string(a.clientId), a.header1 !== void 0 && e.Header.encode(a.header1, d.uint32(18).fork()).ldelim(), a.header2 !== void 0 && e.Header.encode(a.header2, d.uint32(26).fork()).ldelim(), d;
    },
    decode(a, d) {
      const y = a instanceof T.BinaryReader ? a : new T.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = p();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          case 1:
            E.clientId = y.string();
            break;
          case 2:
            E.header1 = e.Header.decode(y, y.uint32());
            break;
          case 3:
            E.header2 = e.Header.decode(y, y.uint32());
            break;
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      const d = p();
      return (0, J.isSet)(a.clientId) && (d.clientId = String(a.clientId)), (0, J.isSet)(a.header1) && (d.header1 = e.Header.fromJSON(a.header1)), (0, J.isSet)(a.header2) && (d.header2 = e.Header.fromJSON(a.header2)), d;
    },
    toJSON(a) {
      const d = {};
      return a.clientId !== void 0 && (d.clientId = a.clientId), a.header1 !== void 0 && (d.header1 = a.header1 ? e.Header.toJSON(a.header1) : void 0), a.header2 !== void 0 && (d.header2 = a.header2 ? e.Header.toJSON(a.header2) : void 0), d;
    },
    fromPartial(a) {
      const d = p();
      return d.clientId = a.clientId ?? "", a.header1 !== void 0 && a.header1 !== null && (d.header1 = e.Header.fromPartial(a.header1)), a.header2 !== void 0 && a.header2 !== null && (d.header2 = e.Header.fromPartial(a.header2)), d;
    }
  };
  function m() {
    return {
      signedHeader: void 0,
      validatorSet: void 0,
      trustedHeight: r.Height.fromPartial({}),
      trustedValidators: void 0
    };
  }
  e.Header = {
    typeUrl: "/ibc.lightclients.tendermint.v1.Header",
    encode(a, d = T.BinaryWriter.create()) {
      return a.signedHeader !== void 0 && S.SignedHeader.encode(a.signedHeader, d.uint32(10).fork()).ldelim(), a.validatorSet !== void 0 && w.ValidatorSet.encode(a.validatorSet, d.uint32(18).fork()).ldelim(), a.trustedHeight !== void 0 && r.Height.encode(a.trustedHeight, d.uint32(26).fork()).ldelim(), a.trustedValidators !== void 0 && w.ValidatorSet.encode(a.trustedValidators, d.uint32(34).fork()).ldelim(), d;
    },
    decode(a, d) {
      const y = a instanceof T.BinaryReader ? a : new T.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = m();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          case 1:
            E.signedHeader = S.SignedHeader.decode(y, y.uint32());
            break;
          case 2:
            E.validatorSet = w.ValidatorSet.decode(y, y.uint32());
            break;
          case 3:
            E.trustedHeight = r.Height.decode(y, y.uint32());
            break;
          case 4:
            E.trustedValidators = w.ValidatorSet.decode(y, y.uint32());
            break;
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      const d = m();
      return (0, J.isSet)(a.signedHeader) && (d.signedHeader = S.SignedHeader.fromJSON(a.signedHeader)), (0, J.isSet)(a.validatorSet) && (d.validatorSet = w.ValidatorSet.fromJSON(a.validatorSet)), (0, J.isSet)(a.trustedHeight) && (d.trustedHeight = r.Height.fromJSON(a.trustedHeight)), (0, J.isSet)(a.trustedValidators) && (d.trustedValidators = w.ValidatorSet.fromJSON(a.trustedValidators)), d;
    },
    toJSON(a) {
      const d = {};
      return a.signedHeader !== void 0 && (d.signedHeader = a.signedHeader ? S.SignedHeader.toJSON(a.signedHeader) : void 0), a.validatorSet !== void 0 && (d.validatorSet = a.validatorSet ? w.ValidatorSet.toJSON(a.validatorSet) : void 0), a.trustedHeight !== void 0 && (d.trustedHeight = a.trustedHeight ? r.Height.toJSON(a.trustedHeight) : void 0), a.trustedValidators !== void 0 && (d.trustedValidators = a.trustedValidators ? w.ValidatorSet.toJSON(a.trustedValidators) : void 0), d;
    },
    fromPartial(a) {
      const d = m();
      return a.signedHeader !== void 0 && a.signedHeader !== null && (d.signedHeader = S.SignedHeader.fromPartial(a.signedHeader)), a.validatorSet !== void 0 && a.validatorSet !== null && (d.validatorSet = w.ValidatorSet.fromPartial(a.validatorSet)), a.trustedHeight !== void 0 && a.trustedHeight !== null && (d.trustedHeight = r.Height.fromPartial(a.trustedHeight)), a.trustedValidators !== void 0 && a.trustedValidators !== null && (d.trustedValidators = w.ValidatorSet.fromPartial(a.trustedValidators)), d;
    }
  };
  function v() {
    return {
      numerator: BigInt(0),
      denominator: BigInt(0)
    };
  }
  e.Fraction = {
    typeUrl: "/ibc.lightclients.tendermint.v1.Fraction",
    encode(a, d = T.BinaryWriter.create()) {
      return a.numerator !== BigInt(0) && d.uint32(8).uint64(a.numerator), a.denominator !== BigInt(0) && d.uint32(16).uint64(a.denominator), d;
    },
    decode(a, d) {
      const y = a instanceof T.BinaryReader ? a : new T.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = v();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          case 1:
            E.numerator = y.uint64();
            break;
          case 2:
            E.denominator = y.uint64();
            break;
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      const d = v();
      return (0, J.isSet)(a.numerator) && (d.numerator = BigInt(a.numerator.toString())), (0, J.isSet)(a.denominator) && (d.denominator = BigInt(a.denominator.toString())), d;
    },
    toJSON(a) {
      const d = {};
      return a.numerator !== void 0 && (d.numerator = (a.numerator || BigInt(0)).toString()), a.denominator !== void 0 && (d.denominator = (a.denominator || BigInt(0)).toString()), d;
    },
    fromPartial(a) {
      const d = v();
      return a.numerator !== void 0 && a.numerator !== null && (d.numerator = BigInt(a.numerator.toString())), a.denominator !== void 0 && a.denominator !== null && (d.denominator = BigInt(a.denominator.toString())), d;
    }
  };
})(Qh);
Object.defineProperty(ws, "__esModule", { value: !0 });
ws.setupIbcExtension = void 0;
const jo = Ke, JR = Ie, bf = Hh, DR = Ts, Lt = qh, no = Vh, bu = Wh, Fh = Qh, Be = Ye;
function Ru(e) {
  if ((e == null ? void 0 : e.typeUrl) !== "/ibc.lightclients.tendermint.v1.ClientState")
    throw new Error(`Unexpected client state type: ${e == null ? void 0 : e.typeUrl}`);
  return Fh.ClientState.decode(e.value);
}
function MR(e) {
  if ((e == null ? void 0 : e.typeUrl) !== "/ibc.lightclients.tendermint.v1.ConsensusState")
    throw new Error(`Unexpected client state type: ${e == null ? void 0 : e.typeUrl}`);
  return Fh.ConsensusState.decode(e.value);
}
function HR(e) {
  const n = (0, Be.createProtobufRpcClient)(e), r = new Lt.QueryClientImpl(n), t = new no.QueryClientImpl(n), i = new bu.QueryClientImpl(n), f = new bf.QueryClientImpl(n);
  return {
    ibc: {
      channel: {
        channel: async (S, w) => r.Channel({
          portId: S,
          channelId: w
        }),
        channels: async (S) => r.Channels({
          pagination: (0, Be.createPagination)(S)
        }),
        allChannels: async () => {
          var J;
          const S = [];
          let w, T;
          do
            w = await r.Channels({
              pagination: (0, Be.createPagination)(T)
            }), S.push(...w.channels), T = (J = w.pagination) == null ? void 0 : J.nextKey;
          while (T && T.length);
          return Lt.QueryChannelsResponse.fromPartial({
            channels: S,
            height: w.height
          });
        },
        connectionChannels: async (S, w) => r.ConnectionChannels({
          connection: S,
          pagination: (0, Be.createPagination)(w)
        }),
        allConnectionChannels: async (S) => {
          var C;
          const w = [];
          let T, J;
          do
            T = await r.ConnectionChannels({
              connection: S,
              pagination: (0, Be.createPagination)(J)
            }), w.push(...T.channels), J = (C = T.pagination) == null ? void 0 : C.nextKey;
          while (J && J.length);
          return Lt.QueryConnectionChannelsResponse.fromPartial({
            channels: w,
            height: T.height
          });
        },
        clientState: async (S, w) => r.ChannelClientState({
          portId: S,
          channelId: w
        }),
        consensusState: async (S, w, T, J) => r.ChannelConsensusState({
          portId: S,
          channelId: w,
          revisionNumber: BigInt(T),
          revisionHeight: BigInt(J)
        }),
        packetCommitment: async (S, w, T) => r.PacketCommitment({
          portId: S,
          channelId: w,
          sequence: (0, Be.longify)(T)
        }),
        packetCommitments: async (S, w, T) => r.PacketCommitments({
          channelId: w,
          portId: S,
          pagination: (0, Be.createPagination)(T)
        }),
        allPacketCommitments: async (S, w) => {
          var R;
          const T = [];
          let J, C;
          do
            J = await r.PacketCommitments({
              channelId: w,
              portId: S,
              pagination: (0, Be.createPagination)(C)
            }), T.push(...J.commitments), C = (R = J.pagination) == null ? void 0 : R.nextKey;
          while (C && C.length);
          return Lt.QueryPacketCommitmentsResponse.fromPartial({
            commitments: T,
            height: J.height
          });
        },
        packetReceipt: async (S, w, T) => r.PacketReceipt({
          portId: S,
          channelId: w,
          sequence: (0, Be.longify)(T)
        }),
        packetAcknowledgement: async (S, w, T) => r.PacketAcknowledgement({
          portId: S,
          channelId: w,
          sequence: (0, Be.longify)(T)
        }),
        packetAcknowledgements: async (S, w, T) => {
          const J = Lt.QueryPacketAcknowledgementsRequest.fromPartial({
            portId: S,
            channelId: w,
            pagination: (0, Be.createPagination)(T)
          });
          return r.PacketAcknowledgements(J);
        },
        allPacketAcknowledgements: async (S, w) => {
          var R;
          const T = [];
          let J, C;
          do {
            const p = Lt.QueryPacketAcknowledgementsRequest.fromPartial({
              channelId: w,
              portId: S,
              pagination: (0, Be.createPagination)(C)
            });
            J = await r.PacketAcknowledgements(p), T.push(...J.acknowledgements), C = (R = J.pagination) == null ? void 0 : R.nextKey;
          } while (C && C.length);
          return Lt.QueryPacketAcknowledgementsResponse.fromPartial({
            acknowledgements: T,
            height: J.height
          });
        },
        unreceivedPackets: async (S, w, T) => r.UnreceivedPackets({
          portId: S,
          channelId: w,
          packetCommitmentSequences: T.map((J) => BigInt(J))
        }),
        unreceivedAcks: async (S, w, T) => r.UnreceivedAcks({
          portId: S,
          channelId: w,
          packetAckSequences: T.map((J) => BigInt(J))
        }),
        nextSequenceReceive: async (S, w) => r.NextSequenceReceive({
          portId: S,
          channelId: w
        })
      },
      client: {
        state: async (S) => t.ClientState({ clientId: S }),
        states: async (S) => t.ClientStates({
          pagination: (0, Be.createPagination)(S)
        }),
        allStates: async () => {
          var J;
          const S = [];
          let w, T;
          do
            w = await t.ClientStates({
              pagination: (0, Be.createPagination)(T)
            }), S.push(...w.clientStates), T = (J = w.pagination) == null ? void 0 : J.nextKey;
          while (T && T.length);
          return no.QueryClientStatesResponse.fromPartial({
            clientStates: S
          });
        },
        consensusState: async (S, w) => t.ConsensusState(no.QueryConsensusStateRequest.fromPartial({
          clientId: S,
          revisionHeight: w !== void 0 ? BigInt(w) : void 0,
          latestHeight: w === void 0
        })),
        consensusStates: async (S, w) => t.ConsensusStates({
          clientId: S,
          pagination: (0, Be.createPagination)(w)
        }),
        allConsensusStates: async (S) => {
          var C;
          const w = [];
          let T, J;
          do
            T = await t.ConsensusStates({
              clientId: S,
              pagination: (0, Be.createPagination)(J)
            }), w.push(...T.consensusStates), J = (C = T.pagination) == null ? void 0 : C.nextKey;
          while (J && J.length);
          return no.QueryConsensusStatesResponse.fromPartial({
            consensusStates: w
          });
        },
        params: async () => t.ClientParams({}),
        stateTm: async (S) => {
          const w = await t.ClientState({ clientId: S });
          return Ru(w.clientState);
        },
        statesTm: async (S) => {
          const { clientStates: w } = await t.ClientStates({
            pagination: (0, Be.createPagination)(S)
          });
          return w.map(({ clientState: T }) => Ru(T));
        },
        allStatesTm: async () => {
          var J;
          const S = [];
          let w, T;
          do
            w = await t.ClientStates({
              pagination: (0, Be.createPagination)(T)
            }), S.push(...w.clientStates), T = (J = w.pagination) == null ? void 0 : J.nextKey;
          while (T && T.length);
          return S.map(({ clientState: C }) => Ru(C));
        },
        consensusStateTm: async (S, w) => {
          const T = await t.ConsensusState(no.QueryConsensusStateRequest.fromPartial({
            clientId: S,
            revisionHeight: w == null ? void 0 : w.revisionHeight,
            revisionNumber: w == null ? void 0 : w.revisionNumber,
            latestHeight: w === void 0
          }));
          return MR(T.consensusState);
        }
      },
      connection: {
        connection: async (S) => i.Connection({
          connectionId: S
        }),
        connections: async (S) => i.Connections({
          pagination: (0, Be.createPagination)(S)
        }),
        allConnections: async () => {
          var J;
          const S = [];
          let w, T;
          do
            w = await i.Connections({
              pagination: (0, Be.createPagination)(T)
            }), S.push(...w.connections), T = (J = w.pagination) == null ? void 0 : J.nextKey;
          while (T && T.length);
          return bu.QueryConnectionsResponse.fromPartial({
            connections: S,
            height: w.height
          });
        },
        clientConnections: async (S) => i.ClientConnections({
          clientId: S
        }),
        clientState: async (S) => i.ConnectionClientState({
          connectionId: S
        }),
        consensusState: async (S, w) => i.ConnectionConsensusState(bu.QueryConnectionConsensusStateRequest.fromPartial({
          connectionId: S,
          revisionHeight: BigInt(w)
        }))
      },
      transfer: {
        denomTrace: async (S) => f.DenomTrace({ hash: S }),
        denomTraces: async (S) => f.DenomTraces({
          pagination: (0, Be.createPagination)(S)
        }),
        allDenomTraces: async () => {
          var J;
          const S = [];
          let w, T;
          do
            w = await f.DenomTraces({
              pagination: (0, Be.createPagination)(T)
            }), S.push(...w.denomTraces), T = (J = w.pagination) == null ? void 0 : J.nextKey;
          while (T && T.length);
          return bf.QueryDenomTracesResponse.fromPartial({
            denomTraces: S
          });
        },
        params: async () => f.Params({})
      },
      verified: {
        channel: {
          channel: async (S, w) => {
            const T = (0, jo.toAscii)(`channelEnds/ports/${S}/channels/${w}`), { value: J } = await e.queryStoreVerified("ibc", T);
            return J.length ? DR.Channel.decode(J) : null;
          },
          packetCommitment: async (S, w, T) => {
            const J = (0, jo.toAscii)(`commitments/ports/${S}/channels/${w}/packets/${T}`), { value: C } = await e.queryStoreVerified("ibc", J);
            return C;
          },
          packetAcknowledgement: async (S, w, T) => {
            const J = (0, jo.toAscii)(`acks/ports/${S}/channels/${w}/acknowledgements/${T}`), { value: C } = await e.queryStoreVerified("ibc", J);
            return C;
          },
          nextSequenceReceive: async (S, w) => {
            const T = (0, jo.toAscii)(`seqAcks/ports/${S}/channels/${w}/nextSequenceAck`), { value: J } = await e.queryStoreVerified("ibc", T);
            return J.length ? JR.Uint64.fromBytes(J).toNumber() : null;
          }
        }
      }
    }
  };
}
ws.setupIbcExtension = HR;
var Ns = {}, $h = {}, Ut = {};
Object.defineProperty(Ut, "__esModule", { value: !0 });
Ut.Params = Ut.Minter = Ut.protobufPackage = void 0;
const Hr = re, vt = ie;
Ut.protobufPackage = "cosmos.mint.v1beta1";
function Bu() {
  return {
    inflation: "",
    annualProvisions: ""
  };
}
Ut.Minter = {
  typeUrl: "/cosmos.mint.v1beta1.Minter",
  encode(e, n = Hr.BinaryWriter.create()) {
    return e.inflation !== "" && n.uint32(10).string(e.inflation), e.annualProvisions !== "" && n.uint32(18).string(e.annualProvisions), n;
  },
  decode(e, n) {
    const r = e instanceof Hr.BinaryReader ? e : new Hr.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = Bu();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.inflation = r.string();
          break;
        case 2:
          i.annualProvisions = r.string();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = Bu();
    return (0, vt.isSet)(e.inflation) && (n.inflation = String(e.inflation)), (0, vt.isSet)(e.annualProvisions) && (n.annualProvisions = String(e.annualProvisions)), n;
  },
  toJSON(e) {
    const n = {};
    return e.inflation !== void 0 && (n.inflation = e.inflation), e.annualProvisions !== void 0 && (n.annualProvisions = e.annualProvisions), n;
  },
  fromPartial(e) {
    const n = Bu();
    return n.inflation = e.inflation ?? "", n.annualProvisions = e.annualProvisions ?? "", n;
  }
};
function Ou() {
  return {
    mintDenom: "",
    inflationRateChange: "",
    inflationMax: "",
    inflationMin: "",
    goalBonded: "",
    blocksPerYear: BigInt(0)
  };
}
Ut.Params = {
  typeUrl: "/cosmos.mint.v1beta1.Params",
  encode(e, n = Hr.BinaryWriter.create()) {
    return e.mintDenom !== "" && n.uint32(10).string(e.mintDenom), e.inflationRateChange !== "" && n.uint32(18).string(e.inflationRateChange), e.inflationMax !== "" && n.uint32(26).string(e.inflationMax), e.inflationMin !== "" && n.uint32(34).string(e.inflationMin), e.goalBonded !== "" && n.uint32(42).string(e.goalBonded), e.blocksPerYear !== BigInt(0) && n.uint32(48).uint64(e.blocksPerYear), n;
  },
  decode(e, n) {
    const r = e instanceof Hr.BinaryReader ? e : new Hr.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = Ou();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.mintDenom = r.string();
          break;
        case 2:
          i.inflationRateChange = r.string();
          break;
        case 3:
          i.inflationMax = r.string();
          break;
        case 4:
          i.inflationMin = r.string();
          break;
        case 5:
          i.goalBonded = r.string();
          break;
        case 6:
          i.blocksPerYear = r.uint64();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = Ou();
    return (0, vt.isSet)(e.mintDenom) && (n.mintDenom = String(e.mintDenom)), (0, vt.isSet)(e.inflationRateChange) && (n.inflationRateChange = String(e.inflationRateChange)), (0, vt.isSet)(e.inflationMax) && (n.inflationMax = String(e.inflationMax)), (0, vt.isSet)(e.inflationMin) && (n.inflationMin = String(e.inflationMin)), (0, vt.isSet)(e.goalBonded) && (n.goalBonded = String(e.goalBonded)), (0, vt.isSet)(e.blocksPerYear) && (n.blocksPerYear = BigInt(e.blocksPerYear.toString())), n;
  },
  toJSON(e) {
    const n = {};
    return e.mintDenom !== void 0 && (n.mintDenom = e.mintDenom), e.inflationRateChange !== void 0 && (n.inflationRateChange = e.inflationRateChange), e.inflationMax !== void 0 && (n.inflationMax = e.inflationMax), e.inflationMin !== void 0 && (n.inflationMin = e.inflationMin), e.goalBonded !== void 0 && (n.goalBonded = e.goalBonded), e.blocksPerYear !== void 0 && (n.blocksPerYear = (e.blocksPerYear || BigInt(0)).toString()), n;
  },
  fromPartial(e) {
    const n = Ou();
    return n.mintDenom = e.mintDenom ?? "", n.inflationRateChange = e.inflationRateChange ?? "", n.inflationMax = e.inflationMax ?? "", n.inflationMin = e.inflationMin ?? "", n.goalBonded = e.goalBonded ?? "", e.blocksPerYear !== void 0 && e.blocksPerYear !== null && (n.blocksPerYear = BigInt(e.blocksPerYear.toString())), n;
  }
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryAnnualProvisionsResponse = e.QueryAnnualProvisionsRequest = e.QueryInflationResponse = e.QueryInflationRequest = e.QueryParamsResponse = e.QueryParamsRequest = e.protobufPackage = void 0;
  const n = Ut, r = re, t = ie;
  e.protobufPackage = "cosmos.mint.v1beta1";
  function i() {
    return {};
  }
  e.QueryParamsRequest = {
    typeUrl: "/cosmos.mint.v1beta1.QueryParamsRequest",
    encode(R, p = r.BinaryWriter.create()) {
      return p;
    },
    decode(R, p) {
      const m = R instanceof r.BinaryReader ? R : new r.BinaryReader(R);
      let v = p === void 0 ? m.len : m.pos + p;
      const a = i();
      for (; m.pos < v; ) {
        const d = m.uint32();
        switch (d >>> 3) {
          default:
            m.skipType(d & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(R) {
      return i();
    },
    toJSON(R) {
      return {};
    },
    fromPartial(R) {
      return i();
    }
  };
  function f() {
    return {
      params: n.Params.fromPartial({})
    };
  }
  e.QueryParamsResponse = {
    typeUrl: "/cosmos.mint.v1beta1.QueryParamsResponse",
    encode(R, p = r.BinaryWriter.create()) {
      return R.params !== void 0 && n.Params.encode(R.params, p.uint32(10).fork()).ldelim(), p;
    },
    decode(R, p) {
      const m = R instanceof r.BinaryReader ? R : new r.BinaryReader(R);
      let v = p === void 0 ? m.len : m.pos + p;
      const a = f();
      for (; m.pos < v; ) {
        const d = m.uint32();
        switch (d >>> 3) {
          case 1:
            a.params = n.Params.decode(m, m.uint32());
            break;
          default:
            m.skipType(d & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(R) {
      const p = f();
      return (0, t.isSet)(R.params) && (p.params = n.Params.fromJSON(R.params)), p;
    },
    toJSON(R) {
      const p = {};
      return R.params !== void 0 && (p.params = R.params ? n.Params.toJSON(R.params) : void 0), p;
    },
    fromPartial(R) {
      const p = f();
      return R.params !== void 0 && R.params !== null && (p.params = n.Params.fromPartial(R.params)), p;
    }
  };
  function S() {
    return {};
  }
  e.QueryInflationRequest = {
    typeUrl: "/cosmos.mint.v1beta1.QueryInflationRequest",
    encode(R, p = r.BinaryWriter.create()) {
      return p;
    },
    decode(R, p) {
      const m = R instanceof r.BinaryReader ? R : new r.BinaryReader(R);
      let v = p === void 0 ? m.len : m.pos + p;
      const a = S();
      for (; m.pos < v; ) {
        const d = m.uint32();
        switch (d >>> 3) {
          default:
            m.skipType(d & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(R) {
      return S();
    },
    toJSON(R) {
      return {};
    },
    fromPartial(R) {
      return S();
    }
  };
  function w() {
    return {
      inflation: new Uint8Array()
    };
  }
  e.QueryInflationResponse = {
    typeUrl: "/cosmos.mint.v1beta1.QueryInflationResponse",
    encode(R, p = r.BinaryWriter.create()) {
      return R.inflation.length !== 0 && p.uint32(10).bytes(R.inflation), p;
    },
    decode(R, p) {
      const m = R instanceof r.BinaryReader ? R : new r.BinaryReader(R);
      let v = p === void 0 ? m.len : m.pos + p;
      const a = w();
      for (; m.pos < v; ) {
        const d = m.uint32();
        switch (d >>> 3) {
          case 1:
            a.inflation = m.bytes();
            break;
          default:
            m.skipType(d & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(R) {
      const p = w();
      return (0, t.isSet)(R.inflation) && (p.inflation = (0, t.bytesFromBase64)(R.inflation)), p;
    },
    toJSON(R) {
      const p = {};
      return R.inflation !== void 0 && (p.inflation = (0, t.base64FromBytes)(R.inflation !== void 0 ? R.inflation : new Uint8Array())), p;
    },
    fromPartial(R) {
      const p = w();
      return p.inflation = R.inflation ?? new Uint8Array(), p;
    }
  };
  function T() {
    return {};
  }
  e.QueryAnnualProvisionsRequest = {
    typeUrl: "/cosmos.mint.v1beta1.QueryAnnualProvisionsRequest",
    encode(R, p = r.BinaryWriter.create()) {
      return p;
    },
    decode(R, p) {
      const m = R instanceof r.BinaryReader ? R : new r.BinaryReader(R);
      let v = p === void 0 ? m.len : m.pos + p;
      const a = T();
      for (; m.pos < v; ) {
        const d = m.uint32();
        switch (d >>> 3) {
          default:
            m.skipType(d & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(R) {
      return T();
    },
    toJSON(R) {
      return {};
    },
    fromPartial(R) {
      return T();
    }
  };
  function J() {
    return {
      annualProvisions: new Uint8Array()
    };
  }
  e.QueryAnnualProvisionsResponse = {
    typeUrl: "/cosmos.mint.v1beta1.QueryAnnualProvisionsResponse",
    encode(R, p = r.BinaryWriter.create()) {
      return R.annualProvisions.length !== 0 && p.uint32(10).bytes(R.annualProvisions), p;
    },
    decode(R, p) {
      const m = R instanceof r.BinaryReader ? R : new r.BinaryReader(R);
      let v = p === void 0 ? m.len : m.pos + p;
      const a = J();
      for (; m.pos < v; ) {
        const d = m.uint32();
        switch (d >>> 3) {
          case 1:
            a.annualProvisions = m.bytes();
            break;
          default:
            m.skipType(d & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(R) {
      const p = J();
      return (0, t.isSet)(R.annualProvisions) && (p.annualProvisions = (0, t.bytesFromBase64)(R.annualProvisions)), p;
    },
    toJSON(R) {
      const p = {};
      return R.annualProvisions !== void 0 && (p.annualProvisions = (0, t.base64FromBytes)(R.annualProvisions !== void 0 ? R.annualProvisions : new Uint8Array())), p;
    },
    fromPartial(R) {
      const p = J();
      return p.annualProvisions = R.annualProvisions ?? new Uint8Array(), p;
    }
  };
  class C {
    constructor(p) {
      this.rpc = p, this.Params = this.Params.bind(this), this.Inflation = this.Inflation.bind(this), this.AnnualProvisions = this.AnnualProvisions.bind(this);
    }
    Params(p = {}) {
      const m = e.QueryParamsRequest.encode(p).finish();
      return this.rpc.request("cosmos.mint.v1beta1.Query", "Params", m).then((a) => e.QueryParamsResponse.decode(new r.BinaryReader(a)));
    }
    Inflation(p = {}) {
      const m = e.QueryInflationRequest.encode(p).finish();
      return this.rpc.request("cosmos.mint.v1beta1.Query", "Inflation", m).then((a) => e.QueryInflationResponse.decode(new r.BinaryReader(a)));
    }
    AnnualProvisions(p = {}) {
      const m = e.QueryAnnualProvisionsRequest.encode(p).finish();
      return this.rpc.request("cosmos.mint.v1beta1.Query", "AnnualProvisions", m).then((a) => e.QueryAnnualProvisionsResponse.decode(new r.BinaryReader(a)));
    }
  }
  e.QueryClientImpl = C;
})($h);
Object.defineProperty(Ns, "__esModule", { value: !0 });
Ns.setupMintExtension = void 0;
const qR = Te, VR = $h, Gt = Ye;
function WR(e) {
  const n = (0, Gt.createProtobufRpcClient)(e), r = new VR.QueryClientImpl(n);
  return {
    mint: {
      params: async () => {
        const { params: t } = await r.Params({});
        return (0, qR.assert)(t), {
          blocksPerYear: t.blocksPerYear,
          goalBonded: (0, Gt.decodeCosmosSdkDecFromProto)(t.goalBonded),
          inflationMin: (0, Gt.decodeCosmosSdkDecFromProto)(t.inflationMin),
          inflationMax: (0, Gt.decodeCosmosSdkDecFromProto)(t.inflationMax),
          inflationRateChange: (0, Gt.decodeCosmosSdkDecFromProto)(t.inflationRateChange),
          mintDenom: t.mintDenom
        };
      },
      inflation: async () => {
        const { inflation: t } = await r.Inflation({});
        return (0, Gt.decodeCosmosSdkDecFromProto)(t);
      },
      annualProvisions: async () => {
        const { annualProvisions: t } = await r.AnnualProvisions({});
        return (0, Gt.decodeCosmosSdkDecFromProto)(t);
      }
    }
  };
}
Ns.setupMintExtension = WR;
var Pi = {};
Object.defineProperty(Pi, "__esModule", { value: !0 });
Pi.createSlashingAminoConverters = Pi.isAminoMsgUnjail = void 0;
function QR(e) {
  return e.type === "cosmos-sdk/MsgUnjail";
}
Pi.isAminoMsgUnjail = QR;
function FR() {
  throw new Error("Not implemented");
}
Pi.createSlashingAminoConverters = FR;
var _s = {}, Lh = {}, Jt = {};
Object.defineProperty(Jt, "__esModule", { value: !0 });
Jt.Params = Jt.ValidatorSigningInfo = Jt.protobufPackage = void 0;
const ha = Je, Pr = vn, qr = re, Ce = ie;
Jt.protobufPackage = "cosmos.slashing.v1beta1";
function Au() {
  return {
    address: "",
    startHeight: BigInt(0),
    indexOffset: BigInt(0),
    jailedUntil: ha.Timestamp.fromPartial({}),
    tombstoned: !1,
    missedBlocksCounter: BigInt(0)
  };
}
Jt.ValidatorSigningInfo = {
  typeUrl: "/cosmos.slashing.v1beta1.ValidatorSigningInfo",
  encode(e, n = qr.BinaryWriter.create()) {
    return e.address !== "" && n.uint32(10).string(e.address), e.startHeight !== BigInt(0) && n.uint32(16).int64(e.startHeight), e.indexOffset !== BigInt(0) && n.uint32(24).int64(e.indexOffset), e.jailedUntil !== void 0 && ha.Timestamp.encode(e.jailedUntil, n.uint32(34).fork()).ldelim(), e.tombstoned === !0 && n.uint32(40).bool(e.tombstoned), e.missedBlocksCounter !== BigInt(0) && n.uint32(48).int64(e.missedBlocksCounter), n;
  },
  decode(e, n) {
    const r = e instanceof qr.BinaryReader ? e : new qr.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = Au();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.address = r.string();
          break;
        case 2:
          i.startHeight = r.int64();
          break;
        case 3:
          i.indexOffset = r.int64();
          break;
        case 4:
          i.jailedUntil = ha.Timestamp.decode(r, r.uint32());
          break;
        case 5:
          i.tombstoned = r.bool();
          break;
        case 6:
          i.missedBlocksCounter = r.int64();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = Au();
    return (0, Ce.isSet)(e.address) && (n.address = String(e.address)), (0, Ce.isSet)(e.startHeight) && (n.startHeight = BigInt(e.startHeight.toString())), (0, Ce.isSet)(e.indexOffset) && (n.indexOffset = BigInt(e.indexOffset.toString())), (0, Ce.isSet)(e.jailedUntil) && (n.jailedUntil = (0, Ce.fromJsonTimestamp)(e.jailedUntil)), (0, Ce.isSet)(e.tombstoned) && (n.tombstoned = !!e.tombstoned), (0, Ce.isSet)(e.missedBlocksCounter) && (n.missedBlocksCounter = BigInt(e.missedBlocksCounter.toString())), n;
  },
  toJSON(e) {
    const n = {};
    return e.address !== void 0 && (n.address = e.address), e.startHeight !== void 0 && (n.startHeight = (e.startHeight || BigInt(0)).toString()), e.indexOffset !== void 0 && (n.indexOffset = (e.indexOffset || BigInt(0)).toString()), e.jailedUntil !== void 0 && (n.jailedUntil = (0, Ce.fromTimestamp)(e.jailedUntil).toISOString()), e.tombstoned !== void 0 && (n.tombstoned = e.tombstoned), e.missedBlocksCounter !== void 0 && (n.missedBlocksCounter = (e.missedBlocksCounter || BigInt(0)).toString()), n;
  },
  fromPartial(e) {
    const n = Au();
    return n.address = e.address ?? "", e.startHeight !== void 0 && e.startHeight !== null && (n.startHeight = BigInt(e.startHeight.toString())), e.indexOffset !== void 0 && e.indexOffset !== null && (n.indexOffset = BigInt(e.indexOffset.toString())), e.jailedUntil !== void 0 && e.jailedUntil !== null && (n.jailedUntil = ha.Timestamp.fromPartial(e.jailedUntil)), n.tombstoned = e.tombstoned ?? !1, e.missedBlocksCounter !== void 0 && e.missedBlocksCounter !== null && (n.missedBlocksCounter = BigInt(e.missedBlocksCounter.toString())), n;
  }
};
function Iu() {
  return {
    signedBlocksWindow: BigInt(0),
    minSignedPerWindow: new Uint8Array(),
    downtimeJailDuration: Pr.Duration.fromPartial({}),
    slashFractionDoubleSign: new Uint8Array(),
    slashFractionDowntime: new Uint8Array()
  };
}
Jt.Params = {
  typeUrl: "/cosmos.slashing.v1beta1.Params",
  encode(e, n = qr.BinaryWriter.create()) {
    return e.signedBlocksWindow !== BigInt(0) && n.uint32(8).int64(e.signedBlocksWindow), e.minSignedPerWindow.length !== 0 && n.uint32(18).bytes(e.minSignedPerWindow), e.downtimeJailDuration !== void 0 && Pr.Duration.encode(e.downtimeJailDuration, n.uint32(26).fork()).ldelim(), e.slashFractionDoubleSign.length !== 0 && n.uint32(34).bytes(e.slashFractionDoubleSign), e.slashFractionDowntime.length !== 0 && n.uint32(42).bytes(e.slashFractionDowntime), n;
  },
  decode(e, n) {
    const r = e instanceof qr.BinaryReader ? e : new qr.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = Iu();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.signedBlocksWindow = r.int64();
          break;
        case 2:
          i.minSignedPerWindow = r.bytes();
          break;
        case 3:
          i.downtimeJailDuration = Pr.Duration.decode(r, r.uint32());
          break;
        case 4:
          i.slashFractionDoubleSign = r.bytes();
          break;
        case 5:
          i.slashFractionDowntime = r.bytes();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = Iu();
    return (0, Ce.isSet)(e.signedBlocksWindow) && (n.signedBlocksWindow = BigInt(e.signedBlocksWindow.toString())), (0, Ce.isSet)(e.minSignedPerWindow) && (n.minSignedPerWindow = (0, Ce.bytesFromBase64)(e.minSignedPerWindow)), (0, Ce.isSet)(e.downtimeJailDuration) && (n.downtimeJailDuration = Pr.Duration.fromJSON(e.downtimeJailDuration)), (0, Ce.isSet)(e.slashFractionDoubleSign) && (n.slashFractionDoubleSign = (0, Ce.bytesFromBase64)(e.slashFractionDoubleSign)), (0, Ce.isSet)(e.slashFractionDowntime) && (n.slashFractionDowntime = (0, Ce.bytesFromBase64)(e.slashFractionDowntime)), n;
  },
  toJSON(e) {
    const n = {};
    return e.signedBlocksWindow !== void 0 && (n.signedBlocksWindow = (e.signedBlocksWindow || BigInt(0)).toString()), e.minSignedPerWindow !== void 0 && (n.minSignedPerWindow = (0, Ce.base64FromBytes)(e.minSignedPerWindow !== void 0 ? e.minSignedPerWindow : new Uint8Array())), e.downtimeJailDuration !== void 0 && (n.downtimeJailDuration = e.downtimeJailDuration ? Pr.Duration.toJSON(e.downtimeJailDuration) : void 0), e.slashFractionDoubleSign !== void 0 && (n.slashFractionDoubleSign = (0, Ce.base64FromBytes)(e.slashFractionDoubleSign !== void 0 ? e.slashFractionDoubleSign : new Uint8Array())), e.slashFractionDowntime !== void 0 && (n.slashFractionDowntime = (0, Ce.base64FromBytes)(e.slashFractionDowntime !== void 0 ? e.slashFractionDowntime : new Uint8Array())), n;
  },
  fromPartial(e) {
    const n = Iu();
    return e.signedBlocksWindow !== void 0 && e.signedBlocksWindow !== null && (n.signedBlocksWindow = BigInt(e.signedBlocksWindow.toString())), n.minSignedPerWindow = e.minSignedPerWindow ?? new Uint8Array(), e.downtimeJailDuration !== void 0 && e.downtimeJailDuration !== null && (n.downtimeJailDuration = Pr.Duration.fromPartial(e.downtimeJailDuration)), n.slashFractionDoubleSign = e.slashFractionDoubleSign ?? new Uint8Array(), n.slashFractionDowntime = e.slashFractionDowntime ?? new Uint8Array(), n;
  }
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QuerySigningInfosResponse = e.QuerySigningInfosRequest = e.QuerySigningInfoResponse = e.QuerySigningInfoRequest = e.QueryParamsResponse = e.QueryParamsRequest = e.protobufPackage = void 0;
  const n = Ae, r = Jt, t = re, i = ie;
  e.protobufPackage = "cosmos.slashing.v1beta1";
  function f() {
    return {};
  }
  e.QueryParamsRequest = {
    typeUrl: "/cosmos.slashing.v1beta1.QueryParamsRequest",
    encode(p, m = t.BinaryWriter.create()) {
      return m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = f();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      return f();
    },
    toJSON(p) {
      return {};
    },
    fromPartial(p) {
      return f();
    }
  };
  function S() {
    return {
      params: r.Params.fromPartial({})
    };
  }
  e.QueryParamsResponse = {
    typeUrl: "/cosmos.slashing.v1beta1.QueryParamsResponse",
    encode(p, m = t.BinaryWriter.create()) {
      return p.params !== void 0 && r.Params.encode(p.params, m.uint32(10).fork()).ldelim(), m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = S();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.params = r.Params.decode(v, v.uint32());
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = S();
      return (0, i.isSet)(p.params) && (m.params = r.Params.fromJSON(p.params)), m;
    },
    toJSON(p) {
      const m = {};
      return p.params !== void 0 && (m.params = p.params ? r.Params.toJSON(p.params) : void 0), m;
    },
    fromPartial(p) {
      const m = S();
      return p.params !== void 0 && p.params !== null && (m.params = r.Params.fromPartial(p.params)), m;
    }
  };
  function w() {
    return {
      consAddress: ""
    };
  }
  e.QuerySigningInfoRequest = {
    typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfoRequest",
    encode(p, m = t.BinaryWriter.create()) {
      return p.consAddress !== "" && m.uint32(10).string(p.consAddress), m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = w();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.consAddress = v.string();
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = w();
      return (0, i.isSet)(p.consAddress) && (m.consAddress = String(p.consAddress)), m;
    },
    toJSON(p) {
      const m = {};
      return p.consAddress !== void 0 && (m.consAddress = p.consAddress), m;
    },
    fromPartial(p) {
      const m = w();
      return m.consAddress = p.consAddress ?? "", m;
    }
  };
  function T() {
    return {
      valSigningInfo: r.ValidatorSigningInfo.fromPartial({})
    };
  }
  e.QuerySigningInfoResponse = {
    typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfoResponse",
    encode(p, m = t.BinaryWriter.create()) {
      return p.valSigningInfo !== void 0 && r.ValidatorSigningInfo.encode(p.valSigningInfo, m.uint32(10).fork()).ldelim(), m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = T();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.valSigningInfo = r.ValidatorSigningInfo.decode(v, v.uint32());
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = T();
      return (0, i.isSet)(p.valSigningInfo) && (m.valSigningInfo = r.ValidatorSigningInfo.fromJSON(p.valSigningInfo)), m;
    },
    toJSON(p) {
      const m = {};
      return p.valSigningInfo !== void 0 && (m.valSigningInfo = p.valSigningInfo ? r.ValidatorSigningInfo.toJSON(p.valSigningInfo) : void 0), m;
    },
    fromPartial(p) {
      const m = T();
      return p.valSigningInfo !== void 0 && p.valSigningInfo !== null && (m.valSigningInfo = r.ValidatorSigningInfo.fromPartial(p.valSigningInfo)), m;
    }
  };
  function J() {
    return {
      pagination: void 0
    };
  }
  e.QuerySigningInfosRequest = {
    typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfosRequest",
    encode(p, m = t.BinaryWriter.create()) {
      return p.pagination !== void 0 && n.PageRequest.encode(p.pagination, m.uint32(10).fork()).ldelim(), m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = J();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.pagination = n.PageRequest.decode(v, v.uint32());
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = J();
      return (0, i.isSet)(p.pagination) && (m.pagination = n.PageRequest.fromJSON(p.pagination)), m;
    },
    toJSON(p) {
      const m = {};
      return p.pagination !== void 0 && (m.pagination = p.pagination ? n.PageRequest.toJSON(p.pagination) : void 0), m;
    },
    fromPartial(p) {
      const m = J();
      return p.pagination !== void 0 && p.pagination !== null && (m.pagination = n.PageRequest.fromPartial(p.pagination)), m;
    }
  };
  function C() {
    return {
      info: [],
      pagination: void 0
    };
  }
  e.QuerySigningInfosResponse = {
    typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfosResponse",
    encode(p, m = t.BinaryWriter.create()) {
      for (const v of p.info)
        r.ValidatorSigningInfo.encode(v, m.uint32(10).fork()).ldelim();
      return p.pagination !== void 0 && n.PageResponse.encode(p.pagination, m.uint32(18).fork()).ldelim(), m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = C();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.info.push(r.ValidatorSigningInfo.decode(v, v.uint32()));
            break;
          case 2:
            d.pagination = n.PageResponse.decode(v, v.uint32());
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = C();
      return Array.isArray(p == null ? void 0 : p.info) && (m.info = p.info.map((v) => r.ValidatorSigningInfo.fromJSON(v))), (0, i.isSet)(p.pagination) && (m.pagination = n.PageResponse.fromJSON(p.pagination)), m;
    },
    toJSON(p) {
      const m = {};
      return p.info ? m.info = p.info.map((v) => v ? r.ValidatorSigningInfo.toJSON(v) : void 0) : m.info = [], p.pagination !== void 0 && (m.pagination = p.pagination ? n.PageResponse.toJSON(p.pagination) : void 0), m;
    },
    fromPartial(p) {
      var v;
      const m = C();
      return m.info = ((v = p.info) == null ? void 0 : v.map((a) => r.ValidatorSigningInfo.fromPartial(a))) || [], p.pagination !== void 0 && p.pagination !== null && (m.pagination = n.PageResponse.fromPartial(p.pagination)), m;
    }
  };
  class R {
    constructor(m) {
      this.rpc = m, this.Params = this.Params.bind(this), this.SigningInfo = this.SigningInfo.bind(this), this.SigningInfos = this.SigningInfos.bind(this);
    }
    Params(m = {}) {
      const v = e.QueryParamsRequest.encode(m).finish();
      return this.rpc.request("cosmos.slashing.v1beta1.Query", "Params", v).then((d) => e.QueryParamsResponse.decode(new t.BinaryReader(d)));
    }
    SigningInfo(m) {
      const v = e.QuerySigningInfoRequest.encode(m).finish();
      return this.rpc.request("cosmos.slashing.v1beta1.Query", "SigningInfo", v).then((d) => e.QuerySigningInfoResponse.decode(new t.BinaryReader(d)));
    }
    SigningInfos(m = {
      pagination: n.PageRequest.fromPartial({})
    }) {
      const v = e.QuerySigningInfosRequest.encode(m).finish();
      return this.rpc.request("cosmos.slashing.v1beta1.Query", "SigningInfos", v).then((d) => e.QuerySigningInfosResponse.decode(new t.BinaryReader(d)));
    }
  }
  e.QueryClientImpl = R;
})(Lh);
Object.defineProperty(_s, "__esModule", { value: !0 });
_s.setupSlashingExtension = void 0;
const $R = Lh, Rf = Ye;
function LR(e) {
  const n = (0, Rf.createProtobufRpcClient)(e), r = new $R.QueryClientImpl(n);
  return {
    slashing: {
      signingInfo: async (t) => await r.SigningInfo({
        consAddress: t
      }),
      signingInfos: async (t) => await r.SigningInfos({
        pagination: (0, Rf.createPagination)(t)
      }),
      params: async () => await r.Params({})
    }
  };
}
_s.setupSlashingExtension = LR;
var $e = {};
Object.defineProperty($e, "__esModule", { value: !0 });
$e.createStakingAminoConverters = $e.isAminoMsgUndelegate = $e.isAminoMsgBeginRedelegate = $e.isAminoMsgDelegate = $e.isAminoMsgEditValidator = $e.isAminoMsgCreateValidator = $e.protoDecimalToJson = void 0;
const Gh = Ie, Bf = Ft, gt = Te;
function so(e) {
  const n = Gh.Decimal.fromAtomics(e, 18), [r, t] = n.toString().split(".");
  return `${r}.${(t ?? "").padEnd(18, "0")}`;
}
$e.protoDecimalToJson = so;
function ea(e) {
  return Gh.Decimal.fromUserInput(e, 18).atomics;
}
function GR(e) {
  return e.type === "cosmos-sdk/MsgCreateValidator";
}
$e.isAminoMsgCreateValidator = GR;
function KR(e) {
  return e.type === "cosmos-sdk/MsgEditValidator";
}
$e.isAminoMsgEditValidator = KR;
function zR(e) {
  return e.type === "cosmos-sdk/MsgDelegate";
}
$e.isAminoMsgDelegate = zR;
function xR(e) {
  return e.type === "cosmos-sdk/MsgBeginRedelegate";
}
$e.isAminoMsgBeginRedelegate = xR;
function ZR(e) {
  return e.type === "cosmos-sdk/MsgUndelegate";
}
$e.isAminoMsgUndelegate = ZR;
function YR() {
  return {
    "/cosmos.staking.v1beta1.MsgBeginRedelegate": {
      aminoType: "cosmos-sdk/MsgBeginRedelegate",
      toAmino: ({ delegatorAddress: e, validatorSrcAddress: n, validatorDstAddress: r, amount: t }) => ((0, gt.assertDefinedAndNotNull)(t, "missing amount"), {
        delegator_address: e,
        validator_src_address: n,
        validator_dst_address: r,
        amount: t
      }),
      fromAmino: ({ delegator_address: e, validator_src_address: n, validator_dst_address: r, amount: t }) => ({
        delegatorAddress: e,
        validatorSrcAddress: n,
        validatorDstAddress: r,
        amount: t
      })
    },
    "/cosmos.staking.v1beta1.MsgCreateValidator": {
      aminoType: "cosmos-sdk/MsgCreateValidator",
      toAmino: ({ description: e, commission: n, minSelfDelegation: r, delegatorAddress: t, validatorAddress: i, pubkey: f, value: S }) => ((0, gt.assertDefinedAndNotNull)(e, "missing description"), (0, gt.assertDefinedAndNotNull)(n, "missing commission"), (0, gt.assertDefinedAndNotNull)(f, "missing pubkey"), (0, gt.assertDefinedAndNotNull)(S, "missing value"), {
        description: {
          moniker: e.moniker,
          identity: e.identity,
          website: e.website,
          security_contact: e.securityContact,
          details: e.details
        },
        commission: {
          rate: so(n.rate),
          max_rate: so(n.maxRate),
          max_change_rate: so(n.maxChangeRate)
        },
        min_self_delegation: r,
        delegator_address: t,
        validator_address: i,
        pubkey: (0, Bf.decodePubkey)(f),
        value: S
      }),
      fromAmino: ({ description: e, commission: n, min_self_delegation: r, delegator_address: t, validator_address: i, pubkey: f, value: S }) => ({
        description: {
          moniker: e.moniker,
          identity: e.identity,
          website: e.website,
          securityContact: e.security_contact,
          details: e.details
        },
        commission: {
          rate: ea(n.rate),
          maxRate: ea(n.max_rate),
          maxChangeRate: ea(n.max_change_rate)
        },
        minSelfDelegation: r,
        delegatorAddress: t,
        validatorAddress: i,
        pubkey: (0, Bf.encodePubkey)(f),
        value: S
      })
    },
    "/cosmos.staking.v1beta1.MsgDelegate": {
      aminoType: "cosmos-sdk/MsgDelegate",
      toAmino: ({ delegatorAddress: e, validatorAddress: n, amount: r }) => ((0, gt.assertDefinedAndNotNull)(r, "missing amount"), {
        delegator_address: e,
        validator_address: n,
        amount: r
      }),
      fromAmino: ({ delegator_address: e, validator_address: n, amount: r }) => ({
        delegatorAddress: e,
        validatorAddress: n,
        amount: r
      })
    },
    "/cosmos.staking.v1beta1.MsgEditValidator": {
      aminoType: "cosmos-sdk/MsgEditValidator",
      toAmino: ({ description: e, commissionRate: n, minSelfDelegation: r, validatorAddress: t }) => ((0, gt.assertDefinedAndNotNull)(e, "missing description"), {
        description: {
          moniker: e.moniker,
          identity: e.identity,
          website: e.website,
          security_contact: e.securityContact,
          details: e.details
        },
        // empty string in the protobuf document means "do not change"
        commission_rate: n ? so(n) : void 0,
        // empty string in the protobuf document means "do not change"
        min_self_delegation: r || void 0,
        validator_address: t
      }),
      fromAmino: ({ description: e, commission_rate: n, min_self_delegation: r, validator_address: t }) => ({
        description: {
          moniker: e.moniker,
          identity: e.identity,
          website: e.website,
          securityContact: e.security_contact,
          details: e.details
        },
        // empty string in the protobuf document means "do not change"
        commissionRate: n ? ea(n) : "",
        // empty string in the protobuf document means "do not change"
        minSelfDelegation: r ?? "",
        validatorAddress: t
      })
    },
    "/cosmos.staking.v1beta1.MsgUndelegate": {
      aminoType: "cosmos-sdk/MsgUndelegate",
      toAmino: ({ delegatorAddress: e, validatorAddress: n, amount: r }) => ((0, gt.assertDefinedAndNotNull)(r, "missing amount"), {
        delegator_address: e,
        validator_address: n,
        amount: r
      }),
      fromAmino: ({ delegator_address: e, validator_address: n, amount: r }) => ({
        delegatorAddress: e,
        validatorAddress: n,
        amount: r
      })
    }
  };
}
$e.createStakingAminoConverters = YR;
var sn = {}, Xc = {}, jc = {}, el = {}, Kh = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.HashedParams = e.VersionParams = e.ValidatorParams = e.EvidenceParams = e.BlockParams = e.ConsensusParams = e.protobufPackage = void 0;
  const n = vn, r = re, t = ie;
  e.protobufPackage = "tendermint.types";
  function i() {
    return {
      block: void 0,
      evidence: void 0,
      validator: void 0,
      version: void 0
    };
  }
  e.ConsensusParams = {
    typeUrl: "/tendermint.types.ConsensusParams",
    encode(C, R = r.BinaryWriter.create()) {
      return C.block !== void 0 && e.BlockParams.encode(C.block, R.uint32(10).fork()).ldelim(), C.evidence !== void 0 && e.EvidenceParams.encode(C.evidence, R.uint32(18).fork()).ldelim(), C.validator !== void 0 && e.ValidatorParams.encode(C.validator, R.uint32(26).fork()).ldelim(), C.version !== void 0 && e.VersionParams.encode(C.version, R.uint32(34).fork()).ldelim(), R;
    },
    decode(C, R) {
      const p = C instanceof r.BinaryReader ? C : new r.BinaryReader(C);
      let m = R === void 0 ? p.len : p.pos + R;
      const v = i();
      for (; p.pos < m; ) {
        const a = p.uint32();
        switch (a >>> 3) {
          case 1:
            v.block = e.BlockParams.decode(p, p.uint32());
            break;
          case 2:
            v.evidence = e.EvidenceParams.decode(p, p.uint32());
            break;
          case 3:
            v.validator = e.ValidatorParams.decode(p, p.uint32());
            break;
          case 4:
            v.version = e.VersionParams.decode(p, p.uint32());
            break;
          default:
            p.skipType(a & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(C) {
      const R = i();
      return (0, t.isSet)(C.block) && (R.block = e.BlockParams.fromJSON(C.block)), (0, t.isSet)(C.evidence) && (R.evidence = e.EvidenceParams.fromJSON(C.evidence)), (0, t.isSet)(C.validator) && (R.validator = e.ValidatorParams.fromJSON(C.validator)), (0, t.isSet)(C.version) && (R.version = e.VersionParams.fromJSON(C.version)), R;
    },
    toJSON(C) {
      const R = {};
      return C.block !== void 0 && (R.block = C.block ? e.BlockParams.toJSON(C.block) : void 0), C.evidence !== void 0 && (R.evidence = C.evidence ? e.EvidenceParams.toJSON(C.evidence) : void 0), C.validator !== void 0 && (R.validator = C.validator ? e.ValidatorParams.toJSON(C.validator) : void 0), C.version !== void 0 && (R.version = C.version ? e.VersionParams.toJSON(C.version) : void 0), R;
    },
    fromPartial(C) {
      const R = i();
      return C.block !== void 0 && C.block !== null && (R.block = e.BlockParams.fromPartial(C.block)), C.evidence !== void 0 && C.evidence !== null && (R.evidence = e.EvidenceParams.fromPartial(C.evidence)), C.validator !== void 0 && C.validator !== null && (R.validator = e.ValidatorParams.fromPartial(C.validator)), C.version !== void 0 && C.version !== null && (R.version = e.VersionParams.fromPartial(C.version)), R;
    }
  };
  function f() {
    return {
      maxBytes: BigInt(0),
      maxGas: BigInt(0)
    };
  }
  e.BlockParams = {
    typeUrl: "/tendermint.types.BlockParams",
    encode(C, R = r.BinaryWriter.create()) {
      return C.maxBytes !== BigInt(0) && R.uint32(8).int64(C.maxBytes), C.maxGas !== BigInt(0) && R.uint32(16).int64(C.maxGas), R;
    },
    decode(C, R) {
      const p = C instanceof r.BinaryReader ? C : new r.BinaryReader(C);
      let m = R === void 0 ? p.len : p.pos + R;
      const v = f();
      for (; p.pos < m; ) {
        const a = p.uint32();
        switch (a >>> 3) {
          case 1:
            v.maxBytes = p.int64();
            break;
          case 2:
            v.maxGas = p.int64();
            break;
          default:
            p.skipType(a & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(C) {
      const R = f();
      return (0, t.isSet)(C.maxBytes) && (R.maxBytes = BigInt(C.maxBytes.toString())), (0, t.isSet)(C.maxGas) && (R.maxGas = BigInt(C.maxGas.toString())), R;
    },
    toJSON(C) {
      const R = {};
      return C.maxBytes !== void 0 && (R.maxBytes = (C.maxBytes || BigInt(0)).toString()), C.maxGas !== void 0 && (R.maxGas = (C.maxGas || BigInt(0)).toString()), R;
    },
    fromPartial(C) {
      const R = f();
      return C.maxBytes !== void 0 && C.maxBytes !== null && (R.maxBytes = BigInt(C.maxBytes.toString())), C.maxGas !== void 0 && C.maxGas !== null && (R.maxGas = BigInt(C.maxGas.toString())), R;
    }
  };
  function S() {
    return {
      maxAgeNumBlocks: BigInt(0),
      maxAgeDuration: n.Duration.fromPartial({}),
      maxBytes: BigInt(0)
    };
  }
  e.EvidenceParams = {
    typeUrl: "/tendermint.types.EvidenceParams",
    encode(C, R = r.BinaryWriter.create()) {
      return C.maxAgeNumBlocks !== BigInt(0) && R.uint32(8).int64(C.maxAgeNumBlocks), C.maxAgeDuration !== void 0 && n.Duration.encode(C.maxAgeDuration, R.uint32(18).fork()).ldelim(), C.maxBytes !== BigInt(0) && R.uint32(24).int64(C.maxBytes), R;
    },
    decode(C, R) {
      const p = C instanceof r.BinaryReader ? C : new r.BinaryReader(C);
      let m = R === void 0 ? p.len : p.pos + R;
      const v = S();
      for (; p.pos < m; ) {
        const a = p.uint32();
        switch (a >>> 3) {
          case 1:
            v.maxAgeNumBlocks = p.int64();
            break;
          case 2:
            v.maxAgeDuration = n.Duration.decode(p, p.uint32());
            break;
          case 3:
            v.maxBytes = p.int64();
            break;
          default:
            p.skipType(a & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(C) {
      const R = S();
      return (0, t.isSet)(C.maxAgeNumBlocks) && (R.maxAgeNumBlocks = BigInt(C.maxAgeNumBlocks.toString())), (0, t.isSet)(C.maxAgeDuration) && (R.maxAgeDuration = n.Duration.fromJSON(C.maxAgeDuration)), (0, t.isSet)(C.maxBytes) && (R.maxBytes = BigInt(C.maxBytes.toString())), R;
    },
    toJSON(C) {
      const R = {};
      return C.maxAgeNumBlocks !== void 0 && (R.maxAgeNumBlocks = (C.maxAgeNumBlocks || BigInt(0)).toString()), C.maxAgeDuration !== void 0 && (R.maxAgeDuration = C.maxAgeDuration ? n.Duration.toJSON(C.maxAgeDuration) : void 0), C.maxBytes !== void 0 && (R.maxBytes = (C.maxBytes || BigInt(0)).toString()), R;
    },
    fromPartial(C) {
      const R = S();
      return C.maxAgeNumBlocks !== void 0 && C.maxAgeNumBlocks !== null && (R.maxAgeNumBlocks = BigInt(C.maxAgeNumBlocks.toString())), C.maxAgeDuration !== void 0 && C.maxAgeDuration !== null && (R.maxAgeDuration = n.Duration.fromPartial(C.maxAgeDuration)), C.maxBytes !== void 0 && C.maxBytes !== null && (R.maxBytes = BigInt(C.maxBytes.toString())), R;
    }
  };
  function w() {
    return {
      pubKeyTypes: []
    };
  }
  e.ValidatorParams = {
    typeUrl: "/tendermint.types.ValidatorParams",
    encode(C, R = r.BinaryWriter.create()) {
      for (const p of C.pubKeyTypes)
        R.uint32(10).string(p);
      return R;
    },
    decode(C, R) {
      const p = C instanceof r.BinaryReader ? C : new r.BinaryReader(C);
      let m = R === void 0 ? p.len : p.pos + R;
      const v = w();
      for (; p.pos < m; ) {
        const a = p.uint32();
        switch (a >>> 3) {
          case 1:
            v.pubKeyTypes.push(p.string());
            break;
          default:
            p.skipType(a & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(C) {
      const R = w();
      return Array.isArray(C == null ? void 0 : C.pubKeyTypes) && (R.pubKeyTypes = C.pubKeyTypes.map((p) => String(p))), R;
    },
    toJSON(C) {
      const R = {};
      return C.pubKeyTypes ? R.pubKeyTypes = C.pubKeyTypes.map((p) => p) : R.pubKeyTypes = [], R;
    },
    fromPartial(C) {
      var p;
      const R = w();
      return R.pubKeyTypes = ((p = C.pubKeyTypes) == null ? void 0 : p.map((m) => m)) || [], R;
    }
  };
  function T() {
    return {
      app: BigInt(0)
    };
  }
  e.VersionParams = {
    typeUrl: "/tendermint.types.VersionParams",
    encode(C, R = r.BinaryWriter.create()) {
      return C.app !== BigInt(0) && R.uint32(8).uint64(C.app), R;
    },
    decode(C, R) {
      const p = C instanceof r.BinaryReader ? C : new r.BinaryReader(C);
      let m = R === void 0 ? p.len : p.pos + R;
      const v = T();
      for (; p.pos < m; ) {
        const a = p.uint32();
        switch (a >>> 3) {
          case 1:
            v.app = p.uint64();
            break;
          default:
            p.skipType(a & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(C) {
      const R = T();
      return (0, t.isSet)(C.app) && (R.app = BigInt(C.app.toString())), R;
    },
    toJSON(C) {
      const R = {};
      return C.app !== void 0 && (R.app = (C.app || BigInt(0)).toString()), R;
    },
    fromPartial(C) {
      const R = T();
      return C.app !== void 0 && C.app !== null && (R.app = BigInt(C.app.toString())), R;
    }
  };
  function J() {
    return {
      blockMaxBytes: BigInt(0),
      blockMaxGas: BigInt(0)
    };
  }
  e.HashedParams = {
    typeUrl: "/tendermint.types.HashedParams",
    encode(C, R = r.BinaryWriter.create()) {
      return C.blockMaxBytes !== BigInt(0) && R.uint32(8).int64(C.blockMaxBytes), C.blockMaxGas !== BigInt(0) && R.uint32(16).int64(C.blockMaxGas), R;
    },
    decode(C, R) {
      const p = C instanceof r.BinaryReader ? C : new r.BinaryReader(C);
      let m = R === void 0 ? p.len : p.pos + R;
      const v = J();
      for (; p.pos < m; ) {
        const a = p.uint32();
        switch (a >>> 3) {
          case 1:
            v.blockMaxBytes = p.int64();
            break;
          case 2:
            v.blockMaxGas = p.int64();
            break;
          default:
            p.skipType(a & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(C) {
      const R = J();
      return (0, t.isSet)(C.blockMaxBytes) && (R.blockMaxBytes = BigInt(C.blockMaxBytes.toString())), (0, t.isSet)(C.blockMaxGas) && (R.blockMaxGas = BigInt(C.blockMaxGas.toString())), R;
    },
    toJSON(C) {
      const R = {};
      return C.blockMaxBytes !== void 0 && (R.blockMaxBytes = (C.blockMaxBytes || BigInt(0)).toString()), C.blockMaxGas !== void 0 && (R.blockMaxGas = (C.blockMaxGas || BigInt(0)).toString()), R;
    },
    fromPartial(C) {
      const R = J();
      return C.blockMaxBytes !== void 0 && C.blockMaxBytes !== null && (R.blockMaxBytes = BigInt(C.blockMaxBytes.toString())), C.blockMaxGas !== void 0 && C.blockMaxGas !== null && (R.blockMaxGas = BigInt(C.blockMaxGas.toString())), R;
    }
  };
})(Kh);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ResponsePrepareProposal = e.ResponseApplySnapshotChunk = e.ResponseLoadSnapshotChunk = e.ResponseOfferSnapshot = e.ResponseListSnapshots = e.ResponseCommit = e.ResponseEndBlock = e.ResponseDeliverTx = e.ResponseCheckTx = e.ResponseBeginBlock = e.ResponseQuery = e.ResponseInitChain = e.ResponseInfo = e.ResponseFlush = e.ResponseEcho = e.ResponseException = e.Response = e.RequestProcessProposal = e.RequestPrepareProposal = e.RequestApplySnapshotChunk = e.RequestLoadSnapshotChunk = e.RequestOfferSnapshot = e.RequestListSnapshots = e.RequestCommit = e.RequestEndBlock = e.RequestDeliverTx = e.RequestCheckTx = e.RequestBeginBlock = e.RequestQuery = e.RequestInitChain = e.RequestInfo = e.RequestFlush = e.RequestEcho = e.Request = e.misbehaviorTypeToJSON = e.misbehaviorTypeFromJSON = e.MisbehaviorType = e.responseProcessProposal_ProposalStatusToJSON = e.responseProcessProposal_ProposalStatusFromJSON = e.ResponseProcessProposal_ProposalStatus = e.responseApplySnapshotChunk_ResultToJSON = e.responseApplySnapshotChunk_ResultFromJSON = e.ResponseApplySnapshotChunk_Result = e.responseOfferSnapshot_ResultToJSON = e.responseOfferSnapshot_ResultFromJSON = e.ResponseOfferSnapshot_Result = e.checkTxTypeToJSON = e.checkTxTypeFromJSON = e.CheckTxType = e.protobufPackage = void 0, e.ABCIApplicationClientImpl = e.Snapshot = e.Misbehavior = e.ExtendedVoteInfo = e.VoteInfo = e.ValidatorUpdate = e.Validator = e.TxResult = e.EventAttribute = e.Event = e.ExtendedCommitInfo = e.CommitInfo = e.ResponseProcessProposal = void 0;
  const n = Je, r = Kh, t = ar, i = Yc, f = or, S = re, w = ie;
  e.protobufPackage = "tendermint.abci";
  var T;
  (function(c) {
    c[c.NEW = 0] = "NEW", c[c.RECHECK = 1] = "RECHECK", c[c.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(T || (e.CheckTxType = T = {}));
  function J(c) {
    switch (c) {
      case 0:
      case "NEW":
        return T.NEW;
      case 1:
      case "RECHECK":
        return T.RECHECK;
      case -1:
      case "UNRECOGNIZED":
      default:
        return T.UNRECOGNIZED;
    }
  }
  e.checkTxTypeFromJSON = J;
  function C(c) {
    switch (c) {
      case T.NEW:
        return "NEW";
      case T.RECHECK:
        return "RECHECK";
      case T.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.checkTxTypeToJSON = C;
  var R;
  (function(c) {
    c[c.UNKNOWN = 0] = "UNKNOWN", c[c.ACCEPT = 1] = "ACCEPT", c[c.ABORT = 2] = "ABORT", c[c.REJECT = 3] = "REJECT", c[c.REJECT_FORMAT = 4] = "REJECT_FORMAT", c[c.REJECT_SENDER = 5] = "REJECT_SENDER", c[c.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(R || (e.ResponseOfferSnapshot_Result = R = {}));
  function p(c) {
    switch (c) {
      case 0:
      case "UNKNOWN":
        return R.UNKNOWN;
      case 1:
      case "ACCEPT":
        return R.ACCEPT;
      case 2:
      case "ABORT":
        return R.ABORT;
      case 3:
      case "REJECT":
        return R.REJECT;
      case 4:
      case "REJECT_FORMAT":
        return R.REJECT_FORMAT;
      case 5:
      case "REJECT_SENDER":
        return R.REJECT_SENDER;
      case -1:
      case "UNRECOGNIZED":
      default:
        return R.UNRECOGNIZED;
    }
  }
  e.responseOfferSnapshot_ResultFromJSON = p;
  function m(c) {
    switch (c) {
      case R.UNKNOWN:
        return "UNKNOWN";
      case R.ACCEPT:
        return "ACCEPT";
      case R.ABORT:
        return "ABORT";
      case R.REJECT:
        return "REJECT";
      case R.REJECT_FORMAT:
        return "REJECT_FORMAT";
      case R.REJECT_SENDER:
        return "REJECT_SENDER";
      case R.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.responseOfferSnapshot_ResultToJSON = m;
  var v;
  (function(c) {
    c[c.UNKNOWN = 0] = "UNKNOWN", c[c.ACCEPT = 1] = "ACCEPT", c[c.ABORT = 2] = "ABORT", c[c.RETRY = 3] = "RETRY", c[c.RETRY_SNAPSHOT = 4] = "RETRY_SNAPSHOT", c[c.REJECT_SNAPSHOT = 5] = "REJECT_SNAPSHOT", c[c.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(v || (e.ResponseApplySnapshotChunk_Result = v = {}));
  function a(c) {
    switch (c) {
      case 0:
      case "UNKNOWN":
        return v.UNKNOWN;
      case 1:
      case "ACCEPT":
        return v.ACCEPT;
      case 2:
      case "ABORT":
        return v.ABORT;
      case 3:
      case "RETRY":
        return v.RETRY;
      case 4:
      case "RETRY_SNAPSHOT":
        return v.RETRY_SNAPSHOT;
      case 5:
      case "REJECT_SNAPSHOT":
        return v.REJECT_SNAPSHOT;
      case -1:
      case "UNRECOGNIZED":
      default:
        return v.UNRECOGNIZED;
    }
  }
  e.responseApplySnapshotChunk_ResultFromJSON = a;
  function d(c) {
    switch (c) {
      case v.UNKNOWN:
        return "UNKNOWN";
      case v.ACCEPT:
        return "ACCEPT";
      case v.ABORT:
        return "ABORT";
      case v.RETRY:
        return "RETRY";
      case v.RETRY_SNAPSHOT:
        return "RETRY_SNAPSHOT";
      case v.REJECT_SNAPSHOT:
        return "REJECT_SNAPSHOT";
      case v.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.responseApplySnapshotChunk_ResultToJSON = d;
  var y;
  (function(c) {
    c[c.UNKNOWN = 0] = "UNKNOWN", c[c.ACCEPT = 1] = "ACCEPT", c[c.REJECT = 2] = "REJECT", c[c.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(y || (e.ResponseProcessProposal_ProposalStatus = y = {}));
  function _(c) {
    switch (c) {
      case 0:
      case "UNKNOWN":
        return y.UNKNOWN;
      case 1:
      case "ACCEPT":
        return y.ACCEPT;
      case 2:
      case "REJECT":
        return y.REJECT;
      case -1:
      case "UNRECOGNIZED":
      default:
        return y.UNRECOGNIZED;
    }
  }
  e.responseProcessProposal_ProposalStatusFromJSON = _;
  function E(c) {
    switch (c) {
      case y.UNKNOWN:
        return "UNKNOWN";
      case y.ACCEPT:
        return "ACCEPT";
      case y.REJECT:
        return "REJECT";
      case y.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.responseProcessProposal_ProposalStatusToJSON = E;
  var U;
  (function(c) {
    c[c.UNKNOWN = 0] = "UNKNOWN", c[c.DUPLICATE_VOTE = 1] = "DUPLICATE_VOTE", c[c.LIGHT_CLIENT_ATTACK = 2] = "LIGHT_CLIENT_ATTACK", c[c.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(U || (e.MisbehaviorType = U = {}));
  function V(c) {
    switch (c) {
      case 0:
      case "UNKNOWN":
        return U.UNKNOWN;
      case 1:
      case "DUPLICATE_VOTE":
        return U.DUPLICATE_VOTE;
      case 2:
      case "LIGHT_CLIENT_ATTACK":
        return U.LIGHT_CLIENT_ATTACK;
      case -1:
      case "UNRECOGNIZED":
      default:
        return U.UNRECOGNIZED;
    }
  }
  e.misbehaviorTypeFromJSON = V;
  function o(c) {
    switch (c) {
      case U.UNKNOWN:
        return "UNKNOWN";
      case U.DUPLICATE_VOTE:
        return "DUPLICATE_VOTE";
      case U.LIGHT_CLIENT_ATTACK:
        return "LIGHT_CLIENT_ATTACK";
      case U.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.misbehaviorTypeToJSON = o;
  function h() {
    return {
      echo: void 0,
      flush: void 0,
      info: void 0,
      initChain: void 0,
      query: void 0,
      beginBlock: void 0,
      checkTx: void 0,
      deliverTx: void 0,
      endBlock: void 0,
      commit: void 0,
      listSnapshots: void 0,
      offerSnapshot: void 0,
      loadSnapshotChunk: void 0,
      applySnapshotChunk: void 0,
      prepareProposal: void 0,
      processProposal: void 0
    };
  }
  e.Request = {
    typeUrl: "/tendermint.abci.Request",
    encode(c, O = S.BinaryWriter.create()) {
      return c.echo !== void 0 && e.RequestEcho.encode(c.echo, O.uint32(10).fork()).ldelim(), c.flush !== void 0 && e.RequestFlush.encode(c.flush, O.uint32(18).fork()).ldelim(), c.info !== void 0 && e.RequestInfo.encode(c.info, O.uint32(26).fork()).ldelim(), c.initChain !== void 0 && e.RequestInitChain.encode(c.initChain, O.uint32(42).fork()).ldelim(), c.query !== void 0 && e.RequestQuery.encode(c.query, O.uint32(50).fork()).ldelim(), c.beginBlock !== void 0 && e.RequestBeginBlock.encode(c.beginBlock, O.uint32(58).fork()).ldelim(), c.checkTx !== void 0 && e.RequestCheckTx.encode(c.checkTx, O.uint32(66).fork()).ldelim(), c.deliverTx !== void 0 && e.RequestDeliverTx.encode(c.deliverTx, O.uint32(74).fork()).ldelim(), c.endBlock !== void 0 && e.RequestEndBlock.encode(c.endBlock, O.uint32(82).fork()).ldelim(), c.commit !== void 0 && e.RequestCommit.encode(c.commit, O.uint32(90).fork()).ldelim(), c.listSnapshots !== void 0 && e.RequestListSnapshots.encode(c.listSnapshots, O.uint32(98).fork()).ldelim(), c.offerSnapshot !== void 0 && e.RequestOfferSnapshot.encode(c.offerSnapshot, O.uint32(106).fork()).ldelim(), c.loadSnapshotChunk !== void 0 && e.RequestLoadSnapshotChunk.encode(c.loadSnapshotChunk, O.uint32(114).fork()).ldelim(), c.applySnapshotChunk !== void 0 && e.RequestApplySnapshotChunk.encode(c.applySnapshotChunk, O.uint32(122).fork()).ldelim(), c.prepareProposal !== void 0 && e.RequestPrepareProposal.encode(c.prepareProposal, O.uint32(130).fork()).ldelim(), c.processProposal !== void 0 && e.RequestProcessProposal.encode(c.processProposal, O.uint32(138).fork()).ldelim(), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = h();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.echo = e.RequestEcho.decode(M, M.uint32());
            break;
          case 2:
            F.flush = e.RequestFlush.decode(M, M.uint32());
            break;
          case 3:
            F.info = e.RequestInfo.decode(M, M.uint32());
            break;
          case 5:
            F.initChain = e.RequestInitChain.decode(M, M.uint32());
            break;
          case 6:
            F.query = e.RequestQuery.decode(M, M.uint32());
            break;
          case 7:
            F.beginBlock = e.RequestBeginBlock.decode(M, M.uint32());
            break;
          case 8:
            F.checkTx = e.RequestCheckTx.decode(M, M.uint32());
            break;
          case 9:
            F.deliverTx = e.RequestDeliverTx.decode(M, M.uint32());
            break;
          case 10:
            F.endBlock = e.RequestEndBlock.decode(M, M.uint32());
            break;
          case 11:
            F.commit = e.RequestCommit.decode(M, M.uint32());
            break;
          case 12:
            F.listSnapshots = e.RequestListSnapshots.decode(M, M.uint32());
            break;
          case 13:
            F.offerSnapshot = e.RequestOfferSnapshot.decode(M, M.uint32());
            break;
          case 14:
            F.loadSnapshotChunk = e.RequestLoadSnapshotChunk.decode(M, M.uint32());
            break;
          case 15:
            F.applySnapshotChunk = e.RequestApplySnapshotChunk.decode(M, M.uint32());
            break;
          case 16:
            F.prepareProposal = e.RequestPrepareProposal.decode(M, M.uint32());
            break;
          case 17:
            F.processProposal = e.RequestProcessProposal.decode(M, M.uint32());
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = h();
      return (0, w.isSet)(c.echo) && (O.echo = e.RequestEcho.fromJSON(c.echo)), (0, w.isSet)(c.flush) && (O.flush = e.RequestFlush.fromJSON(c.flush)), (0, w.isSet)(c.info) && (O.info = e.RequestInfo.fromJSON(c.info)), (0, w.isSet)(c.initChain) && (O.initChain = e.RequestInitChain.fromJSON(c.initChain)), (0, w.isSet)(c.query) && (O.query = e.RequestQuery.fromJSON(c.query)), (0, w.isSet)(c.beginBlock) && (O.beginBlock = e.RequestBeginBlock.fromJSON(c.beginBlock)), (0, w.isSet)(c.checkTx) && (O.checkTx = e.RequestCheckTx.fromJSON(c.checkTx)), (0, w.isSet)(c.deliverTx) && (O.deliverTx = e.RequestDeliverTx.fromJSON(c.deliverTx)), (0, w.isSet)(c.endBlock) && (O.endBlock = e.RequestEndBlock.fromJSON(c.endBlock)), (0, w.isSet)(c.commit) && (O.commit = e.RequestCommit.fromJSON(c.commit)), (0, w.isSet)(c.listSnapshots) && (O.listSnapshots = e.RequestListSnapshots.fromJSON(c.listSnapshots)), (0, w.isSet)(c.offerSnapshot) && (O.offerSnapshot = e.RequestOfferSnapshot.fromJSON(c.offerSnapshot)), (0, w.isSet)(c.loadSnapshotChunk) && (O.loadSnapshotChunk = e.RequestLoadSnapshotChunk.fromJSON(c.loadSnapshotChunk)), (0, w.isSet)(c.applySnapshotChunk) && (O.applySnapshotChunk = e.RequestApplySnapshotChunk.fromJSON(c.applySnapshotChunk)), (0, w.isSet)(c.prepareProposal) && (O.prepareProposal = e.RequestPrepareProposal.fromJSON(c.prepareProposal)), (0, w.isSet)(c.processProposal) && (O.processProposal = e.RequestProcessProposal.fromJSON(c.processProposal)), O;
    },
    toJSON(c) {
      const O = {};
      return c.echo !== void 0 && (O.echo = c.echo ? e.RequestEcho.toJSON(c.echo) : void 0), c.flush !== void 0 && (O.flush = c.flush ? e.RequestFlush.toJSON(c.flush) : void 0), c.info !== void 0 && (O.info = c.info ? e.RequestInfo.toJSON(c.info) : void 0), c.initChain !== void 0 && (O.initChain = c.initChain ? e.RequestInitChain.toJSON(c.initChain) : void 0), c.query !== void 0 && (O.query = c.query ? e.RequestQuery.toJSON(c.query) : void 0), c.beginBlock !== void 0 && (O.beginBlock = c.beginBlock ? e.RequestBeginBlock.toJSON(c.beginBlock) : void 0), c.checkTx !== void 0 && (O.checkTx = c.checkTx ? e.RequestCheckTx.toJSON(c.checkTx) : void 0), c.deliverTx !== void 0 && (O.deliverTx = c.deliverTx ? e.RequestDeliverTx.toJSON(c.deliverTx) : void 0), c.endBlock !== void 0 && (O.endBlock = c.endBlock ? e.RequestEndBlock.toJSON(c.endBlock) : void 0), c.commit !== void 0 && (O.commit = c.commit ? e.RequestCommit.toJSON(c.commit) : void 0), c.listSnapshots !== void 0 && (O.listSnapshots = c.listSnapshots ? e.RequestListSnapshots.toJSON(c.listSnapshots) : void 0), c.offerSnapshot !== void 0 && (O.offerSnapshot = c.offerSnapshot ? e.RequestOfferSnapshot.toJSON(c.offerSnapshot) : void 0), c.loadSnapshotChunk !== void 0 && (O.loadSnapshotChunk = c.loadSnapshotChunk ? e.RequestLoadSnapshotChunk.toJSON(c.loadSnapshotChunk) : void 0), c.applySnapshotChunk !== void 0 && (O.applySnapshotChunk = c.applySnapshotChunk ? e.RequestApplySnapshotChunk.toJSON(c.applySnapshotChunk) : void 0), c.prepareProposal !== void 0 && (O.prepareProposal = c.prepareProposal ? e.RequestPrepareProposal.toJSON(c.prepareProposal) : void 0), c.processProposal !== void 0 && (O.processProposal = c.processProposal ? e.RequestProcessProposal.toJSON(c.processProposal) : void 0), O;
    },
    fromPartial(c) {
      const O = h();
      return c.echo !== void 0 && c.echo !== null && (O.echo = e.RequestEcho.fromPartial(c.echo)), c.flush !== void 0 && c.flush !== null && (O.flush = e.RequestFlush.fromPartial(c.flush)), c.info !== void 0 && c.info !== null && (O.info = e.RequestInfo.fromPartial(c.info)), c.initChain !== void 0 && c.initChain !== null && (O.initChain = e.RequestInitChain.fromPartial(c.initChain)), c.query !== void 0 && c.query !== null && (O.query = e.RequestQuery.fromPartial(c.query)), c.beginBlock !== void 0 && c.beginBlock !== null && (O.beginBlock = e.RequestBeginBlock.fromPartial(c.beginBlock)), c.checkTx !== void 0 && c.checkTx !== null && (O.checkTx = e.RequestCheckTx.fromPartial(c.checkTx)), c.deliverTx !== void 0 && c.deliverTx !== null && (O.deliverTx = e.RequestDeliverTx.fromPartial(c.deliverTx)), c.endBlock !== void 0 && c.endBlock !== null && (O.endBlock = e.RequestEndBlock.fromPartial(c.endBlock)), c.commit !== void 0 && c.commit !== null && (O.commit = e.RequestCommit.fromPartial(c.commit)), c.listSnapshots !== void 0 && c.listSnapshots !== null && (O.listSnapshots = e.RequestListSnapshots.fromPartial(c.listSnapshots)), c.offerSnapshot !== void 0 && c.offerSnapshot !== null && (O.offerSnapshot = e.RequestOfferSnapshot.fromPartial(c.offerSnapshot)), c.loadSnapshotChunk !== void 0 && c.loadSnapshotChunk !== null && (O.loadSnapshotChunk = e.RequestLoadSnapshotChunk.fromPartial(c.loadSnapshotChunk)), c.applySnapshotChunk !== void 0 && c.applySnapshotChunk !== null && (O.applySnapshotChunk = e.RequestApplySnapshotChunk.fromPartial(c.applySnapshotChunk)), c.prepareProposal !== void 0 && c.prepareProposal !== null && (O.prepareProposal = e.RequestPrepareProposal.fromPartial(c.prepareProposal)), c.processProposal !== void 0 && c.processProposal !== null && (O.processProposal = e.RequestProcessProposal.fromPartial(c.processProposal)), O;
    }
  };
  function N() {
    return {
      message: ""
    };
  }
  e.RequestEcho = {
    typeUrl: "/tendermint.abci.RequestEcho",
    encode(c, O = S.BinaryWriter.create()) {
      return c.message !== "" && O.uint32(10).string(c.message), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = N();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.message = M.string();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = N();
      return (0, w.isSet)(c.message) && (O.message = String(c.message)), O;
    },
    toJSON(c) {
      const O = {};
      return c.message !== void 0 && (O.message = c.message), O;
    },
    fromPartial(c) {
      const O = N();
      return O.message = c.message ?? "", O;
    }
  };
  function q() {
    return {};
  }
  e.RequestFlush = {
    typeUrl: "/tendermint.abci.RequestFlush",
    encode(c, O = S.BinaryWriter.create()) {
      return O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = q();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      return q();
    },
    toJSON(c) {
      return {};
    },
    fromPartial(c) {
      return q();
    }
  };
  function u() {
    return {
      version: "",
      blockVersion: BigInt(0),
      p2pVersion: BigInt(0),
      abciVersion: ""
    };
  }
  e.RequestInfo = {
    typeUrl: "/tendermint.abci.RequestInfo",
    encode(c, O = S.BinaryWriter.create()) {
      return c.version !== "" && O.uint32(10).string(c.version), c.blockVersion !== BigInt(0) && O.uint32(16).uint64(c.blockVersion), c.p2pVersion !== BigInt(0) && O.uint32(24).uint64(c.p2pVersion), c.abciVersion !== "" && O.uint32(34).string(c.abciVersion), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = u();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.version = M.string();
            break;
          case 2:
            F.blockVersion = M.uint64();
            break;
          case 3:
            F.p2pVersion = M.uint64();
            break;
          case 4:
            F.abciVersion = M.string();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = u();
      return (0, w.isSet)(c.version) && (O.version = String(c.version)), (0, w.isSet)(c.blockVersion) && (O.blockVersion = BigInt(c.blockVersion.toString())), (0, w.isSet)(c.p2pVersion) && (O.p2pVersion = BigInt(c.p2pVersion.toString())), (0, w.isSet)(c.abciVersion) && (O.abciVersion = String(c.abciVersion)), O;
    },
    toJSON(c) {
      const O = {};
      return c.version !== void 0 && (O.version = c.version), c.blockVersion !== void 0 && (O.blockVersion = (c.blockVersion || BigInt(0)).toString()), c.p2pVersion !== void 0 && (O.p2pVersion = (c.p2pVersion || BigInt(0)).toString()), c.abciVersion !== void 0 && (O.abciVersion = c.abciVersion), O;
    },
    fromPartial(c) {
      const O = u();
      return O.version = c.version ?? "", c.blockVersion !== void 0 && c.blockVersion !== null && (O.blockVersion = BigInt(c.blockVersion.toString())), c.p2pVersion !== void 0 && c.p2pVersion !== null && (O.p2pVersion = BigInt(c.p2pVersion.toString())), O.abciVersion = c.abciVersion ?? "", O;
    }
  };
  function l() {
    return {
      time: n.Timestamp.fromPartial({}),
      chainId: "",
      consensusParams: void 0,
      validators: [],
      appStateBytes: new Uint8Array(),
      initialHeight: BigInt(0)
    };
  }
  e.RequestInitChain = {
    typeUrl: "/tendermint.abci.RequestInitChain",
    encode(c, O = S.BinaryWriter.create()) {
      c.time !== void 0 && n.Timestamp.encode(c.time, O.uint32(10).fork()).ldelim(), c.chainId !== "" && O.uint32(18).string(c.chainId), c.consensusParams !== void 0 && r.ConsensusParams.encode(c.consensusParams, O.uint32(26).fork()).ldelim();
      for (const M of c.validators)
        e.ValidatorUpdate.encode(M, O.uint32(34).fork()).ldelim();
      return c.appStateBytes.length !== 0 && O.uint32(42).bytes(c.appStateBytes), c.initialHeight !== BigInt(0) && O.uint32(48).int64(c.initialHeight), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = l();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.time = n.Timestamp.decode(M, M.uint32());
            break;
          case 2:
            F.chainId = M.string();
            break;
          case 3:
            F.consensusParams = r.ConsensusParams.decode(M, M.uint32());
            break;
          case 4:
            F.validators.push(e.ValidatorUpdate.decode(M, M.uint32()));
            break;
          case 5:
            F.appStateBytes = M.bytes();
            break;
          case 6:
            F.initialHeight = M.int64();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = l();
      return (0, w.isSet)(c.time) && (O.time = (0, w.fromJsonTimestamp)(c.time)), (0, w.isSet)(c.chainId) && (O.chainId = String(c.chainId)), (0, w.isSet)(c.consensusParams) && (O.consensusParams = r.ConsensusParams.fromJSON(c.consensusParams)), Array.isArray(c == null ? void 0 : c.validators) && (O.validators = c.validators.map((M) => e.ValidatorUpdate.fromJSON(M))), (0, w.isSet)(c.appStateBytes) && (O.appStateBytes = (0, w.bytesFromBase64)(c.appStateBytes)), (0, w.isSet)(c.initialHeight) && (O.initialHeight = BigInt(c.initialHeight.toString())), O;
    },
    toJSON(c) {
      const O = {};
      return c.time !== void 0 && (O.time = (0, w.fromTimestamp)(c.time).toISOString()), c.chainId !== void 0 && (O.chainId = c.chainId), c.consensusParams !== void 0 && (O.consensusParams = c.consensusParams ? r.ConsensusParams.toJSON(c.consensusParams) : void 0), c.validators ? O.validators = c.validators.map((M) => M ? e.ValidatorUpdate.toJSON(M) : void 0) : O.validators = [], c.appStateBytes !== void 0 && (O.appStateBytes = (0, w.base64FromBytes)(c.appStateBytes !== void 0 ? c.appStateBytes : new Uint8Array())), c.initialHeight !== void 0 && (O.initialHeight = (c.initialHeight || BigInt(0)).toString()), O;
    },
    fromPartial(c) {
      var M;
      const O = l();
      return c.time !== void 0 && c.time !== null && (O.time = n.Timestamp.fromPartial(c.time)), O.chainId = c.chainId ?? "", c.consensusParams !== void 0 && c.consensusParams !== null && (O.consensusParams = r.ConsensusParams.fromPartial(c.consensusParams)), O.validators = ((M = c.validators) == null ? void 0 : M.map((K) => e.ValidatorUpdate.fromPartial(K))) || [], O.appStateBytes = c.appStateBytes ?? new Uint8Array(), c.initialHeight !== void 0 && c.initialHeight !== null && (O.initialHeight = BigInt(c.initialHeight.toString())), O;
    }
  };
  function I() {
    return {
      data: new Uint8Array(),
      path: "",
      height: BigInt(0),
      prove: !1
    };
  }
  e.RequestQuery = {
    typeUrl: "/tendermint.abci.RequestQuery",
    encode(c, O = S.BinaryWriter.create()) {
      return c.data.length !== 0 && O.uint32(10).bytes(c.data), c.path !== "" && O.uint32(18).string(c.path), c.height !== BigInt(0) && O.uint32(24).int64(c.height), c.prove === !0 && O.uint32(32).bool(c.prove), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = I();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.data = M.bytes();
            break;
          case 2:
            F.path = M.string();
            break;
          case 3:
            F.height = M.int64();
            break;
          case 4:
            F.prove = M.bool();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = I();
      return (0, w.isSet)(c.data) && (O.data = (0, w.bytesFromBase64)(c.data)), (0, w.isSet)(c.path) && (O.path = String(c.path)), (0, w.isSet)(c.height) && (O.height = BigInt(c.height.toString())), (0, w.isSet)(c.prove) && (O.prove = !!c.prove), O;
    },
    toJSON(c) {
      const O = {};
      return c.data !== void 0 && (O.data = (0, w.base64FromBytes)(c.data !== void 0 ? c.data : new Uint8Array())), c.path !== void 0 && (O.path = c.path), c.height !== void 0 && (O.height = (c.height || BigInt(0)).toString()), c.prove !== void 0 && (O.prove = c.prove), O;
    },
    fromPartial(c) {
      const O = I();
      return O.data = c.data ?? new Uint8Array(), O.path = c.path ?? "", c.height !== void 0 && c.height !== null && (O.height = BigInt(c.height.toString())), O.prove = c.prove ?? !1, O;
    }
  };
  function B() {
    return {
      hash: new Uint8Array(),
      header: t.Header.fromPartial({}),
      lastCommitInfo: e.CommitInfo.fromPartial({}),
      byzantineValidators: []
    };
  }
  e.RequestBeginBlock = {
    typeUrl: "/tendermint.abci.RequestBeginBlock",
    encode(c, O = S.BinaryWriter.create()) {
      c.hash.length !== 0 && O.uint32(10).bytes(c.hash), c.header !== void 0 && t.Header.encode(c.header, O.uint32(18).fork()).ldelim(), c.lastCommitInfo !== void 0 && e.CommitInfo.encode(c.lastCommitInfo, O.uint32(26).fork()).ldelim();
      for (const M of c.byzantineValidators)
        e.Misbehavior.encode(M, O.uint32(34).fork()).ldelim();
      return O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = B();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.hash = M.bytes();
            break;
          case 2:
            F.header = t.Header.decode(M, M.uint32());
            break;
          case 3:
            F.lastCommitInfo = e.CommitInfo.decode(M, M.uint32());
            break;
          case 4:
            F.byzantineValidators.push(e.Misbehavior.decode(M, M.uint32()));
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = B();
      return (0, w.isSet)(c.hash) && (O.hash = (0, w.bytesFromBase64)(c.hash)), (0, w.isSet)(c.header) && (O.header = t.Header.fromJSON(c.header)), (0, w.isSet)(c.lastCommitInfo) && (O.lastCommitInfo = e.CommitInfo.fromJSON(c.lastCommitInfo)), Array.isArray(c == null ? void 0 : c.byzantineValidators) && (O.byzantineValidators = c.byzantineValidators.map((M) => e.Misbehavior.fromJSON(M))), O;
    },
    toJSON(c) {
      const O = {};
      return c.hash !== void 0 && (O.hash = (0, w.base64FromBytes)(c.hash !== void 0 ? c.hash : new Uint8Array())), c.header !== void 0 && (O.header = c.header ? t.Header.toJSON(c.header) : void 0), c.lastCommitInfo !== void 0 && (O.lastCommitInfo = c.lastCommitInfo ? e.CommitInfo.toJSON(c.lastCommitInfo) : void 0), c.byzantineValidators ? O.byzantineValidators = c.byzantineValidators.map((M) => M ? e.Misbehavior.toJSON(M) : void 0) : O.byzantineValidators = [], O;
    },
    fromPartial(c) {
      var M;
      const O = B();
      return O.hash = c.hash ?? new Uint8Array(), c.header !== void 0 && c.header !== null && (O.header = t.Header.fromPartial(c.header)), c.lastCommitInfo !== void 0 && c.lastCommitInfo !== null && (O.lastCommitInfo = e.CommitInfo.fromPartial(c.lastCommitInfo)), O.byzantineValidators = ((M = c.byzantineValidators) == null ? void 0 : M.map((K) => e.Misbehavior.fromPartial(K))) || [], O;
    }
  };
  function b() {
    return {
      tx: new Uint8Array(),
      type: 0
    };
  }
  e.RequestCheckTx = {
    typeUrl: "/tendermint.abci.RequestCheckTx",
    encode(c, O = S.BinaryWriter.create()) {
      return c.tx.length !== 0 && O.uint32(10).bytes(c.tx), c.type !== 0 && O.uint32(16).int32(c.type), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = b();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.tx = M.bytes();
            break;
          case 2:
            F.type = M.int32();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = b();
      return (0, w.isSet)(c.tx) && (O.tx = (0, w.bytesFromBase64)(c.tx)), (0, w.isSet)(c.type) && (O.type = J(c.type)), O;
    },
    toJSON(c) {
      const O = {};
      return c.tx !== void 0 && (O.tx = (0, w.base64FromBytes)(c.tx !== void 0 ? c.tx : new Uint8Array())), c.type !== void 0 && (O.type = C(c.type)), O;
    },
    fromPartial(c) {
      const O = b();
      return O.tx = c.tx ?? new Uint8Array(), O.type = c.type ?? 0, O;
    }
  };
  function D() {
    return {
      tx: new Uint8Array()
    };
  }
  e.RequestDeliverTx = {
    typeUrl: "/tendermint.abci.RequestDeliverTx",
    encode(c, O = S.BinaryWriter.create()) {
      return c.tx.length !== 0 && O.uint32(10).bytes(c.tx), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = D();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.tx = M.bytes();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = D();
      return (0, w.isSet)(c.tx) && (O.tx = (0, w.bytesFromBase64)(c.tx)), O;
    },
    toJSON(c) {
      const O = {};
      return c.tx !== void 0 && (O.tx = (0, w.base64FromBytes)(c.tx !== void 0 ? c.tx : new Uint8Array())), O;
    },
    fromPartial(c) {
      const O = D();
      return O.tx = c.tx ?? new Uint8Array(), O;
    }
  };
  function Q() {
    return {
      height: BigInt(0)
    };
  }
  e.RequestEndBlock = {
    typeUrl: "/tendermint.abci.RequestEndBlock",
    encode(c, O = S.BinaryWriter.create()) {
      return c.height !== BigInt(0) && O.uint32(8).int64(c.height), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = Q();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.height = M.int64();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = Q();
      return (0, w.isSet)(c.height) && (O.height = BigInt(c.height.toString())), O;
    },
    toJSON(c) {
      const O = {};
      return c.height !== void 0 && (O.height = (c.height || BigInt(0)).toString()), O;
    },
    fromPartial(c) {
      const O = Q();
      return c.height !== void 0 && c.height !== null && (O.height = BigInt(c.height.toString())), O;
    }
  };
  function H() {
    return {};
  }
  e.RequestCommit = {
    typeUrl: "/tendermint.abci.RequestCommit",
    encode(c, O = S.BinaryWriter.create()) {
      return O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = H();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      return H();
    },
    toJSON(c) {
      return {};
    },
    fromPartial(c) {
      return H();
    }
  };
  function s() {
    return {};
  }
  e.RequestListSnapshots = {
    typeUrl: "/tendermint.abci.RequestListSnapshots",
    encode(c, O = S.BinaryWriter.create()) {
      return O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = s();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      return s();
    },
    toJSON(c) {
      return {};
    },
    fromPartial(c) {
      return s();
    }
  };
  function k() {
    return {
      snapshot: void 0,
      appHash: new Uint8Array()
    };
  }
  e.RequestOfferSnapshot = {
    typeUrl: "/tendermint.abci.RequestOfferSnapshot",
    encode(c, O = S.BinaryWriter.create()) {
      return c.snapshot !== void 0 && e.Snapshot.encode(c.snapshot, O.uint32(10).fork()).ldelim(), c.appHash.length !== 0 && O.uint32(18).bytes(c.appHash), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = k();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.snapshot = e.Snapshot.decode(M, M.uint32());
            break;
          case 2:
            F.appHash = M.bytes();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = k();
      return (0, w.isSet)(c.snapshot) && (O.snapshot = e.Snapshot.fromJSON(c.snapshot)), (0, w.isSet)(c.appHash) && (O.appHash = (0, w.bytesFromBase64)(c.appHash)), O;
    },
    toJSON(c) {
      const O = {};
      return c.snapshot !== void 0 && (O.snapshot = c.snapshot ? e.Snapshot.toJSON(c.snapshot) : void 0), c.appHash !== void 0 && (O.appHash = (0, w.base64FromBytes)(c.appHash !== void 0 ? c.appHash : new Uint8Array())), O;
    },
    fromPartial(c) {
      const O = k();
      return c.snapshot !== void 0 && c.snapshot !== null && (O.snapshot = e.Snapshot.fromPartial(c.snapshot)), O.appHash = c.appHash ?? new Uint8Array(), O;
    }
  };
  function g() {
    return {
      height: BigInt(0),
      format: 0,
      chunk: 0
    };
  }
  e.RequestLoadSnapshotChunk = {
    typeUrl: "/tendermint.abci.RequestLoadSnapshotChunk",
    encode(c, O = S.BinaryWriter.create()) {
      return c.height !== BigInt(0) && O.uint32(8).uint64(c.height), c.format !== 0 && O.uint32(16).uint32(c.format), c.chunk !== 0 && O.uint32(24).uint32(c.chunk), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = g();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.height = M.uint64();
            break;
          case 2:
            F.format = M.uint32();
            break;
          case 3:
            F.chunk = M.uint32();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = g();
      return (0, w.isSet)(c.height) && (O.height = BigInt(c.height.toString())), (0, w.isSet)(c.format) && (O.format = Number(c.format)), (0, w.isSet)(c.chunk) && (O.chunk = Number(c.chunk)), O;
    },
    toJSON(c) {
      const O = {};
      return c.height !== void 0 && (O.height = (c.height || BigInt(0)).toString()), c.format !== void 0 && (O.format = Math.round(c.format)), c.chunk !== void 0 && (O.chunk = Math.round(c.chunk)), O;
    },
    fromPartial(c) {
      const O = g();
      return c.height !== void 0 && c.height !== null && (O.height = BigInt(c.height.toString())), O.format = c.format ?? 0, O.chunk = c.chunk ?? 0, O;
    }
  };
  function P() {
    return {
      index: 0,
      chunk: new Uint8Array(),
      sender: ""
    };
  }
  e.RequestApplySnapshotChunk = {
    typeUrl: "/tendermint.abci.RequestApplySnapshotChunk",
    encode(c, O = S.BinaryWriter.create()) {
      return c.index !== 0 && O.uint32(8).uint32(c.index), c.chunk.length !== 0 && O.uint32(18).bytes(c.chunk), c.sender !== "" && O.uint32(26).string(c.sender), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = P();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.index = M.uint32();
            break;
          case 2:
            F.chunk = M.bytes();
            break;
          case 3:
            F.sender = M.string();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = P();
      return (0, w.isSet)(c.index) && (O.index = Number(c.index)), (0, w.isSet)(c.chunk) && (O.chunk = (0, w.bytesFromBase64)(c.chunk)), (0, w.isSet)(c.sender) && (O.sender = String(c.sender)), O;
    },
    toJSON(c) {
      const O = {};
      return c.index !== void 0 && (O.index = Math.round(c.index)), c.chunk !== void 0 && (O.chunk = (0, w.base64FromBytes)(c.chunk !== void 0 ? c.chunk : new Uint8Array())), c.sender !== void 0 && (O.sender = c.sender), O;
    },
    fromPartial(c) {
      const O = P();
      return O.index = c.index ?? 0, O.chunk = c.chunk ?? new Uint8Array(), O.sender = c.sender ?? "", O;
    }
  };
  function A() {
    return {
      maxTxBytes: BigInt(0),
      txs: [],
      localLastCommit: e.ExtendedCommitInfo.fromPartial({}),
      misbehavior: [],
      height: BigInt(0),
      time: n.Timestamp.fromPartial({}),
      nextValidatorsHash: new Uint8Array(),
      proposerAddress: new Uint8Array()
    };
  }
  e.RequestPrepareProposal = {
    typeUrl: "/tendermint.abci.RequestPrepareProposal",
    encode(c, O = S.BinaryWriter.create()) {
      c.maxTxBytes !== BigInt(0) && O.uint32(8).int64(c.maxTxBytes);
      for (const M of c.txs)
        O.uint32(18).bytes(M);
      c.localLastCommit !== void 0 && e.ExtendedCommitInfo.encode(c.localLastCommit, O.uint32(26).fork()).ldelim();
      for (const M of c.misbehavior)
        e.Misbehavior.encode(M, O.uint32(34).fork()).ldelim();
      return c.height !== BigInt(0) && O.uint32(40).int64(c.height), c.time !== void 0 && n.Timestamp.encode(c.time, O.uint32(50).fork()).ldelim(), c.nextValidatorsHash.length !== 0 && O.uint32(58).bytes(c.nextValidatorsHash), c.proposerAddress.length !== 0 && O.uint32(66).bytes(c.proposerAddress), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = A();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.maxTxBytes = M.int64();
            break;
          case 2:
            F.txs.push(M.bytes());
            break;
          case 3:
            F.localLastCommit = e.ExtendedCommitInfo.decode(M, M.uint32());
            break;
          case 4:
            F.misbehavior.push(e.Misbehavior.decode(M, M.uint32()));
            break;
          case 5:
            F.height = M.int64();
            break;
          case 6:
            F.time = n.Timestamp.decode(M, M.uint32());
            break;
          case 7:
            F.nextValidatorsHash = M.bytes();
            break;
          case 8:
            F.proposerAddress = M.bytes();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = A();
      return (0, w.isSet)(c.maxTxBytes) && (O.maxTxBytes = BigInt(c.maxTxBytes.toString())), Array.isArray(c == null ? void 0 : c.txs) && (O.txs = c.txs.map((M) => (0, w.bytesFromBase64)(M))), (0, w.isSet)(c.localLastCommit) && (O.localLastCommit = e.ExtendedCommitInfo.fromJSON(c.localLastCommit)), Array.isArray(c == null ? void 0 : c.misbehavior) && (O.misbehavior = c.misbehavior.map((M) => e.Misbehavior.fromJSON(M))), (0, w.isSet)(c.height) && (O.height = BigInt(c.height.toString())), (0, w.isSet)(c.time) && (O.time = (0, w.fromJsonTimestamp)(c.time)), (0, w.isSet)(c.nextValidatorsHash) && (O.nextValidatorsHash = (0, w.bytesFromBase64)(c.nextValidatorsHash)), (0, w.isSet)(c.proposerAddress) && (O.proposerAddress = (0, w.bytesFromBase64)(c.proposerAddress)), O;
    },
    toJSON(c) {
      const O = {};
      return c.maxTxBytes !== void 0 && (O.maxTxBytes = (c.maxTxBytes || BigInt(0)).toString()), c.txs ? O.txs = c.txs.map((M) => (0, w.base64FromBytes)(M !== void 0 ? M : new Uint8Array())) : O.txs = [], c.localLastCommit !== void 0 && (O.localLastCommit = c.localLastCommit ? e.ExtendedCommitInfo.toJSON(c.localLastCommit) : void 0), c.misbehavior ? O.misbehavior = c.misbehavior.map((M) => M ? e.Misbehavior.toJSON(M) : void 0) : O.misbehavior = [], c.height !== void 0 && (O.height = (c.height || BigInt(0)).toString()), c.time !== void 0 && (O.time = (0, w.fromTimestamp)(c.time).toISOString()), c.nextValidatorsHash !== void 0 && (O.nextValidatorsHash = (0, w.base64FromBytes)(c.nextValidatorsHash !== void 0 ? c.nextValidatorsHash : new Uint8Array())), c.proposerAddress !== void 0 && (O.proposerAddress = (0, w.base64FromBytes)(c.proposerAddress !== void 0 ? c.proposerAddress : new Uint8Array())), O;
    },
    fromPartial(c) {
      var M, K;
      const O = A();
      return c.maxTxBytes !== void 0 && c.maxTxBytes !== null && (O.maxTxBytes = BigInt(c.maxTxBytes.toString())), O.txs = ((M = c.txs) == null ? void 0 : M.map((F) => F)) || [], c.localLastCommit !== void 0 && c.localLastCommit !== null && (O.localLastCommit = e.ExtendedCommitInfo.fromPartial(c.localLastCommit)), O.misbehavior = ((K = c.misbehavior) == null ? void 0 : K.map((F) => e.Misbehavior.fromPartial(F))) || [], c.height !== void 0 && c.height !== null && (O.height = BigInt(c.height.toString())), c.time !== void 0 && c.time !== null && (O.time = n.Timestamp.fromPartial(c.time)), O.nextValidatorsHash = c.nextValidatorsHash ?? new Uint8Array(), O.proposerAddress = c.proposerAddress ?? new Uint8Array(), O;
    }
  };
  function W() {
    return {
      txs: [],
      proposedLastCommit: e.CommitInfo.fromPartial({}),
      misbehavior: [],
      hash: new Uint8Array(),
      height: BigInt(0),
      time: n.Timestamp.fromPartial({}),
      nextValidatorsHash: new Uint8Array(),
      proposerAddress: new Uint8Array()
    };
  }
  e.RequestProcessProposal = {
    typeUrl: "/tendermint.abci.RequestProcessProposal",
    encode(c, O = S.BinaryWriter.create()) {
      for (const M of c.txs)
        O.uint32(10).bytes(M);
      c.proposedLastCommit !== void 0 && e.CommitInfo.encode(c.proposedLastCommit, O.uint32(18).fork()).ldelim();
      for (const M of c.misbehavior)
        e.Misbehavior.encode(M, O.uint32(26).fork()).ldelim();
      return c.hash.length !== 0 && O.uint32(34).bytes(c.hash), c.height !== BigInt(0) && O.uint32(40).int64(c.height), c.time !== void 0 && n.Timestamp.encode(c.time, O.uint32(50).fork()).ldelim(), c.nextValidatorsHash.length !== 0 && O.uint32(58).bytes(c.nextValidatorsHash), c.proposerAddress.length !== 0 && O.uint32(66).bytes(c.proposerAddress), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = W();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.txs.push(M.bytes());
            break;
          case 2:
            F.proposedLastCommit = e.CommitInfo.decode(M, M.uint32());
            break;
          case 3:
            F.misbehavior.push(e.Misbehavior.decode(M, M.uint32()));
            break;
          case 4:
            F.hash = M.bytes();
            break;
          case 5:
            F.height = M.int64();
            break;
          case 6:
            F.time = n.Timestamp.decode(M, M.uint32());
            break;
          case 7:
            F.nextValidatorsHash = M.bytes();
            break;
          case 8:
            F.proposerAddress = M.bytes();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = W();
      return Array.isArray(c == null ? void 0 : c.txs) && (O.txs = c.txs.map((M) => (0, w.bytesFromBase64)(M))), (0, w.isSet)(c.proposedLastCommit) && (O.proposedLastCommit = e.CommitInfo.fromJSON(c.proposedLastCommit)), Array.isArray(c == null ? void 0 : c.misbehavior) && (O.misbehavior = c.misbehavior.map((M) => e.Misbehavior.fromJSON(M))), (0, w.isSet)(c.hash) && (O.hash = (0, w.bytesFromBase64)(c.hash)), (0, w.isSet)(c.height) && (O.height = BigInt(c.height.toString())), (0, w.isSet)(c.time) && (O.time = (0, w.fromJsonTimestamp)(c.time)), (0, w.isSet)(c.nextValidatorsHash) && (O.nextValidatorsHash = (0, w.bytesFromBase64)(c.nextValidatorsHash)), (0, w.isSet)(c.proposerAddress) && (O.proposerAddress = (0, w.bytesFromBase64)(c.proposerAddress)), O;
    },
    toJSON(c) {
      const O = {};
      return c.txs ? O.txs = c.txs.map((M) => (0, w.base64FromBytes)(M !== void 0 ? M : new Uint8Array())) : O.txs = [], c.proposedLastCommit !== void 0 && (O.proposedLastCommit = c.proposedLastCommit ? e.CommitInfo.toJSON(c.proposedLastCommit) : void 0), c.misbehavior ? O.misbehavior = c.misbehavior.map((M) => M ? e.Misbehavior.toJSON(M) : void 0) : O.misbehavior = [], c.hash !== void 0 && (O.hash = (0, w.base64FromBytes)(c.hash !== void 0 ? c.hash : new Uint8Array())), c.height !== void 0 && (O.height = (c.height || BigInt(0)).toString()), c.time !== void 0 && (O.time = (0, w.fromTimestamp)(c.time).toISOString()), c.nextValidatorsHash !== void 0 && (O.nextValidatorsHash = (0, w.base64FromBytes)(c.nextValidatorsHash !== void 0 ? c.nextValidatorsHash : new Uint8Array())), c.proposerAddress !== void 0 && (O.proposerAddress = (0, w.base64FromBytes)(c.proposerAddress !== void 0 ? c.proposerAddress : new Uint8Array())), O;
    },
    fromPartial(c) {
      var M, K;
      const O = W();
      return O.txs = ((M = c.txs) == null ? void 0 : M.map((F) => F)) || [], c.proposedLastCommit !== void 0 && c.proposedLastCommit !== null && (O.proposedLastCommit = e.CommitInfo.fromPartial(c.proposedLastCommit)), O.misbehavior = ((K = c.misbehavior) == null ? void 0 : K.map((F) => e.Misbehavior.fromPartial(F))) || [], O.hash = c.hash ?? new Uint8Array(), c.height !== void 0 && c.height !== null && (O.height = BigInt(c.height.toString())), c.time !== void 0 && c.time !== null && (O.time = n.Timestamp.fromPartial(c.time)), O.nextValidatorsHash = c.nextValidatorsHash ?? new Uint8Array(), O.proposerAddress = c.proposerAddress ?? new Uint8Array(), O;
    }
  };
  function L() {
    return {
      exception: void 0,
      echo: void 0,
      flush: void 0,
      info: void 0,
      initChain: void 0,
      query: void 0,
      beginBlock: void 0,
      checkTx: void 0,
      deliverTx: void 0,
      endBlock: void 0,
      commit: void 0,
      listSnapshots: void 0,
      offerSnapshot: void 0,
      loadSnapshotChunk: void 0,
      applySnapshotChunk: void 0,
      prepareProposal: void 0,
      processProposal: void 0
    };
  }
  e.Response = {
    typeUrl: "/tendermint.abci.Response",
    encode(c, O = S.BinaryWriter.create()) {
      return c.exception !== void 0 && e.ResponseException.encode(c.exception, O.uint32(10).fork()).ldelim(), c.echo !== void 0 && e.ResponseEcho.encode(c.echo, O.uint32(18).fork()).ldelim(), c.flush !== void 0 && e.ResponseFlush.encode(c.flush, O.uint32(26).fork()).ldelim(), c.info !== void 0 && e.ResponseInfo.encode(c.info, O.uint32(34).fork()).ldelim(), c.initChain !== void 0 && e.ResponseInitChain.encode(c.initChain, O.uint32(50).fork()).ldelim(), c.query !== void 0 && e.ResponseQuery.encode(c.query, O.uint32(58).fork()).ldelim(), c.beginBlock !== void 0 && e.ResponseBeginBlock.encode(c.beginBlock, O.uint32(66).fork()).ldelim(), c.checkTx !== void 0 && e.ResponseCheckTx.encode(c.checkTx, O.uint32(74).fork()).ldelim(), c.deliverTx !== void 0 && e.ResponseDeliverTx.encode(c.deliverTx, O.uint32(82).fork()).ldelim(), c.endBlock !== void 0 && e.ResponseEndBlock.encode(c.endBlock, O.uint32(90).fork()).ldelim(), c.commit !== void 0 && e.ResponseCommit.encode(c.commit, O.uint32(98).fork()).ldelim(), c.listSnapshots !== void 0 && e.ResponseListSnapshots.encode(c.listSnapshots, O.uint32(106).fork()).ldelim(), c.offerSnapshot !== void 0 && e.ResponseOfferSnapshot.encode(c.offerSnapshot, O.uint32(114).fork()).ldelim(), c.loadSnapshotChunk !== void 0 && e.ResponseLoadSnapshotChunk.encode(c.loadSnapshotChunk, O.uint32(122).fork()).ldelim(), c.applySnapshotChunk !== void 0 && e.ResponseApplySnapshotChunk.encode(c.applySnapshotChunk, O.uint32(130).fork()).ldelim(), c.prepareProposal !== void 0 && e.ResponsePrepareProposal.encode(c.prepareProposal, O.uint32(138).fork()).ldelim(), c.processProposal !== void 0 && e.ResponseProcessProposal.encode(c.processProposal, O.uint32(146).fork()).ldelim(), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = L();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.exception = e.ResponseException.decode(M, M.uint32());
            break;
          case 2:
            F.echo = e.ResponseEcho.decode(M, M.uint32());
            break;
          case 3:
            F.flush = e.ResponseFlush.decode(M, M.uint32());
            break;
          case 4:
            F.info = e.ResponseInfo.decode(M, M.uint32());
            break;
          case 6:
            F.initChain = e.ResponseInitChain.decode(M, M.uint32());
            break;
          case 7:
            F.query = e.ResponseQuery.decode(M, M.uint32());
            break;
          case 8:
            F.beginBlock = e.ResponseBeginBlock.decode(M, M.uint32());
            break;
          case 9:
            F.checkTx = e.ResponseCheckTx.decode(M, M.uint32());
            break;
          case 10:
            F.deliverTx = e.ResponseDeliverTx.decode(M, M.uint32());
            break;
          case 11:
            F.endBlock = e.ResponseEndBlock.decode(M, M.uint32());
            break;
          case 12:
            F.commit = e.ResponseCommit.decode(M, M.uint32());
            break;
          case 13:
            F.listSnapshots = e.ResponseListSnapshots.decode(M, M.uint32());
            break;
          case 14:
            F.offerSnapshot = e.ResponseOfferSnapshot.decode(M, M.uint32());
            break;
          case 15:
            F.loadSnapshotChunk = e.ResponseLoadSnapshotChunk.decode(M, M.uint32());
            break;
          case 16:
            F.applySnapshotChunk = e.ResponseApplySnapshotChunk.decode(M, M.uint32());
            break;
          case 17:
            F.prepareProposal = e.ResponsePrepareProposal.decode(M, M.uint32());
            break;
          case 18:
            F.processProposal = e.ResponseProcessProposal.decode(M, M.uint32());
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = L();
      return (0, w.isSet)(c.exception) && (O.exception = e.ResponseException.fromJSON(c.exception)), (0, w.isSet)(c.echo) && (O.echo = e.ResponseEcho.fromJSON(c.echo)), (0, w.isSet)(c.flush) && (O.flush = e.ResponseFlush.fromJSON(c.flush)), (0, w.isSet)(c.info) && (O.info = e.ResponseInfo.fromJSON(c.info)), (0, w.isSet)(c.initChain) && (O.initChain = e.ResponseInitChain.fromJSON(c.initChain)), (0, w.isSet)(c.query) && (O.query = e.ResponseQuery.fromJSON(c.query)), (0, w.isSet)(c.beginBlock) && (O.beginBlock = e.ResponseBeginBlock.fromJSON(c.beginBlock)), (0, w.isSet)(c.checkTx) && (O.checkTx = e.ResponseCheckTx.fromJSON(c.checkTx)), (0, w.isSet)(c.deliverTx) && (O.deliverTx = e.ResponseDeliverTx.fromJSON(c.deliverTx)), (0, w.isSet)(c.endBlock) && (O.endBlock = e.ResponseEndBlock.fromJSON(c.endBlock)), (0, w.isSet)(c.commit) && (O.commit = e.ResponseCommit.fromJSON(c.commit)), (0, w.isSet)(c.listSnapshots) && (O.listSnapshots = e.ResponseListSnapshots.fromJSON(c.listSnapshots)), (0, w.isSet)(c.offerSnapshot) && (O.offerSnapshot = e.ResponseOfferSnapshot.fromJSON(c.offerSnapshot)), (0, w.isSet)(c.loadSnapshotChunk) && (O.loadSnapshotChunk = e.ResponseLoadSnapshotChunk.fromJSON(c.loadSnapshotChunk)), (0, w.isSet)(c.applySnapshotChunk) && (O.applySnapshotChunk = e.ResponseApplySnapshotChunk.fromJSON(c.applySnapshotChunk)), (0, w.isSet)(c.prepareProposal) && (O.prepareProposal = e.ResponsePrepareProposal.fromJSON(c.prepareProposal)), (0, w.isSet)(c.processProposal) && (O.processProposal = e.ResponseProcessProposal.fromJSON(c.processProposal)), O;
    },
    toJSON(c) {
      const O = {};
      return c.exception !== void 0 && (O.exception = c.exception ? e.ResponseException.toJSON(c.exception) : void 0), c.echo !== void 0 && (O.echo = c.echo ? e.ResponseEcho.toJSON(c.echo) : void 0), c.flush !== void 0 && (O.flush = c.flush ? e.ResponseFlush.toJSON(c.flush) : void 0), c.info !== void 0 && (O.info = c.info ? e.ResponseInfo.toJSON(c.info) : void 0), c.initChain !== void 0 && (O.initChain = c.initChain ? e.ResponseInitChain.toJSON(c.initChain) : void 0), c.query !== void 0 && (O.query = c.query ? e.ResponseQuery.toJSON(c.query) : void 0), c.beginBlock !== void 0 && (O.beginBlock = c.beginBlock ? e.ResponseBeginBlock.toJSON(c.beginBlock) : void 0), c.checkTx !== void 0 && (O.checkTx = c.checkTx ? e.ResponseCheckTx.toJSON(c.checkTx) : void 0), c.deliverTx !== void 0 && (O.deliverTx = c.deliverTx ? e.ResponseDeliverTx.toJSON(c.deliverTx) : void 0), c.endBlock !== void 0 && (O.endBlock = c.endBlock ? e.ResponseEndBlock.toJSON(c.endBlock) : void 0), c.commit !== void 0 && (O.commit = c.commit ? e.ResponseCommit.toJSON(c.commit) : void 0), c.listSnapshots !== void 0 && (O.listSnapshots = c.listSnapshots ? e.ResponseListSnapshots.toJSON(c.listSnapshots) : void 0), c.offerSnapshot !== void 0 && (O.offerSnapshot = c.offerSnapshot ? e.ResponseOfferSnapshot.toJSON(c.offerSnapshot) : void 0), c.loadSnapshotChunk !== void 0 && (O.loadSnapshotChunk = c.loadSnapshotChunk ? e.ResponseLoadSnapshotChunk.toJSON(c.loadSnapshotChunk) : void 0), c.applySnapshotChunk !== void 0 && (O.applySnapshotChunk = c.applySnapshotChunk ? e.ResponseApplySnapshotChunk.toJSON(c.applySnapshotChunk) : void 0), c.prepareProposal !== void 0 && (O.prepareProposal = c.prepareProposal ? e.ResponsePrepareProposal.toJSON(c.prepareProposal) : void 0), c.processProposal !== void 0 && (O.processProposal = c.processProposal ? e.ResponseProcessProposal.toJSON(c.processProposal) : void 0), O;
    },
    fromPartial(c) {
      const O = L();
      return c.exception !== void 0 && c.exception !== null && (O.exception = e.ResponseException.fromPartial(c.exception)), c.echo !== void 0 && c.echo !== null && (O.echo = e.ResponseEcho.fromPartial(c.echo)), c.flush !== void 0 && c.flush !== null && (O.flush = e.ResponseFlush.fromPartial(c.flush)), c.info !== void 0 && c.info !== null && (O.info = e.ResponseInfo.fromPartial(c.info)), c.initChain !== void 0 && c.initChain !== null && (O.initChain = e.ResponseInitChain.fromPartial(c.initChain)), c.query !== void 0 && c.query !== null && (O.query = e.ResponseQuery.fromPartial(c.query)), c.beginBlock !== void 0 && c.beginBlock !== null && (O.beginBlock = e.ResponseBeginBlock.fromPartial(c.beginBlock)), c.checkTx !== void 0 && c.checkTx !== null && (O.checkTx = e.ResponseCheckTx.fromPartial(c.checkTx)), c.deliverTx !== void 0 && c.deliverTx !== null && (O.deliverTx = e.ResponseDeliverTx.fromPartial(c.deliverTx)), c.endBlock !== void 0 && c.endBlock !== null && (O.endBlock = e.ResponseEndBlock.fromPartial(c.endBlock)), c.commit !== void 0 && c.commit !== null && (O.commit = e.ResponseCommit.fromPartial(c.commit)), c.listSnapshots !== void 0 && c.listSnapshots !== null && (O.listSnapshots = e.ResponseListSnapshots.fromPartial(c.listSnapshots)), c.offerSnapshot !== void 0 && c.offerSnapshot !== null && (O.offerSnapshot = e.ResponseOfferSnapshot.fromPartial(c.offerSnapshot)), c.loadSnapshotChunk !== void 0 && c.loadSnapshotChunk !== null && (O.loadSnapshotChunk = e.ResponseLoadSnapshotChunk.fromPartial(c.loadSnapshotChunk)), c.applySnapshotChunk !== void 0 && c.applySnapshotChunk !== null && (O.applySnapshotChunk = e.ResponseApplySnapshotChunk.fromPartial(c.applySnapshotChunk)), c.prepareProposal !== void 0 && c.prepareProposal !== null && (O.prepareProposal = e.ResponsePrepareProposal.fromPartial(c.prepareProposal)), c.processProposal !== void 0 && c.processProposal !== null && (O.processProposal = e.ResponseProcessProposal.fromPartial(c.processProposal)), O;
    }
  };
  function $() {
    return {
      error: ""
    };
  }
  e.ResponseException = {
    typeUrl: "/tendermint.abci.ResponseException",
    encode(c, O = S.BinaryWriter.create()) {
      return c.error !== "" && O.uint32(10).string(c.error), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = $();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.error = M.string();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = $();
      return (0, w.isSet)(c.error) && (O.error = String(c.error)), O;
    },
    toJSON(c) {
      const O = {};
      return c.error !== void 0 && (O.error = c.error), O;
    },
    fromPartial(c) {
      const O = $();
      return O.error = c.error ?? "", O;
    }
  };
  function ne() {
    return {
      message: ""
    };
  }
  e.ResponseEcho = {
    typeUrl: "/tendermint.abci.ResponseEcho",
    encode(c, O = S.BinaryWriter.create()) {
      return c.message !== "" && O.uint32(10).string(c.message), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = ne();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.message = M.string();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = ne();
      return (0, w.isSet)(c.message) && (O.message = String(c.message)), O;
    },
    toJSON(c) {
      const O = {};
      return c.message !== void 0 && (O.message = c.message), O;
    },
    fromPartial(c) {
      const O = ne();
      return O.message = c.message ?? "", O;
    }
  };
  function ud() {
    return {};
  }
  e.ResponseFlush = {
    typeUrl: "/tendermint.abci.ResponseFlush",
    encode(c, O = S.BinaryWriter.create()) {
      return O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = ud();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      return ud();
    },
    toJSON(c) {
      return {};
    },
    fromPartial(c) {
      return ud();
    }
  };
  function cd() {
    return {
      data: "",
      version: "",
      appVersion: BigInt(0),
      lastBlockHeight: BigInt(0),
      lastBlockAppHash: new Uint8Array()
    };
  }
  e.ResponseInfo = {
    typeUrl: "/tendermint.abci.ResponseInfo",
    encode(c, O = S.BinaryWriter.create()) {
      return c.data !== "" && O.uint32(10).string(c.data), c.version !== "" && O.uint32(18).string(c.version), c.appVersion !== BigInt(0) && O.uint32(24).uint64(c.appVersion), c.lastBlockHeight !== BigInt(0) && O.uint32(32).int64(c.lastBlockHeight), c.lastBlockAppHash.length !== 0 && O.uint32(42).bytes(c.lastBlockAppHash), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = cd();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.data = M.string();
            break;
          case 2:
            F.version = M.string();
            break;
          case 3:
            F.appVersion = M.uint64();
            break;
          case 4:
            F.lastBlockHeight = M.int64();
            break;
          case 5:
            F.lastBlockAppHash = M.bytes();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = cd();
      return (0, w.isSet)(c.data) && (O.data = String(c.data)), (0, w.isSet)(c.version) && (O.version = String(c.version)), (0, w.isSet)(c.appVersion) && (O.appVersion = BigInt(c.appVersion.toString())), (0, w.isSet)(c.lastBlockHeight) && (O.lastBlockHeight = BigInt(c.lastBlockHeight.toString())), (0, w.isSet)(c.lastBlockAppHash) && (O.lastBlockAppHash = (0, w.bytesFromBase64)(c.lastBlockAppHash)), O;
    },
    toJSON(c) {
      const O = {};
      return c.data !== void 0 && (O.data = c.data), c.version !== void 0 && (O.version = c.version), c.appVersion !== void 0 && (O.appVersion = (c.appVersion || BigInt(0)).toString()), c.lastBlockHeight !== void 0 && (O.lastBlockHeight = (c.lastBlockHeight || BigInt(0)).toString()), c.lastBlockAppHash !== void 0 && (O.lastBlockAppHash = (0, w.base64FromBytes)(c.lastBlockAppHash !== void 0 ? c.lastBlockAppHash : new Uint8Array())), O;
    },
    fromPartial(c) {
      const O = cd();
      return O.data = c.data ?? "", O.version = c.version ?? "", c.appVersion !== void 0 && c.appVersion !== null && (O.appVersion = BigInt(c.appVersion.toString())), c.lastBlockHeight !== void 0 && c.lastBlockHeight !== null && (O.lastBlockHeight = BigInt(c.lastBlockHeight.toString())), O.lastBlockAppHash = c.lastBlockAppHash ?? new Uint8Array(), O;
    }
  };
  function ld() {
    return {
      consensusParams: void 0,
      validators: [],
      appHash: new Uint8Array()
    };
  }
  e.ResponseInitChain = {
    typeUrl: "/tendermint.abci.ResponseInitChain",
    encode(c, O = S.BinaryWriter.create()) {
      c.consensusParams !== void 0 && r.ConsensusParams.encode(c.consensusParams, O.uint32(10).fork()).ldelim();
      for (const M of c.validators)
        e.ValidatorUpdate.encode(M, O.uint32(18).fork()).ldelim();
      return c.appHash.length !== 0 && O.uint32(26).bytes(c.appHash), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = ld();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.consensusParams = r.ConsensusParams.decode(M, M.uint32());
            break;
          case 2:
            F.validators.push(e.ValidatorUpdate.decode(M, M.uint32()));
            break;
          case 3:
            F.appHash = M.bytes();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = ld();
      return (0, w.isSet)(c.consensusParams) && (O.consensusParams = r.ConsensusParams.fromJSON(c.consensusParams)), Array.isArray(c == null ? void 0 : c.validators) && (O.validators = c.validators.map((M) => e.ValidatorUpdate.fromJSON(M))), (0, w.isSet)(c.appHash) && (O.appHash = (0, w.bytesFromBase64)(c.appHash)), O;
    },
    toJSON(c) {
      const O = {};
      return c.consensusParams !== void 0 && (O.consensusParams = c.consensusParams ? r.ConsensusParams.toJSON(c.consensusParams) : void 0), c.validators ? O.validators = c.validators.map((M) => M ? e.ValidatorUpdate.toJSON(M) : void 0) : O.validators = [], c.appHash !== void 0 && (O.appHash = (0, w.base64FromBytes)(c.appHash !== void 0 ? c.appHash : new Uint8Array())), O;
    },
    fromPartial(c) {
      var M;
      const O = ld();
      return c.consensusParams !== void 0 && c.consensusParams !== null && (O.consensusParams = r.ConsensusParams.fromPartial(c.consensusParams)), O.validators = ((M = c.validators) == null ? void 0 : M.map((K) => e.ValidatorUpdate.fromPartial(K))) || [], O.appHash = c.appHash ?? new Uint8Array(), O;
    }
  };
  function fd() {
    return {
      code: 0,
      log: "",
      info: "",
      index: BigInt(0),
      key: new Uint8Array(),
      value: new Uint8Array(),
      proofOps: void 0,
      height: BigInt(0),
      codespace: ""
    };
  }
  e.ResponseQuery = {
    typeUrl: "/tendermint.abci.ResponseQuery",
    encode(c, O = S.BinaryWriter.create()) {
      return c.code !== 0 && O.uint32(8).uint32(c.code), c.log !== "" && O.uint32(26).string(c.log), c.info !== "" && O.uint32(34).string(c.info), c.index !== BigInt(0) && O.uint32(40).int64(c.index), c.key.length !== 0 && O.uint32(50).bytes(c.key), c.value.length !== 0 && O.uint32(58).bytes(c.value), c.proofOps !== void 0 && i.ProofOps.encode(c.proofOps, O.uint32(66).fork()).ldelim(), c.height !== BigInt(0) && O.uint32(72).int64(c.height), c.codespace !== "" && O.uint32(82).string(c.codespace), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = fd();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.code = M.uint32();
            break;
          case 3:
            F.log = M.string();
            break;
          case 4:
            F.info = M.string();
            break;
          case 5:
            F.index = M.int64();
            break;
          case 6:
            F.key = M.bytes();
            break;
          case 7:
            F.value = M.bytes();
            break;
          case 8:
            F.proofOps = i.ProofOps.decode(M, M.uint32());
            break;
          case 9:
            F.height = M.int64();
            break;
          case 10:
            F.codespace = M.string();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = fd();
      return (0, w.isSet)(c.code) && (O.code = Number(c.code)), (0, w.isSet)(c.log) && (O.log = String(c.log)), (0, w.isSet)(c.info) && (O.info = String(c.info)), (0, w.isSet)(c.index) && (O.index = BigInt(c.index.toString())), (0, w.isSet)(c.key) && (O.key = (0, w.bytesFromBase64)(c.key)), (0, w.isSet)(c.value) && (O.value = (0, w.bytesFromBase64)(c.value)), (0, w.isSet)(c.proofOps) && (O.proofOps = i.ProofOps.fromJSON(c.proofOps)), (0, w.isSet)(c.height) && (O.height = BigInt(c.height.toString())), (0, w.isSet)(c.codespace) && (O.codespace = String(c.codespace)), O;
    },
    toJSON(c) {
      const O = {};
      return c.code !== void 0 && (O.code = Math.round(c.code)), c.log !== void 0 && (O.log = c.log), c.info !== void 0 && (O.info = c.info), c.index !== void 0 && (O.index = (c.index || BigInt(0)).toString()), c.key !== void 0 && (O.key = (0, w.base64FromBytes)(c.key !== void 0 ? c.key : new Uint8Array())), c.value !== void 0 && (O.value = (0, w.base64FromBytes)(c.value !== void 0 ? c.value : new Uint8Array())), c.proofOps !== void 0 && (O.proofOps = c.proofOps ? i.ProofOps.toJSON(c.proofOps) : void 0), c.height !== void 0 && (O.height = (c.height || BigInt(0)).toString()), c.codespace !== void 0 && (O.codespace = c.codespace), O;
    },
    fromPartial(c) {
      const O = fd();
      return O.code = c.code ?? 0, O.log = c.log ?? "", O.info = c.info ?? "", c.index !== void 0 && c.index !== null && (O.index = BigInt(c.index.toString())), O.key = c.key ?? new Uint8Array(), O.value = c.value ?? new Uint8Array(), c.proofOps !== void 0 && c.proofOps !== null && (O.proofOps = i.ProofOps.fromPartial(c.proofOps)), c.height !== void 0 && c.height !== null && (O.height = BigInt(c.height.toString())), O.codespace = c.codespace ?? "", O;
    }
  };
  function pd() {
    return {
      events: []
    };
  }
  e.ResponseBeginBlock = {
    typeUrl: "/tendermint.abci.ResponseBeginBlock",
    encode(c, O = S.BinaryWriter.create()) {
      for (const M of c.events)
        e.Event.encode(M, O.uint32(10).fork()).ldelim();
      return O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = pd();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.events.push(e.Event.decode(M, M.uint32()));
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = pd();
      return Array.isArray(c == null ? void 0 : c.events) && (O.events = c.events.map((M) => e.Event.fromJSON(M))), O;
    },
    toJSON(c) {
      const O = {};
      return c.events ? O.events = c.events.map((M) => M ? e.Event.toJSON(M) : void 0) : O.events = [], O;
    },
    fromPartial(c) {
      var M;
      const O = pd();
      return O.events = ((M = c.events) == null ? void 0 : M.map((K) => e.Event.fromPartial(K))) || [], O;
    }
  };
  function hd() {
    return {
      code: 0,
      data: new Uint8Array(),
      log: "",
      info: "",
      gasWanted: BigInt(0),
      gasUsed: BigInt(0),
      events: [],
      codespace: "",
      sender: "",
      priority: BigInt(0),
      mempoolError: ""
    };
  }
  e.ResponseCheckTx = {
    typeUrl: "/tendermint.abci.ResponseCheckTx",
    encode(c, O = S.BinaryWriter.create()) {
      c.code !== 0 && O.uint32(8).uint32(c.code), c.data.length !== 0 && O.uint32(18).bytes(c.data), c.log !== "" && O.uint32(26).string(c.log), c.info !== "" && O.uint32(34).string(c.info), c.gasWanted !== BigInt(0) && O.uint32(40).int64(c.gasWanted), c.gasUsed !== BigInt(0) && O.uint32(48).int64(c.gasUsed);
      for (const M of c.events)
        e.Event.encode(M, O.uint32(58).fork()).ldelim();
      return c.codespace !== "" && O.uint32(66).string(c.codespace), c.sender !== "" && O.uint32(74).string(c.sender), c.priority !== BigInt(0) && O.uint32(80).int64(c.priority), c.mempoolError !== "" && O.uint32(90).string(c.mempoolError), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = hd();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.code = M.uint32();
            break;
          case 2:
            F.data = M.bytes();
            break;
          case 3:
            F.log = M.string();
            break;
          case 4:
            F.info = M.string();
            break;
          case 5:
            F.gasWanted = M.int64();
            break;
          case 6:
            F.gasUsed = M.int64();
            break;
          case 7:
            F.events.push(e.Event.decode(M, M.uint32()));
            break;
          case 8:
            F.codespace = M.string();
            break;
          case 9:
            F.sender = M.string();
            break;
          case 10:
            F.priority = M.int64();
            break;
          case 11:
            F.mempoolError = M.string();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = hd();
      return (0, w.isSet)(c.code) && (O.code = Number(c.code)), (0, w.isSet)(c.data) && (O.data = (0, w.bytesFromBase64)(c.data)), (0, w.isSet)(c.log) && (O.log = String(c.log)), (0, w.isSet)(c.info) && (O.info = String(c.info)), (0, w.isSet)(c.gas_wanted) && (O.gasWanted = BigInt(c.gas_wanted.toString())), (0, w.isSet)(c.gas_used) && (O.gasUsed = BigInt(c.gas_used.toString())), Array.isArray(c == null ? void 0 : c.events) && (O.events = c.events.map((M) => e.Event.fromJSON(M))), (0, w.isSet)(c.codespace) && (O.codespace = String(c.codespace)), (0, w.isSet)(c.sender) && (O.sender = String(c.sender)), (0, w.isSet)(c.priority) && (O.priority = BigInt(c.priority.toString())), (0, w.isSet)(c.mempoolError) && (O.mempoolError = String(c.mempoolError)), O;
    },
    toJSON(c) {
      const O = {};
      return c.code !== void 0 && (O.code = Math.round(c.code)), c.data !== void 0 && (O.data = (0, w.base64FromBytes)(c.data !== void 0 ? c.data : new Uint8Array())), c.log !== void 0 && (O.log = c.log), c.info !== void 0 && (O.info = c.info), c.gasWanted !== void 0 && (O.gas_wanted = (c.gasWanted || BigInt(0)).toString()), c.gasUsed !== void 0 && (O.gas_used = (c.gasUsed || BigInt(0)).toString()), c.events ? O.events = c.events.map((M) => M ? e.Event.toJSON(M) : void 0) : O.events = [], c.codespace !== void 0 && (O.codespace = c.codespace), c.sender !== void 0 && (O.sender = c.sender), c.priority !== void 0 && (O.priority = (c.priority || BigInt(0)).toString()), c.mempoolError !== void 0 && (O.mempoolError = c.mempoolError), O;
    },
    fromPartial(c) {
      var M;
      const O = hd();
      return O.code = c.code ?? 0, O.data = c.data ?? new Uint8Array(), O.log = c.log ?? "", O.info = c.info ?? "", c.gasWanted !== void 0 && c.gasWanted !== null && (O.gasWanted = BigInt(c.gasWanted.toString())), c.gasUsed !== void 0 && c.gasUsed !== null && (O.gasUsed = BigInt(c.gasUsed.toString())), O.events = ((M = c.events) == null ? void 0 : M.map((K) => e.Event.fromPartial(K))) || [], O.codespace = c.codespace ?? "", O.sender = c.sender ?? "", c.priority !== void 0 && c.priority !== null && (O.priority = BigInt(c.priority.toString())), O.mempoolError = c.mempoolError ?? "", O;
    }
  };
  function yd() {
    return {
      code: 0,
      data: new Uint8Array(),
      log: "",
      info: "",
      gasWanted: BigInt(0),
      gasUsed: BigInt(0),
      events: [],
      codespace: ""
    };
  }
  e.ResponseDeliverTx = {
    typeUrl: "/tendermint.abci.ResponseDeliverTx",
    encode(c, O = S.BinaryWriter.create()) {
      c.code !== 0 && O.uint32(8).uint32(c.code), c.data.length !== 0 && O.uint32(18).bytes(c.data), c.log !== "" && O.uint32(26).string(c.log), c.info !== "" && O.uint32(34).string(c.info), c.gasWanted !== BigInt(0) && O.uint32(40).int64(c.gasWanted), c.gasUsed !== BigInt(0) && O.uint32(48).int64(c.gasUsed);
      for (const M of c.events)
        e.Event.encode(M, O.uint32(58).fork()).ldelim();
      return c.codespace !== "" && O.uint32(66).string(c.codespace), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = yd();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.code = M.uint32();
            break;
          case 2:
            F.data = M.bytes();
            break;
          case 3:
            F.log = M.string();
            break;
          case 4:
            F.info = M.string();
            break;
          case 5:
            F.gasWanted = M.int64();
            break;
          case 6:
            F.gasUsed = M.int64();
            break;
          case 7:
            F.events.push(e.Event.decode(M, M.uint32()));
            break;
          case 8:
            F.codespace = M.string();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = yd();
      return (0, w.isSet)(c.code) && (O.code = Number(c.code)), (0, w.isSet)(c.data) && (O.data = (0, w.bytesFromBase64)(c.data)), (0, w.isSet)(c.log) && (O.log = String(c.log)), (0, w.isSet)(c.info) && (O.info = String(c.info)), (0, w.isSet)(c.gas_wanted) && (O.gasWanted = BigInt(c.gas_wanted.toString())), (0, w.isSet)(c.gas_used) && (O.gasUsed = BigInt(c.gas_used.toString())), Array.isArray(c == null ? void 0 : c.events) && (O.events = c.events.map((M) => e.Event.fromJSON(M))), (0, w.isSet)(c.codespace) && (O.codespace = String(c.codespace)), O;
    },
    toJSON(c) {
      const O = {};
      return c.code !== void 0 && (O.code = Math.round(c.code)), c.data !== void 0 && (O.data = (0, w.base64FromBytes)(c.data !== void 0 ? c.data : new Uint8Array())), c.log !== void 0 && (O.log = c.log), c.info !== void 0 && (O.info = c.info), c.gasWanted !== void 0 && (O.gas_wanted = (c.gasWanted || BigInt(0)).toString()), c.gasUsed !== void 0 && (O.gas_used = (c.gasUsed || BigInt(0)).toString()), c.events ? O.events = c.events.map((M) => M ? e.Event.toJSON(M) : void 0) : O.events = [], c.codespace !== void 0 && (O.codespace = c.codespace), O;
    },
    fromPartial(c) {
      var M;
      const O = yd();
      return O.code = c.code ?? 0, O.data = c.data ?? new Uint8Array(), O.log = c.log ?? "", O.info = c.info ?? "", c.gasWanted !== void 0 && c.gasWanted !== null && (O.gasWanted = BigInt(c.gasWanted.toString())), c.gasUsed !== void 0 && c.gasUsed !== null && (O.gasUsed = BigInt(c.gasUsed.toString())), O.events = ((M = c.events) == null ? void 0 : M.map((K) => e.Event.fromPartial(K))) || [], O.codespace = c.codespace ?? "", O;
    }
  };
  function md() {
    return {
      validatorUpdates: [],
      consensusParamUpdates: void 0,
      events: []
    };
  }
  e.ResponseEndBlock = {
    typeUrl: "/tendermint.abci.ResponseEndBlock",
    encode(c, O = S.BinaryWriter.create()) {
      for (const M of c.validatorUpdates)
        e.ValidatorUpdate.encode(M, O.uint32(10).fork()).ldelim();
      c.consensusParamUpdates !== void 0 && r.ConsensusParams.encode(c.consensusParamUpdates, O.uint32(18).fork()).ldelim();
      for (const M of c.events)
        e.Event.encode(M, O.uint32(26).fork()).ldelim();
      return O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = md();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.validatorUpdates.push(e.ValidatorUpdate.decode(M, M.uint32()));
            break;
          case 2:
            F.consensusParamUpdates = r.ConsensusParams.decode(M, M.uint32());
            break;
          case 3:
            F.events.push(e.Event.decode(M, M.uint32()));
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = md();
      return Array.isArray(c == null ? void 0 : c.validatorUpdates) && (O.validatorUpdates = c.validatorUpdates.map((M) => e.ValidatorUpdate.fromJSON(M))), (0, w.isSet)(c.consensusParamUpdates) && (O.consensusParamUpdates = r.ConsensusParams.fromJSON(c.consensusParamUpdates)), Array.isArray(c == null ? void 0 : c.events) && (O.events = c.events.map((M) => e.Event.fromJSON(M))), O;
    },
    toJSON(c) {
      const O = {};
      return c.validatorUpdates ? O.validatorUpdates = c.validatorUpdates.map((M) => M ? e.ValidatorUpdate.toJSON(M) : void 0) : O.validatorUpdates = [], c.consensusParamUpdates !== void 0 && (O.consensusParamUpdates = c.consensusParamUpdates ? r.ConsensusParams.toJSON(c.consensusParamUpdates) : void 0), c.events ? O.events = c.events.map((M) => M ? e.Event.toJSON(M) : void 0) : O.events = [], O;
    },
    fromPartial(c) {
      var M, K;
      const O = md();
      return O.validatorUpdates = ((M = c.validatorUpdates) == null ? void 0 : M.map((F) => e.ValidatorUpdate.fromPartial(F))) || [], c.consensusParamUpdates !== void 0 && c.consensusParamUpdates !== null && (O.consensusParamUpdates = r.ConsensusParams.fromPartial(c.consensusParamUpdates)), O.events = ((K = c.events) == null ? void 0 : K.map((F) => e.Event.fromPartial(F))) || [], O;
    }
  };
  function gd() {
    return {
      data: new Uint8Array(),
      retainHeight: BigInt(0)
    };
  }
  e.ResponseCommit = {
    typeUrl: "/tendermint.abci.ResponseCommit",
    encode(c, O = S.BinaryWriter.create()) {
      return c.data.length !== 0 && O.uint32(18).bytes(c.data), c.retainHeight !== BigInt(0) && O.uint32(24).int64(c.retainHeight), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = gd();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 2:
            F.data = M.bytes();
            break;
          case 3:
            F.retainHeight = M.int64();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = gd();
      return (0, w.isSet)(c.data) && (O.data = (0, w.bytesFromBase64)(c.data)), (0, w.isSet)(c.retainHeight) && (O.retainHeight = BigInt(c.retainHeight.toString())), O;
    },
    toJSON(c) {
      const O = {};
      return c.data !== void 0 && (O.data = (0, w.base64FromBytes)(c.data !== void 0 ? c.data : new Uint8Array())), c.retainHeight !== void 0 && (O.retainHeight = (c.retainHeight || BigInt(0)).toString()), O;
    },
    fromPartial(c) {
      const O = gd();
      return O.data = c.data ?? new Uint8Array(), c.retainHeight !== void 0 && c.retainHeight !== null && (O.retainHeight = BigInt(c.retainHeight.toString())), O;
    }
  };
  function Sd() {
    return {
      snapshots: []
    };
  }
  e.ResponseListSnapshots = {
    typeUrl: "/tendermint.abci.ResponseListSnapshots",
    encode(c, O = S.BinaryWriter.create()) {
      for (const M of c.snapshots)
        e.Snapshot.encode(M, O.uint32(10).fork()).ldelim();
      return O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = Sd();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.snapshots.push(e.Snapshot.decode(M, M.uint32()));
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = Sd();
      return Array.isArray(c == null ? void 0 : c.snapshots) && (O.snapshots = c.snapshots.map((M) => e.Snapshot.fromJSON(M))), O;
    },
    toJSON(c) {
      const O = {};
      return c.snapshots ? O.snapshots = c.snapshots.map((M) => M ? e.Snapshot.toJSON(M) : void 0) : O.snapshots = [], O;
    },
    fromPartial(c) {
      var M;
      const O = Sd();
      return O.snapshots = ((M = c.snapshots) == null ? void 0 : M.map((K) => e.Snapshot.fromPartial(K))) || [], O;
    }
  };
  function kd() {
    return {
      result: 0
    };
  }
  e.ResponseOfferSnapshot = {
    typeUrl: "/tendermint.abci.ResponseOfferSnapshot",
    encode(c, O = S.BinaryWriter.create()) {
      return c.result !== 0 && O.uint32(8).int32(c.result), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = kd();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.result = M.int32();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = kd();
      return (0, w.isSet)(c.result) && (O.result = p(c.result)), O;
    },
    toJSON(c) {
      const O = {};
      return c.result !== void 0 && (O.result = m(c.result)), O;
    },
    fromPartial(c) {
      const O = kd();
      return O.result = c.result ?? 0, O;
    }
  };
  function Pd() {
    return {
      chunk: new Uint8Array()
    };
  }
  e.ResponseLoadSnapshotChunk = {
    typeUrl: "/tendermint.abci.ResponseLoadSnapshotChunk",
    encode(c, O = S.BinaryWriter.create()) {
      return c.chunk.length !== 0 && O.uint32(10).bytes(c.chunk), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = Pd();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.chunk = M.bytes();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = Pd();
      return (0, w.isSet)(c.chunk) && (O.chunk = (0, w.bytesFromBase64)(c.chunk)), O;
    },
    toJSON(c) {
      const O = {};
      return c.chunk !== void 0 && (O.chunk = (0, w.base64FromBytes)(c.chunk !== void 0 ? c.chunk : new Uint8Array())), O;
    },
    fromPartial(c) {
      const O = Pd();
      return O.chunk = c.chunk ?? new Uint8Array(), O;
    }
  };
  function vd() {
    return {
      result: 0,
      refetchChunks: [],
      rejectSenders: []
    };
  }
  e.ResponseApplySnapshotChunk = {
    typeUrl: "/tendermint.abci.ResponseApplySnapshotChunk",
    encode(c, O = S.BinaryWriter.create()) {
      c.result !== 0 && O.uint32(8).int32(c.result), O.uint32(18).fork();
      for (const M of c.refetchChunks)
        O.uint32(M);
      O.ldelim();
      for (const M of c.rejectSenders)
        O.uint32(26).string(M);
      return O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = vd();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.result = M.int32();
            break;
          case 2:
            if ((z & 7) === 2) {
              const Im = M.uint32() + M.pos;
              for (; M.pos < Im; )
                F.refetchChunks.push(M.uint32());
            } else
              F.refetchChunks.push(M.uint32());
            break;
          case 3:
            F.rejectSenders.push(M.string());
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = vd();
      return (0, w.isSet)(c.result) && (O.result = a(c.result)), Array.isArray(c == null ? void 0 : c.refetchChunks) && (O.refetchChunks = c.refetchChunks.map((M) => Number(M))), Array.isArray(c == null ? void 0 : c.rejectSenders) && (O.rejectSenders = c.rejectSenders.map((M) => String(M))), O;
    },
    toJSON(c) {
      const O = {};
      return c.result !== void 0 && (O.result = d(c.result)), c.refetchChunks ? O.refetchChunks = c.refetchChunks.map((M) => Math.round(M)) : O.refetchChunks = [], c.rejectSenders ? O.rejectSenders = c.rejectSenders.map((M) => M) : O.rejectSenders = [], O;
    },
    fromPartial(c) {
      var M, K;
      const O = vd();
      return O.result = c.result ?? 0, O.refetchChunks = ((M = c.refetchChunks) == null ? void 0 : M.map((F) => F)) || [], O.rejectSenders = ((K = c.rejectSenders) == null ? void 0 : K.map((F) => F)) || [], O;
    }
  };
  function bd() {
    return {
      txs: []
    };
  }
  e.ResponsePrepareProposal = {
    typeUrl: "/tendermint.abci.ResponsePrepareProposal",
    encode(c, O = S.BinaryWriter.create()) {
      for (const M of c.txs)
        O.uint32(10).bytes(M);
      return O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = bd();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.txs.push(M.bytes());
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = bd();
      return Array.isArray(c == null ? void 0 : c.txs) && (O.txs = c.txs.map((M) => (0, w.bytesFromBase64)(M))), O;
    },
    toJSON(c) {
      const O = {};
      return c.txs ? O.txs = c.txs.map((M) => (0, w.base64FromBytes)(M !== void 0 ? M : new Uint8Array())) : O.txs = [], O;
    },
    fromPartial(c) {
      var M;
      const O = bd();
      return O.txs = ((M = c.txs) == null ? void 0 : M.map((K) => K)) || [], O;
    }
  };
  function Rd() {
    return {
      status: 0
    };
  }
  e.ResponseProcessProposal = {
    typeUrl: "/tendermint.abci.ResponseProcessProposal",
    encode(c, O = S.BinaryWriter.create()) {
      return c.status !== 0 && O.uint32(8).int32(c.status), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = Rd();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.status = M.int32();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = Rd();
      return (0, w.isSet)(c.status) && (O.status = _(c.status)), O;
    },
    toJSON(c) {
      const O = {};
      return c.status !== void 0 && (O.status = E(c.status)), O;
    },
    fromPartial(c) {
      const O = Rd();
      return O.status = c.status ?? 0, O;
    }
  };
  function Bd() {
    return {
      round: 0,
      votes: []
    };
  }
  e.CommitInfo = {
    typeUrl: "/tendermint.abci.CommitInfo",
    encode(c, O = S.BinaryWriter.create()) {
      c.round !== 0 && O.uint32(8).int32(c.round);
      for (const M of c.votes)
        e.VoteInfo.encode(M, O.uint32(18).fork()).ldelim();
      return O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = Bd();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.round = M.int32();
            break;
          case 2:
            F.votes.push(e.VoteInfo.decode(M, M.uint32()));
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = Bd();
      return (0, w.isSet)(c.round) && (O.round = Number(c.round)), Array.isArray(c == null ? void 0 : c.votes) && (O.votes = c.votes.map((M) => e.VoteInfo.fromJSON(M))), O;
    },
    toJSON(c) {
      const O = {};
      return c.round !== void 0 && (O.round = Math.round(c.round)), c.votes ? O.votes = c.votes.map((M) => M ? e.VoteInfo.toJSON(M) : void 0) : O.votes = [], O;
    },
    fromPartial(c) {
      var M;
      const O = Bd();
      return O.round = c.round ?? 0, O.votes = ((M = c.votes) == null ? void 0 : M.map((K) => e.VoteInfo.fromPartial(K))) || [], O;
    }
  };
  function Od() {
    return {
      round: 0,
      votes: []
    };
  }
  e.ExtendedCommitInfo = {
    typeUrl: "/tendermint.abci.ExtendedCommitInfo",
    encode(c, O = S.BinaryWriter.create()) {
      c.round !== 0 && O.uint32(8).int32(c.round);
      for (const M of c.votes)
        e.ExtendedVoteInfo.encode(M, O.uint32(18).fork()).ldelim();
      return O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = Od();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.round = M.int32();
            break;
          case 2:
            F.votes.push(e.ExtendedVoteInfo.decode(M, M.uint32()));
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = Od();
      return (0, w.isSet)(c.round) && (O.round = Number(c.round)), Array.isArray(c == null ? void 0 : c.votes) && (O.votes = c.votes.map((M) => e.ExtendedVoteInfo.fromJSON(M))), O;
    },
    toJSON(c) {
      const O = {};
      return c.round !== void 0 && (O.round = Math.round(c.round)), c.votes ? O.votes = c.votes.map((M) => M ? e.ExtendedVoteInfo.toJSON(M) : void 0) : O.votes = [], O;
    },
    fromPartial(c) {
      var M;
      const O = Od();
      return O.round = c.round ?? 0, O.votes = ((M = c.votes) == null ? void 0 : M.map((K) => e.ExtendedVoteInfo.fromPartial(K))) || [], O;
    }
  };
  function Ad() {
    return {
      type: "",
      attributes: []
    };
  }
  e.Event = {
    typeUrl: "/tendermint.abci.Event",
    encode(c, O = S.BinaryWriter.create()) {
      c.type !== "" && O.uint32(10).string(c.type);
      for (const M of c.attributes)
        e.EventAttribute.encode(M, O.uint32(18).fork()).ldelim();
      return O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = Ad();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.type = M.string();
            break;
          case 2:
            F.attributes.push(e.EventAttribute.decode(M, M.uint32()));
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = Ad();
      return (0, w.isSet)(c.type) && (O.type = String(c.type)), Array.isArray(c == null ? void 0 : c.attributes) && (O.attributes = c.attributes.map((M) => e.EventAttribute.fromJSON(M))), O;
    },
    toJSON(c) {
      const O = {};
      return c.type !== void 0 && (O.type = c.type), c.attributes ? O.attributes = c.attributes.map((M) => M ? e.EventAttribute.toJSON(M) : void 0) : O.attributes = [], O;
    },
    fromPartial(c) {
      var M;
      const O = Ad();
      return O.type = c.type ?? "", O.attributes = ((M = c.attributes) == null ? void 0 : M.map((K) => e.EventAttribute.fromPartial(K))) || [], O;
    }
  };
  function Id() {
    return {
      key: "",
      value: "",
      index: !1
    };
  }
  e.EventAttribute = {
    typeUrl: "/tendermint.abci.EventAttribute",
    encode(c, O = S.BinaryWriter.create()) {
      return c.key !== "" && O.uint32(10).string(c.key), c.value !== "" && O.uint32(18).string(c.value), c.index === !0 && O.uint32(24).bool(c.index), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = Id();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.key = M.string();
            break;
          case 2:
            F.value = M.string();
            break;
          case 3:
            F.index = M.bool();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = Id();
      return (0, w.isSet)(c.key) && (O.key = String(c.key)), (0, w.isSet)(c.value) && (O.value = String(c.value)), (0, w.isSet)(c.index) && (O.index = !!c.index), O;
    },
    toJSON(c) {
      const O = {};
      return c.key !== void 0 && (O.key = c.key), c.value !== void 0 && (O.value = c.value), c.index !== void 0 && (O.index = c.index), O;
    },
    fromPartial(c) {
      const O = Id();
      return O.key = c.key ?? "", O.value = c.value ?? "", O.index = c.index ?? !1, O;
    }
  };
  function Td() {
    return {
      height: BigInt(0),
      index: 0,
      tx: new Uint8Array(),
      result: e.ResponseDeliverTx.fromPartial({})
    };
  }
  e.TxResult = {
    typeUrl: "/tendermint.abci.TxResult",
    encode(c, O = S.BinaryWriter.create()) {
      return c.height !== BigInt(0) && O.uint32(8).int64(c.height), c.index !== 0 && O.uint32(16).uint32(c.index), c.tx.length !== 0 && O.uint32(26).bytes(c.tx), c.result !== void 0 && e.ResponseDeliverTx.encode(c.result, O.uint32(34).fork()).ldelim(), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = Td();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.height = M.int64();
            break;
          case 2:
            F.index = M.uint32();
            break;
          case 3:
            F.tx = M.bytes();
            break;
          case 4:
            F.result = e.ResponseDeliverTx.decode(M, M.uint32());
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = Td();
      return (0, w.isSet)(c.height) && (O.height = BigInt(c.height.toString())), (0, w.isSet)(c.index) && (O.index = Number(c.index)), (0, w.isSet)(c.tx) && (O.tx = (0, w.bytesFromBase64)(c.tx)), (0, w.isSet)(c.result) && (O.result = e.ResponseDeliverTx.fromJSON(c.result)), O;
    },
    toJSON(c) {
      const O = {};
      return c.height !== void 0 && (O.height = (c.height || BigInt(0)).toString()), c.index !== void 0 && (O.index = Math.round(c.index)), c.tx !== void 0 && (O.tx = (0, w.base64FromBytes)(c.tx !== void 0 ? c.tx : new Uint8Array())), c.result !== void 0 && (O.result = c.result ? e.ResponseDeliverTx.toJSON(c.result) : void 0), O;
    },
    fromPartial(c) {
      const O = Td();
      return c.height !== void 0 && c.height !== null && (O.height = BigInt(c.height.toString())), O.index = c.index ?? 0, O.tx = c.tx ?? new Uint8Array(), c.result !== void 0 && c.result !== null && (O.result = e.ResponseDeliverTx.fromPartial(c.result)), O;
    }
  };
  function wd() {
    return {
      address: new Uint8Array(),
      power: BigInt(0)
    };
  }
  e.Validator = {
    typeUrl: "/tendermint.abci.Validator",
    encode(c, O = S.BinaryWriter.create()) {
      return c.address.length !== 0 && O.uint32(10).bytes(c.address), c.power !== BigInt(0) && O.uint32(24).int64(c.power), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = wd();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.address = M.bytes();
            break;
          case 3:
            F.power = M.int64();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = wd();
      return (0, w.isSet)(c.address) && (O.address = (0, w.bytesFromBase64)(c.address)), (0, w.isSet)(c.power) && (O.power = BigInt(c.power.toString())), O;
    },
    toJSON(c) {
      const O = {};
      return c.address !== void 0 && (O.address = (0, w.base64FromBytes)(c.address !== void 0 ? c.address : new Uint8Array())), c.power !== void 0 && (O.power = (c.power || BigInt(0)).toString()), O;
    },
    fromPartial(c) {
      const O = wd();
      return O.address = c.address ?? new Uint8Array(), c.power !== void 0 && c.power !== null && (O.power = BigInt(c.power.toString())), O;
    }
  };
  function Cd() {
    return {
      pubKey: f.PublicKey.fromPartial({}),
      power: BigInt(0)
    };
  }
  e.ValidatorUpdate = {
    typeUrl: "/tendermint.abci.ValidatorUpdate",
    encode(c, O = S.BinaryWriter.create()) {
      return c.pubKey !== void 0 && f.PublicKey.encode(c.pubKey, O.uint32(10).fork()).ldelim(), c.power !== BigInt(0) && O.uint32(16).int64(c.power), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = Cd();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.pubKey = f.PublicKey.decode(M, M.uint32());
            break;
          case 2:
            F.power = M.int64();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = Cd();
      return (0, w.isSet)(c.pubKey) && (O.pubKey = f.PublicKey.fromJSON(c.pubKey)), (0, w.isSet)(c.power) && (O.power = BigInt(c.power.toString())), O;
    },
    toJSON(c) {
      const O = {};
      return c.pubKey !== void 0 && (O.pubKey = c.pubKey ? f.PublicKey.toJSON(c.pubKey) : void 0), c.power !== void 0 && (O.power = (c.power || BigInt(0)).toString()), O;
    },
    fromPartial(c) {
      const O = Cd();
      return c.pubKey !== void 0 && c.pubKey !== null && (O.pubKey = f.PublicKey.fromPartial(c.pubKey)), c.power !== void 0 && c.power !== null && (O.power = BigInt(c.power.toString())), O;
    }
  };
  function Nd() {
    return {
      validator: e.Validator.fromPartial({}),
      signedLastBlock: !1
    };
  }
  e.VoteInfo = {
    typeUrl: "/tendermint.abci.VoteInfo",
    encode(c, O = S.BinaryWriter.create()) {
      return c.validator !== void 0 && e.Validator.encode(c.validator, O.uint32(10).fork()).ldelim(), c.signedLastBlock === !0 && O.uint32(16).bool(c.signedLastBlock), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = Nd();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.validator = e.Validator.decode(M, M.uint32());
            break;
          case 2:
            F.signedLastBlock = M.bool();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = Nd();
      return (0, w.isSet)(c.validator) && (O.validator = e.Validator.fromJSON(c.validator)), (0, w.isSet)(c.signedLastBlock) && (O.signedLastBlock = !!c.signedLastBlock), O;
    },
    toJSON(c) {
      const O = {};
      return c.validator !== void 0 && (O.validator = c.validator ? e.Validator.toJSON(c.validator) : void 0), c.signedLastBlock !== void 0 && (O.signedLastBlock = c.signedLastBlock), O;
    },
    fromPartial(c) {
      const O = Nd();
      return c.validator !== void 0 && c.validator !== null && (O.validator = e.Validator.fromPartial(c.validator)), O.signedLastBlock = c.signedLastBlock ?? !1, O;
    }
  };
  function _d() {
    return {
      validator: e.Validator.fromPartial({}),
      signedLastBlock: !1,
      voteExtension: new Uint8Array()
    };
  }
  e.ExtendedVoteInfo = {
    typeUrl: "/tendermint.abci.ExtendedVoteInfo",
    encode(c, O = S.BinaryWriter.create()) {
      return c.validator !== void 0 && e.Validator.encode(c.validator, O.uint32(10).fork()).ldelim(), c.signedLastBlock === !0 && O.uint32(16).bool(c.signedLastBlock), c.voteExtension.length !== 0 && O.uint32(26).bytes(c.voteExtension), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = _d();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.validator = e.Validator.decode(M, M.uint32());
            break;
          case 2:
            F.signedLastBlock = M.bool();
            break;
          case 3:
            F.voteExtension = M.bytes();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = _d();
      return (0, w.isSet)(c.validator) && (O.validator = e.Validator.fromJSON(c.validator)), (0, w.isSet)(c.signedLastBlock) && (O.signedLastBlock = !!c.signedLastBlock), (0, w.isSet)(c.voteExtension) && (O.voteExtension = (0, w.bytesFromBase64)(c.voteExtension)), O;
    },
    toJSON(c) {
      const O = {};
      return c.validator !== void 0 && (O.validator = c.validator ? e.Validator.toJSON(c.validator) : void 0), c.signedLastBlock !== void 0 && (O.signedLastBlock = c.signedLastBlock), c.voteExtension !== void 0 && (O.voteExtension = (0, w.base64FromBytes)(c.voteExtension !== void 0 ? c.voteExtension : new Uint8Array())), O;
    },
    fromPartial(c) {
      const O = _d();
      return c.validator !== void 0 && c.validator !== null && (O.validator = e.Validator.fromPartial(c.validator)), O.signedLastBlock = c.signedLastBlock ?? !1, O.voteExtension = c.voteExtension ?? new Uint8Array(), O;
    }
  };
  function Ed() {
    return {
      type: 0,
      validator: e.Validator.fromPartial({}),
      height: BigInt(0),
      time: n.Timestamp.fromPartial({}),
      totalVotingPower: BigInt(0)
    };
  }
  e.Misbehavior = {
    typeUrl: "/tendermint.abci.Misbehavior",
    encode(c, O = S.BinaryWriter.create()) {
      return c.type !== 0 && O.uint32(8).int32(c.type), c.validator !== void 0 && e.Validator.encode(c.validator, O.uint32(18).fork()).ldelim(), c.height !== BigInt(0) && O.uint32(24).int64(c.height), c.time !== void 0 && n.Timestamp.encode(c.time, O.uint32(34).fork()).ldelim(), c.totalVotingPower !== BigInt(0) && O.uint32(40).int64(c.totalVotingPower), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = Ed();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.type = M.int32();
            break;
          case 2:
            F.validator = e.Validator.decode(M, M.uint32());
            break;
          case 3:
            F.height = M.int64();
            break;
          case 4:
            F.time = n.Timestamp.decode(M, M.uint32());
            break;
          case 5:
            F.totalVotingPower = M.int64();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = Ed();
      return (0, w.isSet)(c.type) && (O.type = V(c.type)), (0, w.isSet)(c.validator) && (O.validator = e.Validator.fromJSON(c.validator)), (0, w.isSet)(c.height) && (O.height = BigInt(c.height.toString())), (0, w.isSet)(c.time) && (O.time = (0, w.fromJsonTimestamp)(c.time)), (0, w.isSet)(c.totalVotingPower) && (O.totalVotingPower = BigInt(c.totalVotingPower.toString())), O;
    },
    toJSON(c) {
      const O = {};
      return c.type !== void 0 && (O.type = o(c.type)), c.validator !== void 0 && (O.validator = c.validator ? e.Validator.toJSON(c.validator) : void 0), c.height !== void 0 && (O.height = (c.height || BigInt(0)).toString()), c.time !== void 0 && (O.time = (0, w.fromTimestamp)(c.time).toISOString()), c.totalVotingPower !== void 0 && (O.totalVotingPower = (c.totalVotingPower || BigInt(0)).toString()), O;
    },
    fromPartial(c) {
      const O = Ed();
      return O.type = c.type ?? 0, c.validator !== void 0 && c.validator !== null && (O.validator = e.Validator.fromPartial(c.validator)), c.height !== void 0 && c.height !== null && (O.height = BigInt(c.height.toString())), c.time !== void 0 && c.time !== null && (O.time = n.Timestamp.fromPartial(c.time)), c.totalVotingPower !== void 0 && c.totalVotingPower !== null && (O.totalVotingPower = BigInt(c.totalVotingPower.toString())), O;
    }
  };
  function Ud() {
    return {
      height: BigInt(0),
      format: 0,
      chunks: 0,
      hash: new Uint8Array(),
      metadata: new Uint8Array()
    };
  }
  e.Snapshot = {
    typeUrl: "/tendermint.abci.Snapshot",
    encode(c, O = S.BinaryWriter.create()) {
      return c.height !== BigInt(0) && O.uint32(8).uint64(c.height), c.format !== 0 && O.uint32(16).uint32(c.format), c.chunks !== 0 && O.uint32(24).uint32(c.chunks), c.hash.length !== 0 && O.uint32(34).bytes(c.hash), c.metadata.length !== 0 && O.uint32(42).bytes(c.metadata), O;
    },
    decode(c, O) {
      const M = c instanceof S.BinaryReader ? c : new S.BinaryReader(c);
      let K = O === void 0 ? M.len : M.pos + O;
      const F = Ud();
      for (; M.pos < K; ) {
        const z = M.uint32();
        switch (z >>> 3) {
          case 1:
            F.height = M.uint64();
            break;
          case 2:
            F.format = M.uint32();
            break;
          case 3:
            F.chunks = M.uint32();
            break;
          case 4:
            F.hash = M.bytes();
            break;
          case 5:
            F.metadata = M.bytes();
            break;
          default:
            M.skipType(z & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(c) {
      const O = Ud();
      return (0, w.isSet)(c.height) && (O.height = BigInt(c.height.toString())), (0, w.isSet)(c.format) && (O.format = Number(c.format)), (0, w.isSet)(c.chunks) && (O.chunks = Number(c.chunks)), (0, w.isSet)(c.hash) && (O.hash = (0, w.bytesFromBase64)(c.hash)), (0, w.isSet)(c.metadata) && (O.metadata = (0, w.bytesFromBase64)(c.metadata)), O;
    },
    toJSON(c) {
      const O = {};
      return c.height !== void 0 && (O.height = (c.height || BigInt(0)).toString()), c.format !== void 0 && (O.format = Math.round(c.format)), c.chunks !== void 0 && (O.chunks = Math.round(c.chunks)), c.hash !== void 0 && (O.hash = (0, w.base64FromBytes)(c.hash !== void 0 ? c.hash : new Uint8Array())), c.metadata !== void 0 && (O.metadata = (0, w.base64FromBytes)(c.metadata !== void 0 ? c.metadata : new Uint8Array())), O;
    },
    fromPartial(c) {
      const O = Ud();
      return c.height !== void 0 && c.height !== null && (O.height = BigInt(c.height.toString())), O.format = c.format ?? 0, O.chunks = c.chunks ?? 0, O.hash = c.hash ?? new Uint8Array(), O.metadata = c.metadata ?? new Uint8Array(), O;
    }
  };
  class Am {
    constructor(O) {
      this.rpc = O, this.Echo = this.Echo.bind(this), this.Flush = this.Flush.bind(this), this.Info = this.Info.bind(this), this.DeliverTx = this.DeliverTx.bind(this), this.CheckTx = this.CheckTx.bind(this), this.Query = this.Query.bind(this), this.Commit = this.Commit.bind(this), this.InitChain = this.InitChain.bind(this), this.BeginBlock = this.BeginBlock.bind(this), this.EndBlock = this.EndBlock.bind(this), this.ListSnapshots = this.ListSnapshots.bind(this), this.OfferSnapshot = this.OfferSnapshot.bind(this), this.LoadSnapshotChunk = this.LoadSnapshotChunk.bind(this), this.ApplySnapshotChunk = this.ApplySnapshotChunk.bind(this), this.PrepareProposal = this.PrepareProposal.bind(this), this.ProcessProposal = this.ProcessProposal.bind(this);
    }
    Echo(O) {
      const M = e.RequestEcho.encode(O).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "Echo", M).then((F) => e.ResponseEcho.decode(new S.BinaryReader(F)));
    }
    Flush(O = {}) {
      const M = e.RequestFlush.encode(O).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "Flush", M).then((F) => e.ResponseFlush.decode(new S.BinaryReader(F)));
    }
    Info(O) {
      const M = e.RequestInfo.encode(O).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "Info", M).then((F) => e.ResponseInfo.decode(new S.BinaryReader(F)));
    }
    DeliverTx(O) {
      const M = e.RequestDeliverTx.encode(O).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "DeliverTx", M).then((F) => e.ResponseDeliverTx.decode(new S.BinaryReader(F)));
    }
    CheckTx(O) {
      const M = e.RequestCheckTx.encode(O).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "CheckTx", M).then((F) => e.ResponseCheckTx.decode(new S.BinaryReader(F)));
    }
    Query(O) {
      const M = e.RequestQuery.encode(O).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "Query", M).then((F) => e.ResponseQuery.decode(new S.BinaryReader(F)));
    }
    Commit(O = {}) {
      const M = e.RequestCommit.encode(O).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "Commit", M).then((F) => e.ResponseCommit.decode(new S.BinaryReader(F)));
    }
    InitChain(O) {
      const M = e.RequestInitChain.encode(O).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "InitChain", M).then((F) => e.ResponseInitChain.decode(new S.BinaryReader(F)));
    }
    BeginBlock(O) {
      const M = e.RequestBeginBlock.encode(O).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "BeginBlock", M).then((F) => e.ResponseBeginBlock.decode(new S.BinaryReader(F)));
    }
    EndBlock(O) {
      const M = e.RequestEndBlock.encode(O).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "EndBlock", M).then((F) => e.ResponseEndBlock.decode(new S.BinaryReader(F)));
    }
    ListSnapshots(O = {}) {
      const M = e.RequestListSnapshots.encode(O).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "ListSnapshots", M).then((F) => e.ResponseListSnapshots.decode(new S.BinaryReader(F)));
    }
    OfferSnapshot(O) {
      const M = e.RequestOfferSnapshot.encode(O).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "OfferSnapshot", M).then((F) => e.ResponseOfferSnapshot.decode(new S.BinaryReader(F)));
    }
    LoadSnapshotChunk(O) {
      const M = e.RequestLoadSnapshotChunk.encode(O).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "LoadSnapshotChunk", M).then((F) => e.ResponseLoadSnapshotChunk.decode(new S.BinaryReader(F)));
    }
    ApplySnapshotChunk(O) {
      const M = e.RequestApplySnapshotChunk.encode(O).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "ApplySnapshotChunk", M).then((F) => e.ResponseApplySnapshotChunk.decode(new S.BinaryReader(F)));
    }
    PrepareProposal(O) {
      const M = e.RequestPrepareProposal.encode(O).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "PrepareProposal", M).then((F) => e.ResponsePrepareProposal.decode(new S.BinaryReader(F)));
    }
    ProcessProposal(O) {
      const M = e.RequestProcessProposal.encode(O).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "ProcessProposal", M).then((F) => e.ResponseProcessProposal.decode(new S.BinaryReader(F)));
    }
  }
  e.ABCIApplicationClientImpl = Am;
})(el);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ValidatorUpdates = e.Pool = e.RedelegationResponse = e.RedelegationEntryResponse = e.DelegationResponse = e.Params = e.Redelegation = e.RedelegationEntry = e.UnbondingDelegationEntry = e.UnbondingDelegation = e.Delegation = e.DVVTriplets = e.DVVTriplet = e.DVPairs = e.DVPair = e.ValAddresses = e.Validator = e.Description = e.Commission = e.CommissionRates = e.HistoricalInfo = e.infractionToJSON = e.infractionFromJSON = e.Infraction = e.bondStatusToJSON = e.bondStatusFromJSON = e.BondStatus = e.protobufPackage = void 0;
  const n = ar, r = Je, t = Pe, i = vn, f = De, S = el, w = re, T = ie;
  e.protobufPackage = "cosmos.staking.v1beta1";
  var J;
  (function(g) {
    g[g.BOND_STATUS_UNSPECIFIED = 0] = "BOND_STATUS_UNSPECIFIED", g[g.BOND_STATUS_UNBONDED = 1] = "BOND_STATUS_UNBONDED", g[g.BOND_STATUS_UNBONDING = 2] = "BOND_STATUS_UNBONDING", g[g.BOND_STATUS_BONDED = 3] = "BOND_STATUS_BONDED", g[g.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(J || (e.BondStatus = J = {}));
  function C(g) {
    switch (g) {
      case 0:
      case "BOND_STATUS_UNSPECIFIED":
        return J.BOND_STATUS_UNSPECIFIED;
      case 1:
      case "BOND_STATUS_UNBONDED":
        return J.BOND_STATUS_UNBONDED;
      case 2:
      case "BOND_STATUS_UNBONDING":
        return J.BOND_STATUS_UNBONDING;
      case 3:
      case "BOND_STATUS_BONDED":
        return J.BOND_STATUS_BONDED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return J.UNRECOGNIZED;
    }
  }
  e.bondStatusFromJSON = C;
  function R(g) {
    switch (g) {
      case J.BOND_STATUS_UNSPECIFIED:
        return "BOND_STATUS_UNSPECIFIED";
      case J.BOND_STATUS_UNBONDED:
        return "BOND_STATUS_UNBONDED";
      case J.BOND_STATUS_UNBONDING:
        return "BOND_STATUS_UNBONDING";
      case J.BOND_STATUS_BONDED:
        return "BOND_STATUS_BONDED";
      case J.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.bondStatusToJSON = R;
  var p;
  (function(g) {
    g[g.INFRACTION_UNSPECIFIED = 0] = "INFRACTION_UNSPECIFIED", g[g.INFRACTION_DOUBLE_SIGN = 1] = "INFRACTION_DOUBLE_SIGN", g[g.INFRACTION_DOWNTIME = 2] = "INFRACTION_DOWNTIME", g[g.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(p || (e.Infraction = p = {}));
  function m(g) {
    switch (g) {
      case 0:
      case "INFRACTION_UNSPECIFIED":
        return p.INFRACTION_UNSPECIFIED;
      case 1:
      case "INFRACTION_DOUBLE_SIGN":
        return p.INFRACTION_DOUBLE_SIGN;
      case 2:
      case "INFRACTION_DOWNTIME":
        return p.INFRACTION_DOWNTIME;
      case -1:
      case "UNRECOGNIZED":
      default:
        return p.UNRECOGNIZED;
    }
  }
  e.infractionFromJSON = m;
  function v(g) {
    switch (g) {
      case p.INFRACTION_UNSPECIFIED:
        return "INFRACTION_UNSPECIFIED";
      case p.INFRACTION_DOUBLE_SIGN:
        return "INFRACTION_DOUBLE_SIGN";
      case p.INFRACTION_DOWNTIME:
        return "INFRACTION_DOWNTIME";
      case p.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.infractionToJSON = v;
  function a() {
    return {
      header: n.Header.fromPartial({}),
      valset: []
    };
  }
  e.HistoricalInfo = {
    typeUrl: "/cosmos.staking.v1beta1.HistoricalInfo",
    encode(g, P = w.BinaryWriter.create()) {
      g.header !== void 0 && n.Header.encode(g.header, P.uint32(10).fork()).ldelim();
      for (const A of g.valset)
        e.Validator.encode(A, P.uint32(18).fork()).ldelim();
      return P;
    },
    decode(g, P) {
      const A = g instanceof w.BinaryReader ? g : new w.BinaryReader(g);
      let W = P === void 0 ? A.len : A.pos + P;
      const L = a();
      for (; A.pos < W; ) {
        const $ = A.uint32();
        switch ($ >>> 3) {
          case 1:
            L.header = n.Header.decode(A, A.uint32());
            break;
          case 2:
            L.valset.push(e.Validator.decode(A, A.uint32()));
            break;
          default:
            A.skipType($ & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(g) {
      const P = a();
      return (0, T.isSet)(g.header) && (P.header = n.Header.fromJSON(g.header)), Array.isArray(g == null ? void 0 : g.valset) && (P.valset = g.valset.map((A) => e.Validator.fromJSON(A))), P;
    },
    toJSON(g) {
      const P = {};
      return g.header !== void 0 && (P.header = g.header ? n.Header.toJSON(g.header) : void 0), g.valset ? P.valset = g.valset.map((A) => A ? e.Validator.toJSON(A) : void 0) : P.valset = [], P;
    },
    fromPartial(g) {
      var A;
      const P = a();
      return g.header !== void 0 && g.header !== null && (P.header = n.Header.fromPartial(g.header)), P.valset = ((A = g.valset) == null ? void 0 : A.map((W) => e.Validator.fromPartial(W))) || [], P;
    }
  };
  function d() {
    return {
      rate: "",
      maxRate: "",
      maxChangeRate: ""
    };
  }
  e.CommissionRates = {
    typeUrl: "/cosmos.staking.v1beta1.CommissionRates",
    encode(g, P = w.BinaryWriter.create()) {
      return g.rate !== "" && P.uint32(10).string(g.rate), g.maxRate !== "" && P.uint32(18).string(g.maxRate), g.maxChangeRate !== "" && P.uint32(26).string(g.maxChangeRate), P;
    },
    decode(g, P) {
      const A = g instanceof w.BinaryReader ? g : new w.BinaryReader(g);
      let W = P === void 0 ? A.len : A.pos + P;
      const L = d();
      for (; A.pos < W; ) {
        const $ = A.uint32();
        switch ($ >>> 3) {
          case 1:
            L.rate = A.string();
            break;
          case 2:
            L.maxRate = A.string();
            break;
          case 3:
            L.maxChangeRate = A.string();
            break;
          default:
            A.skipType($ & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(g) {
      const P = d();
      return (0, T.isSet)(g.rate) && (P.rate = String(g.rate)), (0, T.isSet)(g.maxRate) && (P.maxRate = String(g.maxRate)), (0, T.isSet)(g.maxChangeRate) && (P.maxChangeRate = String(g.maxChangeRate)), P;
    },
    toJSON(g) {
      const P = {};
      return g.rate !== void 0 && (P.rate = g.rate), g.maxRate !== void 0 && (P.maxRate = g.maxRate), g.maxChangeRate !== void 0 && (P.maxChangeRate = g.maxChangeRate), P;
    },
    fromPartial(g) {
      const P = d();
      return P.rate = g.rate ?? "", P.maxRate = g.maxRate ?? "", P.maxChangeRate = g.maxChangeRate ?? "", P;
    }
  };
  function y() {
    return {
      commissionRates: e.CommissionRates.fromPartial({}),
      updateTime: r.Timestamp.fromPartial({})
    };
  }
  e.Commission = {
    typeUrl: "/cosmos.staking.v1beta1.Commission",
    encode(g, P = w.BinaryWriter.create()) {
      return g.commissionRates !== void 0 && e.CommissionRates.encode(g.commissionRates, P.uint32(10).fork()).ldelim(), g.updateTime !== void 0 && r.Timestamp.encode(g.updateTime, P.uint32(18).fork()).ldelim(), P;
    },
    decode(g, P) {
      const A = g instanceof w.BinaryReader ? g : new w.BinaryReader(g);
      let W = P === void 0 ? A.len : A.pos + P;
      const L = y();
      for (; A.pos < W; ) {
        const $ = A.uint32();
        switch ($ >>> 3) {
          case 1:
            L.commissionRates = e.CommissionRates.decode(A, A.uint32());
            break;
          case 2:
            L.updateTime = r.Timestamp.decode(A, A.uint32());
            break;
          default:
            A.skipType($ & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(g) {
      const P = y();
      return (0, T.isSet)(g.commissionRates) && (P.commissionRates = e.CommissionRates.fromJSON(g.commissionRates)), (0, T.isSet)(g.updateTime) && (P.updateTime = (0, T.fromJsonTimestamp)(g.updateTime)), P;
    },
    toJSON(g) {
      const P = {};
      return g.commissionRates !== void 0 && (P.commissionRates = g.commissionRates ? e.CommissionRates.toJSON(g.commissionRates) : void 0), g.updateTime !== void 0 && (P.updateTime = (0, T.fromTimestamp)(g.updateTime).toISOString()), P;
    },
    fromPartial(g) {
      const P = y();
      return g.commissionRates !== void 0 && g.commissionRates !== null && (P.commissionRates = e.CommissionRates.fromPartial(g.commissionRates)), g.updateTime !== void 0 && g.updateTime !== null && (P.updateTime = r.Timestamp.fromPartial(g.updateTime)), P;
    }
  };
  function _() {
    return {
      moniker: "",
      identity: "",
      website: "",
      securityContact: "",
      details: ""
    };
  }
  e.Description = {
    typeUrl: "/cosmos.staking.v1beta1.Description",
    encode(g, P = w.BinaryWriter.create()) {
      return g.moniker !== "" && P.uint32(10).string(g.moniker), g.identity !== "" && P.uint32(18).string(g.identity), g.website !== "" && P.uint32(26).string(g.website), g.securityContact !== "" && P.uint32(34).string(g.securityContact), g.details !== "" && P.uint32(42).string(g.details), P;
    },
    decode(g, P) {
      const A = g instanceof w.BinaryReader ? g : new w.BinaryReader(g);
      let W = P === void 0 ? A.len : A.pos + P;
      const L = _();
      for (; A.pos < W; ) {
        const $ = A.uint32();
        switch ($ >>> 3) {
          case 1:
            L.moniker = A.string();
            break;
          case 2:
            L.identity = A.string();
            break;
          case 3:
            L.website = A.string();
            break;
          case 4:
            L.securityContact = A.string();
            break;
          case 5:
            L.details = A.string();
            break;
          default:
            A.skipType($ & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(g) {
      const P = _();
      return (0, T.isSet)(g.moniker) && (P.moniker = String(g.moniker)), (0, T.isSet)(g.identity) && (P.identity = String(g.identity)), (0, T.isSet)(g.website) && (P.website = String(g.website)), (0, T.isSet)(g.securityContact) && (P.securityContact = String(g.securityContact)), (0, T.isSet)(g.details) && (P.details = String(g.details)), P;
    },
    toJSON(g) {
      const P = {};
      return g.moniker !== void 0 && (P.moniker = g.moniker), g.identity !== void 0 && (P.identity = g.identity), g.website !== void 0 && (P.website = g.website), g.securityContact !== void 0 && (P.securityContact = g.securityContact), g.details !== void 0 && (P.details = g.details), P;
    },
    fromPartial(g) {
      const P = _();
      return P.moniker = g.moniker ?? "", P.identity = g.identity ?? "", P.website = g.website ?? "", P.securityContact = g.securityContact ?? "", P.details = g.details ?? "", P;
    }
  };
  function E() {
    return {
      operatorAddress: "",
      consensusPubkey: void 0,
      jailed: !1,
      status: 0,
      tokens: "",
      delegatorShares: "",
      description: e.Description.fromPartial({}),
      unbondingHeight: BigInt(0),
      unbondingTime: r.Timestamp.fromPartial({}),
      commission: e.Commission.fromPartial({}),
      minSelfDelegation: "",
      unbondingOnHoldRefCount: BigInt(0),
      unbondingIds: []
    };
  }
  e.Validator = {
    typeUrl: "/cosmos.staking.v1beta1.Validator",
    encode(g, P = w.BinaryWriter.create()) {
      g.operatorAddress !== "" && P.uint32(10).string(g.operatorAddress), g.consensusPubkey !== void 0 && t.Any.encode(g.consensusPubkey, P.uint32(18).fork()).ldelim(), g.jailed === !0 && P.uint32(24).bool(g.jailed), g.status !== 0 && P.uint32(32).int32(g.status), g.tokens !== "" && P.uint32(42).string(g.tokens), g.delegatorShares !== "" && P.uint32(50).string(g.delegatorShares), g.description !== void 0 && e.Description.encode(g.description, P.uint32(58).fork()).ldelim(), g.unbondingHeight !== BigInt(0) && P.uint32(64).int64(g.unbondingHeight), g.unbondingTime !== void 0 && r.Timestamp.encode(g.unbondingTime, P.uint32(74).fork()).ldelim(), g.commission !== void 0 && e.Commission.encode(g.commission, P.uint32(82).fork()).ldelim(), g.minSelfDelegation !== "" && P.uint32(90).string(g.minSelfDelegation), g.unbondingOnHoldRefCount !== BigInt(0) && P.uint32(96).int64(g.unbondingOnHoldRefCount), P.uint32(106).fork();
      for (const A of g.unbondingIds)
        P.uint64(A);
      return P.ldelim(), P;
    },
    decode(g, P) {
      const A = g instanceof w.BinaryReader ? g : new w.BinaryReader(g);
      let W = P === void 0 ? A.len : A.pos + P;
      const L = E();
      for (; A.pos < W; ) {
        const $ = A.uint32();
        switch ($ >>> 3) {
          case 1:
            L.operatorAddress = A.string();
            break;
          case 2:
            L.consensusPubkey = t.Any.decode(A, A.uint32());
            break;
          case 3:
            L.jailed = A.bool();
            break;
          case 4:
            L.status = A.int32();
            break;
          case 5:
            L.tokens = A.string();
            break;
          case 6:
            L.delegatorShares = A.string();
            break;
          case 7:
            L.description = e.Description.decode(A, A.uint32());
            break;
          case 8:
            L.unbondingHeight = A.int64();
            break;
          case 9:
            L.unbondingTime = r.Timestamp.decode(A, A.uint32());
            break;
          case 10:
            L.commission = e.Commission.decode(A, A.uint32());
            break;
          case 11:
            L.minSelfDelegation = A.string();
            break;
          case 12:
            L.unbondingOnHoldRefCount = A.int64();
            break;
          case 13:
            if (($ & 7) === 2) {
              const ne = A.uint32() + A.pos;
              for (; A.pos < ne; )
                L.unbondingIds.push(A.uint64());
            } else
              L.unbondingIds.push(A.uint64());
            break;
          default:
            A.skipType($ & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(g) {
      const P = E();
      return (0, T.isSet)(g.operatorAddress) && (P.operatorAddress = String(g.operatorAddress)), (0, T.isSet)(g.consensusPubkey) && (P.consensusPubkey = t.Any.fromJSON(g.consensusPubkey)), (0, T.isSet)(g.jailed) && (P.jailed = !!g.jailed), (0, T.isSet)(g.status) && (P.status = C(g.status)), (0, T.isSet)(g.tokens) && (P.tokens = String(g.tokens)), (0, T.isSet)(g.delegatorShares) && (P.delegatorShares = String(g.delegatorShares)), (0, T.isSet)(g.description) && (P.description = e.Description.fromJSON(g.description)), (0, T.isSet)(g.unbondingHeight) && (P.unbondingHeight = BigInt(g.unbondingHeight.toString())), (0, T.isSet)(g.unbondingTime) && (P.unbondingTime = (0, T.fromJsonTimestamp)(g.unbondingTime)), (0, T.isSet)(g.commission) && (P.commission = e.Commission.fromJSON(g.commission)), (0, T.isSet)(g.minSelfDelegation) && (P.minSelfDelegation = String(g.minSelfDelegation)), (0, T.isSet)(g.unbondingOnHoldRefCount) && (P.unbondingOnHoldRefCount = BigInt(g.unbondingOnHoldRefCount.toString())), Array.isArray(g == null ? void 0 : g.unbondingIds) && (P.unbondingIds = g.unbondingIds.map((A) => BigInt(A.toString()))), P;
    },
    toJSON(g) {
      const P = {};
      return g.operatorAddress !== void 0 && (P.operatorAddress = g.operatorAddress), g.consensusPubkey !== void 0 && (P.consensusPubkey = g.consensusPubkey ? t.Any.toJSON(g.consensusPubkey) : void 0), g.jailed !== void 0 && (P.jailed = g.jailed), g.status !== void 0 && (P.status = R(g.status)), g.tokens !== void 0 && (P.tokens = g.tokens), g.delegatorShares !== void 0 && (P.delegatorShares = g.delegatorShares), g.description !== void 0 && (P.description = g.description ? e.Description.toJSON(g.description) : void 0), g.unbondingHeight !== void 0 && (P.unbondingHeight = (g.unbondingHeight || BigInt(0)).toString()), g.unbondingTime !== void 0 && (P.unbondingTime = (0, T.fromTimestamp)(g.unbondingTime).toISOString()), g.commission !== void 0 && (P.commission = g.commission ? e.Commission.toJSON(g.commission) : void 0), g.minSelfDelegation !== void 0 && (P.minSelfDelegation = g.minSelfDelegation), g.unbondingOnHoldRefCount !== void 0 && (P.unbondingOnHoldRefCount = (g.unbondingOnHoldRefCount || BigInt(0)).toString()), g.unbondingIds ? P.unbondingIds = g.unbondingIds.map((A) => (A || BigInt(0)).toString()) : P.unbondingIds = [], P;
    },
    fromPartial(g) {
      var A;
      const P = E();
      return P.operatorAddress = g.operatorAddress ?? "", g.consensusPubkey !== void 0 && g.consensusPubkey !== null && (P.consensusPubkey = t.Any.fromPartial(g.consensusPubkey)), P.jailed = g.jailed ?? !1, P.status = g.status ?? 0, P.tokens = g.tokens ?? "", P.delegatorShares = g.delegatorShares ?? "", g.description !== void 0 && g.description !== null && (P.description = e.Description.fromPartial(g.description)), g.unbondingHeight !== void 0 && g.unbondingHeight !== null && (P.unbondingHeight = BigInt(g.unbondingHeight.toString())), g.unbondingTime !== void 0 && g.unbondingTime !== null && (P.unbondingTime = r.Timestamp.fromPartial(g.unbondingTime)), g.commission !== void 0 && g.commission !== null && (P.commission = e.Commission.fromPartial(g.commission)), P.minSelfDelegation = g.minSelfDelegation ?? "", g.unbondingOnHoldRefCount !== void 0 && g.unbondingOnHoldRefCount !== null && (P.unbondingOnHoldRefCount = BigInt(g.unbondingOnHoldRefCount.toString())), P.unbondingIds = ((A = g.unbondingIds) == null ? void 0 : A.map((W) => BigInt(W.toString()))) || [], P;
    }
  };
  function U() {
    return {
      addresses: []
    };
  }
  e.ValAddresses = {
    typeUrl: "/cosmos.staking.v1beta1.ValAddresses",
    encode(g, P = w.BinaryWriter.create()) {
      for (const A of g.addresses)
        P.uint32(10).string(A);
      return P;
    },
    decode(g, P) {
      const A = g instanceof w.BinaryReader ? g : new w.BinaryReader(g);
      let W = P === void 0 ? A.len : A.pos + P;
      const L = U();
      for (; A.pos < W; ) {
        const $ = A.uint32();
        switch ($ >>> 3) {
          case 1:
            L.addresses.push(A.string());
            break;
          default:
            A.skipType($ & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(g) {
      const P = U();
      return Array.isArray(g == null ? void 0 : g.addresses) && (P.addresses = g.addresses.map((A) => String(A))), P;
    },
    toJSON(g) {
      const P = {};
      return g.addresses ? P.addresses = g.addresses.map((A) => A) : P.addresses = [], P;
    },
    fromPartial(g) {
      var A;
      const P = U();
      return P.addresses = ((A = g.addresses) == null ? void 0 : A.map((W) => W)) || [], P;
    }
  };
  function V() {
    return {
      delegatorAddress: "",
      validatorAddress: ""
    };
  }
  e.DVPair = {
    typeUrl: "/cosmos.staking.v1beta1.DVPair",
    encode(g, P = w.BinaryWriter.create()) {
      return g.delegatorAddress !== "" && P.uint32(10).string(g.delegatorAddress), g.validatorAddress !== "" && P.uint32(18).string(g.validatorAddress), P;
    },
    decode(g, P) {
      const A = g instanceof w.BinaryReader ? g : new w.BinaryReader(g);
      let W = P === void 0 ? A.len : A.pos + P;
      const L = V();
      for (; A.pos < W; ) {
        const $ = A.uint32();
        switch ($ >>> 3) {
          case 1:
            L.delegatorAddress = A.string();
            break;
          case 2:
            L.validatorAddress = A.string();
            break;
          default:
            A.skipType($ & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(g) {
      const P = V();
      return (0, T.isSet)(g.delegatorAddress) && (P.delegatorAddress = String(g.delegatorAddress)), (0, T.isSet)(g.validatorAddress) && (P.validatorAddress = String(g.validatorAddress)), P;
    },
    toJSON(g) {
      const P = {};
      return g.delegatorAddress !== void 0 && (P.delegatorAddress = g.delegatorAddress), g.validatorAddress !== void 0 && (P.validatorAddress = g.validatorAddress), P;
    },
    fromPartial(g) {
      const P = V();
      return P.delegatorAddress = g.delegatorAddress ?? "", P.validatorAddress = g.validatorAddress ?? "", P;
    }
  };
  function o() {
    return {
      pairs: []
    };
  }
  e.DVPairs = {
    typeUrl: "/cosmos.staking.v1beta1.DVPairs",
    encode(g, P = w.BinaryWriter.create()) {
      for (const A of g.pairs)
        e.DVPair.encode(A, P.uint32(10).fork()).ldelim();
      return P;
    },
    decode(g, P) {
      const A = g instanceof w.BinaryReader ? g : new w.BinaryReader(g);
      let W = P === void 0 ? A.len : A.pos + P;
      const L = o();
      for (; A.pos < W; ) {
        const $ = A.uint32();
        switch ($ >>> 3) {
          case 1:
            L.pairs.push(e.DVPair.decode(A, A.uint32()));
            break;
          default:
            A.skipType($ & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(g) {
      const P = o();
      return Array.isArray(g == null ? void 0 : g.pairs) && (P.pairs = g.pairs.map((A) => e.DVPair.fromJSON(A))), P;
    },
    toJSON(g) {
      const P = {};
      return g.pairs ? P.pairs = g.pairs.map((A) => A ? e.DVPair.toJSON(A) : void 0) : P.pairs = [], P;
    },
    fromPartial(g) {
      var A;
      const P = o();
      return P.pairs = ((A = g.pairs) == null ? void 0 : A.map((W) => e.DVPair.fromPartial(W))) || [], P;
    }
  };
  function h() {
    return {
      delegatorAddress: "",
      validatorSrcAddress: "",
      validatorDstAddress: ""
    };
  }
  e.DVVTriplet = {
    typeUrl: "/cosmos.staking.v1beta1.DVVTriplet",
    encode(g, P = w.BinaryWriter.create()) {
      return g.delegatorAddress !== "" && P.uint32(10).string(g.delegatorAddress), g.validatorSrcAddress !== "" && P.uint32(18).string(g.validatorSrcAddress), g.validatorDstAddress !== "" && P.uint32(26).string(g.validatorDstAddress), P;
    },
    decode(g, P) {
      const A = g instanceof w.BinaryReader ? g : new w.BinaryReader(g);
      let W = P === void 0 ? A.len : A.pos + P;
      const L = h();
      for (; A.pos < W; ) {
        const $ = A.uint32();
        switch ($ >>> 3) {
          case 1:
            L.delegatorAddress = A.string();
            break;
          case 2:
            L.validatorSrcAddress = A.string();
            break;
          case 3:
            L.validatorDstAddress = A.string();
            break;
          default:
            A.skipType($ & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(g) {
      const P = h();
      return (0, T.isSet)(g.delegatorAddress) && (P.delegatorAddress = String(g.delegatorAddress)), (0, T.isSet)(g.validatorSrcAddress) && (P.validatorSrcAddress = String(g.validatorSrcAddress)), (0, T.isSet)(g.validatorDstAddress) && (P.validatorDstAddress = String(g.validatorDstAddress)), P;
    },
    toJSON(g) {
      const P = {};
      return g.delegatorAddress !== void 0 && (P.delegatorAddress = g.delegatorAddress), g.validatorSrcAddress !== void 0 && (P.validatorSrcAddress = g.validatorSrcAddress), g.validatorDstAddress !== void 0 && (P.validatorDstAddress = g.validatorDstAddress), P;
    },
    fromPartial(g) {
      const P = h();
      return P.delegatorAddress = g.delegatorAddress ?? "", P.validatorSrcAddress = g.validatorSrcAddress ?? "", P.validatorDstAddress = g.validatorDstAddress ?? "", P;
    }
  };
  function N() {
    return {
      triplets: []
    };
  }
  e.DVVTriplets = {
    typeUrl: "/cosmos.staking.v1beta1.DVVTriplets",
    encode(g, P = w.BinaryWriter.create()) {
      for (const A of g.triplets)
        e.DVVTriplet.encode(A, P.uint32(10).fork()).ldelim();
      return P;
    },
    decode(g, P) {
      const A = g instanceof w.BinaryReader ? g : new w.BinaryReader(g);
      let W = P === void 0 ? A.len : A.pos + P;
      const L = N();
      for (; A.pos < W; ) {
        const $ = A.uint32();
        switch ($ >>> 3) {
          case 1:
            L.triplets.push(e.DVVTriplet.decode(A, A.uint32()));
            break;
          default:
            A.skipType($ & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(g) {
      const P = N();
      return Array.isArray(g == null ? void 0 : g.triplets) && (P.triplets = g.triplets.map((A) => e.DVVTriplet.fromJSON(A))), P;
    },
    toJSON(g) {
      const P = {};
      return g.triplets ? P.triplets = g.triplets.map((A) => A ? e.DVVTriplet.toJSON(A) : void 0) : P.triplets = [], P;
    },
    fromPartial(g) {
      var A;
      const P = N();
      return P.triplets = ((A = g.triplets) == null ? void 0 : A.map((W) => e.DVVTriplet.fromPartial(W))) || [], P;
    }
  };
  function q() {
    return {
      delegatorAddress: "",
      validatorAddress: "",
      shares: ""
    };
  }
  e.Delegation = {
    typeUrl: "/cosmos.staking.v1beta1.Delegation",
    encode(g, P = w.BinaryWriter.create()) {
      return g.delegatorAddress !== "" && P.uint32(10).string(g.delegatorAddress), g.validatorAddress !== "" && P.uint32(18).string(g.validatorAddress), g.shares !== "" && P.uint32(26).string(g.shares), P;
    },
    decode(g, P) {
      const A = g instanceof w.BinaryReader ? g : new w.BinaryReader(g);
      let W = P === void 0 ? A.len : A.pos + P;
      const L = q();
      for (; A.pos < W; ) {
        const $ = A.uint32();
        switch ($ >>> 3) {
          case 1:
            L.delegatorAddress = A.string();
            break;
          case 2:
            L.validatorAddress = A.string();
            break;
          case 3:
            L.shares = A.string();
            break;
          default:
            A.skipType($ & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(g) {
      const P = q();
      return (0, T.isSet)(g.delegatorAddress) && (P.delegatorAddress = String(g.delegatorAddress)), (0, T.isSet)(g.validatorAddress) && (P.validatorAddress = String(g.validatorAddress)), (0, T.isSet)(g.shares) && (P.shares = String(g.shares)), P;
    },
    toJSON(g) {
      const P = {};
      return g.delegatorAddress !== void 0 && (P.delegatorAddress = g.delegatorAddress), g.validatorAddress !== void 0 && (P.validatorAddress = g.validatorAddress), g.shares !== void 0 && (P.shares = g.shares), P;
    },
    fromPartial(g) {
      const P = q();
      return P.delegatorAddress = g.delegatorAddress ?? "", P.validatorAddress = g.validatorAddress ?? "", P.shares = g.shares ?? "", P;
    }
  };
  function u() {
    return {
      delegatorAddress: "",
      validatorAddress: "",
      entries: []
    };
  }
  e.UnbondingDelegation = {
    typeUrl: "/cosmos.staking.v1beta1.UnbondingDelegation",
    encode(g, P = w.BinaryWriter.create()) {
      g.delegatorAddress !== "" && P.uint32(10).string(g.delegatorAddress), g.validatorAddress !== "" && P.uint32(18).string(g.validatorAddress);
      for (const A of g.entries)
        e.UnbondingDelegationEntry.encode(A, P.uint32(26).fork()).ldelim();
      return P;
    },
    decode(g, P) {
      const A = g instanceof w.BinaryReader ? g : new w.BinaryReader(g);
      let W = P === void 0 ? A.len : A.pos + P;
      const L = u();
      for (; A.pos < W; ) {
        const $ = A.uint32();
        switch ($ >>> 3) {
          case 1:
            L.delegatorAddress = A.string();
            break;
          case 2:
            L.validatorAddress = A.string();
            break;
          case 3:
            L.entries.push(e.UnbondingDelegationEntry.decode(A, A.uint32()));
            break;
          default:
            A.skipType($ & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(g) {
      const P = u();
      return (0, T.isSet)(g.delegatorAddress) && (P.delegatorAddress = String(g.delegatorAddress)), (0, T.isSet)(g.validatorAddress) && (P.validatorAddress = String(g.validatorAddress)), Array.isArray(g == null ? void 0 : g.entries) && (P.entries = g.entries.map((A) => e.UnbondingDelegationEntry.fromJSON(A))), P;
    },
    toJSON(g) {
      const P = {};
      return g.delegatorAddress !== void 0 && (P.delegatorAddress = g.delegatorAddress), g.validatorAddress !== void 0 && (P.validatorAddress = g.validatorAddress), g.entries ? P.entries = g.entries.map((A) => A ? e.UnbondingDelegationEntry.toJSON(A) : void 0) : P.entries = [], P;
    },
    fromPartial(g) {
      var A;
      const P = u();
      return P.delegatorAddress = g.delegatorAddress ?? "", P.validatorAddress = g.validatorAddress ?? "", P.entries = ((A = g.entries) == null ? void 0 : A.map((W) => e.UnbondingDelegationEntry.fromPartial(W))) || [], P;
    }
  };
  function l() {
    return {
      creationHeight: BigInt(0),
      completionTime: r.Timestamp.fromPartial({}),
      initialBalance: "",
      balance: "",
      unbondingId: BigInt(0),
      unbondingOnHoldRefCount: BigInt(0)
    };
  }
  e.UnbondingDelegationEntry = {
    typeUrl: "/cosmos.staking.v1beta1.UnbondingDelegationEntry",
    encode(g, P = w.BinaryWriter.create()) {
      return g.creationHeight !== BigInt(0) && P.uint32(8).int64(g.creationHeight), g.completionTime !== void 0 && r.Timestamp.encode(g.completionTime, P.uint32(18).fork()).ldelim(), g.initialBalance !== "" && P.uint32(26).string(g.initialBalance), g.balance !== "" && P.uint32(34).string(g.balance), g.unbondingId !== BigInt(0) && P.uint32(40).uint64(g.unbondingId), g.unbondingOnHoldRefCount !== BigInt(0) && P.uint32(48).int64(g.unbondingOnHoldRefCount), P;
    },
    decode(g, P) {
      const A = g instanceof w.BinaryReader ? g : new w.BinaryReader(g);
      let W = P === void 0 ? A.len : A.pos + P;
      const L = l();
      for (; A.pos < W; ) {
        const $ = A.uint32();
        switch ($ >>> 3) {
          case 1:
            L.creationHeight = A.int64();
            break;
          case 2:
            L.completionTime = r.Timestamp.decode(A, A.uint32());
            break;
          case 3:
            L.initialBalance = A.string();
            break;
          case 4:
            L.balance = A.string();
            break;
          case 5:
            L.unbondingId = A.uint64();
            break;
          case 6:
            L.unbondingOnHoldRefCount = A.int64();
            break;
          default:
            A.skipType($ & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(g) {
      const P = l();
      return (0, T.isSet)(g.creationHeight) && (P.creationHeight = BigInt(g.creationHeight.toString())), (0, T.isSet)(g.completionTime) && (P.completionTime = (0, T.fromJsonTimestamp)(g.completionTime)), (0, T.isSet)(g.initialBalance) && (P.initialBalance = String(g.initialBalance)), (0, T.isSet)(g.balance) && (P.balance = String(g.balance)), (0, T.isSet)(g.unbondingId) && (P.unbondingId = BigInt(g.unbondingId.toString())), (0, T.isSet)(g.unbondingOnHoldRefCount) && (P.unbondingOnHoldRefCount = BigInt(g.unbondingOnHoldRefCount.toString())), P;
    },
    toJSON(g) {
      const P = {};
      return g.creationHeight !== void 0 && (P.creationHeight = (g.creationHeight || BigInt(0)).toString()), g.completionTime !== void 0 && (P.completionTime = (0, T.fromTimestamp)(g.completionTime).toISOString()), g.initialBalance !== void 0 && (P.initialBalance = g.initialBalance), g.balance !== void 0 && (P.balance = g.balance), g.unbondingId !== void 0 && (P.unbondingId = (g.unbondingId || BigInt(0)).toString()), g.unbondingOnHoldRefCount !== void 0 && (P.unbondingOnHoldRefCount = (g.unbondingOnHoldRefCount || BigInt(0)).toString()), P;
    },
    fromPartial(g) {
      const P = l();
      return g.creationHeight !== void 0 && g.creationHeight !== null && (P.creationHeight = BigInt(g.creationHeight.toString())), g.completionTime !== void 0 && g.completionTime !== null && (P.completionTime = r.Timestamp.fromPartial(g.completionTime)), P.initialBalance = g.initialBalance ?? "", P.balance = g.balance ?? "", g.unbondingId !== void 0 && g.unbondingId !== null && (P.unbondingId = BigInt(g.unbondingId.toString())), g.unbondingOnHoldRefCount !== void 0 && g.unbondingOnHoldRefCount !== null && (P.unbondingOnHoldRefCount = BigInt(g.unbondingOnHoldRefCount.toString())), P;
    }
  };
  function I() {
    return {
      creationHeight: BigInt(0),
      completionTime: r.Timestamp.fromPartial({}),
      initialBalance: "",
      sharesDst: "",
      unbondingId: BigInt(0),
      unbondingOnHoldRefCount: BigInt(0)
    };
  }
  e.RedelegationEntry = {
    typeUrl: "/cosmos.staking.v1beta1.RedelegationEntry",
    encode(g, P = w.BinaryWriter.create()) {
      return g.creationHeight !== BigInt(0) && P.uint32(8).int64(g.creationHeight), g.completionTime !== void 0 && r.Timestamp.encode(g.completionTime, P.uint32(18).fork()).ldelim(), g.initialBalance !== "" && P.uint32(26).string(g.initialBalance), g.sharesDst !== "" && P.uint32(34).string(g.sharesDst), g.unbondingId !== BigInt(0) && P.uint32(40).uint64(g.unbondingId), g.unbondingOnHoldRefCount !== BigInt(0) && P.uint32(48).int64(g.unbondingOnHoldRefCount), P;
    },
    decode(g, P) {
      const A = g instanceof w.BinaryReader ? g : new w.BinaryReader(g);
      let W = P === void 0 ? A.len : A.pos + P;
      const L = I();
      for (; A.pos < W; ) {
        const $ = A.uint32();
        switch ($ >>> 3) {
          case 1:
            L.creationHeight = A.int64();
            break;
          case 2:
            L.completionTime = r.Timestamp.decode(A, A.uint32());
            break;
          case 3:
            L.initialBalance = A.string();
            break;
          case 4:
            L.sharesDst = A.string();
            break;
          case 5:
            L.unbondingId = A.uint64();
            break;
          case 6:
            L.unbondingOnHoldRefCount = A.int64();
            break;
          default:
            A.skipType($ & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(g) {
      const P = I();
      return (0, T.isSet)(g.creationHeight) && (P.creationHeight = BigInt(g.creationHeight.toString())), (0, T.isSet)(g.completionTime) && (P.completionTime = (0, T.fromJsonTimestamp)(g.completionTime)), (0, T.isSet)(g.initialBalance) && (P.initialBalance = String(g.initialBalance)), (0, T.isSet)(g.sharesDst) && (P.sharesDst = String(g.sharesDst)), (0, T.isSet)(g.unbondingId) && (P.unbondingId = BigInt(g.unbondingId.toString())), (0, T.isSet)(g.unbondingOnHoldRefCount) && (P.unbondingOnHoldRefCount = BigInt(g.unbondingOnHoldRefCount.toString())), P;
    },
    toJSON(g) {
      const P = {};
      return g.creationHeight !== void 0 && (P.creationHeight = (g.creationHeight || BigInt(0)).toString()), g.completionTime !== void 0 && (P.completionTime = (0, T.fromTimestamp)(g.completionTime).toISOString()), g.initialBalance !== void 0 && (P.initialBalance = g.initialBalance), g.sharesDst !== void 0 && (P.sharesDst = g.sharesDst), g.unbondingId !== void 0 && (P.unbondingId = (g.unbondingId || BigInt(0)).toString()), g.unbondingOnHoldRefCount !== void 0 && (P.unbondingOnHoldRefCount = (g.unbondingOnHoldRefCount || BigInt(0)).toString()), P;
    },
    fromPartial(g) {
      const P = I();
      return g.creationHeight !== void 0 && g.creationHeight !== null && (P.creationHeight = BigInt(g.creationHeight.toString())), g.completionTime !== void 0 && g.completionTime !== null && (P.completionTime = r.Timestamp.fromPartial(g.completionTime)), P.initialBalance = g.initialBalance ?? "", P.sharesDst = g.sharesDst ?? "", g.unbondingId !== void 0 && g.unbondingId !== null && (P.unbondingId = BigInt(g.unbondingId.toString())), g.unbondingOnHoldRefCount !== void 0 && g.unbondingOnHoldRefCount !== null && (P.unbondingOnHoldRefCount = BigInt(g.unbondingOnHoldRefCount.toString())), P;
    }
  };
  function B() {
    return {
      delegatorAddress: "",
      validatorSrcAddress: "",
      validatorDstAddress: "",
      entries: []
    };
  }
  e.Redelegation = {
    typeUrl: "/cosmos.staking.v1beta1.Redelegation",
    encode(g, P = w.BinaryWriter.create()) {
      g.delegatorAddress !== "" && P.uint32(10).string(g.delegatorAddress), g.validatorSrcAddress !== "" && P.uint32(18).string(g.validatorSrcAddress), g.validatorDstAddress !== "" && P.uint32(26).string(g.validatorDstAddress);
      for (const A of g.entries)
        e.RedelegationEntry.encode(A, P.uint32(34).fork()).ldelim();
      return P;
    },
    decode(g, P) {
      const A = g instanceof w.BinaryReader ? g : new w.BinaryReader(g);
      let W = P === void 0 ? A.len : A.pos + P;
      const L = B();
      for (; A.pos < W; ) {
        const $ = A.uint32();
        switch ($ >>> 3) {
          case 1:
            L.delegatorAddress = A.string();
            break;
          case 2:
            L.validatorSrcAddress = A.string();
            break;
          case 3:
            L.validatorDstAddress = A.string();
            break;
          case 4:
            L.entries.push(e.RedelegationEntry.decode(A, A.uint32()));
            break;
          default:
            A.skipType($ & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(g) {
      const P = B();
      return (0, T.isSet)(g.delegatorAddress) && (P.delegatorAddress = String(g.delegatorAddress)), (0, T.isSet)(g.validatorSrcAddress) && (P.validatorSrcAddress = String(g.validatorSrcAddress)), (0, T.isSet)(g.validatorDstAddress) && (P.validatorDstAddress = String(g.validatorDstAddress)), Array.isArray(g == null ? void 0 : g.entries) && (P.entries = g.entries.map((A) => e.RedelegationEntry.fromJSON(A))), P;
    },
    toJSON(g) {
      const P = {};
      return g.delegatorAddress !== void 0 && (P.delegatorAddress = g.delegatorAddress), g.validatorSrcAddress !== void 0 && (P.validatorSrcAddress = g.validatorSrcAddress), g.validatorDstAddress !== void 0 && (P.validatorDstAddress = g.validatorDstAddress), g.entries ? P.entries = g.entries.map((A) => A ? e.RedelegationEntry.toJSON(A) : void 0) : P.entries = [], P;
    },
    fromPartial(g) {
      var A;
      const P = B();
      return P.delegatorAddress = g.delegatorAddress ?? "", P.validatorSrcAddress = g.validatorSrcAddress ?? "", P.validatorDstAddress = g.validatorDstAddress ?? "", P.entries = ((A = g.entries) == null ? void 0 : A.map((W) => e.RedelegationEntry.fromPartial(W))) || [], P;
    }
  };
  function b() {
    return {
      unbondingTime: i.Duration.fromPartial({}),
      maxValidators: 0,
      maxEntries: 0,
      historicalEntries: 0,
      bondDenom: "",
      minCommissionRate: ""
    };
  }
  e.Params = {
    typeUrl: "/cosmos.staking.v1beta1.Params",
    encode(g, P = w.BinaryWriter.create()) {
      return g.unbondingTime !== void 0 && i.Duration.encode(g.unbondingTime, P.uint32(10).fork()).ldelim(), g.maxValidators !== 0 && P.uint32(16).uint32(g.maxValidators), g.maxEntries !== 0 && P.uint32(24).uint32(g.maxEntries), g.historicalEntries !== 0 && P.uint32(32).uint32(g.historicalEntries), g.bondDenom !== "" && P.uint32(42).string(g.bondDenom), g.minCommissionRate !== "" && P.uint32(50).string(g.minCommissionRate), P;
    },
    decode(g, P) {
      const A = g instanceof w.BinaryReader ? g : new w.BinaryReader(g);
      let W = P === void 0 ? A.len : A.pos + P;
      const L = b();
      for (; A.pos < W; ) {
        const $ = A.uint32();
        switch ($ >>> 3) {
          case 1:
            L.unbondingTime = i.Duration.decode(A, A.uint32());
            break;
          case 2:
            L.maxValidators = A.uint32();
            break;
          case 3:
            L.maxEntries = A.uint32();
            break;
          case 4:
            L.historicalEntries = A.uint32();
            break;
          case 5:
            L.bondDenom = A.string();
            break;
          case 6:
            L.minCommissionRate = A.string();
            break;
          default:
            A.skipType($ & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(g) {
      const P = b();
      return (0, T.isSet)(g.unbondingTime) && (P.unbondingTime = i.Duration.fromJSON(g.unbondingTime)), (0, T.isSet)(g.maxValidators) && (P.maxValidators = Number(g.maxValidators)), (0, T.isSet)(g.maxEntries) && (P.maxEntries = Number(g.maxEntries)), (0, T.isSet)(g.historicalEntries) && (P.historicalEntries = Number(g.historicalEntries)), (0, T.isSet)(g.bondDenom) && (P.bondDenom = String(g.bondDenom)), (0, T.isSet)(g.minCommissionRate) && (P.minCommissionRate = String(g.minCommissionRate)), P;
    },
    toJSON(g) {
      const P = {};
      return g.unbondingTime !== void 0 && (P.unbondingTime = g.unbondingTime ? i.Duration.toJSON(g.unbondingTime) : void 0), g.maxValidators !== void 0 && (P.maxValidators = Math.round(g.maxValidators)), g.maxEntries !== void 0 && (P.maxEntries = Math.round(g.maxEntries)), g.historicalEntries !== void 0 && (P.historicalEntries = Math.round(g.historicalEntries)), g.bondDenom !== void 0 && (P.bondDenom = g.bondDenom), g.minCommissionRate !== void 0 && (P.minCommissionRate = g.minCommissionRate), P;
    },
    fromPartial(g) {
      const P = b();
      return g.unbondingTime !== void 0 && g.unbondingTime !== null && (P.unbondingTime = i.Duration.fromPartial(g.unbondingTime)), P.maxValidators = g.maxValidators ?? 0, P.maxEntries = g.maxEntries ?? 0, P.historicalEntries = g.historicalEntries ?? 0, P.bondDenom = g.bondDenom ?? "", P.minCommissionRate = g.minCommissionRate ?? "", P;
    }
  };
  function D() {
    return {
      delegation: e.Delegation.fromPartial({}),
      balance: f.Coin.fromPartial({})
    };
  }
  e.DelegationResponse = {
    typeUrl: "/cosmos.staking.v1beta1.DelegationResponse",
    encode(g, P = w.BinaryWriter.create()) {
      return g.delegation !== void 0 && e.Delegation.encode(g.delegation, P.uint32(10).fork()).ldelim(), g.balance !== void 0 && f.Coin.encode(g.balance, P.uint32(18).fork()).ldelim(), P;
    },
    decode(g, P) {
      const A = g instanceof w.BinaryReader ? g : new w.BinaryReader(g);
      let W = P === void 0 ? A.len : A.pos + P;
      const L = D();
      for (; A.pos < W; ) {
        const $ = A.uint32();
        switch ($ >>> 3) {
          case 1:
            L.delegation = e.Delegation.decode(A, A.uint32());
            break;
          case 2:
            L.balance = f.Coin.decode(A, A.uint32());
            break;
          default:
            A.skipType($ & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(g) {
      const P = D();
      return (0, T.isSet)(g.delegation) && (P.delegation = e.Delegation.fromJSON(g.delegation)), (0, T.isSet)(g.balance) && (P.balance = f.Coin.fromJSON(g.balance)), P;
    },
    toJSON(g) {
      const P = {};
      return g.delegation !== void 0 && (P.delegation = g.delegation ? e.Delegation.toJSON(g.delegation) : void 0), g.balance !== void 0 && (P.balance = g.balance ? f.Coin.toJSON(g.balance) : void 0), P;
    },
    fromPartial(g) {
      const P = D();
      return g.delegation !== void 0 && g.delegation !== null && (P.delegation = e.Delegation.fromPartial(g.delegation)), g.balance !== void 0 && g.balance !== null && (P.balance = f.Coin.fromPartial(g.balance)), P;
    }
  };
  function Q() {
    return {
      redelegationEntry: e.RedelegationEntry.fromPartial({}),
      balance: ""
    };
  }
  e.RedelegationEntryResponse = {
    typeUrl: "/cosmos.staking.v1beta1.RedelegationEntryResponse",
    encode(g, P = w.BinaryWriter.create()) {
      return g.redelegationEntry !== void 0 && e.RedelegationEntry.encode(g.redelegationEntry, P.uint32(10).fork()).ldelim(), g.balance !== "" && P.uint32(34).string(g.balance), P;
    },
    decode(g, P) {
      const A = g instanceof w.BinaryReader ? g : new w.BinaryReader(g);
      let W = P === void 0 ? A.len : A.pos + P;
      const L = Q();
      for (; A.pos < W; ) {
        const $ = A.uint32();
        switch ($ >>> 3) {
          case 1:
            L.redelegationEntry = e.RedelegationEntry.decode(A, A.uint32());
            break;
          case 4:
            L.balance = A.string();
            break;
          default:
            A.skipType($ & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(g) {
      const P = Q();
      return (0, T.isSet)(g.redelegationEntry) && (P.redelegationEntry = e.RedelegationEntry.fromJSON(g.redelegationEntry)), (0, T.isSet)(g.balance) && (P.balance = String(g.balance)), P;
    },
    toJSON(g) {
      const P = {};
      return g.redelegationEntry !== void 0 && (P.redelegationEntry = g.redelegationEntry ? e.RedelegationEntry.toJSON(g.redelegationEntry) : void 0), g.balance !== void 0 && (P.balance = g.balance), P;
    },
    fromPartial(g) {
      const P = Q();
      return g.redelegationEntry !== void 0 && g.redelegationEntry !== null && (P.redelegationEntry = e.RedelegationEntry.fromPartial(g.redelegationEntry)), P.balance = g.balance ?? "", P;
    }
  };
  function H() {
    return {
      redelegation: e.Redelegation.fromPartial({}),
      entries: []
    };
  }
  e.RedelegationResponse = {
    typeUrl: "/cosmos.staking.v1beta1.RedelegationResponse",
    encode(g, P = w.BinaryWriter.create()) {
      g.redelegation !== void 0 && e.Redelegation.encode(g.redelegation, P.uint32(10).fork()).ldelim();
      for (const A of g.entries)
        e.RedelegationEntryResponse.encode(A, P.uint32(18).fork()).ldelim();
      return P;
    },
    decode(g, P) {
      const A = g instanceof w.BinaryReader ? g : new w.BinaryReader(g);
      let W = P === void 0 ? A.len : A.pos + P;
      const L = H();
      for (; A.pos < W; ) {
        const $ = A.uint32();
        switch ($ >>> 3) {
          case 1:
            L.redelegation = e.Redelegation.decode(A, A.uint32());
            break;
          case 2:
            L.entries.push(e.RedelegationEntryResponse.decode(A, A.uint32()));
            break;
          default:
            A.skipType($ & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(g) {
      const P = H();
      return (0, T.isSet)(g.redelegation) && (P.redelegation = e.Redelegation.fromJSON(g.redelegation)), Array.isArray(g == null ? void 0 : g.entries) && (P.entries = g.entries.map((A) => e.RedelegationEntryResponse.fromJSON(A))), P;
    },
    toJSON(g) {
      const P = {};
      return g.redelegation !== void 0 && (P.redelegation = g.redelegation ? e.Redelegation.toJSON(g.redelegation) : void 0), g.entries ? P.entries = g.entries.map((A) => A ? e.RedelegationEntryResponse.toJSON(A) : void 0) : P.entries = [], P;
    },
    fromPartial(g) {
      var A;
      const P = H();
      return g.redelegation !== void 0 && g.redelegation !== null && (P.redelegation = e.Redelegation.fromPartial(g.redelegation)), P.entries = ((A = g.entries) == null ? void 0 : A.map((W) => e.RedelegationEntryResponse.fromPartial(W))) || [], P;
    }
  };
  function s() {
    return {
      notBondedTokens: "",
      bondedTokens: ""
    };
  }
  e.Pool = {
    typeUrl: "/cosmos.staking.v1beta1.Pool",
    encode(g, P = w.BinaryWriter.create()) {
      return g.notBondedTokens !== "" && P.uint32(10).string(g.notBondedTokens), g.bondedTokens !== "" && P.uint32(18).string(g.bondedTokens), P;
    },
    decode(g, P) {
      const A = g instanceof w.BinaryReader ? g : new w.BinaryReader(g);
      let W = P === void 0 ? A.len : A.pos + P;
      const L = s();
      for (; A.pos < W; ) {
        const $ = A.uint32();
        switch ($ >>> 3) {
          case 1:
            L.notBondedTokens = A.string();
            break;
          case 2:
            L.bondedTokens = A.string();
            break;
          default:
            A.skipType($ & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(g) {
      const P = s();
      return (0, T.isSet)(g.notBondedTokens) && (P.notBondedTokens = String(g.notBondedTokens)), (0, T.isSet)(g.bondedTokens) && (P.bondedTokens = String(g.bondedTokens)), P;
    },
    toJSON(g) {
      const P = {};
      return g.notBondedTokens !== void 0 && (P.notBondedTokens = g.notBondedTokens), g.bondedTokens !== void 0 && (P.bondedTokens = g.bondedTokens), P;
    },
    fromPartial(g) {
      const P = s();
      return P.notBondedTokens = g.notBondedTokens ?? "", P.bondedTokens = g.bondedTokens ?? "", P;
    }
  };
  function k() {
    return {
      updates: []
    };
  }
  e.ValidatorUpdates = {
    typeUrl: "/cosmos.staking.v1beta1.ValidatorUpdates",
    encode(g, P = w.BinaryWriter.create()) {
      for (const A of g.updates)
        S.ValidatorUpdate.encode(A, P.uint32(10).fork()).ldelim();
      return P;
    },
    decode(g, P) {
      const A = g instanceof w.BinaryReader ? g : new w.BinaryReader(g);
      let W = P === void 0 ? A.len : A.pos + P;
      const L = k();
      for (; A.pos < W; ) {
        const $ = A.uint32();
        switch ($ >>> 3) {
          case 1:
            L.updates.push(S.ValidatorUpdate.decode(A, A.uint32()));
            break;
          default:
            A.skipType($ & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(g) {
      const P = k();
      return Array.isArray(g == null ? void 0 : g.updates) && (P.updates = g.updates.map((A) => S.ValidatorUpdate.fromJSON(A))), P;
    },
    toJSON(g) {
      const P = {};
      return g.updates ? P.updates = g.updates.map((A) => A ? S.ValidatorUpdate.toJSON(A) : void 0) : P.updates = [], P;
    },
    fromPartial(g) {
      var A;
      const P = k();
      return P.updates = ((A = g.updates) == null ? void 0 : A.map((W) => S.ValidatorUpdate.fromPartial(W))) || [], P;
    }
  };
})(jc);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgUpdateParamsResponse = e.MsgUpdateParams = e.MsgCancelUnbondingDelegationResponse = e.MsgCancelUnbondingDelegation = e.MsgUndelegateResponse = e.MsgUndelegate = e.MsgBeginRedelegateResponse = e.MsgBeginRedelegate = e.MsgDelegateResponse = e.MsgDelegate = e.MsgEditValidatorResponse = e.MsgEditValidator = e.MsgCreateValidatorResponse = e.MsgCreateValidator = e.protobufPackage = void 0;
  const n = jc, r = Pe, t = De, i = Je, f = re, S = ie;
  e.protobufPackage = "cosmos.staking.v1beta1";
  function w() {
    return {
      description: n.Description.fromPartial({}),
      commission: n.CommissionRates.fromPartial({}),
      minSelfDelegation: "",
      delegatorAddress: "",
      validatorAddress: "",
      pubkey: void 0,
      value: t.Coin.fromPartial({})
    };
  }
  e.MsgCreateValidator = {
    typeUrl: "/cosmos.staking.v1beta1.MsgCreateValidator",
    encode(o, h = f.BinaryWriter.create()) {
      return o.description !== void 0 && n.Description.encode(o.description, h.uint32(10).fork()).ldelim(), o.commission !== void 0 && n.CommissionRates.encode(o.commission, h.uint32(18).fork()).ldelim(), o.minSelfDelegation !== "" && h.uint32(26).string(o.minSelfDelegation), o.delegatorAddress !== "" && h.uint32(34).string(o.delegatorAddress), o.validatorAddress !== "" && h.uint32(42).string(o.validatorAddress), o.pubkey !== void 0 && r.Any.encode(o.pubkey, h.uint32(50).fork()).ldelim(), o.value !== void 0 && t.Coin.encode(o.value, h.uint32(58).fork()).ldelim(), h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = w();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.description = n.Description.decode(N, N.uint32());
            break;
          case 2:
            u.commission = n.CommissionRates.decode(N, N.uint32());
            break;
          case 3:
            u.minSelfDelegation = N.string();
            break;
          case 4:
            u.delegatorAddress = N.string();
            break;
          case 5:
            u.validatorAddress = N.string();
            break;
          case 6:
            u.pubkey = r.Any.decode(N, N.uint32());
            break;
          case 7:
            u.value = t.Coin.decode(N, N.uint32());
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = w();
      return (0, S.isSet)(o.description) && (h.description = n.Description.fromJSON(o.description)), (0, S.isSet)(o.commission) && (h.commission = n.CommissionRates.fromJSON(o.commission)), (0, S.isSet)(o.minSelfDelegation) && (h.minSelfDelegation = String(o.minSelfDelegation)), (0, S.isSet)(o.delegatorAddress) && (h.delegatorAddress = String(o.delegatorAddress)), (0, S.isSet)(o.validatorAddress) && (h.validatorAddress = String(o.validatorAddress)), (0, S.isSet)(o.pubkey) && (h.pubkey = r.Any.fromJSON(o.pubkey)), (0, S.isSet)(o.value) && (h.value = t.Coin.fromJSON(o.value)), h;
    },
    toJSON(o) {
      const h = {};
      return o.description !== void 0 && (h.description = o.description ? n.Description.toJSON(o.description) : void 0), o.commission !== void 0 && (h.commission = o.commission ? n.CommissionRates.toJSON(o.commission) : void 0), o.minSelfDelegation !== void 0 && (h.minSelfDelegation = o.minSelfDelegation), o.delegatorAddress !== void 0 && (h.delegatorAddress = o.delegatorAddress), o.validatorAddress !== void 0 && (h.validatorAddress = o.validatorAddress), o.pubkey !== void 0 && (h.pubkey = o.pubkey ? r.Any.toJSON(o.pubkey) : void 0), o.value !== void 0 && (h.value = o.value ? t.Coin.toJSON(o.value) : void 0), h;
    },
    fromPartial(o) {
      const h = w();
      return o.description !== void 0 && o.description !== null && (h.description = n.Description.fromPartial(o.description)), o.commission !== void 0 && o.commission !== null && (h.commission = n.CommissionRates.fromPartial(o.commission)), h.minSelfDelegation = o.minSelfDelegation ?? "", h.delegatorAddress = o.delegatorAddress ?? "", h.validatorAddress = o.validatorAddress ?? "", o.pubkey !== void 0 && o.pubkey !== null && (h.pubkey = r.Any.fromPartial(o.pubkey)), o.value !== void 0 && o.value !== null && (h.value = t.Coin.fromPartial(o.value)), h;
    }
  };
  function T() {
    return {};
  }
  e.MsgCreateValidatorResponse = {
    typeUrl: "/cosmos.staking.v1beta1.MsgCreateValidatorResponse",
    encode(o, h = f.BinaryWriter.create()) {
      return h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = T();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      return T();
    },
    toJSON(o) {
      return {};
    },
    fromPartial(o) {
      return T();
    }
  };
  function J() {
    return {
      description: n.Description.fromPartial({}),
      validatorAddress: "",
      commissionRate: "",
      minSelfDelegation: ""
    };
  }
  e.MsgEditValidator = {
    typeUrl: "/cosmos.staking.v1beta1.MsgEditValidator",
    encode(o, h = f.BinaryWriter.create()) {
      return o.description !== void 0 && n.Description.encode(o.description, h.uint32(10).fork()).ldelim(), o.validatorAddress !== "" && h.uint32(18).string(o.validatorAddress), o.commissionRate !== "" && h.uint32(26).string(o.commissionRate), o.minSelfDelegation !== "" && h.uint32(34).string(o.minSelfDelegation), h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = J();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.description = n.Description.decode(N, N.uint32());
            break;
          case 2:
            u.validatorAddress = N.string();
            break;
          case 3:
            u.commissionRate = N.string();
            break;
          case 4:
            u.minSelfDelegation = N.string();
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = J();
      return (0, S.isSet)(o.description) && (h.description = n.Description.fromJSON(o.description)), (0, S.isSet)(o.validatorAddress) && (h.validatorAddress = String(o.validatorAddress)), (0, S.isSet)(o.commissionRate) && (h.commissionRate = String(o.commissionRate)), (0, S.isSet)(o.minSelfDelegation) && (h.minSelfDelegation = String(o.minSelfDelegation)), h;
    },
    toJSON(o) {
      const h = {};
      return o.description !== void 0 && (h.description = o.description ? n.Description.toJSON(o.description) : void 0), o.validatorAddress !== void 0 && (h.validatorAddress = o.validatorAddress), o.commissionRate !== void 0 && (h.commissionRate = o.commissionRate), o.minSelfDelegation !== void 0 && (h.minSelfDelegation = o.minSelfDelegation), h;
    },
    fromPartial(o) {
      const h = J();
      return o.description !== void 0 && o.description !== null && (h.description = n.Description.fromPartial(o.description)), h.validatorAddress = o.validatorAddress ?? "", h.commissionRate = o.commissionRate ?? "", h.minSelfDelegation = o.minSelfDelegation ?? "", h;
    }
  };
  function C() {
    return {};
  }
  e.MsgEditValidatorResponse = {
    typeUrl: "/cosmos.staking.v1beta1.MsgEditValidatorResponse",
    encode(o, h = f.BinaryWriter.create()) {
      return h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = C();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      return C();
    },
    toJSON(o) {
      return {};
    },
    fromPartial(o) {
      return C();
    }
  };
  function R() {
    return {
      delegatorAddress: "",
      validatorAddress: "",
      amount: t.Coin.fromPartial({})
    };
  }
  e.MsgDelegate = {
    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
    encode(o, h = f.BinaryWriter.create()) {
      return o.delegatorAddress !== "" && h.uint32(10).string(o.delegatorAddress), o.validatorAddress !== "" && h.uint32(18).string(o.validatorAddress), o.amount !== void 0 && t.Coin.encode(o.amount, h.uint32(26).fork()).ldelim(), h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = R();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.delegatorAddress = N.string();
            break;
          case 2:
            u.validatorAddress = N.string();
            break;
          case 3:
            u.amount = t.Coin.decode(N, N.uint32());
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = R();
      return (0, S.isSet)(o.delegatorAddress) && (h.delegatorAddress = String(o.delegatorAddress)), (0, S.isSet)(o.validatorAddress) && (h.validatorAddress = String(o.validatorAddress)), (0, S.isSet)(o.amount) && (h.amount = t.Coin.fromJSON(o.amount)), h;
    },
    toJSON(o) {
      const h = {};
      return o.delegatorAddress !== void 0 && (h.delegatorAddress = o.delegatorAddress), o.validatorAddress !== void 0 && (h.validatorAddress = o.validatorAddress), o.amount !== void 0 && (h.amount = o.amount ? t.Coin.toJSON(o.amount) : void 0), h;
    },
    fromPartial(o) {
      const h = R();
      return h.delegatorAddress = o.delegatorAddress ?? "", h.validatorAddress = o.validatorAddress ?? "", o.amount !== void 0 && o.amount !== null && (h.amount = t.Coin.fromPartial(o.amount)), h;
    }
  };
  function p() {
    return {};
  }
  e.MsgDelegateResponse = {
    typeUrl: "/cosmos.staking.v1beta1.MsgDelegateResponse",
    encode(o, h = f.BinaryWriter.create()) {
      return h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = p();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      return p();
    },
    toJSON(o) {
      return {};
    },
    fromPartial(o) {
      return p();
    }
  };
  function m() {
    return {
      delegatorAddress: "",
      validatorSrcAddress: "",
      validatorDstAddress: "",
      amount: t.Coin.fromPartial({})
    };
  }
  e.MsgBeginRedelegate = {
    typeUrl: "/cosmos.staking.v1beta1.MsgBeginRedelegate",
    encode(o, h = f.BinaryWriter.create()) {
      return o.delegatorAddress !== "" && h.uint32(10).string(o.delegatorAddress), o.validatorSrcAddress !== "" && h.uint32(18).string(o.validatorSrcAddress), o.validatorDstAddress !== "" && h.uint32(26).string(o.validatorDstAddress), o.amount !== void 0 && t.Coin.encode(o.amount, h.uint32(34).fork()).ldelim(), h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = m();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.delegatorAddress = N.string();
            break;
          case 2:
            u.validatorSrcAddress = N.string();
            break;
          case 3:
            u.validatorDstAddress = N.string();
            break;
          case 4:
            u.amount = t.Coin.decode(N, N.uint32());
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = m();
      return (0, S.isSet)(o.delegatorAddress) && (h.delegatorAddress = String(o.delegatorAddress)), (0, S.isSet)(o.validatorSrcAddress) && (h.validatorSrcAddress = String(o.validatorSrcAddress)), (0, S.isSet)(o.validatorDstAddress) && (h.validatorDstAddress = String(o.validatorDstAddress)), (0, S.isSet)(o.amount) && (h.amount = t.Coin.fromJSON(o.amount)), h;
    },
    toJSON(o) {
      const h = {};
      return o.delegatorAddress !== void 0 && (h.delegatorAddress = o.delegatorAddress), o.validatorSrcAddress !== void 0 && (h.validatorSrcAddress = o.validatorSrcAddress), o.validatorDstAddress !== void 0 && (h.validatorDstAddress = o.validatorDstAddress), o.amount !== void 0 && (h.amount = o.amount ? t.Coin.toJSON(o.amount) : void 0), h;
    },
    fromPartial(o) {
      const h = m();
      return h.delegatorAddress = o.delegatorAddress ?? "", h.validatorSrcAddress = o.validatorSrcAddress ?? "", h.validatorDstAddress = o.validatorDstAddress ?? "", o.amount !== void 0 && o.amount !== null && (h.amount = t.Coin.fromPartial(o.amount)), h;
    }
  };
  function v() {
    return {
      completionTime: i.Timestamp.fromPartial({})
    };
  }
  e.MsgBeginRedelegateResponse = {
    typeUrl: "/cosmos.staking.v1beta1.MsgBeginRedelegateResponse",
    encode(o, h = f.BinaryWriter.create()) {
      return o.completionTime !== void 0 && i.Timestamp.encode(o.completionTime, h.uint32(10).fork()).ldelim(), h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = v();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.completionTime = i.Timestamp.decode(N, N.uint32());
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = v();
      return (0, S.isSet)(o.completionTime) && (h.completionTime = (0, S.fromJsonTimestamp)(o.completionTime)), h;
    },
    toJSON(o) {
      const h = {};
      return o.completionTime !== void 0 && (h.completionTime = (0, S.fromTimestamp)(o.completionTime).toISOString()), h;
    },
    fromPartial(o) {
      const h = v();
      return o.completionTime !== void 0 && o.completionTime !== null && (h.completionTime = i.Timestamp.fromPartial(o.completionTime)), h;
    }
  };
  function a() {
    return {
      delegatorAddress: "",
      validatorAddress: "",
      amount: t.Coin.fromPartial({})
    };
  }
  e.MsgUndelegate = {
    typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
    encode(o, h = f.BinaryWriter.create()) {
      return o.delegatorAddress !== "" && h.uint32(10).string(o.delegatorAddress), o.validatorAddress !== "" && h.uint32(18).string(o.validatorAddress), o.amount !== void 0 && t.Coin.encode(o.amount, h.uint32(26).fork()).ldelim(), h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = a();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.delegatorAddress = N.string();
            break;
          case 2:
            u.validatorAddress = N.string();
            break;
          case 3:
            u.amount = t.Coin.decode(N, N.uint32());
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = a();
      return (0, S.isSet)(o.delegatorAddress) && (h.delegatorAddress = String(o.delegatorAddress)), (0, S.isSet)(o.validatorAddress) && (h.validatorAddress = String(o.validatorAddress)), (0, S.isSet)(o.amount) && (h.amount = t.Coin.fromJSON(o.amount)), h;
    },
    toJSON(o) {
      const h = {};
      return o.delegatorAddress !== void 0 && (h.delegatorAddress = o.delegatorAddress), o.validatorAddress !== void 0 && (h.validatorAddress = o.validatorAddress), o.amount !== void 0 && (h.amount = o.amount ? t.Coin.toJSON(o.amount) : void 0), h;
    },
    fromPartial(o) {
      const h = a();
      return h.delegatorAddress = o.delegatorAddress ?? "", h.validatorAddress = o.validatorAddress ?? "", o.amount !== void 0 && o.amount !== null && (h.amount = t.Coin.fromPartial(o.amount)), h;
    }
  };
  function d() {
    return {
      completionTime: i.Timestamp.fromPartial({})
    };
  }
  e.MsgUndelegateResponse = {
    typeUrl: "/cosmos.staking.v1beta1.MsgUndelegateResponse",
    encode(o, h = f.BinaryWriter.create()) {
      return o.completionTime !== void 0 && i.Timestamp.encode(o.completionTime, h.uint32(10).fork()).ldelim(), h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = d();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.completionTime = i.Timestamp.decode(N, N.uint32());
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = d();
      return (0, S.isSet)(o.completionTime) && (h.completionTime = (0, S.fromJsonTimestamp)(o.completionTime)), h;
    },
    toJSON(o) {
      const h = {};
      return o.completionTime !== void 0 && (h.completionTime = (0, S.fromTimestamp)(o.completionTime).toISOString()), h;
    },
    fromPartial(o) {
      const h = d();
      return o.completionTime !== void 0 && o.completionTime !== null && (h.completionTime = i.Timestamp.fromPartial(o.completionTime)), h;
    }
  };
  function y() {
    return {
      delegatorAddress: "",
      validatorAddress: "",
      amount: t.Coin.fromPartial({}),
      creationHeight: BigInt(0)
    };
  }
  e.MsgCancelUnbondingDelegation = {
    typeUrl: "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation",
    encode(o, h = f.BinaryWriter.create()) {
      return o.delegatorAddress !== "" && h.uint32(10).string(o.delegatorAddress), o.validatorAddress !== "" && h.uint32(18).string(o.validatorAddress), o.amount !== void 0 && t.Coin.encode(o.amount, h.uint32(26).fork()).ldelim(), o.creationHeight !== BigInt(0) && h.uint32(32).int64(o.creationHeight), h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = y();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.delegatorAddress = N.string();
            break;
          case 2:
            u.validatorAddress = N.string();
            break;
          case 3:
            u.amount = t.Coin.decode(N, N.uint32());
            break;
          case 4:
            u.creationHeight = N.int64();
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = y();
      return (0, S.isSet)(o.delegatorAddress) && (h.delegatorAddress = String(o.delegatorAddress)), (0, S.isSet)(o.validatorAddress) && (h.validatorAddress = String(o.validatorAddress)), (0, S.isSet)(o.amount) && (h.amount = t.Coin.fromJSON(o.amount)), (0, S.isSet)(o.creationHeight) && (h.creationHeight = BigInt(o.creationHeight.toString())), h;
    },
    toJSON(o) {
      const h = {};
      return o.delegatorAddress !== void 0 && (h.delegatorAddress = o.delegatorAddress), o.validatorAddress !== void 0 && (h.validatorAddress = o.validatorAddress), o.amount !== void 0 && (h.amount = o.amount ? t.Coin.toJSON(o.amount) : void 0), o.creationHeight !== void 0 && (h.creationHeight = (o.creationHeight || BigInt(0)).toString()), h;
    },
    fromPartial(o) {
      const h = y();
      return h.delegatorAddress = o.delegatorAddress ?? "", h.validatorAddress = o.validatorAddress ?? "", o.amount !== void 0 && o.amount !== null && (h.amount = t.Coin.fromPartial(o.amount)), o.creationHeight !== void 0 && o.creationHeight !== null && (h.creationHeight = BigInt(o.creationHeight.toString())), h;
    }
  };
  function _() {
    return {};
  }
  e.MsgCancelUnbondingDelegationResponse = {
    typeUrl: "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegationResponse",
    encode(o, h = f.BinaryWriter.create()) {
      return h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = _();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      return _();
    },
    toJSON(o) {
      return {};
    },
    fromPartial(o) {
      return _();
    }
  };
  function E() {
    return {
      authority: "",
      params: n.Params.fromPartial({})
    };
  }
  e.MsgUpdateParams = {
    typeUrl: "/cosmos.staking.v1beta1.MsgUpdateParams",
    encode(o, h = f.BinaryWriter.create()) {
      return o.authority !== "" && h.uint32(10).string(o.authority), o.params !== void 0 && n.Params.encode(o.params, h.uint32(18).fork()).ldelim(), h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = E();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          case 1:
            u.authority = N.string();
            break;
          case 2:
            u.params = n.Params.decode(N, N.uint32());
            break;
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      const h = E();
      return (0, S.isSet)(o.authority) && (h.authority = String(o.authority)), (0, S.isSet)(o.params) && (h.params = n.Params.fromJSON(o.params)), h;
    },
    toJSON(o) {
      const h = {};
      return o.authority !== void 0 && (h.authority = o.authority), o.params !== void 0 && (h.params = o.params ? n.Params.toJSON(o.params) : void 0), h;
    },
    fromPartial(o) {
      const h = E();
      return h.authority = o.authority ?? "", o.params !== void 0 && o.params !== null && (h.params = n.Params.fromPartial(o.params)), h;
    }
  };
  function U() {
    return {};
  }
  e.MsgUpdateParamsResponse = {
    typeUrl: "/cosmos.staking.v1beta1.MsgUpdateParamsResponse",
    encode(o, h = f.BinaryWriter.create()) {
      return h;
    },
    decode(o, h) {
      const N = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = h === void 0 ? N.len : N.pos + h;
      const u = U();
      for (; N.pos < q; ) {
        const l = N.uint32();
        switch (l >>> 3) {
          default:
            N.skipType(l & 7);
            break;
        }
      }
      return u;
    },
    fromJSON(o) {
      return U();
    },
    toJSON(o) {
      return {};
    },
    fromPartial(o) {
      return U();
    }
  };
  class V {
    constructor(h) {
      this.rpc = h, this.CreateValidator = this.CreateValidator.bind(this), this.EditValidator = this.EditValidator.bind(this), this.Delegate = this.Delegate.bind(this), this.BeginRedelegate = this.BeginRedelegate.bind(this), this.Undelegate = this.Undelegate.bind(this), this.CancelUnbondingDelegation = this.CancelUnbondingDelegation.bind(this), this.UpdateParams = this.UpdateParams.bind(this);
    }
    CreateValidator(h) {
      const N = e.MsgCreateValidator.encode(h).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Msg", "CreateValidator", N).then((u) => e.MsgCreateValidatorResponse.decode(new f.BinaryReader(u)));
    }
    EditValidator(h) {
      const N = e.MsgEditValidator.encode(h).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Msg", "EditValidator", N).then((u) => e.MsgEditValidatorResponse.decode(new f.BinaryReader(u)));
    }
    Delegate(h) {
      const N = e.MsgDelegate.encode(h).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Msg", "Delegate", N).then((u) => e.MsgDelegateResponse.decode(new f.BinaryReader(u)));
    }
    BeginRedelegate(h) {
      const N = e.MsgBeginRedelegate.encode(h).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Msg", "BeginRedelegate", N).then((u) => e.MsgBeginRedelegateResponse.decode(new f.BinaryReader(u)));
    }
    Undelegate(h) {
      const N = e.MsgUndelegate.encode(h).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Msg", "Undelegate", N).then((u) => e.MsgUndelegateResponse.decode(new f.BinaryReader(u)));
    }
    CancelUnbondingDelegation(h) {
      const N = e.MsgCancelUnbondingDelegation.encode(h).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Msg", "CancelUnbondingDelegation", N).then((u) => e.MsgCancelUnbondingDelegationResponse.decode(new f.BinaryReader(u)));
    }
    UpdateParams(h) {
      const N = e.MsgUpdateParams.encode(h).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Msg", "UpdateParams", N).then((u) => e.MsgUpdateParamsResponse.decode(new f.BinaryReader(u)));
    }
  }
  e.MsgClientImpl = V;
})(Xc);
Object.defineProperty(sn, "__esModule", { value: !0 });
sn.isMsgUndelegateEncodeObject = sn.isMsgEditValidatorEncodeObject = sn.isMsgDelegateEncodeObject = sn.isMsgCreateValidatorEncodeObject = sn.isMsgBeginRedelegateEncodeObject = sn.stakingTypes = void 0;
const to = Xc;
sn.stakingTypes = [
  ["/cosmos.staking.v1beta1.MsgBeginRedelegate", to.MsgBeginRedelegate],
  ["/cosmos.staking.v1beta1.MsgCreateValidator", to.MsgCreateValidator],
  ["/cosmos.staking.v1beta1.MsgDelegate", to.MsgDelegate],
  ["/cosmos.staking.v1beta1.MsgEditValidator", to.MsgEditValidator],
  ["/cosmos.staking.v1beta1.MsgUndelegate", to.MsgUndelegate]
];
function XR(e) {
  return e.typeUrl === "/cosmos.staking.v1beta1.MsgBeginRedelegate";
}
sn.isMsgBeginRedelegateEncodeObject = XR;
function jR(e) {
  return e.typeUrl === "/cosmos.staking.v1beta1.MsgCreateValidator";
}
sn.isMsgCreateValidatorEncodeObject = jR;
function eB(e) {
  return e.typeUrl === "/cosmos.staking.v1beta1.MsgDelegate";
}
sn.isMsgDelegateEncodeObject = eB;
function nB(e) {
  return e.typeUrl === "/cosmos.staking.v1beta1.MsgEditValidator";
}
sn.isMsgEditValidatorEncodeObject = nB;
function tB(e) {
  return e.typeUrl === "/cosmos.staking.v1beta1.MsgUndelegate";
}
sn.isMsgUndelegateEncodeObject = tB;
var Es = {}, zh = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryParamsResponse = e.QueryParamsRequest = e.QueryPoolResponse = e.QueryPoolRequest = e.QueryHistoricalInfoResponse = e.QueryHistoricalInfoRequest = e.QueryDelegatorValidatorResponse = e.QueryDelegatorValidatorRequest = e.QueryDelegatorValidatorsResponse = e.QueryDelegatorValidatorsRequest = e.QueryRedelegationsResponse = e.QueryRedelegationsRequest = e.QueryDelegatorUnbondingDelegationsResponse = e.QueryDelegatorUnbondingDelegationsRequest = e.QueryDelegatorDelegationsResponse = e.QueryDelegatorDelegationsRequest = e.QueryUnbondingDelegationResponse = e.QueryUnbondingDelegationRequest = e.QueryDelegationResponse = e.QueryDelegationRequest = e.QueryValidatorUnbondingDelegationsResponse = e.QueryValidatorUnbondingDelegationsRequest = e.QueryValidatorDelegationsResponse = e.QueryValidatorDelegationsRequest = e.QueryValidatorResponse = e.QueryValidatorRequest = e.QueryValidatorsResponse = e.QueryValidatorsRequest = e.protobufPackage = void 0;
  const n = Ae, r = jc, t = re, i = ie;
  e.protobufPackage = "cosmos.staking.v1beta1";
  function f() {
    return {
      status: "",
      pagination: void 0
    };
  }
  e.QueryValidatorsRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryValidatorsRequest",
    encode(s, k = t.BinaryWriter.create()) {
      return s.status !== "" && k.uint32(10).string(s.status), s.pagination !== void 0 && n.PageRequest.encode(s.pagination, k.uint32(18).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof t.BinaryReader ? s : new t.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = f();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.status = g.string();
            break;
          case 2:
            A.pagination = n.PageRequest.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = f();
      return (0, i.isSet)(s.status) && (k.status = String(s.status)), (0, i.isSet)(s.pagination) && (k.pagination = n.PageRequest.fromJSON(s.pagination)), k;
    },
    toJSON(s) {
      const k = {};
      return s.status !== void 0 && (k.status = s.status), s.pagination !== void 0 && (k.pagination = s.pagination ? n.PageRequest.toJSON(s.pagination) : void 0), k;
    },
    fromPartial(s) {
      const k = f();
      return k.status = s.status ?? "", s.pagination !== void 0 && s.pagination !== null && (k.pagination = n.PageRequest.fromPartial(s.pagination)), k;
    }
  };
  function S() {
    return {
      validators: [],
      pagination: void 0
    };
  }
  e.QueryValidatorsResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryValidatorsResponse",
    encode(s, k = t.BinaryWriter.create()) {
      for (const g of s.validators)
        r.Validator.encode(g, k.uint32(10).fork()).ldelim();
      return s.pagination !== void 0 && n.PageResponse.encode(s.pagination, k.uint32(18).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof t.BinaryReader ? s : new t.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = S();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.validators.push(r.Validator.decode(g, g.uint32()));
            break;
          case 2:
            A.pagination = n.PageResponse.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = S();
      return Array.isArray(s == null ? void 0 : s.validators) && (k.validators = s.validators.map((g) => r.Validator.fromJSON(g))), (0, i.isSet)(s.pagination) && (k.pagination = n.PageResponse.fromJSON(s.pagination)), k;
    },
    toJSON(s) {
      const k = {};
      return s.validators ? k.validators = s.validators.map((g) => g ? r.Validator.toJSON(g) : void 0) : k.validators = [], s.pagination !== void 0 && (k.pagination = s.pagination ? n.PageResponse.toJSON(s.pagination) : void 0), k;
    },
    fromPartial(s) {
      var g;
      const k = S();
      return k.validators = ((g = s.validators) == null ? void 0 : g.map((P) => r.Validator.fromPartial(P))) || [], s.pagination !== void 0 && s.pagination !== null && (k.pagination = n.PageResponse.fromPartial(s.pagination)), k;
    }
  };
  function w() {
    return {
      validatorAddr: ""
    };
  }
  e.QueryValidatorRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryValidatorRequest",
    encode(s, k = t.BinaryWriter.create()) {
      return s.validatorAddr !== "" && k.uint32(10).string(s.validatorAddr), k;
    },
    decode(s, k) {
      const g = s instanceof t.BinaryReader ? s : new t.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = w();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.validatorAddr = g.string();
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = w();
      return (0, i.isSet)(s.validatorAddr) && (k.validatorAddr = String(s.validatorAddr)), k;
    },
    toJSON(s) {
      const k = {};
      return s.validatorAddr !== void 0 && (k.validatorAddr = s.validatorAddr), k;
    },
    fromPartial(s) {
      const k = w();
      return k.validatorAddr = s.validatorAddr ?? "", k;
    }
  };
  function T() {
    return {
      validator: r.Validator.fromPartial({})
    };
  }
  e.QueryValidatorResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryValidatorResponse",
    encode(s, k = t.BinaryWriter.create()) {
      return s.validator !== void 0 && r.Validator.encode(s.validator, k.uint32(10).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof t.BinaryReader ? s : new t.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = T();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.validator = r.Validator.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = T();
      return (0, i.isSet)(s.validator) && (k.validator = r.Validator.fromJSON(s.validator)), k;
    },
    toJSON(s) {
      const k = {};
      return s.validator !== void 0 && (k.validator = s.validator ? r.Validator.toJSON(s.validator) : void 0), k;
    },
    fromPartial(s) {
      const k = T();
      return s.validator !== void 0 && s.validator !== null && (k.validator = r.Validator.fromPartial(s.validator)), k;
    }
  };
  function J() {
    return {
      validatorAddr: "",
      pagination: void 0
    };
  }
  e.QueryValidatorDelegationsRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryValidatorDelegationsRequest",
    encode(s, k = t.BinaryWriter.create()) {
      return s.validatorAddr !== "" && k.uint32(10).string(s.validatorAddr), s.pagination !== void 0 && n.PageRequest.encode(s.pagination, k.uint32(18).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof t.BinaryReader ? s : new t.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = J();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.validatorAddr = g.string();
            break;
          case 2:
            A.pagination = n.PageRequest.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = J();
      return (0, i.isSet)(s.validatorAddr) && (k.validatorAddr = String(s.validatorAddr)), (0, i.isSet)(s.pagination) && (k.pagination = n.PageRequest.fromJSON(s.pagination)), k;
    },
    toJSON(s) {
      const k = {};
      return s.validatorAddr !== void 0 && (k.validatorAddr = s.validatorAddr), s.pagination !== void 0 && (k.pagination = s.pagination ? n.PageRequest.toJSON(s.pagination) : void 0), k;
    },
    fromPartial(s) {
      const k = J();
      return k.validatorAddr = s.validatorAddr ?? "", s.pagination !== void 0 && s.pagination !== null && (k.pagination = n.PageRequest.fromPartial(s.pagination)), k;
    }
  };
  function C() {
    return {
      delegationResponses: [],
      pagination: void 0
    };
  }
  e.QueryValidatorDelegationsResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryValidatorDelegationsResponse",
    encode(s, k = t.BinaryWriter.create()) {
      for (const g of s.delegationResponses)
        r.DelegationResponse.encode(g, k.uint32(10).fork()).ldelim();
      return s.pagination !== void 0 && n.PageResponse.encode(s.pagination, k.uint32(18).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof t.BinaryReader ? s : new t.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = C();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.delegationResponses.push(r.DelegationResponse.decode(g, g.uint32()));
            break;
          case 2:
            A.pagination = n.PageResponse.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = C();
      return Array.isArray(s == null ? void 0 : s.delegationResponses) && (k.delegationResponses = s.delegationResponses.map((g) => r.DelegationResponse.fromJSON(g))), (0, i.isSet)(s.pagination) && (k.pagination = n.PageResponse.fromJSON(s.pagination)), k;
    },
    toJSON(s) {
      const k = {};
      return s.delegationResponses ? k.delegationResponses = s.delegationResponses.map((g) => g ? r.DelegationResponse.toJSON(g) : void 0) : k.delegationResponses = [], s.pagination !== void 0 && (k.pagination = s.pagination ? n.PageResponse.toJSON(s.pagination) : void 0), k;
    },
    fromPartial(s) {
      var g;
      const k = C();
      return k.delegationResponses = ((g = s.delegationResponses) == null ? void 0 : g.map((P) => r.DelegationResponse.fromPartial(P))) || [], s.pagination !== void 0 && s.pagination !== null && (k.pagination = n.PageResponse.fromPartial(s.pagination)), k;
    }
  };
  function R() {
    return {
      validatorAddr: "",
      pagination: void 0
    };
  }
  e.QueryValidatorUnbondingDelegationsRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryValidatorUnbondingDelegationsRequest",
    encode(s, k = t.BinaryWriter.create()) {
      return s.validatorAddr !== "" && k.uint32(10).string(s.validatorAddr), s.pagination !== void 0 && n.PageRequest.encode(s.pagination, k.uint32(18).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof t.BinaryReader ? s : new t.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = R();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.validatorAddr = g.string();
            break;
          case 2:
            A.pagination = n.PageRequest.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = R();
      return (0, i.isSet)(s.validatorAddr) && (k.validatorAddr = String(s.validatorAddr)), (0, i.isSet)(s.pagination) && (k.pagination = n.PageRequest.fromJSON(s.pagination)), k;
    },
    toJSON(s) {
      const k = {};
      return s.validatorAddr !== void 0 && (k.validatorAddr = s.validatorAddr), s.pagination !== void 0 && (k.pagination = s.pagination ? n.PageRequest.toJSON(s.pagination) : void 0), k;
    },
    fromPartial(s) {
      const k = R();
      return k.validatorAddr = s.validatorAddr ?? "", s.pagination !== void 0 && s.pagination !== null && (k.pagination = n.PageRequest.fromPartial(s.pagination)), k;
    }
  };
  function p() {
    return {
      unbondingResponses: [],
      pagination: void 0
    };
  }
  e.QueryValidatorUnbondingDelegationsResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryValidatorUnbondingDelegationsResponse",
    encode(s, k = t.BinaryWriter.create()) {
      for (const g of s.unbondingResponses)
        r.UnbondingDelegation.encode(g, k.uint32(10).fork()).ldelim();
      return s.pagination !== void 0 && n.PageResponse.encode(s.pagination, k.uint32(18).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof t.BinaryReader ? s : new t.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = p();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.unbondingResponses.push(r.UnbondingDelegation.decode(g, g.uint32()));
            break;
          case 2:
            A.pagination = n.PageResponse.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = p();
      return Array.isArray(s == null ? void 0 : s.unbondingResponses) && (k.unbondingResponses = s.unbondingResponses.map((g) => r.UnbondingDelegation.fromJSON(g))), (0, i.isSet)(s.pagination) && (k.pagination = n.PageResponse.fromJSON(s.pagination)), k;
    },
    toJSON(s) {
      const k = {};
      return s.unbondingResponses ? k.unbondingResponses = s.unbondingResponses.map((g) => g ? r.UnbondingDelegation.toJSON(g) : void 0) : k.unbondingResponses = [], s.pagination !== void 0 && (k.pagination = s.pagination ? n.PageResponse.toJSON(s.pagination) : void 0), k;
    },
    fromPartial(s) {
      var g;
      const k = p();
      return k.unbondingResponses = ((g = s.unbondingResponses) == null ? void 0 : g.map((P) => r.UnbondingDelegation.fromPartial(P))) || [], s.pagination !== void 0 && s.pagination !== null && (k.pagination = n.PageResponse.fromPartial(s.pagination)), k;
    }
  };
  function m() {
    return {
      delegatorAddr: "",
      validatorAddr: ""
    };
  }
  e.QueryDelegationRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegationRequest",
    encode(s, k = t.BinaryWriter.create()) {
      return s.delegatorAddr !== "" && k.uint32(10).string(s.delegatorAddr), s.validatorAddr !== "" && k.uint32(18).string(s.validatorAddr), k;
    },
    decode(s, k) {
      const g = s instanceof t.BinaryReader ? s : new t.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = m();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.delegatorAddr = g.string();
            break;
          case 2:
            A.validatorAddr = g.string();
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = m();
      return (0, i.isSet)(s.delegatorAddr) && (k.delegatorAddr = String(s.delegatorAddr)), (0, i.isSet)(s.validatorAddr) && (k.validatorAddr = String(s.validatorAddr)), k;
    },
    toJSON(s) {
      const k = {};
      return s.delegatorAddr !== void 0 && (k.delegatorAddr = s.delegatorAddr), s.validatorAddr !== void 0 && (k.validatorAddr = s.validatorAddr), k;
    },
    fromPartial(s) {
      const k = m();
      return k.delegatorAddr = s.delegatorAddr ?? "", k.validatorAddr = s.validatorAddr ?? "", k;
    }
  };
  function v() {
    return {
      delegationResponse: void 0
    };
  }
  e.QueryDelegationResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegationResponse",
    encode(s, k = t.BinaryWriter.create()) {
      return s.delegationResponse !== void 0 && r.DelegationResponse.encode(s.delegationResponse, k.uint32(10).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof t.BinaryReader ? s : new t.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = v();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.delegationResponse = r.DelegationResponse.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = v();
      return (0, i.isSet)(s.delegationResponse) && (k.delegationResponse = r.DelegationResponse.fromJSON(s.delegationResponse)), k;
    },
    toJSON(s) {
      const k = {};
      return s.delegationResponse !== void 0 && (k.delegationResponse = s.delegationResponse ? r.DelegationResponse.toJSON(s.delegationResponse) : void 0), k;
    },
    fromPartial(s) {
      const k = v();
      return s.delegationResponse !== void 0 && s.delegationResponse !== null && (k.delegationResponse = r.DelegationResponse.fromPartial(s.delegationResponse)), k;
    }
  };
  function a() {
    return {
      delegatorAddr: "",
      validatorAddr: ""
    };
  }
  e.QueryUnbondingDelegationRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryUnbondingDelegationRequest",
    encode(s, k = t.BinaryWriter.create()) {
      return s.delegatorAddr !== "" && k.uint32(10).string(s.delegatorAddr), s.validatorAddr !== "" && k.uint32(18).string(s.validatorAddr), k;
    },
    decode(s, k) {
      const g = s instanceof t.BinaryReader ? s : new t.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = a();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.delegatorAddr = g.string();
            break;
          case 2:
            A.validatorAddr = g.string();
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = a();
      return (0, i.isSet)(s.delegatorAddr) && (k.delegatorAddr = String(s.delegatorAddr)), (0, i.isSet)(s.validatorAddr) && (k.validatorAddr = String(s.validatorAddr)), k;
    },
    toJSON(s) {
      const k = {};
      return s.delegatorAddr !== void 0 && (k.delegatorAddr = s.delegatorAddr), s.validatorAddr !== void 0 && (k.validatorAddr = s.validatorAddr), k;
    },
    fromPartial(s) {
      const k = a();
      return k.delegatorAddr = s.delegatorAddr ?? "", k.validatorAddr = s.validatorAddr ?? "", k;
    }
  };
  function d() {
    return {
      unbond: r.UnbondingDelegation.fromPartial({})
    };
  }
  e.QueryUnbondingDelegationResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryUnbondingDelegationResponse",
    encode(s, k = t.BinaryWriter.create()) {
      return s.unbond !== void 0 && r.UnbondingDelegation.encode(s.unbond, k.uint32(10).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof t.BinaryReader ? s : new t.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = d();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.unbond = r.UnbondingDelegation.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = d();
      return (0, i.isSet)(s.unbond) && (k.unbond = r.UnbondingDelegation.fromJSON(s.unbond)), k;
    },
    toJSON(s) {
      const k = {};
      return s.unbond !== void 0 && (k.unbond = s.unbond ? r.UnbondingDelegation.toJSON(s.unbond) : void 0), k;
    },
    fromPartial(s) {
      const k = d();
      return s.unbond !== void 0 && s.unbond !== null && (k.unbond = r.UnbondingDelegation.fromPartial(s.unbond)), k;
    }
  };
  function y() {
    return {
      delegatorAddr: "",
      pagination: void 0
    };
  }
  e.QueryDelegatorDelegationsRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorDelegationsRequest",
    encode(s, k = t.BinaryWriter.create()) {
      return s.delegatorAddr !== "" && k.uint32(10).string(s.delegatorAddr), s.pagination !== void 0 && n.PageRequest.encode(s.pagination, k.uint32(18).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof t.BinaryReader ? s : new t.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = y();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.delegatorAddr = g.string();
            break;
          case 2:
            A.pagination = n.PageRequest.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = y();
      return (0, i.isSet)(s.delegatorAddr) && (k.delegatorAddr = String(s.delegatorAddr)), (0, i.isSet)(s.pagination) && (k.pagination = n.PageRequest.fromJSON(s.pagination)), k;
    },
    toJSON(s) {
      const k = {};
      return s.delegatorAddr !== void 0 && (k.delegatorAddr = s.delegatorAddr), s.pagination !== void 0 && (k.pagination = s.pagination ? n.PageRequest.toJSON(s.pagination) : void 0), k;
    },
    fromPartial(s) {
      const k = y();
      return k.delegatorAddr = s.delegatorAddr ?? "", s.pagination !== void 0 && s.pagination !== null && (k.pagination = n.PageRequest.fromPartial(s.pagination)), k;
    }
  };
  function _() {
    return {
      delegationResponses: [],
      pagination: void 0
    };
  }
  e.QueryDelegatorDelegationsResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorDelegationsResponse",
    encode(s, k = t.BinaryWriter.create()) {
      for (const g of s.delegationResponses)
        r.DelegationResponse.encode(g, k.uint32(10).fork()).ldelim();
      return s.pagination !== void 0 && n.PageResponse.encode(s.pagination, k.uint32(18).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof t.BinaryReader ? s : new t.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = _();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.delegationResponses.push(r.DelegationResponse.decode(g, g.uint32()));
            break;
          case 2:
            A.pagination = n.PageResponse.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = _();
      return Array.isArray(s == null ? void 0 : s.delegationResponses) && (k.delegationResponses = s.delegationResponses.map((g) => r.DelegationResponse.fromJSON(g))), (0, i.isSet)(s.pagination) && (k.pagination = n.PageResponse.fromJSON(s.pagination)), k;
    },
    toJSON(s) {
      const k = {};
      return s.delegationResponses ? k.delegationResponses = s.delegationResponses.map((g) => g ? r.DelegationResponse.toJSON(g) : void 0) : k.delegationResponses = [], s.pagination !== void 0 && (k.pagination = s.pagination ? n.PageResponse.toJSON(s.pagination) : void 0), k;
    },
    fromPartial(s) {
      var g;
      const k = _();
      return k.delegationResponses = ((g = s.delegationResponses) == null ? void 0 : g.map((P) => r.DelegationResponse.fromPartial(P))) || [], s.pagination !== void 0 && s.pagination !== null && (k.pagination = n.PageResponse.fromPartial(s.pagination)), k;
    }
  };
  function E() {
    return {
      delegatorAddr: "",
      pagination: void 0
    };
  }
  e.QueryDelegatorUnbondingDelegationsRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsRequest",
    encode(s, k = t.BinaryWriter.create()) {
      return s.delegatorAddr !== "" && k.uint32(10).string(s.delegatorAddr), s.pagination !== void 0 && n.PageRequest.encode(s.pagination, k.uint32(18).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof t.BinaryReader ? s : new t.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = E();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.delegatorAddr = g.string();
            break;
          case 2:
            A.pagination = n.PageRequest.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = E();
      return (0, i.isSet)(s.delegatorAddr) && (k.delegatorAddr = String(s.delegatorAddr)), (0, i.isSet)(s.pagination) && (k.pagination = n.PageRequest.fromJSON(s.pagination)), k;
    },
    toJSON(s) {
      const k = {};
      return s.delegatorAddr !== void 0 && (k.delegatorAddr = s.delegatorAddr), s.pagination !== void 0 && (k.pagination = s.pagination ? n.PageRequest.toJSON(s.pagination) : void 0), k;
    },
    fromPartial(s) {
      const k = E();
      return k.delegatorAddr = s.delegatorAddr ?? "", s.pagination !== void 0 && s.pagination !== null && (k.pagination = n.PageRequest.fromPartial(s.pagination)), k;
    }
  };
  function U() {
    return {
      unbondingResponses: [],
      pagination: void 0
    };
  }
  e.QueryDelegatorUnbondingDelegationsResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsResponse",
    encode(s, k = t.BinaryWriter.create()) {
      for (const g of s.unbondingResponses)
        r.UnbondingDelegation.encode(g, k.uint32(10).fork()).ldelim();
      return s.pagination !== void 0 && n.PageResponse.encode(s.pagination, k.uint32(18).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof t.BinaryReader ? s : new t.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = U();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.unbondingResponses.push(r.UnbondingDelegation.decode(g, g.uint32()));
            break;
          case 2:
            A.pagination = n.PageResponse.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = U();
      return Array.isArray(s == null ? void 0 : s.unbondingResponses) && (k.unbondingResponses = s.unbondingResponses.map((g) => r.UnbondingDelegation.fromJSON(g))), (0, i.isSet)(s.pagination) && (k.pagination = n.PageResponse.fromJSON(s.pagination)), k;
    },
    toJSON(s) {
      const k = {};
      return s.unbondingResponses ? k.unbondingResponses = s.unbondingResponses.map((g) => g ? r.UnbondingDelegation.toJSON(g) : void 0) : k.unbondingResponses = [], s.pagination !== void 0 && (k.pagination = s.pagination ? n.PageResponse.toJSON(s.pagination) : void 0), k;
    },
    fromPartial(s) {
      var g;
      const k = U();
      return k.unbondingResponses = ((g = s.unbondingResponses) == null ? void 0 : g.map((P) => r.UnbondingDelegation.fromPartial(P))) || [], s.pagination !== void 0 && s.pagination !== null && (k.pagination = n.PageResponse.fromPartial(s.pagination)), k;
    }
  };
  function V() {
    return {
      delegatorAddr: "",
      srcValidatorAddr: "",
      dstValidatorAddr: "",
      pagination: void 0
    };
  }
  e.QueryRedelegationsRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryRedelegationsRequest",
    encode(s, k = t.BinaryWriter.create()) {
      return s.delegatorAddr !== "" && k.uint32(10).string(s.delegatorAddr), s.srcValidatorAddr !== "" && k.uint32(18).string(s.srcValidatorAddr), s.dstValidatorAddr !== "" && k.uint32(26).string(s.dstValidatorAddr), s.pagination !== void 0 && n.PageRequest.encode(s.pagination, k.uint32(34).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof t.BinaryReader ? s : new t.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = V();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.delegatorAddr = g.string();
            break;
          case 2:
            A.srcValidatorAddr = g.string();
            break;
          case 3:
            A.dstValidatorAddr = g.string();
            break;
          case 4:
            A.pagination = n.PageRequest.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = V();
      return (0, i.isSet)(s.delegatorAddr) && (k.delegatorAddr = String(s.delegatorAddr)), (0, i.isSet)(s.srcValidatorAddr) && (k.srcValidatorAddr = String(s.srcValidatorAddr)), (0, i.isSet)(s.dstValidatorAddr) && (k.dstValidatorAddr = String(s.dstValidatorAddr)), (0, i.isSet)(s.pagination) && (k.pagination = n.PageRequest.fromJSON(s.pagination)), k;
    },
    toJSON(s) {
      const k = {};
      return s.delegatorAddr !== void 0 && (k.delegatorAddr = s.delegatorAddr), s.srcValidatorAddr !== void 0 && (k.srcValidatorAddr = s.srcValidatorAddr), s.dstValidatorAddr !== void 0 && (k.dstValidatorAddr = s.dstValidatorAddr), s.pagination !== void 0 && (k.pagination = s.pagination ? n.PageRequest.toJSON(s.pagination) : void 0), k;
    },
    fromPartial(s) {
      const k = V();
      return k.delegatorAddr = s.delegatorAddr ?? "", k.srcValidatorAddr = s.srcValidatorAddr ?? "", k.dstValidatorAddr = s.dstValidatorAddr ?? "", s.pagination !== void 0 && s.pagination !== null && (k.pagination = n.PageRequest.fromPartial(s.pagination)), k;
    }
  };
  function o() {
    return {
      redelegationResponses: [],
      pagination: void 0
    };
  }
  e.QueryRedelegationsResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryRedelegationsResponse",
    encode(s, k = t.BinaryWriter.create()) {
      for (const g of s.redelegationResponses)
        r.RedelegationResponse.encode(g, k.uint32(10).fork()).ldelim();
      return s.pagination !== void 0 && n.PageResponse.encode(s.pagination, k.uint32(18).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof t.BinaryReader ? s : new t.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = o();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.redelegationResponses.push(r.RedelegationResponse.decode(g, g.uint32()));
            break;
          case 2:
            A.pagination = n.PageResponse.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = o();
      return Array.isArray(s == null ? void 0 : s.redelegationResponses) && (k.redelegationResponses = s.redelegationResponses.map((g) => r.RedelegationResponse.fromJSON(g))), (0, i.isSet)(s.pagination) && (k.pagination = n.PageResponse.fromJSON(s.pagination)), k;
    },
    toJSON(s) {
      const k = {};
      return s.redelegationResponses ? k.redelegationResponses = s.redelegationResponses.map((g) => g ? r.RedelegationResponse.toJSON(g) : void 0) : k.redelegationResponses = [], s.pagination !== void 0 && (k.pagination = s.pagination ? n.PageResponse.toJSON(s.pagination) : void 0), k;
    },
    fromPartial(s) {
      var g;
      const k = o();
      return k.redelegationResponses = ((g = s.redelegationResponses) == null ? void 0 : g.map((P) => r.RedelegationResponse.fromPartial(P))) || [], s.pagination !== void 0 && s.pagination !== null && (k.pagination = n.PageResponse.fromPartial(s.pagination)), k;
    }
  };
  function h() {
    return {
      delegatorAddr: "",
      pagination: void 0
    };
  }
  e.QueryDelegatorValidatorsRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorsRequest",
    encode(s, k = t.BinaryWriter.create()) {
      return s.delegatorAddr !== "" && k.uint32(10).string(s.delegatorAddr), s.pagination !== void 0 && n.PageRequest.encode(s.pagination, k.uint32(18).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof t.BinaryReader ? s : new t.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = h();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.delegatorAddr = g.string();
            break;
          case 2:
            A.pagination = n.PageRequest.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = h();
      return (0, i.isSet)(s.delegatorAddr) && (k.delegatorAddr = String(s.delegatorAddr)), (0, i.isSet)(s.pagination) && (k.pagination = n.PageRequest.fromJSON(s.pagination)), k;
    },
    toJSON(s) {
      const k = {};
      return s.delegatorAddr !== void 0 && (k.delegatorAddr = s.delegatorAddr), s.pagination !== void 0 && (k.pagination = s.pagination ? n.PageRequest.toJSON(s.pagination) : void 0), k;
    },
    fromPartial(s) {
      const k = h();
      return k.delegatorAddr = s.delegatorAddr ?? "", s.pagination !== void 0 && s.pagination !== null && (k.pagination = n.PageRequest.fromPartial(s.pagination)), k;
    }
  };
  function N() {
    return {
      validators: [],
      pagination: void 0
    };
  }
  e.QueryDelegatorValidatorsResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorsResponse",
    encode(s, k = t.BinaryWriter.create()) {
      for (const g of s.validators)
        r.Validator.encode(g, k.uint32(10).fork()).ldelim();
      return s.pagination !== void 0 && n.PageResponse.encode(s.pagination, k.uint32(18).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof t.BinaryReader ? s : new t.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = N();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.validators.push(r.Validator.decode(g, g.uint32()));
            break;
          case 2:
            A.pagination = n.PageResponse.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = N();
      return Array.isArray(s == null ? void 0 : s.validators) && (k.validators = s.validators.map((g) => r.Validator.fromJSON(g))), (0, i.isSet)(s.pagination) && (k.pagination = n.PageResponse.fromJSON(s.pagination)), k;
    },
    toJSON(s) {
      const k = {};
      return s.validators ? k.validators = s.validators.map((g) => g ? r.Validator.toJSON(g) : void 0) : k.validators = [], s.pagination !== void 0 && (k.pagination = s.pagination ? n.PageResponse.toJSON(s.pagination) : void 0), k;
    },
    fromPartial(s) {
      var g;
      const k = N();
      return k.validators = ((g = s.validators) == null ? void 0 : g.map((P) => r.Validator.fromPartial(P))) || [], s.pagination !== void 0 && s.pagination !== null && (k.pagination = n.PageResponse.fromPartial(s.pagination)), k;
    }
  };
  function q() {
    return {
      delegatorAddr: "",
      validatorAddr: ""
    };
  }
  e.QueryDelegatorValidatorRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorRequest",
    encode(s, k = t.BinaryWriter.create()) {
      return s.delegatorAddr !== "" && k.uint32(10).string(s.delegatorAddr), s.validatorAddr !== "" && k.uint32(18).string(s.validatorAddr), k;
    },
    decode(s, k) {
      const g = s instanceof t.BinaryReader ? s : new t.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = q();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.delegatorAddr = g.string();
            break;
          case 2:
            A.validatorAddr = g.string();
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = q();
      return (0, i.isSet)(s.delegatorAddr) && (k.delegatorAddr = String(s.delegatorAddr)), (0, i.isSet)(s.validatorAddr) && (k.validatorAddr = String(s.validatorAddr)), k;
    },
    toJSON(s) {
      const k = {};
      return s.delegatorAddr !== void 0 && (k.delegatorAddr = s.delegatorAddr), s.validatorAddr !== void 0 && (k.validatorAddr = s.validatorAddr), k;
    },
    fromPartial(s) {
      const k = q();
      return k.delegatorAddr = s.delegatorAddr ?? "", k.validatorAddr = s.validatorAddr ?? "", k;
    }
  };
  function u() {
    return {
      validator: r.Validator.fromPartial({})
    };
  }
  e.QueryDelegatorValidatorResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorResponse",
    encode(s, k = t.BinaryWriter.create()) {
      return s.validator !== void 0 && r.Validator.encode(s.validator, k.uint32(10).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof t.BinaryReader ? s : new t.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = u();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.validator = r.Validator.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = u();
      return (0, i.isSet)(s.validator) && (k.validator = r.Validator.fromJSON(s.validator)), k;
    },
    toJSON(s) {
      const k = {};
      return s.validator !== void 0 && (k.validator = s.validator ? r.Validator.toJSON(s.validator) : void 0), k;
    },
    fromPartial(s) {
      const k = u();
      return s.validator !== void 0 && s.validator !== null && (k.validator = r.Validator.fromPartial(s.validator)), k;
    }
  };
  function l() {
    return {
      height: BigInt(0)
    };
  }
  e.QueryHistoricalInfoRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryHistoricalInfoRequest",
    encode(s, k = t.BinaryWriter.create()) {
      return s.height !== BigInt(0) && k.uint32(8).int64(s.height), k;
    },
    decode(s, k) {
      const g = s instanceof t.BinaryReader ? s : new t.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = l();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.height = g.int64();
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = l();
      return (0, i.isSet)(s.height) && (k.height = BigInt(s.height.toString())), k;
    },
    toJSON(s) {
      const k = {};
      return s.height !== void 0 && (k.height = (s.height || BigInt(0)).toString()), k;
    },
    fromPartial(s) {
      const k = l();
      return s.height !== void 0 && s.height !== null && (k.height = BigInt(s.height.toString())), k;
    }
  };
  function I() {
    return {
      hist: void 0
    };
  }
  e.QueryHistoricalInfoResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryHistoricalInfoResponse",
    encode(s, k = t.BinaryWriter.create()) {
      return s.hist !== void 0 && r.HistoricalInfo.encode(s.hist, k.uint32(10).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof t.BinaryReader ? s : new t.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = I();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.hist = r.HistoricalInfo.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = I();
      return (0, i.isSet)(s.hist) && (k.hist = r.HistoricalInfo.fromJSON(s.hist)), k;
    },
    toJSON(s) {
      const k = {};
      return s.hist !== void 0 && (k.hist = s.hist ? r.HistoricalInfo.toJSON(s.hist) : void 0), k;
    },
    fromPartial(s) {
      const k = I();
      return s.hist !== void 0 && s.hist !== null && (k.hist = r.HistoricalInfo.fromPartial(s.hist)), k;
    }
  };
  function B() {
    return {};
  }
  e.QueryPoolRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryPoolRequest",
    encode(s, k = t.BinaryWriter.create()) {
      return k;
    },
    decode(s, k) {
      const g = s instanceof t.BinaryReader ? s : new t.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = B();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      return B();
    },
    toJSON(s) {
      return {};
    },
    fromPartial(s) {
      return B();
    }
  };
  function b() {
    return {
      pool: r.Pool.fromPartial({})
    };
  }
  e.QueryPoolResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryPoolResponse",
    encode(s, k = t.BinaryWriter.create()) {
      return s.pool !== void 0 && r.Pool.encode(s.pool, k.uint32(10).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof t.BinaryReader ? s : new t.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = b();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.pool = r.Pool.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = b();
      return (0, i.isSet)(s.pool) && (k.pool = r.Pool.fromJSON(s.pool)), k;
    },
    toJSON(s) {
      const k = {};
      return s.pool !== void 0 && (k.pool = s.pool ? r.Pool.toJSON(s.pool) : void 0), k;
    },
    fromPartial(s) {
      const k = b();
      return s.pool !== void 0 && s.pool !== null && (k.pool = r.Pool.fromPartial(s.pool)), k;
    }
  };
  function D() {
    return {};
  }
  e.QueryParamsRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryParamsRequest",
    encode(s, k = t.BinaryWriter.create()) {
      return k;
    },
    decode(s, k) {
      const g = s instanceof t.BinaryReader ? s : new t.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = D();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      return D();
    },
    toJSON(s) {
      return {};
    },
    fromPartial(s) {
      return D();
    }
  };
  function Q() {
    return {
      params: r.Params.fromPartial({})
    };
  }
  e.QueryParamsResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryParamsResponse",
    encode(s, k = t.BinaryWriter.create()) {
      return s.params !== void 0 && r.Params.encode(s.params, k.uint32(10).fork()).ldelim(), k;
    },
    decode(s, k) {
      const g = s instanceof t.BinaryReader ? s : new t.BinaryReader(s);
      let P = k === void 0 ? g.len : g.pos + k;
      const A = Q();
      for (; g.pos < P; ) {
        const W = g.uint32();
        switch (W >>> 3) {
          case 1:
            A.params = r.Params.decode(g, g.uint32());
            break;
          default:
            g.skipType(W & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(s) {
      const k = Q();
      return (0, i.isSet)(s.params) && (k.params = r.Params.fromJSON(s.params)), k;
    },
    toJSON(s) {
      const k = {};
      return s.params !== void 0 && (k.params = s.params ? r.Params.toJSON(s.params) : void 0), k;
    },
    fromPartial(s) {
      const k = Q();
      return s.params !== void 0 && s.params !== null && (k.params = r.Params.fromPartial(s.params)), k;
    }
  };
  class H {
    constructor(k) {
      this.rpc = k, this.Validators = this.Validators.bind(this), this.Validator = this.Validator.bind(this), this.ValidatorDelegations = this.ValidatorDelegations.bind(this), this.ValidatorUnbondingDelegations = this.ValidatorUnbondingDelegations.bind(this), this.Delegation = this.Delegation.bind(this), this.UnbondingDelegation = this.UnbondingDelegation.bind(this), this.DelegatorDelegations = this.DelegatorDelegations.bind(this), this.DelegatorUnbondingDelegations = this.DelegatorUnbondingDelegations.bind(this), this.Redelegations = this.Redelegations.bind(this), this.DelegatorValidators = this.DelegatorValidators.bind(this), this.DelegatorValidator = this.DelegatorValidator.bind(this), this.HistoricalInfo = this.HistoricalInfo.bind(this), this.Pool = this.Pool.bind(this), this.Params = this.Params.bind(this);
    }
    Validators(k) {
      const g = e.QueryValidatorsRequest.encode(k).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "Validators", g).then((A) => e.QueryValidatorsResponse.decode(new t.BinaryReader(A)));
    }
    Validator(k) {
      const g = e.QueryValidatorRequest.encode(k).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "Validator", g).then((A) => e.QueryValidatorResponse.decode(new t.BinaryReader(A)));
    }
    ValidatorDelegations(k) {
      const g = e.QueryValidatorDelegationsRequest.encode(k).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "ValidatorDelegations", g).then((A) => e.QueryValidatorDelegationsResponse.decode(new t.BinaryReader(A)));
    }
    ValidatorUnbondingDelegations(k) {
      const g = e.QueryValidatorUnbondingDelegationsRequest.encode(k).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "ValidatorUnbondingDelegations", g).then((A) => e.QueryValidatorUnbondingDelegationsResponse.decode(new t.BinaryReader(A)));
    }
    Delegation(k) {
      const g = e.QueryDelegationRequest.encode(k).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "Delegation", g).then((A) => e.QueryDelegationResponse.decode(new t.BinaryReader(A)));
    }
    UnbondingDelegation(k) {
      const g = e.QueryUnbondingDelegationRequest.encode(k).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "UnbondingDelegation", g).then((A) => e.QueryUnbondingDelegationResponse.decode(new t.BinaryReader(A)));
    }
    DelegatorDelegations(k) {
      const g = e.QueryDelegatorDelegationsRequest.encode(k).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorDelegations", g).then((A) => e.QueryDelegatorDelegationsResponse.decode(new t.BinaryReader(A)));
    }
    DelegatorUnbondingDelegations(k) {
      const g = e.QueryDelegatorUnbondingDelegationsRequest.encode(k).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorUnbondingDelegations", g).then((A) => e.QueryDelegatorUnbondingDelegationsResponse.decode(new t.BinaryReader(A)));
    }
    Redelegations(k) {
      const g = e.QueryRedelegationsRequest.encode(k).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "Redelegations", g).then((A) => e.QueryRedelegationsResponse.decode(new t.BinaryReader(A)));
    }
    DelegatorValidators(k) {
      const g = e.QueryDelegatorValidatorsRequest.encode(k).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorValidators", g).then((A) => e.QueryDelegatorValidatorsResponse.decode(new t.BinaryReader(A)));
    }
    DelegatorValidator(k) {
      const g = e.QueryDelegatorValidatorRequest.encode(k).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorValidator", g).then((A) => e.QueryDelegatorValidatorResponse.decode(new t.BinaryReader(A)));
    }
    HistoricalInfo(k) {
      const g = e.QueryHistoricalInfoRequest.encode(k).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "HistoricalInfo", g).then((A) => e.QueryHistoricalInfoResponse.decode(new t.BinaryReader(A)));
    }
    Pool(k = {}) {
      const g = e.QueryPoolRequest.encode(k).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "Pool", g).then((A) => e.QueryPoolResponse.decode(new t.BinaryReader(A)));
    }
    Params(k = {}) {
      const g = e.QueryParamsRequest.encode(k).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "Params", g).then((A) => e.QueryParamsResponse.decode(new t.BinaryReader(A)));
    }
  }
  e.QueryClientImpl = H;
})(zh);
Object.defineProperty(Es, "__esModule", { value: !0 });
Es.setupStakingExtension = void 0;
const rB = zh, St = Ye;
function iB(e) {
  const n = (0, St.createProtobufRpcClient)(e), r = new rB.QueryClientImpl(n);
  return {
    staking: {
      delegation: async (t, i) => await r.Delegation({
        delegatorAddr: t,
        validatorAddr: i
      }),
      delegatorDelegations: async (t, i) => await r.DelegatorDelegations({
        delegatorAddr: t,
        pagination: (0, St.createPagination)(i)
      }),
      delegatorUnbondingDelegations: async (t, i) => await r.DelegatorUnbondingDelegations({
        delegatorAddr: t,
        pagination: (0, St.createPagination)(i)
      }),
      delegatorValidator: async (t, i) => await r.DelegatorValidator({
        delegatorAddr: t,
        validatorAddr: i
      }),
      delegatorValidators: async (t, i) => await r.DelegatorValidators({
        delegatorAddr: t,
        pagination: (0, St.createPagination)(i)
      }),
      historicalInfo: async (t) => await r.HistoricalInfo({
        height: BigInt(t)
      }),
      params: async () => await r.Params({}),
      pool: async () => await r.Pool({}),
      redelegations: async (t, i, f, S) => await r.Redelegations({
        delegatorAddr: t,
        srcValidatorAddr: i,
        dstValidatorAddr: f,
        pagination: (0, St.createPagination)(S)
      }),
      unbondingDelegation: async (t, i) => await r.UnbondingDelegation({
        delegatorAddr: t,
        validatorAddr: i
      }),
      validator: async (t) => await r.Validator({ validatorAddr: t }),
      validatorDelegations: async (t, i) => await r.ValidatorDelegations({
        validatorAddr: t,
        pagination: (0, St.createPagination)(i)
      }),
      validators: async (t, i) => await r.Validators({
        status: t,
        pagination: (0, St.createPagination)(i)
      }),
      validatorUnbondingDelegations: async (t, i) => await r.ValidatorUnbondingDelegations({
        validatorAddr: t,
        pagination: (0, St.createPagination)(i)
      })
    }
  };
}
Es.setupStakingExtension = iB;
var Us = {}, xh = {}, nl = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.SearchTxsResult = e.TxMsgData = e.MsgData = e.SimulationResponse = e.Result = e.GasInfo = e.Attribute = e.StringEvent = e.ABCIMessageLog = e.TxResponse = e.protobufPackage = void 0;
  const n = Pe, r = el, t = re, i = ie;
  e.protobufPackage = "cosmos.base.abci.v1beta1";
  function f() {
    return {
      height: BigInt(0),
      txhash: "",
      codespace: "",
      code: 0,
      data: "",
      rawLog: "",
      logs: [],
      info: "",
      gasWanted: BigInt(0),
      gasUsed: BigInt(0),
      tx: void 0,
      timestamp: "",
      events: []
    };
  }
  e.TxResponse = {
    typeUrl: "/cosmos.base.abci.v1beta1.TxResponse",
    encode(a, d = t.BinaryWriter.create()) {
      a.height !== BigInt(0) && d.uint32(8).int64(a.height), a.txhash !== "" && d.uint32(18).string(a.txhash), a.codespace !== "" && d.uint32(26).string(a.codespace), a.code !== 0 && d.uint32(32).uint32(a.code), a.data !== "" && d.uint32(42).string(a.data), a.rawLog !== "" && d.uint32(50).string(a.rawLog);
      for (const y of a.logs)
        e.ABCIMessageLog.encode(y, d.uint32(58).fork()).ldelim();
      a.info !== "" && d.uint32(66).string(a.info), a.gasWanted !== BigInt(0) && d.uint32(72).int64(a.gasWanted), a.gasUsed !== BigInt(0) && d.uint32(80).int64(a.gasUsed), a.tx !== void 0 && n.Any.encode(a.tx, d.uint32(90).fork()).ldelim(), a.timestamp !== "" && d.uint32(98).string(a.timestamp);
      for (const y of a.events)
        r.Event.encode(y, d.uint32(106).fork()).ldelim();
      return d;
    },
    decode(a, d) {
      const y = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = f();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          case 1:
            E.height = y.int64();
            break;
          case 2:
            E.txhash = y.string();
            break;
          case 3:
            E.codespace = y.string();
            break;
          case 4:
            E.code = y.uint32();
            break;
          case 5:
            E.data = y.string();
            break;
          case 6:
            E.rawLog = y.string();
            break;
          case 7:
            E.logs.push(e.ABCIMessageLog.decode(y, y.uint32()));
            break;
          case 8:
            E.info = y.string();
            break;
          case 9:
            E.gasWanted = y.int64();
            break;
          case 10:
            E.gasUsed = y.int64();
            break;
          case 11:
            E.tx = n.Any.decode(y, y.uint32());
            break;
          case 12:
            E.timestamp = y.string();
            break;
          case 13:
            E.events.push(r.Event.decode(y, y.uint32()));
            break;
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      const d = f();
      return (0, i.isSet)(a.height) && (d.height = BigInt(a.height.toString())), (0, i.isSet)(a.txhash) && (d.txhash = String(a.txhash)), (0, i.isSet)(a.codespace) && (d.codespace = String(a.codespace)), (0, i.isSet)(a.code) && (d.code = Number(a.code)), (0, i.isSet)(a.data) && (d.data = String(a.data)), (0, i.isSet)(a.rawLog) && (d.rawLog = String(a.rawLog)), Array.isArray(a == null ? void 0 : a.logs) && (d.logs = a.logs.map((y) => e.ABCIMessageLog.fromJSON(y))), (0, i.isSet)(a.info) && (d.info = String(a.info)), (0, i.isSet)(a.gasWanted) && (d.gasWanted = BigInt(a.gasWanted.toString())), (0, i.isSet)(a.gasUsed) && (d.gasUsed = BigInt(a.gasUsed.toString())), (0, i.isSet)(a.tx) && (d.tx = n.Any.fromJSON(a.tx)), (0, i.isSet)(a.timestamp) && (d.timestamp = String(a.timestamp)), Array.isArray(a == null ? void 0 : a.events) && (d.events = a.events.map((y) => r.Event.fromJSON(y))), d;
    },
    toJSON(a) {
      const d = {};
      return a.height !== void 0 && (d.height = (a.height || BigInt(0)).toString()), a.txhash !== void 0 && (d.txhash = a.txhash), a.codespace !== void 0 && (d.codespace = a.codespace), a.code !== void 0 && (d.code = Math.round(a.code)), a.data !== void 0 && (d.data = a.data), a.rawLog !== void 0 && (d.rawLog = a.rawLog), a.logs ? d.logs = a.logs.map((y) => y ? e.ABCIMessageLog.toJSON(y) : void 0) : d.logs = [], a.info !== void 0 && (d.info = a.info), a.gasWanted !== void 0 && (d.gasWanted = (a.gasWanted || BigInt(0)).toString()), a.gasUsed !== void 0 && (d.gasUsed = (a.gasUsed || BigInt(0)).toString()), a.tx !== void 0 && (d.tx = a.tx ? n.Any.toJSON(a.tx) : void 0), a.timestamp !== void 0 && (d.timestamp = a.timestamp), a.events ? d.events = a.events.map((y) => y ? r.Event.toJSON(y) : void 0) : d.events = [], d;
    },
    fromPartial(a) {
      var y, _;
      const d = f();
      return a.height !== void 0 && a.height !== null && (d.height = BigInt(a.height.toString())), d.txhash = a.txhash ?? "", d.codespace = a.codespace ?? "", d.code = a.code ?? 0, d.data = a.data ?? "", d.rawLog = a.rawLog ?? "", d.logs = ((y = a.logs) == null ? void 0 : y.map((E) => e.ABCIMessageLog.fromPartial(E))) || [], d.info = a.info ?? "", a.gasWanted !== void 0 && a.gasWanted !== null && (d.gasWanted = BigInt(a.gasWanted.toString())), a.gasUsed !== void 0 && a.gasUsed !== null && (d.gasUsed = BigInt(a.gasUsed.toString())), a.tx !== void 0 && a.tx !== null && (d.tx = n.Any.fromPartial(a.tx)), d.timestamp = a.timestamp ?? "", d.events = ((_ = a.events) == null ? void 0 : _.map((E) => r.Event.fromPartial(E))) || [], d;
    }
  };
  function S() {
    return {
      msgIndex: 0,
      log: "",
      events: []
    };
  }
  e.ABCIMessageLog = {
    typeUrl: "/cosmos.base.abci.v1beta1.ABCIMessageLog",
    encode(a, d = t.BinaryWriter.create()) {
      a.msgIndex !== 0 && d.uint32(8).uint32(a.msgIndex), a.log !== "" && d.uint32(18).string(a.log);
      for (const y of a.events)
        e.StringEvent.encode(y, d.uint32(26).fork()).ldelim();
      return d;
    },
    decode(a, d) {
      const y = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = S();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          case 1:
            E.msgIndex = y.uint32();
            break;
          case 2:
            E.log = y.string();
            break;
          case 3:
            E.events.push(e.StringEvent.decode(y, y.uint32()));
            break;
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      const d = S();
      return (0, i.isSet)(a.msgIndex) && (d.msgIndex = Number(a.msgIndex)), (0, i.isSet)(a.log) && (d.log = String(a.log)), Array.isArray(a == null ? void 0 : a.events) && (d.events = a.events.map((y) => e.StringEvent.fromJSON(y))), d;
    },
    toJSON(a) {
      const d = {};
      return a.msgIndex !== void 0 && (d.msgIndex = Math.round(a.msgIndex)), a.log !== void 0 && (d.log = a.log), a.events ? d.events = a.events.map((y) => y ? e.StringEvent.toJSON(y) : void 0) : d.events = [], d;
    },
    fromPartial(a) {
      var y;
      const d = S();
      return d.msgIndex = a.msgIndex ?? 0, d.log = a.log ?? "", d.events = ((y = a.events) == null ? void 0 : y.map((_) => e.StringEvent.fromPartial(_))) || [], d;
    }
  };
  function w() {
    return {
      type: "",
      attributes: []
    };
  }
  e.StringEvent = {
    typeUrl: "/cosmos.base.abci.v1beta1.StringEvent",
    encode(a, d = t.BinaryWriter.create()) {
      a.type !== "" && d.uint32(10).string(a.type);
      for (const y of a.attributes)
        e.Attribute.encode(y, d.uint32(18).fork()).ldelim();
      return d;
    },
    decode(a, d) {
      const y = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = w();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          case 1:
            E.type = y.string();
            break;
          case 2:
            E.attributes.push(e.Attribute.decode(y, y.uint32()));
            break;
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      const d = w();
      return (0, i.isSet)(a.type) && (d.type = String(a.type)), Array.isArray(a == null ? void 0 : a.attributes) && (d.attributes = a.attributes.map((y) => e.Attribute.fromJSON(y))), d;
    },
    toJSON(a) {
      const d = {};
      return a.type !== void 0 && (d.type = a.type), a.attributes ? d.attributes = a.attributes.map((y) => y ? e.Attribute.toJSON(y) : void 0) : d.attributes = [], d;
    },
    fromPartial(a) {
      var y;
      const d = w();
      return d.type = a.type ?? "", d.attributes = ((y = a.attributes) == null ? void 0 : y.map((_) => e.Attribute.fromPartial(_))) || [], d;
    }
  };
  function T() {
    return {
      key: "",
      value: ""
    };
  }
  e.Attribute = {
    typeUrl: "/cosmos.base.abci.v1beta1.Attribute",
    encode(a, d = t.BinaryWriter.create()) {
      return a.key !== "" && d.uint32(10).string(a.key), a.value !== "" && d.uint32(18).string(a.value), d;
    },
    decode(a, d) {
      const y = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = T();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          case 1:
            E.key = y.string();
            break;
          case 2:
            E.value = y.string();
            break;
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      const d = T();
      return (0, i.isSet)(a.key) && (d.key = String(a.key)), (0, i.isSet)(a.value) && (d.value = String(a.value)), d;
    },
    toJSON(a) {
      const d = {};
      return a.key !== void 0 && (d.key = a.key), a.value !== void 0 && (d.value = a.value), d;
    },
    fromPartial(a) {
      const d = T();
      return d.key = a.key ?? "", d.value = a.value ?? "", d;
    }
  };
  function J() {
    return {
      gasWanted: BigInt(0),
      gasUsed: BigInt(0)
    };
  }
  e.GasInfo = {
    typeUrl: "/cosmos.base.abci.v1beta1.GasInfo",
    encode(a, d = t.BinaryWriter.create()) {
      return a.gasWanted !== BigInt(0) && d.uint32(8).uint64(a.gasWanted), a.gasUsed !== BigInt(0) && d.uint32(16).uint64(a.gasUsed), d;
    },
    decode(a, d) {
      const y = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = J();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          case 1:
            E.gasWanted = y.uint64();
            break;
          case 2:
            E.gasUsed = y.uint64();
            break;
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      const d = J();
      return (0, i.isSet)(a.gasWanted) && (d.gasWanted = BigInt(a.gasWanted.toString())), (0, i.isSet)(a.gasUsed) && (d.gasUsed = BigInt(a.gasUsed.toString())), d;
    },
    toJSON(a) {
      const d = {};
      return a.gasWanted !== void 0 && (d.gasWanted = (a.gasWanted || BigInt(0)).toString()), a.gasUsed !== void 0 && (d.gasUsed = (a.gasUsed || BigInt(0)).toString()), d;
    },
    fromPartial(a) {
      const d = J();
      return a.gasWanted !== void 0 && a.gasWanted !== null && (d.gasWanted = BigInt(a.gasWanted.toString())), a.gasUsed !== void 0 && a.gasUsed !== null && (d.gasUsed = BigInt(a.gasUsed.toString())), d;
    }
  };
  function C() {
    return {
      data: new Uint8Array(),
      log: "",
      events: [],
      msgResponses: []
    };
  }
  e.Result = {
    typeUrl: "/cosmos.base.abci.v1beta1.Result",
    encode(a, d = t.BinaryWriter.create()) {
      a.data.length !== 0 && d.uint32(10).bytes(a.data), a.log !== "" && d.uint32(18).string(a.log);
      for (const y of a.events)
        r.Event.encode(y, d.uint32(26).fork()).ldelim();
      for (const y of a.msgResponses)
        n.Any.encode(y, d.uint32(34).fork()).ldelim();
      return d;
    },
    decode(a, d) {
      const y = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = C();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          case 1:
            E.data = y.bytes();
            break;
          case 2:
            E.log = y.string();
            break;
          case 3:
            E.events.push(r.Event.decode(y, y.uint32()));
            break;
          case 4:
            E.msgResponses.push(n.Any.decode(y, y.uint32()));
            break;
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      const d = C();
      return (0, i.isSet)(a.data) && (d.data = (0, i.bytesFromBase64)(a.data)), (0, i.isSet)(a.log) && (d.log = String(a.log)), Array.isArray(a == null ? void 0 : a.events) && (d.events = a.events.map((y) => r.Event.fromJSON(y))), Array.isArray(a == null ? void 0 : a.msgResponses) && (d.msgResponses = a.msgResponses.map((y) => n.Any.fromJSON(y))), d;
    },
    toJSON(a) {
      const d = {};
      return a.data !== void 0 && (d.data = (0, i.base64FromBytes)(a.data !== void 0 ? a.data : new Uint8Array())), a.log !== void 0 && (d.log = a.log), a.events ? d.events = a.events.map((y) => y ? r.Event.toJSON(y) : void 0) : d.events = [], a.msgResponses ? d.msgResponses = a.msgResponses.map((y) => y ? n.Any.toJSON(y) : void 0) : d.msgResponses = [], d;
    },
    fromPartial(a) {
      var y, _;
      const d = C();
      return d.data = a.data ?? new Uint8Array(), d.log = a.log ?? "", d.events = ((y = a.events) == null ? void 0 : y.map((E) => r.Event.fromPartial(E))) || [], d.msgResponses = ((_ = a.msgResponses) == null ? void 0 : _.map((E) => n.Any.fromPartial(E))) || [], d;
    }
  };
  function R() {
    return {
      gasInfo: e.GasInfo.fromPartial({}),
      result: void 0
    };
  }
  e.SimulationResponse = {
    typeUrl: "/cosmos.base.abci.v1beta1.SimulationResponse",
    encode(a, d = t.BinaryWriter.create()) {
      return a.gasInfo !== void 0 && e.GasInfo.encode(a.gasInfo, d.uint32(10).fork()).ldelim(), a.result !== void 0 && e.Result.encode(a.result, d.uint32(18).fork()).ldelim(), d;
    },
    decode(a, d) {
      const y = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = R();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          case 1:
            E.gasInfo = e.GasInfo.decode(y, y.uint32());
            break;
          case 2:
            E.result = e.Result.decode(y, y.uint32());
            break;
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      const d = R();
      return (0, i.isSet)(a.gasInfo) && (d.gasInfo = e.GasInfo.fromJSON(a.gasInfo)), (0, i.isSet)(a.result) && (d.result = e.Result.fromJSON(a.result)), d;
    },
    toJSON(a) {
      const d = {};
      return a.gasInfo !== void 0 && (d.gasInfo = a.gasInfo ? e.GasInfo.toJSON(a.gasInfo) : void 0), a.result !== void 0 && (d.result = a.result ? e.Result.toJSON(a.result) : void 0), d;
    },
    fromPartial(a) {
      const d = R();
      return a.gasInfo !== void 0 && a.gasInfo !== null && (d.gasInfo = e.GasInfo.fromPartial(a.gasInfo)), a.result !== void 0 && a.result !== null && (d.result = e.Result.fromPartial(a.result)), d;
    }
  };
  function p() {
    return {
      msgType: "",
      data: new Uint8Array()
    };
  }
  e.MsgData = {
    typeUrl: "/cosmos.base.abci.v1beta1.MsgData",
    encode(a, d = t.BinaryWriter.create()) {
      return a.msgType !== "" && d.uint32(10).string(a.msgType), a.data.length !== 0 && d.uint32(18).bytes(a.data), d;
    },
    decode(a, d) {
      const y = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = p();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          case 1:
            E.msgType = y.string();
            break;
          case 2:
            E.data = y.bytes();
            break;
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      const d = p();
      return (0, i.isSet)(a.msgType) && (d.msgType = String(a.msgType)), (0, i.isSet)(a.data) && (d.data = (0, i.bytesFromBase64)(a.data)), d;
    },
    toJSON(a) {
      const d = {};
      return a.msgType !== void 0 && (d.msgType = a.msgType), a.data !== void 0 && (d.data = (0, i.base64FromBytes)(a.data !== void 0 ? a.data : new Uint8Array())), d;
    },
    fromPartial(a) {
      const d = p();
      return d.msgType = a.msgType ?? "", d.data = a.data ?? new Uint8Array(), d;
    }
  };
  function m() {
    return {
      data: [],
      msgResponses: []
    };
  }
  e.TxMsgData = {
    typeUrl: "/cosmos.base.abci.v1beta1.TxMsgData",
    encode(a, d = t.BinaryWriter.create()) {
      for (const y of a.data)
        e.MsgData.encode(y, d.uint32(10).fork()).ldelim();
      for (const y of a.msgResponses)
        n.Any.encode(y, d.uint32(18).fork()).ldelim();
      return d;
    },
    decode(a, d) {
      const y = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = m();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          case 1:
            E.data.push(e.MsgData.decode(y, y.uint32()));
            break;
          case 2:
            E.msgResponses.push(n.Any.decode(y, y.uint32()));
            break;
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      const d = m();
      return Array.isArray(a == null ? void 0 : a.data) && (d.data = a.data.map((y) => e.MsgData.fromJSON(y))), Array.isArray(a == null ? void 0 : a.msgResponses) && (d.msgResponses = a.msgResponses.map((y) => n.Any.fromJSON(y))), d;
    },
    toJSON(a) {
      const d = {};
      return a.data ? d.data = a.data.map((y) => y ? e.MsgData.toJSON(y) : void 0) : d.data = [], a.msgResponses ? d.msgResponses = a.msgResponses.map((y) => y ? n.Any.toJSON(y) : void 0) : d.msgResponses = [], d;
    },
    fromPartial(a) {
      var y, _;
      const d = m();
      return d.data = ((y = a.data) == null ? void 0 : y.map((E) => e.MsgData.fromPartial(E))) || [], d.msgResponses = ((_ = a.msgResponses) == null ? void 0 : _.map((E) => n.Any.fromPartial(E))) || [], d;
    }
  };
  function v() {
    return {
      totalCount: BigInt(0),
      count: BigInt(0),
      pageNumber: BigInt(0),
      pageTotal: BigInt(0),
      limit: BigInt(0),
      txs: []
    };
  }
  e.SearchTxsResult = {
    typeUrl: "/cosmos.base.abci.v1beta1.SearchTxsResult",
    encode(a, d = t.BinaryWriter.create()) {
      a.totalCount !== BigInt(0) && d.uint32(8).uint64(a.totalCount), a.count !== BigInt(0) && d.uint32(16).uint64(a.count), a.pageNumber !== BigInt(0) && d.uint32(24).uint64(a.pageNumber), a.pageTotal !== BigInt(0) && d.uint32(32).uint64(a.pageTotal), a.limit !== BigInt(0) && d.uint32(40).uint64(a.limit);
      for (const y of a.txs)
        e.TxResponse.encode(y, d.uint32(50).fork()).ldelim();
      return d;
    },
    decode(a, d) {
      const y = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let _ = d === void 0 ? y.len : y.pos + d;
      const E = v();
      for (; y.pos < _; ) {
        const U = y.uint32();
        switch (U >>> 3) {
          case 1:
            E.totalCount = y.uint64();
            break;
          case 2:
            E.count = y.uint64();
            break;
          case 3:
            E.pageNumber = y.uint64();
            break;
          case 4:
            E.pageTotal = y.uint64();
            break;
          case 5:
            E.limit = y.uint64();
            break;
          case 6:
            E.txs.push(e.TxResponse.decode(y, y.uint32()));
            break;
          default:
            y.skipType(U & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(a) {
      const d = v();
      return (0, i.isSet)(a.totalCount) && (d.totalCount = BigInt(a.totalCount.toString())), (0, i.isSet)(a.count) && (d.count = BigInt(a.count.toString())), (0, i.isSet)(a.pageNumber) && (d.pageNumber = BigInt(a.pageNumber.toString())), (0, i.isSet)(a.pageTotal) && (d.pageTotal = BigInt(a.pageTotal.toString())), (0, i.isSet)(a.limit) && (d.limit = BigInt(a.limit.toString())), Array.isArray(a == null ? void 0 : a.txs) && (d.txs = a.txs.map((y) => e.TxResponse.fromJSON(y))), d;
    },
    toJSON(a) {
      const d = {};
      return a.totalCount !== void 0 && (d.totalCount = (a.totalCount || BigInt(0)).toString()), a.count !== void 0 && (d.count = (a.count || BigInt(0)).toString()), a.pageNumber !== void 0 && (d.pageNumber = (a.pageNumber || BigInt(0)).toString()), a.pageTotal !== void 0 && (d.pageTotal = (a.pageTotal || BigInt(0)).toString()), a.limit !== void 0 && (d.limit = (a.limit || BigInt(0)).toString()), a.txs ? d.txs = a.txs.map((y) => y ? e.TxResponse.toJSON(y) : void 0) : d.txs = [], d;
    },
    fromPartial(a) {
      var y;
      const d = v();
      return a.totalCount !== void 0 && a.totalCount !== null && (d.totalCount = BigInt(a.totalCount.toString())), a.count !== void 0 && a.count !== null && (d.count = BigInt(a.count.toString())), a.pageNumber !== void 0 && a.pageNumber !== null && (d.pageNumber = BigInt(a.pageNumber.toString())), a.pageTotal !== void 0 && a.pageTotal !== null && (d.pageTotal = BigInt(a.pageTotal.toString())), a.limit !== void 0 && a.limit !== null && (d.limit = BigInt(a.limit.toString())), d.txs = ((y = a.txs) == null ? void 0 : y.map((_) => e.TxResponse.fromPartial(_))) || [], d;
    }
  };
})(nl);
var vi = {}, Zh = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.EvidenceList = e.LightClientAttackEvidence = e.DuplicateVoteEvidence = e.Evidence = e.protobufPackage = void 0;
  const n = ar, r = Je, t = Cs, i = re, f = ie;
  e.protobufPackage = "tendermint.types";
  function S() {
    return {
      duplicateVoteEvidence: void 0,
      lightClientAttackEvidence: void 0
    };
  }
  e.Evidence = {
    typeUrl: "/tendermint.types.Evidence",
    encode(C, R = i.BinaryWriter.create()) {
      return C.duplicateVoteEvidence !== void 0 && e.DuplicateVoteEvidence.encode(C.duplicateVoteEvidence, R.uint32(10).fork()).ldelim(), C.lightClientAttackEvidence !== void 0 && e.LightClientAttackEvidence.encode(C.lightClientAttackEvidence, R.uint32(18).fork()).ldelim(), R;
    },
    decode(C, R) {
      const p = C instanceof i.BinaryReader ? C : new i.BinaryReader(C);
      let m = R === void 0 ? p.len : p.pos + R;
      const v = S();
      for (; p.pos < m; ) {
        const a = p.uint32();
        switch (a >>> 3) {
          case 1:
            v.duplicateVoteEvidence = e.DuplicateVoteEvidence.decode(p, p.uint32());
            break;
          case 2:
            v.lightClientAttackEvidence = e.LightClientAttackEvidence.decode(p, p.uint32());
            break;
          default:
            p.skipType(a & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(C) {
      const R = S();
      return (0, f.isSet)(C.duplicateVoteEvidence) && (R.duplicateVoteEvidence = e.DuplicateVoteEvidence.fromJSON(C.duplicateVoteEvidence)), (0, f.isSet)(C.lightClientAttackEvidence) && (R.lightClientAttackEvidence = e.LightClientAttackEvidence.fromJSON(C.lightClientAttackEvidence)), R;
    },
    toJSON(C) {
      const R = {};
      return C.duplicateVoteEvidence !== void 0 && (R.duplicateVoteEvidence = C.duplicateVoteEvidence ? e.DuplicateVoteEvidence.toJSON(C.duplicateVoteEvidence) : void 0), C.lightClientAttackEvidence !== void 0 && (R.lightClientAttackEvidence = C.lightClientAttackEvidence ? e.LightClientAttackEvidence.toJSON(C.lightClientAttackEvidence) : void 0), R;
    },
    fromPartial(C) {
      const R = S();
      return C.duplicateVoteEvidence !== void 0 && C.duplicateVoteEvidence !== null && (R.duplicateVoteEvidence = e.DuplicateVoteEvidence.fromPartial(C.duplicateVoteEvidence)), C.lightClientAttackEvidence !== void 0 && C.lightClientAttackEvidence !== null && (R.lightClientAttackEvidence = e.LightClientAttackEvidence.fromPartial(C.lightClientAttackEvidence)), R;
    }
  };
  function w() {
    return {
      voteA: void 0,
      voteB: void 0,
      totalVotingPower: BigInt(0),
      validatorPower: BigInt(0),
      timestamp: r.Timestamp.fromPartial({})
    };
  }
  e.DuplicateVoteEvidence = {
    typeUrl: "/tendermint.types.DuplicateVoteEvidence",
    encode(C, R = i.BinaryWriter.create()) {
      return C.voteA !== void 0 && n.Vote.encode(C.voteA, R.uint32(10).fork()).ldelim(), C.voteB !== void 0 && n.Vote.encode(C.voteB, R.uint32(18).fork()).ldelim(), C.totalVotingPower !== BigInt(0) && R.uint32(24).int64(C.totalVotingPower), C.validatorPower !== BigInt(0) && R.uint32(32).int64(C.validatorPower), C.timestamp !== void 0 && r.Timestamp.encode(C.timestamp, R.uint32(42).fork()).ldelim(), R;
    },
    decode(C, R) {
      const p = C instanceof i.BinaryReader ? C : new i.BinaryReader(C);
      let m = R === void 0 ? p.len : p.pos + R;
      const v = w();
      for (; p.pos < m; ) {
        const a = p.uint32();
        switch (a >>> 3) {
          case 1:
            v.voteA = n.Vote.decode(p, p.uint32());
            break;
          case 2:
            v.voteB = n.Vote.decode(p, p.uint32());
            break;
          case 3:
            v.totalVotingPower = p.int64();
            break;
          case 4:
            v.validatorPower = p.int64();
            break;
          case 5:
            v.timestamp = r.Timestamp.decode(p, p.uint32());
            break;
          default:
            p.skipType(a & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(C) {
      const R = w();
      return (0, f.isSet)(C.voteA) && (R.voteA = n.Vote.fromJSON(C.voteA)), (0, f.isSet)(C.voteB) && (R.voteB = n.Vote.fromJSON(C.voteB)), (0, f.isSet)(C.totalVotingPower) && (R.totalVotingPower = BigInt(C.totalVotingPower.toString())), (0, f.isSet)(C.validatorPower) && (R.validatorPower = BigInt(C.validatorPower.toString())), (0, f.isSet)(C.timestamp) && (R.timestamp = (0, f.fromJsonTimestamp)(C.timestamp)), R;
    },
    toJSON(C) {
      const R = {};
      return C.voteA !== void 0 && (R.voteA = C.voteA ? n.Vote.toJSON(C.voteA) : void 0), C.voteB !== void 0 && (R.voteB = C.voteB ? n.Vote.toJSON(C.voteB) : void 0), C.totalVotingPower !== void 0 && (R.totalVotingPower = (C.totalVotingPower || BigInt(0)).toString()), C.validatorPower !== void 0 && (R.validatorPower = (C.validatorPower || BigInt(0)).toString()), C.timestamp !== void 0 && (R.timestamp = (0, f.fromTimestamp)(C.timestamp).toISOString()), R;
    },
    fromPartial(C) {
      const R = w();
      return C.voteA !== void 0 && C.voteA !== null && (R.voteA = n.Vote.fromPartial(C.voteA)), C.voteB !== void 0 && C.voteB !== null && (R.voteB = n.Vote.fromPartial(C.voteB)), C.totalVotingPower !== void 0 && C.totalVotingPower !== null && (R.totalVotingPower = BigInt(C.totalVotingPower.toString())), C.validatorPower !== void 0 && C.validatorPower !== null && (R.validatorPower = BigInt(C.validatorPower.toString())), C.timestamp !== void 0 && C.timestamp !== null && (R.timestamp = r.Timestamp.fromPartial(C.timestamp)), R;
    }
  };
  function T() {
    return {
      conflictingBlock: void 0,
      commonHeight: BigInt(0),
      byzantineValidators: [],
      totalVotingPower: BigInt(0),
      timestamp: r.Timestamp.fromPartial({})
    };
  }
  e.LightClientAttackEvidence = {
    typeUrl: "/tendermint.types.LightClientAttackEvidence",
    encode(C, R = i.BinaryWriter.create()) {
      C.conflictingBlock !== void 0 && n.LightBlock.encode(C.conflictingBlock, R.uint32(10).fork()).ldelim(), C.commonHeight !== BigInt(0) && R.uint32(16).int64(C.commonHeight);
      for (const p of C.byzantineValidators)
        t.Validator.encode(p, R.uint32(26).fork()).ldelim();
      return C.totalVotingPower !== BigInt(0) && R.uint32(32).int64(C.totalVotingPower), C.timestamp !== void 0 && r.Timestamp.encode(C.timestamp, R.uint32(42).fork()).ldelim(), R;
    },
    decode(C, R) {
      const p = C instanceof i.BinaryReader ? C : new i.BinaryReader(C);
      let m = R === void 0 ? p.len : p.pos + R;
      const v = T();
      for (; p.pos < m; ) {
        const a = p.uint32();
        switch (a >>> 3) {
          case 1:
            v.conflictingBlock = n.LightBlock.decode(p, p.uint32());
            break;
          case 2:
            v.commonHeight = p.int64();
            break;
          case 3:
            v.byzantineValidators.push(t.Validator.decode(p, p.uint32()));
            break;
          case 4:
            v.totalVotingPower = p.int64();
            break;
          case 5:
            v.timestamp = r.Timestamp.decode(p, p.uint32());
            break;
          default:
            p.skipType(a & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(C) {
      const R = T();
      return (0, f.isSet)(C.conflictingBlock) && (R.conflictingBlock = n.LightBlock.fromJSON(C.conflictingBlock)), (0, f.isSet)(C.commonHeight) && (R.commonHeight = BigInt(C.commonHeight.toString())), Array.isArray(C == null ? void 0 : C.byzantineValidators) && (R.byzantineValidators = C.byzantineValidators.map((p) => t.Validator.fromJSON(p))), (0, f.isSet)(C.totalVotingPower) && (R.totalVotingPower = BigInt(C.totalVotingPower.toString())), (0, f.isSet)(C.timestamp) && (R.timestamp = (0, f.fromJsonTimestamp)(C.timestamp)), R;
    },
    toJSON(C) {
      const R = {};
      return C.conflictingBlock !== void 0 && (R.conflictingBlock = C.conflictingBlock ? n.LightBlock.toJSON(C.conflictingBlock) : void 0), C.commonHeight !== void 0 && (R.commonHeight = (C.commonHeight || BigInt(0)).toString()), C.byzantineValidators ? R.byzantineValidators = C.byzantineValidators.map((p) => p ? t.Validator.toJSON(p) : void 0) : R.byzantineValidators = [], C.totalVotingPower !== void 0 && (R.totalVotingPower = (C.totalVotingPower || BigInt(0)).toString()), C.timestamp !== void 0 && (R.timestamp = (0, f.fromTimestamp)(C.timestamp).toISOString()), R;
    },
    fromPartial(C) {
      var p;
      const R = T();
      return C.conflictingBlock !== void 0 && C.conflictingBlock !== null && (R.conflictingBlock = n.LightBlock.fromPartial(C.conflictingBlock)), C.commonHeight !== void 0 && C.commonHeight !== null && (R.commonHeight = BigInt(C.commonHeight.toString())), R.byzantineValidators = ((p = C.byzantineValidators) == null ? void 0 : p.map((m) => t.Validator.fromPartial(m))) || [], C.totalVotingPower !== void 0 && C.totalVotingPower !== null && (R.totalVotingPower = BigInt(C.totalVotingPower.toString())), C.timestamp !== void 0 && C.timestamp !== null && (R.timestamp = r.Timestamp.fromPartial(C.timestamp)), R;
    }
  };
  function J() {
    return {
      evidence: []
    };
  }
  e.EvidenceList = {
    typeUrl: "/tendermint.types.EvidenceList",
    encode(C, R = i.BinaryWriter.create()) {
      for (const p of C.evidence)
        e.Evidence.encode(p, R.uint32(10).fork()).ldelim();
      return R;
    },
    decode(C, R) {
      const p = C instanceof i.BinaryReader ? C : new i.BinaryReader(C);
      let m = R === void 0 ? p.len : p.pos + R;
      const v = J();
      for (; p.pos < m; ) {
        const a = p.uint32();
        switch (a >>> 3) {
          case 1:
            v.evidence.push(e.Evidence.decode(p, p.uint32()));
            break;
          default:
            p.skipType(a & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(C) {
      const R = J();
      return Array.isArray(C == null ? void 0 : C.evidence) && (R.evidence = C.evidence.map((p) => e.Evidence.fromJSON(p))), R;
    },
    toJSON(C) {
      const R = {};
      return C.evidence ? R.evidence = C.evidence.map((p) => p ? e.Evidence.toJSON(p) : void 0) : R.evidence = [], R;
    },
    fromPartial(C) {
      var p;
      const R = J();
      return R.evidence = ((p = C.evidence) == null ? void 0 : p.map((m) => e.Evidence.fromPartial(m))) || [], R;
    }
  };
})(Zh);
Object.defineProperty(vi, "__esModule", { value: !0 });
vi.Block = vi.protobufPackage = void 0;
const Me = ar, vr = Zh, Tu = re, na = ie;
vi.protobufPackage = "tendermint.types";
function wu() {
  return {
    header: Me.Header.fromPartial({}),
    data: Me.Data.fromPartial({}),
    evidence: vr.EvidenceList.fromPartial({}),
    lastCommit: void 0
  };
}
vi.Block = {
  typeUrl: "/tendermint.types.Block",
  encode(e, n = Tu.BinaryWriter.create()) {
    return e.header !== void 0 && Me.Header.encode(e.header, n.uint32(10).fork()).ldelim(), e.data !== void 0 && Me.Data.encode(e.data, n.uint32(18).fork()).ldelim(), e.evidence !== void 0 && vr.EvidenceList.encode(e.evidence, n.uint32(26).fork()).ldelim(), e.lastCommit !== void 0 && Me.Commit.encode(e.lastCommit, n.uint32(34).fork()).ldelim(), n;
  },
  decode(e, n) {
    const r = e instanceof Tu.BinaryReader ? e : new Tu.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = wu();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.header = Me.Header.decode(r, r.uint32());
          break;
        case 2:
          i.data = Me.Data.decode(r, r.uint32());
          break;
        case 3:
          i.evidence = vr.EvidenceList.decode(r, r.uint32());
          break;
        case 4:
          i.lastCommit = Me.Commit.decode(r, r.uint32());
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = wu();
    return (0, na.isSet)(e.header) && (n.header = Me.Header.fromJSON(e.header)), (0, na.isSet)(e.data) && (n.data = Me.Data.fromJSON(e.data)), (0, na.isSet)(e.evidence) && (n.evidence = vr.EvidenceList.fromJSON(e.evidence)), (0, na.isSet)(e.lastCommit) && (n.lastCommit = Me.Commit.fromJSON(e.lastCommit)), n;
  },
  toJSON(e) {
    const n = {};
    return e.header !== void 0 && (n.header = e.header ? Me.Header.toJSON(e.header) : void 0), e.data !== void 0 && (n.data = e.data ? Me.Data.toJSON(e.data) : void 0), e.evidence !== void 0 && (n.evidence = e.evidence ? vr.EvidenceList.toJSON(e.evidence) : void 0), e.lastCommit !== void 0 && (n.lastCommit = e.lastCommit ? Me.Commit.toJSON(e.lastCommit) : void 0), n;
  },
  fromPartial(e) {
    const n = wu();
    return e.header !== void 0 && e.header !== null && (n.header = Me.Header.fromPartial(e.header)), e.data !== void 0 && e.data !== null && (n.data = Me.Data.fromPartial(e.data)), e.evidence !== void 0 && e.evidence !== null && (n.evidence = vr.EvidenceList.fromPartial(e.evidence)), e.lastCommit !== void 0 && e.lastCommit !== null && (n.lastCommit = Me.Commit.fromPartial(e.lastCommit)), n;
  }
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ServiceClientImpl = e.TxDecodeAminoResponse = e.TxDecodeAminoRequest = e.TxEncodeAminoResponse = e.TxEncodeAminoRequest = e.TxEncodeResponse = e.TxEncodeRequest = e.TxDecodeResponse = e.TxDecodeRequest = e.GetBlockWithTxsResponse = e.GetBlockWithTxsRequest = e.GetTxResponse = e.GetTxRequest = e.SimulateResponse = e.SimulateRequest = e.BroadcastTxResponse = e.BroadcastTxRequest = e.GetTxsEventResponse = e.GetTxsEventRequest = e.broadcastModeToJSON = e.broadcastModeFromJSON = e.BroadcastMode = e.orderByToJSON = e.orderByFromJSON = e.OrderBy = e.protobufPackage = void 0;
  const n = Qt, r = Ae, t = nl, i = ar, f = vi, S = re, w = ie;
  e.protobufPackage = "cosmos.tx.v1beta1";
  var T;
  (function(H) {
    H[H.ORDER_BY_UNSPECIFIED = 0] = "ORDER_BY_UNSPECIFIED", H[H.ORDER_BY_ASC = 1] = "ORDER_BY_ASC", H[H.ORDER_BY_DESC = 2] = "ORDER_BY_DESC", H[H.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(T || (e.OrderBy = T = {}));
  function J(H) {
    switch (H) {
      case 0:
      case "ORDER_BY_UNSPECIFIED":
        return T.ORDER_BY_UNSPECIFIED;
      case 1:
      case "ORDER_BY_ASC":
        return T.ORDER_BY_ASC;
      case 2:
      case "ORDER_BY_DESC":
        return T.ORDER_BY_DESC;
      case -1:
      case "UNRECOGNIZED":
      default:
        return T.UNRECOGNIZED;
    }
  }
  e.orderByFromJSON = J;
  function C(H) {
    switch (H) {
      case T.ORDER_BY_UNSPECIFIED:
        return "ORDER_BY_UNSPECIFIED";
      case T.ORDER_BY_ASC:
        return "ORDER_BY_ASC";
      case T.ORDER_BY_DESC:
        return "ORDER_BY_DESC";
      case T.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.orderByToJSON = C;
  var R;
  (function(H) {
    H[H.BROADCAST_MODE_UNSPECIFIED = 0] = "BROADCAST_MODE_UNSPECIFIED", H[H.BROADCAST_MODE_BLOCK = 1] = "BROADCAST_MODE_BLOCK", H[H.BROADCAST_MODE_SYNC = 2] = "BROADCAST_MODE_SYNC", H[H.BROADCAST_MODE_ASYNC = 3] = "BROADCAST_MODE_ASYNC", H[H.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(R || (e.BroadcastMode = R = {}));
  function p(H) {
    switch (H) {
      case 0:
      case "BROADCAST_MODE_UNSPECIFIED":
        return R.BROADCAST_MODE_UNSPECIFIED;
      case 1:
      case "BROADCAST_MODE_BLOCK":
        return R.BROADCAST_MODE_BLOCK;
      case 2:
      case "BROADCAST_MODE_SYNC":
        return R.BROADCAST_MODE_SYNC;
      case 3:
      case "BROADCAST_MODE_ASYNC":
        return R.BROADCAST_MODE_ASYNC;
      case -1:
      case "UNRECOGNIZED":
      default:
        return R.UNRECOGNIZED;
    }
  }
  e.broadcastModeFromJSON = p;
  function m(H) {
    switch (H) {
      case R.BROADCAST_MODE_UNSPECIFIED:
        return "BROADCAST_MODE_UNSPECIFIED";
      case R.BROADCAST_MODE_BLOCK:
        return "BROADCAST_MODE_BLOCK";
      case R.BROADCAST_MODE_SYNC:
        return "BROADCAST_MODE_SYNC";
      case R.BROADCAST_MODE_ASYNC:
        return "BROADCAST_MODE_ASYNC";
      case R.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.broadcastModeToJSON = m;
  function v() {
    return {
      events: [],
      pagination: void 0,
      orderBy: 0,
      page: BigInt(0),
      limit: BigInt(0)
    };
  }
  e.GetTxsEventRequest = {
    typeUrl: "/cosmos.tx.v1beta1.GetTxsEventRequest",
    encode(H, s = S.BinaryWriter.create()) {
      for (const k of H.events)
        s.uint32(10).string(k);
      return H.pagination !== void 0 && r.PageRequest.encode(H.pagination, s.uint32(18).fork()).ldelim(), H.orderBy !== 0 && s.uint32(24).int32(H.orderBy), H.page !== BigInt(0) && s.uint32(32).uint64(H.page), H.limit !== BigInt(0) && s.uint32(40).uint64(H.limit), s;
    },
    decode(H, s) {
      const k = H instanceof S.BinaryReader ? H : new S.BinaryReader(H);
      let g = s === void 0 ? k.len : k.pos + s;
      const P = v();
      for (; k.pos < g; ) {
        const A = k.uint32();
        switch (A >>> 3) {
          case 1:
            P.events.push(k.string());
            break;
          case 2:
            P.pagination = r.PageRequest.decode(k, k.uint32());
            break;
          case 3:
            P.orderBy = k.int32();
            break;
          case 4:
            P.page = k.uint64();
            break;
          case 5:
            P.limit = k.uint64();
            break;
          default:
            k.skipType(A & 7);
            break;
        }
      }
      return P;
    },
    fromJSON(H) {
      const s = v();
      return Array.isArray(H == null ? void 0 : H.events) && (s.events = H.events.map((k) => String(k))), (0, w.isSet)(H.pagination) && (s.pagination = r.PageRequest.fromJSON(H.pagination)), (0, w.isSet)(H.orderBy) && (s.orderBy = J(H.orderBy)), (0, w.isSet)(H.page) && (s.page = BigInt(H.page.toString())), (0, w.isSet)(H.limit) && (s.limit = BigInt(H.limit.toString())), s;
    },
    toJSON(H) {
      const s = {};
      return H.events ? s.events = H.events.map((k) => k) : s.events = [], H.pagination !== void 0 && (s.pagination = H.pagination ? r.PageRequest.toJSON(H.pagination) : void 0), H.orderBy !== void 0 && (s.orderBy = C(H.orderBy)), H.page !== void 0 && (s.page = (H.page || BigInt(0)).toString()), H.limit !== void 0 && (s.limit = (H.limit || BigInt(0)).toString()), s;
    },
    fromPartial(H) {
      var k;
      const s = v();
      return s.events = ((k = H.events) == null ? void 0 : k.map((g) => g)) || [], H.pagination !== void 0 && H.pagination !== null && (s.pagination = r.PageRequest.fromPartial(H.pagination)), s.orderBy = H.orderBy ?? 0, H.page !== void 0 && H.page !== null && (s.page = BigInt(H.page.toString())), H.limit !== void 0 && H.limit !== null && (s.limit = BigInt(H.limit.toString())), s;
    }
  };
  function a() {
    return {
      txs: [],
      txResponses: [],
      pagination: void 0,
      total: BigInt(0)
    };
  }
  e.GetTxsEventResponse = {
    typeUrl: "/cosmos.tx.v1beta1.GetTxsEventResponse",
    encode(H, s = S.BinaryWriter.create()) {
      for (const k of H.txs)
        n.Tx.encode(k, s.uint32(10).fork()).ldelim();
      for (const k of H.txResponses)
        t.TxResponse.encode(k, s.uint32(18).fork()).ldelim();
      return H.pagination !== void 0 && r.PageResponse.encode(H.pagination, s.uint32(26).fork()).ldelim(), H.total !== BigInt(0) && s.uint32(32).uint64(H.total), s;
    },
    decode(H, s) {
      const k = H instanceof S.BinaryReader ? H : new S.BinaryReader(H);
      let g = s === void 0 ? k.len : k.pos + s;
      const P = a();
      for (; k.pos < g; ) {
        const A = k.uint32();
        switch (A >>> 3) {
          case 1:
            P.txs.push(n.Tx.decode(k, k.uint32()));
            break;
          case 2:
            P.txResponses.push(t.TxResponse.decode(k, k.uint32()));
            break;
          case 3:
            P.pagination = r.PageResponse.decode(k, k.uint32());
            break;
          case 4:
            P.total = k.uint64();
            break;
          default:
            k.skipType(A & 7);
            break;
        }
      }
      return P;
    },
    fromJSON(H) {
      const s = a();
      return Array.isArray(H == null ? void 0 : H.txs) && (s.txs = H.txs.map((k) => n.Tx.fromJSON(k))), Array.isArray(H == null ? void 0 : H.txResponses) && (s.txResponses = H.txResponses.map((k) => t.TxResponse.fromJSON(k))), (0, w.isSet)(H.pagination) && (s.pagination = r.PageResponse.fromJSON(H.pagination)), (0, w.isSet)(H.total) && (s.total = BigInt(H.total.toString())), s;
    },
    toJSON(H) {
      const s = {};
      return H.txs ? s.txs = H.txs.map((k) => k ? n.Tx.toJSON(k) : void 0) : s.txs = [], H.txResponses ? s.txResponses = H.txResponses.map((k) => k ? t.TxResponse.toJSON(k) : void 0) : s.txResponses = [], H.pagination !== void 0 && (s.pagination = H.pagination ? r.PageResponse.toJSON(H.pagination) : void 0), H.total !== void 0 && (s.total = (H.total || BigInt(0)).toString()), s;
    },
    fromPartial(H) {
      var k, g;
      const s = a();
      return s.txs = ((k = H.txs) == null ? void 0 : k.map((P) => n.Tx.fromPartial(P))) || [], s.txResponses = ((g = H.txResponses) == null ? void 0 : g.map((P) => t.TxResponse.fromPartial(P))) || [], H.pagination !== void 0 && H.pagination !== null && (s.pagination = r.PageResponse.fromPartial(H.pagination)), H.total !== void 0 && H.total !== null && (s.total = BigInt(H.total.toString())), s;
    }
  };
  function d() {
    return {
      txBytes: new Uint8Array(),
      mode: 0
    };
  }
  e.BroadcastTxRequest = {
    typeUrl: "/cosmos.tx.v1beta1.BroadcastTxRequest",
    encode(H, s = S.BinaryWriter.create()) {
      return H.txBytes.length !== 0 && s.uint32(10).bytes(H.txBytes), H.mode !== 0 && s.uint32(16).int32(H.mode), s;
    },
    decode(H, s) {
      const k = H instanceof S.BinaryReader ? H : new S.BinaryReader(H);
      let g = s === void 0 ? k.len : k.pos + s;
      const P = d();
      for (; k.pos < g; ) {
        const A = k.uint32();
        switch (A >>> 3) {
          case 1:
            P.txBytes = k.bytes();
            break;
          case 2:
            P.mode = k.int32();
            break;
          default:
            k.skipType(A & 7);
            break;
        }
      }
      return P;
    },
    fromJSON(H) {
      const s = d();
      return (0, w.isSet)(H.txBytes) && (s.txBytes = (0, w.bytesFromBase64)(H.txBytes)), (0, w.isSet)(H.mode) && (s.mode = p(H.mode)), s;
    },
    toJSON(H) {
      const s = {};
      return H.txBytes !== void 0 && (s.txBytes = (0, w.base64FromBytes)(H.txBytes !== void 0 ? H.txBytes : new Uint8Array())), H.mode !== void 0 && (s.mode = m(H.mode)), s;
    },
    fromPartial(H) {
      const s = d();
      return s.txBytes = H.txBytes ?? new Uint8Array(), s.mode = H.mode ?? 0, s;
    }
  };
  function y() {
    return {
      txResponse: void 0
    };
  }
  e.BroadcastTxResponse = {
    typeUrl: "/cosmos.tx.v1beta1.BroadcastTxResponse",
    encode(H, s = S.BinaryWriter.create()) {
      return H.txResponse !== void 0 && t.TxResponse.encode(H.txResponse, s.uint32(10).fork()).ldelim(), s;
    },
    decode(H, s) {
      const k = H instanceof S.BinaryReader ? H : new S.BinaryReader(H);
      let g = s === void 0 ? k.len : k.pos + s;
      const P = y();
      for (; k.pos < g; ) {
        const A = k.uint32();
        switch (A >>> 3) {
          case 1:
            P.txResponse = t.TxResponse.decode(k, k.uint32());
            break;
          default:
            k.skipType(A & 7);
            break;
        }
      }
      return P;
    },
    fromJSON(H) {
      const s = y();
      return (0, w.isSet)(H.txResponse) && (s.txResponse = t.TxResponse.fromJSON(H.txResponse)), s;
    },
    toJSON(H) {
      const s = {};
      return H.txResponse !== void 0 && (s.txResponse = H.txResponse ? t.TxResponse.toJSON(H.txResponse) : void 0), s;
    },
    fromPartial(H) {
      const s = y();
      return H.txResponse !== void 0 && H.txResponse !== null && (s.txResponse = t.TxResponse.fromPartial(H.txResponse)), s;
    }
  };
  function _() {
    return {
      tx: void 0,
      txBytes: new Uint8Array()
    };
  }
  e.SimulateRequest = {
    typeUrl: "/cosmos.tx.v1beta1.SimulateRequest",
    encode(H, s = S.BinaryWriter.create()) {
      return H.tx !== void 0 && n.Tx.encode(H.tx, s.uint32(10).fork()).ldelim(), H.txBytes.length !== 0 && s.uint32(18).bytes(H.txBytes), s;
    },
    decode(H, s) {
      const k = H instanceof S.BinaryReader ? H : new S.BinaryReader(H);
      let g = s === void 0 ? k.len : k.pos + s;
      const P = _();
      for (; k.pos < g; ) {
        const A = k.uint32();
        switch (A >>> 3) {
          case 1:
            P.tx = n.Tx.decode(k, k.uint32());
            break;
          case 2:
            P.txBytes = k.bytes();
            break;
          default:
            k.skipType(A & 7);
            break;
        }
      }
      return P;
    },
    fromJSON(H) {
      const s = _();
      return (0, w.isSet)(H.tx) && (s.tx = n.Tx.fromJSON(H.tx)), (0, w.isSet)(H.txBytes) && (s.txBytes = (0, w.bytesFromBase64)(H.txBytes)), s;
    },
    toJSON(H) {
      const s = {};
      return H.tx !== void 0 && (s.tx = H.tx ? n.Tx.toJSON(H.tx) : void 0), H.txBytes !== void 0 && (s.txBytes = (0, w.base64FromBytes)(H.txBytes !== void 0 ? H.txBytes : new Uint8Array())), s;
    },
    fromPartial(H) {
      const s = _();
      return H.tx !== void 0 && H.tx !== null && (s.tx = n.Tx.fromPartial(H.tx)), s.txBytes = H.txBytes ?? new Uint8Array(), s;
    }
  };
  function E() {
    return {
      gasInfo: void 0,
      result: void 0
    };
  }
  e.SimulateResponse = {
    typeUrl: "/cosmos.tx.v1beta1.SimulateResponse",
    encode(H, s = S.BinaryWriter.create()) {
      return H.gasInfo !== void 0 && t.GasInfo.encode(H.gasInfo, s.uint32(10).fork()).ldelim(), H.result !== void 0 && t.Result.encode(H.result, s.uint32(18).fork()).ldelim(), s;
    },
    decode(H, s) {
      const k = H instanceof S.BinaryReader ? H : new S.BinaryReader(H);
      let g = s === void 0 ? k.len : k.pos + s;
      const P = E();
      for (; k.pos < g; ) {
        const A = k.uint32();
        switch (A >>> 3) {
          case 1:
            P.gasInfo = t.GasInfo.decode(k, k.uint32());
            break;
          case 2:
            P.result = t.Result.decode(k, k.uint32());
            break;
          default:
            k.skipType(A & 7);
            break;
        }
      }
      return P;
    },
    fromJSON(H) {
      const s = E();
      return (0, w.isSet)(H.gasInfo) && (s.gasInfo = t.GasInfo.fromJSON(H.gasInfo)), (0, w.isSet)(H.result) && (s.result = t.Result.fromJSON(H.result)), s;
    },
    toJSON(H) {
      const s = {};
      return H.gasInfo !== void 0 && (s.gasInfo = H.gasInfo ? t.GasInfo.toJSON(H.gasInfo) : void 0), H.result !== void 0 && (s.result = H.result ? t.Result.toJSON(H.result) : void 0), s;
    },
    fromPartial(H) {
      const s = E();
      return H.gasInfo !== void 0 && H.gasInfo !== null && (s.gasInfo = t.GasInfo.fromPartial(H.gasInfo)), H.result !== void 0 && H.result !== null && (s.result = t.Result.fromPartial(H.result)), s;
    }
  };
  function U() {
    return {
      hash: ""
    };
  }
  e.GetTxRequest = {
    typeUrl: "/cosmos.tx.v1beta1.GetTxRequest",
    encode(H, s = S.BinaryWriter.create()) {
      return H.hash !== "" && s.uint32(10).string(H.hash), s;
    },
    decode(H, s) {
      const k = H instanceof S.BinaryReader ? H : new S.BinaryReader(H);
      let g = s === void 0 ? k.len : k.pos + s;
      const P = U();
      for (; k.pos < g; ) {
        const A = k.uint32();
        switch (A >>> 3) {
          case 1:
            P.hash = k.string();
            break;
          default:
            k.skipType(A & 7);
            break;
        }
      }
      return P;
    },
    fromJSON(H) {
      const s = U();
      return (0, w.isSet)(H.hash) && (s.hash = String(H.hash)), s;
    },
    toJSON(H) {
      const s = {};
      return H.hash !== void 0 && (s.hash = H.hash), s;
    },
    fromPartial(H) {
      const s = U();
      return s.hash = H.hash ?? "", s;
    }
  };
  function V() {
    return {
      tx: void 0,
      txResponse: void 0
    };
  }
  e.GetTxResponse = {
    typeUrl: "/cosmos.tx.v1beta1.GetTxResponse",
    encode(H, s = S.BinaryWriter.create()) {
      return H.tx !== void 0 && n.Tx.encode(H.tx, s.uint32(10).fork()).ldelim(), H.txResponse !== void 0 && t.TxResponse.encode(H.txResponse, s.uint32(18).fork()).ldelim(), s;
    },
    decode(H, s) {
      const k = H instanceof S.BinaryReader ? H : new S.BinaryReader(H);
      let g = s === void 0 ? k.len : k.pos + s;
      const P = V();
      for (; k.pos < g; ) {
        const A = k.uint32();
        switch (A >>> 3) {
          case 1:
            P.tx = n.Tx.decode(k, k.uint32());
            break;
          case 2:
            P.txResponse = t.TxResponse.decode(k, k.uint32());
            break;
          default:
            k.skipType(A & 7);
            break;
        }
      }
      return P;
    },
    fromJSON(H) {
      const s = V();
      return (0, w.isSet)(H.tx) && (s.tx = n.Tx.fromJSON(H.tx)), (0, w.isSet)(H.txResponse) && (s.txResponse = t.TxResponse.fromJSON(H.txResponse)), s;
    },
    toJSON(H) {
      const s = {};
      return H.tx !== void 0 && (s.tx = H.tx ? n.Tx.toJSON(H.tx) : void 0), H.txResponse !== void 0 && (s.txResponse = H.txResponse ? t.TxResponse.toJSON(H.txResponse) : void 0), s;
    },
    fromPartial(H) {
      const s = V();
      return H.tx !== void 0 && H.tx !== null && (s.tx = n.Tx.fromPartial(H.tx)), H.txResponse !== void 0 && H.txResponse !== null && (s.txResponse = t.TxResponse.fromPartial(H.txResponse)), s;
    }
  };
  function o() {
    return {
      height: BigInt(0),
      pagination: void 0
    };
  }
  e.GetBlockWithTxsRequest = {
    typeUrl: "/cosmos.tx.v1beta1.GetBlockWithTxsRequest",
    encode(H, s = S.BinaryWriter.create()) {
      return H.height !== BigInt(0) && s.uint32(8).int64(H.height), H.pagination !== void 0 && r.PageRequest.encode(H.pagination, s.uint32(18).fork()).ldelim(), s;
    },
    decode(H, s) {
      const k = H instanceof S.BinaryReader ? H : new S.BinaryReader(H);
      let g = s === void 0 ? k.len : k.pos + s;
      const P = o();
      for (; k.pos < g; ) {
        const A = k.uint32();
        switch (A >>> 3) {
          case 1:
            P.height = k.int64();
            break;
          case 2:
            P.pagination = r.PageRequest.decode(k, k.uint32());
            break;
          default:
            k.skipType(A & 7);
            break;
        }
      }
      return P;
    },
    fromJSON(H) {
      const s = o();
      return (0, w.isSet)(H.height) && (s.height = BigInt(H.height.toString())), (0, w.isSet)(H.pagination) && (s.pagination = r.PageRequest.fromJSON(H.pagination)), s;
    },
    toJSON(H) {
      const s = {};
      return H.height !== void 0 && (s.height = (H.height || BigInt(0)).toString()), H.pagination !== void 0 && (s.pagination = H.pagination ? r.PageRequest.toJSON(H.pagination) : void 0), s;
    },
    fromPartial(H) {
      const s = o();
      return H.height !== void 0 && H.height !== null && (s.height = BigInt(H.height.toString())), H.pagination !== void 0 && H.pagination !== null && (s.pagination = r.PageRequest.fromPartial(H.pagination)), s;
    }
  };
  function h() {
    return {
      txs: [],
      blockId: void 0,
      block: void 0,
      pagination: void 0
    };
  }
  e.GetBlockWithTxsResponse = {
    typeUrl: "/cosmos.tx.v1beta1.GetBlockWithTxsResponse",
    encode(H, s = S.BinaryWriter.create()) {
      for (const k of H.txs)
        n.Tx.encode(k, s.uint32(10).fork()).ldelim();
      return H.blockId !== void 0 && i.BlockID.encode(H.blockId, s.uint32(18).fork()).ldelim(), H.block !== void 0 && f.Block.encode(H.block, s.uint32(26).fork()).ldelim(), H.pagination !== void 0 && r.PageResponse.encode(H.pagination, s.uint32(34).fork()).ldelim(), s;
    },
    decode(H, s) {
      const k = H instanceof S.BinaryReader ? H : new S.BinaryReader(H);
      let g = s === void 0 ? k.len : k.pos + s;
      const P = h();
      for (; k.pos < g; ) {
        const A = k.uint32();
        switch (A >>> 3) {
          case 1:
            P.txs.push(n.Tx.decode(k, k.uint32()));
            break;
          case 2:
            P.blockId = i.BlockID.decode(k, k.uint32());
            break;
          case 3:
            P.block = f.Block.decode(k, k.uint32());
            break;
          case 4:
            P.pagination = r.PageResponse.decode(k, k.uint32());
            break;
          default:
            k.skipType(A & 7);
            break;
        }
      }
      return P;
    },
    fromJSON(H) {
      const s = h();
      return Array.isArray(H == null ? void 0 : H.txs) && (s.txs = H.txs.map((k) => n.Tx.fromJSON(k))), (0, w.isSet)(H.blockId) && (s.blockId = i.BlockID.fromJSON(H.blockId)), (0, w.isSet)(H.block) && (s.block = f.Block.fromJSON(H.block)), (0, w.isSet)(H.pagination) && (s.pagination = r.PageResponse.fromJSON(H.pagination)), s;
    },
    toJSON(H) {
      const s = {};
      return H.txs ? s.txs = H.txs.map((k) => k ? n.Tx.toJSON(k) : void 0) : s.txs = [], H.blockId !== void 0 && (s.blockId = H.blockId ? i.BlockID.toJSON(H.blockId) : void 0), H.block !== void 0 && (s.block = H.block ? f.Block.toJSON(H.block) : void 0), H.pagination !== void 0 && (s.pagination = H.pagination ? r.PageResponse.toJSON(H.pagination) : void 0), s;
    },
    fromPartial(H) {
      var k;
      const s = h();
      return s.txs = ((k = H.txs) == null ? void 0 : k.map((g) => n.Tx.fromPartial(g))) || [], H.blockId !== void 0 && H.blockId !== null && (s.blockId = i.BlockID.fromPartial(H.blockId)), H.block !== void 0 && H.block !== null && (s.block = f.Block.fromPartial(H.block)), H.pagination !== void 0 && H.pagination !== null && (s.pagination = r.PageResponse.fromPartial(H.pagination)), s;
    }
  };
  function N() {
    return {
      txBytes: new Uint8Array()
    };
  }
  e.TxDecodeRequest = {
    typeUrl: "/cosmos.tx.v1beta1.TxDecodeRequest",
    encode(H, s = S.BinaryWriter.create()) {
      return H.txBytes.length !== 0 && s.uint32(10).bytes(H.txBytes), s;
    },
    decode(H, s) {
      const k = H instanceof S.BinaryReader ? H : new S.BinaryReader(H);
      let g = s === void 0 ? k.len : k.pos + s;
      const P = N();
      for (; k.pos < g; ) {
        const A = k.uint32();
        switch (A >>> 3) {
          case 1:
            P.txBytes = k.bytes();
            break;
          default:
            k.skipType(A & 7);
            break;
        }
      }
      return P;
    },
    fromJSON(H) {
      const s = N();
      return (0, w.isSet)(H.txBytes) && (s.txBytes = (0, w.bytesFromBase64)(H.txBytes)), s;
    },
    toJSON(H) {
      const s = {};
      return H.txBytes !== void 0 && (s.txBytes = (0, w.base64FromBytes)(H.txBytes !== void 0 ? H.txBytes : new Uint8Array())), s;
    },
    fromPartial(H) {
      const s = N();
      return s.txBytes = H.txBytes ?? new Uint8Array(), s;
    }
  };
  function q() {
    return {
      tx: void 0
    };
  }
  e.TxDecodeResponse = {
    typeUrl: "/cosmos.tx.v1beta1.TxDecodeResponse",
    encode(H, s = S.BinaryWriter.create()) {
      return H.tx !== void 0 && n.Tx.encode(H.tx, s.uint32(10).fork()).ldelim(), s;
    },
    decode(H, s) {
      const k = H instanceof S.BinaryReader ? H : new S.BinaryReader(H);
      let g = s === void 0 ? k.len : k.pos + s;
      const P = q();
      for (; k.pos < g; ) {
        const A = k.uint32();
        switch (A >>> 3) {
          case 1:
            P.tx = n.Tx.decode(k, k.uint32());
            break;
          default:
            k.skipType(A & 7);
            break;
        }
      }
      return P;
    },
    fromJSON(H) {
      const s = q();
      return (0, w.isSet)(H.tx) && (s.tx = n.Tx.fromJSON(H.tx)), s;
    },
    toJSON(H) {
      const s = {};
      return H.tx !== void 0 && (s.tx = H.tx ? n.Tx.toJSON(H.tx) : void 0), s;
    },
    fromPartial(H) {
      const s = q();
      return H.tx !== void 0 && H.tx !== null && (s.tx = n.Tx.fromPartial(H.tx)), s;
    }
  };
  function u() {
    return {
      tx: void 0
    };
  }
  e.TxEncodeRequest = {
    typeUrl: "/cosmos.tx.v1beta1.TxEncodeRequest",
    encode(H, s = S.BinaryWriter.create()) {
      return H.tx !== void 0 && n.Tx.encode(H.tx, s.uint32(10).fork()).ldelim(), s;
    },
    decode(H, s) {
      const k = H instanceof S.BinaryReader ? H : new S.BinaryReader(H);
      let g = s === void 0 ? k.len : k.pos + s;
      const P = u();
      for (; k.pos < g; ) {
        const A = k.uint32();
        switch (A >>> 3) {
          case 1:
            P.tx = n.Tx.decode(k, k.uint32());
            break;
          default:
            k.skipType(A & 7);
            break;
        }
      }
      return P;
    },
    fromJSON(H) {
      const s = u();
      return (0, w.isSet)(H.tx) && (s.tx = n.Tx.fromJSON(H.tx)), s;
    },
    toJSON(H) {
      const s = {};
      return H.tx !== void 0 && (s.tx = H.tx ? n.Tx.toJSON(H.tx) : void 0), s;
    },
    fromPartial(H) {
      const s = u();
      return H.tx !== void 0 && H.tx !== null && (s.tx = n.Tx.fromPartial(H.tx)), s;
    }
  };
  function l() {
    return {
      txBytes: new Uint8Array()
    };
  }
  e.TxEncodeResponse = {
    typeUrl: "/cosmos.tx.v1beta1.TxEncodeResponse",
    encode(H, s = S.BinaryWriter.create()) {
      return H.txBytes.length !== 0 && s.uint32(10).bytes(H.txBytes), s;
    },
    decode(H, s) {
      const k = H instanceof S.BinaryReader ? H : new S.BinaryReader(H);
      let g = s === void 0 ? k.len : k.pos + s;
      const P = l();
      for (; k.pos < g; ) {
        const A = k.uint32();
        switch (A >>> 3) {
          case 1:
            P.txBytes = k.bytes();
            break;
          default:
            k.skipType(A & 7);
            break;
        }
      }
      return P;
    },
    fromJSON(H) {
      const s = l();
      return (0, w.isSet)(H.txBytes) && (s.txBytes = (0, w.bytesFromBase64)(H.txBytes)), s;
    },
    toJSON(H) {
      const s = {};
      return H.txBytes !== void 0 && (s.txBytes = (0, w.base64FromBytes)(H.txBytes !== void 0 ? H.txBytes : new Uint8Array())), s;
    },
    fromPartial(H) {
      const s = l();
      return s.txBytes = H.txBytes ?? new Uint8Array(), s;
    }
  };
  function I() {
    return {
      aminoJson: ""
    };
  }
  e.TxEncodeAminoRequest = {
    typeUrl: "/cosmos.tx.v1beta1.TxEncodeAminoRequest",
    encode(H, s = S.BinaryWriter.create()) {
      return H.aminoJson !== "" && s.uint32(10).string(H.aminoJson), s;
    },
    decode(H, s) {
      const k = H instanceof S.BinaryReader ? H : new S.BinaryReader(H);
      let g = s === void 0 ? k.len : k.pos + s;
      const P = I();
      for (; k.pos < g; ) {
        const A = k.uint32();
        switch (A >>> 3) {
          case 1:
            P.aminoJson = k.string();
            break;
          default:
            k.skipType(A & 7);
            break;
        }
      }
      return P;
    },
    fromJSON(H) {
      const s = I();
      return (0, w.isSet)(H.aminoJson) && (s.aminoJson = String(H.aminoJson)), s;
    },
    toJSON(H) {
      const s = {};
      return H.aminoJson !== void 0 && (s.aminoJson = H.aminoJson), s;
    },
    fromPartial(H) {
      const s = I();
      return s.aminoJson = H.aminoJson ?? "", s;
    }
  };
  function B() {
    return {
      aminoBinary: new Uint8Array()
    };
  }
  e.TxEncodeAminoResponse = {
    typeUrl: "/cosmos.tx.v1beta1.TxEncodeAminoResponse",
    encode(H, s = S.BinaryWriter.create()) {
      return H.aminoBinary.length !== 0 && s.uint32(10).bytes(H.aminoBinary), s;
    },
    decode(H, s) {
      const k = H instanceof S.BinaryReader ? H : new S.BinaryReader(H);
      let g = s === void 0 ? k.len : k.pos + s;
      const P = B();
      for (; k.pos < g; ) {
        const A = k.uint32();
        switch (A >>> 3) {
          case 1:
            P.aminoBinary = k.bytes();
            break;
          default:
            k.skipType(A & 7);
            break;
        }
      }
      return P;
    },
    fromJSON(H) {
      const s = B();
      return (0, w.isSet)(H.aminoBinary) && (s.aminoBinary = (0, w.bytesFromBase64)(H.aminoBinary)), s;
    },
    toJSON(H) {
      const s = {};
      return H.aminoBinary !== void 0 && (s.aminoBinary = (0, w.base64FromBytes)(H.aminoBinary !== void 0 ? H.aminoBinary : new Uint8Array())), s;
    },
    fromPartial(H) {
      const s = B();
      return s.aminoBinary = H.aminoBinary ?? new Uint8Array(), s;
    }
  };
  function b() {
    return {
      aminoBinary: new Uint8Array()
    };
  }
  e.TxDecodeAminoRequest = {
    typeUrl: "/cosmos.tx.v1beta1.TxDecodeAminoRequest",
    encode(H, s = S.BinaryWriter.create()) {
      return H.aminoBinary.length !== 0 && s.uint32(10).bytes(H.aminoBinary), s;
    },
    decode(H, s) {
      const k = H instanceof S.BinaryReader ? H : new S.BinaryReader(H);
      let g = s === void 0 ? k.len : k.pos + s;
      const P = b();
      for (; k.pos < g; ) {
        const A = k.uint32();
        switch (A >>> 3) {
          case 1:
            P.aminoBinary = k.bytes();
            break;
          default:
            k.skipType(A & 7);
            break;
        }
      }
      return P;
    },
    fromJSON(H) {
      const s = b();
      return (0, w.isSet)(H.aminoBinary) && (s.aminoBinary = (0, w.bytesFromBase64)(H.aminoBinary)), s;
    },
    toJSON(H) {
      const s = {};
      return H.aminoBinary !== void 0 && (s.aminoBinary = (0, w.base64FromBytes)(H.aminoBinary !== void 0 ? H.aminoBinary : new Uint8Array())), s;
    },
    fromPartial(H) {
      const s = b();
      return s.aminoBinary = H.aminoBinary ?? new Uint8Array(), s;
    }
  };
  function D() {
    return {
      aminoJson: ""
    };
  }
  e.TxDecodeAminoResponse = {
    typeUrl: "/cosmos.tx.v1beta1.TxDecodeAminoResponse",
    encode(H, s = S.BinaryWriter.create()) {
      return H.aminoJson !== "" && s.uint32(10).string(H.aminoJson), s;
    },
    decode(H, s) {
      const k = H instanceof S.BinaryReader ? H : new S.BinaryReader(H);
      let g = s === void 0 ? k.len : k.pos + s;
      const P = D();
      for (; k.pos < g; ) {
        const A = k.uint32();
        switch (A >>> 3) {
          case 1:
            P.aminoJson = k.string();
            break;
          default:
            k.skipType(A & 7);
            break;
        }
      }
      return P;
    },
    fromJSON(H) {
      const s = D();
      return (0, w.isSet)(H.aminoJson) && (s.aminoJson = String(H.aminoJson)), s;
    },
    toJSON(H) {
      const s = {};
      return H.aminoJson !== void 0 && (s.aminoJson = H.aminoJson), s;
    },
    fromPartial(H) {
      const s = D();
      return s.aminoJson = H.aminoJson ?? "", s;
    }
  };
  class Q {
    constructor(s) {
      this.rpc = s, this.Simulate = this.Simulate.bind(this), this.GetTx = this.GetTx.bind(this), this.BroadcastTx = this.BroadcastTx.bind(this), this.GetTxsEvent = this.GetTxsEvent.bind(this), this.GetBlockWithTxs = this.GetBlockWithTxs.bind(this), this.TxDecode = this.TxDecode.bind(this), this.TxEncode = this.TxEncode.bind(this), this.TxEncodeAmino = this.TxEncodeAmino.bind(this), this.TxDecodeAmino = this.TxDecodeAmino.bind(this);
    }
    Simulate(s) {
      const k = e.SimulateRequest.encode(s).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "Simulate", k).then((P) => e.SimulateResponse.decode(new S.BinaryReader(P)));
    }
    GetTx(s) {
      const k = e.GetTxRequest.encode(s).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "GetTx", k).then((P) => e.GetTxResponse.decode(new S.BinaryReader(P)));
    }
    BroadcastTx(s) {
      const k = e.BroadcastTxRequest.encode(s).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "BroadcastTx", k).then((P) => e.BroadcastTxResponse.decode(new S.BinaryReader(P)));
    }
    GetTxsEvent(s) {
      const k = e.GetTxsEventRequest.encode(s).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "GetTxsEvent", k).then((P) => e.GetTxsEventResponse.decode(new S.BinaryReader(P)));
    }
    GetBlockWithTxs(s) {
      const k = e.GetBlockWithTxsRequest.encode(s).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "GetBlockWithTxs", k).then((P) => e.GetBlockWithTxsResponse.decode(new S.BinaryReader(P)));
    }
    TxDecode(s) {
      const k = e.TxDecodeRequest.encode(s).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "TxDecode", k).then((P) => e.TxDecodeResponse.decode(new S.BinaryReader(P)));
    }
    TxEncode(s) {
      const k = e.TxEncodeRequest.encode(s).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "TxEncode", k).then((P) => e.TxEncodeResponse.decode(new S.BinaryReader(P)));
    }
    TxEncodeAmino(s) {
      const k = e.TxEncodeAminoRequest.encode(s).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "TxEncodeAmino", k).then((P) => e.TxEncodeAminoResponse.decode(new S.BinaryReader(P)));
    }
    TxDecodeAmino(s) {
      const k = e.TxDecodeAminoRequest.encode(s).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "TxDecodeAmino", k).then((P) => e.TxDecodeAminoResponse.decode(new S.BinaryReader(P)));
    }
  }
  e.ServiceClientImpl = Q;
})(xh);
Object.defineProperty(Us, "__esModule", { value: !0 });
Us.setupTxExtension = void 0;
const oB = Ft, aB = Qa, Of = xh, ro = Qt, sB = Ye;
function dB(e) {
  const n = (0, sB.createProtobufRpcClient)(e), r = new Of.ServiceClientImpl(n);
  return {
    tx: {
      getTx: async (t) => {
        const i = {
          hash: t
        };
        return await r.GetTx(i);
      },
      simulate: async (t, i, f, S) => {
        const w = ro.Tx.fromPartial({
          authInfo: ro.AuthInfo.fromPartial({
            fee: ro.Fee.fromPartial({}),
            signerInfos: [
              {
                publicKey: (0, oB.encodePubkey)(f),
                sequence: BigInt(S),
                modeInfo: { single: { mode: aB.SignMode.SIGN_MODE_UNSPECIFIED } }
              }
            ]
          }),
          body: ro.TxBody.fromPartial({
            messages: Array.from(t),
            memo: i
          }),
          signatures: [new Uint8Array()]
        }), T = Of.SimulateRequest.fromPartial({
          txBytes: ro.Tx.encode(w).finish()
        });
        return await r.Simulate(T);
      }
    }
  };
}
Us.setupTxExtension = dB;
var bi = {};
Object.defineProperty(bi, "__esModule", { value: !0 });
bi.createVestingAminoConverters = bi.isAminoMsgCreateVestingAccount = void 0;
function uB(e) {
  return e.type === "cosmos-sdk/MsgCreateVestingAccount";
}
bi.isAminoMsgCreateVestingAccount = uB;
function cB() {
  return {
    "/cosmos.vesting.v1beta1.MsgCreateVestingAccount": {
      aminoType: "cosmos-sdk/MsgCreateVestingAccount",
      toAmino: ({ fromAddress: e, toAddress: n, amount: r, endTime: t, delayed: i }) => ({
        from_address: e,
        to_address: n,
        amount: [...r],
        end_time: t.toString(),
        delayed: i
      }),
      fromAmino: ({ from_address: e, to_address: n, amount: r, end_time: t, delayed: i }) => ({
        fromAddress: e,
        toAddress: n,
        amount: [...r],
        endTime: BigInt(t),
        delayed: i
      })
    }
  };
}
bi.createVestingAminoConverters = cB;
var Js = {}, Yh = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgCreatePeriodicVestingAccountResponse = e.MsgCreatePeriodicVestingAccount = e.MsgCreatePermanentLockedAccountResponse = e.MsgCreatePermanentLockedAccount = e.MsgCreateVestingAccountResponse = e.MsgCreateVestingAccount = e.protobufPackage = void 0;
  const n = De, r = Jc, t = re, i = ie;
  e.protobufPackage = "cosmos.vesting.v1beta1";
  function f() {
    return {
      fromAddress: "",
      toAddress: "",
      amount: [],
      endTime: BigInt(0),
      delayed: !1
    };
  }
  e.MsgCreateVestingAccount = {
    typeUrl: "/cosmos.vesting.v1beta1.MsgCreateVestingAccount",
    encode(p, m = t.BinaryWriter.create()) {
      p.fromAddress !== "" && m.uint32(10).string(p.fromAddress), p.toAddress !== "" && m.uint32(18).string(p.toAddress);
      for (const v of p.amount)
        n.Coin.encode(v, m.uint32(26).fork()).ldelim();
      return p.endTime !== BigInt(0) && m.uint32(32).int64(p.endTime), p.delayed === !0 && m.uint32(40).bool(p.delayed), m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = f();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.fromAddress = v.string();
            break;
          case 2:
            d.toAddress = v.string();
            break;
          case 3:
            d.amount.push(n.Coin.decode(v, v.uint32()));
            break;
          case 4:
            d.endTime = v.int64();
            break;
          case 5:
            d.delayed = v.bool();
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = f();
      return (0, i.isSet)(p.fromAddress) && (m.fromAddress = String(p.fromAddress)), (0, i.isSet)(p.toAddress) && (m.toAddress = String(p.toAddress)), Array.isArray(p == null ? void 0 : p.amount) && (m.amount = p.amount.map((v) => n.Coin.fromJSON(v))), (0, i.isSet)(p.endTime) && (m.endTime = BigInt(p.endTime.toString())), (0, i.isSet)(p.delayed) && (m.delayed = !!p.delayed), m;
    },
    toJSON(p) {
      const m = {};
      return p.fromAddress !== void 0 && (m.fromAddress = p.fromAddress), p.toAddress !== void 0 && (m.toAddress = p.toAddress), p.amount ? m.amount = p.amount.map((v) => v ? n.Coin.toJSON(v) : void 0) : m.amount = [], p.endTime !== void 0 && (m.endTime = (p.endTime || BigInt(0)).toString()), p.delayed !== void 0 && (m.delayed = p.delayed), m;
    },
    fromPartial(p) {
      var v;
      const m = f();
      return m.fromAddress = p.fromAddress ?? "", m.toAddress = p.toAddress ?? "", m.amount = ((v = p.amount) == null ? void 0 : v.map((a) => n.Coin.fromPartial(a))) || [], p.endTime !== void 0 && p.endTime !== null && (m.endTime = BigInt(p.endTime.toString())), m.delayed = p.delayed ?? !1, m;
    }
  };
  function S() {
    return {};
  }
  e.MsgCreateVestingAccountResponse = {
    typeUrl: "/cosmos.vesting.v1beta1.MsgCreateVestingAccountResponse",
    encode(p, m = t.BinaryWriter.create()) {
      return m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = S();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      return S();
    },
    toJSON(p) {
      return {};
    },
    fromPartial(p) {
      return S();
    }
  };
  function w() {
    return {
      fromAddress: "",
      toAddress: "",
      amount: []
    };
  }
  e.MsgCreatePermanentLockedAccount = {
    typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount",
    encode(p, m = t.BinaryWriter.create()) {
      p.fromAddress !== "" && m.uint32(10).string(p.fromAddress), p.toAddress !== "" && m.uint32(18).string(p.toAddress);
      for (const v of p.amount)
        n.Coin.encode(v, m.uint32(26).fork()).ldelim();
      return m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = w();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.fromAddress = v.string();
            break;
          case 2:
            d.toAddress = v.string();
            break;
          case 3:
            d.amount.push(n.Coin.decode(v, v.uint32()));
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = w();
      return (0, i.isSet)(p.fromAddress) && (m.fromAddress = String(p.fromAddress)), (0, i.isSet)(p.toAddress) && (m.toAddress = String(p.toAddress)), Array.isArray(p == null ? void 0 : p.amount) && (m.amount = p.amount.map((v) => n.Coin.fromJSON(v))), m;
    },
    toJSON(p) {
      const m = {};
      return p.fromAddress !== void 0 && (m.fromAddress = p.fromAddress), p.toAddress !== void 0 && (m.toAddress = p.toAddress), p.amount ? m.amount = p.amount.map((v) => v ? n.Coin.toJSON(v) : void 0) : m.amount = [], m;
    },
    fromPartial(p) {
      var v;
      const m = w();
      return m.fromAddress = p.fromAddress ?? "", m.toAddress = p.toAddress ?? "", m.amount = ((v = p.amount) == null ? void 0 : v.map((a) => n.Coin.fromPartial(a))) || [], m;
    }
  };
  function T() {
    return {};
  }
  e.MsgCreatePermanentLockedAccountResponse = {
    typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccountResponse",
    encode(p, m = t.BinaryWriter.create()) {
      return m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = T();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      return T();
    },
    toJSON(p) {
      return {};
    },
    fromPartial(p) {
      return T();
    }
  };
  function J() {
    return {
      fromAddress: "",
      toAddress: "",
      startTime: BigInt(0),
      vestingPeriods: []
    };
  }
  e.MsgCreatePeriodicVestingAccount = {
    typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount",
    encode(p, m = t.BinaryWriter.create()) {
      p.fromAddress !== "" && m.uint32(10).string(p.fromAddress), p.toAddress !== "" && m.uint32(18).string(p.toAddress), p.startTime !== BigInt(0) && m.uint32(24).int64(p.startTime);
      for (const v of p.vestingPeriods)
        r.Period.encode(v, m.uint32(34).fork()).ldelim();
      return m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = J();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          case 1:
            d.fromAddress = v.string();
            break;
          case 2:
            d.toAddress = v.string();
            break;
          case 3:
            d.startTime = v.int64();
            break;
          case 4:
            d.vestingPeriods.push(r.Period.decode(v, v.uint32()));
            break;
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      const m = J();
      return (0, i.isSet)(p.fromAddress) && (m.fromAddress = String(p.fromAddress)), (0, i.isSet)(p.toAddress) && (m.toAddress = String(p.toAddress)), (0, i.isSet)(p.startTime) && (m.startTime = BigInt(p.startTime.toString())), Array.isArray(p == null ? void 0 : p.vestingPeriods) && (m.vestingPeriods = p.vestingPeriods.map((v) => r.Period.fromJSON(v))), m;
    },
    toJSON(p) {
      const m = {};
      return p.fromAddress !== void 0 && (m.fromAddress = p.fromAddress), p.toAddress !== void 0 && (m.toAddress = p.toAddress), p.startTime !== void 0 && (m.startTime = (p.startTime || BigInt(0)).toString()), p.vestingPeriods ? m.vestingPeriods = p.vestingPeriods.map((v) => v ? r.Period.toJSON(v) : void 0) : m.vestingPeriods = [], m;
    },
    fromPartial(p) {
      var v;
      const m = J();
      return m.fromAddress = p.fromAddress ?? "", m.toAddress = p.toAddress ?? "", p.startTime !== void 0 && p.startTime !== null && (m.startTime = BigInt(p.startTime.toString())), m.vestingPeriods = ((v = p.vestingPeriods) == null ? void 0 : v.map((a) => r.Period.fromPartial(a))) || [], m;
    }
  };
  function C() {
    return {};
  }
  e.MsgCreatePeriodicVestingAccountResponse = {
    typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccountResponse",
    encode(p, m = t.BinaryWriter.create()) {
      return m;
    },
    decode(p, m) {
      const v = p instanceof t.BinaryReader ? p : new t.BinaryReader(p);
      let a = m === void 0 ? v.len : v.pos + m;
      const d = C();
      for (; v.pos < a; ) {
        const y = v.uint32();
        switch (y >>> 3) {
          default:
            v.skipType(y & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(p) {
      return C();
    },
    toJSON(p) {
      return {};
    },
    fromPartial(p) {
      return C();
    }
  };
  class R {
    constructor(m) {
      this.rpc = m, this.CreateVestingAccount = this.CreateVestingAccount.bind(this), this.CreatePermanentLockedAccount = this.CreatePermanentLockedAccount.bind(this), this.CreatePeriodicVestingAccount = this.CreatePeriodicVestingAccount.bind(this);
    }
    CreateVestingAccount(m) {
      const v = e.MsgCreateVestingAccount.encode(m).finish();
      return this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreateVestingAccount", v).then((d) => e.MsgCreateVestingAccountResponse.decode(new t.BinaryReader(d)));
    }
    CreatePermanentLockedAccount(m) {
      const v = e.MsgCreatePermanentLockedAccount.encode(m).finish();
      return this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreatePermanentLockedAccount", v).then((d) => e.MsgCreatePermanentLockedAccountResponse.decode(new t.BinaryReader(d)));
    }
    CreatePeriodicVestingAccount(m) {
      const v = e.MsgCreatePeriodicVestingAccount.encode(m).finish();
      return this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreatePeriodicVestingAccount", v).then((d) => e.MsgCreatePeriodicVestingAccountResponse.decode(new t.BinaryReader(d)));
    }
  }
  e.MsgClientImpl = R;
})(Yh);
Object.defineProperty(Js, "__esModule", { value: !0 });
Js.vestingTypes = void 0;
const lB = Yh;
Js.vestingTypes = [
  ["/cosmos.vesting.v1beta1.MsgCreateVestingAccount", lB.MsgCreateVestingAccount]
];
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.isAminoMsgCreateValidator = e.isAminoMsgBeginRedelegate = e.createStakingAminoConverters = e.setupSlashingExtension = e.isAminoMsgUnjail = e.createSlashingAminoConverters = e.setupMintExtension = e.setupIbcExtension = e.isMsgTransferEncodeObject = e.ibcTypes = e.isAminoMsgTransfer = e.createIbcAminoConverters = e.groupTypes = e.createGroupAminoConverters = e.setupGovExtension = e.isMsgVoteWeightedEncodeObject = e.isMsgVoteEncodeObject = e.isMsgSubmitProposalEncodeObject = e.isMsgDepositEncodeObject = e.govTypes = e.isAminoMsgVoteWeighted = e.isAminoMsgVote = e.isAminoMsgSubmitProposal = e.isAminoMsgDeposit = e.createGovAminoConverters = e.setupFeegrantExtension = e.feegrantTypes = e.createFeegrantAminoConverters = e.isAminoMsgSubmitEvidence = e.createEvidenceAminoConverters = e.setupDistributionExtension = e.isMsgWithdrawDelegatorRewardEncodeObject = e.distributionTypes = e.isAminoMsgWithdrawValidatorCommission = e.isAminoMsgWithdrawDelegatorReward = e.isAminoMsgSetWithdrawAddress = e.isAminoMsgFundCommunityPool = e.createDistributionAminoConverters = e.isAminoMsgVerifyInvariant = e.createCrysisAminoConverters = e.setupBankExtension = e.isMsgSendEncodeObject = e.bankTypes = e.isAminoMsgSend = e.isAminoMsgMultiSend = e.createBankAminoConverters = e.setupAuthzExtension = e.authzTypes = e.createAuthzAminoConverters = e.setupAuthExtension = void 0, e.vestingTypes = e.isAminoMsgCreateVestingAccount = e.createVestingAminoConverters = e.setupTxExtension = e.setupStakingExtension = e.stakingTypes = e.isMsgUndelegateEncodeObject = e.isMsgEditValidatorEncodeObject = e.isMsgDelegateEncodeObject = e.isMsgCreateValidatorEncodeObject = e.isMsgBeginRedelegateEncodeObject = e.isAminoMsgUndelegate = e.isAminoMsgEditValidator = e.isAminoMsgDelegate = void 0;
  var n = rs;
  Object.defineProperty(e, "setupAuthExtension", { enumerable: !0, get: function() {
    return n.setupAuthExtension;
  } });
  var r = ps;
  Object.defineProperty(e, "createAuthzAminoConverters", { enumerable: !0, get: function() {
    return r.createAuthzAminoConverters;
  } });
  var t = hs;
  Object.defineProperty(e, "authzTypes", { enumerable: !0, get: function() {
    return t.authzTypes;
  } });
  var i = ys;
  Object.defineProperty(e, "setupAuthzExtension", { enumerable: !0, get: function() {
    return i.setupAuthzExtension;
  } });
  var f = Nt;
  Object.defineProperty(e, "createBankAminoConverters", { enumerable: !0, get: function() {
    return f.createBankAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgMultiSend", { enumerable: !0, get: function() {
    return f.isAminoMsgMultiSend;
  } }), Object.defineProperty(e, "isAminoMsgSend", { enumerable: !0, get: function() {
    return f.isAminoMsgSend;
  } });
  var S = li;
  Object.defineProperty(e, "bankTypes", { enumerable: !0, get: function() {
    return S.bankTypes;
  } }), Object.defineProperty(e, "isMsgSendEncodeObject", { enumerable: !0, get: function() {
    return S.isMsgSendEncodeObject;
  } });
  var w = ms;
  Object.defineProperty(e, "setupBankExtension", { enumerable: !0, get: function() {
    return w.setupBankExtension;
  } });
  var T = fi;
  Object.defineProperty(e, "createCrysisAminoConverters", { enumerable: !0, get: function() {
    return T.createCrysisAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgVerifyInvariant", { enumerable: !0, get: function() {
    return T.isAminoMsgVerifyInvariant;
  } });
  var J = Tn;
  Object.defineProperty(e, "createDistributionAminoConverters", { enumerable: !0, get: function() {
    return J.createDistributionAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgFundCommunityPool", { enumerable: !0, get: function() {
    return J.isAminoMsgFundCommunityPool;
  } }), Object.defineProperty(e, "isAminoMsgSetWithdrawAddress", { enumerable: !0, get: function() {
    return J.isAminoMsgSetWithdrawAddress;
  } }), Object.defineProperty(e, "isAminoMsgWithdrawDelegatorReward", { enumerable: !0, get: function() {
    return J.isAminoMsgWithdrawDelegatorReward;
  } }), Object.defineProperty(e, "isAminoMsgWithdrawValidatorCommission", { enumerable: !0, get: function() {
    return J.isAminoMsgWithdrawValidatorCommission;
  } });
  var C = pi;
  Object.defineProperty(e, "distributionTypes", { enumerable: !0, get: function() {
    return C.distributionTypes;
  } }), Object.defineProperty(e, "isMsgWithdrawDelegatorRewardEncodeObject", { enumerable: !0, get: function() {
    return C.isMsgWithdrawDelegatorRewardEncodeObject;
  } });
  var R = gs;
  Object.defineProperty(e, "setupDistributionExtension", { enumerable: !0, get: function() {
    return R.setupDistributionExtension;
  } });
  var p = hi;
  Object.defineProperty(e, "createEvidenceAminoConverters", { enumerable: !0, get: function() {
    return p.createEvidenceAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgSubmitEvidence", { enumerable: !0, get: function() {
    return p.isAminoMsgSubmitEvidence;
  } });
  var m = Ss;
  Object.defineProperty(e, "createFeegrantAminoConverters", { enumerable: !0, get: function() {
    return m.createFeegrantAminoConverters;
  } });
  var v = ks;
  Object.defineProperty(e, "feegrantTypes", { enumerable: !0, get: function() {
    return v.feegrantTypes;
  } });
  var a = Ps;
  Object.defineProperty(e, "setupFeegrantExtension", { enumerable: !0, get: function() {
    return a.setupFeegrantExtension;
  } });
  var d = wn;
  Object.defineProperty(e, "createGovAminoConverters", { enumerable: !0, get: function() {
    return d.createGovAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgDeposit", { enumerable: !0, get: function() {
    return d.isAminoMsgDeposit;
  } }), Object.defineProperty(e, "isAminoMsgSubmitProposal", { enumerable: !0, get: function() {
    return d.isAminoMsgSubmitProposal;
  } }), Object.defineProperty(e, "isAminoMsgVote", { enumerable: !0, get: function() {
    return d.isAminoMsgVote;
  } }), Object.defineProperty(e, "isAminoMsgVoteWeighted", { enumerable: !0, get: function() {
    return d.isAminoMsgVoteWeighted;
  } });
  var y = Cn;
  Object.defineProperty(e, "govTypes", { enumerable: !0, get: function() {
    return y.govTypes;
  } }), Object.defineProperty(e, "isMsgDepositEncodeObject", { enumerable: !0, get: function() {
    return y.isMsgDepositEncodeObject;
  } }), Object.defineProperty(e, "isMsgSubmitProposalEncodeObject", { enumerable: !0, get: function() {
    return y.isMsgSubmitProposalEncodeObject;
  } }), Object.defineProperty(e, "isMsgVoteEncodeObject", { enumerable: !0, get: function() {
    return y.isMsgVoteEncodeObject;
  } }), Object.defineProperty(e, "isMsgVoteWeightedEncodeObject", { enumerable: !0, get: function() {
    return y.isMsgVoteWeightedEncodeObject;
  } });
  var _ = bs;
  Object.defineProperty(e, "setupGovExtension", { enumerable: !0, get: function() {
    return _.setupGovExtension;
  } });
  var E = Rs;
  Object.defineProperty(e, "createGroupAminoConverters", { enumerable: !0, get: function() {
    return E.createGroupAminoConverters;
  } });
  var U = Bs;
  Object.defineProperty(e, "groupTypes", { enumerable: !0, get: function() {
    return U.groupTypes;
  } });
  var V = yi;
  Object.defineProperty(e, "createIbcAminoConverters", { enumerable: !0, get: function() {
    return V.createIbcAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgTransfer", { enumerable: !0, get: function() {
    return V.isAminoMsgTransfer;
  } });
  var o = ki;
  Object.defineProperty(e, "ibcTypes", { enumerable: !0, get: function() {
    return o.ibcTypes;
  } }), Object.defineProperty(e, "isMsgTransferEncodeObject", { enumerable: !0, get: function() {
    return o.isMsgTransferEncodeObject;
  } });
  var h = ws;
  Object.defineProperty(e, "setupIbcExtension", { enumerable: !0, get: function() {
    return h.setupIbcExtension;
  } });
  var N = Ns;
  Object.defineProperty(e, "setupMintExtension", { enumerable: !0, get: function() {
    return N.setupMintExtension;
  } });
  var q = Pi;
  Object.defineProperty(e, "createSlashingAminoConverters", { enumerable: !0, get: function() {
    return q.createSlashingAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgUnjail", { enumerable: !0, get: function() {
    return q.isAminoMsgUnjail;
  } });
  var u = _s;
  Object.defineProperty(e, "setupSlashingExtension", { enumerable: !0, get: function() {
    return u.setupSlashingExtension;
  } });
  var l = $e;
  Object.defineProperty(e, "createStakingAminoConverters", { enumerable: !0, get: function() {
    return l.createStakingAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgBeginRedelegate", { enumerable: !0, get: function() {
    return l.isAminoMsgBeginRedelegate;
  } }), Object.defineProperty(e, "isAminoMsgCreateValidator", { enumerable: !0, get: function() {
    return l.isAminoMsgCreateValidator;
  } }), Object.defineProperty(e, "isAminoMsgDelegate", { enumerable: !0, get: function() {
    return l.isAminoMsgDelegate;
  } }), Object.defineProperty(e, "isAminoMsgEditValidator", { enumerable: !0, get: function() {
    return l.isAminoMsgEditValidator;
  } }), Object.defineProperty(e, "isAminoMsgUndelegate", { enumerable: !0, get: function() {
    return l.isAminoMsgUndelegate;
  } });
  var I = sn;
  Object.defineProperty(e, "isMsgBeginRedelegateEncodeObject", { enumerable: !0, get: function() {
    return I.isMsgBeginRedelegateEncodeObject;
  } }), Object.defineProperty(e, "isMsgCreateValidatorEncodeObject", { enumerable: !0, get: function() {
    return I.isMsgCreateValidatorEncodeObject;
  } }), Object.defineProperty(e, "isMsgDelegateEncodeObject", { enumerable: !0, get: function() {
    return I.isMsgDelegateEncodeObject;
  } }), Object.defineProperty(e, "isMsgEditValidatorEncodeObject", { enumerable: !0, get: function() {
    return I.isMsgEditValidatorEncodeObject;
  } }), Object.defineProperty(e, "isMsgUndelegateEncodeObject", { enumerable: !0, get: function() {
    return I.isMsgUndelegateEncodeObject;
  } }), Object.defineProperty(e, "stakingTypes", { enumerable: !0, get: function() {
    return I.stakingTypes;
  } });
  var B = Es;
  Object.defineProperty(e, "setupStakingExtension", { enumerable: !0, get: function() {
    return B.setupStakingExtension;
  } });
  var b = Us;
  Object.defineProperty(e, "setupTxExtension", { enumerable: !0, get: function() {
    return b.setupTxExtension;
  } });
  var D = bi;
  Object.defineProperty(e, "createVestingAminoConverters", { enumerable: !0, get: function() {
    return D.createVestingAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgCreateVestingAccount", { enumerable: !0, get: function() {
    return D.isAminoMsgCreateVestingAccount;
  } });
  var Q = Js;
  Object.defineProperty(e, "vestingTypes", { enumerable: !0, get: function() {
    return Q.vestingTypes;
  } });
})(ho);
var Dt = {};
Object.defineProperty(Dt, "__esModule", { value: !0 });
Dt.makeMultisignedTxBytes = Dt.makeMultisignedTx = Dt.makeCompactBitArray = void 0;
const fB = To, pB = Ke, hB = Ft, dc = _m, yB = Qa, Af = Qt, Xh = Qt;
function jh(e) {
  const n = Math.ceil(e.length / 8), r = e.length - Math.floor(e.length / 8) * 8, t = new Uint8Array(n);
  return e.forEach((i, f) => {
    const S = Math.floor(f / 8), w = f % 8;
    i && (t[S] |= 1 << 7 - w);
  }), dc.CompactBitArray.fromPartial({ elems: t, extraBitsStored: r });
}
Dt.makeCompactBitArray = jh;
function ey(e, n, r, t, i) {
  const f = Array.from(i.keys()), S = (0, pB.fromBech32)(f[0]).prefix, w = Array(e.value.pubkeys.length).fill(!1), T = new Array();
  for (let m = 0; m < e.value.pubkeys.length; m++) {
    const v = (0, fB.pubkeyToAddress)(e.value.pubkeys[m], S), a = i.get(v);
    a && (w[m] = !0, T.push(a));
  }
  const J = {
    publicKey: (0, hB.encodePubkey)(e),
    modeInfo: {
      multi: {
        bitarray: jh(w),
        modeInfos: T.map((m) => ({ single: { mode: yB.SignMode.SIGN_MODE_LEGACY_AMINO_JSON } }))
      }
    },
    sequence: BigInt(n)
  }, C = Af.AuthInfo.fromPartial({
    signerInfos: [J],
    fee: {
      amount: [...r.amount],
      gasLimit: BigInt(r.gas)
    }
  }), R = Af.AuthInfo.encode(C).finish();
  return Xh.TxRaw.fromPartial({
    bodyBytes: t,
    authInfoBytes: R,
    signatures: [dc.MultiSignature.encode(dc.MultiSignature.fromPartial({ signatures: T })).finish()]
  });
}
Dt.makeMultisignedTx = ey;
function mB(e, n, r, t, i) {
  const f = ey(e, n, r, t, i);
  return Uint8Array.from(Xh.TxRaw.encode(f).finish());
}
Dt.makeMultisignedTxBytes = mB;
var No = {};
Object.defineProperty(No, "__esModule", { value: !0 });
No.isSearchTxQueryArray = void 0;
function gB(e) {
  return Array.isArray(e);
}
No.isSearchTxQueryArray = gB;
var ny = {}, tl = {}, it = {}, Wn = {}, Ri = {};
Object.defineProperty(Ri, "__esModule", { value: !0 });
Ri.fromAscii = Ri.toAscii = void 0;
function SB(e) {
  const n = (r) => r.split("").map((t) => {
    const i = t.charCodeAt(0);
    if (i < 32 || i > 126)
      throw new Error("Cannot encode character that is out of printable ASCII range: " + i);
    return i;
  });
  return Uint8Array.from(n(e));
}
Ri.toAscii = SB;
function kB(e) {
  return ((r) => r.map((t) => {
    if (t < 32 || t > 126)
      throw new Error("Cannot decode character that is out of printable ASCII range: " + t);
    return String.fromCharCode(t);
  }))(Array.from(e)).join("");
}
Ri.fromAscii = kB;
var Bi = {}, PB = x && x.__createBinding || (Object.create ? function(e, n, r, t) {
  t === void 0 && (t = r);
  var i = Object.getOwnPropertyDescriptor(n, r);
  (!i || ("get" in i ? !n.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return n[r];
  } }), Object.defineProperty(e, t, i);
} : function(e, n, r, t) {
  t === void 0 && (t = r), e[t] = n[r];
}), vB = x && x.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), bB = x && x.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var n = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && PB(n, e, r);
  return vB(n, e), n;
};
Object.defineProperty(Bi, "__esModule", { value: !0 });
Bi.fromBase64 = Bi.toBase64 = void 0;
const ty = bB(Va);
function RB(e) {
  return ty.fromByteArray(e);
}
Bi.toBase64 = RB;
function BB(e) {
  if (!e.match(/^[a-zA-Z0-9+/]*={0,2}$/))
    throw new Error("Invalid base64 string format");
  return ty.toByteArray(e);
}
Bi.fromBase64 = BB;
var Mt = {}, OB = x && x.__createBinding || (Object.create ? function(e, n, r, t) {
  t === void 0 && (t = r);
  var i = Object.getOwnPropertyDescriptor(n, r);
  (!i || ("get" in i ? !n.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return n[r];
  } }), Object.defineProperty(e, t, i);
} : function(e, n, r, t) {
  t === void 0 && (t = r), e[t] = n[r];
}), AB = x && x.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), IB = x && x.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var n = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && OB(n, e, r);
  return AB(n, e), n;
};
Object.defineProperty(Mt, "__esModule", { value: !0 });
Mt.normalizeBech32 = Mt.fromBech32 = Mt.toBech32 = void 0;
const Ca = IB(Wa);
function ry(e, n, r) {
  return Ca.encode(e, Ca.toWords(n), r);
}
Mt.toBech32 = ry;
function iy(e, n = 1 / 0) {
  const r = Ca.decode(e, n);
  return {
    prefix: r.prefix,
    data: new Uint8Array(Ca.fromWords(r.words))
  };
}
Mt.fromBech32 = iy;
function TB(e) {
  const { prefix: n, data: r } = iy(e);
  return ry(n, r);
}
Mt.normalizeBech32 = TB;
var Oi = {};
Object.defineProperty(Oi, "__esModule", { value: !0 });
Oi.fromHex = Oi.toHex = void 0;
function wB(e) {
  let n = "";
  for (const r of e)
    n += ("0" + r.toString(16)).slice(-2);
  return n;
}
Oi.toHex = wB;
function CB(e) {
  if (e.length % 2 !== 0)
    throw new Error("hex string length must be a multiple of 2");
  const n = new Uint8Array(e.length / 2);
  for (let r = 0; r < n.length; r++) {
    const t = 2 * r, i = e.slice(t, t + 2);
    if (!i.match(/[0-9a-f]{2}/i))
      throw new Error("hex string contains invalid characters");
    n[r] = parseInt(i, 16);
  }
  return n;
}
Oi.fromHex = CB;
var Ai = {};
Object.defineProperty(Ai, "__esModule", { value: !0 });
Ai.toRfc3339 = Ai.fromRfc3339 = void 0;
const NB = /^(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(\.\d{1,9})?((?:[+-]\d{2}:\d{2})|Z)$/;
function mr(e, n = 2) {
  return e.toString().padStart(n, "0");
}
function _B(e) {
  const n = NB.exec(e);
  if (!n)
    throw new Error("Date string is not in RFC3339 format");
  const r = +n[1], t = +n[2], i = +n[3], f = +n[4], S = +n[5], w = +n[6], T = n[7] ? Math.floor(+n[7] * 1e3) : 0;
  let J, C, R;
  n[8] === "Z" ? (J = 1, C = 0, R = 0) : (J = n[8].substring(0, 1) === "-" ? -1 : 1, C = +n[8].substring(1, 3), R = +n[8].substring(4, 6));
  const p = J * (C * 60 + R) * 60, m = /* @__PURE__ */ new Date();
  return m.setUTCFullYear(r, t - 1, i), m.setUTCHours(f, S, w, T), new Date(m.getTime() - p * 1e3);
}
Ai.fromRfc3339 = _B;
function EB(e) {
  const n = e.getUTCFullYear(), r = mr(e.getUTCMonth() + 1), t = mr(e.getUTCDate()), i = mr(e.getUTCHours()), f = mr(e.getUTCMinutes()), S = mr(e.getUTCSeconds()), w = mr(e.getUTCMilliseconds(), 3);
  return `${n}-${r}-${t}T${i}:${f}:${S}.${w}Z`;
}
Ai.toRfc3339 = EB;
var Ii = {};
Object.defineProperty(Ii, "__esModule", { value: !0 });
Ii.fromUtf8 = Ii.toUtf8 = void 0;
function UB(e) {
  return new TextEncoder().encode(e);
}
Ii.toUtf8 = UB;
function JB(e, n = !1) {
  const r = !n;
  return new TextDecoder("utf-8", { fatal: r }).decode(e);
}
Ii.fromUtf8 = JB;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.toUtf8 = e.fromUtf8 = e.toRfc3339 = e.fromRfc3339 = e.toHex = e.fromHex = e.toBech32 = e.normalizeBech32 = e.fromBech32 = e.toBase64 = e.fromBase64 = e.toAscii = e.fromAscii = void 0;
  var n = Ri;
  Object.defineProperty(e, "fromAscii", { enumerable: !0, get: function() {
    return n.fromAscii;
  } }), Object.defineProperty(e, "toAscii", { enumerable: !0, get: function() {
    return n.toAscii;
  } });
  var r = Bi;
  Object.defineProperty(e, "fromBase64", { enumerable: !0, get: function() {
    return r.fromBase64;
  } }), Object.defineProperty(e, "toBase64", { enumerable: !0, get: function() {
    return r.toBase64;
  } });
  var t = Mt;
  Object.defineProperty(e, "fromBech32", { enumerable: !0, get: function() {
    return t.fromBech32;
  } }), Object.defineProperty(e, "normalizeBech32", { enumerable: !0, get: function() {
    return t.normalizeBech32;
  } }), Object.defineProperty(e, "toBech32", { enumerable: !0, get: function() {
    return t.toBech32;
  } });
  var i = Oi;
  Object.defineProperty(e, "fromHex", { enumerable: !0, get: function() {
    return i.fromHex;
  } }), Object.defineProperty(e, "toHex", { enumerable: !0, get: function() {
    return i.toHex;
  } });
  var f = Ai;
  Object.defineProperty(e, "fromRfc3339", { enumerable: !0, get: function() {
    return f.fromRfc3339;
  } }), Object.defineProperty(e, "toRfc3339", { enumerable: !0, get: function() {
    return f.toRfc3339;
  } });
  var S = Ii;
  Object.defineProperty(e, "fromUtf8", { enumerable: !0, get: function() {
    return S.fromUtf8;
  } }), Object.defineProperty(e, "toUtf8", { enumerable: !0, get: function() {
    return S.toUtf8;
  } });
})(Wn);
Object.defineProperty(it, "__esModule", { value: !0 });
it.pubkeyToAddress = it.pubkeyToRawAddress = it.rawSecp256k1PubkeyToRawAddress = it.rawEd25519PubkeyToRawAddress = void 0;
const uc = _e, DB = Wn;
function oy(e) {
  if (e.length !== 32)
    throw new Error(`Invalid Ed25519 pubkey length: ${e.length}`);
  return (0, uc.sha256)(e).slice(0, 20);
}
it.rawEd25519PubkeyToRawAddress = oy;
function ay(e) {
  if (e.length !== 33)
    throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${e.length}`);
  return (0, uc.ripemd160)((0, uc.sha256)(e));
}
it.rawSecp256k1PubkeyToRawAddress = ay;
function sy(e, n) {
  switch (e) {
    case "ed25519":
      return oy(n);
    case "secp256k1":
      return ay(n);
    default:
      throw new Error(`Pubkey type ${e} not supported`);
  }
}
it.pubkeyToRawAddress = sy;
function MB(e, n) {
  return (0, DB.toHex)(sy(e, n)).toUpperCase();
}
it.pubkeyToAddress = MB;
var Ze = {};
Object.defineProperty(Ze, "__esModule", { value: !0 });
Ze.DateTime = Ze.toSeconds = Ze.fromSeconds = Ze.toRfc3339WithNanoseconds = Ze.fromRfc3339WithNanoseconds = void 0;
const HB = Wn, qB = Ie;
function dy(e) {
  const n = (0, HB.fromRfc3339)(e), r = e.match(/\.(\d+)Z$/), t = r ? r[1].slice(3) : "";
  return n.nanoseconds = parseInt(t.padEnd(6, "0"), 10), n;
}
Ze.fromRfc3339WithNanoseconds = dy;
function uy(e) {
  var t;
  const n = e.toISOString(), r = ((t = e.nanoseconds) == null ? void 0 : t.toString()) ?? "";
  return `${n.slice(0, -1)}${r.padStart(6, "0")}Z`;
}
Ze.toRfc3339WithNanoseconds = uy;
function VB(e, n = 0) {
  const r = new qB.Uint32(n).toNumber();
  if (r > 999999999)
    throw new Error("Nano seconds must not exceed 999999999");
  const t = new Date(e * 1e3 + Math.floor(r / 1e6));
  return t.nanoseconds = r % 1e6, t;
}
Ze.fromSeconds = VB;
function WB(e) {
  return {
    seconds: Math.floor(e.getTime() / 1e3),
    nanos: e.getTime() % 1e3 * 1e6 + (e.nanoseconds ?? 0)
  };
}
Ze.toSeconds = WB;
class QB {
  /** @deprecated Use fromRfc3339WithNanoseconds instead */
  static decode(n) {
    return dy(n);
  }
  /** @deprecated Use toRfc3339WithNanoseconds instead */
  static encode(n) {
    return uy(n);
  }
}
Ze.DateTime = QB;
var Na = {}, Ds = {}, mt = {};
Object.defineProperty(mt, "__esModule", { value: !0 });
mt.createJsonRpcRequest = void 0;
const If = "123456789";
function FB() {
  return If[Math.floor(Math.random() * If.length)];
}
function $B() {
  return parseInt(Array.from({ length: 12 }).map(() => FB()).join(""), 10);
}
function LB(e, n) {
  const r = n ? { ...n } : {};
  return {
    jsonrpc: "2.0",
    id: $B(),
    method: e,
    params: r
  };
}
mt.createJsonRpcRequest = LB;
var _o = {}, Ms = {}, Hs = {}, qs = {};
Object.defineProperty(qs, "__esModule", { value: !0 });
qs.makeJsonRpcId = void 0;
let GB = 1e4;
function KB() {
  return GB += 1;
}
qs.makeJsonRpcId = KB;
var Vs = {}, ft = {};
Object.defineProperty(ft, "__esModule", { value: !0 });
ft.jsonRpcCode = ft.isJsonRpcSuccessResponse = ft.isJsonRpcErrorResponse = void 0;
function cy(e) {
  return typeof e.error == "object";
}
ft.isJsonRpcErrorResponse = cy;
function zB(e) {
  return !cy(e);
}
ft.isJsonRpcSuccessResponse = zB;
ft.jsonRpcCode = {
  parseError: -32700,
  invalidRequest: -32600,
  methodNotFound: -32601,
  invalidParams: -32602,
  internalError: -32603,
  // server error (Reserved for implementation-defined server-errors.):
  // -32000 to -32099
  serverError: {
    default: -32e3
  }
};
Object.defineProperty(Vs, "__esModule", { value: !0 });
Vs.JsonRpcClient = void 0;
const xB = Ao, ZB = ft;
class YB {
  constructor(n) {
    this.connection = n;
  }
  async run(n) {
    const r = this.connection.responseStream.filter((f) => f.id === n.id), t = (0, xB.firstEvent)(r);
    this.connection.sendRequest(n);
    const i = await t;
    if ((0, ZB.isJsonRpcErrorResponse)(i)) {
      const f = i.error;
      throw new Error(`JSON RPC error: code=${f.code}; message='${f.message}'`);
    }
    return i;
  }
}
Vs.JsonRpcClient = YB;
var Nn = {}, Ht = {};
Object.defineProperty(Ht, "__esModule", { value: !0 });
Ht.isJsonCompatibleDictionary = Ht.isJsonCompatibleArray = Ht.isJsonCompatibleValue = void 0;
function rl(e) {
  return !!(typeof e == "string" || typeof e == "number" || typeof e == "boolean" || e === null || // eslint-disable-next-line @typescript-eslint/no-use-before-define
  ly(e) || // eslint-disable-next-line @typescript-eslint/no-use-before-define
  fy(e));
}
Ht.isJsonCompatibleValue = rl;
function ly(e) {
  if (!Array.isArray(e))
    return !1;
  for (const n of e)
    if (!rl(n))
      return !1;
  return !0;
}
Ht.isJsonCompatibleArray = ly;
function fy(e) {
  return typeof e != "object" || e === null || Object.prototype.toString.call(e) !== "[object Object]" ? !1 : Object.values(e).every(rl);
}
Ht.isJsonCompatibleDictionary = fy;
Object.defineProperty(Nn, "__esModule", { value: !0 });
Nn.parseJsonRpcResponse = Nn.parseJsonRpcSuccessResponse = Nn.parseJsonRpcErrorResponse = Nn.parseJsonRpcRequest = Nn.parseJsonRpcId = void 0;
const qt = Ht;
function py(e) {
  if (!(0, qt.isJsonCompatibleDictionary)(e))
    throw new Error("Data must be JSON compatible dictionary");
  const n = e.id;
  return typeof n != "number" && typeof n != "string" ? null : n;
}
Nn.parseJsonRpcId = py;
function XB(e) {
  if (!(0, qt.isJsonCompatibleDictionary)(e))
    throw new Error("Data must be JSON compatible dictionary");
  if (e.jsonrpc !== "2.0")
    throw new Error(`Got unexpected jsonrpc version: ${e.jsonrpc}`);
  const n = py(e);
  if (n === null)
    throw new Error("Invalid id field");
  const r = e.method;
  if (typeof r != "string")
    throw new Error("Invalid method field");
  if (!(0, qt.isJsonCompatibleArray)(e.params) && !(0, qt.isJsonCompatibleDictionary)(e.params))
    throw new Error("Invalid params field");
  return {
    jsonrpc: "2.0",
    id: n,
    method: r,
    params: e.params
  };
}
Nn.parseJsonRpcRequest = XB;
function jB(e) {
  if (typeof e.code != "number")
    throw new Error("Error property 'code' is not a number");
  if (typeof e.message != "string")
    throw new Error("Error property 'message' is not a string");
  let n;
  if (e.data === void 0)
    n = void 0;
  else if ((0, qt.isJsonCompatibleValue)(e.data))
    n = e.data;
  else
    throw new Error("Error property 'data' is defined but not a JSON compatible value.");
  return {
    code: e.code,
    message: e.message,
    ...n !== void 0 ? { data: n } : {}
  };
}
function hy(e) {
  if (!(0, qt.isJsonCompatibleDictionary)(e))
    throw new Error("Data must be JSON compatible dictionary");
  if (e.jsonrpc !== "2.0")
    throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(e)}`);
  const n = e.id;
  if (typeof n != "number" && typeof n != "string" && n !== null)
    throw new Error("Invalid id field");
  if (typeof e.error > "u" || !(0, qt.isJsonCompatibleDictionary)(e.error))
    throw new Error("Invalid error field");
  return {
    jsonrpc: "2.0",
    id: n,
    error: jB(e.error)
  };
}
Nn.parseJsonRpcErrorResponse = hy;
function yy(e) {
  if (!(0, qt.isJsonCompatibleDictionary)(e))
    throw new Error("Data must be JSON compatible dictionary");
  if (e.jsonrpc !== "2.0")
    throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(e)}`);
  const n = e.id;
  if (typeof n != "number" && typeof n != "string")
    throw new Error("Invalid id field");
  if (typeof e.result > "u")
    throw new Error("Invalid result field");
  const r = e.result;
  return {
    jsonrpc: "2.0",
    id: n,
    result: r
  };
}
Nn.parseJsonRpcSuccessResponse = yy;
function eO(e) {
  let n;
  try {
    n = hy(e);
  } catch {
    n = yy(e);
  }
  return n;
}
Nn.parseJsonRpcResponse = eO;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.jsonRpcCode = e.isJsonRpcSuccessResponse = e.isJsonRpcErrorResponse = e.parseJsonRpcSuccessResponse = e.parseJsonRpcResponse = e.parseJsonRpcRequest = e.parseJsonRpcId = e.parseJsonRpcErrorResponse = e.JsonRpcClient = e.makeJsonRpcId = void 0;
  var n = qs;
  Object.defineProperty(e, "makeJsonRpcId", { enumerable: !0, get: function() {
    return n.makeJsonRpcId;
  } });
  var r = Vs;
  Object.defineProperty(e, "JsonRpcClient", { enumerable: !0, get: function() {
    return r.JsonRpcClient;
  } });
  var t = Nn;
  Object.defineProperty(e, "parseJsonRpcErrorResponse", { enumerable: !0, get: function() {
    return t.parseJsonRpcErrorResponse;
  } }), Object.defineProperty(e, "parseJsonRpcId", { enumerable: !0, get: function() {
    return t.parseJsonRpcId;
  } }), Object.defineProperty(e, "parseJsonRpcRequest", { enumerable: !0, get: function() {
    return t.parseJsonRpcRequest;
  } }), Object.defineProperty(e, "parseJsonRpcResponse", { enumerable: !0, get: function() {
    return t.parseJsonRpcResponse;
  } }), Object.defineProperty(e, "parseJsonRpcSuccessResponse", { enumerable: !0, get: function() {
    return t.parseJsonRpcSuccessResponse;
  } });
  var i = ft;
  Object.defineProperty(e, "isJsonRpcErrorResponse", { enumerable: !0, get: function() {
    return i.isJsonRpcErrorResponse;
  } }), Object.defineProperty(e, "isJsonRpcSuccessResponse", { enumerable: !0, get: function() {
    return i.isJsonRpcSuccessResponse;
  } }), Object.defineProperty(e, "jsonRpcCode", { enumerable: !0, get: function() {
    return i.jsonRpcCode;
  } });
})(Hs);
var Eo = {};
function my(e, n) {
  return function() {
    return e.apply(n, arguments);
  };
}
const { toString: nO } = Object.prototype, { getPrototypeOf: il } = Object, Ws = /* @__PURE__ */ ((e) => (n) => {
  const r = nO.call(n);
  return e[r] || (e[r] = r.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), dt = (e) => (e = e.toLowerCase(), (n) => Ws(n) === e), Qs = (e) => (n) => typeof n === e, { isArray: qi } = Array, yo = Qs("undefined");
function tO(e) {
  return e !== null && !yo(e) && e.constructor !== null && !yo(e.constructor) && Vn(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const gy = dt("ArrayBuffer");
function rO(e) {
  let n;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? n = ArrayBuffer.isView(e) : n = e && e.buffer && gy(e.buffer), n;
}
const iO = Qs("string"), Vn = Qs("function"), Sy = Qs("number"), Fs = (e) => e !== null && typeof e == "object", oO = (e) => e === !0 || e === !1, ya = (e) => {
  if (Ws(e) !== "object")
    return !1;
  const n = il(e);
  return (n === null || n === Object.prototype || Object.getPrototypeOf(n) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, aO = dt("Date"), sO = dt("File"), dO = dt("Blob"), uO = dt("FileList"), cO = (e) => Fs(e) && Vn(e.pipe), lO = (e) => {
  let n;
  return e && (typeof FormData == "function" && e instanceof FormData || Vn(e.append) && ((n = Ws(e)) === "formdata" || // detect form-data instance
  n === "object" && Vn(e.toString) && e.toString() === "[object FormData]"));
}, fO = dt("URLSearchParams"), pO = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Uo(e, n, { allOwnKeys: r = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let t, i;
  if (typeof e != "object" && (e = [e]), qi(e))
    for (t = 0, i = e.length; t < i; t++)
      n.call(null, e[t], t, e);
  else {
    const f = r ? Object.getOwnPropertyNames(e) : Object.keys(e), S = f.length;
    let w;
    for (t = 0; t < S; t++)
      w = f[t], n.call(null, e[w], w, e);
  }
}
function ky(e, n) {
  n = n.toLowerCase();
  const r = Object.keys(e);
  let t = r.length, i;
  for (; t-- > 0; )
    if (i = r[t], n === i.toLowerCase())
      return i;
  return null;
}
const Py = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : x, vy = (e) => !yo(e) && e !== Py;
function cc() {
  const { caseless: e } = vy(this) && this || {}, n = {}, r = (t, i) => {
    const f = e && ky(n, i) || i;
    ya(n[f]) && ya(t) ? n[f] = cc(n[f], t) : ya(t) ? n[f] = cc({}, t) : qi(t) ? n[f] = t.slice() : n[f] = t;
  };
  for (let t = 0, i = arguments.length; t < i; t++)
    arguments[t] && Uo(arguments[t], r);
  return n;
}
const hO = (e, n, r, { allOwnKeys: t } = {}) => (Uo(n, (i, f) => {
  r && Vn(i) ? e[f] = my(i, r) : e[f] = i;
}, { allOwnKeys: t }), e), yO = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), mO = (e, n, r, t) => {
  e.prototype = Object.create(n.prototype, t), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: n.prototype
  }), r && Object.assign(e.prototype, r);
}, gO = (e, n, r, t) => {
  let i, f, S;
  const w = {};
  if (n = n || {}, e == null) return n;
  do {
    for (i = Object.getOwnPropertyNames(e), f = i.length; f-- > 0; )
      S = i[f], (!t || t(S, e, n)) && !w[S] && (n[S] = e[S], w[S] = !0);
    e = r !== !1 && il(e);
  } while (e && (!r || r(e, n)) && e !== Object.prototype);
  return n;
}, SO = (e, n, r) => {
  e = String(e), (r === void 0 || r > e.length) && (r = e.length), r -= n.length;
  const t = e.indexOf(n, r);
  return t !== -1 && t === r;
}, kO = (e) => {
  if (!e) return null;
  if (qi(e)) return e;
  let n = e.length;
  if (!Sy(n)) return null;
  const r = new Array(n);
  for (; n-- > 0; )
    r[n] = e[n];
  return r;
}, PO = /* @__PURE__ */ ((e) => (n) => e && n instanceof e)(typeof Uint8Array < "u" && il(Uint8Array)), vO = (e, n) => {
  const t = (e && e[Symbol.iterator]).call(e);
  let i;
  for (; (i = t.next()) && !i.done; ) {
    const f = i.value;
    n.call(e, f[0], f[1]);
  }
}, bO = (e, n) => {
  let r;
  const t = [];
  for (; (r = e.exec(n)) !== null; )
    t.push(r);
  return t;
}, RO = dt("HTMLFormElement"), BO = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(r, t, i) {
    return t.toUpperCase() + i;
  }
), Tf = (({ hasOwnProperty: e }) => (n, r) => e.call(n, r))(Object.prototype), OO = dt("RegExp"), by = (e, n) => {
  const r = Object.getOwnPropertyDescriptors(e), t = {};
  Uo(r, (i, f) => {
    let S;
    (S = n(i, f, e)) !== !1 && (t[f] = S || i);
  }), Object.defineProperties(e, t);
}, AO = (e) => {
  by(e, (n, r) => {
    if (Vn(e) && ["arguments", "caller", "callee"].indexOf(r) !== -1)
      return !1;
    const t = e[r];
    if (Vn(t)) {
      if (n.enumerable = !1, "writable" in n) {
        n.writable = !1;
        return;
      }
      n.set || (n.set = () => {
        throw Error("Can not rewrite read-only method '" + r + "'");
      });
    }
  });
}, IO = (e, n) => {
  const r = {}, t = (i) => {
    i.forEach((f) => {
      r[f] = !0;
    });
  };
  return qi(e) ? t(e) : t(String(e).split(n)), r;
}, TO = () => {
}, wO = (e, n) => (e = +e, Number.isFinite(e) ? e : n), Cu = "abcdefghijklmnopqrstuvwxyz", wf = "0123456789", Ry = {
  DIGIT: wf,
  ALPHA: Cu,
  ALPHA_DIGIT: Cu + Cu.toUpperCase() + wf
}, CO = (e = 16, n = Ry.ALPHA_DIGIT) => {
  let r = "";
  const { length: t } = n;
  for (; e--; )
    r += n[Math.random() * t | 0];
  return r;
};
function NO(e) {
  return !!(e && Vn(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const _O = (e) => {
  const n = new Array(10), r = (t, i) => {
    if (Fs(t)) {
      if (n.indexOf(t) >= 0)
        return;
      if (!("toJSON" in t)) {
        n[i] = t;
        const f = qi(t) ? [] : {};
        return Uo(t, (S, w) => {
          const T = r(S, i + 1);
          !yo(T) && (f[w] = T);
        }), n[i] = void 0, f;
      }
    }
    return t;
  };
  return r(e, 0);
}, EO = dt("AsyncFunction"), UO = (e) => e && (Fs(e) || Vn(e)) && Vn(e.then) && Vn(e.catch);
var Z = {
  isArray: qi,
  isArrayBuffer: gy,
  isBuffer: tO,
  isFormData: lO,
  isArrayBufferView: rO,
  isString: iO,
  isNumber: Sy,
  isBoolean: oO,
  isObject: Fs,
  isPlainObject: ya,
  isUndefined: yo,
  isDate: aO,
  isFile: sO,
  isBlob: dO,
  isRegExp: OO,
  isFunction: Vn,
  isStream: cO,
  isURLSearchParams: fO,
  isTypedArray: PO,
  isFileList: uO,
  forEach: Uo,
  merge: cc,
  extend: hO,
  trim: pO,
  stripBOM: yO,
  inherits: mO,
  toFlatObject: gO,
  kindOf: Ws,
  kindOfTest: dt,
  endsWith: SO,
  toArray: kO,
  forEachEntry: vO,
  matchAll: bO,
  isHTMLForm: RO,
  hasOwnProperty: Tf,
  hasOwnProp: Tf,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: by,
  freezeMethods: AO,
  toObjectSet: IO,
  toCamelCase: BO,
  noop: TO,
  toFiniteNumber: wO,
  findKey: ky,
  global: Py,
  isContextDefined: vy,
  ALPHABET: Ry,
  generateString: CO,
  isSpecCompliantForm: NO,
  toJSONObject: _O,
  isAsyncFn: EO,
  isThenable: UO
};
function ke(e, n, r, t, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", n && (this.code = n), r && (this.config = r), t && (this.request = t), i && (this.response = i);
}
Z.inherits(ke, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: Z.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const By = ke.prototype, Oy = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  Oy[e] = { value: e };
});
Object.defineProperties(ke, Oy);
Object.defineProperty(By, "isAxiosError", { value: !0 });
ke.from = (e, n, r, t, i, f) => {
  const S = Object.create(By);
  return Z.toFlatObject(e, S, function(T) {
    return T !== Error.prototype;
  }, (w) => w !== "isAxiosError"), ke.call(S, e.message, n, r, t, i), S.cause = e, S.name = e.name, f && Object.assign(S, f), S;
};
var JO = null;
function lc(e) {
  return Z.isPlainObject(e) || Z.isArray(e);
}
function Ay(e) {
  return Z.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function Cf(e, n, r) {
  return e ? e.concat(n).map(function(i, f) {
    return i = Ay(i), !r && f ? "[" + i + "]" : i;
  }).join(r ? "." : "") : n;
}
function DO(e) {
  return Z.isArray(e) && !e.some(lc);
}
const MO = Z.toFlatObject(Z, {}, null, function(n) {
  return /^is[A-Z]/.test(n);
});
function $s(e, n, r) {
  if (!Z.isObject(e))
    throw new TypeError("target must be an object");
  n = n || new FormData(), r = Z.toFlatObject(r, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(a, d) {
    return !Z.isUndefined(d[a]);
  });
  const t = r.metaTokens, i = r.visitor || C, f = r.dots, S = r.indexes, T = (r.Blob || typeof Blob < "u" && Blob) && Z.isSpecCompliantForm(n);
  if (!Z.isFunction(i))
    throw new TypeError("visitor must be a function");
  function J(v) {
    if (v === null) return "";
    if (Z.isDate(v))
      return v.toISOString();
    if (!T && Z.isBlob(v))
      throw new ke("Blob is not supported. Use a Buffer instead.");
    return Z.isArrayBuffer(v) || Z.isTypedArray(v) ? T && typeof Blob == "function" ? new Blob([v]) : jt.from(v) : v;
  }
  function C(v, a, d) {
    let y = v;
    if (v && !d && typeof v == "object") {
      if (Z.endsWith(a, "{}"))
        a = t ? a : a.slice(0, -2), v = JSON.stringify(v);
      else if (Z.isArray(v) && DO(v) || (Z.isFileList(v) || Z.endsWith(a, "[]")) && (y = Z.toArray(v)))
        return a = Ay(a), y.forEach(function(E, U) {
          !(Z.isUndefined(E) || E === null) && n.append(
            // eslint-disable-next-line no-nested-ternary
            S === !0 ? Cf([a], U, f) : S === null ? a : a + "[]",
            J(E)
          );
        }), !1;
    }
    return lc(v) ? !0 : (n.append(Cf(d, a, f), J(v)), !1);
  }
  const R = [], p = Object.assign(MO, {
    defaultVisitor: C,
    convertValue: J,
    isVisitable: lc
  });
  function m(v, a) {
    if (!Z.isUndefined(v)) {
      if (R.indexOf(v) !== -1)
        throw Error("Circular reference detected in " + a.join("."));
      R.push(v), Z.forEach(v, function(y, _) {
        (!(Z.isUndefined(y) || y === null) && i.call(
          n,
          y,
          Z.isString(_) ? _.trim() : _,
          a,
          p
        )) === !0 && m(y, a ? a.concat(_) : [_]);
      }), R.pop();
    }
  }
  if (!Z.isObject(e))
    throw new TypeError("data must be an object");
  return m(e), n;
}
function Nf(e) {
  const n = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(t) {
    return n[t];
  });
}
function ol(e, n) {
  this._pairs = [], e && $s(e, this, n);
}
const Iy = ol.prototype;
Iy.append = function(n, r) {
  this._pairs.push([n, r]);
};
Iy.toString = function(n) {
  const r = n ? function(t) {
    return n.call(this, t, Nf);
  } : Nf;
  return this._pairs.map(function(i) {
    return r(i[0]) + "=" + r(i[1]);
  }, "").join("&");
};
function HO(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function Ty(e, n, r) {
  if (!n)
    return e;
  const t = r && r.encode || HO, i = r && r.serialize;
  let f;
  if (i ? f = i(n, r) : f = Z.isURLSearchParams(n) ? n.toString() : new ol(n, r).toString(t), f) {
    const S = e.indexOf("#");
    S !== -1 && (e = e.slice(0, S)), e += (e.indexOf("?") === -1 ? "?" : "&") + f;
  }
  return e;
}
class qO {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(n, r, t) {
    return this.handlers.push({
      fulfilled: n,
      rejected: r,
      synchronous: t ? t.synchronous : !1,
      runWhen: t ? t.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(n) {
    this.handlers[n] && (this.handlers[n] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(n) {
    Z.forEach(this.handlers, function(t) {
      t !== null && n(t);
    });
  }
}
var _f = qO, wy = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, VO = typeof URLSearchParams < "u" ? URLSearchParams : ol, WO = typeof FormData < "u" ? FormData : null, QO = typeof Blob < "u" ? Blob : null, FO = {
  isBrowser: !0,
  classes: {
    URLSearchParams: VO,
    FormData: WO,
    Blob: QO
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
const Cy = typeof window < "u" && typeof document < "u", $O = ((e) => Cy && ["ReactNative", "NativeScript", "NS"].indexOf(e) < 0)(typeof navigator < "u" && navigator.product), LO = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function";
var GO = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  hasBrowserEnv: Cy,
  hasStandardBrowserWebWorkerEnv: LO,
  hasStandardBrowserEnv: $O
}), ot = {
  ...GO,
  ...FO
};
function KO(e, n) {
  return $s(e, new ot.classes.URLSearchParams(), Object.assign({
    visitor: function(r, t, i, f) {
      return ot.isNode && Z.isBuffer(r) ? (this.append(t, r.toString("base64")), !1) : f.defaultVisitor.apply(this, arguments);
    }
  }, n));
}
function zO(e) {
  return Z.matchAll(/\w+|\[(\w*)]/g, e).map((n) => n[0] === "[]" ? "" : n[1] || n[0]);
}
function xO(e) {
  const n = {}, r = Object.keys(e);
  let t;
  const i = r.length;
  let f;
  for (t = 0; t < i; t++)
    f = r[t], n[f] = e[f];
  return n;
}
function Ny(e) {
  function n(r, t, i, f) {
    let S = r[f++];
    if (S === "__proto__") return !0;
    const w = Number.isFinite(+S), T = f >= r.length;
    return S = !S && Z.isArray(i) ? i.length : S, T ? (Z.hasOwnProp(i, S) ? i[S] = [i[S], t] : i[S] = t, !w) : ((!i[S] || !Z.isObject(i[S])) && (i[S] = []), n(r, t, i[S], f) && Z.isArray(i[S]) && (i[S] = xO(i[S])), !w);
  }
  if (Z.isFormData(e) && Z.isFunction(e.entries)) {
    const r = {};
    return Z.forEachEntry(e, (t, i) => {
      n(zO(t), i, r, 0);
    }), r;
  }
  return null;
}
function ZO(e, n, r) {
  if (Z.isString(e))
    try {
      return (n || JSON.parse)(e), Z.trim(e);
    } catch (t) {
      if (t.name !== "SyntaxError")
        throw t;
    }
  return (0, JSON.stringify)(e);
}
const al = {
  transitional: wy,
  adapter: ["xhr", "http"],
  transformRequest: [function(n, r) {
    const t = r.getContentType() || "", i = t.indexOf("application/json") > -1, f = Z.isObject(n);
    if (f && Z.isHTMLForm(n) && (n = new FormData(n)), Z.isFormData(n))
      return i ? JSON.stringify(Ny(n)) : n;
    if (Z.isArrayBuffer(n) || Z.isBuffer(n) || Z.isStream(n) || Z.isFile(n) || Z.isBlob(n))
      return n;
    if (Z.isArrayBufferView(n))
      return n.buffer;
    if (Z.isURLSearchParams(n))
      return r.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), n.toString();
    let w;
    if (f) {
      if (t.indexOf("application/x-www-form-urlencoded") > -1)
        return KO(n, this.formSerializer).toString();
      if ((w = Z.isFileList(n)) || t.indexOf("multipart/form-data") > -1) {
        const T = this.env && this.env.FormData;
        return $s(
          w ? { "files[]": n } : n,
          T && new T(),
          this.formSerializer
        );
      }
    }
    return f || i ? (r.setContentType("application/json", !1), ZO(n)) : n;
  }],
  transformResponse: [function(n) {
    const r = this.transitional || al.transitional, t = r && r.forcedJSONParsing, i = this.responseType === "json";
    if (n && Z.isString(n) && (t && !this.responseType || i)) {
      const S = !(r && r.silentJSONParsing) && i;
      try {
        return JSON.parse(n);
      } catch (w) {
        if (S)
          throw w.name === "SyntaxError" ? ke.from(w, ke.ERR_BAD_RESPONSE, this, null, this.response) : w;
      }
    }
    return n;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: ot.classes.FormData,
    Blob: ot.classes.Blob
  },
  validateStatus: function(n) {
    return n >= 200 && n < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
Z.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  al.headers[e] = {};
});
var sl = al;
const YO = Z.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var XO = (e) => {
  const n = {};
  let r, t, i;
  return e && e.split(`
`).forEach(function(S) {
    i = S.indexOf(":"), r = S.substring(0, i).trim().toLowerCase(), t = S.substring(i + 1).trim(), !(!r || n[r] && YO[r]) && (r === "set-cookie" ? n[r] ? n[r].push(t) : n[r] = [t] : n[r] = n[r] ? n[r] + ", " + t : t);
  }), n;
};
const Ef = Symbol("internals");
function io(e) {
  return e && String(e).trim().toLowerCase();
}
function ma(e) {
  return e === !1 || e == null ? e : Z.isArray(e) ? e.map(ma) : String(e);
}
function jO(e) {
  const n = /* @__PURE__ */ Object.create(null), r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let t;
  for (; t = r.exec(e); )
    n[t[1]] = t[2];
  return n;
}
const e0 = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function Nu(e, n, r, t, i) {
  if (Z.isFunction(t))
    return t.call(this, n, r);
  if (i && (n = r), !!Z.isString(n)) {
    if (Z.isString(t))
      return n.indexOf(t) !== -1;
    if (Z.isRegExp(t))
      return t.test(n);
  }
}
function n0(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (n, r, t) => r.toUpperCase() + t);
}
function t0(e, n) {
  const r = Z.toCamelCase(" " + n);
  ["get", "set", "has"].forEach((t) => {
    Object.defineProperty(e, t + r, {
      value: function(i, f, S) {
        return this[t].call(this, n, i, f, S);
      },
      configurable: !0
    });
  });
}
class Ls {
  constructor(n) {
    n && this.set(n);
  }
  set(n, r, t) {
    const i = this;
    function f(w, T, J) {
      const C = io(T);
      if (!C)
        throw new Error("header name must be a non-empty string");
      const R = Z.findKey(i, C);
      (!R || i[R] === void 0 || J === !0 || J === void 0 && i[R] !== !1) && (i[R || T] = ma(w));
    }
    const S = (w, T) => Z.forEach(w, (J, C) => f(J, C, T));
    return Z.isPlainObject(n) || n instanceof this.constructor ? S(n, r) : Z.isString(n) && (n = n.trim()) && !e0(n) ? S(XO(n), r) : n != null && f(r, n, t), this;
  }
  get(n, r) {
    if (n = io(n), n) {
      const t = Z.findKey(this, n);
      if (t) {
        const i = this[t];
        if (!r)
          return i;
        if (r === !0)
          return jO(i);
        if (Z.isFunction(r))
          return r.call(this, i, t);
        if (Z.isRegExp(r))
          return r.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(n, r) {
    if (n = io(n), n) {
      const t = Z.findKey(this, n);
      return !!(t && this[t] !== void 0 && (!r || Nu(this, this[t], t, r)));
    }
    return !1;
  }
  delete(n, r) {
    const t = this;
    let i = !1;
    function f(S) {
      if (S = io(S), S) {
        const w = Z.findKey(t, S);
        w && (!r || Nu(t, t[w], w, r)) && (delete t[w], i = !0);
      }
    }
    return Z.isArray(n) ? n.forEach(f) : f(n), i;
  }
  clear(n) {
    const r = Object.keys(this);
    let t = r.length, i = !1;
    for (; t--; ) {
      const f = r[t];
      (!n || Nu(this, this[f], f, n, !0)) && (delete this[f], i = !0);
    }
    return i;
  }
  normalize(n) {
    const r = this, t = {};
    return Z.forEach(this, (i, f) => {
      const S = Z.findKey(t, f);
      if (S) {
        r[S] = ma(i), delete r[f];
        return;
      }
      const w = n ? n0(f) : String(f).trim();
      w !== f && delete r[f], r[w] = ma(i), t[w] = !0;
    }), this;
  }
  concat(...n) {
    return this.constructor.concat(this, ...n);
  }
  toJSON(n) {
    const r = /* @__PURE__ */ Object.create(null);
    return Z.forEach(this, (t, i) => {
      t != null && t !== !1 && (r[i] = n && Z.isArray(t) ? t.join(", ") : t);
    }), r;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([n, r]) => n + ": " + r).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(n) {
    return n instanceof this ? n : new this(n);
  }
  static concat(n, ...r) {
    const t = new this(n);
    return r.forEach((i) => t.set(i)), t;
  }
  static accessor(n) {
    const t = (this[Ef] = this[Ef] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function f(S) {
      const w = io(S);
      t[w] || (t0(i, S), t[w] = !0);
    }
    return Z.isArray(n) ? n.forEach(f) : f(n), this;
  }
}
Ls.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
Z.reduceDescriptors(Ls.prototype, ({ value: e }, n) => {
  let r = n[0].toUpperCase() + n.slice(1);
  return {
    get: () => e,
    set(t) {
      this[r] = t;
    }
  };
});
Z.freezeMethods(Ls);
var pt = Ls;
function _u(e, n) {
  const r = this || sl, t = n || r, i = pt.from(t.headers);
  let f = t.data;
  return Z.forEach(e, function(w) {
    f = w.call(r, f, i.normalize(), n ? n.status : void 0);
  }), i.normalize(), f;
}
function _y(e) {
  return !!(e && e.__CANCEL__);
}
function Jo(e, n, r) {
  ke.call(this, e ?? "canceled", ke.ERR_CANCELED, n, r), this.name = "CanceledError";
}
Z.inherits(Jo, ke, {
  __CANCEL__: !0
});
function r0(e, n, r) {
  const t = r.config.validateStatus;
  !r.status || !t || t(r.status) ? e(r) : n(new ke(
    "Request failed with status code " + r.status,
    [ke.ERR_BAD_REQUEST, ke.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4],
    r.config,
    r.request,
    r
  ));
}
var i0 = ot.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, n, r, t, i, f) {
      const S = [e + "=" + encodeURIComponent(n)];
      Z.isNumber(r) && S.push("expires=" + new Date(r).toGMTString()), Z.isString(t) && S.push("path=" + t), Z.isString(i) && S.push("domain=" + i), f === !0 && S.push("secure"), document.cookie = S.join("; ");
    },
    read(e) {
      const n = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return n ? decodeURIComponent(n[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function o0(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function a0(e, n) {
  return n ? e.replace(/\/?\/$/, "") + "/" + n.replace(/^\/+/, "") : e;
}
function Ey(e, n) {
  return e && !o0(n) ? a0(e, n) : n;
}
var s0 = ot.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const n = /(msie|trident)/i.test(navigator.userAgent), r = document.createElement("a");
    let t;
    function i(f) {
      let S = f;
      return n && (r.setAttribute("href", S), S = r.href), r.setAttribute("href", S), {
        href: r.href,
        protocol: r.protocol ? r.protocol.replace(/:$/, "") : "",
        host: r.host,
        search: r.search ? r.search.replace(/^\?/, "") : "",
        hash: r.hash ? r.hash.replace(/^#/, "") : "",
        hostname: r.hostname,
        port: r.port,
        pathname: r.pathname.charAt(0) === "/" ? r.pathname : "/" + r.pathname
      };
    }
    return t = i(window.location.href), function(S) {
      const w = Z.isString(S) ? i(S) : S;
      return w.protocol === t.protocol && w.host === t.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function() {
    return function() {
      return !0;
    };
  }()
);
function d0(e) {
  const n = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return n && n[1] || "";
}
function u0(e, n) {
  e = e || 10;
  const r = new Array(e), t = new Array(e);
  let i = 0, f = 0, S;
  return n = n !== void 0 ? n : 1e3, function(T) {
    const J = Date.now(), C = t[f];
    S || (S = J), r[i] = T, t[i] = J;
    let R = f, p = 0;
    for (; R !== i; )
      p += r[R++], R = R % e;
    if (i = (i + 1) % e, i === f && (f = (f + 1) % e), J - S < n)
      return;
    const m = C && J - C;
    return m ? Math.round(p * 1e3 / m) : void 0;
  };
}
function Uf(e, n) {
  let r = 0;
  const t = u0(50, 250);
  return (i) => {
    const f = i.loaded, S = i.lengthComputable ? i.total : void 0, w = f - r, T = t(w), J = f <= S;
    r = f;
    const C = {
      loaded: f,
      total: S,
      progress: S ? f / S : void 0,
      bytes: w,
      rate: T || void 0,
      estimated: T && S && J ? (S - f) / T : void 0,
      event: i
    };
    C[n ? "download" : "upload"] = !0, e(C);
  };
}
const c0 = typeof XMLHttpRequest < "u";
var l0 = c0 && function(e) {
  return new Promise(function(r, t) {
    let i = e.data;
    const f = pt.from(e.headers).normalize();
    let { responseType: S, withXSRFToken: w } = e, T;
    function J() {
      e.cancelToken && e.cancelToken.unsubscribe(T), e.signal && e.signal.removeEventListener("abort", T);
    }
    let C;
    if (Z.isFormData(i)) {
      if (ot.hasStandardBrowserEnv || ot.hasStandardBrowserWebWorkerEnv)
        f.setContentType(!1);
      else if ((C = f.getContentType()) !== !1) {
        const [a, ...d] = C ? C.split(";").map((y) => y.trim()).filter(Boolean) : [];
        f.setContentType([a || "multipart/form-data", ...d].join("; "));
      }
    }
    let R = new XMLHttpRequest();
    if (e.auth) {
      const a = e.auth.username || "", d = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : "";
      f.set("Authorization", "Basic " + btoa(a + ":" + d));
    }
    const p = Ey(e.baseURL, e.url);
    R.open(e.method.toUpperCase(), Ty(p, e.params, e.paramsSerializer), !0), R.timeout = e.timeout;
    function m() {
      if (!R)
        return;
      const a = pt.from(
        "getAllResponseHeaders" in R && R.getAllResponseHeaders()
      ), y = {
        data: !S || S === "text" || S === "json" ? R.responseText : R.response,
        status: R.status,
        statusText: R.statusText,
        headers: a,
        config: e,
        request: R
      };
      r0(function(E) {
        r(E), J();
      }, function(E) {
        t(E), J();
      }, y), R = null;
    }
    if ("onloadend" in R ? R.onloadend = m : R.onreadystatechange = function() {
      !R || R.readyState !== 4 || R.status === 0 && !(R.responseURL && R.responseURL.indexOf("file:") === 0) || setTimeout(m);
    }, R.onabort = function() {
      R && (t(new ke("Request aborted", ke.ECONNABORTED, e, R)), R = null);
    }, R.onerror = function() {
      t(new ke("Network Error", ke.ERR_NETWORK, e, R)), R = null;
    }, R.ontimeout = function() {
      let d = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded";
      const y = e.transitional || wy;
      e.timeoutErrorMessage && (d = e.timeoutErrorMessage), t(new ke(
        d,
        y.clarifyTimeoutError ? ke.ETIMEDOUT : ke.ECONNABORTED,
        e,
        R
      )), R = null;
    }, ot.hasStandardBrowserEnv && (w && Z.isFunction(w) && (w = w(e)), w || w !== !1 && s0(p))) {
      const a = e.xsrfHeaderName && e.xsrfCookieName && i0.read(e.xsrfCookieName);
      a && f.set(e.xsrfHeaderName, a);
    }
    i === void 0 && f.setContentType(null), "setRequestHeader" in R && Z.forEach(f.toJSON(), function(d, y) {
      R.setRequestHeader(y, d);
    }), Z.isUndefined(e.withCredentials) || (R.withCredentials = !!e.withCredentials), S && S !== "json" && (R.responseType = e.responseType), typeof e.onDownloadProgress == "function" && R.addEventListener("progress", Uf(e.onDownloadProgress, !0)), typeof e.onUploadProgress == "function" && R.upload && R.upload.addEventListener("progress", Uf(e.onUploadProgress)), (e.cancelToken || e.signal) && (T = (a) => {
      R && (t(!a || a.type ? new Jo(null, e, R) : a), R.abort(), R = null);
    }, e.cancelToken && e.cancelToken.subscribe(T), e.signal && (e.signal.aborted ? T() : e.signal.addEventListener("abort", T)));
    const v = d0(p);
    if (v && ot.protocols.indexOf(v) === -1) {
      t(new ke("Unsupported protocol " + v + ":", ke.ERR_BAD_REQUEST, e));
      return;
    }
    R.send(i || null);
  });
};
const fc = {
  http: JO,
  xhr: l0
};
Z.forEach(fc, (e, n) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: n });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: n });
  }
});
const Jf = (e) => `- ${e}`, f0 = (e) => Z.isFunction(e) || e === null || e === !1;
var Uy = {
  getAdapter: (e) => {
    e = Z.isArray(e) ? e : [e];
    const { length: n } = e;
    let r, t;
    const i = {};
    for (let f = 0; f < n; f++) {
      r = e[f];
      let S;
      if (t = r, !f0(r) && (t = fc[(S = String(r)).toLowerCase()], t === void 0))
        throw new ke(`Unknown adapter '${S}'`);
      if (t)
        break;
      i[S || "#" + f] = t;
    }
    if (!t) {
      const f = Object.entries(i).map(
        ([w, T]) => `adapter ${w} ` + (T === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let S = n ? f.length > 1 ? `since :
` + f.map(Jf).join(`
`) : " " + Jf(f[0]) : "as no adapter specified";
      throw new ke(
        "There is no suitable adapter to dispatch the request " + S,
        "ERR_NOT_SUPPORT"
      );
    }
    return t;
  },
  adapters: fc
};
function Eu(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new Jo(null, e);
}
function Df(e) {
  return Eu(e), e.headers = pt.from(e.headers), e.data = _u.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), Uy.getAdapter(e.adapter || sl.adapter)(e).then(function(t) {
    return Eu(e), t.data = _u.call(
      e,
      e.transformResponse,
      t
    ), t.headers = pt.from(t.headers), t;
  }, function(t) {
    return _y(t) || (Eu(e), t && t.response && (t.response.data = _u.call(
      e,
      e.transformResponse,
      t.response
    ), t.response.headers = pt.from(t.response.headers))), Promise.reject(t);
  });
}
const Mf = (e) => e instanceof pt ? { ...e } : e;
function Ti(e, n) {
  n = n || {};
  const r = {};
  function t(J, C, R) {
    return Z.isPlainObject(J) && Z.isPlainObject(C) ? Z.merge.call({ caseless: R }, J, C) : Z.isPlainObject(C) ? Z.merge({}, C) : Z.isArray(C) ? C.slice() : C;
  }
  function i(J, C, R) {
    if (Z.isUndefined(C)) {
      if (!Z.isUndefined(J))
        return t(void 0, J, R);
    } else return t(J, C, R);
  }
  function f(J, C) {
    if (!Z.isUndefined(C))
      return t(void 0, C);
  }
  function S(J, C) {
    if (Z.isUndefined(C)) {
      if (!Z.isUndefined(J))
        return t(void 0, J);
    } else return t(void 0, C);
  }
  function w(J, C, R) {
    if (R in n)
      return t(J, C);
    if (R in e)
      return t(void 0, J);
  }
  const T = {
    url: f,
    method: f,
    data: f,
    baseURL: S,
    transformRequest: S,
    transformResponse: S,
    paramsSerializer: S,
    timeout: S,
    timeoutMessage: S,
    withCredentials: S,
    withXSRFToken: S,
    adapter: S,
    responseType: S,
    xsrfCookieName: S,
    xsrfHeaderName: S,
    onUploadProgress: S,
    onDownloadProgress: S,
    decompress: S,
    maxContentLength: S,
    maxBodyLength: S,
    beforeRedirect: S,
    transport: S,
    httpAgent: S,
    httpsAgent: S,
    cancelToken: S,
    socketPath: S,
    responseEncoding: S,
    validateStatus: w,
    headers: (J, C) => i(Mf(J), Mf(C), !0)
  };
  return Z.forEach(Object.keys(Object.assign({}, e, n)), function(C) {
    const R = T[C] || i, p = R(e[C], n[C], C);
    Z.isUndefined(p) && R !== w || (r[C] = p);
  }), r;
}
const Jy = "1.6.8", dl = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, n) => {
  dl[e] = function(t) {
    return typeof t === e || "a" + (n < 1 ? "n " : " ") + e;
  };
});
const Hf = {};
dl.transitional = function(n, r, t) {
  function i(f, S) {
    return "[Axios v" + Jy + "] Transitional option '" + f + "'" + S + (t ? ". " + t : "");
  }
  return (f, S, w) => {
    if (n === !1)
      throw new ke(
        i(S, " has been removed" + (r ? " in " + r : "")),
        ke.ERR_DEPRECATED
      );
    return r && !Hf[S] && (Hf[S] = !0), n ? n(f, S, w) : !0;
  };
};
function p0(e, n, r) {
  if (typeof e != "object")
    throw new ke("options must be an object", ke.ERR_BAD_OPTION_VALUE);
  const t = Object.keys(e);
  let i = t.length;
  for (; i-- > 0; ) {
    const f = t[i], S = n[f];
    if (S) {
      const w = e[f], T = w === void 0 || S(w, f, e);
      if (T !== !0)
        throw new ke("option " + f + " must be " + T, ke.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (r !== !0)
      throw new ke("Unknown option " + f, ke.ERR_BAD_OPTION);
  }
}
var pc = {
  assertOptions: p0,
  validators: dl
};
const kt = pc.validators;
class _a {
  constructor(n) {
    this.defaults = n, this.interceptors = {
      request: new _f(),
      response: new _f()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(n, r) {
    try {
      return await this._request(n, r);
    } catch (t) {
      if (t instanceof Error) {
        let i;
        Error.captureStackTrace ? Error.captureStackTrace(i = {}) : i = new Error();
        const f = i.stack ? i.stack.replace(/^.+\n/, "") : "";
        t.stack ? f && !String(t.stack).endsWith(f.replace(/^.+\n.+\n/, "")) && (t.stack += `
` + f) : t.stack = f;
      }
      throw t;
    }
  }
  _request(n, r) {
    typeof n == "string" ? (r = r || {}, r.url = n) : r = n || {}, r = Ti(this.defaults, r);
    const { transitional: t, paramsSerializer: i, headers: f } = r;
    t !== void 0 && pc.assertOptions(t, {
      silentJSONParsing: kt.transitional(kt.boolean),
      forcedJSONParsing: kt.transitional(kt.boolean),
      clarifyTimeoutError: kt.transitional(kt.boolean)
    }, !1), i != null && (Z.isFunction(i) ? r.paramsSerializer = {
      serialize: i
    } : pc.assertOptions(i, {
      encode: kt.function,
      serialize: kt.function
    }, !0)), r.method = (r.method || this.defaults.method || "get").toLowerCase();
    let S = f && Z.merge(
      f.common,
      f[r.method]
    );
    f && Z.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (v) => {
        delete f[v];
      }
    ), r.headers = pt.concat(S, f);
    const w = [];
    let T = !0;
    this.interceptors.request.forEach(function(a) {
      typeof a.runWhen == "function" && a.runWhen(r) === !1 || (T = T && a.synchronous, w.unshift(a.fulfilled, a.rejected));
    });
    const J = [];
    this.interceptors.response.forEach(function(a) {
      J.push(a.fulfilled, a.rejected);
    });
    let C, R = 0, p;
    if (!T) {
      const v = [Df.bind(this), void 0];
      for (v.unshift.apply(v, w), v.push.apply(v, J), p = v.length, C = Promise.resolve(r); R < p; )
        C = C.then(v[R++], v[R++]);
      return C;
    }
    p = w.length;
    let m = r;
    for (R = 0; R < p; ) {
      const v = w[R++], a = w[R++];
      try {
        m = v(m);
      } catch (d) {
        a.call(this, d);
        break;
      }
    }
    try {
      C = Df.call(this, m);
    } catch (v) {
      return Promise.reject(v);
    }
    for (R = 0, p = J.length; R < p; )
      C = C.then(J[R++], J[R++]);
    return C;
  }
  getUri(n) {
    n = Ti(this.defaults, n);
    const r = Ey(n.baseURL, n.url);
    return Ty(r, n.params, n.paramsSerializer);
  }
}
Z.forEach(["delete", "get", "head", "options"], function(n) {
  _a.prototype[n] = function(r, t) {
    return this.request(Ti(t || {}, {
      method: n,
      url: r,
      data: (t || {}).data
    }));
  };
});
Z.forEach(["post", "put", "patch"], function(n) {
  function r(t) {
    return function(f, S, w) {
      return this.request(Ti(w || {}, {
        method: n,
        headers: t ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: f,
        data: S
      }));
    };
  }
  _a.prototype[n] = r(), _a.prototype[n + "Form"] = r(!0);
});
var ga = _a;
class ul {
  constructor(n) {
    if (typeof n != "function")
      throw new TypeError("executor must be a function.");
    let r;
    this.promise = new Promise(function(f) {
      r = f;
    });
    const t = this;
    this.promise.then((i) => {
      if (!t._listeners) return;
      let f = t._listeners.length;
      for (; f-- > 0; )
        t._listeners[f](i);
      t._listeners = null;
    }), this.promise.then = (i) => {
      let f;
      const S = new Promise((w) => {
        t.subscribe(w), f = w;
      }).then(i);
      return S.cancel = function() {
        t.unsubscribe(f);
      }, S;
    }, n(function(f, S, w) {
      t.reason || (t.reason = new Jo(f, S, w), r(t.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(n) {
    if (this.reason) {
      n(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(n) : this._listeners = [n];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(n) {
    if (!this._listeners)
      return;
    const r = this._listeners.indexOf(n);
    r !== -1 && this._listeners.splice(r, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let n;
    return {
      token: new ul(function(i) {
        n = i;
      }),
      cancel: n
    };
  }
}
var h0 = ul;
function y0(e) {
  return function(r) {
    return e.apply(null, r);
  };
}
function m0(e) {
  return Z.isObject(e) && e.isAxiosError === !0;
}
const hc = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(hc).forEach(([e, n]) => {
  hc[n] = e;
});
var g0 = hc;
function Dy(e) {
  const n = new ga(e), r = my(ga.prototype.request, n);
  return Z.extend(r, ga.prototype, n, { allOwnKeys: !0 }), Z.extend(r, n, null, { allOwnKeys: !0 }), r.create = function(i) {
    return Dy(Ti(e, i));
  }, r;
}
const we = Dy(sl);
we.Axios = ga;
we.CanceledError = Jo;
we.CancelToken = h0;
we.isCancel = _y;
we.VERSION = Jy;
we.toFormData = $s;
we.AxiosError = ke;
we.Cancel = we.CanceledError;
we.all = function(n) {
  return Promise.all(n);
};
we.spread = y0;
we.isAxiosError = m0;
we.mergeConfig = Ti;
we.AxiosHeaders = pt;
we.formToJSON = (e) => Ny(Z.isHTMLForm(e) ? new FormData(e) : e);
we.getAdapter = Uy.getAdapter;
we.HttpStatusCode = g0;
we.default = we;
var S0 = we, k0 = x && x.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Eo, "__esModule", { value: !0 });
Eo.http = void 0;
const P0 = k0(S0);
function v0(e) {
  if (e.status >= 400)
    throw new Error(`Bad status on response: ${e.status}`);
  return e;
}
function b0(e) {
  return e.toString().includes("emitExperimentalWarning");
}
async function R0(e, n, r, t) {
  if (typeof fetch == "function" && !b0(fetch)) {
    const i = {
      method: e,
      body: t ? JSON.stringify(t) : void 0,
      headers: {
        // eslint-disable-next-line @typescript-eslint/naming-convention
        "Content-Type": "application/json",
        ...r
      }
    };
    return fetch(n, i).then(v0).then((f) => f.json());
  } else
    return P0.default.request({ url: n, method: e, data: t, headers: r }).then((i) => i.data);
}
Eo.http = R0;
var ht = {};
Object.defineProperty(ht, "__esModule", { value: !0 });
ht.hasProtocol = ht.instanceOfRpcStreamingClient = void 0;
function B0(e) {
  return typeof e.listen == "function";
}
ht.instanceOfRpcStreamingClient = B0;
function O0(e) {
  return e.search("://") !== -1;
}
ht.hasProtocol = O0;
Object.defineProperty(Ms, "__esModule", { value: !0 });
Ms.HttpBatchClient = void 0;
const qf = Hs, A0 = Eo, I0 = ht, Vf = {
  dispatchInterval: 20,
  batchSizeLimit: 20
};
class T0 {
  constructor(n, r = {}) {
    if (this.queue = [], this.options = {
      batchSizeLimit: r.batchSizeLimit ?? Vf.batchSizeLimit,
      dispatchInterval: r.dispatchInterval ?? Vf.dispatchInterval
    }, typeof n == "string") {
      if (!(0, I0.hasProtocol)(n))
        throw new Error("Endpoint URL is missing a protocol. Expected 'https://' or 'http://'.");
      this.url = n;
    } else
      this.url = n.url, this.headers = n.headers;
    this.timer = setInterval(() => this.tick(), r.dispatchInterval), this.validate();
  }
  disconnect() {
    this.timer && clearInterval(this.timer), this.timer = void 0;
  }
  async execute(n) {
    return new Promise((r, t) => {
      this.queue.push({ request: n, resolve: r, reject: t }), this.queue.length >= this.options.batchSizeLimit && this.tick();
    });
  }
  validate() {
    if (!this.options.batchSizeLimit || !Number.isSafeInteger(this.options.batchSizeLimit) || this.options.batchSizeLimit < 1)
      throw new Error("batchSizeLimit must be a safe integer >= 1");
  }
  /**
   * This is called in an interval where promise rejections cannot be handled.
   * So this is not async and HTTP errors need to be handled by the queued promises.
   */
  tick() {
    const n = this.queue.splice(0, this.options.batchSizeLimit);
    if (!n.length)
      return;
    const r = n.map((i) => i.request), t = r.map((i) => i.id);
    (0, A0.http)("POST", this.url, this.headers, r).then((i) => {
      (Array.isArray(i) ? i : [i]).forEach((S) => {
        const w = n.find((R) => R.request.id === S.id);
        if (!w)
          return;
        const { reject: T, resolve: J } = w, C = (0, qf.parseJsonRpcResponse)(S);
        (0, qf.isJsonRpcErrorResponse)(C) ? T(new Error(JSON.stringify(C.error))) : J(C);
      });
    }, (i) => {
      for (const f of t) {
        const S = n.find((w) => w.request.id === f);
        if (!S)
          return;
        S.reject(i);
      }
    });
  }
}
Ms.HttpBatchClient = T0;
var Gs = {};
Object.defineProperty(Gs, "__esModule", { value: !0 });
Gs.HttpClient = void 0;
const Wf = Hs, w0 = Eo, C0 = ht;
class N0 {
  constructor(n) {
    if (typeof n == "string") {
      if (!(0, C0.hasProtocol)(n))
        throw new Error("Endpoint URL is missing a protocol. Expected 'https://' or 'http://'.");
      this.url = n;
    } else
      this.url = n.url, this.headers = n.headers;
  }
  disconnect() {
  }
  async execute(n) {
    const r = (0, Wf.parseJsonRpcResponse)(await (0, w0.http)("POST", this.url, this.headers, n));
    if ((0, Wf.isJsonRpcErrorResponse)(r))
      throw new Error(JSON.stringify(r.error));
    return r;
  }
}
Gs.HttpClient = N0;
var Ks = {}, My = {}, cl = {}, Do = {}, Mo = {}, br = null;
typeof WebSocket < "u" ? br = WebSocket : typeof MozWebSocket < "u" ? br = MozWebSocket : typeof x < "u" ? br = x.WebSocket || x.MozWebSocket : typeof window < "u" ? br = window.WebSocket || window.MozWebSocket : typeof self < "u" && (br = self.WebSocket || self.MozWebSocket);
var _0 = br, E0 = x && x.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Mo, "__esModule", { value: !0 });
Mo.SocketWrapper = void 0;
const gr = E0(_0);
function U0() {
  return typeof Jd < "u" && typeof Jd.versions < "u" && typeof Jd.versions.node < "u";
}
class J0 {
  constructor(n, r, t, i, f, S = 1e4) {
    this.closed = !1, this.connected = new Promise((w, T) => {
      this.connectedResolver = w, this.connectedRejecter = T;
    }), this.url = n, this.messageHandler = r, this.errorHandler = t, this.openHandler = i, this.closeHandler = f, this.timeout = S;
  }
  /**
   * returns a promise that resolves when connection is open
   */
  connect() {
    const n = new gr.default(this.url);
    n.onerror = (t) => {
      this.clearTimeout(), this.errorHandler && this.errorHandler(t);
    }, n.onmessage = (t) => {
      this.messageHandler({
        type: t.type,
        data: t.data
      });
    }, n.onopen = (t) => {
      this.clearTimeout(), this.connectedResolver(), this.openHandler && this.openHandler();
    }, n.onclose = (t) => {
      this.closed = !0, this.closeHandler && this.closeHandler(t);
    };
    const r = Date.now();
    this.timeoutId = setTimeout(() => {
      n.onmessage = () => 0, n.onerror = () => 0, n.onopen = () => 0, n.onclose = () => 0, n.close(), this.socket = void 0;
      const t = Math.floor(Date.now() - r);
      this.connectedRejecter(`Connection attempt timed out after ${t} ms`);
    }, this.timeout), this.socket = n;
  }
  /**
   * Closes an established connection and aborts other connection states
   */
  disconnect() {
    if (!this.socket)
      throw new Error("Socket undefined. This must be called after connecting.");
    switch (this.clearTimeout(), this.socket.readyState) {
      case gr.default.OPEN:
        this.socket.close(
          1e3
          /* Normal Closure */
        );
        break;
      case gr.default.CLOSED:
        break;
      case gr.default.CONNECTING:
        this.socket.onopen = () => 0, this.socket.onclose = () => 0, this.socket.onerror = () => 0, this.socket.onmessage = () => 0, this.socket = void 0, this.closeHandler && this.closeHandler({ wasClean: !1, code: 4001 });
        break;
      case gr.default.CLOSING:
        break;
      default:
        throw new Error(`Unknown readyState: ${this.socket.readyState}`);
    }
  }
  async send(n) {
    return new Promise((r, t) => {
      if (!this.socket)
        throw new Error("Socket undefined. This must be called after connecting.");
      if (this.closed)
        throw new Error("Socket was closed, so no data can be sent anymore.");
      if (this.socket.readyState !== gr.default.OPEN)
        throw new Error("Websocket is not open");
      U0() ? this.socket.send(n, (i) => i ? t(i) : r()) : (this.socket.send(n), r());
    });
  }
  /**
   * Clears the timeout function, such that no timeout error will be raised anymore. This should be
   * called when the connection is established, a connection error occurred or the socket is disconnected.
   *
   * This method must not be called before `connect()`.
   * This method is idempotent.
   */
  clearTimeout() {
    if (!this.timeoutId)
      throw new Error("Timeout ID not set. This should not happen and usually means connect() was not called.");
    clearTimeout(this.timeoutId);
  }
}
Mo.SocketWrapper = J0;
Object.defineProperty(Do, "__esModule", { value: !0 });
Do.StreamingSocket = void 0;
const D0 = qe, M0 = Mo;
class H0 {
  constructor(n, r = 1e4) {
    this.socket = new M0.SocketWrapper(n, (i) => {
      this.eventProducerListener && this.eventProducerListener.next(i);
    }, (i) => {
      this.eventProducerListener && this.eventProducerListener.error(i);
    }, () => {
    }, (i) => {
      this.eventProducerListener && (i.wasClean ? this.eventProducerListener.complete() : this.eventProducerListener.error("Socket was closed unclean"));
    }, r), this.connected = this.socket.connected;
    const t = {
      start: (i) => this.eventProducerListener = i,
      stop: () => this.eventProducerListener = void 0
    };
    this.events = D0.Stream.create(t);
  }
  connect() {
    this.socket.connect();
  }
  disconnect() {
    this.socket.disconnect();
  }
  async send(n) {
    return this.socket.send(n);
  }
}
Do.StreamingSocket = H0;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueueingStreamingSocket = e.ConnectionStatus = void 0;
  const n = Ao, r = qe, t = Do;
  var i;
  (function(S) {
    S[S.Unconnected = 0] = "Unconnected", S[S.Connecting = 1] = "Connecting", S[S.Connected = 2] = "Connected", S[S.Disconnected = 3] = "Disconnected";
  })(i = e.ConnectionStatus || (e.ConnectionStatus = {}));
  class f {
    constructor(w, T = 1e4, J) {
      this.queue = [], this.isProcessingQueue = !1, this.url = w, this.timeout = T, this.reconnectedHandler = J;
      const C = {
        start: (R) => this.eventProducerListener = R,
        stop: () => this.eventProducerListener = void 0
      };
      this.events = r.Stream.create(C), this.connectionStatusProducer = new n.DefaultValueProducer(i.Unconnected), this.connectionStatus = new n.ValueAndUpdates(this.connectionStatusProducer), this.socket = new t.StreamingSocket(this.url, this.timeout), this.socket.events.subscribe({
        next: (R) => {
          if (!this.eventProducerListener)
            throw new Error("No event producer listener set");
          this.eventProducerListener.next(R);
        },
        error: () => this.connectionStatusProducer.update(i.Disconnected)
      });
    }
    connect() {
      this.connectionStatusProducer.update(i.Connecting), this.socket.connected.then(async () => (this.connectionStatusProducer.update(i.Connected), this.processQueue()), () => this.connectionStatusProducer.update(i.Disconnected)), this.socket.connect();
    }
    disconnect() {
      this.connectionStatusProducer.update(i.Disconnected), this.socket.disconnect();
    }
    reconnect() {
      this.socket = new t.StreamingSocket(this.url, this.timeout), this.socket.events.subscribe({
        next: (w) => {
          if (!this.eventProducerListener)
            throw new Error("No event producer listener set");
          this.eventProducerListener.next(w);
        },
        error: () => this.connectionStatusProducer.update(i.Disconnected)
      }), this.socket.connected.then(() => {
        this.reconnectedHandler && this.reconnectedHandler();
      }), this.connect();
    }
    getQueueLength() {
      return this.queue.length;
    }
    queueRequest(w) {
      this.queue.push(w), this.processQueue();
    }
    async processQueue() {
      if (this.isProcessingQueue || this.connectionStatus.value !== i.Connected)
        return;
      this.isProcessingQueue = !0;
      let w;
      for (; w = this.queue.shift(); )
        try {
          await this.socket.send(w), this.isProcessingQueue = !1;
        } catch {
          this.queue.unshift(w), this.isProcessingQueue = !1;
          return;
        }
    }
  }
  e.QueueingStreamingSocket = f;
})(cl);
var zs = {};
Object.defineProperty(zs, "__esModule", { value: !0 });
zs.ReconnectingSocket = void 0;
const q0 = qe, Uu = cl;
class ll {
  /** Starts with a 0.1 second timeout, then doubles every attempt with a maximum timeout of 5 seconds. */
  static calculateTimeout(n) {
    return Math.min(2 ** n * 100, 5e3);
  }
  constructor(n, r = 1e4, t) {
    this.unconnected = !0, this.disconnected = !1, this.timeoutIndex = 0, this.reconnectTimeout = null;
    const i = {
      start: (f) => this.eventProducerListener = f,
      stop: () => this.eventProducerListener = void 0
    };
    this.events = q0.Stream.create(i), this.socket = new Uu.QueueingStreamingSocket(n, r, t), this.socket.events.subscribe({
      next: (f) => {
        this.eventProducerListener && this.eventProducerListener.next(f);
      },
      error: (f) => {
        this.eventProducerListener && this.eventProducerListener.error(f);
      }
    }), this.connectionStatus = this.socket.connectionStatus, this.connectionStatus.updates.subscribe({
      next: (f) => {
        f === Uu.ConnectionStatus.Connected && (this.timeoutIndex = 0), f === Uu.ConnectionStatus.Disconnected && (this.reconnectTimeout && (clearTimeout(this.reconnectTimeout), this.reconnectTimeout = null), this.reconnectTimeout = setTimeout(() => this.socket.reconnect(), ll.calculateTimeout(this.timeoutIndex++)));
      }
    });
  }
  connect() {
    if (!this.unconnected)
      throw new Error("Cannot connect: socket has already connected");
    this.socket.connect(), this.unconnected = !1;
  }
  disconnect() {
    if (this.unconnected)
      throw new Error("Cannot disconnect: socket has not yet connected");
    this.socket.disconnect(), this.eventProducerListener && this.eventProducerListener.complete(), this.disconnected = !0;
  }
  queueRequest(n) {
    if (this.disconnected)
      throw new Error("Cannot queue request: socket has disconnected");
    this.socket.queueRequest(n);
  }
}
zs.ReconnectingSocket = ll;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.StreamingSocket = e.SocketWrapper = e.ReconnectingSocket = e.QueueingStreamingSocket = e.ConnectionStatus = void 0;
  var n = cl;
  Object.defineProperty(e, "ConnectionStatus", { enumerable: !0, get: function() {
    return n.ConnectionStatus;
  } }), Object.defineProperty(e, "QueueingStreamingSocket", { enumerable: !0, get: function() {
    return n.QueueingStreamingSocket;
  } });
  var r = zs;
  Object.defineProperty(e, "ReconnectingSocket", { enumerable: !0, get: function() {
    return r.ReconnectingSocket;
  } });
  var t = Mo;
  Object.defineProperty(e, "SocketWrapper", { enumerable: !0, get: function() {
    return t.SocketWrapper;
  } });
  var i = Do;
  Object.defineProperty(e, "StreamingSocket", { enumerable: !0, get: function() {
    return i.StreamingSocket;
  } });
})(My);
Object.defineProperty(Ks, "__esModule", { value: !0 });
Ks.WebsocketClient = void 0;
const Ea = Hs, Qf = My, V0 = Ao, W0 = qe, Q0 = ht;
function F0(e) {
  throw e;
}
function Hy(e) {
  if (e.type !== "message")
    throw new Error(`Unexcepted message type on websocket: ${e.type}`);
  return (0, Ea.parseJsonRpcResponse)(JSON.parse(e.data));
}
class $0 {
  constructor(n, r) {
    this.running = !1, this.subscriptions = [], this.request = n, this.socket = r;
  }
  /**
   * Implementation of Producer.start
   */
  start(n) {
    if (this.running)
      throw Error("Already started. Please stop first before restarting.");
    this.running = !0, this.connectToClient(n), this.socket.queueRequest(JSON.stringify(this.request));
  }
  /**
   * Implementation of Producer.stop
   *
   * Called by the stream when the stream's last listener stopped listening
   * or when the producer completed.
   */
  stop() {
    this.running = !1;
    const n = { ...this.request, method: "unsubscribe" };
    try {
      this.socket.queueRequest(JSON.stringify(n));
    } catch (r) {
      if (!(r instanceof Error && r.message.match(/socket has disconnected/i))) throw r;
    }
  }
  connectToClient(n) {
    const r = this.socket.events.map(Hy), t = r.filter((S) => S.id === this.request.id).subscribe({
      next: (S) => {
        (0, Ea.isJsonRpcErrorResponse)(S) && (this.closeSubscriptions(), n.error(JSON.stringify(S.error))), t.unsubscribe();
      }
    }), i = r.filter((S) => S.id === this.request.id).subscribe({
      next: (S) => {
        (0, Ea.isJsonRpcErrorResponse)(S) ? (this.closeSubscriptions(), n.error(JSON.stringify(S.error))) : n.next(S.result);
      }
    }), f = r.subscribe({
      error: (S) => {
        this.closeSubscriptions(), n.error(S);
      },
      complete: () => {
        this.closeSubscriptions(), n.complete();
      }
    });
    this.subscriptions.push(t, i, f);
  }
  closeSubscriptions() {
    for (const n of this.subscriptions)
      n.unsubscribe();
    this.subscriptions = [];
  }
}
class L0 {
  constructor(n, r = F0) {
    if (this.subscriptionStreams = /* @__PURE__ */ new Map(), !(0, Q0.hasProtocol)(n))
      throw new Error("Base URL is missing a protocol. Expected 'ws://' or 'wss://'.");
    const t = n.endsWith("/") ? "websocket" : "/websocket";
    this.url = n + t, this.socket = new Qf.ReconnectingSocket(this.url);
    const i = this.socket.events.subscribe({
      error: (f) => {
        r(f), i.unsubscribe();
      }
    });
    this.jsonRpcResponseStream = this.socket.events.map(Hy), this.socket.connect();
  }
  async execute(n) {
    const r = this.responseForRequestId(n.id);
    this.socket.queueRequest(JSON.stringify(n));
    const t = await r;
    if ((0, Ea.isJsonRpcErrorResponse)(t))
      throw new Error(JSON.stringify(t.error));
    return t;
  }
  listen(n) {
    if (n.method !== "subscribe")
      throw new Error('Request method must be "subscribe" to start event listening');
    const r = n.params.query;
    if (typeof r != "string")
      throw new Error("request.params.query must be a string");
    if (!this.subscriptionStreams.has(r)) {
      const t = new $0(n, this.socket), i = W0.Stream.create(t);
      this.subscriptionStreams.set(r, i);
    }
    return this.subscriptionStreams.get(r).filter((t) => t.query !== void 0);
  }
  /**
   * Resolves as soon as websocket is connected. execute() queues requests automatically,
   * so this should be required for testing purposes only.
   */
  async connected() {
    await this.socket.connectionStatus.waitFor(Qf.ConnectionStatus.Connected);
  }
  disconnect() {
    this.socket.disconnect();
  }
  async responseForRequestId(n) {
    return (0, V0.firstEvent)(this.jsonRpcResponseStream.filter((r) => r.id === n));
  }
}
Ks.WebsocketClient = L0;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.WebsocketClient = e.instanceOfRpcStreamingClient = e.HttpClient = e.HttpBatchClient = void 0;
  var n = Ms;
  Object.defineProperty(e, "HttpBatchClient", { enumerable: !0, get: function() {
    return n.HttpBatchClient;
  } });
  var r = Gs;
  Object.defineProperty(e, "HttpClient", { enumerable: !0, get: function() {
    return r.HttpClient;
  } });
  var t = ht;
  Object.defineProperty(e, "instanceOfRpcStreamingClient", { enumerable: !0, get: function() {
    return t.instanceOfRpcStreamingClient;
  } });
  var i = Ks;
  Object.defineProperty(e, "WebsocketClient", { enumerable: !0, get: function() {
    return i.WebsocketClient;
  } });
})(_o);
var qy = {}, xs = {}, Pn = {}, me = {};
Object.defineProperty(me, "__esModule", { value: !0 });
me.encodeBlockId = me.encodeVersion = me.encodeBytes = me.encodeTime = me.encodeUvarint = me.encodeString = me.dictionaryToStringMap = me.may = me.assertNotEmpty = me.assertObject = me.assertArray = me.assertNumber = me.assertString = me.assertBoolean = me.assertSet = void 0;
const G0 = Wn;
function sr(e) {
  if (e === void 0)
    throw new Error("Value must not be undefined");
  if (e === null)
    throw new Error("Value must not be null");
  return e;
}
me.assertSet = sr;
function K0(e) {
  if (sr(e), typeof e != "boolean")
    throw new Error("Value must be a boolean");
  return e;
}
me.assertBoolean = K0;
function z0(e) {
  if (sr(e), typeof e != "string")
    throw new Error("Value must be a string");
  return e;
}
me.assertString = z0;
function x0(e) {
  if (sr(e), typeof e != "number")
    throw new Error("Value must be a number");
  return e;
}
me.assertNumber = x0;
function Z0(e) {
  if (sr(e), !Array.isArray(e))
    throw new Error("Value must be a an array");
  return e;
}
me.assertArray = Z0;
function Y0(e) {
  if (sr(e), typeof e != "object")
    throw new Error("Value must be an object");
  if (Object.prototype.toString.call(e) !== "[object Object]")
    throw new Error("Value must be a simple object");
  return e;
}
me.assertObject = Y0;
function X0(e) {
  if (sr(e), typeof e == "number" && e === 0)
    throw new Error("must provide a non-zero value");
  if (e.length === 0)
    throw new Error("must provide a non-empty value");
  return e;
}
me.assertNotEmpty = X0;
function j0(e, n) {
  return n == null ? void 0 : e(n);
}
me.may = j0;
function eA(e) {
  const n = /* @__PURE__ */ new Map();
  for (const r of Object.keys(e)) {
    const t = e[r];
    if (typeof t != "string")
      throw new Error("Found dictionary value of type other than string");
    n.set(r, t);
  }
  return n;
}
me.dictionaryToStringMap = eA;
function nA(e) {
  const n = (0, G0.toUtf8)(e);
  return Uint8Array.from([n.length, ...n]);
}
me.encodeString = nA;
function wi(e) {
  return e >= 128 ? (
    // eslint-disable-next-line no-bitwise
    Uint8Array.from([e & 255 | 128, ...wi(e >> 7)])
  ) : (
    // eslint-disable-next-line no-bitwise
    Uint8Array.from([e & 255])
  );
}
me.encodeUvarint = wi;
function tA(e) {
  const n = e.getTime(), r = Math.floor(n / 1e3), t = r ? [8, ...wi(r)] : new Uint8Array(), i = (e.nanoseconds || 0) + n % 1e3 * 1e6, f = i ? [16, ...wi(i)] : new Uint8Array();
  return Uint8Array.from([...t, ...f]);
}
me.encodeTime = tA;
function rA(e) {
  if (e.length >= 128)
    throw new Error("Not implemented for byte arrays of length 128 or more");
  return e.length ? Uint8Array.from([e.length, ...e]) : new Uint8Array();
}
me.encodeBytes = rA;
function iA(e) {
  const n = e.block ? Uint8Array.from([8, ...wi(e.block)]) : new Uint8Array(), r = e.app ? Uint8Array.from([16, ...wi(e.app)]) : new Uint8Array();
  return Uint8Array.from([...n, ...r]);
}
me.encodeVersion = iA;
function oA(e) {
  return Uint8Array.from([
    10,
    e.hash.length,
    ...e.hash,
    18,
    e.parts.hash.length + 4,
    8,
    e.parts.total,
    18,
    e.parts.hash.length,
    ...e.parts.hash
  ]);
}
me.encodeBlockId = oA;
Object.defineProperty(Pn, "__esModule", { value: !0 });
Pn.smallIntToApi = Pn.apiToBigInt = Pn.apiToSmallInt = void 0;
const yc = Ie, aA = me;
function sA(e) {
  return (typeof e == "number" ? new yc.Int53(e) : yc.Int53.fromString(e)).toNumber();
}
Pn.apiToSmallInt = sA;
function dA(e) {
  if ((0, aA.assertString)(e), !e.match(/^-?[0-9]+$/))
    throw new Error("Invalid string format");
  return BigInt(e);
}
Pn.apiToBigInt = dA;
function uA(e) {
  return new yc.Int53(e).toString();
}
Pn.smallIntToApi = uA;
var ge = {};
Object.defineProperty(ge, "__esModule", { value: !0 });
ge.encodeBlockId = ge.encodeVersion = ge.encodeBytes = ge.encodeTime = ge.encodeUvarint = ge.encodeString = ge.dictionaryToStringMap = ge.may = ge.assertNotEmpty = ge.assertObject = ge.assertArray = ge.assertNumber = ge.assertString = ge.assertBoolean = ge.assertSet = void 0;
const cA = Wn;
function dr(e) {
  if (e === void 0)
    throw new Error("Value must not be undefined");
  if (e === null)
    throw new Error("Value must not be null");
  return e;
}
ge.assertSet = dr;
function lA(e) {
  if (dr(e), typeof e != "boolean")
    throw new Error("Value must be a boolean");
  return e;
}
ge.assertBoolean = lA;
function fA(e) {
  if (dr(e), typeof e != "string")
    throw new Error("Value must be a string");
  return e;
}
ge.assertString = fA;
function pA(e) {
  if (dr(e), typeof e != "number")
    throw new Error("Value must be a number");
  return e;
}
ge.assertNumber = pA;
function hA(e) {
  if (dr(e), !Array.isArray(e))
    throw new Error("Value must be a an array");
  return e;
}
ge.assertArray = hA;
function yA(e) {
  if (dr(e), typeof e != "object")
    throw new Error("Value must be an object");
  if (Object.prototype.toString.call(e) !== "[object Object]")
    throw new Error("Value must be a simple object");
  return e;
}
ge.assertObject = yA;
function mA(e) {
  if (dr(e), typeof e == "number" && e === 0)
    throw new Error("must provide a non-zero value");
  if (e.length === 0)
    throw new Error("must provide a non-empty value");
  return e;
}
ge.assertNotEmpty = mA;
function gA(e, n) {
  return n == null ? void 0 : e(n);
}
ge.may = gA;
function SA(e) {
  const n = /* @__PURE__ */ new Map();
  for (const r of Object.keys(e)) {
    const t = e[r];
    if (typeof t != "string")
      throw new Error("Found dictionary value of type other than string");
    n.set(r, t);
  }
  return n;
}
ge.dictionaryToStringMap = SA;
function kA(e) {
  const n = (0, cA.toUtf8)(e);
  return Uint8Array.from([n.length, ...n]);
}
ge.encodeString = kA;
function Ci(e) {
  return e >= 128 ? (
    // eslint-disable-next-line no-bitwise
    Uint8Array.from([e & 255 | 128, ...Ci(e >> 7)])
  ) : (
    // eslint-disable-next-line no-bitwise
    Uint8Array.from([e & 255])
  );
}
ge.encodeUvarint = Ci;
function PA(e) {
  const n = e.getTime(), r = Math.floor(n / 1e3), t = r ? [8, ...Ci(r)] : new Uint8Array(), i = (e.nanoseconds || 0) + n % 1e3 * 1e6, f = i ? [16, ...Ci(i)] : new Uint8Array();
  return Uint8Array.from([...t, ...f]);
}
ge.encodeTime = PA;
function vA(e) {
  if (e.length >= 128)
    throw new Error("Not implemented for byte arrays of length 128 or more");
  return e.length ? Uint8Array.from([e.length, ...e]) : new Uint8Array();
}
ge.encodeBytes = vA;
function bA(e) {
  const n = e.block ? Uint8Array.from([8, ...Ci(e.block)]) : new Uint8Array(), r = e.app ? Uint8Array.from([16, ...Ci(e.app)]) : new Uint8Array();
  return Uint8Array.from([...n, ...r]);
}
ge.encodeVersion = bA;
function RA(e) {
  return Uint8Array.from([
    10,
    e.hash.length,
    ...e.hash,
    18,
    e.parts.hash.length + 4,
    8,
    e.parts.total,
    18,
    e.parts.hash.length,
    ...e.parts.hash
  ]);
}
ge.encodeBlockId = RA;
var Zs = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.buildQuery = e.SubscriptionEventType = e.Method = void 0, function(r) {
    r.AbciInfo = "abci_info", r.AbciQuery = "abci_query", r.Block = "block", r.Blockchain = "blockchain", r.BlockResults = "block_results", r.BlockSearch = "block_search", r.BroadcastTxAsync = "broadcast_tx_async", r.BroadcastTxSync = "broadcast_tx_sync", r.BroadcastTxCommit = "broadcast_tx_commit", r.Commit = "commit", r.Genesis = "genesis", r.Health = "health", r.NumUnconfirmedTxs = "num_unconfirmed_txs", r.Status = "status", r.Subscribe = "subscribe", r.Tx = "tx", r.TxSearch = "tx_search", r.Validators = "validators", r.Unsubscribe = "unsubscribe";
  }(e.Method || (e.Method = {})), function(r) {
    r.NewBlock = "NewBlock", r.NewBlockHeader = "NewBlockHeader", r.Tx = "Tx";
  }(e.SubscriptionEventType || (e.SubscriptionEventType = {}));
  function n(r) {
    const i = (r.tags ? r.tags : []).map((S) => `${S.key}='${S.value}'`), f = r.raw ? [r.raw] : [];
    return [...i, ...f].join(" AND ");
  }
  e.buildQuery = n;
})(Zs);
var BA = x && x.__createBinding || (Object.create ? function(e, n, r, t) {
  t === void 0 && (t = r);
  var i = Object.getOwnPropertyDescriptor(n, r);
  (!i || ("get" in i ? !n.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return n[r];
  } }), Object.defineProperty(e, t, i);
} : function(e, n, r, t) {
  t === void 0 && (t = r), e[t] = n[r];
}), OA = x && x.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), AA = x && x.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var n = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && BA(n, e, r);
  return OA(n, e), n;
};
Object.defineProperty(xs, "__esModule", { value: !0 });
xs.Params = void 0;
const fl = Wn, Ln = Pn, Ve = mt, cn = ge, IA = AA(Zs);
function Ju(e) {
  return {
    height: (0, cn.may)(Ln.smallIntToApi, e.height)
  };
}
function TA(e) {
  return {
    minHeight: (0, cn.may)(Ln.smallIntToApi, e.minHeight),
    maxHeight: (0, cn.may)(Ln.smallIntToApi, e.maxHeight)
  };
}
function wA(e) {
  return {
    query: e.query,
    page: (0, cn.may)(Ln.smallIntToApi, e.page),
    per_page: (0, cn.may)(Ln.smallIntToApi, e.per_page),
    order_by: e.order_by
  };
}
function CA(e) {
  return {
    path: (0, cn.assertNotEmpty)(e.path),
    data: (0, fl.toHex)(e.data),
    height: (0, cn.may)(Ln.smallIntToApi, e.height),
    prove: e.prove
  };
}
function NA(e) {
  return {
    tx: (0, fl.toBase64)((0, cn.assertNotEmpty)(e.tx))
  };
}
function _A(e) {
  return {
    hash: (0, fl.toBase64)((0, cn.assertNotEmpty)(e.hash)),
    prove: e.prove
  };
}
function EA(e) {
  return {
    query: e.query,
    prove: e.prove,
    page: (0, cn.may)(Ln.smallIntToApi, e.page),
    per_page: (0, cn.may)(Ln.smallIntToApi, e.per_page),
    order_by: e.order_by
  };
}
function UA(e) {
  return {
    height: (0, cn.may)(Ln.smallIntToApi, e.height),
    page: (0, cn.may)(Ln.smallIntToApi, e.page),
    per_page: (0, cn.may)(Ln.smallIntToApi, e.per_page)
  };
}
let JA = class {
  static encodeAbciInfo(n) {
    return (0, Ve.createJsonRpcRequest)(n.method);
  }
  static encodeAbciQuery(n) {
    return (0, Ve.createJsonRpcRequest)(n.method, CA(n.params));
  }
  static encodeBlock(n) {
    return (0, Ve.createJsonRpcRequest)(n.method, Ju(n.params));
  }
  static encodeBlockchain(n) {
    return (0, Ve.createJsonRpcRequest)(n.method, TA(n.params));
  }
  static encodeBlockResults(n) {
    return (0, Ve.createJsonRpcRequest)(n.method, Ju(n.params));
  }
  static encodeBlockSearch(n) {
    return (0, Ve.createJsonRpcRequest)(n.method, wA(n.params));
  }
  static encodeBroadcastTx(n) {
    return (0, Ve.createJsonRpcRequest)(n.method, NA(n.params));
  }
  static encodeCommit(n) {
    return (0, Ve.createJsonRpcRequest)(n.method, Ju(n.params));
  }
  static encodeGenesis(n) {
    return (0, Ve.createJsonRpcRequest)(n.method);
  }
  static encodeHealth(n) {
    return (0, Ve.createJsonRpcRequest)(n.method);
  }
  static encodeNumUnconfirmedTxs(n) {
    return (0, Ve.createJsonRpcRequest)(n.method);
  }
  static encodeStatus(n) {
    return (0, Ve.createJsonRpcRequest)(n.method);
  }
  static encodeSubscribe(n) {
    const r = { key: "tm.event", value: n.query.type }, t = IA.buildQuery({ tags: [r], raw: n.query.raw });
    return (0, Ve.createJsonRpcRequest)("subscribe", { query: t });
  }
  static encodeTx(n) {
    return (0, Ve.createJsonRpcRequest)(n.method, _A(n.params));
  }
  // TODO: encode params for query string???
  static encodeTxSearch(n) {
    return (0, Ve.createJsonRpcRequest)(n.method, EA(n.params));
  }
  static encodeValidators(n) {
    return (0, Ve.createJsonRpcRequest)(n.method, UA(n.params));
  }
};
xs.Params = JA;
var _n = {}, Ho = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.BlockIdFlag = void 0, function(n) {
    n[n.Unknown = 0] = "Unknown", n[n.Absent = 1] = "Absent", n[n.Commit = 2] = "Commit", n[n.Nil = 3] = "Nil", n[n.Unrecognized = -1] = "Unrecognized";
  }(e.BlockIdFlag || (e.BlockIdFlag = {}));
})(Ho);
var Ni = {};
Object.defineProperty(Ni, "__esModule", { value: !0 });
Ni.hashBlock = Ni.hashTx = void 0;
const pl = _e, je = ge;
function DA(e) {
  return (0, pl.sha256)(e);
}
Ni.hashTx = DA;
function MA(e) {
  if (e < 1)
    throw new Error("Cannot split an empty tree");
  const n = 2 ** Math.floor(Math.log2(e));
  return n < e ? n : n / 2;
}
function HA(e) {
  const n = new pl.Sha256(Uint8Array.from([0]));
  return n.update(e), n.digest();
}
function qA(e, n) {
  const r = new pl.Sha256(Uint8Array.from([1]));
  return r.update(e), r.update(n), r.digest();
}
function mc(e) {
  switch (e.length) {
    case 0:
      throw new Error("Cannot hash empty tree");
    case 1:
      return HA(e[0]);
    default: {
      const n = MA(e.length), r = mc(e.slice(0, n)), t = mc(e.slice(n));
      return qA(r, t);
    }
  }
}
function VA(e) {
  if (!e.lastBlockId)
    throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
  const n = [
    (0, je.encodeVersion)(e.version),
    (0, je.encodeString)(e.chainId),
    (0, je.encodeUvarint)(e.height),
    (0, je.encodeTime)(e.time),
    (0, je.encodeBlockId)(e.lastBlockId),
    (0, je.encodeBytes)(e.lastCommitHash),
    (0, je.encodeBytes)(e.dataHash),
    (0, je.encodeBytes)(e.validatorsHash),
    (0, je.encodeBytes)(e.nextValidatorsHash),
    (0, je.encodeBytes)(e.consensusHash),
    (0, je.encodeBytes)(e.appHash),
    (0, je.encodeBytes)(e.lastResultsHash),
    (0, je.encodeBytes)(e.evidenceHash),
    (0, je.encodeBytes)(e.proposerAddress)
  ];
  return mc(n);
}
Ni.hashBlock = VA;
Object.defineProperty(_n, "__esModule", { value: !0 });
_n.Responses = _n.decodeValidatorInfo = _n.decodeValidatorGenesis = _n.decodeValidatorUpdate = _n.decodeEvent = void 0;
const ce = Wn, Vy = Te, mo = Ze, se = Pn, WA = Ho, j = ge, QA = Ni;
function FA(e) {
  return {
    data: e.data,
    lastBlockHeight: (0, j.may)(se.apiToSmallInt, e.last_block_height),
    lastBlockAppHash: (0, j.may)(ce.fromBase64, e.last_block_app_hash)
  };
}
function $A(e) {
  return {
    ops: e.ops.map((n) => ({
      type: n.type,
      key: (0, ce.fromBase64)(n.key),
      data: (0, ce.fromBase64)(n.data)
    }))
  };
}
function LA(e) {
  return {
    key: (0, ce.fromBase64)((0, j.assertString)(e.key ?? "")),
    value: (0, ce.fromBase64)((0, j.assertString)(e.value ?? "")),
    proof: (0, j.may)($A, e.proofOps),
    height: (0, j.may)(se.apiToSmallInt, e.height),
    code: (0, j.may)(se.apiToSmallInt, e.code),
    codespace: (0, j.assertString)(e.codespace ?? ""),
    index: (0, j.may)(se.apiToSmallInt, e.index),
    log: e.log,
    info: (0, j.assertString)(e.info ?? "")
  };
}
function GA(e) {
  return {
    key: (0, j.assertNotEmpty)(e.key),
    value: e.value ?? ""
  };
}
function KA(e) {
  return (0, j.assertArray)(e).map(GA);
}
function Wy(e) {
  return {
    type: e.type,
    attributes: e.attributes ? KA(e.attributes) : []
  };
}
_n.decodeEvent = Wy;
function gc(e) {
  return (0, j.assertArray)(e).map(Wy);
}
function _i(e) {
  return {
    code: (0, se.apiToSmallInt)((0, j.assertNumber)(e.code ?? 0)),
    codespace: e.codespace,
    log: e.log,
    data: (0, j.may)(ce.fromBase64, e.data),
    events: e.events ? gc(e.events) : [],
    gasWanted: (0, se.apiToBigInt)(e.gas_wanted ?? "0"),
    gasUsed: (0, se.apiToBigInt)(e.gas_used ?? "0")
  };
}
function hl(e) {
  if ("Sum" in e) {
    const [[n, r]] = Object.entries(e.Sum.value);
    return (0, Vy.assert)(n === "ed25519" || n === "secp256k1", `unknown pubkey type: ${n}`), {
      algorithm: n,
      data: (0, ce.fromBase64)((0, j.assertNotEmpty)(r))
    };
  } else
    switch (e.type) {
      case "tendermint/PubKeyEd25519":
        return {
          algorithm: "ed25519",
          data: (0, ce.fromBase64)((0, j.assertNotEmpty)(e.value))
        };
      case "tendermint/PubKeySecp256k1":
        return {
          algorithm: "secp256k1",
          data: (0, ce.fromBase64)((0, j.assertNotEmpty)(e.value))
        };
      default:
        throw new Error(`unknown pubkey type: ${e.type}`);
    }
}
function zA(e) {
  return {
    maxBytes: (0, se.apiToSmallInt)((0, j.assertNotEmpty)(e.max_bytes)),
    maxGas: (0, se.apiToSmallInt)((0, j.assertNotEmpty)(e.max_gas))
  };
}
function xA(e) {
  return {
    maxAgeNumBlocks: (0, se.apiToSmallInt)((0, j.assertNotEmpty)(e.max_age_num_blocks)),
    maxAgeDuration: (0, se.apiToSmallInt)((0, j.assertNotEmpty)(e.max_age_duration))
  };
}
function Qy(e) {
  return {
    block: zA((0, j.assertObject)(e.block)),
    evidence: xA((0, j.assertObject)(e.evidence))
  };
}
function Fy(e) {
  return {
    pubkey: hl((0, j.assertObject)(e.pub_key)),
    votingPower: (0, se.apiToBigInt)(e.power ?? "0")
  };
}
_n.decodeValidatorUpdate = Fy;
function ZA(e) {
  return {
    height: (0, se.apiToSmallInt)((0, j.assertNotEmpty)(e.height)),
    results: (e.txs_results || []).map(_i),
    validatorUpdates: (e.validator_updates || []).map(Fy),
    consensusUpdates: (0, j.may)(Qy, e.consensus_param_updates),
    beginBlockEvents: gc(e.begin_block_events || []),
    endBlockEvents: gc(e.end_block_events || [])
  };
}
function Ys(e) {
  return {
    hash: (0, ce.fromHex)((0, j.assertNotEmpty)(e.hash)),
    parts: {
      total: (0, j.assertNotEmpty)(e.parts.total),
      hash: (0, ce.fromHex)((0, j.assertNotEmpty)(e.parts.hash))
    }
  };
}
function YA(e) {
  return {
    block: (0, se.apiToSmallInt)(e.block),
    app: (0, se.apiToSmallInt)(e.app ?? 0)
  };
}
function Xs(e) {
  return {
    version: YA(e.version),
    chainId: (0, j.assertNotEmpty)(e.chain_id),
    height: (0, se.apiToSmallInt)((0, j.assertNotEmpty)(e.height)),
    time: (0, mo.fromRfc3339WithNanoseconds)((0, j.assertNotEmpty)(e.time)),
    // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
    // { hash: '', parts: { total: 0, hash: '' } }
    lastBlockId: e.last_block_id.hash ? Ys(e.last_block_id) : null,
    lastCommitHash: (0, ce.fromHex)((0, j.assertSet)(e.last_commit_hash)),
    dataHash: (0, ce.fromHex)((0, j.assertSet)(e.data_hash)),
    validatorsHash: (0, ce.fromHex)((0, j.assertSet)(e.validators_hash)),
    nextValidatorsHash: (0, ce.fromHex)((0, j.assertSet)(e.next_validators_hash)),
    consensusHash: (0, ce.fromHex)((0, j.assertSet)(e.consensus_hash)),
    appHash: (0, ce.fromHex)((0, j.assertSet)(e.app_hash)),
    lastResultsHash: (0, ce.fromHex)((0, j.assertSet)(e.last_results_hash)),
    evidenceHash: (0, ce.fromHex)((0, j.assertSet)(e.evidence_hash)),
    proposerAddress: (0, ce.fromHex)((0, j.assertNotEmpty)(e.proposer_address))
  };
}
function XA(e) {
  return {
    blockId: Ys(e.block_id),
    blockSize: (0, se.apiToSmallInt)((0, j.assertNotEmpty)(e.block_size)),
    header: Xs(e.header),
    numTxs: (0, se.apiToSmallInt)((0, j.assertNotEmpty)(e.num_txs))
  };
}
function jA(e) {
  return {
    lastHeight: (0, se.apiToSmallInt)((0, j.assertNotEmpty)(e.last_height)),
    blockMetas: (0, j.assertArray)(e.block_metas).map(XA)
  };
}
function e2(e) {
  return {
    ..._i(e),
    hash: (0, ce.fromHex)((0, j.assertNotEmpty)(e.hash))
  };
}
function n2(e) {
  const n = e.tx_result ? _i(e.tx_result) : void 0;
  return {
    height: (0, se.apiToSmallInt)(e.height),
    hash: (0, ce.fromHex)((0, j.assertNotEmpty)(e.hash)),
    checkTx: _i((0, j.assertObject)(e.check_tx)),
    deliverTx: n,
    txResult: n
  };
}
function t2(e) {
  return (0, Vy.assert)(e in WA.BlockIdFlag), e;
}
function r2(e) {
  return {
    blockIdFlag: t2(e.block_id_flag),
    validatorAddress: e.validator_address ? (0, ce.fromHex)(e.validator_address) : void 0,
    timestamp: e.timestamp ? (0, mo.fromRfc3339WithNanoseconds)(e.timestamp) : void 0,
    signature: e.signature ? (0, ce.fromBase64)(e.signature) : void 0
  };
}
function $y(e) {
  return {
    blockId: Ys((0, j.assertObject)(e.block_id)),
    height: (0, se.apiToSmallInt)((0, j.assertNotEmpty)(e.height)),
    round: (0, se.apiToSmallInt)(e.round),
    signatures: (0, j.assertArray)(e.signatures).map(r2)
  };
}
function i2(e) {
  return {
    canonical: (0, j.assertBoolean)(e.canonical),
    header: Xs(e.signed_header.header),
    commit: $y(e.signed_header.commit)
  };
}
function Ly(e) {
  return {
    address: (0, ce.fromHex)((0, j.assertNotEmpty)(e.address)),
    pubkey: hl((0, j.assertObject)(e.pub_key)),
    votingPower: (0, se.apiToBigInt)((0, j.assertNotEmpty)(e.power))
  };
}
_n.decodeValidatorGenesis = Ly;
function o2(e) {
  return {
    genesisTime: (0, mo.fromRfc3339WithNanoseconds)((0, j.assertNotEmpty)(e.genesis_time)),
    chainId: (0, j.assertNotEmpty)(e.chain_id),
    consensusParams: Qy(e.consensus_params),
    validators: e.validators ? (0, j.assertArray)(e.validators).map(Ly) : [],
    appHash: (0, ce.fromHex)((0, j.assertSet)(e.app_hash)),
    appState: e.app_state
  };
}
function yl(e) {
  return {
    pubkey: hl((0, j.assertObject)(e.pub_key)),
    votingPower: (0, se.apiToBigInt)((0, j.assertNotEmpty)(e.voting_power)),
    address: (0, ce.fromHex)((0, j.assertNotEmpty)(e.address)),
    proposerPriority: e.proposer_priority ? (0, se.apiToSmallInt)(e.proposer_priority) : void 0
  };
}
_n.decodeValidatorInfo = yl;
function a2(e) {
  return {
    id: (0, ce.fromHex)((0, j.assertNotEmpty)(e.id)),
    listenAddr: (0, j.assertNotEmpty)(e.listen_addr),
    network: (0, j.assertNotEmpty)(e.network),
    version: (0, j.assertString)(e.version),
    channels: (0, j.assertNotEmpty)(e.channels),
    moniker: (0, j.assertNotEmpty)(e.moniker),
    other: (0, j.dictionaryToStringMap)(e.other),
    protocolVersion: {
      app: (0, se.apiToSmallInt)((0, j.assertNotEmpty)(e.protocol_version.app)),
      block: (0, se.apiToSmallInt)((0, j.assertNotEmpty)(e.protocol_version.block)),
      p2p: (0, se.apiToSmallInt)((0, j.assertNotEmpty)(e.protocol_version.p2p))
    }
  };
}
function s2(e) {
  const n = e.earliest_block_height ? (0, se.apiToSmallInt)(e.earliest_block_height) : void 0, r = e.earliest_block_time ? (0, mo.fromRfc3339WithNanoseconds)(e.earliest_block_time) : void 0;
  return {
    earliestAppHash: e.earliest_app_hash ? (0, ce.fromHex)(e.earliest_app_hash) : void 0,
    earliestBlockHash: e.earliest_block_hash ? (0, ce.fromHex)(e.earliest_block_hash) : void 0,
    earliestBlockHeight: n || void 0,
    earliestBlockTime: r != null && r.getTime() ? r : void 0,
    latestBlockHash: (0, ce.fromHex)((0, j.assertNotEmpty)(e.latest_block_hash)),
    latestAppHash: (0, ce.fromHex)((0, j.assertNotEmpty)(e.latest_app_hash)),
    latestBlockTime: (0, mo.fromRfc3339WithNanoseconds)((0, j.assertNotEmpty)(e.latest_block_time)),
    latestBlockHeight: (0, se.apiToSmallInt)((0, j.assertNotEmpty)(e.latest_block_height)),
    catchingUp: (0, j.assertBoolean)(e.catching_up)
  };
}
function d2(e) {
  return {
    nodeInfo: a2(e.node_info),
    syncInfo: s2(e.sync_info),
    validatorInfo: yl(e.validator_info)
  };
}
function u2(e) {
  return {
    data: (0, ce.fromBase64)((0, j.assertNotEmpty)(e.data)),
    rootHash: (0, ce.fromHex)((0, j.assertNotEmpty)(e.root_hash)),
    proof: {
      total: (0, se.apiToSmallInt)((0, j.assertNotEmpty)(e.proof.total)),
      index: (0, se.apiToSmallInt)((0, j.assertNotEmpty)(e.proof.index)),
      leafHash: (0, ce.fromBase64)((0, j.assertNotEmpty)(e.proof.leaf_hash)),
      aunts: (0, j.assertArray)(e.proof.aunts).map(ce.fromBase64)
    }
  };
}
function Gy(e) {
  return {
    tx: (0, ce.fromBase64)((0, j.assertNotEmpty)(e.tx)),
    result: _i((0, j.assertObject)(e.tx_result)),
    height: (0, se.apiToSmallInt)((0, j.assertNotEmpty)(e.height)),
    index: (0, se.apiToSmallInt)((0, j.assertNumber)(e.index)),
    hash: (0, ce.fromHex)((0, j.assertNotEmpty)(e.hash)),
    proof: (0, j.may)(u2, e.proof)
  };
}
function c2(e) {
  return {
    totalCount: (0, se.apiToSmallInt)((0, j.assertNotEmpty)(e.total_count)),
    txs: (0, j.assertArray)(e.txs).map(Gy)
  };
}
function l2(e) {
  const n = (0, ce.fromBase64)((0, j.assertNotEmpty)(e.tx));
  return {
    tx: n,
    hash: (0, QA.hashTx)(n),
    result: _i(e.result),
    height: (0, se.apiToSmallInt)((0, j.assertNotEmpty)(e.height))
  };
}
function f2(e) {
  return {
    blockHeight: (0, se.apiToSmallInt)((0, j.assertNotEmpty)(e.block_height)),
    validators: (0, j.assertArray)(e.validators).map(yl),
    count: (0, se.apiToSmallInt)((0, j.assertNotEmpty)(e.count)),
    total: (0, se.apiToSmallInt)((0, j.assertNotEmpty)(e.total))
  };
}
function Ky(e) {
  var n;
  return {
    header: Xs((0, j.assertObject)(e.header)),
    // For the block at height 1, last commit is not set. This is represented in an empty object like this:
    // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
    lastCommit: e.last_commit.block_id.hash ? $y((0, j.assertObject)(e.last_commit)) : null,
    txs: e.data.txs ? (0, j.assertArray)(e.data.txs).map(ce.fromBase64) : [],
    // Lift up .evidence.evidence to just .evidence
    // See https://github.com/tendermint/tendermint/issues/7697
    evidence: ((n = e.evidence) == null ? void 0 : n.evidence) ?? []
  };
}
function zy(e) {
  return {
    blockId: Ys(e.block_id),
    block: Ky(e.block)
  };
}
function p2(e) {
  return {
    totalCount: (0, se.apiToSmallInt)((0, j.assertNotEmpty)(e.total_count)),
    blocks: (0, j.assertArray)(e.blocks).map(zy)
  };
}
function h2(e) {
  return {
    total: (0, se.apiToSmallInt)((0, j.assertNotEmpty)(e.total)),
    totalBytes: (0, se.apiToSmallInt)((0, j.assertNotEmpty)(e.total_bytes))
  };
}
let y2 = class xy {
  static decodeAbciInfo(n) {
    return FA((0, j.assertObject)(n.result.response));
  }
  static decodeAbciQuery(n) {
    return LA((0, j.assertObject)(n.result.response));
  }
  static decodeBlock(n) {
    return zy(n.result);
  }
  static decodeBlockResults(n) {
    return ZA(n.result);
  }
  static decodeBlockSearch(n) {
    return p2(n.result);
  }
  static decodeBlockchain(n) {
    return jA(n.result);
  }
  static decodeBroadcastTxSync(n) {
    return e2(n.result);
  }
  static decodeBroadcastTxAsync(n) {
    return xy.decodeBroadcastTxSync(n);
  }
  static decodeBroadcastTxCommit(n) {
    return n2(n.result);
  }
  static decodeCommit(n) {
    return i2(n.result);
  }
  static decodeGenesis(n) {
    return o2((0, j.assertObject)(n.result.genesis));
  }
  static decodeHealth() {
    return null;
  }
  static decodeNumUnconfirmedTxs(n) {
    return h2(n.result);
  }
  static decodeStatus(n) {
    return d2(n.result);
  }
  static decodeNewBlockEvent(n) {
    return Ky(n.data.value.block);
  }
  static decodeNewBlockHeaderEvent(n) {
    return Xs(n.data.value.header);
  }
  static decodeTxEvent(n) {
    return l2(n.data.value.TxResult);
  }
  static decodeTx(n) {
    return Gy(n.result);
  }
  static decodeTxSearch(n) {
    return c2(n.result);
  }
  static decodeValidators(n) {
    return f2(n.result);
  }
};
_n.Responses = y2;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Responses = e.Params = void 0;
  var n = xs;
  Object.defineProperty(e, "Params", { enumerable: !0, get: function() {
    return n.Params;
  } });
  var r = _n;
  Object.defineProperty(e, "Responses", { enumerable: !0, get: function() {
    return r.Responses;
  } });
})(qy);
var m2 = x && x.__createBinding || (Object.create ? function(e, n, r, t) {
  t === void 0 && (t = r);
  var i = Object.getOwnPropertyDescriptor(n, r);
  (!i || ("get" in i ? !n.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return n[r];
  } }), Object.defineProperty(e, t, i);
} : function(e, n, r, t) {
  t === void 0 && (t = r), e[t] = n[r];
}), g2 = x && x.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), S2 = x && x.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var n = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && m2(n, e, r);
  return g2(n, e), n;
};
Object.defineProperty(Ds, "__esModule", { value: !0 });
Ds.Comet38Client = void 0;
const k2 = mt, ta = _o, fe = qy, ve = S2(Zs);
class Ua {
  /**
   * Creates a new Tendermint client for the given endpoint.
   *
   * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
   */
  static async connect(n) {
    let r;
    return typeof n == "object" ? r = new ta.HttpClient(n) : r = n.startsWith("http://") || n.startsWith("https://") ? new ta.HttpClient(n) : new ta.WebsocketClient(n), await this.detectVersion(r), Ua.create(r);
  }
  /**
   * Creates a new Tendermint client given an RPC client.
   */
  static async create(n) {
    return new Ua(n);
  }
  static async detectVersion(n) {
    const r = (0, k2.createJsonRpcRequest)(ve.Method.Status), i = (await n.execute(r)).result;
    if (!i || !i.node_info)
      throw new Error("Unrecognized format for status response");
    const f = i.node_info.version;
    if (typeof f != "string")
      throw new Error("Unrecognized version format: must be string");
    return f;
  }
  /**
   * Use `Tendermint37Client.connect` or `Tendermint37Client.create` to create an instance.
   */
  constructor(n) {
    this.client = n;
  }
  disconnect() {
    this.client.disconnect();
  }
  async abciInfo() {
    const n = { method: ve.Method.AbciInfo };
    return this.doCall(n, fe.Params.encodeAbciInfo, fe.Responses.decodeAbciInfo);
  }
  async abciQuery(n) {
    const r = { params: n, method: ve.Method.AbciQuery };
    return this.doCall(r, fe.Params.encodeAbciQuery, fe.Responses.decodeAbciQuery);
  }
  async block(n) {
    const r = { method: ve.Method.Block, params: { height: n } };
    return this.doCall(r, fe.Params.encodeBlock, fe.Responses.decodeBlock);
  }
  async blockResults(n) {
    const r = {
      method: ve.Method.BlockResults,
      params: { height: n }
    };
    return this.doCall(r, fe.Params.encodeBlockResults, fe.Responses.decodeBlockResults);
  }
  /**
   * Search for events that are in a block.
   *
   * NOTE
   * This method will error on any node that is running a Tendermint version lower than 0.34.9.
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
   */
  async blockSearch(n) {
    const r = { params: n, method: ve.Method.BlockSearch }, t = await this.doCall(r, fe.Params.encodeBlockSearch, fe.Responses.decodeBlockSearch);
    return {
      ...t,
      // make sure we sort by height, as tendermint may be sorting by string value of the height
      blocks: [...t.blocks].sort((i, f) => i.block.header.height - f.block.header.height)
    };
  }
  // this should paginate through all blockSearch options to ensure it returns all results.
  // starts with page 1 or whatever was provided (eg. to start on page 7)
  //
  // NOTE
  // This method will error on any node that is running a Tendermint version lower than 0.34.9.
  async blockSearchAll(n) {
    let r = n.page || 1;
    const t = [];
    let i = !1;
    for (; !i; ) {
      const f = await this.blockSearch({ ...n, page: r });
      t.push(...f.blocks), t.length < f.totalCount ? r++ : i = !0;
    }
    return t.sort((f, S) => f.block.header.height - S.block.header.height), {
      totalCount: t.length,
      blocks: t
    };
  }
  /**
   * Queries block headers filtered by minHeight <= height <= maxHeight.
   *
   * @param minHeight The minimum height to be included in the result. Defaults to 0.
   * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
   */
  async blockchain(n, r) {
    const t = {
      method: ve.Method.Blockchain,
      params: {
        minHeight: n,
        maxHeight: r
      }
    };
    return this.doCall(t, fe.Params.encodeBlockchain, fe.Responses.decodeBlockchain);
  }
  /**
   * Broadcast transaction to mempool and wait for response
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
   */
  async broadcastTxSync(n) {
    const r = { params: n, method: ve.Method.BroadcastTxSync };
    return this.doCall(r, fe.Params.encodeBroadcastTx, fe.Responses.decodeBroadcastTxSync);
  }
  /**
   * Broadcast transaction to mempool and do not wait for result
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
   */
  async broadcastTxAsync(n) {
    const r = { params: n, method: ve.Method.BroadcastTxAsync };
    return this.doCall(r, fe.Params.encodeBroadcastTx, fe.Responses.decodeBroadcastTxAsync);
  }
  /**
   * Broadcast transaction to mempool and wait for block
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
   */
  async broadcastTxCommit(n) {
    const r = { params: n, method: ve.Method.BroadcastTxCommit };
    return this.doCall(r, fe.Params.encodeBroadcastTx, fe.Responses.decodeBroadcastTxCommit);
  }
  async commit(n) {
    const r = { method: ve.Method.Commit, params: { height: n } };
    return this.doCall(r, fe.Params.encodeCommit, fe.Responses.decodeCommit);
  }
  async genesis() {
    const n = { method: ve.Method.Genesis };
    return this.doCall(n, fe.Params.encodeGenesis, fe.Responses.decodeGenesis);
  }
  async health() {
    const n = { method: ve.Method.Health };
    return this.doCall(n, fe.Params.encodeHealth, fe.Responses.decodeHealth);
  }
  async numUnconfirmedTxs() {
    const n = { method: ve.Method.NumUnconfirmedTxs };
    return this.doCall(n, fe.Params.encodeNumUnconfirmedTxs, fe.Responses.decodeNumUnconfirmedTxs);
  }
  async status() {
    const n = { method: ve.Method.Status };
    return this.doCall(n, fe.Params.encodeStatus, fe.Responses.decodeStatus);
  }
  subscribeNewBlock() {
    const n = {
      method: ve.Method.Subscribe,
      query: { type: ve.SubscriptionEventType.NewBlock }
    };
    return this.subscribe(n, fe.Responses.decodeNewBlockEvent);
  }
  subscribeNewBlockHeader() {
    const n = {
      method: ve.Method.Subscribe,
      query: { type: ve.SubscriptionEventType.NewBlockHeader }
    };
    return this.subscribe(n, fe.Responses.decodeNewBlockHeaderEvent);
  }
  subscribeTx(n) {
    const r = {
      method: ve.Method.Subscribe,
      query: {
        type: ve.SubscriptionEventType.Tx,
        raw: n
      }
    };
    return this.subscribe(r, fe.Responses.decodeTxEvent);
  }
  /**
   * Get a single transaction by hash
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/tx
   */
  async tx(n) {
    const r = { params: n, method: ve.Method.Tx };
    return this.doCall(r, fe.Params.encodeTx, fe.Responses.decodeTx);
  }
  /**
   * Search for transactions that are in a block
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
   */
  async txSearch(n) {
    const r = { params: n, method: ve.Method.TxSearch };
    return this.doCall(r, fe.Params.encodeTxSearch, fe.Responses.decodeTxSearch);
  }
  // this should paginate through all txSearch options to ensure it returns all results.
  // starts with page 1 or whatever was provided (eg. to start on page 7)
  async txSearchAll(n) {
    let r = n.page || 1;
    const t = [];
    let i = !1;
    for (; !i; ) {
      const f = await this.txSearch({ ...n, page: r });
      t.push(...f.txs), t.length < f.totalCount ? r++ : i = !0;
    }
    return {
      totalCount: t.length,
      txs: t
    };
  }
  async validators(n) {
    const r = {
      method: ve.Method.Validators,
      params: n
    };
    return this.doCall(r, fe.Params.encodeValidators, fe.Responses.decodeValidators);
  }
  async validatorsAll(n) {
    const r = [];
    let t = 1, i = !1, f = n;
    for (; !i; ) {
      const S = await this.validators({
        per_page: 50,
        height: f,
        page: t
      });
      r.push(...S.validators), f = f || S.blockHeight, r.length < S.total ? t++ : i = !0;
    }
    return {
      // NOTE: Default value is for type safety but this should always be set
      blockHeight: f ?? 0,
      count: r.length,
      total: r.length,
      validators: r
    };
  }
  // doCall is a helper to handle the encode/call/decode logic
  async doCall(n, r, t) {
    const i = r(n), f = await this.client.execute(i);
    return t(f);
  }
  subscribe(n, r) {
    if (!(0, ta.instanceOfRpcStreamingClient)(this.client))
      throw new Error("This RPC client type cannot subscribe to events");
    const t = fe.Params.encodeSubscribe(n);
    return this.client.listen(t).map((f) => r(f));
  }
}
Ds.Comet38Client = Ua;
var Zy = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.VoteType = e.broadcastTxCommitSuccess = e.broadcastTxSyncSuccess = void 0;
  function n(t) {
    return t.code === 0;
  }
  e.broadcastTxSyncSuccess = n;
  function r(t) {
    return t.checkTx.code === 0 && !!t.deliverTx && t.deliverTx.code === 0;
  }
  e.broadcastTxCommitSuccess = r, function(t) {
    t[t.PreVote = 1] = "PreVote", t[t.PreCommit = 2] = "PreCommit";
  }(e.VoteType || (e.VoteType = {}));
})(Zy);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.VoteType = e.broadcastTxSyncSuccess = e.broadcastTxCommitSuccess = e.SubscriptionEventType = e.Method = e.Comet38Client = void 0;
  var n = Ds;
  Object.defineProperty(e, "Comet38Client", { enumerable: !0, get: function() {
    return n.Comet38Client;
  } });
  var r = Zs;
  Object.defineProperty(e, "Method", { enumerable: !0, get: function() {
    return r.Method;
  } }), Object.defineProperty(e, "SubscriptionEventType", { enumerable: !0, get: function() {
    return r.SubscriptionEventType;
  } });
  var t = Zy;
  Object.defineProperty(e, "broadcastTxCommitSuccess", { enumerable: !0, get: function() {
    return t.broadcastTxCommitSuccess;
  } }), Object.defineProperty(e, "broadcastTxSyncSuccess", { enumerable: !0, get: function() {
    return t.broadcastTxSyncSuccess;
  } }), Object.defineProperty(e, "VoteType", { enumerable: !0, get: function() {
    return t.VoteType;
  } });
})(Na);
var lo = {}, js = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.buildQuery = e.SubscriptionEventType = e.Method = void 0, function(r) {
    r.AbciInfo = "abci_info", r.AbciQuery = "abci_query", r.Block = "block", r.Blockchain = "blockchain", r.BlockResults = "block_results", r.BlockSearch = "block_search", r.BroadcastTxAsync = "broadcast_tx_async", r.BroadcastTxSync = "broadcast_tx_sync", r.BroadcastTxCommit = "broadcast_tx_commit", r.Commit = "commit", r.Genesis = "genesis", r.Health = "health", r.NumUnconfirmedTxs = "num_unconfirmed_txs", r.Status = "status", r.Subscribe = "subscribe", r.Tx = "tx", r.TxSearch = "tx_search", r.Validators = "validators", r.Unsubscribe = "unsubscribe";
  }(e.Method || (e.Method = {})), function(r) {
    r.NewBlock = "NewBlock", r.NewBlockHeader = "NewBlockHeader", r.Tx = "Tx";
  }(e.SubscriptionEventType || (e.SubscriptionEventType = {}));
  function n(r) {
    const i = (r.tags ? r.tags : []).map((S) => `${S.key}='${S.value}'`), f = r.raw ? [r.raw] : [];
    return [...i, ...f].join(" AND ");
  }
  e.buildQuery = n;
})(js);
var Yy = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.VoteType = e.broadcastTxCommitSuccess = e.broadcastTxSyncSuccess = void 0;
  function n(t) {
    return t.code === 0;
  }
  e.broadcastTxSyncSuccess = n;
  function r(t) {
    return t.checkTx.code === 0 && !!t.deliverTx && t.deliverTx.code === 0;
  }
  e.broadcastTxCommitSuccess = r, function(t) {
    t[t.PreVote = 1] = "PreVote", t[t.PreCommit = 2] = "PreCommit";
  }(e.VoteType || (e.VoteType = {}));
})(Yy);
var ed = {}, Xy = {}, nd = {}, P2 = x && x.__createBinding || (Object.create ? function(e, n, r, t) {
  t === void 0 && (t = r);
  var i = Object.getOwnPropertyDescriptor(n, r);
  (!i || ("get" in i ? !n.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return n[r];
  } }), Object.defineProperty(e, t, i);
} : function(e, n, r, t) {
  t === void 0 && (t = r), e[t] = n[r];
}), v2 = x && x.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), b2 = x && x.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var n = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && P2(n, e, r);
  return v2(n, e), n;
};
Object.defineProperty(nd, "__esModule", { value: !0 });
nd.Params = void 0;
const ml = Wn, Gn = Pn, We = mt, ln = me, R2 = b2(js);
function Du(e) {
  return {
    height: (0, ln.may)(Gn.smallIntToApi, e.height)
  };
}
function B2(e) {
  return {
    minHeight: (0, ln.may)(Gn.smallIntToApi, e.minHeight),
    maxHeight: (0, ln.may)(Gn.smallIntToApi, e.maxHeight)
  };
}
function O2(e) {
  return {
    query: e.query,
    page: (0, ln.may)(Gn.smallIntToApi, e.page),
    per_page: (0, ln.may)(Gn.smallIntToApi, e.per_page),
    order_by: e.order_by
  };
}
function A2(e) {
  return {
    path: (0, ln.assertNotEmpty)(e.path),
    data: (0, ml.toHex)(e.data),
    height: (0, ln.may)(Gn.smallIntToApi, e.height),
    prove: e.prove
  };
}
function I2(e) {
  return {
    tx: (0, ml.toBase64)((0, ln.assertNotEmpty)(e.tx))
  };
}
function T2(e) {
  return {
    hash: (0, ml.toBase64)((0, ln.assertNotEmpty)(e.hash)),
    prove: e.prove
  };
}
function w2(e) {
  return {
    query: e.query,
    prove: e.prove,
    page: (0, ln.may)(Gn.smallIntToApi, e.page),
    per_page: (0, ln.may)(Gn.smallIntToApi, e.per_page),
    order_by: e.order_by
  };
}
function C2(e) {
  return {
    height: (0, ln.may)(Gn.smallIntToApi, e.height),
    page: (0, ln.may)(Gn.smallIntToApi, e.page),
    per_page: (0, ln.may)(Gn.smallIntToApi, e.per_page)
  };
}
let N2 = class {
  static encodeAbciInfo(n) {
    return (0, We.createJsonRpcRequest)(n.method);
  }
  static encodeAbciQuery(n) {
    return (0, We.createJsonRpcRequest)(n.method, A2(n.params));
  }
  static encodeBlock(n) {
    return (0, We.createJsonRpcRequest)(n.method, Du(n.params));
  }
  static encodeBlockchain(n) {
    return (0, We.createJsonRpcRequest)(n.method, B2(n.params));
  }
  static encodeBlockResults(n) {
    return (0, We.createJsonRpcRequest)(n.method, Du(n.params));
  }
  static encodeBlockSearch(n) {
    return (0, We.createJsonRpcRequest)(n.method, O2(n.params));
  }
  static encodeBroadcastTx(n) {
    return (0, We.createJsonRpcRequest)(n.method, I2(n.params));
  }
  static encodeCommit(n) {
    return (0, We.createJsonRpcRequest)(n.method, Du(n.params));
  }
  static encodeGenesis(n) {
    return (0, We.createJsonRpcRequest)(n.method);
  }
  static encodeHealth(n) {
    return (0, We.createJsonRpcRequest)(n.method);
  }
  static encodeNumUnconfirmedTxs(n) {
    return (0, We.createJsonRpcRequest)(n.method);
  }
  static encodeStatus(n) {
    return (0, We.createJsonRpcRequest)(n.method);
  }
  static encodeSubscribe(n) {
    const r = { key: "tm.event", value: n.query.type }, t = R2.buildQuery({ tags: [r], raw: n.query.raw });
    return (0, We.createJsonRpcRequest)("subscribe", { query: t });
  }
  static encodeTx(n) {
    return (0, We.createJsonRpcRequest)(n.method, T2(n.params));
  }
  // TODO: encode params for query string???
  static encodeTxSearch(n) {
    return (0, We.createJsonRpcRequest)(n.method, w2(n.params));
  }
  static encodeValidators(n) {
    return (0, We.createJsonRpcRequest)(n.method, C2(n.params));
  }
};
nd.Params = N2;
var En = {}, Ei = {};
Object.defineProperty(Ei, "__esModule", { value: !0 });
Ei.hashBlock = Ei.hashTx = void 0;
const gl = _e, en = me;
function _2(e) {
  return (0, gl.sha256)(e);
}
Ei.hashTx = _2;
function E2(e) {
  if (e < 1)
    throw new Error("Cannot split an empty tree");
  const n = 2 ** Math.floor(Math.log2(e));
  return n < e ? n : n / 2;
}
function U2(e) {
  const n = new gl.Sha256(Uint8Array.from([0]));
  return n.update(e), n.digest();
}
function J2(e, n) {
  const r = new gl.Sha256(Uint8Array.from([1]));
  return r.update(e), r.update(n), r.digest();
}
function Sc(e) {
  switch (e.length) {
    case 0:
      throw new Error("Cannot hash empty tree");
    case 1:
      return U2(e[0]);
    default: {
      const n = E2(e.length), r = Sc(e.slice(0, n)), t = Sc(e.slice(n));
      return J2(r, t);
    }
  }
}
function D2(e) {
  if (!e.lastBlockId)
    throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
  const n = [
    (0, en.encodeVersion)(e.version),
    (0, en.encodeString)(e.chainId),
    (0, en.encodeUvarint)(e.height),
    (0, en.encodeTime)(e.time),
    (0, en.encodeBlockId)(e.lastBlockId),
    (0, en.encodeBytes)(e.lastCommitHash),
    (0, en.encodeBytes)(e.dataHash),
    (0, en.encodeBytes)(e.validatorsHash),
    (0, en.encodeBytes)(e.nextValidatorsHash),
    (0, en.encodeBytes)(e.consensusHash),
    (0, en.encodeBytes)(e.appHash),
    (0, en.encodeBytes)(e.lastResultsHash),
    (0, en.encodeBytes)(e.evidenceHash),
    (0, en.encodeBytes)(e.proposerAddress)
  ];
  return Sc(n);
}
Ei.hashBlock = D2;
Object.defineProperty(En, "__esModule", { value: !0 });
En.Responses = En.decodeValidatorInfo = En.decodeValidatorGenesis = En.decodeValidatorUpdate = En.decodeEvent = void 0;
const ae = Wn, jy = Te, go = Ze, de = Pn, M2 = Ho, Y = me, H2 = Ei;
function q2(e) {
  return {
    data: e.data,
    lastBlockHeight: (0, Y.may)(de.apiToSmallInt, e.last_block_height),
    lastBlockAppHash: (0, Y.may)(ae.fromBase64, e.last_block_app_hash)
  };
}
function V2(e) {
  return {
    ops: e.ops.map((n) => ({
      type: n.type,
      key: (0, ae.fromBase64)(n.key),
      data: (0, ae.fromBase64)(n.data)
    }))
  };
}
function W2(e) {
  return {
    key: (0, ae.fromBase64)((0, Y.assertString)(e.key ?? "")),
    value: (0, ae.fromBase64)((0, Y.assertString)(e.value ?? "")),
    proof: (0, Y.may)(V2, e.proofOps),
    height: (0, Y.may)(de.apiToSmallInt, e.height),
    code: (0, Y.may)(de.apiToSmallInt, e.code),
    codespace: (0, Y.assertString)(e.codespace ?? ""),
    index: (0, Y.may)(de.apiToSmallInt, e.index),
    log: e.log,
    info: (0, Y.assertString)(e.info ?? "")
  };
}
function Q2(e) {
  return {
    key: (0, ae.fromBase64)((0, Y.assertNotEmpty)(e.key)),
    value: (0, ae.fromBase64)((0, Y.assertString)(e.value ?? ""))
  };
}
function F2(e) {
  return (0, Y.assertArray)(e).map(Q2);
}
function em(e) {
  return {
    type: e.type,
    attributes: e.attributes ? F2(e.attributes) : []
  };
}
En.decodeEvent = em;
function kc(e) {
  return (0, Y.assertArray)(e).map(em);
}
function Ui(e) {
  return {
    code: (0, de.apiToSmallInt)((0, Y.assertNumber)(e.code ?? 0)),
    codespace: e.codespace,
    log: e.log,
    data: (0, Y.may)(ae.fromBase64, e.data),
    events: e.events ? kc(e.events) : [],
    gasWanted: (0, de.apiToBigInt)(e.gas_wanted ?? "0"),
    gasUsed: (0, de.apiToBigInt)(e.gas_used ?? "0")
  };
}
function Sl(e) {
  if ("Sum" in e) {
    const [[n, r]] = Object.entries(e.Sum.value);
    return (0, jy.assert)(n === "ed25519" || n === "secp256k1", `unknown pubkey type: ${n}`), {
      algorithm: n,
      data: (0, ae.fromBase64)((0, Y.assertNotEmpty)(r))
    };
  } else
    switch (e.type) {
      case "tendermint/PubKeyEd25519":
        return {
          algorithm: "ed25519",
          data: (0, ae.fromBase64)((0, Y.assertNotEmpty)(e.value))
        };
      case "tendermint/PubKeySecp256k1":
        return {
          algorithm: "secp256k1",
          data: (0, ae.fromBase64)((0, Y.assertNotEmpty)(e.value))
        };
      default:
        throw new Error(`unknown pubkey type: ${e.type}`);
    }
}
function $2(e) {
  return {
    maxBytes: (0, de.apiToSmallInt)((0, Y.assertNotEmpty)(e.max_bytes)),
    maxGas: (0, de.apiToSmallInt)((0, Y.assertNotEmpty)(e.max_gas))
  };
}
function L2(e) {
  return {
    maxAgeNumBlocks: (0, de.apiToSmallInt)((0, Y.assertNotEmpty)(e.max_age_num_blocks)),
    maxAgeDuration: (0, de.apiToSmallInt)((0, Y.assertNotEmpty)(e.max_age_duration))
  };
}
function nm(e) {
  return {
    block: $2((0, Y.assertObject)(e.block)),
    evidence: L2((0, Y.assertObject)(e.evidence))
  };
}
function tm(e) {
  return {
    pubkey: Sl((0, Y.assertObject)(e.pub_key)),
    votingPower: (0, de.apiToBigInt)(e.power ?? "0")
  };
}
En.decodeValidatorUpdate = tm;
function G2(e) {
  return {
    height: (0, de.apiToSmallInt)((0, Y.assertNotEmpty)(e.height)),
    results: (e.txs_results || []).map(Ui),
    validatorUpdates: (e.validator_updates || []).map(tm),
    consensusUpdates: (0, Y.may)(nm, e.consensus_param_updates),
    beginBlockEvents: kc(e.begin_block_events || []),
    endBlockEvents: kc(e.end_block_events || [])
  };
}
function td(e) {
  return {
    hash: (0, ae.fromHex)((0, Y.assertNotEmpty)(e.hash)),
    parts: {
      total: (0, Y.assertNotEmpty)(e.parts.total),
      hash: (0, ae.fromHex)((0, Y.assertNotEmpty)(e.parts.hash))
    }
  };
}
function K2(e) {
  return {
    block: (0, de.apiToSmallInt)(e.block),
    app: (0, de.apiToSmallInt)(e.app ?? 0)
  };
}
function rd(e) {
  return {
    version: K2(e.version),
    chainId: (0, Y.assertNotEmpty)(e.chain_id),
    height: (0, de.apiToSmallInt)((0, Y.assertNotEmpty)(e.height)),
    time: (0, go.fromRfc3339WithNanoseconds)((0, Y.assertNotEmpty)(e.time)),
    // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
    // { hash: '', parts: { total: 0, hash: '' } }
    lastBlockId: e.last_block_id.hash ? td(e.last_block_id) : null,
    lastCommitHash: (0, ae.fromHex)((0, Y.assertSet)(e.last_commit_hash)),
    dataHash: (0, ae.fromHex)((0, Y.assertSet)(e.data_hash)),
    validatorsHash: (0, ae.fromHex)((0, Y.assertSet)(e.validators_hash)),
    nextValidatorsHash: (0, ae.fromHex)((0, Y.assertSet)(e.next_validators_hash)),
    consensusHash: (0, ae.fromHex)((0, Y.assertSet)(e.consensus_hash)),
    appHash: (0, ae.fromHex)((0, Y.assertSet)(e.app_hash)),
    lastResultsHash: (0, ae.fromHex)((0, Y.assertSet)(e.last_results_hash)),
    evidenceHash: (0, ae.fromHex)((0, Y.assertSet)(e.evidence_hash)),
    proposerAddress: (0, ae.fromHex)((0, Y.assertNotEmpty)(e.proposer_address))
  };
}
function z2(e) {
  return {
    blockId: td(e.block_id),
    blockSize: (0, de.apiToSmallInt)((0, Y.assertNotEmpty)(e.block_size)),
    header: rd(e.header),
    numTxs: (0, de.apiToSmallInt)((0, Y.assertNotEmpty)(e.num_txs))
  };
}
function x2(e) {
  return {
    lastHeight: (0, de.apiToSmallInt)((0, Y.assertNotEmpty)(e.last_height)),
    blockMetas: (0, Y.assertArray)(e.block_metas).map(z2)
  };
}
function Z2(e) {
  return {
    ...Ui(e),
    hash: (0, ae.fromHex)((0, Y.assertNotEmpty)(e.hash))
  };
}
function Y2(e) {
  return {
    height: (0, de.apiToSmallInt)(e.height),
    hash: (0, ae.fromHex)((0, Y.assertNotEmpty)(e.hash)),
    checkTx: Ui((0, Y.assertObject)(e.check_tx)),
    deliverTx: (0, Y.may)(Ui, e.deliver_tx)
  };
}
function X2(e) {
  return (0, jy.assert)(e in M2.BlockIdFlag), e;
}
function j2(e) {
  return {
    blockIdFlag: X2(e.block_id_flag),
    validatorAddress: e.validator_address ? (0, ae.fromHex)(e.validator_address) : void 0,
    timestamp: e.timestamp ? (0, go.fromRfc3339WithNanoseconds)(e.timestamp) : void 0,
    signature: e.signature ? (0, ae.fromBase64)(e.signature) : void 0
  };
}
function rm(e) {
  return {
    blockId: td((0, Y.assertObject)(e.block_id)),
    height: (0, de.apiToSmallInt)((0, Y.assertNotEmpty)(e.height)),
    round: (0, de.apiToSmallInt)(e.round),
    signatures: (0, Y.assertArray)(e.signatures).map(j2)
  };
}
function e3(e) {
  return {
    canonical: (0, Y.assertBoolean)(e.canonical),
    header: rd(e.signed_header.header),
    commit: rm(e.signed_header.commit)
  };
}
function im(e) {
  return {
    address: (0, ae.fromHex)((0, Y.assertNotEmpty)(e.address)),
    pubkey: Sl((0, Y.assertObject)(e.pub_key)),
    votingPower: (0, de.apiToBigInt)((0, Y.assertNotEmpty)(e.power))
  };
}
En.decodeValidatorGenesis = im;
function n3(e) {
  return {
    genesisTime: (0, go.fromRfc3339WithNanoseconds)((0, Y.assertNotEmpty)(e.genesis_time)),
    chainId: (0, Y.assertNotEmpty)(e.chain_id),
    consensusParams: nm(e.consensus_params),
    validators: e.validators ? (0, Y.assertArray)(e.validators).map(im) : [],
    appHash: (0, ae.fromHex)((0, Y.assertSet)(e.app_hash)),
    appState: e.app_state
  };
}
function kl(e) {
  return {
    pubkey: Sl((0, Y.assertObject)(e.pub_key)),
    votingPower: (0, de.apiToBigInt)((0, Y.assertNotEmpty)(e.voting_power)),
    address: (0, ae.fromHex)((0, Y.assertNotEmpty)(e.address)),
    proposerPriority: e.proposer_priority ? (0, de.apiToSmallInt)(e.proposer_priority) : void 0
  };
}
En.decodeValidatorInfo = kl;
function t3(e) {
  return {
    id: (0, ae.fromHex)((0, Y.assertNotEmpty)(e.id)),
    listenAddr: (0, Y.assertNotEmpty)(e.listen_addr),
    network: (0, Y.assertNotEmpty)(e.network),
    version: (0, Y.assertString)(e.version),
    channels: (0, Y.assertNotEmpty)(e.channels),
    moniker: (0, Y.assertNotEmpty)(e.moniker),
    other: (0, Y.dictionaryToStringMap)(e.other),
    protocolVersion: {
      app: (0, de.apiToSmallInt)((0, Y.assertNotEmpty)(e.protocol_version.app)),
      block: (0, de.apiToSmallInt)((0, Y.assertNotEmpty)(e.protocol_version.block)),
      p2p: (0, de.apiToSmallInt)((0, Y.assertNotEmpty)(e.protocol_version.p2p))
    }
  };
}
function r3(e) {
  const n = e.earliest_block_height ? (0, de.apiToSmallInt)(e.earliest_block_height) : void 0, r = e.earliest_block_time ? (0, go.fromRfc3339WithNanoseconds)(e.earliest_block_time) : void 0;
  return {
    earliestAppHash: e.earliest_app_hash ? (0, ae.fromHex)(e.earliest_app_hash) : void 0,
    earliestBlockHash: e.earliest_block_hash ? (0, ae.fromHex)(e.earliest_block_hash) : void 0,
    earliestBlockHeight: n || void 0,
    earliestBlockTime: r != null && r.getTime() ? r : void 0,
    latestBlockHash: (0, ae.fromHex)((0, Y.assertNotEmpty)(e.latest_block_hash)),
    latestAppHash: (0, ae.fromHex)((0, Y.assertNotEmpty)(e.latest_app_hash)),
    latestBlockTime: (0, go.fromRfc3339WithNanoseconds)((0, Y.assertNotEmpty)(e.latest_block_time)),
    latestBlockHeight: (0, de.apiToSmallInt)((0, Y.assertNotEmpty)(e.latest_block_height)),
    catchingUp: (0, Y.assertBoolean)(e.catching_up)
  };
}
function i3(e) {
  return {
    nodeInfo: t3(e.node_info),
    syncInfo: r3(e.sync_info),
    validatorInfo: kl(e.validator_info)
  };
}
function o3(e) {
  return {
    data: (0, ae.fromBase64)((0, Y.assertNotEmpty)(e.data)),
    rootHash: (0, ae.fromHex)((0, Y.assertNotEmpty)(e.root_hash)),
    proof: {
      total: (0, de.apiToSmallInt)((0, Y.assertNotEmpty)(e.proof.total)),
      index: (0, de.apiToSmallInt)((0, Y.assertNotEmpty)(e.proof.index)),
      leafHash: (0, ae.fromBase64)((0, Y.assertNotEmpty)(e.proof.leaf_hash)),
      aunts: (0, Y.assertArray)(e.proof.aunts).map(ae.fromBase64)
    }
  };
}
function om(e) {
  return {
    tx: (0, ae.fromBase64)((0, Y.assertNotEmpty)(e.tx)),
    result: Ui((0, Y.assertObject)(e.tx_result)),
    height: (0, de.apiToSmallInt)((0, Y.assertNotEmpty)(e.height)),
    index: (0, de.apiToSmallInt)((0, Y.assertNumber)(e.index)),
    hash: (0, ae.fromHex)((0, Y.assertNotEmpty)(e.hash)),
    proof: (0, Y.may)(o3, e.proof)
  };
}
function a3(e) {
  return {
    totalCount: (0, de.apiToSmallInt)((0, Y.assertNotEmpty)(e.total_count)),
    txs: (0, Y.assertArray)(e.txs).map(om)
  };
}
function s3(e) {
  const n = (0, ae.fromBase64)((0, Y.assertNotEmpty)(e.tx));
  return {
    tx: n,
    hash: (0, H2.hashTx)(n),
    result: Ui(e.result),
    height: (0, de.apiToSmallInt)((0, Y.assertNotEmpty)(e.height))
  };
}
function d3(e) {
  return {
    blockHeight: (0, de.apiToSmallInt)((0, Y.assertNotEmpty)(e.block_height)),
    validators: (0, Y.assertArray)(e.validators).map(kl),
    count: (0, de.apiToSmallInt)((0, Y.assertNotEmpty)(e.count)),
    total: (0, de.apiToSmallInt)((0, Y.assertNotEmpty)(e.total))
  };
}
function am(e) {
  var n;
  return {
    header: rd((0, Y.assertObject)(e.header)),
    // For the block at height 1, last commit is not set. This is represented in an empty object like this:
    // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
    lastCommit: e.last_commit.block_id.hash ? rm((0, Y.assertObject)(e.last_commit)) : null,
    txs: e.data.txs ? (0, Y.assertArray)(e.data.txs).map(ae.fromBase64) : [],
    // Lift up .evidence.evidence to just .evidence
    // See https://github.com/tendermint/tendermint/issues/7697
    evidence: ((n = e.evidence) == null ? void 0 : n.evidence) ?? []
  };
}
function sm(e) {
  return {
    blockId: td(e.block_id),
    block: am(e.block)
  };
}
function u3(e) {
  return {
    totalCount: (0, de.apiToSmallInt)((0, Y.assertNotEmpty)(e.total_count)),
    blocks: (0, Y.assertArray)(e.blocks).map(sm)
  };
}
function c3(e) {
  return {
    total: (0, de.apiToSmallInt)((0, Y.assertNotEmpty)(e.total)),
    totalBytes: (0, de.apiToSmallInt)((0, Y.assertNotEmpty)(e.total_bytes))
  };
}
let l3 = class dm {
  static decodeAbciInfo(n) {
    return q2((0, Y.assertObject)(n.result.response));
  }
  static decodeAbciQuery(n) {
    return W2((0, Y.assertObject)(n.result.response));
  }
  static decodeBlock(n) {
    return sm(n.result);
  }
  static decodeBlockResults(n) {
    return G2(n.result);
  }
  static decodeBlockSearch(n) {
    return u3(n.result);
  }
  static decodeBlockchain(n) {
    return x2(n.result);
  }
  static decodeBroadcastTxSync(n) {
    return Z2(n.result);
  }
  static decodeBroadcastTxAsync(n) {
    return dm.decodeBroadcastTxSync(n);
  }
  static decodeBroadcastTxCommit(n) {
    return Y2(n.result);
  }
  static decodeCommit(n) {
    return e3(n.result);
  }
  static decodeGenesis(n) {
    return n3((0, Y.assertObject)(n.result.genesis));
  }
  static decodeHealth() {
    return null;
  }
  static decodeNumUnconfirmedTxs(n) {
    return c3(n.result);
  }
  static decodeStatus(n) {
    return i3(n.result);
  }
  static decodeNewBlockEvent(n) {
    return am(n.data.value.block);
  }
  static decodeNewBlockHeaderEvent(n) {
    return rd(n.data.value.header);
  }
  static decodeTxEvent(n) {
    return s3(n.data.value.TxResult);
  }
  static decodeTx(n) {
    return om(n.result);
  }
  static decodeTxSearch(n) {
    return a3(n.result);
  }
  static decodeValidators(n) {
    return d3(n.result);
  }
};
En.Responses = l3;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Responses = e.Params = void 0;
  var n = nd;
  Object.defineProperty(e, "Params", { enumerable: !0, get: function() {
    return n.Params;
  } });
  var r = En;
  Object.defineProperty(e, "Responses", { enumerable: !0, get: function() {
    return r.Responses;
  } });
})(Xy);
var f3 = x && x.__createBinding || (Object.create ? function(e, n, r, t) {
  t === void 0 && (t = r);
  var i = Object.getOwnPropertyDescriptor(n, r);
  (!i || ("get" in i ? !n.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return n[r];
  } }), Object.defineProperty(e, t, i);
} : function(e, n, r, t) {
  t === void 0 && (t = r), e[t] = n[r];
}), p3 = x && x.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), h3 = x && x.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var n = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && f3(n, e, r);
  return p3(n, e), n;
};
Object.defineProperty(ed, "__esModule", { value: !0 });
ed.Tendermint34Client = void 0;
const y3 = mt, ra = _o, pe = Xy, be = h3(js);
class Ja {
  /**
   * Creates a new Tendermint client for the given endpoint.
   *
   * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
   */
  static async connect(n) {
    let r;
    return typeof n == "object" ? r = new ra.HttpClient(n) : r = n.startsWith("http://") || n.startsWith("https://") ? new ra.HttpClient(n) : new ra.WebsocketClient(n), await this.detectVersion(r), Ja.create(r);
  }
  /**
   * Creates a new Tendermint client given an RPC client.
   */
  static async create(n) {
    return new Ja(n);
  }
  static async detectVersion(n) {
    const r = (0, y3.createJsonRpcRequest)(be.Method.Status), i = (await n.execute(r)).result;
    if (!i || !i.node_info)
      throw new Error("Unrecognized format for status response");
    const f = i.node_info.version;
    if (typeof f != "string")
      throw new Error("Unrecognized version format: must be string");
    return f;
  }
  /**
   * Use `Tendermint34Client.connect` or `Tendermint34Client.create` to create an instance.
   */
  constructor(n) {
    this.client = n;
  }
  disconnect() {
    this.client.disconnect();
  }
  async abciInfo() {
    const n = { method: be.Method.AbciInfo };
    return this.doCall(n, pe.Params.encodeAbciInfo, pe.Responses.decodeAbciInfo);
  }
  async abciQuery(n) {
    const r = { params: n, method: be.Method.AbciQuery };
    return this.doCall(r, pe.Params.encodeAbciQuery, pe.Responses.decodeAbciQuery);
  }
  async block(n) {
    const r = { method: be.Method.Block, params: { height: n } };
    return this.doCall(r, pe.Params.encodeBlock, pe.Responses.decodeBlock);
  }
  async blockResults(n) {
    const r = {
      method: be.Method.BlockResults,
      params: { height: n }
    };
    return this.doCall(r, pe.Params.encodeBlockResults, pe.Responses.decodeBlockResults);
  }
  /**
   * Search for events that are in a block.
   *
   * NOTE
   * This method will error on any node that is running a Tendermint version lower than 0.34.9.
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
   */
  async blockSearch(n) {
    const r = { params: n, method: be.Method.BlockSearch }, t = await this.doCall(r, pe.Params.encodeBlockSearch, pe.Responses.decodeBlockSearch);
    return {
      ...t,
      // make sure we sort by height, as tendermint may be sorting by string value of the height
      blocks: [...t.blocks].sort((i, f) => i.block.header.height - f.block.header.height)
    };
  }
  // this should paginate through all blockSearch options to ensure it returns all results.
  // starts with page 1 or whatever was provided (eg. to start on page 7)
  //
  // NOTE
  // This method will error on any node that is running a Tendermint version lower than 0.34.9.
  async blockSearchAll(n) {
    let r = n.page || 1;
    const t = [];
    let i = !1;
    for (; !i; ) {
      const f = await this.blockSearch({ ...n, page: r });
      t.push(...f.blocks), t.length < f.totalCount ? r++ : i = !0;
    }
    return t.sort((f, S) => f.block.header.height - S.block.header.height), {
      totalCount: t.length,
      blocks: t
    };
  }
  /**
   * Queries block headers filtered by minHeight <= height <= maxHeight.
   *
   * @param minHeight The minimum height to be included in the result. Defaults to 0.
   * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
   */
  async blockchain(n, r) {
    const t = {
      method: be.Method.Blockchain,
      params: {
        minHeight: n,
        maxHeight: r
      }
    };
    return this.doCall(t, pe.Params.encodeBlockchain, pe.Responses.decodeBlockchain);
  }
  /**
   * Broadcast transaction to mempool and wait for response
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
   */
  async broadcastTxSync(n) {
    const r = { params: n, method: be.Method.BroadcastTxSync };
    return this.doCall(r, pe.Params.encodeBroadcastTx, pe.Responses.decodeBroadcastTxSync);
  }
  /**
   * Broadcast transaction to mempool and do not wait for result
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
   */
  async broadcastTxAsync(n) {
    const r = { params: n, method: be.Method.BroadcastTxAsync };
    return this.doCall(r, pe.Params.encodeBroadcastTx, pe.Responses.decodeBroadcastTxAsync);
  }
  /**
   * Broadcast transaction to mempool and wait for block
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
   */
  async broadcastTxCommit(n) {
    const r = { params: n, method: be.Method.BroadcastTxCommit };
    return this.doCall(r, pe.Params.encodeBroadcastTx, pe.Responses.decodeBroadcastTxCommit);
  }
  async commit(n) {
    const r = { method: be.Method.Commit, params: { height: n } };
    return this.doCall(r, pe.Params.encodeCommit, pe.Responses.decodeCommit);
  }
  async genesis() {
    const n = { method: be.Method.Genesis };
    return this.doCall(n, pe.Params.encodeGenesis, pe.Responses.decodeGenesis);
  }
  async health() {
    const n = { method: be.Method.Health };
    return this.doCall(n, pe.Params.encodeHealth, pe.Responses.decodeHealth);
  }
  async numUnconfirmedTxs() {
    const n = { method: be.Method.NumUnconfirmedTxs };
    return this.doCall(n, pe.Params.encodeNumUnconfirmedTxs, pe.Responses.decodeNumUnconfirmedTxs);
  }
  async status() {
    const n = { method: be.Method.Status };
    return this.doCall(n, pe.Params.encodeStatus, pe.Responses.decodeStatus);
  }
  subscribeNewBlock() {
    const n = {
      method: be.Method.Subscribe,
      query: { type: be.SubscriptionEventType.NewBlock }
    };
    return this.subscribe(n, pe.Responses.decodeNewBlockEvent);
  }
  subscribeNewBlockHeader() {
    const n = {
      method: be.Method.Subscribe,
      query: { type: be.SubscriptionEventType.NewBlockHeader }
    };
    return this.subscribe(n, pe.Responses.decodeNewBlockHeaderEvent);
  }
  subscribeTx(n) {
    const r = {
      method: be.Method.Subscribe,
      query: {
        type: be.SubscriptionEventType.Tx,
        raw: n
      }
    };
    return this.subscribe(r, pe.Responses.decodeTxEvent);
  }
  /**
   * Get a single transaction by hash
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/tx
   */
  async tx(n) {
    const r = { params: n, method: be.Method.Tx };
    return this.doCall(r, pe.Params.encodeTx, pe.Responses.decodeTx);
  }
  /**
   * Search for transactions that are in a block
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
   */
  async txSearch(n) {
    const r = { params: n, method: be.Method.TxSearch };
    return this.doCall(r, pe.Params.encodeTxSearch, pe.Responses.decodeTxSearch);
  }
  // this should paginate through all txSearch options to ensure it returns all results.
  // starts with page 1 or whatever was provided (eg. to start on page 7)
  async txSearchAll(n) {
    let r = n.page || 1;
    const t = [];
    let i = !1;
    for (; !i; ) {
      const f = await this.txSearch({ ...n, page: r });
      t.push(...f.txs), t.length < f.totalCount ? r++ : i = !0;
    }
    return {
      totalCount: t.length,
      txs: t
    };
  }
  async validators(n) {
    const r = {
      method: be.Method.Validators,
      params: n
    };
    return this.doCall(r, pe.Params.encodeValidators, pe.Responses.decodeValidators);
  }
  async validatorsAll(n) {
    const r = [];
    let t = 1, i = !1, f = n;
    for (; !i; ) {
      const S = await this.validators({
        per_page: 50,
        height: f,
        page: t
      });
      r.push(...S.validators), f = f || S.blockHeight, r.length < S.total ? t++ : i = !0;
    }
    return {
      // NOTE: Default value is for type safety but this should always be set
      blockHeight: f ?? 0,
      count: r.length,
      total: r.length,
      validators: r
    };
  }
  // doCall is a helper to handle the encode/call/decode logic
  async doCall(n, r, t) {
    const i = r(n), f = await this.client.execute(i);
    return t(f);
  }
  subscribe(n, r) {
    if (!(0, ra.instanceOfRpcStreamingClient)(this.client))
      throw new Error("This RPC client type cannot subscribe to events");
    const t = pe.Params.encodeSubscribe(n);
    return this.client.listen(t).map((f) => r(f));
  }
}
ed.Tendermint34Client = Ja;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Tendermint34Client = e.VoteType = e.broadcastTxSyncSuccess = e.broadcastTxCommitSuccess = e.SubscriptionEventType = e.Method = void 0;
  var n = js;
  Object.defineProperty(e, "Method", { enumerable: !0, get: function() {
    return n.Method;
  } }), Object.defineProperty(e, "SubscriptionEventType", { enumerable: !0, get: function() {
    return n.SubscriptionEventType;
  } });
  var r = Yy;
  Object.defineProperty(e, "broadcastTxCommitSuccess", { enumerable: !0, get: function() {
    return r.broadcastTxCommitSuccess;
  } }), Object.defineProperty(e, "broadcastTxSyncSuccess", { enumerable: !0, get: function() {
    return r.broadcastTxSyncSuccess;
  } }), Object.defineProperty(e, "VoteType", { enumerable: !0, get: function() {
    return r.VoteType;
  } });
  var t = ed;
  Object.defineProperty(e, "Tendermint34Client", { enumerable: !0, get: function() {
    return t.Tendermint34Client;
  } });
})(lo);
var Da = {}, id = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.buildQuery = e.SubscriptionEventType = e.Method = void 0, function(r) {
    r.AbciInfo = "abci_info", r.AbciQuery = "abci_query", r.Block = "block", r.Blockchain = "blockchain", r.BlockResults = "block_results", r.BlockSearch = "block_search", r.BroadcastTxAsync = "broadcast_tx_async", r.BroadcastTxSync = "broadcast_tx_sync", r.BroadcastTxCommit = "broadcast_tx_commit", r.Commit = "commit", r.Genesis = "genesis", r.Health = "health", r.NumUnconfirmedTxs = "num_unconfirmed_txs", r.Status = "status", r.Subscribe = "subscribe", r.Tx = "tx", r.TxSearch = "tx_search", r.Validators = "validators", r.Unsubscribe = "unsubscribe";
  }(e.Method || (e.Method = {})), function(r) {
    r.NewBlock = "NewBlock", r.NewBlockHeader = "NewBlockHeader", r.Tx = "Tx";
  }(e.SubscriptionEventType || (e.SubscriptionEventType = {}));
  function n(r) {
    const i = (r.tags ? r.tags : []).map((S) => `${S.key}='${S.value}'`), f = r.raw ? [r.raw] : [];
    return [...i, ...f].join(" AND ");
  }
  e.buildQuery = n;
})(id);
var um = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.VoteType = e.broadcastTxCommitSuccess = e.broadcastTxSyncSuccess = void 0;
  function n(t) {
    return t.code === 0;
  }
  e.broadcastTxSyncSuccess = n;
  function r(t) {
    return t.checkTx.code === 0 && !!t.deliverTx && t.deliverTx.code === 0;
  }
  e.broadcastTxCommitSuccess = r, function(t) {
    t[t.PreVote = 1] = "PreVote", t[t.PreCommit = 2] = "PreCommit";
  }(e.VoteType || (e.VoteType = {}));
})(um);
var od = {}, cm = {}, ad = {}, Se = {};
Object.defineProperty(Se, "__esModule", { value: !0 });
Se.encodeBlockId = Se.encodeVersion = Se.encodeBytes = Se.encodeTime = Se.encodeUvarint = Se.encodeString = Se.dictionaryToStringMap = Se.may = Se.assertNotEmpty = Se.assertObject = Se.assertArray = Se.assertNumber = Se.assertString = Se.assertBoolean = Se.assertSet = void 0;
const m3 = Wn;
function ur(e) {
  if (e === void 0)
    throw new Error("Value must not be undefined");
  if (e === null)
    throw new Error("Value must not be null");
  return e;
}
Se.assertSet = ur;
function g3(e) {
  if (ur(e), typeof e != "boolean")
    throw new Error("Value must be a boolean");
  return e;
}
Se.assertBoolean = g3;
function S3(e) {
  if (ur(e), typeof e != "string")
    throw new Error("Value must be a string");
  return e;
}
Se.assertString = S3;
function k3(e) {
  if (ur(e), typeof e != "number")
    throw new Error("Value must be a number");
  return e;
}
Se.assertNumber = k3;
function P3(e) {
  if (ur(e), !Array.isArray(e))
    throw new Error("Value must be a an array");
  return e;
}
Se.assertArray = P3;
function v3(e) {
  if (ur(e), typeof e != "object")
    throw new Error("Value must be an object");
  if (Object.prototype.toString.call(e) !== "[object Object]")
    throw new Error("Value must be a simple object");
  return e;
}
Se.assertObject = v3;
function b3(e) {
  if (ur(e), typeof e == "number" && e === 0)
    throw new Error("must provide a non-zero value");
  if (e.length === 0)
    throw new Error("must provide a non-empty value");
  return e;
}
Se.assertNotEmpty = b3;
function R3(e, n) {
  return n == null ? void 0 : e(n);
}
Se.may = R3;
function B3(e) {
  const n = /* @__PURE__ */ new Map();
  for (const r of Object.keys(e)) {
    const t = e[r];
    if (typeof t != "string")
      throw new Error("Found dictionary value of type other than string");
    n.set(r, t);
  }
  return n;
}
Se.dictionaryToStringMap = B3;
function O3(e) {
  const n = (0, m3.toUtf8)(e);
  return Uint8Array.from([n.length, ...n]);
}
Se.encodeString = O3;
function Ji(e) {
  return e >= 128 ? (
    // eslint-disable-next-line no-bitwise
    Uint8Array.from([e & 255 | 128, ...Ji(e >> 7)])
  ) : (
    // eslint-disable-next-line no-bitwise
    Uint8Array.from([e & 255])
  );
}
Se.encodeUvarint = Ji;
function A3(e) {
  const n = e.getTime(), r = Math.floor(n / 1e3), t = r ? [8, ...Ji(r)] : new Uint8Array(), i = (e.nanoseconds || 0) + n % 1e3 * 1e6, f = i ? [16, ...Ji(i)] : new Uint8Array();
  return Uint8Array.from([...t, ...f]);
}
Se.encodeTime = A3;
function I3(e) {
  if (e.length >= 128)
    throw new Error("Not implemented for byte arrays of length 128 or more");
  return e.length ? Uint8Array.from([e.length, ...e]) : new Uint8Array();
}
Se.encodeBytes = I3;
function T3(e) {
  const n = e.block ? Uint8Array.from([8, ...Ji(e.block)]) : new Uint8Array(), r = e.app ? Uint8Array.from([16, ...Ji(e.app)]) : new Uint8Array();
  return Uint8Array.from([...n, ...r]);
}
Se.encodeVersion = T3;
function w3(e) {
  return Uint8Array.from([
    10,
    e.hash.length,
    ...e.hash,
    18,
    e.parts.hash.length + 4,
    8,
    e.parts.total,
    18,
    e.parts.hash.length,
    ...e.parts.hash
  ]);
}
Se.encodeBlockId = w3;
var C3 = x && x.__createBinding || (Object.create ? function(e, n, r, t) {
  t === void 0 && (t = r);
  var i = Object.getOwnPropertyDescriptor(n, r);
  (!i || ("get" in i ? !n.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return n[r];
  } }), Object.defineProperty(e, t, i);
} : function(e, n, r, t) {
  t === void 0 && (t = r), e[t] = n[r];
}), N3 = x && x.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), _3 = x && x.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var n = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && C3(n, e, r);
  return N3(n, e), n;
};
Object.defineProperty(ad, "__esModule", { value: !0 });
ad.Params = void 0;
const Pl = Wn, Kn = Pn, Qe = mt, fn = Se, E3 = _3(id);
function Mu(e) {
  return {
    height: (0, fn.may)(Kn.smallIntToApi, e.height)
  };
}
function U3(e) {
  return {
    minHeight: (0, fn.may)(Kn.smallIntToApi, e.minHeight),
    maxHeight: (0, fn.may)(Kn.smallIntToApi, e.maxHeight)
  };
}
function J3(e) {
  return {
    query: e.query,
    page: (0, fn.may)(Kn.smallIntToApi, e.page),
    per_page: (0, fn.may)(Kn.smallIntToApi, e.per_page),
    order_by: e.order_by
  };
}
function D3(e) {
  return {
    path: (0, fn.assertNotEmpty)(e.path),
    data: (0, Pl.toHex)(e.data),
    height: (0, fn.may)(Kn.smallIntToApi, e.height),
    prove: e.prove
  };
}
function M3(e) {
  return {
    tx: (0, Pl.toBase64)((0, fn.assertNotEmpty)(e.tx))
  };
}
function H3(e) {
  return {
    hash: (0, Pl.toBase64)((0, fn.assertNotEmpty)(e.hash)),
    prove: e.prove
  };
}
function q3(e) {
  return {
    query: e.query,
    prove: e.prove,
    page: (0, fn.may)(Kn.smallIntToApi, e.page),
    per_page: (0, fn.may)(Kn.smallIntToApi, e.per_page),
    order_by: e.order_by
  };
}
function V3(e) {
  return {
    height: (0, fn.may)(Kn.smallIntToApi, e.height),
    page: (0, fn.may)(Kn.smallIntToApi, e.page),
    per_page: (0, fn.may)(Kn.smallIntToApi, e.per_page)
  };
}
class W3 {
  static encodeAbciInfo(n) {
    return (0, Qe.createJsonRpcRequest)(n.method);
  }
  static encodeAbciQuery(n) {
    return (0, Qe.createJsonRpcRequest)(n.method, D3(n.params));
  }
  static encodeBlock(n) {
    return (0, Qe.createJsonRpcRequest)(n.method, Mu(n.params));
  }
  static encodeBlockchain(n) {
    return (0, Qe.createJsonRpcRequest)(n.method, U3(n.params));
  }
  static encodeBlockResults(n) {
    return (0, Qe.createJsonRpcRequest)(n.method, Mu(n.params));
  }
  static encodeBlockSearch(n) {
    return (0, Qe.createJsonRpcRequest)(n.method, J3(n.params));
  }
  static encodeBroadcastTx(n) {
    return (0, Qe.createJsonRpcRequest)(n.method, M3(n.params));
  }
  static encodeCommit(n) {
    return (0, Qe.createJsonRpcRequest)(n.method, Mu(n.params));
  }
  static encodeGenesis(n) {
    return (0, Qe.createJsonRpcRequest)(n.method);
  }
  static encodeHealth(n) {
    return (0, Qe.createJsonRpcRequest)(n.method);
  }
  static encodeNumUnconfirmedTxs(n) {
    return (0, Qe.createJsonRpcRequest)(n.method);
  }
  static encodeStatus(n) {
    return (0, Qe.createJsonRpcRequest)(n.method);
  }
  static encodeSubscribe(n) {
    const r = { key: "tm.event", value: n.query.type }, t = E3.buildQuery({ tags: [r], raw: n.query.raw });
    return (0, Qe.createJsonRpcRequest)("subscribe", { query: t });
  }
  static encodeTx(n) {
    return (0, Qe.createJsonRpcRequest)(n.method, H3(n.params));
  }
  // TODO: encode params for query string???
  static encodeTxSearch(n) {
    return (0, Qe.createJsonRpcRequest)(n.method, q3(n.params));
  }
  static encodeValidators(n) {
    return (0, Qe.createJsonRpcRequest)(n.method, V3(n.params));
  }
}
ad.Params = W3;
var Un = {}, Di = {};
Object.defineProperty(Di, "__esModule", { value: !0 });
Di.hashBlock = Di.hashTx = void 0;
const vl = _e, nn = Se;
function Q3(e) {
  return (0, vl.sha256)(e);
}
Di.hashTx = Q3;
function F3(e) {
  if (e < 1)
    throw new Error("Cannot split an empty tree");
  const n = 2 ** Math.floor(Math.log2(e));
  return n < e ? n : n / 2;
}
function $3(e) {
  const n = new vl.Sha256(Uint8Array.from([0]));
  return n.update(e), n.digest();
}
function L3(e, n) {
  const r = new vl.Sha256(Uint8Array.from([1]));
  return r.update(e), r.update(n), r.digest();
}
function Pc(e) {
  switch (e.length) {
    case 0:
      throw new Error("Cannot hash empty tree");
    case 1:
      return $3(e[0]);
    default: {
      const n = F3(e.length), r = Pc(e.slice(0, n)), t = Pc(e.slice(n));
      return L3(r, t);
    }
  }
}
function G3(e) {
  if (!e.lastBlockId)
    throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
  const n = [
    (0, nn.encodeVersion)(e.version),
    (0, nn.encodeString)(e.chainId),
    (0, nn.encodeUvarint)(e.height),
    (0, nn.encodeTime)(e.time),
    (0, nn.encodeBlockId)(e.lastBlockId),
    (0, nn.encodeBytes)(e.lastCommitHash),
    (0, nn.encodeBytes)(e.dataHash),
    (0, nn.encodeBytes)(e.validatorsHash),
    (0, nn.encodeBytes)(e.nextValidatorsHash),
    (0, nn.encodeBytes)(e.consensusHash),
    (0, nn.encodeBytes)(e.appHash),
    (0, nn.encodeBytes)(e.lastResultsHash),
    (0, nn.encodeBytes)(e.evidenceHash),
    (0, nn.encodeBytes)(e.proposerAddress)
  ];
  return Pc(n);
}
Di.hashBlock = G3;
Object.defineProperty(Un, "__esModule", { value: !0 });
Un.Responses = Un.decodeValidatorInfo = Un.decodeValidatorGenesis = Un.decodeValidatorUpdate = Un.decodeEvent = void 0;
const le = Wn, lm = Te, So = Ze, ue = Pn, K3 = Ho, X = Se, z3 = Di;
function x3(e) {
  return {
    data: e.data,
    lastBlockHeight: (0, X.may)(ue.apiToSmallInt, e.last_block_height),
    lastBlockAppHash: (0, X.may)(le.fromBase64, e.last_block_app_hash)
  };
}
function Z3(e) {
  return {
    ops: e.ops.map((n) => ({
      type: n.type,
      key: (0, le.fromBase64)(n.key),
      data: (0, le.fromBase64)(n.data)
    }))
  };
}
function Y3(e) {
  return {
    key: (0, le.fromBase64)((0, X.assertString)(e.key ?? "")),
    value: (0, le.fromBase64)((0, X.assertString)(e.value ?? "")),
    proof: (0, X.may)(Z3, e.proofOps),
    height: (0, X.may)(ue.apiToSmallInt, e.height),
    code: (0, X.may)(ue.apiToSmallInt, e.code),
    codespace: (0, X.assertString)(e.codespace ?? ""),
    index: (0, X.may)(ue.apiToSmallInt, e.index),
    log: e.log,
    info: (0, X.assertString)(e.info ?? "")
  };
}
function X3(e) {
  return {
    key: (0, X.assertNotEmpty)(e.key),
    value: e.value ?? ""
  };
}
function j3(e) {
  return (0, X.assertArray)(e).map(X3);
}
function fm(e) {
  return {
    type: e.type,
    attributes: e.attributes ? j3(e.attributes) : []
  };
}
Un.decodeEvent = fm;
function vc(e) {
  return (0, X.assertArray)(e).map(fm);
}
function Mi(e) {
  return {
    code: (0, ue.apiToSmallInt)((0, X.assertNumber)(e.code ?? 0)),
    codespace: e.codespace,
    log: e.log,
    data: (0, X.may)(le.fromBase64, e.data),
    events: e.events ? vc(e.events) : [],
    gasWanted: (0, ue.apiToBigInt)(e.gas_wanted ?? "0"),
    gasUsed: (0, ue.apiToBigInt)(e.gas_used ?? "0")
  };
}
function bl(e) {
  if ("Sum" in e) {
    const [[n, r]] = Object.entries(e.Sum.value);
    return (0, lm.assert)(n === "ed25519" || n === "secp256k1", `unknown pubkey type: ${n}`), {
      algorithm: n,
      data: (0, le.fromBase64)((0, X.assertNotEmpty)(r))
    };
  } else
    switch (e.type) {
      case "tendermint/PubKeyEd25519":
        return {
          algorithm: "ed25519",
          data: (0, le.fromBase64)((0, X.assertNotEmpty)(e.value))
        };
      case "tendermint/PubKeySecp256k1":
        return {
          algorithm: "secp256k1",
          data: (0, le.fromBase64)((0, X.assertNotEmpty)(e.value))
        };
      default:
        throw new Error(`unknown pubkey type: ${e.type}`);
    }
}
function eI(e) {
  return {
    maxBytes: (0, ue.apiToSmallInt)((0, X.assertNotEmpty)(e.max_bytes)),
    maxGas: (0, ue.apiToSmallInt)((0, X.assertNotEmpty)(e.max_gas))
  };
}
function nI(e) {
  return {
    maxAgeNumBlocks: (0, ue.apiToSmallInt)((0, X.assertNotEmpty)(e.max_age_num_blocks)),
    maxAgeDuration: (0, ue.apiToSmallInt)((0, X.assertNotEmpty)(e.max_age_duration))
  };
}
function pm(e) {
  return {
    block: eI((0, X.assertObject)(e.block)),
    evidence: nI((0, X.assertObject)(e.evidence))
  };
}
function hm(e) {
  return {
    pubkey: bl((0, X.assertObject)(e.pub_key)),
    votingPower: (0, ue.apiToBigInt)(e.power ?? "0")
  };
}
Un.decodeValidatorUpdate = hm;
function tI(e) {
  return {
    height: (0, ue.apiToSmallInt)((0, X.assertNotEmpty)(e.height)),
    results: (e.txs_results || []).map(Mi),
    validatorUpdates: (e.validator_updates || []).map(hm),
    consensusUpdates: (0, X.may)(pm, e.consensus_param_updates),
    beginBlockEvents: vc(e.begin_block_events || []),
    endBlockEvents: vc(e.end_block_events || [])
  };
}
function sd(e) {
  return {
    hash: (0, le.fromHex)((0, X.assertNotEmpty)(e.hash)),
    parts: {
      total: (0, X.assertNotEmpty)(e.parts.total),
      hash: (0, le.fromHex)((0, X.assertNotEmpty)(e.parts.hash))
    }
  };
}
function rI(e) {
  return {
    block: (0, ue.apiToSmallInt)(e.block),
    app: (0, ue.apiToSmallInt)(e.app ?? 0)
  };
}
function dd(e) {
  return {
    version: rI(e.version),
    chainId: (0, X.assertNotEmpty)(e.chain_id),
    height: (0, ue.apiToSmallInt)((0, X.assertNotEmpty)(e.height)),
    time: (0, So.fromRfc3339WithNanoseconds)((0, X.assertNotEmpty)(e.time)),
    // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
    // { hash: '', parts: { total: 0, hash: '' } }
    lastBlockId: e.last_block_id.hash ? sd(e.last_block_id) : null,
    lastCommitHash: (0, le.fromHex)((0, X.assertSet)(e.last_commit_hash)),
    dataHash: (0, le.fromHex)((0, X.assertSet)(e.data_hash)),
    validatorsHash: (0, le.fromHex)((0, X.assertSet)(e.validators_hash)),
    nextValidatorsHash: (0, le.fromHex)((0, X.assertSet)(e.next_validators_hash)),
    consensusHash: (0, le.fromHex)((0, X.assertSet)(e.consensus_hash)),
    appHash: (0, le.fromHex)((0, X.assertSet)(e.app_hash)),
    lastResultsHash: (0, le.fromHex)((0, X.assertSet)(e.last_results_hash)),
    evidenceHash: (0, le.fromHex)((0, X.assertSet)(e.evidence_hash)),
    proposerAddress: (0, le.fromHex)((0, X.assertNotEmpty)(e.proposer_address))
  };
}
function iI(e) {
  return {
    blockId: sd(e.block_id),
    blockSize: (0, ue.apiToSmallInt)((0, X.assertNotEmpty)(e.block_size)),
    header: dd(e.header),
    numTxs: (0, ue.apiToSmallInt)((0, X.assertNotEmpty)(e.num_txs))
  };
}
function oI(e) {
  return {
    lastHeight: (0, ue.apiToSmallInt)((0, X.assertNotEmpty)(e.last_height)),
    blockMetas: (0, X.assertArray)(e.block_metas).map(iI)
  };
}
function aI(e) {
  return {
    ...Mi(e),
    hash: (0, le.fromHex)((0, X.assertNotEmpty)(e.hash))
  };
}
function sI(e) {
  return {
    height: (0, ue.apiToSmallInt)(e.height),
    hash: (0, le.fromHex)((0, X.assertNotEmpty)(e.hash)),
    checkTx: Mi((0, X.assertObject)(e.check_tx)),
    deliverTx: (0, X.may)(Mi, e.deliver_tx)
  };
}
function dI(e) {
  return (0, lm.assert)(e in K3.BlockIdFlag), e;
}
function uI(e) {
  return {
    blockIdFlag: dI(e.block_id_flag),
    validatorAddress: e.validator_address ? (0, le.fromHex)(e.validator_address) : void 0,
    timestamp: e.timestamp ? (0, So.fromRfc3339WithNanoseconds)(e.timestamp) : void 0,
    signature: e.signature ? (0, le.fromBase64)(e.signature) : void 0
  };
}
function ym(e) {
  return {
    blockId: sd((0, X.assertObject)(e.block_id)),
    height: (0, ue.apiToSmallInt)((0, X.assertNotEmpty)(e.height)),
    round: (0, ue.apiToSmallInt)(e.round),
    signatures: (0, X.assertArray)(e.signatures).map(uI)
  };
}
function cI(e) {
  return {
    canonical: (0, X.assertBoolean)(e.canonical),
    header: dd(e.signed_header.header),
    commit: ym(e.signed_header.commit)
  };
}
function mm(e) {
  return {
    address: (0, le.fromHex)((0, X.assertNotEmpty)(e.address)),
    pubkey: bl((0, X.assertObject)(e.pub_key)),
    votingPower: (0, ue.apiToBigInt)((0, X.assertNotEmpty)(e.power))
  };
}
Un.decodeValidatorGenesis = mm;
function lI(e) {
  return {
    genesisTime: (0, So.fromRfc3339WithNanoseconds)((0, X.assertNotEmpty)(e.genesis_time)),
    chainId: (0, X.assertNotEmpty)(e.chain_id),
    consensusParams: pm(e.consensus_params),
    validators: e.validators ? (0, X.assertArray)(e.validators).map(mm) : [],
    appHash: (0, le.fromHex)((0, X.assertSet)(e.app_hash)),
    appState: e.app_state
  };
}
function Rl(e) {
  return {
    pubkey: bl((0, X.assertObject)(e.pub_key)),
    votingPower: (0, ue.apiToBigInt)((0, X.assertNotEmpty)(e.voting_power)),
    address: (0, le.fromHex)((0, X.assertNotEmpty)(e.address)),
    proposerPriority: e.proposer_priority ? (0, ue.apiToSmallInt)(e.proposer_priority) : void 0
  };
}
Un.decodeValidatorInfo = Rl;
function fI(e) {
  return {
    id: (0, le.fromHex)((0, X.assertNotEmpty)(e.id)),
    listenAddr: (0, X.assertNotEmpty)(e.listen_addr),
    network: (0, X.assertNotEmpty)(e.network),
    version: (0, X.assertString)(e.version),
    channels: (0, X.assertNotEmpty)(e.channels),
    moniker: (0, X.assertNotEmpty)(e.moniker),
    other: (0, X.dictionaryToStringMap)(e.other),
    protocolVersion: {
      app: (0, ue.apiToSmallInt)((0, X.assertNotEmpty)(e.protocol_version.app)),
      block: (0, ue.apiToSmallInt)((0, X.assertNotEmpty)(e.protocol_version.block)),
      p2p: (0, ue.apiToSmallInt)((0, X.assertNotEmpty)(e.protocol_version.p2p))
    }
  };
}
function pI(e) {
  const n = e.earliest_block_height ? (0, ue.apiToSmallInt)(e.earliest_block_height) : void 0, r = e.earliest_block_time ? (0, So.fromRfc3339WithNanoseconds)(e.earliest_block_time) : void 0;
  return {
    earliestAppHash: e.earliest_app_hash ? (0, le.fromHex)(e.earliest_app_hash) : void 0,
    earliestBlockHash: e.earliest_block_hash ? (0, le.fromHex)(e.earliest_block_hash) : void 0,
    earliestBlockHeight: n || void 0,
    earliestBlockTime: r != null && r.getTime() ? r : void 0,
    latestBlockHash: (0, le.fromHex)((0, X.assertNotEmpty)(e.latest_block_hash)),
    latestAppHash: (0, le.fromHex)((0, X.assertNotEmpty)(e.latest_app_hash)),
    latestBlockTime: (0, So.fromRfc3339WithNanoseconds)((0, X.assertNotEmpty)(e.latest_block_time)),
    latestBlockHeight: (0, ue.apiToSmallInt)((0, X.assertNotEmpty)(e.latest_block_height)),
    catchingUp: (0, X.assertBoolean)(e.catching_up)
  };
}
function hI(e) {
  return {
    nodeInfo: fI(e.node_info),
    syncInfo: pI(e.sync_info),
    validatorInfo: Rl(e.validator_info)
  };
}
function yI(e) {
  return {
    data: (0, le.fromBase64)((0, X.assertNotEmpty)(e.data)),
    rootHash: (0, le.fromHex)((0, X.assertNotEmpty)(e.root_hash)),
    proof: {
      total: (0, ue.apiToSmallInt)((0, X.assertNotEmpty)(e.proof.total)),
      index: (0, ue.apiToSmallInt)((0, X.assertNotEmpty)(e.proof.index)),
      leafHash: (0, le.fromBase64)((0, X.assertNotEmpty)(e.proof.leaf_hash)),
      aunts: (0, X.assertArray)(e.proof.aunts).map(le.fromBase64)
    }
  };
}
function gm(e) {
  return {
    tx: (0, le.fromBase64)((0, X.assertNotEmpty)(e.tx)),
    result: Mi((0, X.assertObject)(e.tx_result)),
    height: (0, ue.apiToSmallInt)((0, X.assertNotEmpty)(e.height)),
    index: (0, ue.apiToSmallInt)((0, X.assertNumber)(e.index)),
    hash: (0, le.fromHex)((0, X.assertNotEmpty)(e.hash)),
    proof: (0, X.may)(yI, e.proof)
  };
}
function mI(e) {
  return {
    totalCount: (0, ue.apiToSmallInt)((0, X.assertNotEmpty)(e.total_count)),
    txs: (0, X.assertArray)(e.txs).map(gm)
  };
}
function gI(e) {
  const n = (0, le.fromBase64)((0, X.assertNotEmpty)(e.tx));
  return {
    tx: n,
    hash: (0, z3.hashTx)(n),
    result: Mi(e.result),
    height: (0, ue.apiToSmallInt)((0, X.assertNotEmpty)(e.height))
  };
}
function SI(e) {
  return {
    blockHeight: (0, ue.apiToSmallInt)((0, X.assertNotEmpty)(e.block_height)),
    validators: (0, X.assertArray)(e.validators).map(Rl),
    count: (0, ue.apiToSmallInt)((0, X.assertNotEmpty)(e.count)),
    total: (0, ue.apiToSmallInt)((0, X.assertNotEmpty)(e.total))
  };
}
function Sm(e) {
  var n;
  return {
    header: dd((0, X.assertObject)(e.header)),
    // For the block at height 1, last commit is not set. This is represented in an empty object like this:
    // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
    lastCommit: e.last_commit.block_id.hash ? ym((0, X.assertObject)(e.last_commit)) : null,
    txs: e.data.txs ? (0, X.assertArray)(e.data.txs).map(le.fromBase64) : [],
    // Lift up .evidence.evidence to just .evidence
    // See https://github.com/tendermint/tendermint/issues/7697
    evidence: ((n = e.evidence) == null ? void 0 : n.evidence) ?? []
  };
}
function km(e) {
  return {
    blockId: sd(e.block_id),
    block: Sm(e.block)
  };
}
function kI(e) {
  return {
    totalCount: (0, ue.apiToSmallInt)((0, X.assertNotEmpty)(e.total_count)),
    blocks: (0, X.assertArray)(e.blocks).map(km)
  };
}
function PI(e) {
  return {
    total: (0, ue.apiToSmallInt)((0, X.assertNotEmpty)(e.total)),
    totalBytes: (0, ue.apiToSmallInt)((0, X.assertNotEmpty)(e.total_bytes))
  };
}
class Bl {
  static decodeAbciInfo(n) {
    return x3((0, X.assertObject)(n.result.response));
  }
  static decodeAbciQuery(n) {
    return Y3((0, X.assertObject)(n.result.response));
  }
  static decodeBlock(n) {
    return km(n.result);
  }
  static decodeBlockResults(n) {
    return tI(n.result);
  }
  static decodeBlockSearch(n) {
    return kI(n.result);
  }
  static decodeBlockchain(n) {
    return oI(n.result);
  }
  static decodeBroadcastTxSync(n) {
    return aI(n.result);
  }
  static decodeBroadcastTxAsync(n) {
    return Bl.decodeBroadcastTxSync(n);
  }
  static decodeBroadcastTxCommit(n) {
    return sI(n.result);
  }
  static decodeCommit(n) {
    return cI(n.result);
  }
  static decodeGenesis(n) {
    return lI((0, X.assertObject)(n.result.genesis));
  }
  static decodeHealth() {
    return null;
  }
  static decodeNumUnconfirmedTxs(n) {
    return PI(n.result);
  }
  static decodeStatus(n) {
    return hI(n.result);
  }
  static decodeNewBlockEvent(n) {
    return Sm(n.data.value.block);
  }
  static decodeNewBlockHeaderEvent(n) {
    return dd(n.data.value.header);
  }
  static decodeTxEvent(n) {
    return gI(n.data.value.TxResult);
  }
  static decodeTx(n) {
    return gm(n.result);
  }
  static decodeTxSearch(n) {
    return mI(n.result);
  }
  static decodeValidators(n) {
    return SI(n.result);
  }
}
Un.Responses = Bl;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Responses = e.Params = void 0;
  var n = ad;
  Object.defineProperty(e, "Params", { enumerable: !0, get: function() {
    return n.Params;
  } });
  var r = Un;
  Object.defineProperty(e, "Responses", { enumerable: !0, get: function() {
    return r.Responses;
  } });
})(cm);
var vI = x && x.__createBinding || (Object.create ? function(e, n, r, t) {
  t === void 0 && (t = r);
  var i = Object.getOwnPropertyDescriptor(n, r);
  (!i || ("get" in i ? !n.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return n[r];
  } }), Object.defineProperty(e, t, i);
} : function(e, n, r, t) {
  t === void 0 && (t = r), e[t] = n[r];
}), bI = x && x.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), RI = x && x.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var n = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && vI(n, e, r);
  return bI(n, e), n;
};
Object.defineProperty(od, "__esModule", { value: !0 });
od.Tendermint37Client = void 0;
const BI = mt, ia = _o, he = cm, Re = RI(id);
class Ma {
  /**
   * Creates a new Tendermint client for the given endpoint.
   *
   * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
   */
  static async connect(n) {
    let r;
    return typeof n == "object" ? r = new ia.HttpClient(n) : r = n.startsWith("http://") || n.startsWith("https://") ? new ia.HttpClient(n) : new ia.WebsocketClient(n), await this.detectVersion(r), Ma.create(r);
  }
  /**
   * Creates a new Tendermint client given an RPC client.
   */
  static async create(n) {
    return new Ma(n);
  }
  static async detectVersion(n) {
    const r = (0, BI.createJsonRpcRequest)(Re.Method.Status), i = (await n.execute(r)).result;
    if (!i || !i.node_info)
      throw new Error("Unrecognized format for status response");
    const f = i.node_info.version;
    if (typeof f != "string")
      throw new Error("Unrecognized version format: must be string");
    return f;
  }
  /**
   * Use `Tendermint37Client.connect` or `Tendermint37Client.create` to create an instance.
   */
  constructor(n) {
    this.client = n;
  }
  disconnect() {
    this.client.disconnect();
  }
  async abciInfo() {
    const n = { method: Re.Method.AbciInfo };
    return this.doCall(n, he.Params.encodeAbciInfo, he.Responses.decodeAbciInfo);
  }
  async abciQuery(n) {
    const r = { params: n, method: Re.Method.AbciQuery };
    return this.doCall(r, he.Params.encodeAbciQuery, he.Responses.decodeAbciQuery);
  }
  async block(n) {
    const r = { method: Re.Method.Block, params: { height: n } };
    return this.doCall(r, he.Params.encodeBlock, he.Responses.decodeBlock);
  }
  async blockResults(n) {
    const r = {
      method: Re.Method.BlockResults,
      params: { height: n }
    };
    return this.doCall(r, he.Params.encodeBlockResults, he.Responses.decodeBlockResults);
  }
  /**
   * Search for events that are in a block.
   *
   * NOTE
   * This method will error on any node that is running a Tendermint version lower than 0.34.9.
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
   */
  async blockSearch(n) {
    const r = { params: n, method: Re.Method.BlockSearch }, t = await this.doCall(r, he.Params.encodeBlockSearch, he.Responses.decodeBlockSearch);
    return {
      ...t,
      // make sure we sort by height, as tendermint may be sorting by string value of the height
      blocks: [...t.blocks].sort((i, f) => i.block.header.height - f.block.header.height)
    };
  }
  // this should paginate through all blockSearch options to ensure it returns all results.
  // starts with page 1 or whatever was provided (eg. to start on page 7)
  //
  // NOTE
  // This method will error on any node that is running a Tendermint version lower than 0.34.9.
  async blockSearchAll(n) {
    let r = n.page || 1;
    const t = [];
    let i = !1;
    for (; !i; ) {
      const f = await this.blockSearch({ ...n, page: r });
      t.push(...f.blocks), t.length < f.totalCount ? r++ : i = !0;
    }
    return t.sort((f, S) => f.block.header.height - S.block.header.height), {
      totalCount: t.length,
      blocks: t
    };
  }
  /**
   * Queries block headers filtered by minHeight <= height <= maxHeight.
   *
   * @param minHeight The minimum height to be included in the result. Defaults to 0.
   * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
   */
  async blockchain(n, r) {
    const t = {
      method: Re.Method.Blockchain,
      params: {
        minHeight: n,
        maxHeight: r
      }
    };
    return this.doCall(t, he.Params.encodeBlockchain, he.Responses.decodeBlockchain);
  }
  /**
   * Broadcast transaction to mempool and wait for response
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
   */
  async broadcastTxSync(n) {
    const r = { params: n, method: Re.Method.BroadcastTxSync };
    return this.doCall(r, he.Params.encodeBroadcastTx, he.Responses.decodeBroadcastTxSync);
  }
  /**
   * Broadcast transaction to mempool and do not wait for result
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
   */
  async broadcastTxAsync(n) {
    const r = { params: n, method: Re.Method.BroadcastTxAsync };
    return this.doCall(r, he.Params.encodeBroadcastTx, he.Responses.decodeBroadcastTxAsync);
  }
  /**
   * Broadcast transaction to mempool and wait for block
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
   */
  async broadcastTxCommit(n) {
    const r = { params: n, method: Re.Method.BroadcastTxCommit };
    return this.doCall(r, he.Params.encodeBroadcastTx, he.Responses.decodeBroadcastTxCommit);
  }
  async commit(n) {
    const r = { method: Re.Method.Commit, params: { height: n } };
    return this.doCall(r, he.Params.encodeCommit, he.Responses.decodeCommit);
  }
  async genesis() {
    const n = { method: Re.Method.Genesis };
    return this.doCall(n, he.Params.encodeGenesis, he.Responses.decodeGenesis);
  }
  async health() {
    const n = { method: Re.Method.Health };
    return this.doCall(n, he.Params.encodeHealth, he.Responses.decodeHealth);
  }
  async numUnconfirmedTxs() {
    const n = { method: Re.Method.NumUnconfirmedTxs };
    return this.doCall(n, he.Params.encodeNumUnconfirmedTxs, he.Responses.decodeNumUnconfirmedTxs);
  }
  async status() {
    const n = { method: Re.Method.Status };
    return this.doCall(n, he.Params.encodeStatus, he.Responses.decodeStatus);
  }
  subscribeNewBlock() {
    const n = {
      method: Re.Method.Subscribe,
      query: { type: Re.SubscriptionEventType.NewBlock }
    };
    return this.subscribe(n, he.Responses.decodeNewBlockEvent);
  }
  subscribeNewBlockHeader() {
    const n = {
      method: Re.Method.Subscribe,
      query: { type: Re.SubscriptionEventType.NewBlockHeader }
    };
    return this.subscribe(n, he.Responses.decodeNewBlockHeaderEvent);
  }
  subscribeTx(n) {
    const r = {
      method: Re.Method.Subscribe,
      query: {
        type: Re.SubscriptionEventType.Tx,
        raw: n
      }
    };
    return this.subscribe(r, he.Responses.decodeTxEvent);
  }
  /**
   * Get a single transaction by hash
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/tx
   */
  async tx(n) {
    const r = { params: n, method: Re.Method.Tx };
    return this.doCall(r, he.Params.encodeTx, he.Responses.decodeTx);
  }
  /**
   * Search for transactions that are in a block
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
   */
  async txSearch(n) {
    const r = { params: n, method: Re.Method.TxSearch };
    return this.doCall(r, he.Params.encodeTxSearch, he.Responses.decodeTxSearch);
  }
  // this should paginate through all txSearch options to ensure it returns all results.
  // starts with page 1 or whatever was provided (eg. to start on page 7)
  async txSearchAll(n) {
    let r = n.page || 1;
    const t = [];
    let i = !1;
    for (; !i; ) {
      const f = await this.txSearch({ ...n, page: r });
      t.push(...f.txs), t.length < f.totalCount ? r++ : i = !0;
    }
    return {
      totalCount: t.length,
      txs: t
    };
  }
  async validators(n) {
    const r = {
      method: Re.Method.Validators,
      params: n
    };
    return this.doCall(r, he.Params.encodeValidators, he.Responses.decodeValidators);
  }
  async validatorsAll(n) {
    const r = [];
    let t = 1, i = !1, f = n;
    for (; !i; ) {
      const S = await this.validators({
        per_page: 50,
        height: f,
        page: t
      });
      r.push(...S.validators), f = f || S.blockHeight, r.length < S.total ? t++ : i = !0;
    }
    return {
      // NOTE: Default value is for type safety but this should always be set
      blockHeight: f ?? 0,
      count: r.length,
      total: r.length,
      validators: r
    };
  }
  // doCall is a helper to handle the encode/call/decode logic
  async doCall(n, r, t) {
    const i = r(n), f = await this.client.execute(i);
    return t(f);
  }
  subscribe(n, r) {
    if (!(0, ia.instanceOfRpcStreamingClient)(this.client))
      throw new Error("This RPC client type cannot subscribe to events");
    const t = he.Params.encodeSubscribe(n);
    return this.client.listen(t).map((f) => r(f));
  }
}
od.Tendermint37Client = Ma;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Tendermint37Client = e.VoteType = e.broadcastTxSyncSuccess = e.broadcastTxCommitSuccess = e.SubscriptionEventType = e.Method = void 0;
  var n = id;
  Object.defineProperty(e, "Method", { enumerable: !0, get: function() {
    return n.Method;
  } }), Object.defineProperty(e, "SubscriptionEventType", { enumerable: !0, get: function() {
    return n.SubscriptionEventType;
  } });
  var r = um;
  Object.defineProperty(e, "broadcastTxCommitSuccess", { enumerable: !0, get: function() {
    return r.broadcastTxCommitSuccess;
  } }), Object.defineProperty(e, "broadcastTxSyncSuccess", { enumerable: !0, get: function() {
    return r.broadcastTxSyncSuccess;
  } }), Object.defineProperty(e, "VoteType", { enumerable: !0, get: function() {
    return r.VoteType;
  } });
  var t = od;
  Object.defineProperty(e, "Tendermint37Client", { enumerable: !0, get: function() {
    return t.Tendermint37Client;
  } });
})(Da);
var at = {};
Object.defineProperty(at, "__esModule", { value: !0 });
at.connectComet = at.isComet38Client = at.isTendermint37Client = at.isTendermint34Client = void 0;
const Pm = Na, vm = lo, bm = Da;
function OI(e) {
  return e instanceof vm.Tendermint34Client;
}
at.isTendermint34Client = OI;
function AI(e) {
  return e instanceof bm.Tendermint37Client;
}
at.isTendermint37Client = AI;
function II(e) {
  return e instanceof Pm.Comet38Client;
}
at.isComet38Client = II;
async function TI(e) {
  let n;
  const r = await bm.Tendermint37Client.connect(e), t = (await r.status()).nodeInfo.version;
  return t.startsWith("0.37.") ? n = r : t.startsWith("0.38.") ? (r.disconnect(), n = await Pm.Comet38Client.connect(e)) : (r.disconnect(), n = await vm.Tendermint34Client.connect(e)), n;
}
at.connectComet = TI;
(function(e) {
  var n = x && x.__createBinding || (Object.create ? function(m, v, a, d) {
    d === void 0 && (d = a);
    var y = Object.getOwnPropertyDescriptor(v, a);
    (!y || ("get" in y ? !v.__esModule : y.writable || y.configurable)) && (y = { enumerable: !0, get: function() {
      return v[a];
    } }), Object.defineProperty(m, d, y);
  } : function(m, v, a, d) {
    d === void 0 && (d = a), m[d] = v[a];
  }), r = x && x.__setModuleDefault || (Object.create ? function(m, v) {
    Object.defineProperty(m, "default", { enumerable: !0, value: v });
  } : function(m, v) {
    m.default = v;
  }), t = x && x.__importStar || function(m) {
    if (m && m.__esModule) return m;
    var v = {};
    if (m != null) for (var a in m) a !== "default" && Object.prototype.hasOwnProperty.call(m, a) && n(v, m, a);
    return r(v, m), v;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.BlockIdFlag = e.isTendermint37Client = e.isTendermint34Client = e.isComet38Client = e.connectComet = e.Tendermint37Client = e.tendermint37 = e.Tendermint34Client = e.tendermint34 = e.VoteType = e.SubscriptionEventType = e.Method = e.broadcastTxSyncSuccess = e.broadcastTxCommitSuccess = e.WebsocketClient = e.HttpClient = e.HttpBatchClient = e.Comet38Client = e.comet38 = e.toSeconds = e.toRfc3339WithNanoseconds = e.fromSeconds = e.fromRfc3339WithNanoseconds = e.DateTime = e.rawSecp256k1PubkeyToRawAddress = e.rawEd25519PubkeyToRawAddress = e.pubkeyToRawAddress = e.pubkeyToAddress = void 0;
  var i = it;
  Object.defineProperty(e, "pubkeyToAddress", { enumerable: !0, get: function() {
    return i.pubkeyToAddress;
  } }), Object.defineProperty(e, "pubkeyToRawAddress", { enumerable: !0, get: function() {
    return i.pubkeyToRawAddress;
  } }), Object.defineProperty(e, "rawEd25519PubkeyToRawAddress", { enumerable: !0, get: function() {
    return i.rawEd25519PubkeyToRawAddress;
  } }), Object.defineProperty(e, "rawSecp256k1PubkeyToRawAddress", { enumerable: !0, get: function() {
    return i.rawSecp256k1PubkeyToRawAddress;
  } });
  var f = Ze;
  Object.defineProperty(e, "DateTime", { enumerable: !0, get: function() {
    return f.DateTime;
  } }), Object.defineProperty(e, "fromRfc3339WithNanoseconds", { enumerable: !0, get: function() {
    return f.fromRfc3339WithNanoseconds;
  } }), Object.defineProperty(e, "fromSeconds", { enumerable: !0, get: function() {
    return f.fromSeconds;
  } }), Object.defineProperty(e, "toRfc3339WithNanoseconds", { enumerable: !0, get: function() {
    return f.toRfc3339WithNanoseconds;
  } }), Object.defineProperty(e, "toSeconds", { enumerable: !0, get: function() {
    return f.toSeconds;
  } }), e.comet38 = t(Na);
  var S = Na;
  Object.defineProperty(e, "Comet38Client", { enumerable: !0, get: function() {
    return S.Comet38Client;
  } });
  var w = _o;
  Object.defineProperty(e, "HttpBatchClient", { enumerable: !0, get: function() {
    return w.HttpBatchClient;
  } }), Object.defineProperty(e, "HttpClient", { enumerable: !0, get: function() {
    return w.HttpClient;
  } }), Object.defineProperty(e, "WebsocketClient", { enumerable: !0, get: function() {
    return w.WebsocketClient;
  } });
  var T = lo;
  Object.defineProperty(e, "broadcastTxCommitSuccess", { enumerable: !0, get: function() {
    return T.broadcastTxCommitSuccess;
  } }), Object.defineProperty(e, "broadcastTxSyncSuccess", { enumerable: !0, get: function() {
    return T.broadcastTxSyncSuccess;
  } }), Object.defineProperty(e, "Method", { enumerable: !0, get: function() {
    return T.Method;
  } }), Object.defineProperty(e, "SubscriptionEventType", { enumerable: !0, get: function() {
    return T.SubscriptionEventType;
  } }), Object.defineProperty(e, "VoteType", { enumerable: !0, get: function() {
    return T.VoteType;
  } }), e.tendermint34 = t(lo);
  var J = lo;
  Object.defineProperty(e, "Tendermint34Client", { enumerable: !0, get: function() {
    return J.Tendermint34Client;
  } }), e.tendermint37 = t(Da);
  var C = Da;
  Object.defineProperty(e, "Tendermint37Client", { enumerable: !0, get: function() {
    return C.Tendermint37Client;
  } });
  var R = at;
  Object.defineProperty(e, "connectComet", { enumerable: !0, get: function() {
    return R.connectComet;
  } }), Object.defineProperty(e, "isComet38Client", { enumerable: !0, get: function() {
    return R.isComet38Client;
  } }), Object.defineProperty(e, "isTendermint34Client", { enumerable: !0, get: function() {
    return R.isTendermint34Client;
  } }), Object.defineProperty(e, "isTendermint37Client", { enumerable: !0, get: function() {
    return R.isTendermint37Client;
  } });
  var p = Ho;
  Object.defineProperty(e, "BlockIdFlag", { enumerable: !0, get: function() {
    return p.BlockIdFlag;
  } });
})(tl);
var He = {};
Object.defineProperty(He, "__esModule", { value: !0 });
He.StargateClient = He.BroadcastTxError = He.assertIsDeliverTxFailure = He.assertIsDeliverTxSuccess = He.isDeliverTxSuccess = He.isDeliverTxFailure = He.TimeoutError = void 0;
const wI = To, Hu = Ke, Ff = Ie, $f = tl, Lf = Te, CI = nl, NI = ko, _I = Oo, oa = ho, EI = Ye, UI = No;
class Rm extends Error {
  constructor(n, r) {
    super(n), this.txId = r;
  }
}
He.TimeoutError = Rm;
function Ol(e) {
  return !!e.code;
}
He.isDeliverTxFailure = Ol;
function Bm(e) {
  return !Ol(e);
}
He.isDeliverTxSuccess = Bm;
function JI(e) {
  if (Ol(e))
    throw new Error(`Error when broadcasting tx ${e.transactionHash} at height ${e.height}. Code: ${e.code}; Raw log: ${e.rawLog}`);
}
He.assertIsDeliverTxSuccess = JI;
function DI(e) {
  if (Bm(e))
    throw new Error(`Transaction ${e.transactionHash} did not fail at height ${e.height}. Code: ${e.code}; Raw log: ${e.rawLog}`);
}
He.assertIsDeliverTxFailure = DI;
class Om extends Error {
  constructor(n, r, t) {
    super(`Broadcasting transaction failed with code ${n} (codespace: ${r}). Log: ${t}`), this.code = n, this.codespace = r, this.log = t;
  }
}
He.BroadcastTxError = Om;
class Ha {
  /**
   * Creates an instance by connecting to the given CometBFT RPC endpoint.
   *
   * This uses auto-detection to decide between a CometBFT 0.38, Tendermint 0.37 and 0.34 client.
   * To set the Comet client explicitly, use `create`.
   */
  static async connect(n, r = {}) {
    const t = await (0, $f.connectComet)(n);
    return Ha.create(t, r);
  }
  /**
   * Creates an instance from a manually created Comet client.
   * Use this to use `Comet38Client` or `Tendermint37Client` instead of `Tendermint34Client`.
   */
  static async create(n, r = {}) {
    return new Ha(n, r);
  }
  constructor(n, r) {
    n && (this.cometClient = n, this.queryClient = EI.QueryClient.withExtensions(n, oa.setupAuthExtension, oa.setupBankExtension, oa.setupStakingExtension, oa.setupTxExtension));
    const { accountParser: t = NI.accountFromAny } = r;
    this.accountParser = t;
  }
  getCometClient() {
    return this.cometClient;
  }
  forceGetCometClient() {
    if (!this.cometClient)
      throw new Error("Comet client not available. You cannot use online functionality in offline mode.");
    return this.cometClient;
  }
  getQueryClient() {
    return this.queryClient;
  }
  forceGetQueryClient() {
    if (!this.queryClient)
      throw new Error("Query client not available. You cannot use online functionality in offline mode.");
    return this.queryClient;
  }
  async getChainId() {
    if (!this.chainId) {
      const r = (await this.forceGetCometClient().status()).nodeInfo.network;
      if (!r)
        throw new Error("Chain ID must not be empty");
      this.chainId = r;
    }
    return this.chainId;
  }
  async getHeight() {
    return (await this.forceGetCometClient().status()).syncInfo.latestBlockHeight;
  }
  async getAccount(n) {
    try {
      const r = await this.forceGetQueryClient().auth.account(n);
      return r ? this.accountParser(r) : null;
    } catch (r) {
      if (/rpc error: code = NotFound/i.test(r.toString()))
        return null;
      throw r;
    }
  }
  async getSequence(n) {
    const r = await this.getAccount(n);
    if (!r)
      throw new Error(`Account '${n}' does not exist on chain. Send some tokens there before trying to query sequence.`);
    return {
      accountNumber: r.accountNumber,
      sequence: r.sequence
    };
  }
  async getBlock(n) {
    const r = await this.forceGetCometClient().block(n);
    return {
      id: (0, Hu.toHex)(r.blockId.hash).toUpperCase(),
      header: {
        version: {
          block: new Ff.Uint53(r.block.header.version.block).toString(),
          app: new Ff.Uint53(r.block.header.version.app).toString()
        },
        height: r.block.header.height,
        chainId: r.block.header.chainId,
        time: (0, $f.toRfc3339WithNanoseconds)(r.block.header.time)
      },
      txs: r.block.txs
    };
  }
  async getBalance(n, r) {
    return this.forceGetQueryClient().bank.balance(n, r);
  }
  /**
   * Queries all balances for all denoms that belong to this address.
   *
   * Uses the grpc queries (which iterates over the store internally), and we cannot get
   * proofs from such a method.
   */
  async getAllBalances(n) {
    return this.forceGetQueryClient().bank.allBalances(n);
  }
  async getBalanceStaked(n) {
    const r = [];
    let t;
    do {
      const { delegationResponses: f, pagination: S } = await this.forceGetQueryClient().staking.delegatorDelegations(n, t), w = f || [];
      r.push(...w), t = S == null ? void 0 : S.nextKey;
    } while (t !== void 0 && t.length !== 0);
    return r.reduce((f, S) => ((0, Lf.assert)(S.balance), f !== null ? (0, wI.addCoins)(f, S.balance) : S.balance), null);
  }
  async getDelegation(n, r) {
    var i;
    let t;
    try {
      t = (i = (await this.forceGetQueryClient().staking.delegation(n, r)).delegationResponse) == null ? void 0 : i.balance;
    } catch (f) {
      if (!f.toString().includes("key not found")) throw f;
    }
    return t || null;
  }
  async getTx(n) {
    return (await this.txsQuery(`tx.hash='${n}'`))[0] ?? null;
  }
  async searchTx(n) {
    let r;
    if (typeof n == "string")
      r = n;
    else if ((0, UI.isSearchTxQueryArray)(n))
      r = n.map((t) => typeof t.value == "string" ? `${t.key}='${t.value}'` : `${t.key}=${t.value}`).join(" AND ");
    else
      throw new Error("Got unsupported query type. See CosmJS 0.31 CHANGELOG for API breaking changes here.");
    return this.txsQuery(r);
  }
  disconnect() {
    this.cometClient && this.cometClient.disconnect();
  }
  /**
   * Broadcasts a signed transaction to the network and monitors its inclusion in a block.
   *
   * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
   * an error is thrown.
   *
   * If the transaction is not included in a block before the provided timeout, this errors with a `TimeoutError`.
   *
   * If the transaction is included in a block, a `DeliverTxResponse` is returned. The caller then
   * usually needs to check for execution success or failure.
   */
  async broadcastTx(n, r = 6e4, t = 3e3) {
    let i = !1;
    const f = setTimeout(() => {
      i = !0;
    }, r), S = async (T) => {
      if (i)
        throw new Rm(`Transaction with ID ${T} was submitted but was not yet found on the chain. You might want to check later. There was a wait of ${r / 1e3} seconds.`, T);
      await (0, Lf.sleep)(t);
      const J = await this.getTx(T);
      return J ? {
        code: J.code,
        height: J.height,
        txIndex: J.txIndex,
        events: J.events,
        rawLog: J.rawLog,
        transactionHash: T,
        msgResponses: J.msgResponses,
        gasUsed: J.gasUsed,
        gasWanted: J.gasWanted
      } : S(T);
    }, w = await this.broadcastTxSync(n);
    return new Promise((T, J) => S(w).then((C) => {
      clearTimeout(f), T(C);
    }, (C) => {
      clearTimeout(f), J(C);
    }));
  }
  /**
   * Broadcasts a signed transaction to the network without monitoring it.
   *
   * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
   * an error is thrown.
   *
   * If the transaction is broadcasted, a `string` containing the hash of the transaction is returned. The caller then
   * usually needs to check if the transaction was included in a block and was successful.
   *
   * @returns Returns the hash of the transaction
   */
  async broadcastTxSync(n) {
    const r = await this.forceGetCometClient().broadcastTxSync({ tx: n });
    return r.code ? Promise.reject(new Om(r.code, r.codespace ?? "", r.log)) : (0, Hu.toHex)(r.hash).toUpperCase();
  }
  async txsQuery(n) {
    return (await this.forceGetCometClient().txSearchAll({ query: n })).txs.map((t) => {
      const i = CI.TxMsgData.decode(t.result.data ?? new Uint8Array());
      return {
        height: t.height,
        txIndex: t.index,
        hash: (0, Hu.toHex)(t.hash).toUpperCase(),
        code: t.result.code,
        events: t.result.events.map(_I.fromTendermintEvent),
        rawLog: t.result.log || "",
        tx: t.tx,
        msgResponses: i.msgResponses,
        gasUsed: t.result.gasUsed,
        gasWanted: t.result.gasWanted
      };
    });
  }
}
He.StargateClient = Ha;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.SigningStargateClient = e.createDefaultAminoConverters = e.defaultRegistryTypes = void 0;
  const n = To, r = Ke, t = Ie, i = Ft, f = tl, S = Te, w = De, T = Fc, J = Xc, C = Qa, R = Qt, p = Is, m = Bo, v = ir, a = ho, d = ho, y = He;
  e.defaultRegistryTypes = [
    ["/cosmos.base.v1beta1.Coin", w.Coin],
    ...a.authzTypes,
    ...a.bankTypes,
    ...a.distributionTypes,
    ...a.feegrantTypes,
    ...a.govTypes,
    ...a.groupTypes,
    ...a.stakingTypes,
    ...a.ibcTypes,
    ...a.vestingTypes
  ];
  function _() {
    return {
      ...(0, d.createAuthzAminoConverters)(),
      ...(0, d.createBankAminoConverters)(),
      ...(0, d.createDistributionAminoConverters)(),
      ...(0, d.createGovAminoConverters)(),
      ...(0, d.createStakingAminoConverters)(),
      ...(0, d.createIbcAminoConverters)(),
      ...(0, d.createFeegrantAminoConverters)(),
      ...(0, d.createVestingAminoConverters)()
    };
  }
  e.createDefaultAminoConverters = _;
  class E extends y.StargateClient {
    /**
     * Creates an instance by connecting to the given CometBFT RPC endpoint.
     *
     * This uses auto-detection to decide between a CometBFT 0.38, Tendermint 0.37 and 0.34 client.
     * To set the Comet client explicitly, use `createWithSigner`.
     */
    static async connectWithSigner(V, o, h = {}) {
      const N = await (0, f.connectComet)(V);
      return E.createWithSigner(N, o, h);
    }
    /**
     * Creates an instance from a manually created Comet client.
     * Use this to use `Comet38Client` or `Tendermint37Client` instead of `Tendermint34Client`.
     */
    static async createWithSigner(V, o, h = {}) {
      return new E(V, o, h);
    }
    /**
     * Creates a client in offline mode.
     *
     * This should only be used in niche cases where you know exactly what you're doing,
     * e.g. when building an offline signing application.
     *
     * When you try to use online functionality with such a signer, an
     * exception will be raised.
     */
    static async offline(V, o = {}) {
      return new E(void 0, V, o);
    }
    constructor(V, o, h) {
      super(V, h);
      const { registry: N = new i.Registry(e.defaultRegistryTypes), aminoTypes: q = new m.AminoTypes(_()) } = h;
      this.registry = N, this.aminoTypes = q, this.signer = o, this.broadcastTimeoutMs = h.broadcastTimeoutMs, this.broadcastPollIntervalMs = h.broadcastPollIntervalMs, this.gasPrice = h.gasPrice;
    }
    async simulate(V, o, h) {
      const N = o.map((B) => this.registry.encodeAsAny(B)), q = (await this.signer.getAccounts()).find((B) => B.address === V);
      if (!q)
        throw new Error("Failed to retrieve account from signer");
      const u = (0, n.encodeSecp256k1Pubkey)(q.pubkey), { sequence: l } = await this.getSequence(V), { gasInfo: I } = await this.forceGetQueryClient().tx.simulate(N, h, u, l);
      return (0, S.assertDefined)(I), t.Uint53.fromString(I.gasUsed.toString()).toNumber();
    }
    async sendTokens(V, o, h, N, q = "") {
      const u = {
        typeUrl: "/cosmos.bank.v1beta1.MsgSend",
        value: {
          fromAddress: V,
          toAddress: o,
          amount: [...h]
        }
      };
      return this.signAndBroadcast(V, [u], N, q);
    }
    async delegateTokens(V, o, h, N, q = "") {
      const u = {
        typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
        value: J.MsgDelegate.fromPartial({
          delegatorAddress: V,
          validatorAddress: o,
          amount: h
        })
      };
      return this.signAndBroadcast(V, [u], N, q);
    }
    async undelegateTokens(V, o, h, N, q = "") {
      const u = {
        typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
        value: J.MsgUndelegate.fromPartial({
          delegatorAddress: V,
          validatorAddress: o,
          amount: h
        })
      };
      return this.signAndBroadcast(V, [u], N, q);
    }
    async withdrawRewards(V, o, h, N = "") {
      const q = {
        typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
        value: T.MsgWithdrawDelegatorReward.fromPartial({
          delegatorAddress: V,
          validatorAddress: o
        })
      };
      return this.signAndBroadcast(V, [q], h, N);
    }
    /**
     * @deprecated This API does not support setting the memo field of `MsgTransfer` (only the transaction memo).
     * We'll remove this method at some point because trying to wrap the various message types is a losing strategy.
     * Please migrate to `signAndBroadcast` with an `MsgTransferEncodeObject` created in the caller code instead.
     * @see https://github.com/cosmos/cosmjs/issues/1493
     */
    async sendIbcTokens(V, o, h, N, q, u, l, I, B = "") {
      const b = l ? BigInt(l) * BigInt(1e9) : void 0, D = {
        typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
        value: p.MsgTransfer.fromPartial({
          sourcePort: N,
          sourceChannel: q,
          sender: V,
          receiver: o,
          token: h,
          timeoutHeight: u,
          timeoutTimestamp: b
        })
      };
      return this.signAndBroadcast(V, [D], I, B);
    }
    async signAndBroadcast(V, o, h, N = "", q) {
      let u;
      if (h == "auto" || typeof h == "number") {
        (0, S.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
        const B = await this.simulate(V, o, N), b = typeof h == "number" ? h : 1.4;
        u = (0, v.calculateFee)(Math.round(B * b), this.gasPrice);
      } else
        u = h;
      const l = await this.sign(V, o, u, N, void 0, q), I = R.TxRaw.encode(l).finish();
      return this.broadcastTx(I, this.broadcastTimeoutMs, this.broadcastPollIntervalMs);
    }
    /**
     * This method is useful if you want to send a transaction in broadcast,
     * without waiting for it to be placed inside a block, because for example
     * I would like to receive the hash to later track the transaction with another tool.
     * @returns Returns the hash of the transaction
     */
    async signAndBroadcastSync(V, o, h, N = "", q) {
      let u;
      if (h == "auto" || typeof h == "number") {
        (0, S.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
        const B = await this.simulate(V, o, N), b = typeof h == "number" ? h : 1.3;
        u = (0, v.calculateFee)(Math.round(B * b), this.gasPrice);
      } else
        u = h;
      const l = await this.sign(V, o, u, N, void 0, q), I = R.TxRaw.encode(l).finish();
      return this.broadcastTxSync(I);
    }
    /**
     * Gets account number and sequence from the API, creates a sign doc,
     * creates a single signature and assembles the signed transaction.
     *
     * The sign mode (SIGN_MODE_DIRECT or SIGN_MODE_LEGACY_AMINO_JSON) is determined by this client's signer.
     *
     * You can pass signer data (account number, sequence and chain ID) explicitly instead of querying them
     * from the chain. This is needed when signing for a multisig account, but it also allows for offline signing
     * (See the SigningStargateClient.offline constructor).
     */
    async sign(V, o, h, N, q, u) {
      let l;
      if (q)
        l = q;
      else {
        const { accountNumber: I, sequence: B } = await this.getSequence(V), b = await this.getChainId();
        l = {
          accountNumber: I,
          sequence: B,
          chainId: b
        };
      }
      return (0, i.isOfflineDirectSigner)(this.signer) ? this.signDirect(V, o, h, N, l, u) : this.signAmino(V, o, h, N, l, u);
    }
    async signAmino(V, o, h, N, { accountNumber: q, sequence: u, chainId: l }, I) {
      (0, S.assert)(!(0, i.isOfflineDirectSigner)(this.signer));
      const B = (await this.signer.getAccounts()).find((ne) => ne.address === V);
      if (!B)
        throw new Error("Failed to retrieve account from signer");
      const b = (0, i.encodePubkey)((0, n.encodeSecp256k1Pubkey)(B.pubkey)), D = C.SignMode.SIGN_MODE_LEGACY_AMINO_JSON, Q = o.map((ne) => this.aminoTypes.toAmino(ne)), H = (0, n.makeSignDoc)(Q, h, l, N, q, u, I), { signature: s, signed: k } = await this.signer.signAmino(V, H), P = {
        typeUrl: "/cosmos.tx.v1beta1.TxBody",
        value: {
          messages: k.msgs.map((ne) => this.aminoTypes.fromAmino(ne)),
          memo: k.memo,
          timeoutHeight: I
        }
      }, A = this.registry.encode(P), W = t.Int53.fromString(k.fee.gas).toNumber(), L = t.Int53.fromString(k.sequence).toNumber(), $ = (0, i.makeAuthInfoBytes)([{ pubkey: b, sequence: L }], k.fee.amount, W, k.fee.granter, k.fee.payer, D);
      return R.TxRaw.fromPartial({
        bodyBytes: A,
        authInfoBytes: $,
        signatures: [(0, r.fromBase64)(s.signature)]
      });
    }
    async signDirect(V, o, h, N, { accountNumber: q, sequence: u, chainId: l }, I) {
      (0, S.assert)((0, i.isOfflineDirectSigner)(this.signer));
      const B = (await this.signer.getAccounts()).find((A) => A.address === V);
      if (!B)
        throw new Error("Failed to retrieve account from signer");
      const b = (0, i.encodePubkey)((0, n.encodeSecp256k1Pubkey)(B.pubkey)), D = {
        typeUrl: "/cosmos.tx.v1beta1.TxBody",
        value: {
          messages: o,
          memo: N,
          timeoutHeight: I
        }
      }, Q = this.registry.encode(D), H = t.Int53.fromString(h.gas).toNumber(), s = (0, i.makeAuthInfoBytes)([{ pubkey: b, sequence: u }], h.amount, H, h.granter, h.payer), k = (0, i.makeSignDoc)(Q, s, l, q), { signature: g, signed: P } = await this.signer.signDirect(V, k);
      return R.TxRaw.fromPartial({
        bodyBytes: P.bodyBytes,
        authInfoBytes: P.authInfoBytes,
        signatures: [(0, r.fromBase64)(g.signature)]
      });
    }
  }
  e.SigningStargateClient = E;
})(ny);
(function(e) {
  var n = x && x.__createBinding || (Object.create ? function(a, d, y, _) {
    _ === void 0 && (_ = y);
    var E = Object.getOwnPropertyDescriptor(d, y);
    (!E || ("get" in E ? !d.__esModule : E.writable || E.configurable)) && (E = { enumerable: !0, get: function() {
      return d[y];
    } }), Object.defineProperty(a, _, E);
  } : function(a, d, y, _) {
    _ === void 0 && (_ = y), a[_] = d[y];
  }), r = x && x.__setModuleDefault || (Object.create ? function(a, d) {
    Object.defineProperty(a, "default", { enumerable: !0, value: d });
  } : function(a, d) {
    a.default = d;
  }), t = x && x.__importStar || function(a) {
    if (a && a.__esModule) return a;
    var d = {};
    if (a != null) for (var y in a) y !== "default" && Object.prototype.hasOwnProperty.call(a, y) && n(d, a, y);
    return r(d, a), d;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.isMsgWithdrawDelegatorRewardEncodeObject = e.isMsgVoteWeightedEncodeObject = e.isMsgVoteEncodeObject = e.isMsgUndelegateEncodeObject = e.isMsgTransferEncodeObject = e.isMsgSubmitProposalEncodeObject = e.isMsgSendEncodeObject = e.isMsgEditValidatorEncodeObject = e.isMsgDepositEncodeObject = e.isMsgDelegateEncodeObject = e.isMsgCreateValidatorEncodeObject = e.isMsgBeginRedelegateEncodeObject = e.isAminoMsgWithdrawValidatorCommission = e.isAminoMsgWithdrawDelegatorReward = e.isAminoMsgVoteWeighted = e.isAminoMsgVote = e.isAminoMsgVerifyInvariant = e.isAminoMsgUnjail = e.isAminoMsgUndelegate = e.isAminoMsgTransfer = e.isAminoMsgSubmitProposal = e.isAminoMsgSubmitEvidence = e.isAminoMsgSetWithdrawAddress = e.isAminoMsgSend = e.isAminoMsgMultiSend = e.isAminoMsgFundCommunityPool = e.isAminoMsgEditValidator = e.isAminoMsgDeposit = e.isAminoMsgDelegate = e.isAminoMsgCreateVestingAccount = e.isAminoMsgCreateValidator = e.isAminoMsgBeginRedelegate = e.createVestingAminoConverters = e.createStakingAminoConverters = e.createSlashingAminoConverters = e.createIbcAminoConverters = e.createGroupAminoConverters = e.createGovAminoConverters = e.createFeegrantAminoConverters = e.createEvidenceAminoConverters = e.createDistributionAminoConverters = e.createCrysisAminoConverters = e.createBankAminoConverters = e.createAuthzAminoConverters = e.logs = e.GasPrice = e.calculateFee = e.fromTendermintEvent = e.AminoTypes = e.accountFromAny = void 0, e.parseCoins = e.makeCosmoshubPath = e.coins = e.coin = e.TimeoutError = e.StargateClient = e.isDeliverTxSuccess = e.isDeliverTxFailure = e.BroadcastTxError = e.assertIsDeliverTxSuccess = e.assertIsDeliverTxFailure = e.SigningStargateClient = e.defaultRegistryTypes = e.createDefaultAminoConverters = e.isSearchTxQueryArray = e.QueryClient = e.decodeCosmosSdkDecFromProto = e.createProtobufRpcClient = e.createPagination = e.makeMultisignedTxBytes = e.makeMultisignedTx = e.setupTxExtension = e.setupStakingExtension = e.setupSlashingExtension = e.setupMintExtension = e.setupIbcExtension = e.setupGovExtension = e.setupFeegrantExtension = e.setupDistributionExtension = e.setupBankExtension = e.setupAuthzExtension = e.setupAuthExtension = void 0;
  var i = ko;
  Object.defineProperty(e, "accountFromAny", { enumerable: !0, get: function() {
    return i.accountFromAny;
  } });
  var f = Bo;
  Object.defineProperty(e, "AminoTypes", { enumerable: !0, get: function() {
    return f.AminoTypes;
  } });
  var S = Oo;
  Object.defineProperty(e, "fromTendermintEvent", { enumerable: !0, get: function() {
    return S.fromTendermintEvent;
  } });
  var w = ir;
  Object.defineProperty(e, "calculateFee", { enumerable: !0, get: function() {
    return w.calculateFee;
  } }), Object.defineProperty(e, "GasPrice", { enumerable: !0, get: function() {
    return w.GasPrice;
  } }), e.logs = t(an);
  var T = ho;
  Object.defineProperty(e, "createAuthzAminoConverters", { enumerable: !0, get: function() {
    return T.createAuthzAminoConverters;
  } }), Object.defineProperty(e, "createBankAminoConverters", { enumerable: !0, get: function() {
    return T.createBankAminoConverters;
  } }), Object.defineProperty(e, "createCrysisAminoConverters", { enumerable: !0, get: function() {
    return T.createCrysisAminoConverters;
  } }), Object.defineProperty(e, "createDistributionAminoConverters", { enumerable: !0, get: function() {
    return T.createDistributionAminoConverters;
  } }), Object.defineProperty(e, "createEvidenceAminoConverters", { enumerable: !0, get: function() {
    return T.createEvidenceAminoConverters;
  } }), Object.defineProperty(e, "createFeegrantAminoConverters", { enumerable: !0, get: function() {
    return T.createFeegrantAminoConverters;
  } }), Object.defineProperty(e, "createGovAminoConverters", { enumerable: !0, get: function() {
    return T.createGovAminoConverters;
  } }), Object.defineProperty(e, "createGroupAminoConverters", { enumerable: !0, get: function() {
    return T.createGroupAminoConverters;
  } }), Object.defineProperty(e, "createIbcAminoConverters", { enumerable: !0, get: function() {
    return T.createIbcAminoConverters;
  } }), Object.defineProperty(e, "createSlashingAminoConverters", { enumerable: !0, get: function() {
    return T.createSlashingAminoConverters;
  } }), Object.defineProperty(e, "createStakingAminoConverters", { enumerable: !0, get: function() {
    return T.createStakingAminoConverters;
  } }), Object.defineProperty(e, "createVestingAminoConverters", { enumerable: !0, get: function() {
    return T.createVestingAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgBeginRedelegate", { enumerable: !0, get: function() {
    return T.isAminoMsgBeginRedelegate;
  } }), Object.defineProperty(e, "isAminoMsgCreateValidator", { enumerable: !0, get: function() {
    return T.isAminoMsgCreateValidator;
  } }), Object.defineProperty(e, "isAminoMsgCreateVestingAccount", { enumerable: !0, get: function() {
    return T.isAminoMsgCreateVestingAccount;
  } }), Object.defineProperty(e, "isAminoMsgDelegate", { enumerable: !0, get: function() {
    return T.isAminoMsgDelegate;
  } }), Object.defineProperty(e, "isAminoMsgDeposit", { enumerable: !0, get: function() {
    return T.isAminoMsgDeposit;
  } }), Object.defineProperty(e, "isAminoMsgEditValidator", { enumerable: !0, get: function() {
    return T.isAminoMsgEditValidator;
  } }), Object.defineProperty(e, "isAminoMsgFundCommunityPool", { enumerable: !0, get: function() {
    return T.isAminoMsgFundCommunityPool;
  } }), Object.defineProperty(e, "isAminoMsgMultiSend", { enumerable: !0, get: function() {
    return T.isAminoMsgMultiSend;
  } }), Object.defineProperty(e, "isAminoMsgSend", { enumerable: !0, get: function() {
    return T.isAminoMsgSend;
  } }), Object.defineProperty(e, "isAminoMsgSetWithdrawAddress", { enumerable: !0, get: function() {
    return T.isAminoMsgSetWithdrawAddress;
  } }), Object.defineProperty(e, "isAminoMsgSubmitEvidence", { enumerable: !0, get: function() {
    return T.isAminoMsgSubmitEvidence;
  } }), Object.defineProperty(e, "isAminoMsgSubmitProposal", { enumerable: !0, get: function() {
    return T.isAminoMsgSubmitProposal;
  } }), Object.defineProperty(e, "isAminoMsgTransfer", { enumerable: !0, get: function() {
    return T.isAminoMsgTransfer;
  } }), Object.defineProperty(e, "isAminoMsgUndelegate", { enumerable: !0, get: function() {
    return T.isAminoMsgUndelegate;
  } }), Object.defineProperty(e, "isAminoMsgUnjail", { enumerable: !0, get: function() {
    return T.isAminoMsgUnjail;
  } }), Object.defineProperty(e, "isAminoMsgVerifyInvariant", { enumerable: !0, get: function() {
    return T.isAminoMsgVerifyInvariant;
  } }), Object.defineProperty(e, "isAminoMsgVote", { enumerable: !0, get: function() {
    return T.isAminoMsgVote;
  } }), Object.defineProperty(e, "isAminoMsgVoteWeighted", { enumerable: !0, get: function() {
    return T.isAminoMsgVoteWeighted;
  } }), Object.defineProperty(e, "isAminoMsgWithdrawDelegatorReward", { enumerable: !0, get: function() {
    return T.isAminoMsgWithdrawDelegatorReward;
  } }), Object.defineProperty(e, "isAminoMsgWithdrawValidatorCommission", { enumerable: !0, get: function() {
    return T.isAminoMsgWithdrawValidatorCommission;
  } }), Object.defineProperty(e, "isMsgBeginRedelegateEncodeObject", { enumerable: !0, get: function() {
    return T.isMsgBeginRedelegateEncodeObject;
  } }), Object.defineProperty(e, "isMsgCreateValidatorEncodeObject", { enumerable: !0, get: function() {
    return T.isMsgCreateValidatorEncodeObject;
  } }), Object.defineProperty(e, "isMsgDelegateEncodeObject", { enumerable: !0, get: function() {
    return T.isMsgDelegateEncodeObject;
  } }), Object.defineProperty(e, "isMsgDepositEncodeObject", { enumerable: !0, get: function() {
    return T.isMsgDepositEncodeObject;
  } }), Object.defineProperty(e, "isMsgEditValidatorEncodeObject", { enumerable: !0, get: function() {
    return T.isMsgEditValidatorEncodeObject;
  } }), Object.defineProperty(e, "isMsgSendEncodeObject", { enumerable: !0, get: function() {
    return T.isMsgSendEncodeObject;
  } }), Object.defineProperty(e, "isMsgSubmitProposalEncodeObject", { enumerable: !0, get: function() {
    return T.isMsgSubmitProposalEncodeObject;
  } }), Object.defineProperty(e, "isMsgTransferEncodeObject", { enumerable: !0, get: function() {
    return T.isMsgTransferEncodeObject;
  } }), Object.defineProperty(e, "isMsgUndelegateEncodeObject", { enumerable: !0, get: function() {
    return T.isMsgUndelegateEncodeObject;
  } }), Object.defineProperty(e, "isMsgVoteEncodeObject", { enumerable: !0, get: function() {
    return T.isMsgVoteEncodeObject;
  } }), Object.defineProperty(e, "isMsgVoteWeightedEncodeObject", { enumerable: !0, get: function() {
    return T.isMsgVoteWeightedEncodeObject;
  } }), Object.defineProperty(e, "isMsgWithdrawDelegatorRewardEncodeObject", { enumerable: !0, get: function() {
    return T.isMsgWithdrawDelegatorRewardEncodeObject;
  } }), Object.defineProperty(e, "setupAuthExtension", { enumerable: !0, get: function() {
    return T.setupAuthExtension;
  } }), Object.defineProperty(e, "setupAuthzExtension", { enumerable: !0, get: function() {
    return T.setupAuthzExtension;
  } }), Object.defineProperty(e, "setupBankExtension", { enumerable: !0, get: function() {
    return T.setupBankExtension;
  } }), Object.defineProperty(e, "setupDistributionExtension", { enumerable: !0, get: function() {
    return T.setupDistributionExtension;
  } }), Object.defineProperty(e, "setupFeegrantExtension", { enumerable: !0, get: function() {
    return T.setupFeegrantExtension;
  } }), Object.defineProperty(e, "setupGovExtension", { enumerable: !0, get: function() {
    return T.setupGovExtension;
  } }), Object.defineProperty(e, "setupIbcExtension", { enumerable: !0, get: function() {
    return T.setupIbcExtension;
  } }), Object.defineProperty(e, "setupMintExtension", { enumerable: !0, get: function() {
    return T.setupMintExtension;
  } }), Object.defineProperty(e, "setupSlashingExtension", { enumerable: !0, get: function() {
    return T.setupSlashingExtension;
  } }), Object.defineProperty(e, "setupStakingExtension", { enumerable: !0, get: function() {
    return T.setupStakingExtension;
  } }), Object.defineProperty(e, "setupTxExtension", { enumerable: !0, get: function() {
    return T.setupTxExtension;
  } });
  var J = Dt;
  Object.defineProperty(e, "makeMultisignedTx", { enumerable: !0, get: function() {
    return J.makeMultisignedTx;
  } }), Object.defineProperty(e, "makeMultisignedTxBytes", { enumerable: !0, get: function() {
    return J.makeMultisignedTxBytes;
  } });
  var C = Ye;
  Object.defineProperty(e, "createPagination", { enumerable: !0, get: function() {
    return C.createPagination;
  } }), Object.defineProperty(e, "createProtobufRpcClient", { enumerable: !0, get: function() {
    return C.createProtobufRpcClient;
  } }), Object.defineProperty(e, "decodeCosmosSdkDecFromProto", { enumerable: !0, get: function() {
    return C.decodeCosmosSdkDecFromProto;
  } }), Object.defineProperty(e, "QueryClient", { enumerable: !0, get: function() {
    return C.QueryClient;
  } });
  var R = No;
  Object.defineProperty(e, "isSearchTxQueryArray", { enumerable: !0, get: function() {
    return R.isSearchTxQueryArray;
  } });
  var p = ny;
  Object.defineProperty(e, "createDefaultAminoConverters", { enumerable: !0, get: function() {
    return p.createDefaultAminoConverters;
  } }), Object.defineProperty(e, "defaultRegistryTypes", { enumerable: !0, get: function() {
    return p.defaultRegistryTypes;
  } }), Object.defineProperty(e, "SigningStargateClient", { enumerable: !0, get: function() {
    return p.SigningStargateClient;
  } });
  var m = He;
  Object.defineProperty(e, "assertIsDeliverTxFailure", { enumerable: !0, get: function() {
    return m.assertIsDeliverTxFailure;
  } }), Object.defineProperty(e, "assertIsDeliverTxSuccess", { enumerable: !0, get: function() {
    return m.assertIsDeliverTxSuccess;
  } }), Object.defineProperty(e, "BroadcastTxError", { enumerable: !0, get: function() {
    return m.BroadcastTxError;
  } }), Object.defineProperty(e, "isDeliverTxFailure", { enumerable: !0, get: function() {
    return m.isDeliverTxFailure;
  } }), Object.defineProperty(e, "isDeliverTxSuccess", { enumerable: !0, get: function() {
    return m.isDeliverTxSuccess;
  } }), Object.defineProperty(e, "StargateClient", { enumerable: !0, get: function() {
    return m.StargateClient;
  } }), Object.defineProperty(e, "TimeoutError", { enumerable: !0, get: function() {
    return m.TimeoutError;
  } });
  var v = Ft;
  Object.defineProperty(e, "coin", { enumerable: !0, get: function() {
    return v.coin;
  } }), Object.defineProperty(e, "coins", { enumerable: !0, get: function() {
    return v.coins;
  } }), Object.defineProperty(e, "makeCosmoshubPath", { enumerable: !0, get: function() {
    return v.makeCosmoshubPath;
  } }), Object.defineProperty(e, "parseCoins", { enumerable: !0, get: function() {
    return v.parseCoins;
  } });
})(Zf);
const FI = /* @__PURE__ */ Em({
  __proto__: null
}, [Zf]);
export {
  Ie as a,
  Te as b,
  _e as c,
  Zf as d,
  tl as e,
  nl as f,
  Ft as g,
  Xc as h,
  FI as i,
  Ae as p,
  Fc as t
};
//# sourceMappingURL=index-D-iNVJVY.js.map
