let r = 0;
const s = [], x = (e, t, n) => {
  const i = {
    type: e,
    id: String(++r),
    date: /* @__PURE__ */ new Date()
  };
  t && (i.message = t), h(i);
}, p = ({ type: e, message: t, data: n, context: i }) => {
  const o = {
    type: e,
    id: String(++r),
    date: /* @__PURE__ */ new Date()
  };
  t && (o.message = t), n && (o.data = n), i && (o.context = i), h(o);
};
class c {
  constructor(t, n) {
    this.type = t, this.context = n;
  }
  trace(t, n) {
    p({
      type: this.type,
      message: t,
      data: n,
      context: this.context
    });
  }
  getContext() {
    return this.context;
  }
  setContext(t) {
    this.context = t;
  }
  updateContext(t) {
    this.context = Object.assign(Object.assign({}, this.context), t);
  }
  getType() {
    return this.type;
  }
  setType(t) {
    this.type = t;
  }
  /**
   * Create a new instance of the LocalTracer with an updated `type`
   *
   * It does not mutate the calling instance, but returns a new LocalTracer,
   * following a simple builder pattern.
   */
  withType(t) {
    return new c(t, this.context);
  }
  /**
   * Create a new instance of the LocalTracer with a new `context`
   *
   * It does not mutate the calling instance, but returns a new LocalTracer,
   * following a simple builder pattern.
   *
   * @param context A TraceContext, that can undefined to reset the context
   */
  withContext(t) {
    return new c(this.type, t);
  }
  /**
   * Create a new instance of the LocalTracer with an updated `context`,
   * on which an additional context is merged with the existing one.
   *
   * It does not mutate the calling instance, but returns a new LocalTracer,
   * following a simple builder pattern.
   */
  withUpdatedContext(t) {
    return new c(this.type, Object.assign(Object.assign({}, this.context), t));
  }
}
const d = (e) => (s.push(e), () => {
  const t = s.indexOf(e);
  t !== -1 && (s[t] = s[s.length - 1], s.pop());
});
function h(e) {
  for (let t = 0; t < s.length; t++)
    try {
      s[t](e);
    } catch {
    }
}
typeof window < "u" && (window.__ledgerLogsListen = d);
export {
  c as L,
  x as l
};
//# sourceMappingURL=index-Chfa4EHr.js.map
