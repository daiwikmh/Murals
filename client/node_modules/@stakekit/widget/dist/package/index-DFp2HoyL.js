"use client";
import { m as v, o as R, k as ss, p as jr, U as Ta, g as La } from "./index.package-BC048X0m.js";
import { b as tn, s as xa, r as ro } from "./readable-browser---6EBavs.js";
import { a as K, b as nn, r as Oa } from "./hooks.module-TMImTKxr.js";
import { e as so } from "./events-rGQ7b66e.js";
import { a as Ba } from "./index-C7yl2I7O.js";
var io = {}, yt = {}, rn = {};
Object.defineProperty(rn, "__esModule", { value: !0 });
rn.walletLogo = void 0;
const Fa = (e, t) => {
  let n;
  switch (e) {
    case "standard":
      return n = t, `data:image/svg+xml,%3Csvg width='${t}' height='${n}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `;
    case "circle":
      return n = t, `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${t}' height='${n}' viewBox='0 0 999.81 999.81'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052fe;%7D.cls-2%7Bfill:%23fefefe;%7D.cls-3%7Bfill:%230152fe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M655-115.9h56c.83,1.59,2.36.88,3.56,1a478,478,0,0,1,75.06,10.42C891.4-81.76,978.33-32.58,1049.19,44q116.7,126,131.94,297.61c.38,4.14-.34,8.53,1.78,12.45v59c-1.58.84-.91,2.35-1,3.56a482.05,482.05,0,0,1-10.38,74.05c-24,106.72-76.64,196.76-158.83,268.93s-178.18,112.82-287.2,122.6c-4.83.43-9.86-.25-14.51,1.77H654c-1-1.68-2.69-.91-4.06-1a496.89,496.89,0,0,1-105.9-18.59c-93.54-27.42-172.78-77.59-236.91-150.94Q199.34,590.1,184.87,426.58c-.47-5.19.25-10.56-1.77-15.59V355c1.68-1,.91-2.7,1-4.06a498.12,498.12,0,0,1,18.58-105.9c26-88.75,72.64-164.9,140.6-227.57q126-116.27,297.21-131.61C645.32-114.57,650.35-113.88,655-115.9Zm377.92,500c0-192.44-156.31-349.49-347.56-350.15-194.13-.68-350.94,155.13-352.29,347.42-1.37,194.55,155.51,352.1,348.56,352.47C876.15,734.23,1032.93,577.84,1032.93,384.11Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-2' d='M1032.93,384.11c0,193.73-156.78,350.12-351.29,349.74-193-.37-349.93-157.92-348.56-352.47C334.43,189.09,491.24,33.28,685.37,34,876.62,34.62,1032.94,191.67,1032.93,384.11ZM683,496.81q43.74,0,87.48,0c15.55,0,25.32-9.72,25.33-25.21q0-87.48,0-175c0-15.83-9.68-25.46-25.59-25.46H595.77c-15.88,0-25.57,9.64-25.58,25.46q0,87.23,0,174.45c0,16.18,9.59,25.7,25.84,25.71Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-3' d='M683,496.81H596c-16.25,0-25.84-9.53-25.84-25.71q0-87.23,0-174.45c0-15.82,9.7-25.46,25.58-25.46H770.22c15.91,0,25.59,9.63,25.59,25.46q0,87.47,0,175c0,15.49-9.78,25.2-25.33,25.21Q726.74,496.84,683,496.81Z' transform='translate(-183.1 115.9)'/%3E%3C/svg%3E`;
    case "text":
      return n = (0.1 * t).toFixed(2), `data:image/svg+xml,%3Csvg width='${t}' height='${n}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
    case "textWithLogo":
      return n = (0.25 * t).toFixed(2), `data:image/svg+xml,%3Csvg width='${t}' height='${n}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
    case "textLight":
      return n = (0.1 * t).toFixed(2), `data:image/svg+xml,%3Csvg width='${t}' height='${n}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
    case "textWithLogoLight":
      return n = (0.25 * t).toFixed(2), `data:image/svg+xml,%3Csvg width='${t}' height='${n}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
    default:
      return n = t, `data:image/svg+xml,%3Csvg width='${t}' height='${n}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `;
  }
};
rn.walletLogo = Fa;
var sn = {};
Object.defineProperty(sn, "__esModule", { value: !0 });
sn.LINK_API_URL = void 0;
sn.LINK_API_URL = "https://www.walletlink.org";
var m = {}, vt = {}, ve = {};
Object.defineProperty(ve, "__esModule", { value: !0 });
ve.errorValues = ve.standardErrorCodes = void 0;
ve.standardErrorCodes = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901,
    unsupportedChain: 4902
  }
};
ve.errorValues = {
  "-32700": {
    standard: "JSON RPC 2.0",
    message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
  },
  "-32600": {
    standard: "JSON RPC 2.0",
    message: "The JSON sent is not a valid Request object."
  },
  "-32601": {
    standard: "JSON RPC 2.0",
    message: "The method does not exist / is not available."
  },
  "-32602": {
    standard: "JSON RPC 2.0",
    message: "Invalid method parameter(s)."
  },
  "-32603": {
    standard: "JSON RPC 2.0",
    message: "Internal JSON-RPC error."
  },
  "-32000": {
    standard: "EIP-1474",
    message: "Invalid input."
  },
  "-32001": {
    standard: "EIP-1474",
    message: "Resource not found."
  },
  "-32002": {
    standard: "EIP-1474",
    message: "Resource unavailable."
  },
  "-32003": {
    standard: "EIP-1474",
    message: "Transaction rejected."
  },
  "-32004": {
    standard: "EIP-1474",
    message: "Method not supported."
  },
  "-32005": {
    standard: "EIP-1474",
    message: "Request limit exceeded."
  },
  4001: {
    standard: "EIP-1193",
    message: "User rejected the request."
  },
  4100: {
    standard: "EIP-1193",
    message: "The requested account and/or method has not been authorized by the user."
  },
  4200: {
    standard: "EIP-1193",
    message: "The requested method is not supported by this Ethereum provider."
  },
  4900: {
    standard: "EIP-1193",
    message: "The provider is disconnected from all chains."
  },
  4901: {
    standard: "EIP-1193",
    message: "The provider is disconnected from the specified chain."
  },
  4902: {
    standard: "EIP-3085",
    message: "Unrecognized chain ID."
  }
};
var on = {}, an = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.serialize = e.getErrorCode = e.isValidCode = e.getMessageFromCode = e.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
  const t = ve, n = "Unspecified error message.";
  e.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
  function r(u, f = n) {
    if (u && Number.isInteger(u)) {
      const b = u.toString();
      if (d(t.errorValues, b))
        return t.errorValues[b].message;
      if (c(u))
        return e.JSON_RPC_SERVER_ERROR_MESSAGE;
    }
    return f;
  }
  e.getMessageFromCode = r;
  function s(u) {
    if (!Number.isInteger(u))
      return !1;
    const f = u.toString();
    return !!(t.errorValues[f] || c(u));
  }
  e.isValidCode = s;
  function i(u) {
    var f;
    if (typeof u == "number")
      return u;
    if (o(u))
      return (f = u.code) !== null && f !== void 0 ? f : u.errorCode;
  }
  e.getErrorCode = i;
  function o(u) {
    return typeof u == "object" && u !== null && (typeof u.code == "number" || typeof u.errorCode == "number");
  }
  function a(u, { shouldIncludeStack: f = !1 } = {}) {
    const b = {};
    if (u && typeof u == "object" && !Array.isArray(u) && d(u, "code") && s(u.code)) {
      const w = u;
      b.code = w.code, w.message && typeof w.message == "string" ? (b.message = w.message, d(w, "data") && (b.data = w.data)) : (b.message = r(b.code), b.data = { originalError: l(u) });
    } else
      b.code = t.standardErrorCodes.rpc.internal, b.message = h(u, "message") ? u.message : n, b.data = { originalError: l(u) };
    return f && (b.stack = h(u, "stack") ? u.stack : void 0), b;
  }
  e.serialize = a;
  function c(u) {
    return u >= -32099 && u <= -32e3;
  }
  function l(u) {
    return u && typeof u == "object" && !Array.isArray(u) ? Object.assign({}, u) : u;
  }
  function d(u, f) {
    return Object.prototype.hasOwnProperty.call(u, f);
  }
  function h(u, f) {
    return typeof u == "object" && u !== null && f in u && typeof u[f] == "string";
  }
})(an);
Object.defineProperty(on, "__esModule", { value: !0 });
on.standardErrors = void 0;
const z = ve, oo = an;
on.standardErrors = {
  rpc: {
    parse: (e) => re(z.standardErrorCodes.rpc.parse, e),
    invalidRequest: (e) => re(z.standardErrorCodes.rpc.invalidRequest, e),
    invalidParams: (e) => re(z.standardErrorCodes.rpc.invalidParams, e),
    methodNotFound: (e) => re(z.standardErrorCodes.rpc.methodNotFound, e),
    internal: (e) => re(z.standardErrorCodes.rpc.internal, e),
    server: (e) => {
      if (!e || typeof e != "object" || Array.isArray(e))
        throw new Error("Ethereum RPC Server errors must provide single object argument.");
      const { code: t } = e;
      if (!Number.isInteger(t) || t > -32005 || t < -32099)
        throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
      return re(t, e);
    },
    invalidInput: (e) => re(z.standardErrorCodes.rpc.invalidInput, e),
    resourceNotFound: (e) => re(z.standardErrorCodes.rpc.resourceNotFound, e),
    resourceUnavailable: (e) => re(z.standardErrorCodes.rpc.resourceUnavailable, e),
    transactionRejected: (e) => re(z.standardErrorCodes.rpc.transactionRejected, e),
    methodNotSupported: (e) => re(z.standardErrorCodes.rpc.methodNotSupported, e),
    limitExceeded: (e) => re(z.standardErrorCodes.rpc.limitExceeded, e)
  },
  provider: {
    userRejectedRequest: (e) => Ue(z.standardErrorCodes.provider.userRejectedRequest, e),
    unauthorized: (e) => Ue(z.standardErrorCodes.provider.unauthorized, e),
    unsupportedMethod: (e) => Ue(z.standardErrorCodes.provider.unsupportedMethod, e),
    disconnected: (e) => Ue(z.standardErrorCodes.provider.disconnected, e),
    chainDisconnected: (e) => Ue(z.standardErrorCodes.provider.chainDisconnected, e),
    unsupportedChain: (e) => Ue(z.standardErrorCodes.provider.unsupportedChain, e),
    custom: (e) => {
      if (!e || typeof e != "object" || Array.isArray(e))
        throw new Error("Ethereum Provider custom errors must provide single object argument.");
      const { code: t, message: n, data: r } = e;
      if (!n || typeof n != "string")
        throw new Error('"message" must be a nonempty string');
      return new lo(t, n, r);
    }
  }
};
function re(e, t) {
  const [n, r] = ao(t);
  return new co(e, n || (0, oo.getMessageFromCode)(e), r);
}
function Ue(e, t) {
  const [n, r] = ao(t);
  return new lo(e, n || (0, oo.getMessageFromCode)(e), r);
}
function ao(e) {
  if (e) {
    if (typeof e == "string")
      return [e];
    if (typeof e == "object" && !Array.isArray(e)) {
      const { message: t, data: n } = e;
      if (t && typeof t != "string")
        throw new Error("Must specify string message.");
      return [t || void 0, n];
    }
  }
  return [];
}
let co = class extends Error {
  constructor(t, n, r) {
    if (!Number.isInteger(t))
      throw new Error('"code" must be an integer.');
    if (!n || typeof n != "string")
      throw new Error('"message" must be a nonempty string.');
    super(n), this.code = t, r !== void 0 && (this.data = r);
  }
}, lo = class extends co {
  /**
   * Create an Ethereum Provider JSON-RPC error.
   * `code` must be an integer in the 1000 <= 4999 range.
   */
  constructor(t, n, r) {
    if (!ja(t))
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    super(t, n, r);
  }
};
function ja(e) {
  return Number.isInteger(e) && e >= 1e3 && e <= 4999;
}
var cn = {}, it = {};
Object.defineProperty(it, "__esModule", { value: !0 });
it.isErrorResponse = void 0;
function Da(e) {
  return e.errorMessage !== void 0;
}
it.isErrorResponse = Da;
var ot = {};
Object.defineProperty(ot, "__esModule", { value: !0 });
ot.LIB_VERSION = void 0;
ot.LIB_VERSION = "3.9.3";
Object.defineProperty(cn, "__esModule", { value: !0 });
cn.serializeError = void 0;
const $a = it, Ha = ot, Ua = ve, Wa = an;
function za(e, t) {
  const n = (0, Wa.serialize)(Va(e), {
    shouldIncludeStack: !0
  }), r = new URL("https://docs.cloud.coinbase.com/wallet-sdk/docs/errors");
  r.searchParams.set("version", Ha.LIB_VERSION), r.searchParams.set("code", n.code.toString());
  const s = Ja(n.data, t);
  return s && r.searchParams.set("method", s), r.searchParams.set("message", n.message), Object.assign(Object.assign({}, n), { docUrl: r.href });
}
cn.serializeError = za;
function Va(e) {
  return typeof e == "string" ? {
    message: e,
    code: Ua.standardErrorCodes.rpc.internal
  } : (0, $a.isErrorResponse)(e) ? Object.assign(Object.assign({}, e), { message: e.errorMessage, code: e.errorCode, data: { method: e.method } }) : e;
}
function Ja(e, t) {
  const n = e == null ? void 0 : e.method;
  if (n)
    return n;
  if (t !== void 0) {
    if (typeof t == "string")
      return t;
    if (Array.isArray(t)) {
      if (t.length > 0)
        return t[0].method;
    } else return t.method;
  }
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.standardErrors = e.standardErrorCodes = e.serializeError = e.getMessageFromCode = e.getErrorCode = void 0;
  const t = ve;
  Object.defineProperty(e, "standardErrorCodes", { enumerable: !0, get: function() {
    return t.standardErrorCodes;
  } });
  const n = on;
  Object.defineProperty(e, "standardErrors", { enumerable: !0, get: function() {
    return n.standardErrors;
  } });
  const r = cn;
  Object.defineProperty(e, "serializeError", { enumerable: !0, get: function() {
    return r.serializeError;
  } });
  const s = an;
  Object.defineProperty(e, "getErrorCode", { enumerable: !0, get: function() {
    return s.getErrorCode;
  } }), Object.defineProperty(e, "getMessageFromCode", { enumerable: !0, get: function() {
    return s.getMessageFromCode;
  } });
})(vt);
var $ = {};
Object.defineProperty($, "__esModule", { value: !0 });
$.ProviderType = $.RegExpString = $.IntNumber = $.BigIntString = $.AddressString = $.HexString = $.OpaqueType = void 0;
function Et() {
  return (e) => e;
}
$.OpaqueType = Et;
$.HexString = Et();
$.AddressString = Et();
$.BigIntString = Et();
function qa(e) {
  return Math.floor(e);
}
$.IntNumber = qa;
$.RegExpString = Et();
var ui;
(function(e) {
  e.CoinbaseWallet = "CoinbaseWallet", e.MetaMask = "MetaMask", e.Unselected = "";
})(ui || ($.ProviderType = ui = {}));
var Za = v && v.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(m, "__esModule", { value: !0 });
m.isMobileWeb = m.getLocation = m.isInIFrame = m.createQrUrl = m.getFavicon = m.range = m.isBigNumber = m.ensureParsedJSONObject = m.ensureBN = m.ensureRegExpString = m.ensureIntNumber = m.ensureBuffer = m.ensureAddressString = m.ensureEvenLengthHexString = m.ensureHexString = m.isHexString = m.prepend0x = m.strip0x = m.has0xPrefix = m.hexStringFromIntNumber = m.intNumberFromHexString = m.bigIntStringFromBN = m.hexStringFromBuffer = m.hexStringToUint8Array = m.uint8ArrayToHex = m.randomBytesHex = void 0;
const Ce = Za(tn), De = vt, ae = $, uo = /^[0-9]*$/, ho = /^[a-f0-9]*$/;
function Ga(e) {
  return fo(crypto.getRandomValues(new Uint8Array(e)));
}
m.randomBytesHex = Ga;
function fo(e) {
  return [...e].map((t) => t.toString(16).padStart(2, "0")).join("");
}
m.uint8ArrayToHex = fo;
function Qa(e) {
  return new Uint8Array(e.match(/.{1,2}/g).map((t) => parseInt(t, 16)));
}
m.hexStringToUint8Array = Qa;
function Ka(e, t = !1) {
  const n = e.toString("hex");
  return (0, ae.HexString)(t ? `0x${n}` : n);
}
m.hexStringFromBuffer = Ka;
function Ya(e) {
  return (0, ae.BigIntString)(e.toString(10));
}
m.bigIntStringFromBN = Ya;
function Xa(e) {
  return (0, ae.IntNumber)(new Ce.default(Ct(e, !1), 16).toNumber());
}
m.intNumberFromHexString = Xa;
function ec(e) {
  return (0, ae.HexString)(`0x${new Ce.default(e).toString(16)}`);
}
m.hexStringFromIntNumber = ec;
function is(e) {
  return e.startsWith("0x") || e.startsWith("0X");
}
m.has0xPrefix = is;
function ln(e) {
  return is(e) ? e.slice(2) : e;
}
m.strip0x = ln;
function go(e) {
  return is(e) ? `0x${e.slice(2)}` : `0x${e}`;
}
m.prepend0x = go;
function kt(e) {
  if (typeof e != "string")
    return !1;
  const t = ln(e).toLowerCase();
  return ho.test(t);
}
m.isHexString = kt;
function po(e, t = !1) {
  if (typeof e == "string") {
    const n = ln(e).toLowerCase();
    if (ho.test(n))
      return (0, ae.HexString)(t ? `0x${n}` : n);
  }
  throw De.standardErrors.rpc.invalidParams(`"${String(e)}" is not a hexadecimal string`);
}
m.ensureHexString = po;
function Ct(e, t = !1) {
  let n = po(e, !1);
  return n.length % 2 === 1 && (n = (0, ae.HexString)(`0${n}`)), t ? (0, ae.HexString)(`0x${n}`) : n;
}
m.ensureEvenLengthHexString = Ct;
function tc(e) {
  if (typeof e == "string") {
    const t = ln(e).toLowerCase();
    if (kt(t) && t.length === 40)
      return (0, ae.AddressString)(go(t));
  }
  throw De.standardErrors.rpc.invalidParams(`Invalid Ethereum address: ${String(e)}`);
}
m.ensureAddressString = tc;
function nc(e) {
  if (R.isBuffer(e))
    return e;
  if (typeof e == "string") {
    if (kt(e)) {
      const t = Ct(e, !1);
      return R.from(t, "hex");
    }
    return R.from(e, "utf8");
  }
  throw De.standardErrors.rpc.invalidParams(`Not binary data: ${String(e)}`);
}
m.ensureBuffer = nc;
function mo(e) {
  if (typeof e == "number" && Number.isInteger(e))
    return (0, ae.IntNumber)(e);
  if (typeof e == "string") {
    if (uo.test(e))
      return (0, ae.IntNumber)(Number(e));
    if (kt(e))
      return (0, ae.IntNumber)(new Ce.default(Ct(e, !1), 16).toNumber());
  }
  throw De.standardErrors.rpc.invalidParams(`Not an integer: ${String(e)}`);
}
m.ensureIntNumber = mo;
function rc(e) {
  if (e instanceof RegExp)
    return (0, ae.RegExpString)(e.toString());
  throw De.standardErrors.rpc.invalidParams(`Not a RegExp: ${String(e)}`);
}
m.ensureRegExpString = rc;
function sc(e) {
  if (e !== null && (Ce.default.isBN(e) || bo(e)))
    return new Ce.default(e.toString(10), 10);
  if (typeof e == "number")
    return new Ce.default(mo(e));
  if (typeof e == "string") {
    if (uo.test(e))
      return new Ce.default(e, 10);
    if (kt(e))
      return new Ce.default(Ct(e, !1), 16);
  }
  throw De.standardErrors.rpc.invalidParams(`Not an integer: ${String(e)}`);
}
m.ensureBN = sc;
function ic(e) {
  if (typeof e == "string")
    return JSON.parse(e);
  if (typeof e == "object")
    return e;
  throw De.standardErrors.rpc.invalidParams(`Not a JSON string or an object: ${String(e)}`);
}
m.ensureParsedJSONObject = ic;
function bo(e) {
  if (e == null || typeof e.constructor != "function")
    return !1;
  const { constructor: t } = e;
  return typeof t.config == "function" && typeof t.EUCLID == "number";
}
m.isBigNumber = bo;
function oc(e, t) {
  return Array.from({ length: t - e }, (n, r) => e + r);
}
m.range = oc;
function ac() {
  const e = document.querySelector('link[sizes="192x192"]') || document.querySelector('link[sizes="180x180"]') || document.querySelector('link[rel="icon"]') || document.querySelector('link[rel="shortcut icon"]'), { protocol: t, host: n } = document.location, r = e ? e.getAttribute("href") : null;
  return !r || r.startsWith("javascript:") || r.startsWith("vbscript:") ? null : r.startsWith("http://") || r.startsWith("https://") || r.startsWith("data:") ? r : r.startsWith("//") ? t + r : `${t}//${n}${r}`;
}
m.getFavicon = ac;
function cc(e, t, n, r, s, i) {
  const o = r ? "parent-id" : "id", a = new URLSearchParams({
    [o]: e,
    secret: t,
    server: n,
    v: s,
    chainId: i.toString()
  }).toString();
  return `${n}/#/link?${a}`;
}
m.createQrUrl = cc;
function yo() {
  try {
    return window.frameElement !== null;
  } catch {
    return !1;
  }
}
m.isInIFrame = yo;
function lc() {
  try {
    return yo() && window.top ? window.top.location : window.location;
  } catch {
    return window.location;
  }
}
m.getLocation = lc;
function dc() {
  var e;
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test((e = window == null ? void 0 : window.navigator) === null || e === void 0 ? void 0 : e.userAgent);
}
m.isMobileWeb = dc;
var dn = {};
Object.defineProperty(dn, "__esModule", { value: !0 });
dn.ScopedLocalStorage = void 0;
class uc {
  // eslint-disable-next-line no-useless-constructor
  constructor(t) {
    this.scope = t;
  }
  setItem(t, n) {
    localStorage.setItem(this.scopedKey(t), n);
  }
  getItem(t) {
    return localStorage.getItem(this.scopedKey(t));
  }
  removeItem(t) {
    localStorage.removeItem(this.scopedKey(t));
  }
  clear() {
    const t = this.scopedKey(""), n = [];
    for (let r = 0; r < localStorage.length; r++) {
      const s = localStorage.key(r);
      typeof s == "string" && s.startsWith(t) && n.push(s);
    }
    n.forEach((r) => localStorage.removeItem(r));
  }
  scopedKey(t) {
    return `${this.scope}:${t}`;
  }
}
dn.ScopedLocalStorage = uc;
var Xe = {}, St = {}, Rt = {}, at = {};
Object.defineProperty(at, "__esModule", { value: !0 });
at.EVENTS = void 0;
at.EVENTS = {
  STARTED_CONNECTING: "walletlink_sdk.started.connecting",
  CONNECTED_STATE_CHANGE: "walletlink_sdk.connected",
  DISCONNECTED: "walletlink_sdk.disconnected",
  METADATA_DESTROYED: "walletlink_sdk_metadata_destroyed",
  LINKED: "walletlink_sdk.linked",
  FAILURE: "walletlink_sdk.generic_failure",
  SESSION_CONFIG_RECEIVED: "walletlink_sdk.session_config_event_received",
  ETH_ACCOUNTS_STATE: "walletlink_sdk.eth_accounts_state",
  SESSION_STATE_CHANGE: "walletlink_sdk.session_state_change",
  UNLINKED_ERROR_STATE: "walletlink_sdk.unlinked_error_state",
  SKIPPED_CLEARING_SESSION: "walletlink_sdk.skipped_clearing_session",
  GENERAL_ERROR: "walletlink_sdk.general_error",
  WEB3_REQUEST: "walletlink_sdk.web3.request",
  WEB3_REQUEST_PUBLISHED: "walletlink_sdk.web3.request_published",
  WEB3_RESPONSE: "walletlink_sdk.web3.response",
  METHOD_NOT_IMPLEMENTED: "walletlink_sdk.method_not_implemented",
  UNKNOWN_ADDRESS_ENCOUNTERED: "walletlink_sdk.unknown_address_encountered"
};
var oe = {};
Object.defineProperty(oe, "__esModule", { value: !0 });
oe.RelayAbstract = oe.APP_VERSION_KEY = oe.LOCAL_STORAGE_ADDRESSES_KEY = oe.WALLET_USER_NAME_KEY = void 0;
const hi = vt;
oe.WALLET_USER_NAME_KEY = "walletUsername";
oe.LOCAL_STORAGE_ADDRESSES_KEY = "Addresses";
oe.APP_VERSION_KEY = "AppVersion";
class hc {
  async makeEthereumJSONRPCRequest(t, n) {
    if (!n)
      throw new Error("Error: No jsonRpcUrl provided");
    return window.fetch(n, {
      method: "POST",
      body: JSON.stringify(t),
      mode: "cors",
      headers: { "Content-Type": "application/json" }
    }).then((r) => r.json()).then((r) => {
      if (!r)
        throw hi.standardErrors.rpc.parse({});
      const s = r, { error: i } = s;
      if (i)
        throw (0, hi.serializeError)(i, t.method);
      return s;
    });
  }
}
oe.RelayAbstract = hc;
var ct = {};
Object.defineProperty(ct, "__esModule", { value: !0 });
ct.Session = void 0;
const fi = xa, gi = m, pi = "session:id", mi = "session:secret", bi = "session:linked";
class os {
  constructor(t, n, r, s) {
    this._storage = t, this._id = n || (0, gi.randomBytesHex)(16), this._secret = r || (0, gi.randomBytesHex)(32), this._key = new fi.sha256().update(`${this._id}, ${this._secret} WalletLink`).digest("hex"), this._linked = !!s;
  }
  static load(t) {
    const n = t.getItem(pi), r = t.getItem(bi), s = t.getItem(mi);
    return n && s ? new os(t, n, s, r === "1") : null;
  }
  /**
   * Takes in a session ID and returns the sha256 hash of it.
   * @param sessionId session ID
   */
  static hash(t) {
    return new fi.sha256().update(t).digest("hex");
  }
  get id() {
    return this._id;
  }
  get secret() {
    return this._secret;
  }
  get key() {
    return this._key;
  }
  get linked() {
    return this._linked;
  }
  set linked(t) {
    this._linked = t, this.persistLinked();
  }
  save() {
    return this._storage.setItem(pi, this._id), this._storage.setItem(mi, this._secret), this.persistLinked(), this;
  }
  persistLinked() {
    this._storage.setItem(bi, this._linked ? "1" : "0");
  }
}
ct.Session = os;
var un = {}, hn = {};
Object.defineProperty(hn, "__esModule", { value: !0 });
hn.Cipher = void 0;
const Ut = m;
class fc {
  // @param secret hex representation of 32-byte secret
  constructor(t) {
    this.secret = t;
  }
  /**
   *
   * @param plainText string to be encrypted
   * returns hex string representation of bytes in the order: initialization vector (iv),
   * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes. Remaining bytes are the
   * encrypted plainText.
   */
  async encrypt(t) {
    const n = this.secret;
    if (n.length !== 64)
      throw Error("secret must be 256 bits");
    const r = crypto.getRandomValues(new Uint8Array(12)), s = await crypto.subtle.importKey("raw", (0, Ut.hexStringToUint8Array)(n), { name: "aes-gcm" }, !1, ["encrypt", "decrypt"]), i = new TextEncoder(), o = await window.crypto.subtle.encrypt({
      name: "AES-GCM",
      iv: r
    }, s, i.encode(t)), a = 16, c = o.slice(o.byteLength - a), l = o.slice(0, o.byteLength - a), d = new Uint8Array(c), h = new Uint8Array(l), u = new Uint8Array([...r, ...d, ...h]);
    return (0, Ut.uint8ArrayToHex)(u);
  }
  /**
   *
   * @param cipherText hex string representation of bytes in the order: initialization vector (iv),
   * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes.
   */
  async decrypt(t) {
    const n = this.secret;
    if (n.length !== 64)
      throw Error("secret must be 256 bits");
    return new Promise((r, s) => {
      (async function() {
        const i = await crypto.subtle.importKey("raw", (0, Ut.hexStringToUint8Array)(n), { name: "aes-gcm" }, !1, ["encrypt", "decrypt"]), o = (0, Ut.hexStringToUint8Array)(t), a = o.slice(0, 12), c = o.slice(12, 28), l = o.slice(28), d = new Uint8Array([...l, ...c]), h = {
          name: "AES-GCM",
          iv: new Uint8Array(a)
        };
        try {
          const u = await window.crypto.subtle.decrypt(h, i, d), f = new TextDecoder();
          r(f.decode(u));
        } catch (u) {
          s(u);
        }
      })();
    });
  }
}
hn.Cipher = fc;
var fn = {};
Object.defineProperty(fn, "__esModule", { value: !0 });
fn.WalletLinkHTTP = void 0;
class gc {
  constructor(t, n, r) {
    this.linkAPIUrl = t, this.sessionId = n;
    const s = `${n}:${r}`;
    this.auth = `Basic ${btoa(s)}`;
  }
  // mark unseen events as seen
  async markUnseenEventsAsSeen(t) {
    return Promise.all(t.map((n) => fetch(`${this.linkAPIUrl}/events/${n.eventId}/seen`, {
      method: "POST",
      headers: {
        Authorization: this.auth
      }
    }))).catch((n) => {
    });
  }
  async fetchUnseenEvents() {
    var t;
    const n = await fetch(`${this.linkAPIUrl}/events?unseen=true`, {
      headers: {
        Authorization: this.auth
      }
    });
    if (n.ok) {
      const { events: r, error: s } = await n.json();
      if (s)
        throw new Error(`Check unseen events failed: ${s}`);
      const i = (t = r == null ? void 0 : r.filter((o) => o.event === "Web3Response").map((o) => ({
        type: "Event",
        sessionId: this.sessionId,
        eventId: o.id,
        event: o.event,
        data: o.data
      }))) !== null && t !== void 0 ? t : [];
      return this.markUnseenEventsAsSeen(i), i;
    }
    throw new Error(`Check unseen events failed: ${n.status}`);
  }
}
fn.WalletLinkHTTP = gc;
var et = {};
Object.defineProperty(et, "__esModule", { value: !0 });
et.WalletLinkWebSocket = et.ConnectionState = void 0;
var Ze;
(function(e) {
  e[e.DISCONNECTED = 0] = "DISCONNECTED", e[e.CONNECTING = 1] = "CONNECTING", e[e.CONNECTED = 2] = "CONNECTED";
})(Ze || (et.ConnectionState = Ze = {}));
class pc {
  setConnectionStateListener(t) {
    this.connectionStateListener = t;
  }
  setIncomingDataListener(t) {
    this.incomingDataListener = t;
  }
  /**
   * Constructor
   * @param url WebSocket server URL
   * @param [WebSocketClass] Custom WebSocket implementation
   */
  constructor(t, n = WebSocket) {
    this.WebSocketClass = n, this.webSocket = null, this.pendingData = [], this.url = t.replace(/^http/, "ws");
  }
  /**
   * Make a websocket connection
   * @returns a Promise that resolves when connected
   */
  async connect() {
    if (this.webSocket)
      throw new Error("webSocket object is not null");
    return new Promise((t, n) => {
      var r;
      let s;
      try {
        this.webSocket = s = new this.WebSocketClass(this.url);
      } catch (i) {
        n(i);
        return;
      }
      (r = this.connectionStateListener) === null || r === void 0 || r.call(this, Ze.CONNECTING), s.onclose = (i) => {
        var o;
        this.clearWebSocket(), n(new Error(`websocket error ${i.code}: ${i.reason}`)), (o = this.connectionStateListener) === null || o === void 0 || o.call(this, Ze.DISCONNECTED);
      }, s.onopen = (i) => {
        var o;
        t(), (o = this.connectionStateListener) === null || o === void 0 || o.call(this, Ze.CONNECTED), this.pendingData.length > 0 && ([...this.pendingData].forEach((c) => this.sendData(c)), this.pendingData = []);
      }, s.onmessage = (i) => {
        var o, a;
        if (i.data === "h")
          (o = this.incomingDataListener) === null || o === void 0 || o.call(this, {
            type: "Heartbeat"
          });
        else
          try {
            const c = JSON.parse(i.data);
            (a = this.incomingDataListener) === null || a === void 0 || a.call(this, c);
          } catch {
          }
      };
    });
  }
  /**
   * Disconnect from server
   */
  disconnect() {
    var t;
    const { webSocket: n } = this;
    if (n) {
      this.clearWebSocket(), (t = this.connectionStateListener) === null || t === void 0 || t.call(this, Ze.DISCONNECTED), this.connectionStateListener = void 0, this.incomingDataListener = void 0;
      try {
        n.close();
      } catch {
      }
    }
  }
  /**
   * Send data to server
   * @param data text to send
   */
  sendData(t) {
    const { webSocket: n } = this;
    if (!n) {
      this.pendingData.push(t), this.connect();
      return;
    }
    n.send(t);
  }
  clearWebSocket() {
    const { webSocket: t } = this;
    t && (this.webSocket = null, t.onclose = null, t.onerror = null, t.onmessage = null, t.onopen = null);
  }
}
et.WalletLinkWebSocket = pc;
Object.defineProperty(un, "__esModule", { value: !0 });
un.WalletLinkConnection = void 0;
const We = $, mc = hn, ue = at, yi = oe, ze = ct, bc = fn, Wt = et, wi = 1e4, yc = 6e4;
class wc {
  /**
   * Constructor
   * @param session Session
   * @param linkAPIUrl Coinbase Wallet link server URL
   * @param listener WalletLinkConnectionUpdateListener
   * @param [WebSocketClass] Custom WebSocket implementation
   */
  constructor({ session: t, linkAPIUrl: n, listener: r, diagnostic: s, WebSocketClass: i = WebSocket }) {
    this.destroyed = !1, this.lastHeartbeatResponse = 0, this.nextReqId = (0, We.IntNumber)(1), this._connected = !1, this._linked = !1, this.shouldFetchUnseenEventsOnConnect = !1, this.requestResolutions = /* @__PURE__ */ new Map(), this.handleSessionMetadataUpdated = (a) => {
      if (!a)
        return;
      (/* @__PURE__ */ new Map([
        ["__destroyed", this.handleDestroyed],
        ["EthereumAddress", this.handleAccountUpdated],
        ["WalletUsername", this.handleWalletUsernameUpdated],
        ["AppVersion", this.handleAppVersionUpdated],
        [
          "ChainId",
          (l) => a.JsonRpcUrl && this.handleChainUpdated(l, a.JsonRpcUrl)
        ]
      ])).forEach((l, d) => {
        const h = a[d];
        h !== void 0 && l(h);
      });
    }, this.handleDestroyed = (a) => {
      var c, l;
      a === "1" && ((c = this.listener) === null || c === void 0 || c.resetAndReload(), (l = this.diagnostic) === null || l === void 0 || l.log(ue.EVENTS.METADATA_DESTROYED, {
        alreadyDestroyed: this.isDestroyed,
        sessionIdHash: ze.Session.hash(this.session.id)
      }));
    }, this.handleAccountUpdated = async (a) => {
      var c, l;
      try {
        const d = await this.cipher.decrypt(a);
        (c = this.listener) === null || c === void 0 || c.accountUpdated(d);
      } catch {
        (l = this.diagnostic) === null || l === void 0 || l.log(ue.EVENTS.GENERAL_ERROR, {
          message: "Had error decrypting",
          value: "selectedAddress"
        });
      }
    }, this.handleMetadataUpdated = async (a, c) => {
      var l, d;
      try {
        const h = await this.cipher.decrypt(c);
        (l = this.listener) === null || l === void 0 || l.metadataUpdated(a, h);
      } catch {
        (d = this.diagnostic) === null || d === void 0 || d.log(ue.EVENTS.GENERAL_ERROR, {
          message: "Had error decrypting",
          value: a
        });
      }
    }, this.handleWalletUsernameUpdated = async (a) => {
      this.handleMetadataUpdated(yi.WALLET_USER_NAME_KEY, a);
    }, this.handleAppVersionUpdated = async (a) => {
      this.handleMetadataUpdated(yi.APP_VERSION_KEY, a);
    }, this.handleChainUpdated = async (a, c) => {
      var l, d;
      try {
        const h = await this.cipher.decrypt(a), u = await this.cipher.decrypt(c);
        (l = this.listener) === null || l === void 0 || l.chainUpdated(h, u);
      } catch {
        (d = this.diagnostic) === null || d === void 0 || d.log(ue.EVENTS.GENERAL_ERROR, {
          message: "Had error decrypting",
          value: "chainId|jsonRpcUrl"
        });
      }
    }, this.session = t, this.cipher = new mc.Cipher(t.secret), this.diagnostic = s, this.listener = r;
    const o = new Wt.WalletLinkWebSocket(`${n}/rpc`, i);
    o.setConnectionStateListener(async (a) => {
      var c;
      (c = this.diagnostic) === null || c === void 0 || c.log(ue.EVENTS.CONNECTED_STATE_CHANGE, {
        state: a,
        sessionIdHash: ze.Session.hash(t.id)
      });
      let l = !1;
      switch (a) {
        case Wt.ConnectionState.DISCONNECTED:
          if (!this.destroyed) {
            const d = async () => {
              await new Promise((h) => setTimeout(h, 5e3)), this.destroyed || o.connect().catch(() => {
                d();
              });
            };
            d();
          }
          break;
        case Wt.ConnectionState.CONNECTED:
          try {
            await this.authenticate(), this.sendIsLinked(), this.sendGetSessionConfig(), l = !0;
          } catch {
          }
          this.updateLastHeartbeat(), setInterval(() => {
            this.heartbeat();
          }, wi), this.shouldFetchUnseenEventsOnConnect && this.fetchUnseenEventsAPI();
          break;
        case Wt.ConnectionState.CONNECTING:
          break;
      }
      this.connected !== l && (this.connected = l);
    }), o.setIncomingDataListener((a) => {
      var c, l, d;
      switch (a.type) {
        case "Heartbeat":
          this.updateLastHeartbeat();
          return;
        case "IsLinkedOK":
        case "Linked": {
          const h = a.type === "IsLinkedOK" ? a.linked : void 0;
          (c = this.diagnostic) === null || c === void 0 || c.log(ue.EVENTS.LINKED, {
            sessionIdHash: ze.Session.hash(t.id),
            linked: h,
            type: a.type,
            onlineGuests: a.onlineGuests
          }), this.linked = h || a.onlineGuests > 0;
          break;
        }
        case "GetSessionConfigOK":
        case "SessionConfigUpdated": {
          (l = this.diagnostic) === null || l === void 0 || l.log(ue.EVENTS.SESSION_CONFIG_RECEIVED, {
            sessionIdHash: ze.Session.hash(t.id),
            metadata_keys: a && a.metadata ? Object.keys(a.metadata) : void 0
          }), this.handleSessionMetadataUpdated(a.metadata);
          break;
        }
        case "Event": {
          this.handleIncomingEvent(a);
          break;
        }
      }
      a.id !== void 0 && ((d = this.requestResolutions.get(a.id)) === null || d === void 0 || d(a));
    }), this.ws = o, this.http = new bc.WalletLinkHTTP(n, t.id, t.key);
  }
  /**
   * Make a connection to the server
   */
  connect() {
    var t;
    if (this.destroyed)
      throw new Error("instance is destroyed");
    (t = this.diagnostic) === null || t === void 0 || t.log(ue.EVENTS.STARTED_CONNECTING, {
      sessionIdHash: ze.Session.hash(this.session.id)
    }), this.ws.connect();
  }
  /**
   * Terminate connection, and mark as destroyed. To reconnect, create a new
   * instance of WalletSDKConnection
   */
  destroy() {
    var t;
    this.destroyed = !0, this.ws.disconnect(), (t = this.diagnostic) === null || t === void 0 || t.log(ue.EVENTS.DISCONNECTED, {
      sessionIdHash: ze.Session.hash(this.session.id)
    }), this.listener = void 0;
  }
  get isDestroyed() {
    return this.destroyed;
  }
  get connected() {
    return this._connected;
  }
  set connected(t) {
    var n, r;
    this._connected = t, t && ((n = this.onceConnected) === null || n === void 0 || n.call(this)), (r = this.listener) === null || r === void 0 || r.connectedUpdated(t);
  }
  setOnceConnected(t) {
    return new Promise((n) => {
      this.connected ? t().then(n) : this.onceConnected = () => {
        t().then(n), this.onceConnected = void 0;
      };
    });
  }
  get linked() {
    return this._linked;
  }
  set linked(t) {
    var n, r;
    this._linked = t, t && ((n = this.onceLinked) === null || n === void 0 || n.call(this)), (r = this.listener) === null || r === void 0 || r.linkedUpdated(t);
  }
  setOnceLinked(t) {
    return new Promise((n) => {
      this.linked ? t().then(n) : this.onceLinked = () => {
        t().then(n), this.onceLinked = void 0;
      };
    });
  }
  async handleIncomingEvent(t) {
    var n, r;
    if (!(t.type !== "Event" || t.event !== "Web3Response"))
      try {
        const s = await this.cipher.decrypt(t.data), i = JSON.parse(s);
        if (i.type !== "WEB3_RESPONSE")
          return;
        (n = this.listener) === null || n === void 0 || n.handleWeb3ResponseMessage(i);
      } catch {
        (r = this.diagnostic) === null || r === void 0 || r.log(ue.EVENTS.GENERAL_ERROR, {
          message: "Had error decrypting",
          value: "incomingEvent"
        });
      }
  }
  async checkUnseenEvents() {
    if (!this.connected) {
      this.shouldFetchUnseenEventsOnConnect = !0;
      return;
    }
    await new Promise((t) => setTimeout(t, 250));
    try {
      await this.fetchUnseenEventsAPI();
    } catch {
    }
  }
  async fetchUnseenEventsAPI() {
    this.shouldFetchUnseenEventsOnConnect = !1, (await this.http.fetchUnseenEvents()).forEach((n) => this.handleIncomingEvent(n));
  }
  /**
   * Set session metadata in SessionConfig object
   * @param key
   * @param value
   * @returns a Promise that completes when successful
   */
  async setSessionMetadata(t, n) {
    const r = {
      type: "SetSessionConfig",
      id: (0, We.IntNumber)(this.nextReqId++),
      sessionId: this.session.id,
      metadata: { [t]: n }
    };
    return this.setOnceConnected(async () => {
      const s = await this.makeRequest(r);
      if (s.type === "Fail")
        throw new Error(s.error || "failed to set session metadata");
    });
  }
  /**
   * Publish an event and emit event ID when successful
   * @param event event name
   * @param unencryptedData unencrypted event data
   * @param callWebhook whether the webhook should be invoked
   * @returns a Promise that emits event ID when successful
   */
  async publishEvent(t, n, r = !1) {
    const s = await this.cipher.encrypt(JSON.stringify(Object.assign(Object.assign({}, n), { origin: location.origin, relaySource: window.coinbaseWalletExtension ? "injected_sdk" : "sdk" }))), i = {
      type: "PublishEvent",
      id: (0, We.IntNumber)(this.nextReqId++),
      sessionId: this.session.id,
      event: t,
      data: s,
      callWebhook: r
    };
    return this.setOnceLinked(async () => {
      const o = await this.makeRequest(i);
      if (o.type === "Fail")
        throw new Error(o.error || "failed to publish event");
      return o.eventId;
    });
  }
  sendData(t) {
    this.ws.sendData(JSON.stringify(t));
  }
  updateLastHeartbeat() {
    this.lastHeartbeatResponse = Date.now();
  }
  heartbeat() {
    if (Date.now() - this.lastHeartbeatResponse > wi * 2) {
      this.ws.disconnect();
      return;
    }
    try {
      this.ws.sendData("h");
    } catch {
    }
  }
  async makeRequest(t, n = yc) {
    const r = t.id;
    this.sendData(t);
    let s;
    return Promise.race([
      new Promise((i, o) => {
        s = window.setTimeout(() => {
          o(new Error(`request ${r} timed out`));
        }, n);
      }),
      new Promise((i) => {
        this.requestResolutions.set(r, (o) => {
          clearTimeout(s), i(o), this.requestResolutions.delete(r);
        });
      })
    ]);
  }
  async authenticate() {
    const t = {
      type: "HostSession",
      id: (0, We.IntNumber)(this.nextReqId++),
      sessionId: this.session.id,
      sessionKey: this.session.key
    }, n = await this.makeRequest(t);
    if (n.type === "Fail")
      throw new Error(n.error || "failed to authentcate");
  }
  sendIsLinked() {
    const t = {
      type: "IsLinked",
      id: (0, We.IntNumber)(this.nextReqId++),
      sessionId: this.session.id
    };
    this.sendData(t);
  }
  sendGetSessionConfig() {
    const t = {
      type: "GetSessionConfig",
      id: (0, We.IntNumber)(this.nextReqId++),
      sessionId: this.session.id
    };
    this.sendData(t);
  }
}
un.WalletLinkConnection = wc;
var It = {}, Mt = {}, as = {};
Object.defineProperty(as, "__esModule", { value: !0 });
as.default = '@namespace svg "http://www.w3.org/2000/svg";.-cbwsdk-css-reset,.-cbwsdk-css-reset *{animation:none;animation-delay:0;animation-direction:normal;animation-duration:0;animation-fill-mode:none;animation-iteration-count:1;animation-name:none;animation-play-state:running;animation-timing-function:ease;backface-visibility:visible;background:0;background-attachment:scroll;background-clip:border-box;background-color:rgba(0,0,0,0);background-image:none;background-origin:padding-box;background-position:0 0;background-position-x:0;background-position-y:0;background-repeat:repeat;background-size:auto auto;border:0;border-style:none;border-width:medium;border-color:inherit;border-bottom:0;border-bottom-color:inherit;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-style:none;border-bottom-width:medium;border-collapse:separate;border-image:none;border-left:0;border-left-color:inherit;border-left-style:none;border-left-width:medium;border-radius:0;border-right:0;border-right-color:inherit;border-right-style:none;border-right-width:medium;border-spacing:0;border-top:0;border-top-color:inherit;border-top-left-radius:0;border-top-right-radius:0;border-top-style:none;border-top-width:medium;box-shadow:none;box-sizing:border-box;caption-side:top;clear:none;clip:auto;color:inherit;columns:auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium none currentColor;column-rule-color:currentColor;column-rule-style:none;column-rule-width:none;column-span:1;column-width:auto;counter-increment:none;counter-reset:none;direction:ltr;empty-cells:show;float:none;font:normal;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;height:auto;hyphens:none;letter-spacing:normal;line-height:normal;list-style:none;list-style-image:none;list-style-position:outside;list-style-type:disc;margin:0;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;opacity:1;orphans:0;outline:0;outline-color:invert;outline-style:none;outline-width:medium;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;perspective:none;perspective-origin:50% 50%;pointer-events:auto;position:static;quotes:"\\201C" "\\201D" "\\2018" "\\2019";tab-size:8;table-layout:auto;text-align:inherit;text-align-last:auto;text-decoration:none;text-decoration-color:inherit;text-decoration-line:none;text-decoration-style:solid;text-indent:0;text-shadow:none;text-transform:none;transform:none;transform-style:flat;transition:none;transition-delay:0s;transition-duration:0s;transition-property:none;transition-timing-function:ease;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:0;word-spacing:normal;z-index:auto}.-cbwsdk-css-reset strong{font-weight:bold}.-cbwsdk-css-reset *{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;line-height:1}.-cbwsdk-css-reset [class*=container]{margin:0;padding:0}.-cbwsdk-css-reset style{display:none}';
var _c = v && v.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Mt, "__esModule", { value: !0 });
Mt.injectCssReset = void 0;
const vc = _c(as);
function Ec() {
  const e = document.createElement("style");
  e.type = "text/css", e.appendChild(document.createTextNode(vc.default)), document.documentElement.appendChild(e);
}
Mt.injectCssReset = Ec;
var gn = {}, pn = {};
function wo(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (n = wo(e[t])) && (r && (r += " "), r += n);
  else for (t in e) e[t] && (r && (r += " "), r += t);
  return r;
}
function _i() {
  for (var e, t, n = 0, r = ""; n < arguments.length; ) (e = arguments[n++]) && (t = wo(e)) && (r && (r += " "), r += t);
  return r;
}
const kc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clsx: _i,
  default: _i
}, Symbol.toStringTag, { value: "Module" })), At = /* @__PURE__ */ ss(kc);
var tt = {}, mn = {};
Object.defineProperty(mn, "__esModule", { value: !0 });
mn.CloseIcon = void 0;
const vi = K;
function Cc(e) {
  return (0, vi.h)(
    "svg",
    Object.assign({ width: "40", height: "40", viewBox: "0 0 40 40", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, e),
    (0, vi.h)("path", { d: "M13.7677 13L12.3535 14.4142L18.3535 20.4142L12.3535 26.4142L13.7677 27.8284L19.7677 21.8284L25.7677 27.8284L27.1819 26.4142L21.1819 20.4142L27.1819 14.4142L25.7677 13L19.7677 19L13.7677 13Z" })
  );
}
mn.CloseIcon = Cc;
var bn = {};
Object.defineProperty(bn, "__esModule", { value: !0 });
bn.CoinbaseWalletRound = void 0;
const zt = K;
function Sc(e) {
  return (0, zt.h)(
    "svg",
    Object.assign({ width: "28", height: "28", viewBox: "0 0 28 28", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, e),
    (0, zt.h)("circle", { cx: "14", cy: "14", r: "14", fill: "#0052FF" }),
    (0, zt.h)("path", { d: "M23.8521 14.0003C23.8521 19.455 19.455 23.8521 14.0003 23.8521C8.54559 23.8521 4.14844 19.455 4.14844 14.0003C4.14844 8.54559 8.54559 4.14844 14.0003 4.14844C19.455 4.14844 23.8521 8.54559 23.8521 14.0003Z", fill: "white" }),
    (0, zt.h)("path", { d: "M11.1855 12.5042C11.1855 12.0477 11.1855 11.7942 11.2835 11.642C11.3814 11.4899 11.4793 11.3377 11.6261 11.287C11.8219 11.1855 12.0178 11.1855 12.5073 11.1855H15.4934C15.983 11.1855 16.1788 11.1855 16.3746 11.287C16.5215 11.3884 16.6683 11.4899 16.7173 11.642C16.8152 11.8449 16.8152 12.0477 16.8152 12.5042V15.4965C16.8152 15.953 16.8152 16.2066 16.7173 16.3587C16.6194 16.5109 16.5215 16.663 16.3746 16.7137C16.1788 16.8152 15.983 16.8152 15.4934 16.8152H12.5073C12.0178 16.8152 11.8219 16.8152 11.6261 16.7137C11.4793 16.6123 11.3324 16.5109 11.2835 16.3587C11.1855 16.1558 11.1855 15.953 11.1855 15.4965V12.5042Z", fill: "#0052FF" })
  );
}
bn.CoinbaseWalletRound = Sc;
var yn = {};
Object.defineProperty(yn, "__esModule", { value: !0 });
yn.QRCodeIcon = void 0;
const gt = K;
function Rc(e) {
  return (0, gt.h)(
    "svg",
    Object.assign({ width: "18", height: "18", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg" }, e),
    (0, gt.h)("path", { d: "M3 3V8.99939L5 8.99996V5H9V3H3Z" }),
    (0, gt.h)("path", { d: "M15 21L21 21V15.0006L19 15V19L15 19V21Z" }),
    (0, gt.h)("path", { d: "M21 9H19V5H15.0006L15 3H21V9Z" }),
    (0, gt.h)("path", { d: "M3 15V21H8.99939L8.99996 19H5L5 15H3Z" })
  );
}
yn.QRCodeIcon = Rc;
var wn = {};
function _o(e) {
  this.mode = te.MODE_8BIT_BYTE, this.data = e, this.parsedData = [];
  for (var t = 0, n = this.data.length; t < n; t++) {
    var r = [], s = this.data.charCodeAt(t);
    s > 65536 ? (r[0] = 240 | (s & 1835008) >>> 18, r[1] = 128 | (s & 258048) >>> 12, r[2] = 128 | (s & 4032) >>> 6, r[3] = 128 | s & 63) : s > 2048 ? (r[0] = 224 | (s & 61440) >>> 12, r[1] = 128 | (s & 4032) >>> 6, r[2] = 128 | s & 63) : s > 128 ? (r[0] = 192 | (s & 1984) >>> 6, r[1] = 128 | s & 63) : r[0] = s, this.parsedData.push(r);
  }
  this.parsedData = Array.prototype.concat.apply([], this.parsedData), this.parsedData.length != this.data.length && (this.parsedData.unshift(191), this.parsedData.unshift(187), this.parsedData.unshift(239));
}
_o.prototype = {
  getLength: function(e) {
    return this.parsedData.length;
  },
  write: function(e) {
    for (var t = 0, n = this.parsedData.length; t < n; t++)
      e.put(this.parsedData[t], 8);
  }
};
function me(e, t) {
  this.typeNumber = e, this.errorCorrectLevel = t, this.modules = null, this.moduleCount = 0, this.dataCache = null, this.dataList = [];
}
me.prototype = { addData: function(e) {
  var t = new _o(e);
  this.dataList.push(t), this.dataCache = null;
}, isDark: function(e, t) {
  if (e < 0 || this.moduleCount <= e || t < 0 || this.moduleCount <= t)
    throw new Error(e + "," + t);
  return this.modules[e][t];
}, getModuleCount: function() {
  return this.moduleCount;
}, make: function() {
  this.makeImpl(!1, this.getBestMaskPattern());
}, makeImpl: function(e, t) {
  this.moduleCount = this.typeNumber * 4 + 17, this.modules = new Array(this.moduleCount);
  for (var n = 0; n < this.moduleCount; n++) {
    this.modules[n] = new Array(this.moduleCount);
    for (var r = 0; r < this.moduleCount; r++)
      this.modules[n][r] = null;
  }
  this.setupPositionProbePattern(0, 0), this.setupPositionProbePattern(this.moduleCount - 7, 0), this.setupPositionProbePattern(0, this.moduleCount - 7), this.setupPositionAdjustPattern(), this.setupTimingPattern(), this.setupTypeInfo(e, t), this.typeNumber >= 7 && this.setupTypeNumber(e), this.dataCache == null && (this.dataCache = me.createData(this.typeNumber, this.errorCorrectLevel, this.dataList)), this.mapData(this.dataCache, t);
}, setupPositionProbePattern: function(e, t) {
  for (var n = -1; n <= 7; n++)
    if (!(e + n <= -1 || this.moduleCount <= e + n))
      for (var r = -1; r <= 7; r++)
        t + r <= -1 || this.moduleCount <= t + r || (0 <= n && n <= 6 && (r == 0 || r == 6) || 0 <= r && r <= 6 && (n == 0 || n == 6) || 2 <= n && n <= 4 && 2 <= r && r <= 4 ? this.modules[e + n][t + r] = !0 : this.modules[e + n][t + r] = !1);
}, getBestMaskPattern: function() {
  for (var e = 0, t = 0, n = 0; n < 8; n++) {
    this.makeImpl(!0, n);
    var r = x.getLostPoint(this);
    (n == 0 || e > r) && (e = r, t = n);
  }
  return t;
}, createMovieClip: function(e, t, n) {
  var r = e.createEmptyMovieClip(t, n), s = 1;
  this.make();
  for (var i = 0; i < this.modules.length; i++)
    for (var o = i * s, a = 0; a < this.modules[i].length; a++) {
      var c = a * s, l = this.modules[i][a];
      l && (r.beginFill(0, 100), r.moveTo(c, o), r.lineTo(c + s, o), r.lineTo(c + s, o + s), r.lineTo(c, o + s), r.endFill());
    }
  return r;
}, setupTimingPattern: function() {
  for (var e = 8; e < this.moduleCount - 8; e++)
    this.modules[e][6] == null && (this.modules[e][6] = e % 2 == 0);
  for (var t = 8; t < this.moduleCount - 8; t++)
    this.modules[6][t] == null && (this.modules[6][t] = t % 2 == 0);
}, setupPositionAdjustPattern: function() {
  for (var e = x.getPatternPosition(this.typeNumber), t = 0; t < e.length; t++)
    for (var n = 0; n < e.length; n++) {
      var r = e[t], s = e[n];
      if (this.modules[r][s] == null)
        for (var i = -2; i <= 2; i++)
          for (var o = -2; o <= 2; o++)
            i == -2 || i == 2 || o == -2 || o == 2 || i == 0 && o == 0 ? this.modules[r + i][s + o] = !0 : this.modules[r + i][s + o] = !1;
    }
}, setupTypeNumber: function(e) {
  for (var t = x.getBCHTypeNumber(this.typeNumber), n = 0; n < 18; n++) {
    var r = !e && (t >> n & 1) == 1;
    this.modules[Math.floor(n / 3)][n % 3 + this.moduleCount - 8 - 3] = r;
  }
  for (var n = 0; n < 18; n++) {
    var r = !e && (t >> n & 1) == 1;
    this.modules[n % 3 + this.moduleCount - 8 - 3][Math.floor(n / 3)] = r;
  }
}, setupTypeInfo: function(e, t) {
  for (var n = this.errorCorrectLevel << 3 | t, r = x.getBCHTypeInfo(n), s = 0; s < 15; s++) {
    var i = !e && (r >> s & 1) == 1;
    s < 6 ? this.modules[s][8] = i : s < 8 ? this.modules[s + 1][8] = i : this.modules[this.moduleCount - 15 + s][8] = i;
  }
  for (var s = 0; s < 15; s++) {
    var i = !e && (r >> s & 1) == 1;
    s < 8 ? this.modules[8][this.moduleCount - s - 1] = i : s < 9 ? this.modules[8][15 - s - 1 + 1] = i : this.modules[8][15 - s - 1] = i;
  }
  this.modules[this.moduleCount - 8][8] = !e;
}, mapData: function(e, t) {
  for (var n = -1, r = this.moduleCount - 1, s = 7, i = 0, o = this.moduleCount - 1; o > 0; o -= 2)
    for (o == 6 && o--; ; ) {
      for (var a = 0; a < 2; a++)
        if (this.modules[r][o - a] == null) {
          var c = !1;
          i < e.length && (c = (e[i] >>> s & 1) == 1);
          var l = x.getMask(t, r, o - a);
          l && (c = !c), this.modules[r][o - a] = c, s--, s == -1 && (i++, s = 7);
        }
      if (r += n, r < 0 || this.moduleCount <= r) {
        r -= n, n = -n;
        break;
      }
    }
} };
me.PAD0 = 236;
me.PAD1 = 17;
me.createData = function(e, t, n) {
  for (var r = pe.getRSBlocks(e, t), s = new vo(), i = 0; i < n.length; i++) {
    var o = n[i];
    s.put(o.mode, 4), s.put(o.getLength(), x.getLengthInBits(o.mode, e)), o.write(s);
  }
  for (var a = 0, i = 0; i < r.length; i++)
    a += r[i].dataCount;
  if (s.getLengthInBits() > a * 8)
    throw new Error("code length overflow. (" + s.getLengthInBits() + ">" + a * 8 + ")");
  for (s.getLengthInBits() + 4 <= a * 8 && s.put(0, 4); s.getLengthInBits() % 8 != 0; )
    s.putBit(!1);
  for (; !(s.getLengthInBits() >= a * 8 || (s.put(me.PAD0, 8), s.getLengthInBits() >= a * 8)); )
    s.put(me.PAD1, 8);
  return me.createBytes(s, r);
};
me.createBytes = function(e, t) {
  for (var n = 0, r = 0, s = 0, i = new Array(t.length), o = new Array(t.length), a = 0; a < t.length; a++) {
    var c = t[a].dataCount, l = t[a].totalCount - c;
    r = Math.max(r, c), s = Math.max(s, l), i[a] = new Array(c);
    for (var d = 0; d < i[a].length; d++)
      i[a][d] = 255 & e.buffer[d + n];
    n += c;
    var h = x.getErrorCorrectPolynomial(l), u = new Ge(i[a], h.getLength() - 1), f = u.mod(h);
    o[a] = new Array(h.getLength() - 1);
    for (var d = 0; d < o[a].length; d++) {
      var b = d + f.getLength() - o[a].length;
      o[a][d] = b >= 0 ? f.get(b) : 0;
    }
  }
  for (var w = 0, d = 0; d < t.length; d++)
    w += t[d].totalCount;
  for (var _ = new Array(w), k = 0, d = 0; d < r; d++)
    for (var a = 0; a < t.length; a++)
      d < i[a].length && (_[k++] = i[a][d]);
  for (var d = 0; d < s; d++)
    for (var a = 0; a < t.length; a++)
      d < o[a].length && (_[k++] = o[a][d]);
  return _;
};
var te = { MODE_NUMBER: 1, MODE_ALPHA_NUM: 2, MODE_8BIT_BYTE: 4, MODE_KANJI: 8 }, Se = { L: 1, M: 0, Q: 3, H: 2 }, Ee = { PATTERN000: 0, PATTERN001: 1, PATTERN010: 2, PATTERN011: 3, PATTERN100: 4, PATTERN101: 5, PATTERN110: 6, PATTERN111: 7 }, x = { PATTERN_POSITION_TABLE: [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]], G15: 1335, G18: 7973, G15_MASK: 21522, getBCHTypeInfo: function(e) {
  for (var t = e << 10; x.getBCHDigit(t) - x.getBCHDigit(x.G15) >= 0; )
    t ^= x.G15 << x.getBCHDigit(t) - x.getBCHDigit(x.G15);
  return (e << 10 | t) ^ x.G15_MASK;
}, getBCHTypeNumber: function(e) {
  for (var t = e << 12; x.getBCHDigit(t) - x.getBCHDigit(x.G18) >= 0; )
    t ^= x.G18 << x.getBCHDigit(t) - x.getBCHDigit(x.G18);
  return e << 12 | t;
}, getBCHDigit: function(e) {
  for (var t = 0; e != 0; )
    t++, e >>>= 1;
  return t;
}, getPatternPosition: function(e) {
  return x.PATTERN_POSITION_TABLE[e - 1];
}, getMask: function(e, t, n) {
  switch (e) {
    case Ee.PATTERN000:
      return (t + n) % 2 == 0;
    case Ee.PATTERN001:
      return t % 2 == 0;
    case Ee.PATTERN010:
      return n % 3 == 0;
    case Ee.PATTERN011:
      return (t + n) % 3 == 0;
    case Ee.PATTERN100:
      return (Math.floor(t / 2) + Math.floor(n / 3)) % 2 == 0;
    case Ee.PATTERN101:
      return t * n % 2 + t * n % 3 == 0;
    case Ee.PATTERN110:
      return (t * n % 2 + t * n % 3) % 2 == 0;
    case Ee.PATTERN111:
      return (t * n % 3 + (t + n) % 2) % 2 == 0;
    default:
      throw new Error("bad maskPattern:" + e);
  }
}, getErrorCorrectPolynomial: function(e) {
  for (var t = new Ge([1], 0), n = 0; n < e; n++)
    t = t.multiply(new Ge([1, U.gexp(n)], 0));
  return t;
}, getLengthInBits: function(e, t) {
  if (1 <= t && t < 10)
    switch (e) {
      case te.MODE_NUMBER:
        return 10;
      case te.MODE_ALPHA_NUM:
        return 9;
      case te.MODE_8BIT_BYTE:
        return 8;
      case te.MODE_KANJI:
        return 8;
      default:
        throw new Error("mode:" + e);
    }
  else if (t < 27)
    switch (e) {
      case te.MODE_NUMBER:
        return 12;
      case te.MODE_ALPHA_NUM:
        return 11;
      case te.MODE_8BIT_BYTE:
        return 16;
      case te.MODE_KANJI:
        return 10;
      default:
        throw new Error("mode:" + e);
    }
  else if (t < 41)
    switch (e) {
      case te.MODE_NUMBER:
        return 14;
      case te.MODE_ALPHA_NUM:
        return 13;
      case te.MODE_8BIT_BYTE:
        return 16;
      case te.MODE_KANJI:
        return 12;
      default:
        throw new Error("mode:" + e);
    }
  else
    throw new Error("type:" + t);
}, getLostPoint: function(e) {
  for (var t = e.getModuleCount(), n = 0, r = 0; r < t; r++)
    for (var s = 0; s < t; s++) {
      for (var i = 0, o = e.isDark(r, s), a = -1; a <= 1; a++)
        if (!(r + a < 0 || t <= r + a))
          for (var c = -1; c <= 1; c++)
            s + c < 0 || t <= s + c || a == 0 && c == 0 || o == e.isDark(r + a, s + c) && i++;
      i > 5 && (n += 3 + i - 5);
    }
  for (var r = 0; r < t - 1; r++)
    for (var s = 0; s < t - 1; s++) {
      var l = 0;
      e.isDark(r, s) && l++, e.isDark(r + 1, s) && l++, e.isDark(r, s + 1) && l++, e.isDark(r + 1, s + 1) && l++, (l == 0 || l == 4) && (n += 3);
    }
  for (var r = 0; r < t; r++)
    for (var s = 0; s < t - 6; s++)
      e.isDark(r, s) && !e.isDark(r, s + 1) && e.isDark(r, s + 2) && e.isDark(r, s + 3) && e.isDark(r, s + 4) && !e.isDark(r, s + 5) && e.isDark(r, s + 6) && (n += 40);
  for (var s = 0; s < t; s++)
    for (var r = 0; r < t - 6; r++)
      e.isDark(r, s) && !e.isDark(r + 1, s) && e.isDark(r + 2, s) && e.isDark(r + 3, s) && e.isDark(r + 4, s) && !e.isDark(r + 5, s) && e.isDark(r + 6, s) && (n += 40);
  for (var d = 0, s = 0; s < t; s++)
    for (var r = 0; r < t; r++)
      e.isDark(r, s) && d++;
  var h = Math.abs(100 * d / t / t - 50) / 5;
  return n += h * 10, n;
} }, U = { glog: function(e) {
  if (e < 1)
    throw new Error("glog(" + e + ")");
  return U.LOG_TABLE[e];
}, gexp: function(e) {
  for (; e < 0; )
    e += 255;
  for (; e >= 256; )
    e -= 255;
  return U.EXP_TABLE[e];
}, EXP_TABLE: new Array(256), LOG_TABLE: new Array(256) };
for (var V = 0; V < 8; V++)
  U.EXP_TABLE[V] = 1 << V;
for (var V = 8; V < 256; V++)
  U.EXP_TABLE[V] = U.EXP_TABLE[V - 4] ^ U.EXP_TABLE[V - 5] ^ U.EXP_TABLE[V - 6] ^ U.EXP_TABLE[V - 8];
for (var V = 0; V < 255; V++)
  U.LOG_TABLE[U.EXP_TABLE[V]] = V;
function Ge(e, t) {
  if (e.length == null)
    throw new Error(e.length + "/" + t);
  for (var n = 0; n < e.length && e[n] == 0; )
    n++;
  this.num = new Array(e.length - n + t);
  for (var r = 0; r < e.length - n; r++)
    this.num[r] = e[r + n];
}
Ge.prototype = { get: function(e) {
  return this.num[e];
}, getLength: function() {
  return this.num.length;
}, multiply: function(e) {
  for (var t = new Array(this.getLength() + e.getLength() - 1), n = 0; n < this.getLength(); n++)
    for (var r = 0; r < e.getLength(); r++)
      t[n + r] ^= U.gexp(U.glog(this.get(n)) + U.glog(e.get(r)));
  return new Ge(t, 0);
}, mod: function(e) {
  if (this.getLength() - e.getLength() < 0)
    return this;
  for (var t = U.glog(this.get(0)) - U.glog(e.get(0)), n = new Array(this.getLength()), r = 0; r < this.getLength(); r++)
    n[r] = this.get(r);
  for (var r = 0; r < e.getLength(); r++)
    n[r] ^= U.gexp(U.glog(e.get(r)) + t);
  return new Ge(n, 0).mod(e);
} };
function pe(e, t) {
  this.totalCount = e, this.dataCount = t;
}
pe.RS_BLOCK_TABLE = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]];
pe.getRSBlocks = function(e, t) {
  var n = pe.getRsBlockTable(e, t);
  if (n == null)
    throw new Error("bad rs block @ typeNumber:" + e + "/errorCorrectLevel:" + t);
  for (var r = n.length / 3, s = [], i = 0; i < r; i++)
    for (var o = n[i * 3 + 0], a = n[i * 3 + 1], c = n[i * 3 + 2], l = 0; l < o; l++)
      s.push(new pe(a, c));
  return s;
};
pe.getRsBlockTable = function(e, t) {
  switch (t) {
    case Se.L:
      return pe.RS_BLOCK_TABLE[(e - 1) * 4 + 0];
    case Se.M:
      return pe.RS_BLOCK_TABLE[(e - 1) * 4 + 1];
    case Se.Q:
      return pe.RS_BLOCK_TABLE[(e - 1) * 4 + 2];
    case Se.H:
      return pe.RS_BLOCK_TABLE[(e - 1) * 4 + 3];
    default:
      return;
  }
};
function vo() {
  this.buffer = [], this.length = 0;
}
vo.prototype = { get: function(e) {
  var t = Math.floor(e / 8);
  return (this.buffer[t] >>> 7 - e % 8 & 1) == 1;
}, put: function(e, t) {
  for (var n = 0; n < t; n++)
    this.putBit((e >>> t - n - 1 & 1) == 1);
}, getLengthInBits: function() {
  return this.length;
}, putBit: function(e) {
  var t = Math.floor(this.length / 8);
  this.buffer.length <= t && this.buffer.push(0), e && (this.buffer[t] |= 128 >>> this.length % 8), this.length++;
} };
var Dr = [[17, 14, 11, 7], [32, 26, 20, 14], [53, 42, 32, 24], [78, 62, 46, 34], [106, 84, 60, 44], [134, 106, 74, 58], [154, 122, 86, 64], [192, 152, 108, 84], [230, 180, 130, 98], [271, 213, 151, 119], [321, 251, 177, 137], [367, 287, 203, 155], [425, 331, 241, 177], [458, 362, 258, 194], [520, 412, 292, 220], [586, 450, 322, 250], [644, 504, 364, 280], [718, 560, 394, 310], [792, 624, 442, 338], [858, 666, 482, 382], [929, 711, 509, 403], [1003, 779, 565, 439], [1091, 857, 611, 461], [1171, 911, 661, 511], [1273, 997, 715, 535], [1367, 1059, 751, 593], [1465, 1125, 805, 625], [1528, 1190, 868, 658], [1628, 1264, 908, 698], [1732, 1370, 982, 742], [1840, 1452, 1030, 790], [1952, 1538, 1112, 842], [2068, 1628, 1168, 898], [2188, 1722, 1228, 958], [2303, 1809, 1283, 983], [2431, 1911, 1351, 1051], [2563, 1989, 1423, 1093], [2699, 2099, 1499, 1139], [2809, 2213, 1579, 1219], [2953, 2331, 1663, 1273]];
function Eo(e) {
  if (this.options = {
    padding: 4,
    width: 256,
    height: 256,
    typeNumber: 4,
    color: "#000000",
    background: "#ffffff",
    ecl: "M",
    image: {
      svg: "",
      width: 0,
      height: 0
    }
  }, typeof e == "string" && (e = {
    content: e
  }), e)
    for (var t in e)
      this.options[t] = e[t];
  if (typeof this.options.content != "string")
    throw new Error("Expected 'content' as string!");
  if (this.options.content.length === 0)
    throw new Error("Expected 'content' to be non-empty!");
  if (!(this.options.padding >= 0))
    throw new Error("Expected 'padding' value to be non-negative!");
  if (!(this.options.width > 0) || !(this.options.height > 0))
    throw new Error("Expected 'width' or 'height' value to be higher than zero!");
  function n(c) {
    switch (c) {
      case "L":
        return Se.L;
      case "M":
        return Se.M;
      case "Q":
        return Se.Q;
      case "H":
        return Se.H;
      default:
        throw new Error("Unknwon error correction level: " + c);
    }
  }
  function r(c, l) {
    for (var d = s(c), h = 1, u = 0, f = 0, b = Dr.length; f <= b; f++) {
      var w = Dr[f];
      if (!w)
        throw new Error("Content too long: expected " + u + " but got " + d);
      switch (l) {
        case "L":
          u = w[0];
          break;
        case "M":
          u = w[1];
          break;
        case "Q":
          u = w[2];
          break;
        case "H":
          u = w[3];
          break;
        default:
          throw new Error("Unknwon error correction level: " + l);
      }
      if (d <= u)
        break;
      h++;
    }
    if (h > Dr.length)
      throw new Error("Content too long");
    return h;
  }
  function s(c) {
    var l = encodeURI(c).toString().replace(/\%[0-9a-fA-F]{2}/g, "a");
    return l.length + (l.length != c ? 3 : 0);
  }
  var i = this.options.content, o = r(i, this.options.ecl), a = n(this.options.ecl);
  this.qrcode = new me(o, a), this.qrcode.addData(i), this.qrcode.make();
}
Eo.prototype.svg = function(e) {
  var t = this.options || {}, n = this.qrcode.modules;
  typeof e > "u" && (e = { container: t.container || "svg" });
  for (var r = typeof t.pretty < "u" ? !!t.pretty : !0, s = r ? "  " : "", i = r ? `\r
` : "", o = t.width, a = t.height, c = n.length, l = o / (c + 2 * t.padding), d = a / (c + 2 * t.padding), h = typeof t.join < "u" ? !!t.join : !1, u = typeof t.swap < "u" ? !!t.swap : !1, f = typeof t.xmlDeclaration < "u" ? !!t.xmlDeclaration : !0, b = typeof t.predefined < "u" ? !!t.predefined : !1, w = b ? s + '<defs><path id="qrmodule" d="M0 0 h' + d + " v" + l + ' H0 z" style="fill:' + t.color + ';shape-rendering:crispEdges;" /></defs>' + i : "", _ = s + '<rect x="0" y="0" width="' + o + '" height="' + a + '" style="fill:' + t.background + ';shape-rendering:crispEdges;"/>' + i, k = "", y = "", g = 0; g < c; g++)
    for (var M = 0; M < c; M++) {
      var p = n[M][g];
      if (p) {
        var C = M * l + t.padding * l, T = g * d + t.padding * d;
        if (u) {
          var W = C;
          C = T, T = W;
        }
        if (h) {
          var Q = l + C, j = d + T;
          C = Number.isInteger(C) ? Number(C) : C.toFixed(2), T = Number.isInteger(T) ? Number(T) : T.toFixed(2), Q = Number.isInteger(Q) ? Number(Q) : Q.toFixed(2), j = Number.isInteger(j) ? Number(j) : j.toFixed(2), y += "M" + C + "," + T + " V" + j + " H" + Q + " V" + T + " H" + C + " Z ";
        } else b ? k += s + '<use x="' + C.toString() + '" y="' + T.toString() + '" href="#qrmodule" />' + i : k += s + '<rect x="' + C.toString() + '" y="' + T.toString() + '" width="' + l + '" height="' + d + '" style="fill:' + t.color + ';shape-rendering:crispEdges;"/>' + i;
      }
    }
  h && (k = s + '<path x="0" y="0" style="fill:' + t.color + ';shape-rendering:crispEdges;" d="' + y + '" />');
  let X = "";
  if (this.options.image !== void 0 && this.options.image.svg) {
    const ht = o * this.options.image.width / 100, ft = a * this.options.image.height / 100, $t = o / 2 - ht / 2, Ht = a / 2 - ft / 2;
    X += `<svg x="${$t}" y="${Ht}" width="${ht}" height="${ft}" viewBox="0 0 100 100" preserveAspectRatio="xMinYMin meet">`, X += this.options.image.svg + i, X += "</svg>";
  }
  var D = "";
  switch (e.container) {
    case "svg":
      f && (D += '<?xml version="1.0" standalone="yes"?>' + i), D += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="' + o + '" height="' + a + '">' + i, D += w + _ + k, D += X, D += "</svg>";
      break;
    case "svg-viewbox":
      f && (D += '<?xml version="1.0" standalone="yes"?>' + i), D += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 ' + o + " " + a + '">' + i, D += w + _ + k, D += X, D += "</svg>";
      break;
    case "g":
      D += '<g width="' + o + '" height="' + a + '">' + i, D += w + _ + k, D += X, D += "</g>";
      break;
    default:
      D += (w + _ + k + X).replace(/^\s+/, "");
      break;
  }
  return D;
};
var Ic = Eo, Mc = v && v.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(wn, "__esModule", { value: !0 });
wn.QRCode = void 0;
const Ac = K, Ei = nn, Pc = Mc(Ic), Nc = (e) => {
  const [t, n] = (0, Ei.useState)("");
  return (0, Ei.useEffect)(() => {
    var r, s;
    const i = new Pc.default({
      content: e.content,
      background: e.bgColor || "#ffffff",
      color: e.fgColor || "#000000",
      container: "svg",
      ecl: "M",
      width: (r = e.width) !== null && r !== void 0 ? r : 256,
      height: (s = e.height) !== null && s !== void 0 ? s : 256,
      padding: 0,
      image: e.image
    }), o = R.from(i.svg(), "utf8").toString("base64");
    n(`data:image/svg+xml;base64,${o}`);
  }, [e.bgColor, e.content, e.fgColor, e.height, e.image, e.width]), t ? (0, Ac.h)("img", { src: t, alt: "QR Code" }) : null;
};
wn.QRCode = Nc;
var _n = {}, cs = {};
Object.defineProperty(cs, "__esModule", { value: !0 });
cs.default = ".-cbwsdk-css-reset .-cbwsdk-spinner{display:inline-block}.-cbwsdk-css-reset .-cbwsdk-spinner svg{display:inline-block;animation:2s linear infinite -cbwsdk-spinner-svg}.-cbwsdk-css-reset .-cbwsdk-spinner svg circle{animation:1.9s ease-in-out infinite both -cbwsdk-spinner-circle;display:block;fill:rgba(0,0,0,0);stroke-dasharray:283;stroke-dashoffset:280;stroke-linecap:round;stroke-width:10px;transform-origin:50% 50%}@keyframes -cbwsdk-spinner-svg{0%{transform:rotateZ(0deg)}100%{transform:rotateZ(360deg)}}@keyframes -cbwsdk-spinner-circle{0%,25%{stroke-dashoffset:280;transform:rotate(0)}50%,75%{stroke-dashoffset:75;transform:rotate(45deg)}100%{stroke-dashoffset:280;transform:rotate(360deg)}}";
var Tc = v && v.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(_n, "__esModule", { value: !0 });
_n.Spinner = void 0;
const Vt = K, Lc = Tc(cs), xc = (e) => {
  var t;
  const n = (t = e.size) !== null && t !== void 0 ? t : 64, r = e.color || "#000";
  return (0, Vt.h)(
    "div",
    { class: "-cbwsdk-spinner" },
    (0, Vt.h)("style", null, Lc.default),
    (0, Vt.h)(
      "svg",
      { viewBox: "0 0 100 100", xmlns: "http://www.w3.org/2000/svg", style: { width: n, height: n } },
      (0, Vt.h)("circle", { style: { cx: 50, cy: 50, r: 45, stroke: r } })
    )
  );
};
_n.Spinner = xc;
var ls = {};
Object.defineProperty(ls, "__esModule", { value: !0 });
ls.default = ".-cbwsdk-css-reset .-cbwsdk-connect-content{height:430px;width:700px;border-radius:12px;padding:30px}.-cbwsdk-css-reset .-cbwsdk-connect-content.light{background:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content.dark{background:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-header{display:flex;align-items:center;justify-content:space-between;margin:0 0 30px}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading{font-style:normal;font-weight:500;font-size:28px;line-height:36px;margin:0}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-layout{display:flex;flex-direction:row}.-cbwsdk-css-reset .-cbwsdk-connect-content-column-left{margin-right:30px;display:flex;flex-direction:column;justify-content:space-between}.-cbwsdk-css-reset .-cbwsdk-connect-content-column-right{flex:25%;margin-right:34px}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-wrapper{width:220px;height:220px;border-radius:12px;display:flex;justify-content:center;align-items:center;background:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting{position:absolute;top:0;bottom:0;left:0;right:0;display:flex;flex-direction:column;align-items:center;justify-content:center}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.light{background-color:rgba(255,255,255,.95)}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.light>p{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.dark{background-color:rgba(10,11,13,.9)}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.dark>p{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting>p{font-size:12px;font-weight:bold;margin-top:16px}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app{border-radius:8px;font-size:14px;line-height:20px;padding:12px;width:339px}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app.light{background:#eef0f3;color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app.dark{background:#1e2025;color:#8a919e}.-cbwsdk-css-reset .-cbwsdk-cancel-button{-webkit-appearance:none;border:none;background:none;cursor:pointer;padding:0;margin:0}.-cbwsdk-css-reset .-cbwsdk-cancel-button-x{position:relative;display:block;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-wallet-steps{padding:0 0 0 16px;margin:0;width:100%;list-style:decimal}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item{list-style-type:decimal;display:list-item;font-style:normal;font-weight:400;font-size:16px;line-height:24px;margin-top:20px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item-wrapper{display:flex;align-items:center}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-pad-left{margin-left:6px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon{display:flex;border-radius:50%;height:24px;width:24px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon svg{margin:auto;display:block}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon.light{background:#0052ff}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon.dark{background:#588af5}.-cbwsdk-css-reset .-cbwsdk-connect-item{align-items:center;display:flex;flex-direction:row;padding:16px 24px;gap:12px;cursor:pointer;border-radius:100px;font-weight:600}.-cbwsdk-css-reset .-cbwsdk-connect-item.light{background:#f5f8ff;color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-connect-item.dark{background:#001033;color:#588af5}.-cbwsdk-css-reset .-cbwsdk-connect-item-copy-wrapper{margin:0 4px 0 8px}.-cbwsdk-css-reset .-cbwsdk-connect-item-title{margin:0 0 0;font-size:16px;line-height:24px;font-weight:500}.-cbwsdk-css-reset .-cbwsdk-connect-item-description{font-weight:400;font-size:14px;line-height:20px;margin:0}";
var ko = v && v.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(tt, "__esModule", { value: !0 });
tt.CoinbaseWalletSteps = tt.ConnectContent = void 0;
const Be = ko(At), P = K, Oc = m, Bc = ot, Fc = mn, jc = bn, Dc = yn, $c = wn, Hc = _n, Uc = ko(ls), $r = {
  title: "Coinbase Wallet app",
  description: "Connect with your self-custody wallet",
  steps: Co
}, Wc = (e) => e === "light" ? "#FFFFFF" : "#0A0B0D";
function zc(e) {
  const { theme: t } = e, n = (0, Oc.createQrUrl)(e.sessionId, e.sessionSecret, e.linkAPIUrl, e.isParentConnection, e.version, e.chainId), r = $r.steps;
  return (0, P.h)(
    "div",
    { "data-testid": "connect-content", className: (0, Be.default)("-cbwsdk-connect-content", t) },
    (0, P.h)("style", null, Uc.default),
    (0, P.h)(
      "div",
      { className: "-cbwsdk-connect-content-header" },
      (0, P.h)("h2", { className: (0, Be.default)("-cbwsdk-connect-content-heading", t) }, "Scan to connect with our mobile app"),
      e.onCancel && (0, P.h)(
        "button",
        { type: "button", className: "-cbwsdk-cancel-button", onClick: e.onCancel },
        (0, P.h)(Fc.CloseIcon, { fill: t === "light" ? "#0A0B0D" : "#FFFFFF" })
      )
    ),
    (0, P.h)(
      "div",
      { className: "-cbwsdk-connect-content-layout" },
      (0, P.h)(
        "div",
        { className: "-cbwsdk-connect-content-column-left" },
        (0, P.h)(Vc, { title: $r.title, description: $r.description, theme: t })
      ),
      (0, P.h)(
        "div",
        { className: "-cbwsdk-connect-content-column-right" },
        (0, P.h)(
          "div",
          { className: "-cbwsdk-connect-content-qr-wrapper" },
          (0, P.h)($c.QRCode, { content: n, width: 200, height: 200, fgColor: "#000", bgColor: "transparent" }),
          (0, P.h)("input", { type: "hidden", name: "cbw-cbwsdk-version", value: Bc.LIB_VERSION }),
          (0, P.h)("input", { type: "hidden", value: n })
        ),
        (0, P.h)(r, { theme: t }),
        !e.isConnected && (0, P.h)(
          "div",
          { "data-testid": "connecting-spinner", className: (0, Be.default)("-cbwsdk-connect-content-qr-connecting", t) },
          (0, P.h)(Hc.Spinner, { size: 36, color: t === "dark" ? "#FFF" : "#000" }),
          (0, P.h)("p", null, "Connecting...")
        )
      )
    )
  );
}
tt.ConnectContent = zc;
function Vc({ title: e, description: t, theme: n }) {
  return (0, P.h)(
    "div",
    { className: (0, Be.default)("-cbwsdk-connect-item", n) },
    (0, P.h)(
      "div",
      null,
      (0, P.h)(jc.CoinbaseWalletRound, null)
    ),
    (0, P.h)(
      "div",
      { className: "-cbwsdk-connect-item-copy-wrapper" },
      (0, P.h)("h3", { className: "-cbwsdk-connect-item-title" }, e),
      (0, P.h)("p", { className: "-cbwsdk-connect-item-description" }, t)
    )
  );
}
function Co({ theme: e }) {
  return (0, P.h)(
    "ol",
    { className: "-cbwsdk-wallet-steps" },
    (0, P.h)(
      "li",
      { className: (0, Be.default)("-cbwsdk-wallet-steps-item", e) },
      (0, P.h)("div", { className: "-cbwsdk-wallet-steps-item-wrapper" }, "Open Coinbase Wallet app")
    ),
    (0, P.h)(
      "li",
      { className: (0, Be.default)("-cbwsdk-wallet-steps-item", e) },
      (0, P.h)(
        "div",
        { className: "-cbwsdk-wallet-steps-item-wrapper" },
        (0, P.h)(
          "span",
          null,
          "Tap ",
          (0, P.h)("strong", null, "Scan"),
          " "
        ),
        (0, P.h)(
          "span",
          { className: (0, Be.default)("-cbwsdk-wallet-steps-pad-left", "-cbwsdk-wallet-steps-icon", e) },
          (0, P.h)(Dc.QRCodeIcon, { fill: Wc(e) })
        )
      )
    )
  );
}
tt.CoinbaseWalletSteps = Co;
var vn = {}, En = {};
Object.defineProperty(En, "__esModule", { value: !0 });
En.ArrowLeftIcon = void 0;
const ki = K;
function Jc(e) {
  return (0, ki.h)(
    "svg",
    Object.assign({ width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg" }, e),
    (0, ki.h)("path", { d: "M8.60675 0.155884L7.37816 1.28209L12.7723 7.16662H0V8.83328H12.6548L6.82149 14.6666L8 15.8451L15.8201 8.02501L8.60675 0.155884Z" })
  );
}
En.ArrowLeftIcon = Jc;
var kn = {};
Object.defineProperty(kn, "__esModule", { value: !0 });
kn.LaptopIcon = void 0;
const Hr = K;
function qc(e) {
  return (0, Hr.h)(
    "svg",
    Object.assign({ width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" }, e),
    (0, Hr.h)("path", { d: "M1.8001 2.2002H12.2001V9.40019H1.8001V2.2002ZM3.4001 3.8002V7.80019H10.6001V3.8002H3.4001Z" }),
    (0, Hr.h)("path", { d: "M13.4001 10.2002H0.600098C0.600098 11.0838 1.31644 11.8002 2.2001 11.8002H11.8001C12.6838 11.8002 13.4001 11.0838 13.4001 10.2002Z" })
  );
}
kn.LaptopIcon = qc;
var Cn = {};
Object.defineProperty(Cn, "__esModule", { value: !0 });
Cn.SafeIcon = void 0;
const Ci = K;
function Zc(e) {
  return (0, Ci.h)(
    "svg",
    Object.assign({ width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" }, e),
    (0, Ci.h)("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M0.600098 0.600098V11.8001H13.4001V0.600098H0.600098ZM7.0001 9.2001C5.3441 9.2001 4.0001 7.8561 4.0001 6.2001C4.0001 4.5441 5.3441 3.2001 7.0001 3.2001C8.6561 3.2001 10.0001 4.5441 10.0001 6.2001C10.0001 7.8561 8.6561 9.2001 7.0001 9.2001ZM0.600098 12.6001H3.8001V13.4001H0.600098V12.6001ZM10.2001 12.6001H13.4001V13.4001H10.2001V12.6001ZM8.8001 6.2001C8.8001 7.19421 7.99421 8.0001 7.0001 8.0001C6.00598 8.0001 5.2001 7.19421 5.2001 6.2001C5.2001 5.20598 6.00598 4.4001 7.0001 4.4001C7.99421 4.4001 8.8001 5.20598 8.8001 6.2001Z" })
  );
}
Cn.SafeIcon = Zc;
var ds = {};
Object.defineProperty(ds, "__esModule", { value: !0 });
ds.default = ".-cbwsdk-css-reset .-cbwsdk-try-extension{display:flex;margin-top:12px;height:202px;width:700px;border-radius:12px;padding:30px}.-cbwsdk-css-reset .-cbwsdk-try-extension.light{background:#fff}.-cbwsdk-css-reset .-cbwsdk-try-extension.dark{background:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-try-extension-column-half{flex:50%}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading{font-style:normal;font-weight:500;font-size:25px;line-height:32px;margin:0;max-width:204px}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta{appearance:none;border:none;background:none;color:#0052ff;cursor:pointer;padding:0;text-decoration:none;display:block;font-weight:600;font-size:16px;line-height:24px}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta.light{color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta.dark{color:#588af5}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta-wrapper{display:flex;align-items:center;margin-top:12px}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta-icon{display:block;margin-left:4px;height:14px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list{display:flex;flex-direction:column;justify-content:center;align-items:center;margin:0;padding:0;list-style:none;height:100%}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item{display:flex;align-items:center;flex-flow:nowrap;margin-top:24px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item:first-of-type{margin-top:0}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon-wrapper{display:block}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon{display:flex;height:32px;width:32px;border-radius:50%}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon svg{margin:auto;display:block}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon.light{background:#eef0f3}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon.dark{background:#1e2025}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy{display:block;font-weight:400;font-size:14px;line-height:20px;padding-left:12px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy.light{color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy.dark{color:#8a919e}";
var So = v && v.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(vn, "__esModule", { value: !0 });
vn.TryExtensionContent = void 0;
const Me = So(At), F = K, Ur = nn, Gc = En, Qc = kn, Kc = Cn, Yc = So(ds);
function Xc({ theme: e }) {
  const [t, n] = (0, Ur.useState)(!1), r = (0, Ur.useCallback)(() => {
    window.open("https://api.wallet.coinbase.com/rpc/v2/desktop/chrome", "_blank");
  }, []), s = (0, Ur.useCallback)(() => {
    t ? window.location.reload() : (r(), n(!0));
  }, [r, t]);
  return (0, F.h)(
    "div",
    { class: (0, Me.default)("-cbwsdk-try-extension", e) },
    (0, F.h)("style", null, Yc.default),
    (0, F.h)(
      "div",
      { class: "-cbwsdk-try-extension-column-half" },
      (0, F.h)("h3", { class: (0, Me.default)("-cbwsdk-try-extension-heading", e) }, "Or try the Coinbase Wallet browser extension"),
      (0, F.h)(
        "div",
        { class: "-cbwsdk-try-extension-cta-wrapper" },
        (0, F.h)("button", { class: (0, Me.default)("-cbwsdk-try-extension-cta", e), onClick: s }, t ? "Refresh" : "Install"),
        (0, F.h)("div", null, !t && (0, F.h)(Gc.ArrowLeftIcon, { class: "-cbwsdk-try-extension-cta-icon", fill: e === "light" ? "#0052FF" : "#588AF5" }))
      )
    ),
    (0, F.h)(
      "div",
      { class: "-cbwsdk-try-extension-column-half" },
      (0, F.h)(
        "ul",
        { class: "-cbwsdk-try-extension-list" },
        (0, F.h)(
          "li",
          { class: "-cbwsdk-try-extension-list-item" },
          (0, F.h)(
            "div",
            { class: "-cbwsdk-try-extension-list-item-icon-wrapper" },
            (0, F.h)(
              "span",
              { class: (0, Me.default)("-cbwsdk-try-extension-list-item-icon", e) },
              (0, F.h)(Qc.LaptopIcon, { fill: e === "light" ? "#0A0B0D" : "#FFFFFF" })
            )
          ),
          (0, F.h)("div", { class: (0, Me.default)("-cbwsdk-try-extension-list-item-copy", e) }, "Connect with dapps with just one click on your desktop browser")
        ),
        (0, F.h)(
          "li",
          { class: "-cbwsdk-try-extension-list-item" },
          (0, F.h)(
            "div",
            { class: "-cbwsdk-try-extension-list-item-icon-wrapper" },
            (0, F.h)(
              "span",
              { class: (0, Me.default)("-cbwsdk-try-extension-list-item-icon", e) },
              (0, F.h)(Kc.SafeIcon, { fill: e === "light" ? "#0A0B0D" : "#FFFFFF" })
            )
          ),
          (0, F.h)("div", { class: (0, Me.default)("-cbwsdk-try-extension-list-item-copy", e) }, "Add an additional layer of security by using a supported Ledger hardware wallet")
        )
      )
    )
  );
}
vn.TryExtensionContent = Xc;
var us = {};
Object.defineProperty(us, "__esModule", { value: !0 });
us.default = ".-cbwsdk-css-reset .-cbwsdk-connect-dialog{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop.light{background-color:rgba(0,0,0,.5)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop.dark{background-color:rgba(50,53,61,.4)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-box{display:flex;position:relative;flex-direction:column;transform:scale(1);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-box-hidden{opacity:0;transform:scale(0.85)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-container{display:block}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-container-hidden{display:none}";
var Ro = v && v.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(pn, "__esModule", { value: !0 });
pn.ConnectDialog = void 0;
const Wr = Ro(At), Ae = K, zr = nn, el = tt, tl = vn, nl = Ro(us), rl = (e) => {
  const { isOpen: t, darkMode: n } = e, [r, s] = (0, zr.useState)(!t), [i, o] = (0, zr.useState)(!t);
  (0, zr.useEffect)(() => {
    const c = [
      window.setTimeout(() => {
        o(!t);
      }, 10)
    ];
    return t ? s(!1) : c.push(window.setTimeout(() => {
      s(!0);
    }, 360)), () => {
      c.forEach(window.clearTimeout);
    };
  }, [t]);
  const a = n ? "dark" : "light";
  return (0, Ae.h)(
    "div",
    { class: (0, Wr.default)("-cbwsdk-connect-dialog-container", r && "-cbwsdk-connect-dialog-container-hidden") },
    (0, Ae.h)("style", null, nl.default),
    (0, Ae.h)("div", { class: (0, Wr.default)("-cbwsdk-connect-dialog-backdrop", a, i && "-cbwsdk-connect-dialog-backdrop-hidden") }),
    (0, Ae.h)(
      "div",
      { class: "-cbwsdk-connect-dialog" },
      (0, Ae.h)(
        "div",
        { class: (0, Wr.default)("-cbwsdk-connect-dialog-box", i && "-cbwsdk-connect-dialog-box-hidden") },
        e.connectDisabled ? null : (0, Ae.h)(el.ConnectContent, { theme: a, version: e.version, sessionId: e.sessionId, sessionSecret: e.sessionSecret, linkAPIUrl: e.linkAPIUrl, isConnected: e.isConnected, isParentConnection: e.isParentConnection, chainId: e.chainId, onCancel: e.onCancel }),
        (0, Ae.h)(tl.TryExtensionContent, { theme: a })
      )
    )
  );
};
pn.ConnectDialog = rl;
Object.defineProperty(gn, "__esModule", { value: !0 });
gn.LinkFlow = void 0;
const Vr = K, sl = pn;
class il {
  constructor(t) {
    this.connected = !1, this.chainId = 1, this.isOpen = !1, this.onCancel = null, this.root = null, this.connectDisabled = !1, this.darkMode = t.darkMode, this.version = t.version, this.sessionId = t.sessionId, this.sessionSecret = t.sessionSecret, this.linkAPIUrl = t.linkAPIUrl, this.isParentConnection = t.isParentConnection;
  }
  attach(t) {
    this.root = document.createElement("div"), this.root.className = "-cbwsdk-link-flow-root", t.appendChild(this.root), this.render();
  }
  setConnected(t) {
    this.connected !== t && (this.connected = t, this.render());
  }
  setChainId(t) {
    this.chainId !== t && (this.chainId = t, this.render());
  }
  detach() {
    var t;
    this.root && ((0, Vr.render)(null, this.root), (t = this.root.parentElement) === null || t === void 0 || t.removeChild(this.root));
  }
  setConnectDisabled(t) {
    this.connectDisabled = t;
  }
  open(t) {
    this.isOpen = !0, this.onCancel = t.onCancel, this.render();
  }
  close() {
    this.isOpen = !1, this.onCancel = null, this.render();
  }
  render() {
    this.root && (0, Vr.render)((0, Vr.h)(sl.ConnectDialog, { darkMode: this.darkMode, version: this.version, sessionId: this.sessionId, sessionSecret: this.sessionSecret, linkAPIUrl: this.linkAPIUrl, isOpen: this.isOpen, isConnected: this.connected, isParentConnection: this.isParentConnection, chainId: this.chainId, onCancel: this.onCancel, connectDisabled: this.connectDisabled }), this.root);
  }
}
gn.LinkFlow = il;
var hs = {}, fs = {};
Object.defineProperty(fs, "__esModule", { value: !0 });
fs.default = ".-cbwsdk-css-reset .-gear-container{margin-left:16px !important;margin-right:9px !important;display:flex;align-items:center;justify-content:center;width:24px;height:24px;transition:opacity .25s}.-cbwsdk-css-reset .-gear-container *{user-select:none}.-cbwsdk-css-reset .-gear-container svg{opacity:0;position:absolute}.-cbwsdk-css-reset .-gear-icon{height:12px;width:12px;z-index:10000}.-cbwsdk-css-reset .-cbwsdk-snackbar{align-items:flex-end;display:flex;flex-direction:column;position:fixed;right:0;top:0;z-index:2147483647}.-cbwsdk-css-reset .-cbwsdk-snackbar *{user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance{display:flex;flex-direction:column;margin:8px 16px 0 16px;overflow:visible;text-align:left;transform:translateX(0);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header:hover .-gear-container svg{opacity:1}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header{display:flex;align-items:center;background:#fff;overflow:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-cblogo{margin:8px 8px 8px 8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-message{color:#000;font-size:13px;line-height:1.5;user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu{background:#fff;transition:opacity .25s ease-in-out,transform .25s linear,visibility 0s;visibility:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;opacity:0;flex-direction:column;padding-left:8px;padding-right:8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:last-child{margin-bottom:8px !important}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover{background:#f5f7f8;border-radius:6px;transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover span{color:#050f19;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover svg path{fill:#000;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item{visibility:inherit;height:35px;margin-top:8px;margin-bottom:0;display:flex;flex-direction:row;align-items:center;padding:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item *{visibility:inherit;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover{background:rgba(223,95,103,.2);transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover svg path{fill:#df5f67;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover span{color:#df5f67;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-info{color:#aaa;font-size:13px;margin:0 8px 0 32px;position:absolute}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-hidden{opacity:0;text-align:left;transform:translateX(25%);transition:opacity .5s linear}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-expanded .-cbwsdk-snackbar-instance-menu{opacity:1;display:flex;transform:translateY(8px);visibility:visible}";
(function(e) {
  var t = v && v.__importDefault || function(h) {
    return h && h.__esModule ? h : { default: h };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.SnackbarInstance = e.SnackbarContainer = e.Snackbar = void 0;
  const n = t(At), r = K, s = nn, i = t(fs), o = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEuNDkyIDEwLjQxOWE4LjkzIDguOTMgMCAwMTguOTMtOC45M2gxMS4xNjNhOC45MyA4LjkzIDAgMDE4LjkzIDguOTN2MTEuMTYzYTguOTMgOC45MyAwIDAxLTguOTMgOC45M0gxMC40MjJhOC45MyA4LjkzIDAgMDEtOC45My04LjkzVjEwLjQxOXoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEwLjQxOSAwSDIxLjU4QzI3LjMzNSAwIDMyIDQuNjY1IDMyIDEwLjQxOVYyMS41OEMzMiAyNy4zMzUgMjcuMzM1IDMyIDIxLjU4MSAzMkgxMC40MkM0LjY2NSAzMiAwIDI3LjMzNSAwIDIxLjU4MVYxMC40MkMwIDQuNjY1IDQuNjY1IDAgMTAuNDE5IDB6bTAgMS40ODhhOC45MyA4LjkzIDAgMDAtOC45MyA4LjkzdjExLjE2M2E4LjkzIDguOTMgMCAwMDguOTMgOC45M0gyMS41OGE4LjkzIDguOTMgMCAwMDguOTMtOC45M1YxMC40MmE4LjkzIDguOTMgMCAwMC04LjkzLTguOTNIMTAuNDJ6IiBmaWxsPSIjZmZmIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS45OTggMjYuMDQ5Yy01LjU0OSAwLTEwLjA0Ny00LjQ5OC0xMC4wNDctMTAuMDQ3IDAtNS41NDggNC40OTgtMTAuMDQ2IDEwLjA0Ny0xMC4wNDYgNS41NDggMCAxMC4wNDYgNC40OTggMTAuMDQ2IDEwLjA0NiAwIDUuNTQ5LTQuNDk4IDEwLjA0Ny0xMC4wNDYgMTAuMDQ3eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xMi43NjIgMTQuMjU0YzAtLjgyMi42NjctMS40ODkgMS40ODktMS40ODloMy40OTdjLjgyMiAwIDEuNDg4LjY2NiAxLjQ4OCAxLjQ4OXYzLjQ5N2MwIC44MjItLjY2NiAxLjQ4OC0xLjQ4OCAxLjQ4OGgtMy40OTdhMS40ODggMS40ODggMCAwMS0xLjQ4OS0xLjQ4OHYtMy40OTh6IiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+", a = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDYuNzV2LTEuNWwtMS43Mi0uNTdjLS4wOC0uMjctLjE5LS41Mi0uMzItLjc3bC44MS0xLjYyLTEuMDYtMS4wNi0xLjYyLjgxYy0uMjQtLjEzLS41LS4yNC0uNzctLjMyTDYuNzUgMGgtMS41bC0uNTcgMS43MmMtLjI3LjA4LS41My4xOS0uNzcuMzJsLTEuNjItLjgxLTEuMDYgMS4wNi44MSAxLjYyYy0uMTMuMjQtLjI0LjUtLjMyLjc3TDAgNS4yNXYxLjVsMS43Mi41N2MuMDguMjcuMTkuNTMuMzIuNzdsLS44MSAxLjYyIDEuMDYgMS4wNiAxLjYyLS44MWMuMjQuMTMuNS4yMy43Ny4zMkw1LjI1IDEyaDEuNWwuNTctMS43MmMuMjctLjA4LjUyLS4xOS43Ny0uMzJsMS42Mi44MSAxLjA2LTEuMDYtLjgxLTEuNjJjLjEzLS4yNC4yMy0uNS4zMi0uNzdMMTIgNi43NXpNNiA4LjVhMi41IDIuNSAwIDAxMC01IDIuNSAyLjUgMCAwMTAgNXoiIGZpbGw9IiMwNTBGMTkiLz48L3N2Zz4=";
  class c {
    constructor(u) {
      this.items = /* @__PURE__ */ new Map(), this.nextItemKey = 0, this.root = null, this.darkMode = u.darkMode;
    }
    attach(u) {
      this.root = document.createElement("div"), this.root.className = "-cbwsdk-snackbar-root", u.appendChild(this.root), this.render();
    }
    presentItem(u) {
      const f = this.nextItemKey++;
      return this.items.set(f, u), this.render(), () => {
        this.items.delete(f), this.render();
      };
    }
    clear() {
      this.items.clear(), this.render();
    }
    render() {
      this.root && (0, r.render)((0, r.h)(
        "div",
        null,
        (0, r.h)(e.SnackbarContainer, { darkMode: this.darkMode }, Array.from(this.items.entries()).map(([u, f]) => (0, r.h)(e.SnackbarInstance, Object.assign({}, f, { key: u }))))
      ), this.root);
    }
  }
  e.Snackbar = c;
  const l = (h) => (0, r.h)(
    "div",
    { class: (0, n.default)("-cbwsdk-snackbar-container") },
    (0, r.h)("style", null, i.default),
    (0, r.h)("div", { class: "-cbwsdk-snackbar" }, h.children)
  );
  e.SnackbarContainer = l;
  const d = ({ autoExpand: h, message: u, menuItems: f }) => {
    const [b, w] = (0, s.useState)(!0), [_, k] = (0, s.useState)(h ?? !1);
    (0, s.useEffect)(() => {
      const g = [
        window.setTimeout(() => {
          w(!1);
        }, 1),
        window.setTimeout(() => {
          k(!0);
        }, 1e4)
      ];
      return () => {
        g.forEach(window.clearTimeout);
      };
    });
    const y = () => {
      k(!_);
    };
    return (0, r.h)(
      "div",
      { class: (0, n.default)("-cbwsdk-snackbar-instance", b && "-cbwsdk-snackbar-instance-hidden", _ && "-cbwsdk-snackbar-instance-expanded") },
      (0, r.h)(
        "div",
        { class: "-cbwsdk-snackbar-instance-header", onClick: y },
        (0, r.h)("img", { src: o, class: "-cbwsdk-snackbar-instance-header-cblogo" }),
        " ",
        (0, r.h)("div", { class: "-cbwsdk-snackbar-instance-header-message" }, u),
        (0, r.h)(
          "div",
          { class: "-gear-container" },
          !_ && (0, r.h)(
            "svg",
            { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
            (0, r.h)("circle", { cx: "12", cy: "12", r: "12", fill: "#F5F7F8" })
          ),
          (0, r.h)("img", { src: a, class: "-gear-icon", title: "Expand" })
        )
      ),
      f && f.length > 0 && (0, r.h)("div", { class: "-cbwsdk-snackbar-instance-menu" }, f.map((g, M) => (0, r.h)(
        "div",
        { class: (0, n.default)("-cbwsdk-snackbar-instance-menu-item", g.isRed && "-cbwsdk-snackbar-instance-menu-item-is-red"), onClick: g.onClick, key: M },
        (0, r.h)(
          "svg",
          { width: g.svgWidth, height: g.svgHeight, viewBox: "0 0 10 11", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
          (0, r.h)("path", { "fill-rule": g.defaultFillRule, "clip-rule": g.defaultClipRule, d: g.path, fill: "#AAAAAA" })
        ),
        (0, r.h)("span", { class: (0, n.default)("-cbwsdk-snackbar-instance-menu-item-info", g.isRed && "-cbwsdk-snackbar-instance-menu-item-info-is-red") }, g.info)
      )))
    );
  };
  e.SnackbarInstance = d;
})(hs);
Object.defineProperty(It, "__esModule", { value: !0 });
It.WalletLinkRelayUI = void 0;
const ol = Mt, al = gn, cl = hs;
class ll {
  constructor(t) {
    this.standalone = null, this.attached = !1, this.snackbar = new cl.Snackbar({
      darkMode: t.darkMode
    }), this.linkFlow = new al.LinkFlow({
      darkMode: t.darkMode,
      version: t.version,
      sessionId: t.session.id,
      sessionSecret: t.session.secret,
      linkAPIUrl: t.linkAPIUrl,
      isParentConnection: !1
    });
  }
  attach() {
    if (this.attached)
      throw new Error("Coinbase Wallet SDK UI is already attached");
    const t = document.documentElement, n = document.createElement("div");
    n.className = "-cbwsdk-css-reset", t.appendChild(n), this.linkFlow.attach(n), this.snackbar.attach(n), this.attached = !0, (0, ol.injectCssReset)();
  }
  setConnected(t) {
    this.linkFlow.setConnected(t);
  }
  setChainId(t) {
    this.linkFlow.setChainId(t);
  }
  setConnectDisabled(t) {
    this.linkFlow.setConnectDisabled(t);
  }
  /* istanbul ignore next */
  addEthereumChain() {
  }
  // no-op
  /* istanbul ignore next */
  watchAsset() {
  }
  // no-op
  /* istanbul ignore next */
  switchEthereumChain() {
  }
  // no-op
  requestEthereumAccounts(t) {
    this.linkFlow.open({ onCancel: t.onCancel });
  }
  hideRequestEthereumAccounts() {
    this.linkFlow.close();
  }
  /* istanbul ignore next */
  signEthereumMessage() {
  }
  // no-op
  /* istanbul ignore next */
  signEthereumTransaction() {
  }
  // no-op
  /* istanbul ignore next */
  submitEthereumTransaction() {
  }
  // no-op
  /* istanbul ignore next */
  ethereumAddressFromSignedMessage() {
  }
  // no-op
  showConnecting(t) {
    let n;
    return t.isUnlinkedErrorState ? n = {
      autoExpand: !0,
      message: "Connection lost",
      menuItems: [
        {
          isRed: !1,
          info: "Reset connection",
          svgWidth: "10",
          svgHeight: "11",
          path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
          defaultFillRule: "evenodd",
          defaultClipRule: "evenodd",
          onClick: t.onResetConnection
        }
      ]
    } : n = {
      message: "Confirm on phone",
      menuItems: [
        {
          isRed: !0,
          info: "Cancel transaction",
          svgWidth: "11",
          svgHeight: "11",
          path: "M10.3711 1.52346L9.21775 0.370117L5.37109 4.21022L1.52444 0.370117L0.371094 1.52346L4.2112 5.37012L0.371094 9.21677L1.52444 10.3701L5.37109 6.53001L9.21775 10.3701L10.3711 9.21677L6.53099 5.37012L10.3711 1.52346Z",
          defaultFillRule: "inherit",
          defaultClipRule: "inherit",
          onClick: t.onCancel
        },
        {
          isRed: !1,
          info: "Reset connection",
          svgWidth: "10",
          svgHeight: "11",
          path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
          defaultFillRule: "evenodd",
          defaultClipRule: "evenodd",
          onClick: t.onResetConnection
        }
      ]
    }, this.snackbar.presentItem(n);
  }
  /* istanbul ignore next */
  reloadUI() {
    document.location.reload();
  }
  /* istanbul ignore next */
  inlineAccountsResponse() {
    return !1;
  }
  /* istanbul ignore next */
  inlineAddEthereumChain() {
    return !1;
  }
  /* istanbul ignore next */
  inlineWatchAsset() {
    return !1;
  }
  /* istanbul ignore next */
  inlineSwitchEthereumChain() {
    return !1;
  }
  /* istanbul ignore next */
  setStandalone(t) {
    this.standalone = t;
  }
  /* istanbul ignore next */
  isStandalone() {
    var t;
    return (t = this.standalone) !== null && t !== void 0 ? t : !1;
  }
}
It.WalletLinkRelayUI = ll;
Object.defineProperty(Rt, "__esModule", { value: !0 });
Rt.WalletLinkRelay = void 0;
const Ve = vt, dl = $, L = m, Pe = at, Si = oe, ke = ct, ul = un, Ne = it, hl = It;
class _e extends Si.RelayAbstract {
  constructor(t) {
    var n;
    super(), this.accountsCallback = null, this.chainCallbackParams = { chainId: "", jsonRpcUrl: "" }, this.chainCallback = null, this.dappDefaultChain = 1, this.appName = "", this.appLogoUrl = null, this.linkedUpdated = (o) => {
      var a;
      this.isLinked = o;
      const c = this.storage.getItem(Si.LOCAL_STORAGE_ADDRESSES_KEY);
      if (o && (this.session.linked = o), this.isUnlinkedErrorState = !1, c) {
        const l = c.split(" "), d = this.storage.getItem("IsStandaloneSigning") === "true";
        if (l[0] !== "" && !o && this.session.linked && !d) {
          this.isUnlinkedErrorState = !0;
          const h = this.getSessionIdHash();
          (a = this.diagnostic) === null || a === void 0 || a.log(Pe.EVENTS.UNLINKED_ERROR_STATE, {
            sessionIdHash: h
          });
        }
      }
    }, this.metadataUpdated = (o, a) => {
      this.storage.setItem(o, a);
    }, this.chainUpdated = (o, a) => {
      this.chainCallbackParams.chainId === o && this.chainCallbackParams.jsonRpcUrl === a || (this.chainCallbackParams = {
        chainId: o,
        jsonRpcUrl: a
      }, this.chainCallback && this.chainCallback(o, a));
    }, this.accountUpdated = (o) => {
      this.accountsCallback && this.accountsCallback([o]), _e.accountRequestCallbackIds.size > 0 && (Array.from(_e.accountRequestCallbackIds.values()).forEach((a) => {
        const c = {
          type: "WEB3_RESPONSE",
          id: a,
          response: {
            method: "requestEthereumAccounts",
            result: [o]
          }
        };
        this.invokeCallback(Object.assign(Object.assign({}, c), { id: a }));
      }), _e.accountRequestCallbackIds.clear());
    }, this.connectedUpdated = (o) => {
      this.ui.setConnected(o);
    }, this.resetAndReload = this.resetAndReload.bind(this), this.linkAPIUrl = t.linkAPIUrl, this.storage = t.storage, this.options = t;
    const { session: r, ui: s, connection: i } = this.subscribe();
    this._session = r, this.connection = i, this.relayEventManager = t.relayEventManager, this.diagnostic = t.diagnosticLogger, this._reloadOnDisconnect = (n = t.reloadOnDisconnect) !== null && n !== void 0 ? n : !0, this.ui = s;
  }
  subscribe() {
    const t = ke.Session.load(this.storage) || new ke.Session(this.storage).save(), { linkAPIUrl: n, diagnostic: r } = this, s = new ul.WalletLinkConnection({
      session: t,
      linkAPIUrl: n,
      diagnostic: r,
      listener: this
    }), { version: i, darkMode: o } = this.options, a = this.options.uiConstructor({
      linkAPIUrl: n,
      version: i,
      darkMode: o,
      session: t
    });
    return s.connect(), { session: t, ui: a, connection: s };
  }
  attachUI() {
    this.ui.attach();
  }
  resetAndReload() {
    Promise.race([
      this.connection.setSessionMetadata("__destroyed", "1"),
      new Promise((t) => setTimeout(() => t(null), 1e3))
    ]).then(() => {
      var t, n;
      const r = this.ui.isStandalone();
      (t = this.diagnostic) === null || t === void 0 || t.log(Pe.EVENTS.SESSION_STATE_CHANGE, {
        method: "relay::resetAndReload",
        sessionMetadataChange: "__destroyed, 1",
        sessionIdHash: this.getSessionIdHash()
      }), this.connection.destroy();
      const s = ke.Session.load(this.storage);
      if ((s == null ? void 0 : s.id) === this._session.id ? this.storage.clear() : s && ((n = this.diagnostic) === null || n === void 0 || n.log(Pe.EVENTS.SKIPPED_CLEARING_SESSION, {
        sessionIdHash: this.getSessionIdHash(),
        storedSessionIdHash: ke.Session.hash(s.id)
      })), this._reloadOnDisconnect) {
        this.ui.reloadUI();
        return;
      }
      this.accountsCallback && this.accountsCallback([], !0);
      const { session: i, ui: o, connection: a } = this.subscribe();
      this._session = i, this.connection = a, this.ui = o, r && this.ui.setStandalone && this.ui.setStandalone(!0), this.options.headlessMode || this.attachUI();
    }).catch((t) => {
      var n;
      (n = this.diagnostic) === null || n === void 0 || n.log(Pe.EVENTS.FAILURE, {
        method: "relay::resetAndReload",
        message: `failed to reset and reload with ${t}`,
        sessionIdHash: this.getSessionIdHash()
      });
    });
  }
  setAppInfo(t, n) {
    this.appName = t, this.appLogoUrl = n;
  }
  getStorageItem(t) {
    return this.storage.getItem(t);
  }
  get session() {
    return this._session;
  }
  setStorageItem(t, n) {
    this.storage.setItem(t, n);
  }
  signEthereumMessage(t, n, r, s) {
    return this.sendRequest({
      method: "signEthereumMessage",
      params: {
        message: (0, L.hexStringFromBuffer)(t, !0),
        address: n,
        addPrefix: r,
        typedDataJson: s || null
      }
    });
  }
  ethereumAddressFromSignedMessage(t, n, r) {
    return this.sendRequest({
      method: "ethereumAddressFromSignedMessage",
      params: {
        message: (0, L.hexStringFromBuffer)(t, !0),
        signature: (0, L.hexStringFromBuffer)(n, !0),
        addPrefix: r
      }
    });
  }
  signEthereumTransaction(t) {
    return this.sendRequest({
      method: "signEthereumTransaction",
      params: {
        fromAddress: t.fromAddress,
        toAddress: t.toAddress,
        weiValue: (0, L.bigIntStringFromBN)(t.weiValue),
        data: (0, L.hexStringFromBuffer)(t.data, !0),
        nonce: t.nonce,
        gasPriceInWei: t.gasPriceInWei ? (0, L.bigIntStringFromBN)(t.gasPriceInWei) : null,
        maxFeePerGas: t.gasPriceInWei ? (0, L.bigIntStringFromBN)(t.gasPriceInWei) : null,
        maxPriorityFeePerGas: t.gasPriceInWei ? (0, L.bigIntStringFromBN)(t.gasPriceInWei) : null,
        gasLimit: t.gasLimit ? (0, L.bigIntStringFromBN)(t.gasLimit) : null,
        chainId: t.chainId,
        shouldSubmit: !1
      }
    });
  }
  signAndSubmitEthereumTransaction(t) {
    return this.sendRequest({
      method: "signEthereumTransaction",
      params: {
        fromAddress: t.fromAddress,
        toAddress: t.toAddress,
        weiValue: (0, L.bigIntStringFromBN)(t.weiValue),
        data: (0, L.hexStringFromBuffer)(t.data, !0),
        nonce: t.nonce,
        gasPriceInWei: t.gasPriceInWei ? (0, L.bigIntStringFromBN)(t.gasPriceInWei) : null,
        maxFeePerGas: t.maxFeePerGas ? (0, L.bigIntStringFromBN)(t.maxFeePerGas) : null,
        maxPriorityFeePerGas: t.maxPriorityFeePerGas ? (0, L.bigIntStringFromBN)(t.maxPriorityFeePerGas) : null,
        gasLimit: t.gasLimit ? (0, L.bigIntStringFromBN)(t.gasLimit) : null,
        chainId: t.chainId,
        shouldSubmit: !0
      }
    });
  }
  submitEthereumTransaction(t, n) {
    return this.sendRequest({
      method: "submitEthereumTransaction",
      params: {
        signedTransaction: (0, L.hexStringFromBuffer)(t, !0),
        chainId: n
      }
    });
  }
  scanQRCode(t) {
    return this.sendRequest({
      method: "scanQRCode",
      params: {
        regExp: t
      }
    });
  }
  getQRCodeUrl() {
    return (0, L.createQrUrl)(this._session.id, this._session.secret, this.linkAPIUrl, !1, this.options.version, this.dappDefaultChain);
  }
  genericRequest(t, n) {
    return this.sendRequest({
      method: "generic",
      params: {
        action: n,
        data: t
      }
    });
  }
  sendGenericMessage(t) {
    return this.sendRequest(t);
  }
  sendRequest(t) {
    let n = null;
    const r = (0, L.randomBytesHex)(8), s = (o) => {
      this.publishWeb3RequestCanceledEvent(r), this.handleErrorResponse(r, t.method, o), n == null || n();
    };
    return { promise: new Promise((o, a) => {
      this.ui.isStandalone() || (n = this.ui.showConnecting({
        isUnlinkedErrorState: this.isUnlinkedErrorState,
        onCancel: s,
        onResetConnection: this.resetAndReload
        // eslint-disable-line @typescript-eslint/unbound-method
      })), this.relayEventManager.callbacks.set(r, (c) => {
        if (n == null || n(), (0, Ne.isErrorResponse)(c))
          return a(new Error(c.errorMessage));
        o(c);
      }), this.ui.isStandalone() ? this.sendRequestStandalone(r, t) : this.publishWeb3RequestEvent(r, t);
    }), cancel: s };
  }
  setConnectDisabled(t) {
    this.ui.setConnectDisabled(t);
  }
  setAccountsCallback(t) {
    this.accountsCallback = t;
  }
  setChainCallback(t) {
    this.chainCallback = t;
  }
  setDappDefaultChainCallback(t) {
    this.dappDefaultChain = t, this.ui instanceof hl.WalletLinkRelayUI && this.ui.setChainId(t);
  }
  publishWeb3RequestEvent(t, n) {
    var r;
    const s = { type: "WEB3_REQUEST", id: t, request: n }, i = ke.Session.load(this.storage);
    (r = this.diagnostic) === null || r === void 0 || r.log(Pe.EVENTS.WEB3_REQUEST, {
      eventId: s.id,
      method: `relay::${n.method}`,
      sessionIdHash: this.getSessionIdHash(),
      storedSessionIdHash: i ? ke.Session.hash(i.id) : "",
      isSessionMismatched: ((i == null ? void 0 : i.id) !== this._session.id).toString()
    }), this.publishEvent("Web3Request", s, !0).then((o) => {
      var a;
      (a = this.diagnostic) === null || a === void 0 || a.log(Pe.EVENTS.WEB3_REQUEST_PUBLISHED, {
        eventId: s.id,
        method: `relay::${n.method}`,
        sessionIdHash: this.getSessionIdHash(),
        storedSessionIdHash: i ? ke.Session.hash(i.id) : "",
        isSessionMismatched: ((i == null ? void 0 : i.id) !== this._session.id).toString()
      });
    }).catch((o) => {
      this.handleWeb3ResponseMessage({
        type: "WEB3_RESPONSE",
        id: s.id,
        response: {
          method: n.method,
          errorMessage: o.message
        }
      });
    });
  }
  publishWeb3RequestCanceledEvent(t) {
    const n = {
      type: "WEB3_REQUEST_CANCELED",
      id: t
    };
    this.publishEvent("Web3RequestCanceled", n, !1).then();
  }
  publishEvent(t, n, r) {
    return this.connection.publishEvent(t, n, r);
  }
  handleWeb3ResponseMessage(t) {
    var n;
    const { response: r } = t;
    if ((n = this.diagnostic) === null || n === void 0 || n.log(Pe.EVENTS.WEB3_RESPONSE, {
      eventId: t.id,
      method: `relay::${r.method}`,
      sessionIdHash: this.getSessionIdHash()
    }), r.method === "requestEthereumAccounts") {
      _e.accountRequestCallbackIds.forEach((s) => this.invokeCallback(Object.assign(Object.assign({}, t), { id: s }))), _e.accountRequestCallbackIds.clear();
      return;
    }
    this.invokeCallback(t);
  }
  handleErrorResponse(t, n, r, s) {
    var i;
    const o = (i = r == null ? void 0 : r.message) !== null && i !== void 0 ? i : (0, Ve.getMessageFromCode)(s);
    this.handleWeb3ResponseMessage({
      type: "WEB3_RESPONSE",
      id: t,
      response: {
        method: n,
        errorMessage: o,
        errorCode: s
      }
    });
  }
  invokeCallback(t) {
    const n = this.relayEventManager.callbacks.get(t.id);
    n && (n(t.response), this.relayEventManager.callbacks.delete(t.id));
  }
  requestEthereumAccounts() {
    const t = {
      method: "requestEthereumAccounts",
      params: {
        appName: this.appName,
        appLogoUrl: this.appLogoUrl || null
      }
    }, n = (0, L.randomBytesHex)(8), r = (i) => {
      this.publishWeb3RequestCanceledEvent(n), this.handleErrorResponse(n, t.method, i);
    };
    return { promise: new Promise((i, o) => {
      if (this.relayEventManager.callbacks.set(n, (a) => {
        if (this.ui.hideRequestEthereumAccounts(), (0, Ne.isErrorResponse)(a))
          return o(new Error(a.errorMessage));
        i(a);
      }), this.ui.inlineAccountsResponse()) {
        const a = (c) => {
          this.handleWeb3ResponseMessage({
            type: "WEB3_RESPONSE",
            id: n,
            response: { method: "requestEthereumAccounts", result: c }
          });
        };
        this.ui.requestEthereumAccounts({
          onCancel: r,
          onAccounts: a
        });
      } else {
        const a = Ve.standardErrors.provider.userRejectedRequest("User denied account authorization");
        this.ui.requestEthereumAccounts({
          onCancel: () => r(a)
        });
      }
      _e.accountRequestCallbackIds.add(n), !this.ui.inlineAccountsResponse() && !this.ui.isStandalone() && this.publishWeb3RequestEvent(n, t);
    }), cancel: r };
  }
  selectProvider(t) {
    const n = {
      method: "selectProvider",
      params: {
        providerOptions: t
      }
    }, r = (0, L.randomBytesHex)(8), s = (o) => {
      this.publishWeb3RequestCanceledEvent(r), this.handleErrorResponse(r, n.method, o);
    }, i = new Promise((o, a) => {
      this.relayEventManager.callbacks.set(r, (d) => {
        if ((0, Ne.isErrorResponse)(d))
          return a(new Error(d.errorMessage));
        o(d);
      });
      const c = (d) => {
        this.handleWeb3ResponseMessage({
          type: "WEB3_RESPONSE",
          id: r,
          response: { method: "selectProvider", result: dl.ProviderType.Unselected }
        });
      }, l = (d) => {
        this.handleWeb3ResponseMessage({
          type: "WEB3_RESPONSE",
          id: r,
          response: { method: "selectProvider", result: d }
        });
      };
      this.ui.selectProvider && this.ui.selectProvider({
        onApprove: l,
        onCancel: c,
        providerOptions: t
      });
    });
    return { cancel: s, promise: i };
  }
  watchAsset(t, n, r, s, i, o) {
    const a = {
      method: "watchAsset",
      params: {
        type: t,
        options: {
          address: n,
          symbol: r,
          decimals: s,
          image: i
        },
        chainId: o
      }
    };
    let c = null;
    const l = (0, L.randomBytesHex)(8), d = (u) => {
      this.publishWeb3RequestCanceledEvent(l), this.handleErrorResponse(l, a.method, u), c == null || c();
    };
    this.ui.inlineWatchAsset() || (c = this.ui.showConnecting({
      isUnlinkedErrorState: this.isUnlinkedErrorState,
      onCancel: d,
      onResetConnection: this.resetAndReload
      // eslint-disable-line @typescript-eslint/unbound-method
    }));
    const h = new Promise((u, f) => {
      this.relayEventManager.callbacks.set(l, (_) => {
        if (c == null || c(), (0, Ne.isErrorResponse)(_))
          return f(new Error(_.errorMessage));
        u(_);
      });
      const b = (_) => {
        this.handleWeb3ResponseMessage({
          type: "WEB3_RESPONSE",
          id: l,
          response: {
            method: "watchAsset",
            result: !1
          }
        });
      }, w = () => {
        this.handleWeb3ResponseMessage({
          type: "WEB3_RESPONSE",
          id: l,
          response: {
            method: "watchAsset",
            result: !0
          }
        });
      };
      this.ui.inlineWatchAsset() && this.ui.watchAsset({
        onApprove: w,
        onCancel: b,
        type: t,
        address: n,
        symbol: r,
        decimals: s,
        image: i,
        chainId: o
      }), !this.ui.inlineWatchAsset() && !this.ui.isStandalone() && this.publishWeb3RequestEvent(l, a);
    });
    return { cancel: d, promise: h };
  }
  addEthereumChain(t, n, r, s, i, o) {
    const a = {
      method: "addEthereumChain",
      params: {
        chainId: t,
        rpcUrls: n,
        blockExplorerUrls: s,
        chainName: i,
        iconUrls: r,
        nativeCurrency: o
      }
    };
    let c = null;
    const l = (0, L.randomBytesHex)(8), d = (u) => {
      this.publishWeb3RequestCanceledEvent(l), this.handleErrorResponse(l, a.method, u), c == null || c();
    };
    return this.ui.inlineAddEthereumChain(t) || (c = this.ui.showConnecting({
      isUnlinkedErrorState: this.isUnlinkedErrorState,
      onCancel: d,
      onResetConnection: this.resetAndReload
      // eslint-disable-line @typescript-eslint/unbound-method
    })), { promise: new Promise((u, f) => {
      this.relayEventManager.callbacks.set(l, (_) => {
        if (c == null || c(), (0, Ne.isErrorResponse)(_))
          return f(new Error(_.errorMessage));
        u(_);
      });
      const b = (_) => {
        this.handleWeb3ResponseMessage({
          type: "WEB3_RESPONSE",
          id: l,
          response: {
            method: "addEthereumChain",
            result: {
              isApproved: !1,
              rpcUrl: ""
            }
          }
        });
      }, w = (_) => {
        this.handleWeb3ResponseMessage({
          type: "WEB3_RESPONSE",
          id: l,
          response: {
            method: "addEthereumChain",
            result: {
              isApproved: !0,
              rpcUrl: _
            }
          }
        });
      };
      this.ui.inlineAddEthereumChain(t) && this.ui.addEthereumChain({
        onCancel: b,
        onApprove: w,
        chainId: a.params.chainId,
        rpcUrls: a.params.rpcUrls,
        blockExplorerUrls: a.params.blockExplorerUrls,
        chainName: a.params.chainName,
        iconUrls: a.params.iconUrls,
        nativeCurrency: a.params.nativeCurrency
      }), !this.ui.inlineAddEthereumChain(t) && !this.ui.isStandalone() && this.publishWeb3RequestEvent(l, a);
    }), cancel: d };
  }
  switchEthereumChain(t, n) {
    const r = {
      method: "switchEthereumChain",
      params: Object.assign({ chainId: t }, { address: n })
    }, s = (0, L.randomBytesHex)(8), i = (a) => {
      this.publishWeb3RequestCanceledEvent(s), this.handleErrorResponse(s, r.method, a);
    };
    return { promise: new Promise((a, c) => {
      this.relayEventManager.callbacks.set(s, (h) => {
        if ((0, Ne.isErrorResponse)(h) && h.errorCode)
          return c(Ve.standardErrors.provider.custom({
            code: h.errorCode,
            message: "Unrecognized chain ID. Try adding the chain using addEthereumChain first."
          }));
        if ((0, Ne.isErrorResponse)(h))
          return c(new Error(h.errorMessage));
        a(h);
      });
      const l = (h) => {
        var u;
        if (h) {
          const f = (u = (0, Ve.getErrorCode)(h)) !== null && u !== void 0 ? u : Ve.standardErrorCodes.provider.unsupportedChain;
          this.handleErrorResponse(s, "switchEthereumChain", h instanceof Error ? h : Ve.standardErrors.provider.unsupportedChain(t), f);
        } else
          this.handleWeb3ResponseMessage({
            type: "WEB3_RESPONSE",
            id: s,
            response: {
              method: "switchEthereumChain",
              result: {
                isApproved: !1,
                rpcUrl: ""
              }
            }
          });
      }, d = (h) => {
        this.handleWeb3ResponseMessage({
          type: "WEB3_RESPONSE",
          id: s,
          response: {
            method: "switchEthereumChain",
            result: {
              isApproved: !0,
              rpcUrl: h
            }
          }
        });
      };
      this.ui.switchEthereumChain({
        onCancel: l,
        onApprove: d,
        chainId: r.params.chainId,
        address: r.params.address
      }), !this.ui.inlineSwitchEthereumChain() && !this.ui.isStandalone() && this.publishWeb3RequestEvent(s, r);
    }), cancel: i };
  }
  inlineAddEthereumChain(t) {
    return this.ui.inlineAddEthereumChain(t);
  }
  getSessionIdHash() {
    return ke.Session.hash(this._session.id);
  }
  sendRequestStandalone(t, n) {
    const r = (i) => {
      this.handleErrorResponse(t, n.method, i);
    }, s = (i) => {
      this.handleWeb3ResponseMessage({
        type: "WEB3_RESPONSE",
        id: t,
        response: i
      });
    };
    switch (n.method) {
      case "signEthereumMessage":
        this.ui.signEthereumMessage({
          request: n,
          onSuccess: s,
          onCancel: r
        });
        break;
      case "signEthereumTransaction":
        this.ui.signEthereumTransaction({
          request: n,
          onSuccess: s,
          onCancel: r
        });
        break;
      case "submitEthereumTransaction":
        this.ui.submitEthereumTransaction({
          request: n,
          onSuccess: s,
          onCancel: r
        });
        break;
      case "ethereumAddressFromSignedMessage":
        this.ui.ethereumAddressFromSignedMessage({
          request: n,
          onSuccess: s
        });
        break;
      default:
        r();
        break;
    }
  }
}
Rt.WalletLinkRelay = _e;
_e.accountRequestCallbackIds = /* @__PURE__ */ new Set();
var Pt = {}, Sn = {}, Io = {};
(function(e) {
  var t = v && v.__createBinding || (Object.create ? function(r, s, i, o) {
    o === void 0 && (o = i);
    var a = Object.getOwnPropertyDescriptor(s, i);
    (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
      return s[i];
    } }), Object.defineProperty(r, o, a);
  } : function(r, s, i, o) {
    o === void 0 && (o = i), r[o] = s[i];
  }), n = v && v.__exportStar || function(r, s) {
    for (var i in r) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && t(s, r, i);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), n(hs, e);
})(Io);
var gs = {};
Object.defineProperty(gs, "__esModule", { value: !0 });
gs.default = ".-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop{position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s;background-color:rgba(10,11,13,.5)}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box{display:block;position:fixed;top:50%;left:50%;transform:translate(-50%, -50%);padding:20px;border-radius:8px;background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box p{display:block;font-weight:400;font-size:14px;line-height:20px;padding-bottom:12px;color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box button{appearance:none;border:none;background:none;color:#0052ff;padding:0;text-decoration:none;display:block;font-weight:600;font-size:16px;line-height:24px}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark{background-color:#0a0b0d;color:#fff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark button{color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light{background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light button{color:#0052ff}";
var Mo = v && v.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Sn, "__esModule", { value: !0 });
Sn.RedirectDialog = void 0;
const fl = Mo(At), ge = K, gl = Mt, pl = Io, ml = Mo(gs);
class bl {
  constructor() {
    this.root = null;
  }
  attach() {
    const t = document.documentElement;
    this.root = document.createElement("div"), this.root.className = "-cbwsdk-css-reset", t.appendChild(this.root), (0, gl.injectCssReset)();
  }
  present(t) {
    this.render(t);
  }
  clear() {
    this.render(null);
  }
  render(t) {
    this.root && ((0, ge.render)(null, this.root), t && (0, ge.render)((0, ge.h)(yl, Object.assign({}, t, { onDismiss: () => {
      this.clear();
    } })), this.root));
  }
}
Sn.RedirectDialog = bl;
const yl = ({ title: e, buttonText: t, darkMode: n, onButtonClick: r, onDismiss: s }) => {
  const i = n ? "dark" : "light";
  return (0, ge.h)(
    pl.SnackbarContainer,
    { darkMode: n },
    (0, ge.h)(
      "div",
      { class: "-cbwsdk-redirect-dialog" },
      (0, ge.h)("style", null, ml.default),
      (0, ge.h)("div", { class: "-cbwsdk-redirect-dialog-backdrop", onClick: s }),
      (0, ge.h)(
        "div",
        { class: (0, fl.default)("-cbwsdk-redirect-dialog-box", i) },
        (0, ge.h)("p", null, e),
        (0, ge.h)("button", { onClick: r }, t)
      )
    )
  );
};
Object.defineProperty(Pt, "__esModule", { value: !0 });
Pt.MobileRelayUI = void 0;
const wl = Sn;
class _l {
  constructor(t) {
    this.attached = !1, this.darkMode = !1, this.redirectDialog = new wl.RedirectDialog(), this.darkMode = t.darkMode;
  }
  attach() {
    if (this.attached)
      throw new Error("Coinbase Wallet SDK UI is already attached");
    this.redirectDialog.attach(), this.attached = !0;
  }
  setConnected(t) {
  }
  // no-op
  redirectToCoinbaseWallet(t) {
    const n = new URL("https://go.cb-w.com/walletlink");
    n.searchParams.append("redirect_url", window.location.href), t && n.searchParams.append("wl_url", t);
    const r = document.createElement("a");
    r.target = "cbw-opener", r.href = n.href, r.rel = "noreferrer noopener", r.click();
  }
  openCoinbaseWalletDeeplink(t) {
    this.redirectDialog.present({
      title: "Redirecting to Coinbase Wallet...",
      buttonText: "Open",
      darkMode: this.darkMode,
      onButtonClick: () => {
        this.redirectToCoinbaseWallet(t);
      }
    }), setTimeout(() => {
      this.redirectToCoinbaseWallet(t);
    }, 99);
  }
  showConnecting(t) {
    return () => {
      this.redirectDialog.clear();
    };
  }
  hideRequestEthereumAccounts() {
    this.redirectDialog.clear();
  }
  // -- Methods below are not needed for mobile
  requestEthereumAccounts() {
  }
  // no-op
  addEthereumChain() {
  }
  // no-op
  watchAsset() {
  }
  // no-op
  selectProvider() {
  }
  // no-op
  switchEthereumChain() {
  }
  // no-op
  signEthereumMessage() {
  }
  // no-op
  signEthereumTransaction() {
  }
  // no-op
  submitEthereumTransaction() {
  }
  // no-op
  ethereumAddressFromSignedMessage() {
  }
  // no-op
  reloadUI() {
  }
  // no-op
  setStandalone() {
  }
  // no-op
  setConnectDisabled() {
  }
  // no-op
  inlineAccountsResponse() {
    return !1;
  }
  inlineAddEthereumChain() {
    return !1;
  }
  inlineWatchAsset() {
    return !1;
  }
  inlineSwitchEthereumChain() {
    return !1;
  }
  isStandalone() {
    return !1;
  }
}
Pt.MobileRelayUI = _l;
Object.defineProperty(St, "__esModule", { value: !0 });
St.MobileRelay = void 0;
const vl = m, El = Rt, kl = Pt;
class Cl extends El.WalletLinkRelay {
  constructor(t) {
    var n;
    super(t), this._enableMobileWalletLink = (n = t.enableMobileWalletLink) !== null && n !== void 0 ? n : !1;
  }
  // override
  requestEthereumAccounts() {
    return this._enableMobileWalletLink ? super.requestEthereumAccounts() : {
      promise: new Promise(() => {
        const t = (0, vl.getLocation)();
        t.href = `https://go.cb-w.com/dapp?cb_url=${encodeURIComponent(t.href)}`;
      }),
      cancel: () => {
      }
    };
  }
  // override
  publishWeb3RequestEvent(t, n) {
    if (super.publishWeb3RequestEvent(t, n), !(this._enableMobileWalletLink && this.ui instanceof kl.MobileRelayUI))
      return;
    let r = !1;
    switch (n.method) {
      case "requestEthereumAccounts":
      case "connectAndSignIn":
        r = !0, this.ui.openCoinbaseWalletDeeplink(this.getQRCodeUrl());
        break;
      case "switchEthereumChain":
        return;
      default:
        r = !0, this.ui.openCoinbaseWalletDeeplink();
        break;
    }
    r && window.addEventListener("blur", () => {
      window.addEventListener("focus", () => {
        this.connection.checkUnseenEvents();
      }, { once: !0 });
    }, { once: !0 });
  }
  // override
  handleWeb3ResponseMessage(t) {
    super.handleWeb3ResponseMessage(t);
  }
  connectAndSignIn(t) {
    if (!this._enableMobileWalletLink)
      throw new Error("connectAndSignIn is supported only when enableMobileWalletLink is on");
    return this.sendRequest({
      method: "connectAndSignIn",
      params: {
        appName: this.appName,
        appLogoUrl: this.appLogoUrl,
        domain: window.location.hostname,
        aud: window.location.href,
        version: "1",
        type: "eip4361",
        nonce: t.nonce,
        iat: (/* @__PURE__ */ new Date()).toISOString(),
        chainId: `eip155:${this.dappDefaultChain}`,
        statement: t.statement,
        resources: t.resources
      }
    });
  }
}
St.MobileRelay = Cl;
const { Transform: Sl } = ro;
var Rl = (e) => class Ao extends Sl {
  constructor(n, r, s, i, o) {
    super(o), this._rate = n, this._capacity = r, this._delimitedSuffix = s, this._hashBitLength = i, this._options = o, this._state = new e(), this._state.initialize(n, r), this._finalized = !1;
  }
  _transform(n, r, s) {
    let i = null;
    try {
      this.update(n, r);
    } catch (o) {
      i = o;
    }
    s(i);
  }
  _flush(n) {
    let r = null;
    try {
      this.push(this.digest());
    } catch (s) {
      r = s;
    }
    n(r);
  }
  update(n, r) {
    if (!R.isBuffer(n) && typeof n != "string") throw new TypeError("Data must be a string or a buffer");
    if (this._finalized) throw new Error("Digest already called");
    return R.isBuffer(n) || (n = R.from(n, r)), this._state.absorb(n), this;
  }
  digest(n) {
    if (this._finalized) throw new Error("Digest already called");
    this._finalized = !0, this._delimitedSuffix && this._state.absorbLastFewBits(this._delimitedSuffix);
    let r = this._state.squeeze(this._hashBitLength / 8);
    return n !== void 0 && (r = r.toString(n)), this._resetState(), r;
  }
  // remove result from memory
  _resetState() {
    return this._state.initialize(this._rate, this._capacity), this;
  }
  // because sometimes we need hash right now and little later
  _clone() {
    const n = new Ao(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);
    return this._state.copy(n._state), n._finalized = this._finalized, n;
  }
};
const { Transform: Il } = ro;
var Ml = (e) => class Po extends Il {
  constructor(n, r, s, i) {
    super(i), this._rate = n, this._capacity = r, this._delimitedSuffix = s, this._options = i, this._state = new e(), this._state.initialize(n, r), this._finalized = !1;
  }
  _transform(n, r, s) {
    let i = null;
    try {
      this.update(n, r);
    } catch (o) {
      i = o;
    }
    s(i);
  }
  _flush() {
  }
  _read(n) {
    this.push(this.squeeze(n));
  }
  update(n, r) {
    if (!R.isBuffer(n) && typeof n != "string") throw new TypeError("Data must be a string or a buffer");
    if (this._finalized) throw new Error("Squeeze already called");
    return R.isBuffer(n) || (n = R.from(n, r)), this._state.absorb(n), this;
  }
  squeeze(n, r) {
    this._finalized || (this._finalized = !0, this._state.absorbLastFewBits(this._delimitedSuffix));
    let s = this._state.squeeze(n);
    return r !== void 0 && (s = s.toString(r)), s;
  }
  _resetState() {
    return this._state.initialize(this._rate, this._capacity), this;
  }
  _clone() {
    const n = new Po(this._rate, this._capacity, this._delimitedSuffix, this._options);
    return this._state.copy(n._state), n._finalized = this._finalized, n;
  }
};
const Al = Rl, Pl = Ml;
var Nl = function(e) {
  const t = Al(e), n = Pl(e);
  return function(r, s) {
    switch (typeof r == "string" ? r.toLowerCase() : r) {
      case "keccak224":
        return new t(1152, 448, null, 224, s);
      case "keccak256":
        return new t(1088, 512, null, 256, s);
      case "keccak384":
        return new t(832, 768, null, 384, s);
      case "keccak512":
        return new t(576, 1024, null, 512, s);
      case "sha3-224":
        return new t(1152, 448, 6, 224, s);
      case "sha3-256":
        return new t(1088, 512, 6, 256, s);
      case "sha3-384":
        return new t(832, 768, 6, 384, s);
      case "sha3-512":
        return new t(576, 1024, 6, 512, s);
      case "shake128":
        return new n(1344, 256, 31, s);
      case "shake256":
        return new n(1088, 512, 31, s);
      default:
        throw new Error("Invald algorithm: " + r);
    }
  };
}, No = {};
const Ri = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
No.p1600 = function(e) {
  for (let t = 0; t < 24; ++t) {
    const n = e[0] ^ e[10] ^ e[20] ^ e[30] ^ e[40], r = e[1] ^ e[11] ^ e[21] ^ e[31] ^ e[41], s = e[2] ^ e[12] ^ e[22] ^ e[32] ^ e[42], i = e[3] ^ e[13] ^ e[23] ^ e[33] ^ e[43], o = e[4] ^ e[14] ^ e[24] ^ e[34] ^ e[44], a = e[5] ^ e[15] ^ e[25] ^ e[35] ^ e[45], c = e[6] ^ e[16] ^ e[26] ^ e[36] ^ e[46], l = e[7] ^ e[17] ^ e[27] ^ e[37] ^ e[47], d = e[8] ^ e[18] ^ e[28] ^ e[38] ^ e[48], h = e[9] ^ e[19] ^ e[29] ^ e[39] ^ e[49];
    let u = d ^ (s << 1 | i >>> 31), f = h ^ (i << 1 | s >>> 31);
    const b = e[0] ^ u, w = e[1] ^ f, _ = e[10] ^ u, k = e[11] ^ f, y = e[20] ^ u, g = e[21] ^ f, M = e[30] ^ u, p = e[31] ^ f, C = e[40] ^ u, T = e[41] ^ f;
    u = n ^ (o << 1 | a >>> 31), f = r ^ (a << 1 | o >>> 31);
    const W = e[2] ^ u, Q = e[3] ^ f, j = e[12] ^ u, X = e[13] ^ f, D = e[22] ^ u, ht = e[23] ^ f, ft = e[32] ^ u, $t = e[33] ^ f, Ht = e[42] ^ u, xs = e[43] ^ f;
    u = s ^ (c << 1 | l >>> 31), f = i ^ (l << 1 | c >>> 31);
    const Os = e[4] ^ u, Bs = e[5] ^ f, Fs = e[14] ^ u, js = e[15] ^ f, Ds = e[24] ^ u, $s = e[25] ^ f, Hs = e[34] ^ u, Us = e[35] ^ f, Ws = e[44] ^ u, zs = e[45] ^ f;
    u = o ^ (d << 1 | h >>> 31), f = a ^ (h << 1 | d >>> 31);
    const Vs = e[6] ^ u, Js = e[7] ^ f, qs = e[16] ^ u, Zs = e[17] ^ f, Gs = e[26] ^ u, Qs = e[27] ^ f, Ks = e[36] ^ u, Ys = e[37] ^ f, Xs = e[46] ^ u, ei = e[47] ^ f;
    u = c ^ (n << 1 | r >>> 31), f = l ^ (r << 1 | n >>> 31);
    const ti = e[8] ^ u, ni = e[9] ^ f, ri = e[18] ^ u, si = e[19] ^ f, ii = e[28] ^ u, oi = e[29] ^ f, ai = e[38] ^ u, ci = e[39] ^ f, li = e[48] ^ u, di = e[49] ^ f, Un = b, Wn = w, zn = k << 4 | _ >>> 28, Vn = _ << 4 | k >>> 28, Jn = y << 3 | g >>> 29, qn = g << 3 | y >>> 29, Zn = p << 9 | M >>> 23, Gn = M << 9 | p >>> 23, Qn = C << 18 | T >>> 14, Kn = T << 18 | C >>> 14, Yn = W << 1 | Q >>> 31, Xn = Q << 1 | W >>> 31, er = X << 12 | j >>> 20, tr = j << 12 | X >>> 20, nr = D << 10 | ht >>> 22, rr = ht << 10 | D >>> 22, sr = $t << 13 | ft >>> 19, ir = ft << 13 | $t >>> 19, or = Ht << 2 | xs >>> 30, ar = xs << 2 | Ht >>> 30, cr = Bs << 30 | Os >>> 2, lr = Os << 30 | Bs >>> 2, dr = Fs << 6 | js >>> 26, ur = js << 6 | Fs >>> 26, hr = $s << 11 | Ds >>> 21, fr = Ds << 11 | $s >>> 21, gr = Hs << 15 | Us >>> 17, pr = Us << 15 | Hs >>> 17, mr = zs << 29 | Ws >>> 3, br = Ws << 29 | zs >>> 3, yr = Vs << 28 | Js >>> 4, wr = Js << 28 | Vs >>> 4, _r = Zs << 23 | qs >>> 9, vr = qs << 23 | Zs >>> 9, Er = Gs << 25 | Qs >>> 7, kr = Qs << 25 | Gs >>> 7, Cr = Ks << 21 | Ys >>> 11, Sr = Ys << 21 | Ks >>> 11, Rr = ei << 24 | Xs >>> 8, Ir = Xs << 24 | ei >>> 8, Mr = ti << 27 | ni >>> 5, Ar = ni << 27 | ti >>> 5, Pr = ri << 20 | si >>> 12, Nr = si << 20 | ri >>> 12, Tr = oi << 7 | ii >>> 25, Lr = ii << 7 | oi >>> 25, xr = ai << 8 | ci >>> 24, Or = ci << 8 | ai >>> 24, Br = li << 14 | di >>> 18, Fr = di << 14 | li >>> 18;
    e[0] = Un ^ ~er & hr, e[1] = Wn ^ ~tr & fr, e[10] = yr ^ ~Pr & Jn, e[11] = wr ^ ~Nr & qn, e[20] = Yn ^ ~dr & Er, e[21] = Xn ^ ~ur & kr, e[30] = Mr ^ ~zn & nr, e[31] = Ar ^ ~Vn & rr, e[40] = cr ^ ~_r & Tr, e[41] = lr ^ ~vr & Lr, e[2] = er ^ ~hr & Cr, e[3] = tr ^ ~fr & Sr, e[12] = Pr ^ ~Jn & sr, e[13] = Nr ^ ~qn & ir, e[22] = dr ^ ~Er & xr, e[23] = ur ^ ~kr & Or, e[32] = zn ^ ~nr & gr, e[33] = Vn ^ ~rr & pr, e[42] = _r ^ ~Tr & Zn, e[43] = vr ^ ~Lr & Gn, e[4] = hr ^ ~Cr & Br, e[5] = fr ^ ~Sr & Fr, e[14] = Jn ^ ~sr & mr, e[15] = qn ^ ~ir & br, e[24] = Er ^ ~xr & Qn, e[25] = kr ^ ~Or & Kn, e[34] = nr ^ ~gr & Rr, e[35] = rr ^ ~pr & Ir, e[44] = Tr ^ ~Zn & or, e[45] = Lr ^ ~Gn & ar, e[6] = Cr ^ ~Br & Un, e[7] = Sr ^ ~Fr & Wn, e[16] = sr ^ ~mr & yr, e[17] = ir ^ ~br & wr, e[26] = xr ^ ~Qn & Yn, e[27] = Or ^ ~Kn & Xn, e[36] = gr ^ ~Rr & Mr, e[37] = pr ^ ~Ir & Ar, e[46] = Zn ^ ~or & cr, e[47] = Gn ^ ~ar & lr, e[8] = Br ^ ~Un & er, e[9] = Fr ^ ~Wn & tr, e[18] = mr ^ ~yr & Pr, e[19] = br ^ ~wr & Nr, e[28] = Qn ^ ~Yn & dr, e[29] = Kn ^ ~Xn & ur, e[38] = Rr ^ ~Mr & zn, e[39] = Ir ^ ~Ar & Vn, e[48] = or ^ ~cr & _r, e[49] = ar ^ ~lr & vr, e[0] ^= Ri[t * 2], e[1] ^= Ri[t * 2 + 1];
  }
};
const Yt = No;
function lt() {
  this.state = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ], this.blockSize = null, this.count = 0, this.squeezing = !1;
}
lt.prototype.initialize = function(e, t) {
  for (let n = 0; n < 50; ++n) this.state[n] = 0;
  this.blockSize = e / 8, this.count = 0, this.squeezing = !1;
};
lt.prototype.absorb = function(e) {
  for (let t = 0; t < e.length; ++t)
    this.state[~~(this.count / 4)] ^= e[t] << 8 * (this.count % 4), this.count += 1, this.count === this.blockSize && (Yt.p1600(this.state), this.count = 0);
};
lt.prototype.absorbLastFewBits = function(e) {
  this.state[~~(this.count / 4)] ^= e << 8 * (this.count % 4), e & 128 && this.count === this.blockSize - 1 && Yt.p1600(this.state), this.state[~~((this.blockSize - 1) / 4)] ^= 128 << 8 * ((this.blockSize - 1) % 4), Yt.p1600(this.state), this.count = 0, this.squeezing = !0;
};
lt.prototype.squeeze = function(e) {
  this.squeezing || this.absorbLastFewBits(1);
  const t = R.alloc(e);
  for (let n = 0; n < e; ++n)
    t[n] = this.state[~~(this.count / 4)] >>> 8 * (this.count % 4) & 255, this.count += 1, this.count === this.blockSize && (Yt.p1600(this.state), this.count = 0);
  return t;
};
lt.prototype.copy = function(e) {
  for (let t = 0; t < 50; ++t) e.state[t] = this.state[t];
  e.blockSize = this.blockSize, e.count = this.count, e.squeezing = this.squeezing;
};
var Tl = lt, Ll = Nl(Tl);
const xl = Ll, Ol = tn;
function To(e) {
  return R.allocUnsafe(e).fill(0);
}
function Lo(e, t, n) {
  const r = To(t);
  return e = Rn(e), n ? e.length < t ? (e.copy(r), r) : e.slice(0, t) : e.length < t ? (e.copy(r, t - e.length), r) : e.slice(-t);
}
function Bl(e, t) {
  return Lo(e, t, !0);
}
function Rn(e) {
  if (!R.isBuffer(e))
    if (Array.isArray(e))
      e = R.from(e);
    else if (typeof e == "string")
      xo(e) ? e = R.from(Dl(Oo(e)), "hex") : e = R.from(e);
    else if (typeof e == "number")
      e = intToBuffer(e);
    else if (e == null)
      e = R.allocUnsafe(0);
    else if (Ol.isBN(e))
      e = e.toArrayLike(R);
    else if (e.toArray)
      e = R.from(e.toArray());
    else
      throw new Error("invalid type");
  return e;
}
function Fl(e) {
  return e = Rn(e), "0x" + e.toString("hex");
}
function jl(e, t) {
  return e = Rn(e), t || (t = 256), xl("keccak" + t).update(e).digest();
}
function Dl(e) {
  return e.length % 2 ? "0" + e : e;
}
function xo(e) {
  return typeof e == "string" && e.match(/^0x[0-9A-Fa-f]*$/);
}
function Oo(e) {
  return typeof e == "string" && e.startsWith("0x") ? e.slice(2) : e;
}
var Bo = {
  zeros: To,
  setLength: Lo,
  setLengthRight: Bl,
  isHexString: xo,
  stripHexPrefix: Oo,
  toBuffer: Rn,
  bufferToHex: Fl,
  keccak: jl
};
const Fe = Bo, xe = tn;
function Fo(e) {
  return e.startsWith("int[") ? "int256" + e.slice(3) : e === "int" ? "int256" : e.startsWith("uint[") ? "uint256" + e.slice(4) : e === "uint" ? "uint256" : e.startsWith("fixed[") ? "fixed128x128" + e.slice(5) : e === "fixed" ? "fixed128x128" : e.startsWith("ufixed[") ? "ufixed128x128" + e.slice(6) : e === "ufixed" ? "ufixed128x128" : e;
}
function Qe(e) {
  return parseInt(/^\D+(\d+)$/.exec(e)[1], 10);
}
function Ii(e) {
  var t = /^\D+(\d+)x(\d+)$/.exec(e);
  return [parseInt(t[1], 10), parseInt(t[2], 10)];
}
function jo(e) {
  var t = e.match(/(.*)\[(.*?)\]$/);
  return t ? t[2] === "" ? "dynamic" : parseInt(t[2], 10) : null;
}
function Te(e) {
  var t = typeof e;
  if (t === "string")
    return Fe.isHexString(e) ? new xe(Fe.stripHexPrefix(e), 16) : new xe(e, 10);
  if (t === "number")
    return new xe(e);
  if (e.toArray)
    return e;
  throw new Error("Argument is not a number");
}
function fe(e, t) {
  var n, r, s, i;
  if (e === "address")
    return fe("uint160", Te(t));
  if (e === "bool")
    return fe("uint8", t ? 1 : 0);
  if (e === "string")
    return fe("bytes", new R(t, "utf8"));
  if (Hl(e)) {
    if (typeof t.length > "u")
      throw new Error("Not an array?");
    if (n = jo(e), n !== "dynamic" && n !== 0 && t.length > n)
      throw new Error("Elements exceed array size: " + n);
    s = [], e = e.slice(0, e.lastIndexOf("[")), typeof t == "string" && (t = JSON.parse(t));
    for (i in t)
      s.push(fe(e, t[i]));
    if (n === "dynamic") {
      var o = fe("uint256", t.length);
      s.unshift(o);
    }
    return R.concat(s);
  } else {
    if (e === "bytes")
      return t = new R(t), s = R.concat([fe("uint256", t.length), t]), t.length % 32 !== 0 && (s = R.concat([s, Fe.zeros(32 - t.length % 32)])), s;
    if (e.startsWith("bytes")) {
      if (n = Qe(e), n < 1 || n > 32)
        throw new Error("Invalid bytes<N> width: " + n);
      return Fe.setLengthRight(t, 32);
    } else if (e.startsWith("uint")) {
      if (n = Qe(e), n % 8 || n < 8 || n > 256)
        throw new Error("Invalid uint<N> width: " + n);
      if (r = Te(t), r.bitLength() > n)
        throw new Error("Supplied uint exceeds width: " + n + " vs " + r.bitLength());
      if (r < 0)
        throw new Error("Supplied uint is negative");
      return r.toArrayLike(R, "be", 32);
    } else if (e.startsWith("int")) {
      if (n = Qe(e), n % 8 || n < 8 || n > 256)
        throw new Error("Invalid int<N> width: " + n);
      if (r = Te(t), r.bitLength() > n)
        throw new Error("Supplied int exceeds width: " + n + " vs " + r.bitLength());
      return r.toTwos(256).toArrayLike(R, "be", 32);
    } else if (e.startsWith("ufixed")) {
      if (n = Ii(e), r = Te(t), r < 0)
        throw new Error("Supplied ufixed is negative");
      return fe("uint256", r.mul(new xe(2).pow(new xe(n[1]))));
    } else if (e.startsWith("fixed"))
      return n = Ii(e), fe("int256", Te(t).mul(new xe(2).pow(new xe(n[1]))));
  }
  throw new Error("Unsupported or invalid type: " + e);
}
function $l(e) {
  return e === "string" || e === "bytes" || jo(e) === "dynamic";
}
function Hl(e) {
  return e.lastIndexOf("]") === e.length - 1;
}
function Ul(e, t) {
  var n = [], r = [], s = 32 * e.length;
  for (var i in e) {
    var o = Fo(e[i]), a = t[i], c = fe(o, a);
    $l(o) ? (n.push(fe("uint256", s)), r.push(c), s += c.length) : n.push(c);
  }
  return R.concat(n.concat(r));
}
function Do(e, t) {
  if (e.length !== t.length)
    throw new Error("Number of types are not matching the values");
  for (var n, r, s = [], i = 0; i < e.length; i++) {
    var o = Fo(e[i]), a = t[i];
    if (o === "bytes")
      s.push(a);
    else if (o === "string")
      s.push(new R(a, "utf8"));
    else if (o === "bool")
      s.push(new R(a ? "01" : "00", "hex"));
    else if (o === "address")
      s.push(Fe.setLength(a, 20));
    else if (o.startsWith("bytes")) {
      if (n = Qe(o), n < 1 || n > 32)
        throw new Error("Invalid bytes<N> width: " + n);
      s.push(Fe.setLengthRight(a, n));
    } else if (o.startsWith("uint")) {
      if (n = Qe(o), n % 8 || n < 8 || n > 256)
        throw new Error("Invalid uint<N> width: " + n);
      if (r = Te(a), r.bitLength() > n)
        throw new Error("Supplied uint exceeds width: " + n + " vs " + r.bitLength());
      s.push(r.toArrayLike(R, "be", n / 8));
    } else if (o.startsWith("int")) {
      if (n = Qe(o), n % 8 || n < 8 || n > 256)
        throw new Error("Invalid int<N> width: " + n);
      if (r = Te(a), r.bitLength() > n)
        throw new Error("Supplied int exceeds width: " + n + " vs " + r.bitLength());
      s.push(r.toTwos(n).toArrayLike(R, "be", n / 8));
    } else
      throw new Error("Unsupported or invalid type: " + o);
  }
  return R.concat(s);
}
function Wl(e, t) {
  return Fe.keccak(Do(e, t));
}
var zl = {
  rawEncode: Ul,
  solidityPack: Do,
  soliditySHA3: Wl
};
const de = Bo, bt = zl, $o = {
  type: "object",
  properties: {
    types: {
      type: "object",
      additionalProperties: {
        type: "array",
        items: {
          type: "object",
          properties: {
            name: { type: "string" },
            type: { type: "string" }
          },
          required: ["name", "type"]
        }
      }
    },
    primaryType: { type: "string" },
    domain: { type: "object" },
    message: { type: "object" }
  },
  required: ["types", "primaryType", "domain", "message"]
}, Jr = {
  /**
   * Encodes an object by encoding and concatenating each of its members
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of an object
   */
  encodeData(e, t, n, r = !0) {
    const s = ["bytes32"], i = [this.hashType(e, n)];
    if (r) {
      const o = (a, c, l) => {
        if (n[c] !== void 0)
          return ["bytes32", l == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : de.keccak(this.encodeData(c, l, n, r))];
        if (l === void 0)
          throw new Error(`missing value for field ${a} of type ${c}`);
        if (c === "bytes")
          return ["bytes32", de.keccak(l)];
        if (c === "string")
          return typeof l == "string" && (l = R.from(l, "utf8")), ["bytes32", de.keccak(l)];
        if (c.lastIndexOf("]") === c.length - 1) {
          const d = c.slice(0, c.lastIndexOf("[")), h = l.map((u) => o(a, d, u));
          return ["bytes32", de.keccak(bt.rawEncode(
            h.map(([u]) => u),
            h.map(([, u]) => u)
          ))];
        }
        return [c, l];
      };
      for (const a of n[e]) {
        const [c, l] = o(a.name, a.type, t[a.name]);
        s.push(c), i.push(l);
      }
    } else
      for (const o of n[e]) {
        let a = t[o.name];
        if (a !== void 0)
          if (o.type === "bytes")
            s.push("bytes32"), a = de.keccak(a), i.push(a);
          else if (o.type === "string")
            s.push("bytes32"), typeof a == "string" && (a = R.from(a, "utf8")), a = de.keccak(a), i.push(a);
          else if (n[o.type] !== void 0)
            s.push("bytes32"), a = de.keccak(this.encodeData(o.type, a, n, r)), i.push(a);
          else {
            if (o.type.lastIndexOf("]") === o.type.length - 1)
              throw new Error("Arrays currently unimplemented in encodeData");
            s.push(o.type), i.push(a);
          }
      }
    return bt.rawEncode(s, i);
  },
  /**
   * Encodes the type of an object by encoding a comma delimited list of its members
   *
   * @param {string} primaryType - Root type to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of the type of an object
   */
  encodeType(e, t) {
    let n = "", r = this.findTypeDependencies(e, t).filter((s) => s !== e);
    r = [e].concat(r.sort());
    for (const s of r) {
      if (!t[s])
        throw new Error("No type definition specified: " + s);
      n += s + "(" + t[s].map(({ name: o, type: a }) => a + " " + o).join(",") + ")";
    }
    return n;
  },
  /**
   * Finds all types within a type defintion object
   *
   * @param {string} primaryType - Root type
   * @param {Object} types - Type definitions
   * @param {Array} results - current set of accumulated types
   * @returns {Array} - Set of all types found in the type definition
   */
  findTypeDependencies(e, t, n = []) {
    if (e = e.match(/^\w*/)[0], n.includes(e) || t[e] === void 0)
      return n;
    n.push(e);
    for (const r of t[e])
      for (const s of this.findTypeDependencies(r.type, t, n))
        !n.includes(s) && n.push(s);
    return n;
  },
  /**
   * Hashes an object
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to hash
   * @param {Object} types - Type definitions
   * @returns {Buffer} - Hash of an object
   */
  hashStruct(e, t, n, r = !0) {
    return de.keccak(this.encodeData(e, t, n, r));
  },
  /**
   * Hashes the type of an object
   *
   * @param {string} primaryType - Root type to hash
   * @param {Object} types - Type definitions
   * @returns {string} - Hash of an object
   */
  hashType(e, t) {
    return de.keccak(this.encodeType(e, t));
  },
  /**
   * Removes properties from a message object that are not defined per EIP-712
   *
   * @param {Object} data - typed message object
   * @returns {Object} - typed message object with only allowed fields
   */
  sanitizeData(e) {
    const t = {};
    for (const n in $o.properties)
      e[n] && (t[n] = e[n]);
    return t.types && (t.types = Object.assign({ EIP712Domain: [] }, t.types)), t;
  },
  /**
   * Returns the hash of a typed message as per EIP-712 for signing
   *
   * @param {Object} typedData - Types message data to sign
   * @returns {string} - sha3 hash for signing
   */
  hash(e, t = !0) {
    const n = this.sanitizeData(e), r = [R.from("1901", "hex")];
    return r.push(this.hashStruct("EIP712Domain", n.domain, n.types, t)), n.primaryType !== "EIP712Domain" && r.push(this.hashStruct(n.primaryType, n.message, n.types, t)), de.keccak(R.concat(r));
  }
};
var Vl = {
  TYPED_MESSAGE_SCHEMA: $o,
  TypedDataUtils: Jr,
  hashForSignTypedDataLegacy: function(e) {
    return Jl(e.data);
  },
  hashForSignTypedData_v3: function(e) {
    return Jr.hash(e.data, !1);
  },
  hashForSignTypedData_v4: function(e) {
    return Jr.hash(e.data);
  }
};
function Jl(e) {
  const t = new Error("Expect argument to be non-empty array");
  if (typeof e != "object" || !e.length) throw t;
  const n = e.map(function(i) {
    return i.type === "bytes" ? de.toBuffer(i.value) : i.value;
  }), r = e.map(function(i) {
    return i.type;
  }), s = e.map(function(i) {
    if (!i.name) throw t;
    return i.type + " " + i.name;
  });
  return bt.soliditySHA3(
    ["bytes32", "bytes32"],
    [
      bt.soliditySHA3(new Array(e.length).fill("string"), s),
      bt.soliditySHA3(r, n)
    ]
  );
}
var nt = {};
Object.defineProperty(nt, "__esModule", { value: !0 });
nt.filterFromParam = nt.FilterPolyfill = void 0;
const qe = $, Z = m, ql = 5 * 60 * 1e3, Le = {
  jsonrpc: "2.0",
  id: 0
};
class Zl {
  constructor(t) {
    this.logFilters = /* @__PURE__ */ new Map(), this.blockFilters = /* @__PURE__ */ new Set(), this.pendingTransactionFilters = /* @__PURE__ */ new Set(), this.cursors = /* @__PURE__ */ new Map(), this.timeouts = /* @__PURE__ */ new Map(), this.nextFilterId = (0, qe.IntNumber)(1), this.REQUEST_THROTTLE_INTERVAL = 1e3, this.lastFetchTimestamp = /* @__PURE__ */ new Date(0), this.resolvers = [], this.provider = t;
  }
  async newFilter(t) {
    const n = Ho(t), r = this.makeFilterId(), s = await this.setInitialCursorPosition(r, n.fromBlock);
    return this.logFilters.set(r, n), this.setFilterTimeout(r), (0, Z.hexStringFromIntNumber)(r);
  }
  async newBlockFilter() {
    const t = this.makeFilterId(), n = await this.setInitialCursorPosition(t, "latest");
    return this.blockFilters.add(t), this.setFilterTimeout(t), (0, Z.hexStringFromIntNumber)(t);
  }
  async newPendingTransactionFilter() {
    const t = this.makeFilterId(), n = await this.setInitialCursorPosition(t, "latest");
    return this.pendingTransactionFilters.add(t), this.setFilterTimeout(t), (0, Z.hexStringFromIntNumber)(t);
  }
  uninstallFilter(t) {
    const n = (0, Z.intNumberFromHexString)(t);
    return this.deleteFilter(n), !0;
  }
  getFilterChanges(t) {
    const n = (0, Z.intNumberFromHexString)(t);
    return this.timeouts.has(n) && this.setFilterTimeout(n), this.logFilters.has(n) ? this.getLogFilterChanges(n) : this.blockFilters.has(n) ? this.getBlockFilterChanges(n) : this.pendingTransactionFilters.has(n) ? this.getPendingTransactionFilterChanges(n) : Promise.resolve(Jt());
  }
  async getFilterLogs(t) {
    const n = (0, Z.intNumberFromHexString)(t), r = this.logFilters.get(n);
    return r ? this.sendAsyncPromise(Object.assign(Object.assign({}, Le), { method: "eth_getLogs", params: [Mi(r)] })) : Jt();
  }
  makeFilterId() {
    return (0, qe.IntNumber)(++this.nextFilterId);
  }
  sendAsyncPromise(t) {
    return new Promise((n, r) => {
      this.provider.sendAsync(t, (s, i) => {
        if (s)
          return r(s);
        if (Array.isArray(i) || i == null)
          return r(new Error(`unexpected response received: ${JSON.stringify(i)}`));
        n(i);
      });
    });
  }
  deleteFilter(t) {
    this.logFilters.delete(t), this.blockFilters.delete(t), this.pendingTransactionFilters.delete(t), this.cursors.delete(t), this.timeouts.delete(t);
  }
  async getLogFilterChanges(t) {
    const n = this.logFilters.get(t), r = this.cursors.get(t);
    if (!r || !n)
      return Jt();
    const s = await this.getCurrentBlockHeight(), i = n.toBlock === "latest" ? s : n.toBlock;
    if (r > s || r > Number(n.toBlock))
      return qt();
    const o = await this.sendAsyncPromise(Object.assign(Object.assign({}, Le), { method: "eth_getLogs", params: [
      Mi(Object.assign(Object.assign({}, n), { fromBlock: r, toBlock: i }))
    ] }));
    if (Array.isArray(o.result)) {
      const a = o.result.map((l) => (0, Z.intNumberFromHexString)(l.blockNumber || "0x0")), c = Math.max(...a);
      if (c && c > r) {
        const l = (0, qe.IntNumber)(c + 1);
        this.cursors.set(t, l);
      }
    }
    return o;
  }
  async getBlockFilterChanges(t) {
    const n = this.cursors.get(t);
    if (!n)
      return Jt();
    const r = await this.getCurrentBlockHeight();
    if (n > r)
      return qt();
    const s = (await Promise.all(
      // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
      (0, Z.range)(n, r + 1).map((o) => this.getBlockHashByNumber((0, qe.IntNumber)(o)))
    )).filter((o) => !!o), i = (0, qe.IntNumber)(n + s.length);
    return this.cursors.set(t, i), Object.assign(Object.assign({}, Le), { result: s });
  }
  async getPendingTransactionFilterChanges(t) {
    return Promise.resolve(qt());
  }
  async setInitialCursorPosition(t, n) {
    const r = await this.getCurrentBlockHeight(), s = typeof n == "number" && n > r ? n : r;
    return this.cursors.set(t, s), s;
  }
  setFilterTimeout(t) {
    const n = this.timeouts.get(t);
    n && window.clearTimeout(n);
    const r = window.setTimeout(() => {
      this.deleteFilter(t);
    }, ql);
    this.timeouts.set(t, r);
  }
  // throttle eth_blockNumber requests
  async getCurrentBlockHeight() {
    const t = /* @__PURE__ */ new Date();
    if (t.getTime() - this.lastFetchTimestamp.getTime() > this.REQUEST_THROTTLE_INTERVAL) {
      this.lastFetchTimestamp = t;
      const n = await this._getCurrentBlockHeight();
      this.currentBlockHeight = n, this.resolvers.forEach((r) => r(n)), this.resolvers = [];
    }
    return this.currentBlockHeight ? this.currentBlockHeight : new Promise((n) => this.resolvers.push(n));
  }
  async _getCurrentBlockHeight() {
    const { result: t } = await this.sendAsyncPromise(Object.assign(Object.assign({}, Le), { method: "eth_blockNumber", params: [] }));
    return (0, Z.intNumberFromHexString)((0, Z.ensureHexString)(t));
  }
  async getBlockHashByNumber(t) {
    const n = await this.sendAsyncPromise(Object.assign(Object.assign({}, Le), { method: "eth_getBlockByNumber", params: [(0, Z.hexStringFromIntNumber)(t), !1] }));
    return n.result && typeof n.result.hash == "string" ? (0, Z.ensureHexString)(n.result.hash) : null;
  }
}
nt.FilterPolyfill = Zl;
function Ho(e) {
  return {
    fromBlock: Ai(e.fromBlock),
    toBlock: Ai(e.toBlock),
    addresses: e.address === void 0 ? null : Array.isArray(e.address) ? e.address : [e.address],
    topics: e.topics || []
  };
}
nt.filterFromParam = Ho;
function Mi(e) {
  const t = {
    fromBlock: Pi(e.fromBlock),
    toBlock: Pi(e.toBlock),
    topics: e.topics
  };
  return e.addresses !== null && (t.address = e.addresses), t;
}
function Ai(e) {
  if (e === void 0 || e === "latest" || e === "pending")
    return "latest";
  if (e === "earliest")
    return (0, qe.IntNumber)(0);
  if ((0, Z.isHexString)(e))
    return (0, Z.intNumberFromHexString)(e);
  throw new Error(`Invalid block option: ${String(e)}`);
}
function Pi(e) {
  return e === "latest" ? e : (0, Z.hexStringFromIntNumber)(e);
}
function Jt() {
  return Object.assign(Object.assign({}, Le), { error: { code: -32e3, message: "filter not found" } });
}
function qt() {
  return Object.assign(Object.assign({}, Le), { result: [] });
}
var In = {}, Uo = {}, Mn = {}, ps = Gl;
function Gl(e) {
  e = e || {};
  var t = e.max || Number.MAX_SAFE_INTEGER, n = typeof e.start < "u" ? e.start : Math.floor(Math.random() * t);
  return function() {
    return n = n % t, n++;
  };
}
const Ni = (e, t) => function() {
  const n = t.promiseModule, r = new Array(arguments.length);
  for (let s = 0; s < arguments.length; s++)
    r[s] = arguments[s];
  return new n((s, i) => {
    t.errorFirst ? r.push(function(o, a) {
      if (t.multiArgs) {
        const c = new Array(arguments.length - 1);
        for (let l = 1; l < arguments.length; l++)
          c[l - 1] = arguments[l];
        o ? (c.unshift(o), i(c)) : s(c);
      } else o ? i(o) : s(a);
    }) : r.push(function(o) {
      if (t.multiArgs) {
        const a = new Array(arguments.length - 1);
        for (let c = 0; c < arguments.length; c++)
          a[c] = arguments[c];
        s(a);
      } else
        s(o);
    }), e.apply(this, r);
  });
};
var Ql = (e, t) => {
  t = Object.assign({
    exclude: [/.+(Sync|Stream)$/],
    errorFirst: !0,
    promiseModule: Promise
  }, t);
  const n = (s) => {
    const i = (o) => typeof o == "string" ? s === o : o.test(s);
    return t.include ? t.include.some(i) : !t.exclude.some(i);
  };
  let r;
  typeof e == "function" ? r = function() {
    return t.excludeMain ? e.apply(this, arguments) : Ni(e, t).apply(this, arguments);
  } : r = Object.create(Object.getPrototypeOf(e));
  for (const s in e) {
    const i = e[s];
    r[s] = typeof i == "function" && n(s) ? Ni(i, t) : i;
  }
  return r;
}, Nt = {}, Tt = {};
Object.defineProperty(Tt, "__esModule", { value: !0 });
const Kl = so;
function Ti(e, t, n) {
  try {
    Reflect.apply(e, t, n);
  } catch (r) {
    setTimeout(() => {
      throw r;
    });
  }
}
function Yl(e) {
  const t = e.length, n = new Array(t);
  for (let r = 0; r < t; r += 1)
    n[r] = e[r];
  return n;
}
let Xl = class extends Kl.EventEmitter {
  emit(t, ...n) {
    let r = t === "error";
    const s = this._events;
    if (s !== void 0)
      r = r && s.error === void 0;
    else if (!r)
      return !1;
    if (r) {
      let o;
      if (n.length > 0 && ([o] = n), o instanceof Error)
        throw o;
      const a = new Error(`Unhandled error.${o ? ` (${o.message})` : ""}`);
      throw a.context = o, a;
    }
    const i = s[t];
    if (i === void 0)
      return !1;
    if (typeof i == "function")
      Ti(i, this, n);
    else {
      const o = i.length, a = Yl(i);
      for (let c = 0; c < o; c += 1)
        Ti(a[c], this, n);
    }
    return !0;
  }
};
Tt.default = Xl;
var ed = v && v.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Nt, "__esModule", { value: !0 });
Nt.BaseBlockTracker = void 0;
const td = ed(Tt), nd = 1e3, rd = (e, t) => e + t, Li = ["sync", "latest"];
class sd extends td.default {
  constructor(t) {
    super(), this._blockResetDuration = t.blockResetDuration || 20 * nd, this._usePastBlocks = t.usePastBlocks || !1, this._currentBlock = null, this._isRunning = !1, this._onNewListener = this._onNewListener.bind(this), this._onRemoveListener = this._onRemoveListener.bind(this), this._resetCurrentBlock = this._resetCurrentBlock.bind(this), this._setupInternalEvents();
  }
  async destroy() {
    this._cancelBlockResetTimeout(), await this._maybeEnd(), super.removeAllListeners();
  }
  isRunning() {
    return this._isRunning;
  }
  getCurrentBlock() {
    return this._currentBlock;
  }
  async getLatestBlock() {
    return this._currentBlock ? this._currentBlock : await new Promise((n) => this.once("latest", n));
  }
  // dont allow module consumer to remove our internal event listeners
  removeAllListeners(t) {
    return t ? super.removeAllListeners(t) : super.removeAllListeners(), this._setupInternalEvents(), this._onRemoveListener(), this;
  }
  _setupInternalEvents() {
    this.removeListener("newListener", this._onNewListener), this.removeListener("removeListener", this._onRemoveListener), this.on("newListener", this._onNewListener), this.on("removeListener", this._onRemoveListener);
  }
  _onNewListener(t) {
    Li.includes(t) && this._maybeStart();
  }
  _onRemoveListener() {
    this._getBlockTrackerEventCount() > 0 || this._maybeEnd();
  }
  async _maybeStart() {
    this._isRunning || (this._isRunning = !0, this._cancelBlockResetTimeout(), await this._start(), this.emit("_started"));
  }
  async _maybeEnd() {
    this._isRunning && (this._isRunning = !1, this._setupBlockResetTimeout(), await this._end(), this.emit("_ended"));
  }
  _getBlockTrackerEventCount() {
    return Li.map((t) => this.listenerCount(t)).reduce(rd);
  }
  _shouldUseNewBlock(t) {
    const n = this._currentBlock;
    if (!n)
      return !0;
    const r = xi(t), s = xi(n);
    return this._usePastBlocks && r < s || r > s;
  }
  _newPotentialLatest(t) {
    this._shouldUseNewBlock(t) && this._setCurrentBlock(t);
  }
  _setCurrentBlock(t) {
    const n = this._currentBlock;
    this._currentBlock = t, this.emit("latest", t), this.emit("sync", { oldBlock: n, newBlock: t });
  }
  _setupBlockResetTimeout() {
    this._cancelBlockResetTimeout(), this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration), this._blockResetTimeout.unref && this._blockResetTimeout.unref();
  }
  _cancelBlockResetTimeout() {
    this._blockResetTimeout && clearTimeout(this._blockResetTimeout);
  }
  _resetCurrentBlock() {
    this._currentBlock = null;
  }
}
Nt.BaseBlockTracker = sd;
function xi(e) {
  return Number.parseInt(e, 16);
}
var Wo = {}, zo = {}, J = {};
class Vo extends TypeError {
  constructor(t, n) {
    let r;
    const { message: s, explanation: i, ...o } = t, { path: a } = t, c = a.length === 0 ? s : `At path: ${a.join(".")} -- ${s}`;
    super(i ?? c), i != null && (this.cause = c), Object.assign(this, o), this.name = this.constructor.name, this.failures = () => r ?? (r = [t, ...n()]);
  }
}
function id(e) {
  return ce(e) && typeof e[Symbol.iterator] == "function";
}
function ce(e) {
  return typeof e == "object" && e != null;
}
function Oi(e) {
  if (Object.prototype.toString.call(e) !== "[object Object]")
    return !1;
  const t = Object.getPrototypeOf(e);
  return t === null || t === Object.prototype;
}
function H(e) {
  return typeof e == "symbol" ? e.toString() : typeof e == "string" ? JSON.stringify(e) : `${e}`;
}
function od(e) {
  const { done: t, value: n } = e.next();
  return t ? void 0 : n;
}
function ad(e, t, n, r) {
  if (e === !0)
    return;
  e === !1 ? e = {} : typeof e == "string" && (e = { message: e });
  const { path: s, branch: i } = t, { type: o } = n, { refinement: a, message: c = `Expected a value of type \`${o}\`${a ? ` with refinement \`${a}\`` : ""}, but received: \`${H(r)}\`` } = e;
  return {
    value: r,
    type: o,
    refinement: a,
    key: s[s.length - 1],
    path: s,
    branch: i,
    ...e,
    message: c
  };
}
function* Xr(e, t, n, r) {
  id(e) || (e = [e]);
  for (const s of e) {
    const i = ad(s, t, n, r);
    i && (yield i);
  }
}
function* ms(e, t, n = {}) {
  const { path: r = [], branch: s = [e], coerce: i = !1, mask: o = !1 } = n, a = { path: r, branch: s };
  if (i && (e = t.coercer(e, a), o && t.type !== "type" && ce(t.schema) && ce(e) && !Array.isArray(e)))
    for (const l in e)
      t.schema[l] === void 0 && delete e[l];
  let c = "valid";
  for (const l of t.validator(e, a))
    l.explanation = n.message, c = "not_valid", yield [l, void 0];
  for (let [l, d, h] of t.entries(e, a)) {
    const u = ms(d, h, {
      path: l === void 0 ? r : [...r, l],
      branch: l === void 0 ? s : [...s, d],
      coerce: i,
      mask: o,
      message: n.message
    });
    for (const f of u)
      f[0] ? (c = f[0].refinement != null ? "not_refined" : "not_valid", yield [f[0], void 0]) : i && (d = f[1], l === void 0 ? e = d : e instanceof Map ? e.set(l, d) : e instanceof Set ? e.add(d) : ce(e) && (d !== void 0 || l in e) && (e[l] = d));
  }
  if (c !== "not_valid")
    for (const l of t.refiner(e, a))
      l.explanation = n.message, c = "not_refined", yield [l, void 0];
  c === "valid" && (yield [void 0, e]);
}
class B {
  constructor(t) {
    const { type: n, schema: r, validator: s, refiner: i, coercer: o = (c) => c, entries: a = function* () {
    } } = t;
    this.type = n, this.schema = r, this.entries = a, this.coercer = o, s ? this.validator = (c, l) => {
      const d = s(c, l);
      return Xr(d, l, this, c);
    } : this.validator = () => [], i ? this.refiner = (c, l) => {
      const d = i(c, l);
      return Xr(d, l, this, c);
    } : this.refiner = () => [];
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(t, n) {
    return Jo(t, this, n);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(t, n) {
    return qo(t, this, n);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(t) {
    return bs(t, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema.
   */
  mask(t, n) {
    return Zo(t, this, n);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `withCoercion` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful.
   */
  validate(t, n = {}) {
    return dt(t, this, n);
  }
}
function Jo(e, t, n) {
  const r = dt(e, t, { message: n });
  if (r[0])
    throw r[0];
}
function qo(e, t, n) {
  const r = dt(e, t, { coerce: !0, message: n });
  if (r[0])
    throw r[0];
  return r[1];
}
function Zo(e, t, n) {
  const r = dt(e, t, { coerce: !0, mask: !0, message: n });
  if (r[0])
    throw r[0];
  return r[1];
}
function bs(e, t) {
  return !dt(e, t)[0];
}
function dt(e, t, n = {}) {
  const r = ms(e, t, n), s = od(r);
  return s[0] ? [new Vo(s[0], function* () {
    for (const o of r)
      o[0] && (yield o[0]);
  }), void 0] : [void 0, s[1]];
}
function cd(...e) {
  const t = e[0].type === "type", n = e.map((s) => s.schema), r = Object.assign({}, ...n);
  return t ? ws(r) : Lt(r);
}
function Y(e, t) {
  return new B({ type: e, schema: null, validator: t });
}
function ld(e, t) {
  return new B({
    ...e,
    refiner: (n, r) => n === void 0 || e.refiner(n, r),
    validator(n, r) {
      return n === void 0 ? !0 : (t(n, r), e.validator(n, r));
    }
  });
}
function dd(e) {
  return new B({
    type: "dynamic",
    schema: null,
    *entries(t, n) {
      yield* e(t, n).entries(t, n);
    },
    validator(t, n) {
      return e(t, n).validator(t, n);
    },
    coercer(t, n) {
      return e(t, n).coercer(t, n);
    },
    refiner(t, n) {
      return e(t, n).refiner(t, n);
    }
  });
}
function ud(e) {
  let t;
  return new B({
    type: "lazy",
    schema: null,
    *entries(n, r) {
      t ?? (t = e()), yield* t.entries(n, r);
    },
    validator(n, r) {
      return t ?? (t = e()), t.validator(n, r);
    },
    coercer(n, r) {
      return t ?? (t = e()), t.coercer(n, r);
    },
    refiner(n, r) {
      return t ?? (t = e()), t.refiner(n, r);
    }
  });
}
function hd(e, t) {
  const { schema: n } = e, r = { ...n };
  for (const s of t)
    delete r[s];
  switch (e.type) {
    case "type":
      return ws(r);
    default:
      return Lt(r);
  }
}
function fd(e) {
  const t = e instanceof B ? { ...e.schema } : { ...e };
  for (const n in t)
    t[n] = Go(t[n]);
  return Lt(t);
}
function gd(e, t) {
  const { schema: n } = e, r = {};
  for (const s of t)
    r[s] = n[s];
  return Lt(r);
}
function pd(e, t) {
  return Y(e, t);
}
function md() {
  return Y("any", () => !0);
}
function bd(e) {
  return new B({
    type: "array",
    schema: e,
    *entries(t) {
      if (e && Array.isArray(t))
        for (const [n, r] of t.entries())
          yield [n, r, e];
    },
    coercer(t) {
      return Array.isArray(t) ? t.slice() : t;
    },
    validator(t) {
      return Array.isArray(t) || `Expected an array value, but received: ${H(t)}`;
    }
  });
}
function yd() {
  return Y("bigint", (e) => typeof e == "bigint");
}
function wd() {
  return Y("boolean", (e) => typeof e == "boolean");
}
function _d() {
  return Y("date", (e) => e instanceof Date && !isNaN(e.getTime()) || `Expected a valid \`Date\` object, but received: ${H(e)}`);
}
function vd(e) {
  const t = {}, n = e.map((r) => H(r)).join();
  for (const r of e)
    t[r] = r;
  return new B({
    type: "enums",
    schema: t,
    validator(r) {
      return e.includes(r) || `Expected one of \`${n}\`, but received: ${H(r)}`;
    }
  });
}
function Ed() {
  return Y("func", (e) => typeof e == "function" || `Expected a function, but received: ${H(e)}`);
}
function kd(e) {
  return Y("instance", (t) => t instanceof e || `Expected a \`${e.name}\` instance, but received: ${H(t)}`);
}
function Cd() {
  return Y("integer", (e) => typeof e == "number" && !isNaN(e) && Number.isInteger(e) || `Expected an integer, but received: ${H(e)}`);
}
function Sd(e) {
  return new B({
    type: "intersection",
    schema: null,
    *entries(t, n) {
      for (const r of e)
        yield* r.entries(t, n);
    },
    *validator(t, n) {
      for (const r of e)
        yield* r.validator(t, n);
    },
    *refiner(t, n) {
      for (const r of e)
        yield* r.refiner(t, n);
    }
  });
}
function Rd(e) {
  const t = H(e), n = typeof e;
  return new B({
    type: "literal",
    schema: n === "string" || n === "number" || n === "boolean" ? e : null,
    validator(r) {
      return r === e || `Expected the literal \`${t}\`, but received: ${H(r)}`;
    }
  });
}
function Id(e, t) {
  return new B({
    type: "map",
    schema: null,
    *entries(n) {
      if (e && t && n instanceof Map)
        for (const [r, s] of n.entries())
          yield [r, r, e], yield [r, s, t];
    },
    coercer(n) {
      return n instanceof Map ? new Map(n) : n;
    },
    validator(n) {
      return n instanceof Map || `Expected a \`Map\` object, but received: ${H(n)}`;
    }
  });
}
function ys() {
  return Y("never", () => !1);
}
function Md(e) {
  return new B({
    ...e,
    validator: (t, n) => t === null || e.validator(t, n),
    refiner: (t, n) => t === null || e.refiner(t, n)
  });
}
function Ad() {
  return Y("number", (e) => typeof e == "number" && !isNaN(e) || `Expected a number, but received: ${H(e)}`);
}
function Lt(e) {
  const t = e ? Object.keys(e) : [], n = ys();
  return new B({
    type: "object",
    schema: e || null,
    *entries(r) {
      if (e && ce(r)) {
        const s = new Set(Object.keys(r));
        for (const i of t)
          s.delete(i), yield [i, r[i], e[i]];
        for (const i of s)
          yield [i, r[i], n];
      }
    },
    validator(r) {
      return ce(r) || `Expected an object, but received: ${H(r)}`;
    },
    coercer(r) {
      return ce(r) ? { ...r } : r;
    }
  });
}
function Go(e) {
  return new B({
    ...e,
    validator: (t, n) => t === void 0 || e.validator(t, n),
    refiner: (t, n) => t === void 0 || e.refiner(t, n)
  });
}
function Pd(e, t) {
  return new B({
    type: "record",
    schema: null,
    *entries(n) {
      if (ce(n))
        for (const r in n) {
          const s = n[r];
          yield [r, r, e], yield [r, s, t];
        }
    },
    validator(n) {
      return ce(n) || `Expected an object, but received: ${H(n)}`;
    }
  });
}
function Nd() {
  return Y("regexp", (e) => e instanceof RegExp);
}
function Td(e) {
  return new B({
    type: "set",
    schema: null,
    *entries(t) {
      if (e && t instanceof Set)
        for (const n of t)
          yield [n, n, e];
    },
    coercer(t) {
      return t instanceof Set ? new Set(t) : t;
    },
    validator(t) {
      return t instanceof Set || `Expected a \`Set\` object, but received: ${H(t)}`;
    }
  });
}
function Qo() {
  return Y("string", (e) => typeof e == "string" || `Expected a string, but received: ${H(e)}`);
}
function Ld(e) {
  const t = ys();
  return new B({
    type: "tuple",
    schema: null,
    *entries(n) {
      if (Array.isArray(n)) {
        const r = Math.max(e.length, n.length);
        for (let s = 0; s < r; s++)
          yield [s, n[s], e[s] || t];
      }
    },
    validator(n) {
      return Array.isArray(n) || `Expected an array, but received: ${H(n)}`;
    }
  });
}
function ws(e) {
  const t = Object.keys(e);
  return new B({
    type: "type",
    schema: e,
    *entries(n) {
      if (ce(n))
        for (const r of t)
          yield [r, n[r], e[r]];
    },
    validator(n) {
      return ce(n) || `Expected an object, but received: ${H(n)}`;
    },
    coercer(n) {
      return ce(n) ? { ...n } : n;
    }
  });
}
function xd(e) {
  const t = e.map((n) => n.type).join(" | ");
  return new B({
    type: "union",
    schema: null,
    coercer(n) {
      for (const r of e) {
        const [s, i] = r.validate(n, { coerce: !0 });
        if (!s)
          return i;
      }
      return n;
    },
    validator(n, r) {
      const s = [];
      for (const i of e) {
        const [...o] = ms(n, i, r), [a] = o;
        if (a[0])
          for (const [c] of o)
            c && s.push(c);
        else
          return [];
      }
      return [
        `Expected the value to satisfy a union of \`${t}\`, but received: ${H(n)}`,
        ...s
      ];
    }
  });
}
function Ko() {
  return Y("unknown", () => !0);
}
function _s(e, t, n) {
  return new B({
    ...e,
    coercer: (r, s) => bs(r, t) ? e.coercer(n(r, s), s) : e.coercer(r, s)
  });
}
function Od(e, t, n = {}) {
  return _s(e, Ko(), (r) => {
    const s = typeof t == "function" ? t() : t;
    if (r === void 0)
      return s;
    if (!n.strict && Oi(r) && Oi(s)) {
      const i = { ...r };
      let o = !1;
      for (const a in s)
        i[a] === void 0 && (i[a] = s[a], o = !0);
      if (o)
        return i;
    }
    return r;
  });
}
function Bd(e) {
  return _s(e, Qo(), (t) => t.trim());
}
function Fd(e) {
  return $e(e, "empty", (t) => {
    const n = Yo(t);
    return n === 0 || `Expected an empty ${e.type} but received one with a size of \`${n}\``;
  });
}
function Yo(e) {
  return e instanceof Map || e instanceof Set ? e.size : e.length;
}
function jd(e, t, n = {}) {
  const { exclusive: r } = n;
  return $e(e, "max", (s) => r ? s < t : s <= t || `Expected a ${e.type} less than ${r ? "" : "or equal to "}${t} but received \`${s}\``);
}
function Dd(e, t, n = {}) {
  const { exclusive: r } = n;
  return $e(e, "min", (s) => r ? s > t : s >= t || `Expected a ${e.type} greater than ${r ? "" : "or equal to "}${t} but received \`${s}\``);
}
function $d(e) {
  return $e(e, "nonempty", (t) => Yo(t) > 0 || `Expected a nonempty ${e.type} but received an empty one`);
}
function Hd(e, t) {
  return $e(e, "pattern", (n) => t.test(n) || `Expected a ${e.type} matching \`/${t.source}/\` but received "${n}"`);
}
function Ud(e, t, n = t) {
  const r = `Expected a ${e.type}`, s = t === n ? `of \`${t}\`` : `between \`${t}\` and \`${n}\``;
  return $e(e, "size", (i) => {
    if (typeof i == "number" || i instanceof Date)
      return t <= i && i <= n || `${r} ${s} but received \`${i}\``;
    if (i instanceof Map || i instanceof Set) {
      const { size: o } = i;
      return t <= o && o <= n || `${r} with a size ${s} but received one with a size of \`${o}\``;
    } else {
      const { length: o } = i;
      return t <= o && o <= n || `${r} with a length ${s} but received one with a length of \`${o}\``;
    }
  });
}
function $e(e, t, n) {
  return new B({
    ...e,
    *refiner(r, s) {
      yield* e.refiner(r, s);
      const i = n(r, s), o = Xr(i, s, e, r);
      for (const a of o)
        yield { ...a, refinement: t };
    }
  });
}
const Wd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Struct: B,
  StructError: Vo,
  any: md,
  array: bd,
  assert: Jo,
  assign: cd,
  bigint: yd,
  boolean: wd,
  coerce: _s,
  create: qo,
  date: _d,
  defaulted: Od,
  define: Y,
  deprecated: ld,
  dynamic: dd,
  empty: Fd,
  enums: vd,
  func: Ed,
  instance: kd,
  integer: Cd,
  intersection: Sd,
  is: bs,
  lazy: ud,
  literal: Rd,
  map: Id,
  mask: Zo,
  max: jd,
  min: Dd,
  never: ys,
  nonempty: $d,
  nullable: Md,
  number: Ad,
  object: Lt,
  omit: hd,
  optional: Go,
  partial: fd,
  pattern: Hd,
  pick: gd,
  record: Pd,
  refine: $e,
  regexp: Nd,
  set: Td,
  size: Ud,
  string: Qo,
  struct: pd,
  trimmed: Bd,
  tuple: Ld,
  type: ws,
  union: xd,
  unknown: Ko,
  validate: dt
}, Symbol.toStringTag, { value: "Module" })), He = /* @__PURE__ */ ss(Wd);
Object.defineProperty(J, "__esModule", { value: !0 });
J.assertExhaustive = J.assertStruct = J.assert = J.AssertionError = void 0;
const zd = He;
function Vd(e) {
  return typeof e == "object" && e !== null && "message" in e;
}
function Jd(e) {
  var t, n;
  return typeof ((n = (t = e == null ? void 0 : e.prototype) === null || t === void 0 ? void 0 : t.constructor) === null || n === void 0 ? void 0 : n.name) == "string";
}
function qd(e) {
  const t = Vd(e) ? e.message : String(e);
  return t.endsWith(".") ? t.slice(0, -1) : t;
}
function Xo(e, t) {
  return Jd(e) ? new e({
    message: t
  }) : e({
    message: t
  });
}
class vs extends Error {
  constructor(t) {
    super(t.message), this.code = "ERR_ASSERTION";
  }
}
J.AssertionError = vs;
function Zd(e, t = "Assertion failed.", n = vs) {
  if (!e)
    throw t instanceof Error ? t : Xo(n, t);
}
J.assert = Zd;
function Gd(e, t, n = "Assertion failed", r = vs) {
  try {
    (0, zd.assert)(e, t);
  } catch (s) {
    throw Xo(r, `${n}: ${qd(s)}.`);
  }
}
J.assertStruct = Gd;
function Qd(e) {
  throw new Error("Invalid branch reached. Should be detected during compilation.");
}
J.assertExhaustive = Qd;
var xt = {};
Object.defineProperty(xt, "__esModule", { value: !0 });
xt.base64 = void 0;
const Kd = He, Yd = J, Xd = (e, t = {}) => {
  var n, r;
  const s = (n = t.paddingRequired) !== null && n !== void 0 ? n : !1, i = (r = t.characterSet) !== null && r !== void 0 ? r : "base64";
  let o;
  i === "base64" ? o = String.raw`[A-Za-z0-9+\/]` : ((0, Yd.assert)(i === "base64url"), o = String.raw`[-_A-Za-z0-9]`);
  let a;
  return s ? a = new RegExp(`^(?:${o}{4})*(?:${o}{3}=|${o}{2}==)?$`, "u") : a = new RegExp(`^(?:${o}{4})*(?:${o}{2,3}|${o}{3}=|${o}{2}==)?$`, "u"), (0, Kd.pattern)(e, a);
};
xt.base64 = Xd;
var N = {}, Ot = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.remove0x = e.add0x = e.assertIsStrictHexString = e.assertIsHexString = e.isStrictHexString = e.isHexString = e.StrictHexStruct = e.HexStruct = void 0;
  const t = He, n = J;
  e.HexStruct = (0, t.pattern)((0, t.string)(), /^(?:0x)?[0-9a-f]+$/iu), e.StrictHexStruct = (0, t.pattern)((0, t.string)(), /^0x[0-9a-f]+$/iu);
  function r(l) {
    return (0, t.is)(l, e.HexStruct);
  }
  e.isHexString = r;
  function s(l) {
    return (0, t.is)(l, e.StrictHexStruct);
  }
  e.isStrictHexString = s;
  function i(l) {
    (0, n.assert)(r(l), "Value must be a hexadecimal string.");
  }
  e.assertIsHexString = i;
  function o(l) {
    (0, n.assert)(s(l), 'Value must be a hexadecimal string, starting with "0x".');
  }
  e.assertIsStrictHexString = o;
  function a(l) {
    return l.startsWith("0x") ? l : l.startsWith("0X") ? `0x${l.substring(2)}` : `0x${l}`;
  }
  e.add0x = a;
  function c(l) {
    return l.startsWith("0x") || l.startsWith("0X") ? l.substring(2) : l;
  }
  e.remove0x = c;
})(Ot);
Object.defineProperty(N, "__esModule", { value: !0 });
N.createDataView = N.concatBytes = N.valueToBytes = N.stringToBytes = N.numberToBytes = N.signedBigIntToBytes = N.bigIntToBytes = N.hexToBytes = N.bytesToString = N.bytesToNumber = N.bytesToSignedBigInt = N.bytesToBigInt = N.bytesToHex = N.assertIsBytes = N.isBytes = void 0;
const ne = J, es = Ot, Bi = 48, Fi = 58, ji = 87;
function eu() {
  const e = [];
  return () => {
    if (e.length === 0)
      for (let t = 0; t < 256; t++)
        e.push(t.toString(16).padStart(2, "0"));
    return e;
  };
}
const tu = eu();
function Es(e) {
  return e instanceof Uint8Array;
}
N.isBytes = Es;
function ut(e) {
  (0, ne.assert)(Es(e), "Value must be a Uint8Array.");
}
N.assertIsBytes = ut;
function ea(e) {
  if (ut(e), e.length === 0)
    return "0x";
  const t = tu(), n = new Array(e.length);
  for (let r = 0; r < e.length; r++)
    n[r] = t[e[r]];
  return (0, es.add0x)(n.join(""));
}
N.bytesToHex = ea;
function ta(e) {
  ut(e);
  const t = ea(e);
  return BigInt(t);
}
N.bytesToBigInt = ta;
function nu(e) {
  ut(e);
  let t = BigInt(0);
  for (const n of e)
    t = (t << BigInt(8)) + BigInt(n);
  return BigInt.asIntN(e.length * 8, t);
}
N.bytesToSignedBigInt = nu;
function ru(e) {
  ut(e);
  const t = ta(e);
  return (0, ne.assert)(t <= BigInt(Number.MAX_SAFE_INTEGER), "Number is not a safe integer. Use `bytesToBigInt` instead."), Number(t);
}
N.bytesToNumber = ru;
function su(e) {
  return ut(e), new TextDecoder().decode(e);
}
N.bytesToString = su;
function An(e) {
  var t;
  if (((t = e == null ? void 0 : e.toLowerCase) === null || t === void 0 ? void 0 : t.call(e)) === "0x")
    return new Uint8Array();
  (0, es.assertIsHexString)(e);
  const n = (0, es.remove0x)(e).toLowerCase(), r = n.length % 2 === 0 ? n : `0${n}`, s = new Uint8Array(r.length / 2);
  for (let i = 0; i < s.length; i++) {
    const o = r.charCodeAt(i * 2), a = r.charCodeAt(i * 2 + 1), c = o - (o < Fi ? Bi : ji), l = a - (a < Fi ? Bi : ji);
    s[i] = c * 16 + l;
  }
  return s;
}
N.hexToBytes = An;
function na(e) {
  (0, ne.assert)(typeof e == "bigint", "Value must be a bigint."), (0, ne.assert)(e >= BigInt(0), "Value must be a non-negative bigint.");
  const t = e.toString(16);
  return An(t);
}
N.bigIntToBytes = na;
function iu(e, t) {
  (0, ne.assert)(t > 0);
  const n = e >> BigInt(31);
  return !((~e & n) + (e & ~n) >> BigInt(t * 8 + -1));
}
function ou(e, t) {
  (0, ne.assert)(typeof e == "bigint", "Value must be a bigint."), (0, ne.assert)(typeof t == "number", "Byte length must be a number."), (0, ne.assert)(t > 0, "Byte length must be greater than 0."), (0, ne.assert)(iu(e, t), "Byte length is too small to represent the given value.");
  let n = e;
  const r = new Uint8Array(t);
  for (let s = 0; s < r.length; s++)
    r[s] = Number(BigInt.asUintN(8, n)), n >>= BigInt(8);
  return r.reverse();
}
N.signedBigIntToBytes = ou;
function ra(e) {
  (0, ne.assert)(typeof e == "number", "Value must be a number."), (0, ne.assert)(e >= 0, "Value must be a non-negative number."), (0, ne.assert)(Number.isSafeInteger(e), "Value is not a safe integer. Use `bigIntToBytes` instead.");
  const t = e.toString(16);
  return An(t);
}
N.numberToBytes = ra;
function sa(e) {
  return (0, ne.assert)(typeof e == "string", "Value must be a string."), new TextEncoder().encode(e);
}
N.stringToBytes = sa;
function ia(e) {
  if (typeof e == "bigint")
    return na(e);
  if (typeof e == "number")
    return ra(e);
  if (typeof e == "string")
    return e.startsWith("0x") ? An(e) : sa(e);
  if (Es(e))
    return e;
  throw new TypeError(`Unsupported value type: "${typeof e}".`);
}
N.valueToBytes = ia;
function au(e) {
  const t = new Array(e.length);
  let n = 0;
  for (let s = 0; s < e.length; s++) {
    const i = ia(e[s]);
    t[s] = i, n += i.length;
  }
  const r = new Uint8Array(n);
  for (let s = 0, i = 0; s < t.length; s++)
    r.set(t[s], i), i += t[s].length;
  return r;
}
N.concatBytes = au;
function cu(e) {
  if (typeof R < "u" && e instanceof R) {
    const t = e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength);
    return new DataView(t);
  }
  return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
N.createDataView = cu;
var Pn = {};
Object.defineProperty(Pn, "__esModule", { value: !0 });
Pn.ChecksumStruct = void 0;
const Di = He, lu = xt;
Pn.ChecksumStruct = (0, Di.size)((0, lu.base64)((0, Di.string)(), { paddingRequired: !0 }), 44, 44);
var be = {};
Object.defineProperty(be, "__esModule", { value: !0 });
be.createHex = be.createBytes = be.createBigInt = be.createNumber = void 0;
const O = He, du = J, oa = N, Nn = Ot, aa = (0, O.union)([(0, O.number)(), (0, O.bigint)(), (0, O.string)(), Nn.StrictHexStruct]), uu = (0, O.coerce)((0, O.number)(), aa, Number), hu = (0, O.coerce)((0, O.bigint)(), aa, BigInt);
(0, O.union)([Nn.StrictHexStruct, (0, O.instance)(Uint8Array)]);
const fu = (0, O.coerce)((0, O.instance)(Uint8Array), (0, O.union)([Nn.StrictHexStruct]), oa.hexToBytes), gu = (0, O.coerce)(Nn.StrictHexStruct, (0, O.instance)(Uint8Array), oa.bytesToHex);
function pu(e) {
  try {
    const t = (0, O.create)(e, uu);
    return (0, du.assert)(Number.isFinite(t), `Expected a number-like value, got "${e}".`), t;
  } catch (t) {
    throw t instanceof O.StructError ? new Error(`Expected a number-like value, got "${e}".`) : t;
  }
}
be.createNumber = pu;
function mu(e) {
  try {
    return (0, O.create)(e, hu);
  } catch (t) {
    throw t instanceof O.StructError ? new Error(`Expected a number-like value, got "${String(t.value)}".`) : t;
  }
}
be.createBigInt = mu;
function bu(e) {
  if (typeof e == "string" && e.toLowerCase() === "0x")
    return new Uint8Array();
  try {
    return (0, O.create)(e, fu);
  } catch (t) {
    throw t instanceof O.StructError ? new Error(`Expected a bytes-like value, got "${String(t.value)}".`) : t;
  }
}
be.createBytes = bu;
function yu(e) {
  if (e instanceof Uint8Array && e.length === 0 || typeof e == "string" && e.toLowerCase() === "0x")
    return "0x";
  try {
    return (0, O.create)(e, gu);
  } catch (t) {
    throw t instanceof O.StructError ? new Error(`Expected a bytes-like value, got "${String(t.value)}".`) : t;
  }
}
be.createHex = yu;
var rt = {}, ca = v && v.__classPrivateFieldSet || function(e, t, n, r, s) {
  if (r === "m") throw new TypeError("Private method is not writable");
  if (r === "a" && !s) throw new TypeError("Private accessor was defined without a setter");
  if (typeof t == "function" ? e !== t || !s : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return r === "a" ? s.call(e, n) : s ? s.value = n : t.set(e, n), n;
}, G = v && v.__classPrivateFieldGet || function(e, t, n, r) {
  if (n === "a" && !r) throw new TypeError("Private accessor was defined without a getter");
  if (typeof t == "function" ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? r : n === "a" ? r.call(e) : r ? r.value : t.get(e);
}, le, he;
Object.defineProperty(rt, "__esModule", { value: !0 });
rt.FrozenSet = rt.FrozenMap = void 0;
class ks {
  constructor(t) {
    le.set(this, void 0), ca(this, le, new Map(t), "f"), Object.freeze(this);
  }
  get size() {
    return G(this, le, "f").size;
  }
  [(le = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
    return G(this, le, "f")[Symbol.iterator]();
  }
  entries() {
    return G(this, le, "f").entries();
  }
  forEach(t, n) {
    return G(this, le, "f").forEach((r, s, i) => t.call(n, r, s, this));
  }
  get(t) {
    return G(this, le, "f").get(t);
  }
  has(t) {
    return G(this, le, "f").has(t);
  }
  keys() {
    return G(this, le, "f").keys();
  }
  values() {
    return G(this, le, "f").values();
  }
  toString() {
    return `FrozenMap(${this.size}) {${this.size > 0 ? ` ${[...this.entries()].map(([t, n]) => `${String(t)} => ${String(n)}`).join(", ")} ` : ""}}`;
  }
}
rt.FrozenMap = ks;
class Cs {
  constructor(t) {
    he.set(this, void 0), ca(this, he, new Set(t), "f"), Object.freeze(this);
  }
  get size() {
    return G(this, he, "f").size;
  }
  [(he = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
    return G(this, he, "f")[Symbol.iterator]();
  }
  entries() {
    return G(this, he, "f").entries();
  }
  forEach(t, n) {
    return G(this, he, "f").forEach((r, s, i) => t.call(n, r, s, this));
  }
  has(t) {
    return G(this, he, "f").has(t);
  }
  keys() {
    return G(this, he, "f").keys();
  }
  values() {
    return G(this, he, "f").values();
  }
  toString() {
    return `FrozenSet(${this.size}) {${this.size > 0 ? ` ${[...this.values()].map((t) => String(t)).join(", ")} ` : ""}}`;
  }
}
rt.FrozenSet = Cs;
Object.freeze(ks);
Object.freeze(ks.prototype);
Object.freeze(Cs);
Object.freeze(Cs.prototype);
var la = {};
Object.defineProperty(la, "__esModule", { value: !0 });
var da = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.getJsonRpcIdValidator = e.assertIsJsonRpcError = e.isJsonRpcError = e.assertIsJsonRpcFailure = e.isJsonRpcFailure = e.assertIsJsonRpcSuccess = e.isJsonRpcSuccess = e.assertIsJsonRpcResponse = e.isJsonRpcResponse = e.assertIsPendingJsonRpcResponse = e.isPendingJsonRpcResponse = e.JsonRpcResponseStruct = e.JsonRpcFailureStruct = e.JsonRpcSuccessStruct = e.PendingJsonRpcResponseStruct = e.assertIsJsonRpcRequest = e.isJsonRpcRequest = e.assertIsJsonRpcNotification = e.isJsonRpcNotification = e.JsonRpcNotificationStruct = e.JsonRpcRequestStruct = e.JsonRpcParamsStruct = e.JsonRpcErrorStruct = e.JsonRpcIdStruct = e.JsonRpcVersionStruct = e.jsonrpc2 = e.getJsonSize = e.isValidJson = e.JsonStruct = e.UnsafeJsonStruct = void 0;
  const t = He, n = J, r = () => (0, t.define)("finite number", (p) => (0, t.is)(p, (0, t.number)()) && Number.isFinite(p));
  e.UnsafeJsonStruct = (0, t.union)([
    (0, t.literal)(null),
    (0, t.boolean)(),
    r(),
    (0, t.string)(),
    (0, t.array)((0, t.lazy)(() => e.UnsafeJsonStruct)),
    (0, t.record)((0, t.string)(), (0, t.lazy)(() => e.UnsafeJsonStruct))
  ]), e.JsonStruct = (0, t.define)("Json", (p, C) => {
    function T(W, Q) {
      const X = [...Q.validator(W, C)];
      return X.length > 0 ? X : !0;
    }
    try {
      const W = T(p, e.UnsafeJsonStruct);
      return W !== !0 ? W : T(JSON.parse(JSON.stringify(p)), e.UnsafeJsonStruct);
    } catch (W) {
      return W instanceof RangeError ? "Circular reference detected" : !1;
    }
  });
  function s(p) {
    return (0, t.is)(p, e.JsonStruct);
  }
  e.isValidJson = s;
  function i(p) {
    (0, n.assertStruct)(p, e.JsonStruct, "Invalid JSON value");
    const C = JSON.stringify(p);
    return new TextEncoder().encode(C).byteLength;
  }
  e.getJsonSize = i, e.jsonrpc2 = "2.0", e.JsonRpcVersionStruct = (0, t.literal)(e.jsonrpc2), e.JsonRpcIdStruct = (0, t.nullable)((0, t.union)([(0, t.number)(), (0, t.string)()])), e.JsonRpcErrorStruct = (0, t.object)({
    code: (0, t.integer)(),
    message: (0, t.string)(),
    data: (0, t.optional)(e.JsonStruct),
    stack: (0, t.optional)((0, t.string)())
  }), e.JsonRpcParamsStruct = (0, t.optional)((0, t.union)([(0, t.record)((0, t.string)(), e.JsonStruct), (0, t.array)(e.JsonStruct)])), e.JsonRpcRequestStruct = (0, t.object)({
    id: e.JsonRpcIdStruct,
    jsonrpc: e.JsonRpcVersionStruct,
    method: (0, t.string)(),
    params: e.JsonRpcParamsStruct
  }), e.JsonRpcNotificationStruct = (0, t.omit)(e.JsonRpcRequestStruct, ["id"]);
  function o(p) {
    return (0, t.is)(p, e.JsonRpcNotificationStruct);
  }
  e.isJsonRpcNotification = o;
  function a(p, C) {
    (0, n.assertStruct)(p, e.JsonRpcNotificationStruct, "Invalid JSON-RPC notification", C);
  }
  e.assertIsJsonRpcNotification = a;
  function c(p) {
    return (0, t.is)(p, e.JsonRpcRequestStruct);
  }
  e.isJsonRpcRequest = c;
  function l(p, C) {
    (0, n.assertStruct)(p, e.JsonRpcRequestStruct, "Invalid JSON-RPC request", C);
  }
  e.assertIsJsonRpcRequest = l, e.PendingJsonRpcResponseStruct = (0, t.object)({
    id: e.JsonRpcIdStruct,
    jsonrpc: e.JsonRpcVersionStruct,
    result: (0, t.optional)((0, t.unknown)()),
    error: (0, t.optional)(e.JsonRpcErrorStruct)
  }), e.JsonRpcSuccessStruct = (0, t.object)({
    id: e.JsonRpcIdStruct,
    jsonrpc: e.JsonRpcVersionStruct,
    result: e.JsonStruct
  }), e.JsonRpcFailureStruct = (0, t.object)({
    id: e.JsonRpcIdStruct,
    jsonrpc: e.JsonRpcVersionStruct,
    error: e.JsonRpcErrorStruct
  }), e.JsonRpcResponseStruct = (0, t.union)([
    e.JsonRpcSuccessStruct,
    e.JsonRpcFailureStruct
  ]);
  function d(p) {
    return (0, t.is)(p, e.PendingJsonRpcResponseStruct);
  }
  e.isPendingJsonRpcResponse = d;
  function h(p, C) {
    (0, n.assertStruct)(p, e.PendingJsonRpcResponseStruct, "Invalid pending JSON-RPC response", C);
  }
  e.assertIsPendingJsonRpcResponse = h;
  function u(p) {
    return (0, t.is)(p, e.JsonRpcResponseStruct);
  }
  e.isJsonRpcResponse = u;
  function f(p, C) {
    (0, n.assertStruct)(p, e.JsonRpcResponseStruct, "Invalid JSON-RPC response", C);
  }
  e.assertIsJsonRpcResponse = f;
  function b(p) {
    return (0, t.is)(p, e.JsonRpcSuccessStruct);
  }
  e.isJsonRpcSuccess = b;
  function w(p, C) {
    (0, n.assertStruct)(p, e.JsonRpcSuccessStruct, "Invalid JSON-RPC success response", C);
  }
  e.assertIsJsonRpcSuccess = w;
  function _(p) {
    return (0, t.is)(p, e.JsonRpcFailureStruct);
  }
  e.isJsonRpcFailure = _;
  function k(p, C) {
    (0, n.assertStruct)(p, e.JsonRpcFailureStruct, "Invalid JSON-RPC failure response", C);
  }
  e.assertIsJsonRpcFailure = k;
  function y(p) {
    return (0, t.is)(p, e.JsonRpcErrorStruct);
  }
  e.isJsonRpcError = y;
  function g(p, C) {
    (0, n.assertStruct)(p, e.JsonRpcErrorStruct, "Invalid JSON-RPC error", C);
  }
  e.assertIsJsonRpcError = g;
  function M(p) {
    const { permitEmptyString: C, permitFractions: T, permitNull: W } = Object.assign({ permitEmptyString: !0, permitFractions: !1, permitNull: !0 }, p);
    return (j) => !!(typeof j == "number" && (T || Number.isInteger(j)) || typeof j == "string" && (C || j.length > 0) || W && j === null);
  }
  e.getJsonRpcIdValidator = M;
})(da);
var ua = {};
Object.defineProperty(ua, "__esModule", { value: !0 });
var st = {}, ts = { exports: {} }, qr, $i;
function wu() {
  if ($i) return qr;
  $i = 1;
  var e = 1e3, t = e * 60, n = t * 60, r = n * 24, s = r * 7, i = r * 365.25;
  qr = function(d, h) {
    h = h || {};
    var u = typeof d;
    if (u === "string" && d.length > 0)
      return o(d);
    if (u === "number" && isFinite(d))
      return h.long ? c(d) : a(d);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(d)
    );
  };
  function o(d) {
    if (d = String(d), !(d.length > 100)) {
      var h = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        d
      );
      if (h) {
        var u = parseFloat(h[1]), f = (h[2] || "ms").toLowerCase();
        switch (f) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return u * i;
          case "weeks":
          case "week":
          case "w":
            return u * s;
          case "days":
          case "day":
          case "d":
            return u * r;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return u * n;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return u * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return u * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return u;
          default:
            return;
        }
      }
    }
  }
  function a(d) {
    var h = Math.abs(d);
    return h >= r ? Math.round(d / r) + "d" : h >= n ? Math.round(d / n) + "h" : h >= t ? Math.round(d / t) + "m" : h >= e ? Math.round(d / e) + "s" : d + "ms";
  }
  function c(d) {
    var h = Math.abs(d);
    return h >= r ? l(d, h, r, "day") : h >= n ? l(d, h, n, "hour") : h >= t ? l(d, h, t, "minute") : h >= e ? l(d, h, e, "second") : d + " ms";
  }
  function l(d, h, u, f) {
    var b = h >= u * 1.5;
    return Math.round(d / u) + " " + f + (b ? "s" : "");
  }
  return qr;
}
function _u(e) {
  n.debug = n, n.default = n, n.coerce = c, n.disable = i, n.enable = s, n.enabled = o, n.humanize = wu(), n.destroy = l, Object.keys(e).forEach((d) => {
    n[d] = e[d];
  }), n.names = [], n.skips = [], n.formatters = {};
  function t(d) {
    let h = 0;
    for (let u = 0; u < d.length; u++)
      h = (h << 5) - h + d.charCodeAt(u), h |= 0;
    return n.colors[Math.abs(h) % n.colors.length];
  }
  n.selectColor = t;
  function n(d) {
    let h, u = null, f, b;
    function w(..._) {
      if (!w.enabled)
        return;
      const k = w, y = Number(/* @__PURE__ */ new Date()), g = y - (h || y);
      k.diff = g, k.prev = h, k.curr = y, h = y, _[0] = n.coerce(_[0]), typeof _[0] != "string" && _.unshift("%O");
      let M = 0;
      _[0] = _[0].replace(/%([a-zA-Z%])/g, (C, T) => {
        if (C === "%%")
          return "%";
        M++;
        const W = n.formatters[T];
        if (typeof W == "function") {
          const Q = _[M];
          C = W.call(k, Q), _.splice(M, 1), M--;
        }
        return C;
      }), n.formatArgs.call(k, _), (k.log || n.log).apply(k, _);
    }
    return w.namespace = d, w.useColors = n.useColors(), w.color = n.selectColor(d), w.extend = r, w.destroy = n.destroy, Object.defineProperty(w, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => u !== null ? u : (f !== n.namespaces && (f = n.namespaces, b = n.enabled(d)), b),
      set: (_) => {
        u = _;
      }
    }), typeof n.init == "function" && n.init(w), w;
  }
  function r(d, h) {
    const u = n(this.namespace + (typeof h > "u" ? ":" : h) + d);
    return u.log = this.log, u;
  }
  function s(d) {
    n.save(d), n.namespaces = d, n.names = [], n.skips = [];
    let h;
    const u = (typeof d == "string" ? d : "").split(/[\s,]+/), f = u.length;
    for (h = 0; h < f; h++)
      u[h] && (d = u[h].replace(/\*/g, ".*?"), d[0] === "-" ? n.skips.push(new RegExp("^" + d.slice(1) + "$")) : n.names.push(new RegExp("^" + d + "$")));
  }
  function i() {
    const d = [
      ...n.names.map(a),
      ...n.skips.map(a).map((h) => "-" + h)
    ].join(",");
    return n.enable(""), d;
  }
  function o(d) {
    if (d[d.length - 1] === "*")
      return !0;
    let h, u;
    for (h = 0, u = n.skips.length; h < u; h++)
      if (n.skips[h].test(d))
        return !1;
    for (h = 0, u = n.names.length; h < u; h++)
      if (n.names[h].test(d))
        return !0;
    return !1;
  }
  function a(d) {
    return d.toString().substring(2, d.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function c(d) {
    return d instanceof Error ? d.stack || d.message : d;
  }
  function l() {
  }
  return n.enable(n.load()), n;
}
var vu = _u;
(function(e, t) {
  t.formatArgs = r, t.save = s, t.load = i, t.useColors = n, t.storage = o(), t.destroy = /* @__PURE__ */ (() => {
    let c = !1;
    return () => {
      c || (c = !0);
    };
  })(), t.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function n() {
    return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function r(c) {
    if (c[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + c[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors)
      return;
    const l = "color: " + this.color;
    c.splice(1, 0, l, "color: inherit");
    let d = 0, h = 0;
    c[0].replace(/%[a-zA-Z%]/g, (u) => {
      u !== "%%" && (d++, u === "%c" && (h = d));
    }), c.splice(h, 0, l);
  }
  t.log = console.debug || console.log || (() => {
  });
  function s(c) {
    try {
      c ? t.storage.setItem("debug", c) : t.storage.removeItem("debug");
    } catch {
    }
  }
  function i() {
    let c;
    try {
      c = t.storage.getItem("debug");
    } catch {
    }
    return !c && typeof jr < "u" && "env" in jr && (c = jr.env.DEBUG), c;
  }
  function o() {
    try {
      return localStorage;
    } catch {
    }
  }
  e.exports = vu(t);
  const { formatters: a } = e.exports;
  a.j = function(c) {
    try {
      return JSON.stringify(c);
    } catch (l) {
      return "[UnexpectedJSONParseError]: " + l.message;
    }
  };
})(ts, ts.exports);
var Eu = ts.exports, ku = v && v.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(st, "__esModule", { value: !0 });
st.createModuleLogger = st.createProjectLogger = void 0;
const Cu = ku(Eu), Su = (0, Cu.default)("metamask");
function Ru(e) {
  return Su.extend(e);
}
st.createProjectLogger = Ru;
function Iu(e, t) {
  return e.extend(t);
}
st.createModuleLogger = Iu;
var ha = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.calculateNumberSize = e.calculateStringSize = e.isASCII = e.isPlainObject = e.ESCAPE_CHARACTERS_REGEXP = e.JsonSize = e.hasProperty = e.isObject = e.isNullOrUndefined = e.isNonEmptyArray = void 0;
  function t(l) {
    return Array.isArray(l) && l.length > 0;
  }
  e.isNonEmptyArray = t;
  function n(l) {
    return l == null;
  }
  e.isNullOrUndefined = n;
  function r(l) {
    return !!l && typeof l == "object" && !Array.isArray(l);
  }
  e.isObject = r;
  const s = (l, d) => Object.hasOwnProperty.call(l, d);
  e.hasProperty = s, function(l) {
    l[l.Null = 4] = "Null", l[l.Comma = 1] = "Comma", l[l.Wrapper = 1] = "Wrapper", l[l.True = 4] = "True", l[l.False = 5] = "False", l[l.Quote = 1] = "Quote", l[l.Colon = 1] = "Colon", l[l.Date = 24] = "Date";
  }(e.JsonSize || (e.JsonSize = {})), e.ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu;
  function i(l) {
    if (typeof l != "object" || l === null)
      return !1;
    try {
      let d = l;
      for (; Object.getPrototypeOf(d) !== null; )
        d = Object.getPrototypeOf(d);
      return Object.getPrototypeOf(l) === d;
    } catch {
      return !1;
    }
  }
  e.isPlainObject = i;
  function o(l) {
    return l.charCodeAt(0) <= 127;
  }
  e.isASCII = o;
  function a(l) {
    var d;
    return l.split("").reduce((u, f) => o(f) ? u + 1 : u + 2, 0) + ((d = l.match(e.ESCAPE_CHARACTERS_REGEXP)) !== null && d !== void 0 ? d : []).length;
  }
  e.calculateStringSize = a;
  function c(l) {
    return l.toString().length;
  }
  e.calculateNumberSize = c;
})(ha);
var ye = {};
Object.defineProperty(ye, "__esModule", { value: !0 });
ye.hexToBigInt = ye.hexToNumber = ye.bigIntToHex = ye.numberToHex = void 0;
const Ke = J, wt = Ot, Mu = (e) => ((0, Ke.assert)(typeof e == "number", "Value must be a number."), (0, Ke.assert)(e >= 0, "Value must be a non-negative number."), (0, Ke.assert)(Number.isSafeInteger(e), "Value is not a safe integer. Use `bigIntToHex` instead."), (0, wt.add0x)(e.toString(16)));
ye.numberToHex = Mu;
const Au = (e) => ((0, Ke.assert)(typeof e == "bigint", "Value must be a bigint."), (0, Ke.assert)(e >= 0, "Value must be a non-negative bigint."), (0, wt.add0x)(e.toString(16)));
ye.bigIntToHex = Au;
const Pu = (e) => {
  (0, wt.assertIsHexString)(e);
  const t = parseInt(e, 16);
  return (0, Ke.assert)(Number.isSafeInteger(t), "Value is not a safe integer. Use `hexToBigInt` instead."), t;
};
ye.hexToNumber = Pu;
const Nu = (e) => ((0, wt.assertIsHexString)(e), BigInt((0, wt.add0x)(e)));
ye.hexToBigInt = Nu;
var fa = {};
Object.defineProperty(fa, "__esModule", { value: !0 });
var ga = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.timeSince = e.inMilliseconds = e.Duration = void 0, function(i) {
    i[i.Millisecond = 1] = "Millisecond", i[i.Second = 1e3] = "Second", i[i.Minute = 6e4] = "Minute", i[i.Hour = 36e5] = "Hour", i[i.Day = 864e5] = "Day", i[i.Week = 6048e5] = "Week", i[i.Year = 31536e6] = "Year";
  }(e.Duration || (e.Duration = {}));
  const t = (i) => Number.isInteger(i) && i >= 0, n = (i, o) => {
    if (!t(i))
      throw new Error(`"${o}" must be a non-negative integer. Received: "${i}".`);
  };
  function r(i, o) {
    return n(i, "count"), i * o;
  }
  e.inMilliseconds = r;
  function s(i) {
    return n(i, "timestamp"), Date.now() - i;
  }
  e.timeSince = s;
})(ga);
var pa = {};
Object.defineProperty(pa, "__esModule", { value: !0 });
var ma = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.satisfiesVersionRange = e.gtRange = e.gtVersion = e.assertIsSemVerRange = e.assertIsSemVerVersion = e.isValidSemVerRange = e.isValidSemVerVersion = e.VersionRangeStruct = e.VersionStruct = void 0;
  const t = Ba, n = He, r = J;
  e.VersionStruct = (0, n.refine)((0, n.string)(), "Version", (h) => (0, t.valid)(h) === null ? `Expected SemVer version, got "${h}"` : !0), e.VersionRangeStruct = (0, n.refine)((0, n.string)(), "Version range", (h) => (0, t.validRange)(h) === null ? `Expected SemVer range, got "${h}"` : !0);
  function s(h) {
    return (0, n.is)(h, e.VersionStruct);
  }
  e.isValidSemVerVersion = s;
  function i(h) {
    return (0, n.is)(h, e.VersionRangeStruct);
  }
  e.isValidSemVerRange = i;
  function o(h) {
    (0, r.assertStruct)(h, e.VersionStruct);
  }
  e.assertIsSemVerVersion = o;
  function a(h) {
    (0, r.assertStruct)(h, e.VersionRangeStruct);
  }
  e.assertIsSemVerRange = a;
  function c(h, u) {
    return (0, t.gt)(h, u);
  }
  e.gtVersion = c;
  function l(h, u) {
    return (0, t.gtr)(h, u);
  }
  e.gtRange = l;
  function d(h, u) {
    return (0, t.satisfies)(h, u, {
      includePrerelease: !0
    });
  }
  e.satisfiesVersionRange = d;
})(ma);
(function(e) {
  var t = v && v.__createBinding || (Object.create ? function(r, s, i, o) {
    o === void 0 && (o = i);
    var a = Object.getOwnPropertyDescriptor(s, i);
    (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
      return s[i];
    } }), Object.defineProperty(r, o, a);
  } : function(r, s, i, o) {
    o === void 0 && (o = i), r[o] = s[i];
  }), n = v && v.__exportStar || function(r, s) {
    for (var i in r) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && t(s, r, i);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), n(J, e), n(xt, e), n(N, e), n(Pn, e), n(be, e), n(rt, e), n(la, e), n(Ot, e), n(da, e), n(ua, e), n(st, e), n(ha, e), n(ye, e), n(fa, e), n(ga, e), n(pa, e), n(ma, e);
})(zo);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.createModuleLogger = e.projectLogger = void 0;
  const t = zo;
  Object.defineProperty(e, "createModuleLogger", { enumerable: !0, get: function() {
    return t.createModuleLogger;
  } }), e.projectLogger = (0, t.createProjectLogger)("eth-block-tracker");
})(Wo);
var ba = v && v.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Mn, "__esModule", { value: !0 });
Mn.PollingBlockTracker = void 0;
const Tu = ba(ps), Lu = ba(Ql), xu = Nt, Hi = Wo, Ui = (0, Hi.createModuleLogger)(Hi.projectLogger, "polling-block-tracker"), Ou = (0, Tu.default)(), Bu = 1e3;
class Fu extends xu.BaseBlockTracker {
  constructor(t = {}) {
    var n;
    if (!t.provider)
      throw new Error("PollingBlockTracker - no provider specified.");
    super(Object.assign(Object.assign({}, t), { blockResetDuration: (n = t.blockResetDuration) !== null && n !== void 0 ? n : t.pollingInterval })), this._provider = t.provider, this._pollingInterval = t.pollingInterval || 20 * Bu, this._retryTimeout = t.retryTimeout || this._pollingInterval / 10, this._keepEventLoopActive = t.keepEventLoopActive === void 0 ? !0 : t.keepEventLoopActive, this._setSkipCacheFlag = t.setSkipCacheFlag || !1;
  }
  // trigger block polling
  async checkForLatestBlock() {
    return await this._updateLatestBlock(), await this.getLatestBlock();
  }
  async _start() {
    this._synchronize();
  }
  async _end() {
  }
  async _synchronize() {
    for (var t; this._isRunning; )
      try {
        await this._updateLatestBlock();
        const n = Wi(this._pollingInterval, !this._keepEventLoopActive);
        this.emit("_waitingForNextIteration"), await n;
      } catch (n) {
        const r = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:
${(t = n.stack) !== null && t !== void 0 ? t : n}`);
        try {
          this.emit("error", r);
        } catch {
        }
        const s = Wi(this._retryTimeout, !this._keepEventLoopActive);
        this.emit("_waitingForNextIteration"), await s;
      }
  }
  async _updateLatestBlock() {
    const t = await this._fetchLatestBlock();
    this._newPotentialLatest(t);
  }
  async _fetchLatestBlock() {
    const t = {
      jsonrpc: "2.0",
      id: Ou(),
      method: "eth_blockNumber",
      params: []
    };
    this._setSkipCacheFlag && (t.skipCache = !0), Ui("Making request", t);
    const n = await (0, Lu.default)((r) => this._provider.sendAsync(t, r))();
    if (Ui("Got response", n), n.error)
      throw new Error(`PollingBlockTracker - encountered error fetching block:
${n.error.message}`);
    return n.result;
  }
}
Mn.PollingBlockTracker = Fu;
function Wi(e, t) {
  return new Promise((n) => {
    const r = setTimeout(n, e);
    r.unref && t && r.unref();
  });
}
var Tn = {}, ju = v && v.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Tn, "__esModule", { value: !0 });
Tn.SubscribeBlockTracker = void 0;
const Du = ju(ps), $u = Nt, Hu = (0, Du.default)();
class Uu extends $u.BaseBlockTracker {
  constructor(t = {}) {
    if (!t.provider)
      throw new Error("SubscribeBlockTracker - no provider specified.");
    super(t), this._provider = t.provider, this._subscriptionId = null;
  }
  async checkForLatestBlock() {
    return await this.getLatestBlock();
  }
  async _start() {
    if (this._subscriptionId === void 0 || this._subscriptionId === null)
      try {
        const t = await this._call("eth_blockNumber");
        this._subscriptionId = await this._call("eth_subscribe", "newHeads"), this._provider.on("data", this._handleSubData.bind(this)), this._newPotentialLatest(t);
      } catch (t) {
        this.emit("error", t);
      }
  }
  async _end() {
    if (this._subscriptionId !== null && this._subscriptionId !== void 0)
      try {
        await this._call("eth_unsubscribe", this._subscriptionId), this._subscriptionId = null;
      } catch (t) {
        this.emit("error", t);
      }
  }
  _call(t, ...n) {
    return new Promise((r, s) => {
      this._provider.sendAsync({
        id: Hu(),
        method: t,
        params: n,
        jsonrpc: "2.0"
      }, (i, o) => {
        i ? s(i) : r(o.result);
      });
    });
  }
  _handleSubData(t, n) {
    var r;
    n.method === "eth_subscription" && ((r = n.params) === null || r === void 0 ? void 0 : r.subscription) === this._subscriptionId && this._newPotentialLatest(n.params.result.number);
  }
}
Tn.SubscribeBlockTracker = Uu;
(function(e) {
  var t = v && v.__createBinding || (Object.create ? function(r, s, i, o) {
    o === void 0 && (o = i), Object.defineProperty(r, o, { enumerable: !0, get: function() {
      return s[i];
    } });
  } : function(r, s, i, o) {
    o === void 0 && (o = i), r[o] = s[i];
  }), n = v && v.__exportStar || function(r, s) {
    for (var i in r) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && t(s, r, i);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), n(Mn, e), n(Tn, e);
})(Uo);
var Ss = {}, Ln = {}, Bt = {};
Object.defineProperty(Bt, "__esModule", { value: !0 });
Bt.getUniqueId = void 0;
const ya = 4294967295;
let Zr = Math.floor(Math.random() * ya);
function Wu() {
  return Zr = (Zr + 1) % ya, Zr;
}
Bt.getUniqueId = Wu;
Object.defineProperty(Ln, "__esModule", { value: !0 });
Ln.createIdRemapMiddleware = void 0;
const zu = Bt;
function Vu() {
  return (e, t, n, r) => {
    const s = e.id, i = zu.getUniqueId();
    e.id = i, t.id = i, n((o) => {
      e.id = s, t.id = s, o();
    });
  };
}
Ln.createIdRemapMiddleware = Vu;
var xn = {};
Object.defineProperty(xn, "__esModule", { value: !0 });
xn.createAsyncMiddleware = void 0;
function Ju(e) {
  return async (t, n, r, s) => {
    let i;
    const o = new Promise((d) => {
      i = d;
    });
    let a = null, c = !1;
    const l = async () => {
      c = !0, r((d) => {
        a = d, i();
      }), await o;
    };
    try {
      await e(t, n, l), c ? (await o, a(null)) : s(null);
    } catch (d) {
      a ? a(d) : s(d);
    }
  };
}
xn.createAsyncMiddleware = Ju;
var On = {};
Object.defineProperty(On, "__esModule", { value: !0 });
On.createScaffoldMiddleware = void 0;
function qu(e) {
  return (t, n, r, s) => {
    const i = e[t.method];
    return i === void 0 ? r() : typeof i == "function" ? i(t, n, r, s) : (n.result = i, s());
  };
}
On.createScaffoldMiddleware = qu;
var Ft = {}, Rs = {};
Object.defineProperty(Rs, "__esModule", { value: !0 });
const Zu = so;
function zi(e, t, n) {
  try {
    Reflect.apply(e, t, n);
  } catch (r) {
    setTimeout(() => {
      throw r;
    });
  }
}
function Gu(e) {
  const t = e.length, n = new Array(t);
  for (let r = 0; r < t; r += 1)
    n[r] = e[r];
  return n;
}
let Qu = class extends Zu.EventEmitter {
  emit(t, ...n) {
    let r = t === "error";
    const s = this._events;
    if (s !== void 0)
      r = r && s.error === void 0;
    else if (!r)
      return !1;
    if (r) {
      let o;
      if (n.length > 0 && ([o] = n), o instanceof Error)
        throw o;
      const a = new Error(`Unhandled error.${o ? ` (${o.message})` : ""}`);
      throw a.context = o, a;
    }
    const i = s[t];
    if (i === void 0)
      return !1;
    if (typeof i == "function")
      zi(i, this, n);
    else {
      const o = i.length, a = Gu(i);
      for (let c = 0; c < o; c += 1)
        zi(a[c], this, n);
    }
    return !0;
  }
};
Rs.default = Qu;
var wa = {}, Re = {}, Ku = _t;
_t.default = _t;
_t.stable = Ea;
_t.stableStringify = Ea;
var Xt = "[...]", _a = "[Circular]", je = [], Oe = [];
function va() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
function _t(e, t, n, r) {
  typeof r > "u" && (r = va()), ns(e, "", 0, [], void 0, 0, r);
  var s;
  try {
    Oe.length === 0 ? s = JSON.stringify(e, t, n) : s = JSON.stringify(e, ka(t), n);
  } catch {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; je.length !== 0; ) {
      var i = je.pop();
      i.length === 4 ? Object.defineProperty(i[0], i[1], i[3]) : i[0][i[1]] = i[2];
    }
  }
  return s;
}
function Ye(e, t, n, r) {
  var s = Object.getOwnPropertyDescriptor(r, n);
  s.get !== void 0 ? s.configurable ? (Object.defineProperty(r, n, { value: e }), je.push([r, n, t, s])) : Oe.push([t, n, e]) : (r[n] = e, je.push([r, n, t]));
}
function ns(e, t, n, r, s, i, o) {
  i += 1;
  var a;
  if (typeof e == "object" && e !== null) {
    for (a = 0; a < r.length; a++)
      if (r[a] === e) {
        Ye(_a, e, t, s);
        return;
      }
    if (typeof o.depthLimit < "u" && i > o.depthLimit) {
      Ye(Xt, e, t, s);
      return;
    }
    if (typeof o.edgesLimit < "u" && n + 1 > o.edgesLimit) {
      Ye(Xt, e, t, s);
      return;
    }
    if (r.push(e), Array.isArray(e))
      for (a = 0; a < e.length; a++)
        ns(e[a], a, a, r, e, i, o);
    else {
      var c = Object.keys(e);
      for (a = 0; a < c.length; a++) {
        var l = c[a];
        ns(e[l], l, a, r, e, i, o);
      }
    }
    r.pop();
  }
}
function Yu(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
function Ea(e, t, n, r) {
  typeof r > "u" && (r = va());
  var s = rs(e, "", 0, [], void 0, 0, r) || e, i;
  try {
    Oe.length === 0 ? i = JSON.stringify(s, t, n) : i = JSON.stringify(s, ka(t), n);
  } catch {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; je.length !== 0; ) {
      var o = je.pop();
      o.length === 4 ? Object.defineProperty(o[0], o[1], o[3]) : o[0][o[1]] = o[2];
    }
  }
  return i;
}
function rs(e, t, n, r, s, i, o) {
  i += 1;
  var a;
  if (typeof e == "object" && e !== null) {
    for (a = 0; a < r.length; a++)
      if (r[a] === e) {
        Ye(_a, e, t, s);
        return;
      }
    try {
      if (typeof e.toJSON == "function")
        return;
    } catch {
      return;
    }
    if (typeof o.depthLimit < "u" && i > o.depthLimit) {
      Ye(Xt, e, t, s);
      return;
    }
    if (typeof o.edgesLimit < "u" && n + 1 > o.edgesLimit) {
      Ye(Xt, e, t, s);
      return;
    }
    if (r.push(e), Array.isArray(e))
      for (a = 0; a < e.length; a++)
        rs(e[a], a, a, r, e, i, o);
    else {
      var c = {}, l = Object.keys(e).sort(Yu);
      for (a = 0; a < l.length; a++) {
        var d = l[a];
        rs(e[d], d, a, r, e, i, o), c[d] = e[d];
      }
      if (typeof s < "u")
        je.push([s, t, e]), s[t] = c;
      else
        return c;
    }
    r.pop();
  }
}
function ka(e) {
  return e = typeof e < "u" ? e : function(t, n) {
    return n;
  }, function(t, n) {
    if (Oe.length > 0)
      for (var r = 0; r < Oe.length; r++) {
        var s = Oe[r];
        if (s[1] === t && s[0] === n) {
          n = s[2], Oe.splice(r, 1);
          break;
        }
      }
    return e.call(this, t, n);
  };
}
Object.defineProperty(Re, "__esModule", { value: !0 });
Re.EthereumProviderError = Re.EthereumRpcError = void 0;
const Xu = Ku;
class Ca extends Error {
  constructor(t, n, r) {
    if (!Number.isInteger(t))
      throw new Error('"code" must be an integer.');
    if (!n || typeof n != "string")
      throw new Error('"message" must be a nonempty string.');
    super(n), this.code = t, r !== void 0 && (this.data = r);
  }
  /**
   * Returns a plain object with all public class properties.
   */
  serialize() {
    const t = {
      code: this.code,
      message: this.message
    };
    return this.data !== void 0 && (t.data = this.data), this.stack && (t.stack = this.stack), t;
  }
  /**
   * Return a string representation of the serialized error, omitting
   * any circular references.
   */
  toString() {
    return Xu.default(this.serialize(), nh, 2);
  }
}
Re.EthereumRpcError = Ca;
class eh extends Ca {
  /**
   * Create an Ethereum Provider JSON-RPC error.
   * `code` must be an integer in the 1000 <= 4999 range.
   */
  constructor(t, n, r) {
    if (!th(t))
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    super(t, n, r);
  }
}
Re.EthereumProviderError = eh;
function th(e) {
  return Number.isInteger(e) && e >= 1e3 && e <= 4999;
}
function nh(e, t) {
  if (t !== "[Circular]")
    return t;
}
var Is = {}, Ie = {};
Object.defineProperty(Ie, "__esModule", { value: !0 });
Ie.errorValues = Ie.errorCodes = void 0;
Ie.errorCodes = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901
  }
};
Ie.errorValues = {
  "-32700": {
    standard: "JSON RPC 2.0",
    message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
  },
  "-32600": {
    standard: "JSON RPC 2.0",
    message: "The JSON sent is not a valid Request object."
  },
  "-32601": {
    standard: "JSON RPC 2.0",
    message: "The method does not exist / is not available."
  },
  "-32602": {
    standard: "JSON RPC 2.0",
    message: "Invalid method parameter(s)."
  },
  "-32603": {
    standard: "JSON RPC 2.0",
    message: "Internal JSON-RPC error."
  },
  "-32000": {
    standard: "EIP-1474",
    message: "Invalid input."
  },
  "-32001": {
    standard: "EIP-1474",
    message: "Resource not found."
  },
  "-32002": {
    standard: "EIP-1474",
    message: "Resource unavailable."
  },
  "-32003": {
    standard: "EIP-1474",
    message: "Transaction rejected."
  },
  "-32004": {
    standard: "EIP-1474",
    message: "Method not supported."
  },
  "-32005": {
    standard: "EIP-1474",
    message: "Request limit exceeded."
  },
  4001: {
    standard: "EIP-1193",
    message: "User rejected the request."
  },
  4100: {
    standard: "EIP-1193",
    message: "The requested account and/or method has not been authorized by the user."
  },
  4200: {
    standard: "EIP-1193",
    message: "The requested method is not supported by this Ethereum provider."
  },
  4900: {
    standard: "EIP-1193",
    message: "The provider is disconnected from all chains."
  },
  4901: {
    standard: "EIP-1193",
    message: "The provider is disconnected from the specified chain."
  }
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.serializeError = e.isValidCode = e.getMessageFromCode = e.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
  const t = Ie, n = Re, r = t.errorCodes.rpc.internal, s = "Unspecified error message. This is a bug, please report it.", i = {
    code: r,
    message: o(r)
  };
  e.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
  function o(u, f = s) {
    if (Number.isInteger(u)) {
      const b = u.toString();
      if (h(t.errorValues, b))
        return t.errorValues[b].message;
      if (l(u))
        return e.JSON_RPC_SERVER_ERROR_MESSAGE;
    }
    return f;
  }
  e.getMessageFromCode = o;
  function a(u) {
    if (!Number.isInteger(u))
      return !1;
    const f = u.toString();
    return !!(t.errorValues[f] || l(u));
  }
  e.isValidCode = a;
  function c(u, { fallbackError: f = i, shouldIncludeStack: b = !1 } = {}) {
    var w, _;
    if (!f || !Number.isInteger(f.code) || typeof f.message != "string")
      throw new Error("Must provide fallback error with integer number code and string message.");
    if (u instanceof n.EthereumRpcError)
      return u.serialize();
    const k = {};
    if (u && typeof u == "object" && !Array.isArray(u) && h(u, "code") && a(u.code)) {
      const g = u;
      k.code = g.code, g.message && typeof g.message == "string" ? (k.message = g.message, h(g, "data") && (k.data = g.data)) : (k.message = o(k.code), k.data = { originalError: d(u) });
    } else {
      k.code = f.code;
      const g = (w = u) === null || w === void 0 ? void 0 : w.message;
      k.message = g && typeof g == "string" ? g : f.message, k.data = { originalError: d(u) };
    }
    const y = (_ = u) === null || _ === void 0 ? void 0 : _.stack;
    return b && u && y && typeof y == "string" && (k.stack = y), k;
  }
  e.serializeError = c;
  function l(u) {
    return u >= -32099 && u <= -32e3;
  }
  function d(u) {
    return u && typeof u == "object" && !Array.isArray(u) ? Object.assign({}, u) : u;
  }
  function h(u, f) {
    return Object.prototype.hasOwnProperty.call(u, f);
  }
})(Is);
var Bn = {};
Object.defineProperty(Bn, "__esModule", { value: !0 });
Bn.ethErrors = void 0;
const Ms = Re, Sa = Is, q = Ie;
Bn.ethErrors = {
  rpc: {
    /**
     * Get a JSON RPC 2.0 Parse (-32700) error.
     */
    parse: (e) => se(q.errorCodes.rpc.parse, e),
    /**
     * Get a JSON RPC 2.0 Invalid Request (-32600) error.
     */
    invalidRequest: (e) => se(q.errorCodes.rpc.invalidRequest, e),
    /**
     * Get a JSON RPC 2.0 Invalid Params (-32602) error.
     */
    invalidParams: (e) => se(q.errorCodes.rpc.invalidParams, e),
    /**
     * Get a JSON RPC 2.0 Method Not Found (-32601) error.
     */
    methodNotFound: (e) => se(q.errorCodes.rpc.methodNotFound, e),
    /**
     * Get a JSON RPC 2.0 Internal (-32603) error.
     */
    internal: (e) => se(q.errorCodes.rpc.internal, e),
    /**
     * Get a JSON RPC 2.0 Server error.
     * Permits integer error codes in the [ -32099 <= -32005 ] range.
     * Codes -32000 through -32004 are reserved by EIP-1474.
     */
    server: (e) => {
      if (!e || typeof e != "object" || Array.isArray(e))
        throw new Error("Ethereum RPC Server errors must provide single object argument.");
      const { code: t } = e;
      if (!Number.isInteger(t) || t > -32005 || t < -32099)
        throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
      return se(t, e);
    },
    /**
     * Get an Ethereum JSON RPC Invalid Input (-32000) error.
     */
    invalidInput: (e) => se(q.errorCodes.rpc.invalidInput, e),
    /**
     * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
     */
    resourceNotFound: (e) => se(q.errorCodes.rpc.resourceNotFound, e),
    /**
     * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
     */
    resourceUnavailable: (e) => se(q.errorCodes.rpc.resourceUnavailable, e),
    /**
     * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
     */
    transactionRejected: (e) => se(q.errorCodes.rpc.transactionRejected, e),
    /**
     * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
     */
    methodNotSupported: (e) => se(q.errorCodes.rpc.methodNotSupported, e),
    /**
     * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
     */
    limitExceeded: (e) => se(q.errorCodes.rpc.limitExceeded, e)
  },
  provider: {
    /**
     * Get an Ethereum Provider User Rejected Request (4001) error.
     */
    userRejectedRequest: (e) => pt(q.errorCodes.provider.userRejectedRequest, e),
    /**
     * Get an Ethereum Provider Unauthorized (4100) error.
     */
    unauthorized: (e) => pt(q.errorCodes.provider.unauthorized, e),
    /**
     * Get an Ethereum Provider Unsupported Method (4200) error.
     */
    unsupportedMethod: (e) => pt(q.errorCodes.provider.unsupportedMethod, e),
    /**
     * Get an Ethereum Provider Not Connected (4900) error.
     */
    disconnected: (e) => pt(q.errorCodes.provider.disconnected, e),
    /**
     * Get an Ethereum Provider Chain Not Connected (4901) error.
     */
    chainDisconnected: (e) => pt(q.errorCodes.provider.chainDisconnected, e),
    /**
     * Get a custom Ethereum Provider error.
     */
    custom: (e) => {
      if (!e || typeof e != "object" || Array.isArray(e))
        throw new Error("Ethereum Provider custom errors must provide single object argument.");
      const { code: t, message: n, data: r } = e;
      if (!n || typeof n != "string")
        throw new Error('"message" must be a nonempty string');
      return new Ms.EthereumProviderError(t, n, r);
    }
  }
};
function se(e, t) {
  const [n, r] = Ra(t);
  return new Ms.EthereumRpcError(e, n || Sa.getMessageFromCode(e), r);
}
function pt(e, t) {
  const [n, r] = Ra(t);
  return new Ms.EthereumProviderError(e, n || Sa.getMessageFromCode(e), r);
}
function Ra(e) {
  if (e) {
    if (typeof e == "string")
      return [e];
    if (typeof e == "object" && !Array.isArray(e)) {
      const { message: t, data: n } = e;
      if (t && typeof t != "string")
        throw new Error("Must specify string message.");
      return [t || void 0, n];
    }
  }
  return [];
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.getMessageFromCode = e.serializeError = e.EthereumProviderError = e.EthereumRpcError = e.ethErrors = e.errorCodes = void 0;
  const t = Re;
  Object.defineProperty(e, "EthereumRpcError", { enumerable: !0, get: function() {
    return t.EthereumRpcError;
  } }), Object.defineProperty(e, "EthereumProviderError", { enumerable: !0, get: function() {
    return t.EthereumProviderError;
  } });
  const n = Is;
  Object.defineProperty(e, "serializeError", { enumerable: !0, get: function() {
    return n.serializeError;
  } }), Object.defineProperty(e, "getMessageFromCode", { enumerable: !0, get: function() {
    return n.getMessageFromCode;
  } });
  const r = Bn;
  Object.defineProperty(e, "ethErrors", { enumerable: !0, get: function() {
    return r.ethErrors;
  } });
  const s = Ie;
  Object.defineProperty(e, "errorCodes", { enumerable: !0, get: function() {
    return s.errorCodes;
  } });
})(wa);
var rh = v && v.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Ft, "__esModule", { value: !0 });
Ft.JsonRpcEngine = void 0;
const sh = rh(Rs), ie = wa;
class we extends sh.default {
  constructor() {
    super(), this._middleware = [];
  }
  /**
   * Add a middleware function to the engine's middleware stack.
   *
   * @param middleware - The middleware function to add.
   */
  push(t) {
    this._middleware.push(t);
  }
  handle(t, n) {
    if (n && typeof n != "function")
      throw new Error('"callback" must be a function if provided.');
    return Array.isArray(t) ? n ? this._handleBatch(t, n) : this._handleBatch(t) : n ? this._handle(t, n) : this._promiseHandle(t);
  }
  /**
   * Returns this engine as a middleware function that can be pushed to other
   * engines.
   *
   * @returns This engine as a middleware function.
   */
  asMiddleware() {
    return async (t, n, r, s) => {
      try {
        const [i, o, a] = await we._runAllMiddleware(t, n, this._middleware);
        return o ? (await we._runReturnHandlers(a), s(i)) : r(async (c) => {
          try {
            await we._runReturnHandlers(a);
          } catch (l) {
            return c(l);
          }
          return c();
        });
      } catch (i) {
        return s(i);
      }
    };
  }
  async _handleBatch(t, n) {
    try {
      const r = await Promise.all(
        // 1. Begin executing each request in the order received
        t.map(this._promiseHandle.bind(this))
      );
      return n ? n(null, r) : r;
    } catch (r) {
      if (n)
        return n(r);
      throw r;
    }
  }
  /**
   * A promise-wrapped _handle.
   */
  _promiseHandle(t) {
    return new Promise((n) => {
      this._handle(t, (r, s) => {
        n(s);
      });
    });
  }
  /**
   * Ensures that the request object is valid, processes it, and passes any
   * error and the response object to the given callback.
   *
   * Does not reject.
   */
  async _handle(t, n) {
    if (!t || Array.isArray(t) || typeof t != "object") {
      const o = new ie.EthereumRpcError(ie.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof t}`, { request: t });
      return n(o, { id: void 0, jsonrpc: "2.0", error: o });
    }
    if (typeof t.method != "string") {
      const o = new ie.EthereumRpcError(ie.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof t.method}`, { request: t });
      return n(o, { id: t.id, jsonrpc: "2.0", error: o });
    }
    const r = Object.assign({}, t), s = {
      id: r.id,
      jsonrpc: r.jsonrpc
    };
    let i = null;
    try {
      await this._processRequest(r, s);
    } catch (o) {
      i = o;
    }
    return i && (delete s.result, s.error || (s.error = ie.serializeError(i))), n(i, s);
  }
  /**
   * For the given request and response, runs all middleware and their return
   * handlers, if any, and ensures that internal request processing semantics
   * are satisfied.
   */
  async _processRequest(t, n) {
    const [r, s, i] = await we._runAllMiddleware(t, n, this._middleware);
    if (we._checkForCompletion(t, n, s), await we._runReturnHandlers(i), r)
      throw r;
  }
  /**
   * Serially executes the given stack of middleware.
   *
   * @returns An array of any error encountered during middleware execution,
   * a boolean indicating whether the request was completed, and an array of
   * middleware-defined return handlers.
   */
  static async _runAllMiddleware(t, n, r) {
    const s = [];
    let i = null, o = !1;
    for (const a of r)
      if ([i, o] = await we._runMiddleware(t, n, a, s), o)
        break;
    return [i, o, s.reverse()];
  }
  /**
   * Runs an individual middleware.
   *
   * @returns An array of any error encountered during middleware exection,
   * and a boolean indicating whether the request should end.
   */
  static _runMiddleware(t, n, r, s) {
    return new Promise((i) => {
      const o = (c) => {
        const l = c || n.error;
        l && (n.error = ie.serializeError(l)), i([l, !0]);
      }, a = (c) => {
        n.error ? o(n.error) : (c && (typeof c != "function" && o(new ie.EthereumRpcError(ie.errorCodes.rpc.internal, `JsonRpcEngine: "next" return handlers must be functions. Received "${typeof c}" for request:
${Gr(t)}`, { request: t })), s.push(c)), i([null, !1]));
      };
      try {
        r(t, n, a, o);
      } catch (c) {
        o(c);
      }
    });
  }
  /**
   * Serially executes array of return handlers. The request and response are
   * assumed to be in their scope.
   */
  static async _runReturnHandlers(t) {
    for (const n of t)
      await new Promise((r, s) => {
        n((i) => i ? s(i) : r());
      });
  }
  /**
   * Throws an error if the response has neither a result nor an error, or if
   * the "isComplete" flag is falsy.
   */
  static _checkForCompletion(t, n, r) {
    if (!("result" in n) && !("error" in n))
      throw new ie.EthereumRpcError(ie.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:
${Gr(t)}`, { request: t });
    if (!r)
      throw new ie.EthereumRpcError(ie.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:
${Gr(t)}`, { request: t });
  }
}
Ft.JsonRpcEngine = we;
function Gr(e) {
  return JSON.stringify(e, null, 2);
}
var Fn = {};
Object.defineProperty(Fn, "__esModule", { value: !0 });
Fn.mergeMiddleware = void 0;
const ih = Ft;
function oh(e) {
  const t = new ih.JsonRpcEngine();
  return e.forEach((n) => t.push(n)), t.asMiddleware();
}
Fn.mergeMiddleware = oh;
(function(e) {
  var t = v && v.__createBinding || (Object.create ? function(r, s, i, o) {
    o === void 0 && (o = i), Object.defineProperty(r, o, { enumerable: !0, get: function() {
      return s[i];
    } });
  } : function(r, s, i, o) {
    o === void 0 && (o = i), r[o] = s[i];
  }), n = v && v.__exportStar || function(r, s) {
    for (var i in r) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && t(s, r, i);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), n(Ln, e), n(xn, e), n(On, e), n(Bt, e), n(Ft, e), n(Fn, e);
})(Ss);
var Ia = {}, As = {};
const Ps = /* @__PURE__ */ ss(Ta);
var jn = {};
Object.defineProperty(jn, "__esModule", { value: !0 });
var Vi = Ps, ah = (
  /** @class */
  function() {
    function e(t) {
      if (this._maxConcurrency = t, this._queue = [], t <= 0)
        throw new Error("semaphore must be initialized to a positive value");
      this._value = t;
    }
    return e.prototype.acquire = function() {
      var t = this, n = this.isLocked(), r = new Promise(function(s) {
        return t._queue.push(s);
      });
      return n || this._dispatch(), r;
    }, e.prototype.runExclusive = function(t) {
      return Vi.__awaiter(this, void 0, void 0, function() {
        var n, r, s;
        return Vi.__generator(this, function(i) {
          switch (i.label) {
            case 0:
              return [4, this.acquire()];
            case 1:
              n = i.sent(), r = n[0], s = n[1], i.label = 2;
            case 2:
              return i.trys.push([2, , 4, 5]), [4, t(r)];
            case 3:
              return [2, i.sent()];
            case 4:
              return s(), [
                7
                /*endfinally*/
              ];
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.isLocked = function() {
      return this._value <= 0;
    }, e.prototype.release = function() {
      if (this._maxConcurrency > 1)
        throw new Error("this method is unavailabel on semaphores with concurrency > 1; use the scoped release returned by acquire instead");
      if (this._currentReleaser) {
        var t = this._currentReleaser;
        this._currentReleaser = void 0, t();
      }
    }, e.prototype._dispatch = function() {
      var t = this, n = this._queue.shift();
      if (n) {
        var r = !1;
        this._currentReleaser = function() {
          r || (r = !0, t._value++, t._dispatch());
        }, n([this._value--, this._currentReleaser]);
      }
    }, e;
  }()
);
jn.default = ah;
Object.defineProperty(As, "__esModule", { value: !0 });
var Ji = Ps, ch = jn, lh = (
  /** @class */
  function() {
    function e() {
      this._semaphore = new ch.default(1);
    }
    return e.prototype.acquire = function() {
      return Ji.__awaiter(this, void 0, void 0, function() {
        var t, n;
        return Ji.__generator(this, function(r) {
          switch (r.label) {
            case 0:
              return [4, this._semaphore.acquire()];
            case 1:
              return t = r.sent(), n = t[1], [2, n];
          }
        });
      });
    }, e.prototype.runExclusive = function(t) {
      return this._semaphore.runExclusive(function() {
        return t();
      });
    }, e.prototype.isLocked = function() {
      return this._semaphore.isLocked();
    }, e.prototype.release = function() {
      this._semaphore.release();
    }, e;
  }()
);
As.default = lh;
var Dn = {};
Object.defineProperty(Dn, "__esModule", { value: !0 });
Dn.withTimeout = void 0;
var Zt = Ps;
function dh(e, t, n) {
  var r = this;
  return n === void 0 && (n = new Error("timeout")), {
    acquire: function() {
      return new Promise(function(s, i) {
        return Zt.__awaiter(r, void 0, void 0, function() {
          var o, a, c;
          return Zt.__generator(this, function(l) {
            switch (l.label) {
              case 0:
                return o = !1, setTimeout(function() {
                  o = !0, i(n);
                }, t), [4, e.acquire()];
              case 1:
                return a = l.sent(), o ? (c = Array.isArray(a) ? a[1] : a, c()) : s(a), [
                  2
                  /*return*/
                ];
            }
          });
        });
      });
    },
    runExclusive: function(s) {
      return Zt.__awaiter(this, void 0, void 0, function() {
        var i, o;
        return Zt.__generator(this, function(a) {
          switch (a.label) {
            case 0:
              i = function() {
              }, a.label = 1;
            case 1:
              return a.trys.push([1, , 7, 8]), [4, this.acquire()];
            case 2:
              return o = a.sent(), Array.isArray(o) ? (i = o[1], [4, s(o[0])]) : [3, 4];
            case 3:
              return [2, a.sent()];
            case 4:
              return i = o, [4, s()];
            case 5:
              return [2, a.sent()];
            case 6:
              return [3, 8];
            case 7:
              return i(), [
                7
                /*endfinally*/
              ];
            case 8:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    },
    release: function() {
      e.release();
    },
    isLocked: function() {
      return e.isLocked();
    }
  };
}
Dn.withTimeout = dh;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.withTimeout = e.Semaphore = e.Mutex = void 0;
  var t = As;
  Object.defineProperty(e, "Mutex", { enumerable: !0, get: function() {
    return t.default;
  } });
  var n = jn;
  Object.defineProperty(e, "Semaphore", { enumerable: !0, get: function() {
    return n.default;
  } });
  var r = Dn;
  Object.defineProperty(e, "withTimeout", { enumerable: !0, get: function() {
    return r.withTimeout;
  } });
})(Ia);
var uh = fh, hh = Object.prototype.hasOwnProperty;
function fh() {
  for (var e = {}, t = 0; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      hh.call(n, r) && (e[r] = n[r]);
  }
  return e;
}
const gh = uh, ph = ps();
var mh = E;
function E(e) {
  const t = this;
  t.currentProvider = e;
}
E.prototype.getBalance = jt(2, "eth_getBalance");
E.prototype.getCode = jt(2, "eth_getCode");
E.prototype.getTransactionCount = jt(2, "eth_getTransactionCount");
E.prototype.getStorageAt = jt(3, "eth_getStorageAt");
E.prototype.call = jt(2, "eth_call");
E.prototype.protocolVersion = I("eth_protocolVersion");
E.prototype.syncing = I("eth_syncing");
E.prototype.coinbase = I("eth_coinbase");
E.prototype.mining = I("eth_mining");
E.prototype.hashrate = I("eth_hashrate");
E.prototype.gasPrice = I("eth_gasPrice");
E.prototype.accounts = I("eth_accounts");
E.prototype.blockNumber = I("eth_blockNumber");
E.prototype.getBlockTransactionCountByHash = I("eth_getBlockTransactionCountByHash");
E.prototype.getBlockTransactionCountByNumber = I("eth_getBlockTransactionCountByNumber");
E.prototype.getUncleCountByBlockHash = I("eth_getUncleCountByBlockHash");
E.prototype.getUncleCountByBlockNumber = I("eth_getUncleCountByBlockNumber");
E.prototype.sign = I("eth_sign");
E.prototype.sendTransaction = I("eth_sendTransaction");
E.prototype.sendRawTransaction = I("eth_sendRawTransaction");
E.prototype.estimateGas = I("eth_estimateGas");
E.prototype.getBlockByHash = I("eth_getBlockByHash");
E.prototype.getBlockByNumber = I("eth_getBlockByNumber");
E.prototype.getTransactionByHash = I("eth_getTransactionByHash");
E.prototype.getTransactionByBlockHashAndIndex = I("eth_getTransactionByBlockHashAndIndex");
E.prototype.getTransactionByBlockNumberAndIndex = I("eth_getTransactionByBlockNumberAndIndex");
E.prototype.getTransactionReceipt = I("eth_getTransactionReceipt");
E.prototype.getUncleByBlockHashAndIndex = I("eth_getUncleByBlockHashAndIndex");
E.prototype.getUncleByBlockNumberAndIndex = I("eth_getUncleByBlockNumberAndIndex");
E.prototype.getCompilers = I("eth_getCompilers");
E.prototype.compileLLL = I("eth_compileLLL");
E.prototype.compileSolidity = I("eth_compileSolidity");
E.prototype.compileSerpent = I("eth_compileSerpent");
E.prototype.newFilter = I("eth_newFilter");
E.prototype.newBlockFilter = I("eth_newBlockFilter");
E.prototype.newPendingTransactionFilter = I("eth_newPendingTransactionFilter");
E.prototype.uninstallFilter = I("eth_uninstallFilter");
E.prototype.getFilterChanges = I("eth_getFilterChanges");
E.prototype.getFilterLogs = I("eth_getFilterLogs");
E.prototype.getLogs = I("eth_getLogs");
E.prototype.getWork = I("eth_getWork");
E.prototype.submitWork = I("eth_submitWork");
E.prototype.submitHashrate = I("eth_submitHashrate");
E.prototype.sendAsync = function(e, t) {
  this.currentProvider.sendAsync(bh(e), function(r, s) {
    if (!r && s.error && (r = new Error("EthQuery - RPC Error - " + s.error.message)), r) return t(r);
    t(null, s.result);
  });
};
function I(e) {
  return function() {
    const t = this;
    var n = [].slice.call(arguments), r = n.pop();
    t.sendAsync({
      method: e,
      params: n
    }, r);
  };
}
function jt(e, t) {
  return function() {
    const n = this;
    var r = [].slice.call(arguments), s = r.pop();
    r.length < e && r.push("latest"), n.sendAsync({
      method: t,
      params: r
    }, s);
  };
}
function bh(e) {
  return gh({
    // defaults
    id: ph(),
    jsonrpc: "2.0",
    params: []
    // user-specified
  }, e);
}
const qi = (e, t, n, r) => function(...s) {
  const i = t.promiseModule;
  return new i((o, a) => {
    t.multiArgs ? s.push((...l) => {
      t.errorFirst ? l[0] ? a(l) : (l.shift(), o(l)) : o(l);
    }) : t.errorFirst ? s.push((l, d) => {
      l ? a(l) : o(d);
    }) : s.push(o), Reflect.apply(e, this === n ? r : this, s);
  });
}, Zi = /* @__PURE__ */ new WeakMap();
var yh = (e, t) => {
  t = {
    exclude: [/.+(?:Sync|Stream)$/],
    errorFirst: !0,
    promiseModule: Promise,
    ...t
  };
  const n = typeof e;
  if (!(e !== null && (n === "object" || n === "function")))
    throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${e === null ? "null" : n}\``);
  const r = (o, a) => {
    let c = Zi.get(o);
    if (c || (c = {}, Zi.set(o, c)), a in c)
      return c[a];
    const l = (b) => typeof b == "string" || typeof a == "symbol" ? a === b : b.test(a), d = Reflect.getOwnPropertyDescriptor(o, a), h = d === void 0 || d.writable || d.configurable, f = (t.include ? t.include.some(l) : !t.exclude.some(l)) && h;
    return c[a] = f, f;
  }, s = /* @__PURE__ */ new WeakMap(), i = new Proxy(e, {
    apply(o, a, c) {
      const l = s.get(o);
      if (l)
        return Reflect.apply(l, a, c);
      const d = t.excludeMain ? o : qi(o, t, i, o);
      return s.set(o, d), Reflect.apply(d, a, c);
    },
    get(o, a) {
      const c = o[a];
      if (!r(o, a) || c === Function.prototype[a])
        return c;
      const l = s.get(c);
      if (l)
        return l;
      if (typeof c == "function") {
        const d = qi(c, t, i, o);
        return s.set(c, d), d;
      }
      return c;
    }
  });
  return i;
};
const wh = Tt.default;
let _h = class extends wh {
  constructor() {
    super(), this.updates = [];
  }
  async initialize() {
  }
  async update() {
    throw new Error("BaseFilter - no update method specified");
  }
  addResults(t) {
    this.updates = this.updates.concat(t), t.forEach((n) => this.emit("update", n));
  }
  addInitialResults(t) {
  }
  getChangesAndClear() {
    const t = this.updates;
    return this.updates = [], t;
  }
};
var Ns = _h;
const vh = Ns;
let Eh = class extends vh {
  constructor() {
    super(), this.allResults = [];
  }
  async update() {
    throw new Error("BaseFilterWithHistory - no update method specified");
  }
  addResults(t) {
    this.allResults = this.allResults.concat(t), super.addResults(t);
  }
  addInitialResults(t) {
    this.allResults = this.allResults.concat(t), super.addInitialResults(t);
  }
  getAllResults() {
    return this.allResults;
  }
};
var kh = Eh, Dt = {
  minBlockRef: Ch,
  maxBlockRef: Sh,
  sortBlockRefs: Ts,
  bnToHex: Rh,
  blockRefIsNumber: Ih,
  hexToInt: en,
  incrementHexInt: Mh,
  intToHex: Ma,
  unsafeRandomBytes: Ah
};
function Ch(...e) {
  return Ts(e)[0];
}
function Sh(...e) {
  const t = Ts(e);
  return t[t.length - 1];
}
function Ts(e) {
  return e.sort((t, n) => t === "latest" || n === "earliest" ? 1 : n === "latest" || t === "earliest" ? -1 : en(t) - en(n));
}
function Rh(e) {
  return "0x" + e.toString(16);
}
function Ih(e) {
  return e && !["earliest", "latest", "pending"].includes(e);
}
function en(e) {
  return e == null ? e : Number.parseInt(e, 16);
}
function Mh(e) {
  if (e == null) return e;
  const t = en(e);
  return Ma(t + 1);
}
function Ma(e) {
  if (e == null) return e;
  let t = e.toString(16);
  return t.length % 2 && (t = "0" + t), "0x" + t;
}
function Ah(e) {
  let t = "0x";
  for (let n = 0; n < e; n++)
    t += Gi(), t += Gi();
  return t;
}
function Gi() {
  return Math.floor(Math.random() * 16).toString(16);
}
const Ph = mh, Nh = yh, Th = kh, { bnToHex: Gf, hexToInt: Gt, incrementHexInt: Lh, minBlockRef: xh, blockRefIsNumber: Oh } = Dt;
let Bh = class extends Th {
  constructor({ provider: t, params: n }) {
    super(), this.type = "log", this.ethQuery = new Ph(t), this.params = Object.assign({
      fromBlock: "latest",
      toBlock: "latest",
      address: void 0,
      topics: []
    }, n), this.params.address && (Array.isArray(this.params.address) || (this.params.address = [this.params.address]), this.params.address = this.params.address.map((r) => r.toLowerCase()));
  }
  async initialize({ currentBlock: t }) {
    let n = this.params.fromBlock;
    ["latest", "pending"].includes(n) && (n = t), n === "earliest" && (n = "0x0"), this.params.fromBlock = n;
    const r = xh(this.params.toBlock, t), s = Object.assign({}, this.params, { toBlock: r }), i = await this._fetchLogs(s);
    this.addInitialResults(i);
  }
  async update({ oldBlock: t, newBlock: n }) {
    const r = n;
    let s;
    t ? s = Lh(t) : s = n;
    const i = Object.assign({}, this.params, { fromBlock: s, toBlock: r }), a = (await this._fetchLogs(i)).filter((c) => this.matchLog(c));
    this.addResults(a);
  }
  async _fetchLogs(t) {
    return await Nh((r) => this.ethQuery.getLogs(t, r))();
  }
  matchLog(t) {
    if (Gt(this.params.fromBlock) >= Gt(t.blockNumber) || Oh(this.params.toBlock) && Gt(this.params.toBlock) <= Gt(t.blockNumber)) return !1;
    const n = t.address && t.address.toLowerCase();
    return this.params.address && n && !this.params.address.includes(n) ? !1 : this.params.topics.every((s, i) => {
      let o = t.topics[i];
      if (!o) return !1;
      o = o.toLowerCase();
      let a = Array.isArray(s) ? s : [s];
      return a.includes(null) ? !0 : (a = a.map((d) => d.toLowerCase()), a.includes(o));
    });
  }
};
var Fh = Bh, Ls = jh;
async function jh({ provider: e, fromBlock: t, toBlock: n }) {
  t || (t = n);
  const r = Qi(t), i = Qi(n) - r + 1, o = Array(i).fill().map((c, l) => r + l).map(Dh);
  let a = await Promise.all(
    o.map((c) => Hh(e, "eth_getBlockByNumber", [c, !1]))
  );
  return a = a.filter((c) => c !== null), a;
}
function Qi(e) {
  return e == null ? e : Number.parseInt(e, 16);
}
function Dh(e) {
  return e == null ? e : "0x" + e.toString(16);
}
function $h(e, t) {
  return new Promise((n, r) => {
    e.sendAsync(t, (s, i) => {
      s ? r(s) : i.error ? r(i.error) : i.result ? n(i.result) : r(new Error("Result was empty"));
    });
  });
}
async function Hh(e, t, n) {
  for (let r = 0; r < 3; r++)
    try {
      return await $h(e, {
        id: 1,
        jsonrpc: "2.0",
        method: t,
        params: n
      });
    } catch {
    }
  return null;
}
const Uh = Ns, Wh = Ls, { incrementHexInt: zh } = Dt;
let Vh = class extends Uh {
  constructor({ provider: t, params: n }) {
    super(), this.type = "block", this.provider = t;
  }
  async update({ oldBlock: t, newBlock: n }) {
    const r = n, s = zh(t), o = (await Wh({ provider: this.provider, fromBlock: s, toBlock: r })).map((a) => a.hash);
    this.addResults(o);
  }
};
var Jh = Vh;
const qh = Ns, Zh = Ls, { incrementHexInt: Gh } = Dt;
let Qh = class extends qh {
  constructor({ provider: t }) {
    super(), this.type = "tx", this.provider = t;
  }
  async update({ oldBlock: t }) {
    const n = t, r = Gh(t), s = await Zh({ provider: this.provider, fromBlock: r, toBlock: n }), i = [];
    for (const o of s)
      i.push(...o.transactions);
    this.addResults(i);
  }
};
var Kh = Qh;
const Yh = Ia.Mutex, { createAsyncMiddleware: Xh, createScaffoldMiddleware: ef } = Ss, tf = Fh, nf = Jh, rf = Kh, { intToHex: Aa, hexToInt: Qr } = Dt;
var sf = of;
function of({ blockTracker: e, provider: t }) {
  let n = 0, r = {};
  const s = new Yh(), i = af({ mutex: s }), o = ef({
    // install filters
    eth_newFilter: i(Kr(c)),
    eth_newBlockFilter: i(Kr(l)),
    eth_newPendingTransactionFilter: i(Kr(d)),
    // uninstall filters
    eth_uninstallFilter: i(Kt(f)),
    // checking filter changes
    eth_getFilterChanges: i(Kt(h)),
    eth_getFilterLogs: i(Kt(u))
  }), a = async ({ oldBlock: y, newBlock: g }) => {
    if (r.length === 0) return;
    const M = await s.acquire();
    try {
      await Promise.all(Je(r).map(async (p) => {
        try {
          await p.update({ oldBlock: y, newBlock: g });
        } catch {
        }
      }));
    } catch {
    }
    M();
  };
  return o.newLogFilter = c, o.newBlockFilter = l, o.newPendingTransactionFilter = d, o.uninstallFilter = f, o.getFilterChanges = h, o.getFilterLogs = u, o.destroy = () => {
    _();
  }, o;
  async function c(y) {
    const g = new tf({ provider: t, params: y });
    return await b(g), g;
  }
  async function l() {
    const y = new nf({ provider: t });
    return await b(y), y;
  }
  async function d() {
    const y = new rf({ provider: t });
    return await b(y), y;
  }
  async function h(y) {
    const g = Qr(y), M = r[g];
    if (!M)
      throw new Error(`No filter for index "${g}"`);
    return M.getChangesAndClear();
  }
  async function u(y) {
    const g = Qr(y), M = r[g];
    if (!M)
      throw new Error(`No filter for index "${g}"`);
    let p = [];
    return M.type === "log" && (p = M.getAllResults()), p;
  }
  async function f(y) {
    const g = Qr(y), p = !!r[g];
    return p && await w(g), p;
  }
  async function b(y) {
    const g = Je(r).length, M = await e.getLatestBlock();
    await y.initialize({ currentBlock: M }), n++, r[n] = y, y.id = n, y.idHex = Aa(n);
    const p = Je(r).length;
    return k({ prevFilterCount: g, newFilterCount: p }), n;
  }
  async function w(y) {
    const g = Je(r).length;
    delete r[y];
    const M = Je(r).length;
    k({ prevFilterCount: g, newFilterCount: M });
  }
  async function _() {
    const y = Je(r).length;
    r = {}, k({ prevFilterCount: y, newFilterCount: 0 });
  }
  function k({ prevFilterCount: y, newFilterCount: g }) {
    if (y === 0 && g > 0) {
      e.on("sync", a);
      return;
    }
    if (y > 0 && g === 0) {
      e.removeListener("sync", a);
      return;
    }
  }
}
function Kr(e) {
  return Kt(async (...t) => {
    const n = await e(...t);
    return Aa(n.id);
  });
}
function Kt(e) {
  return Xh(async (t, n) => {
    const r = await e.apply(null, t.params);
    n.result = r;
  });
}
function af({ mutex: e }) {
  return (t) => async (n, r, s, i) => {
    (await e.acquire())(), t(n, r, s, i);
  };
}
function Je(e, t) {
  const n = [];
  for (let r in e)
    n.push(e[r]);
  return n;
}
const cf = Tt.default, { createAsyncMiddleware: Ki, createScaffoldMiddleware: lf } = Ss, df = sf, { unsafeRandomBytes: uf, incrementHexInt: hf } = Dt, ff = Ls;
var gf = pf;
function pf({ blockTracker: e, provider: t }) {
  const n = {}, r = df({ blockTracker: e, provider: t });
  let s = !1;
  const i = new cf(), o = lf({
    eth_subscribe: Ki(a),
    eth_unsubscribe: Ki(c)
  });
  return o.destroy = d, { events: i, middleware: o };
  async function a(h, u) {
    if (s) throw new Error(
      "SubscriptionManager - attempting to use after destroying"
    );
    const f = h.params[0], b = uf(16);
    let w;
    switch (f) {
      case "newHeads":
        w = _({ subId: b });
        break;
      case "logs":
        const y = h.params[1], g = await r.newLogFilter(y);
        w = k({ subId: b, filter: g });
        break;
      default:
        throw new Error(`SubscriptionManager - unsupported subscription type "${f}"`);
    }
    n[b] = w, u.result = b;
    return;
    function _({ subId: y }) {
      const g = {
        type: f,
        destroy: async () => {
          e.removeListener("sync", g.update);
        },
        update: async ({ oldBlock: M, newBlock: p }) => {
          const C = p, T = hf(M);
          (await ff({ provider: t, fromBlock: T, toBlock: C })).map(mf).filter((j) => j !== null).forEach((j) => {
            l(y, j);
          });
        }
      };
      return e.on("sync", g.update), g;
    }
    function k({ subId: y, filter: g }) {
      return g.on("update", (p) => l(y, p)), {
        type: f,
        destroy: async () => await r.uninstallFilter(g.idHex)
      };
    }
  }
  async function c(h, u) {
    if (s) throw new Error(
      "SubscriptionManager - attempting to use after destroying"
    );
    const f = h.params[0], b = n[f];
    if (!b) {
      u.result = !1;
      return;
    }
    delete n[f], await b.destroy(), u.result = !0;
  }
  function l(h, u) {
    i.emit("notification", {
      jsonrpc: "2.0",
      method: "eth_subscription",
      params: {
        subscription: h,
        result: u
      }
    });
  }
  function d() {
    i.removeAllListeners();
    for (const h in n)
      n[h].destroy(), delete n[h];
    s = !0;
  }
}
function mf(e) {
  return e == null ? null : {
    hash: e.hash,
    parentHash: e.parentHash,
    sha3Uncles: e.sha3Uncles,
    miner: e.miner,
    stateRoot: e.stateRoot,
    transactionsRoot: e.transactionsRoot,
    receiptsRoot: e.receiptsRoot,
    logsBloom: e.logsBloom,
    difficulty: e.difficulty,
    number: e.number,
    gasLimit: e.gasLimit,
    gasUsed: e.gasUsed,
    nonce: e.nonce,
    mixHash: e.mixHash,
    timestamp: e.timestamp,
    extraData: e.extraData
  };
}
Object.defineProperty(In, "__esModule", { value: !0 });
In.SubscriptionManager = void 0;
const bf = Uo, yf = gf, Yi = () => {
};
class wf {
  constructor(t) {
    const n = new bf.PollingBlockTracker({
      provider: t,
      pollingInterval: 15e3,
      setSkipCacheFlag: !0
    }), { events: r, middleware: s } = yf({
      blockTracker: n,
      provider: t
    });
    this.events = r, this.subscriptionMiddleware = s;
  }
  async handleRequest(t) {
    const n = {};
    return await this.subscriptionMiddleware(t, n, Yi, Yi), n;
  }
  destroy() {
    this.subscriptionMiddleware.destroy();
  }
}
In.SubscriptionManager = wf;
var Pa = v && v.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Xe, "__esModule", { value: !0 });
Xe.CoinbaseWalletProvider = void 0;
const _f = Pa(tn), vf = Oa, A = vt, S = m, Ef = St, Xi = oe, Qt = ct, ee = it, Yr = Pa(Vl), mt = at, kf = nt, Cf = In, eo = "DefaultChainId", to = "DefaultJsonRpcUrl";
class Sf extends vf.EventEmitter {
  constructor(t) {
    var n, r;
    super(), this._filterPolyfill = new kf.FilterPolyfill(this), this._subscriptionManager = new Cf.SubscriptionManager(this), this._relay = null, this._addresses = [], this.hasMadeFirstChainChangedEmission = !1, this.setProviderInfo = this.setProviderInfo.bind(this), this.updateProviderInfo = this.updateProviderInfo.bind(this), this.getChainId = this.getChainId.bind(this), this.setAppInfo = this.setAppInfo.bind(this), this.enable = this.enable.bind(this), this.close = this.close.bind(this), this.send = this.send.bind(this), this.sendAsync = this.sendAsync.bind(this), this.request = this.request.bind(this), this._setAddresses = this._setAddresses.bind(this), this.scanQRCode = this.scanQRCode.bind(this), this.genericRequest = this.genericRequest.bind(this), this._chainIdFromOpts = t.chainId, this._jsonRpcUrlFromOpts = t.jsonRpcUrl, this._overrideIsMetaMask = t.overrideIsMetaMask, this._relayProvider = t.relayProvider, this._storage = t.storage, this._relayEventManager = t.relayEventManager, this.diagnostic = t.diagnosticLogger, this.reloadOnDisconnect = !0, this.isCoinbaseWallet = (n = t.overrideIsCoinbaseWallet) !== null && n !== void 0 ? n : !0, this.isCoinbaseBrowser = (r = t.overrideIsCoinbaseBrowser) !== null && r !== void 0 ? r : !1, this.qrUrl = t.qrUrl;
    const s = this.getChainId(), i = (0, S.prepend0x)(s.toString(16));
    this.emit("connect", { chainIdStr: i });
    const o = this._storage.getItem(Xi.LOCAL_STORAGE_ADDRESSES_KEY);
    if (o) {
      const a = o.split(" ");
      a[0] !== "" && (this._addresses = a.map((c) => (0, S.ensureAddressString)(c)), this.emit("accountsChanged", a));
    }
    this._subscriptionManager.events.on("notification", (a) => {
      this.emit("message", {
        type: a.method,
        data: a.params
      });
    }), this._isAuthorized() && this.initializeRelay(), window.addEventListener("message", (a) => {
      var c;
      if (!(a.origin !== location.origin || a.source !== window) && a.data.type === "walletLinkMessage" && a.data.data.action === "dappChainSwitched") {
        const l = a.data.data.chainId, d = (c = a.data.data.jsonRpcUrl) !== null && c !== void 0 ? c : this.jsonRpcUrl;
        this.updateProviderInfo(d, Number(l));
      }
    });
  }
  /** @deprecated Use `.request({ method: 'eth_accounts' })` instead. */
  get selectedAddress() {
    return this._addresses[0] || void 0;
  }
  /** @deprecated Use the chain ID. If you still need the network ID, use `.request({ method: 'net_version' })`. */
  get networkVersion() {
    return this.getChainId().toString(10);
  }
  /** @deprecated Use `.request({ method: 'eth_chainId' })` instead. */
  get chainId() {
    return (0, S.prepend0x)(this.getChainId().toString(16));
  }
  get isWalletLink() {
    return !0;
  }
  /**
   * Some DApps (i.e. Alpha Homora) seem to require the window.ethereum object return
   * true for this method.
   */
  get isMetaMask() {
    return this._overrideIsMetaMask;
  }
  get host() {
    return this.jsonRpcUrl;
  }
  get connected() {
    return !0;
  }
  isConnected() {
    return !0;
  }
  get jsonRpcUrl() {
    var t;
    return (t = this._storage.getItem(to)) !== null && t !== void 0 ? t : this._jsonRpcUrlFromOpts;
  }
  set jsonRpcUrl(t) {
    this._storage.setItem(to, t);
  }
  disableReloadOnDisconnect() {
    this.reloadOnDisconnect = !1;
  }
  setProviderInfo(t, n) {
    this.isCoinbaseBrowser || (this._chainIdFromOpts = n, this._jsonRpcUrlFromOpts = t), this.updateProviderInfo(this.jsonRpcUrl, this.getChainId());
  }
  updateProviderInfo(t, n) {
    this.jsonRpcUrl = t;
    const r = this.getChainId();
    this._storage.setItem(eo, n.toString(10)), ((0, S.ensureIntNumber)(n) !== r || !this.hasMadeFirstChainChangedEmission) && (this.emit("chainChanged", this.getChainId()), this.hasMadeFirstChainChangedEmission = !0);
  }
  async watchAsset(t, n, r, s, i, o) {
    const c = await (await this.initializeRelay()).watchAsset(t, n, r, s, i, o == null ? void 0 : o.toString()).promise;
    return (0, ee.isErrorResponse)(c) ? !1 : !!c.result;
  }
  async addEthereumChain(t, n, r, s, i, o) {
    var a, c;
    if ((0, S.ensureIntNumber)(t) === this.getChainId())
      return !1;
    const l = await this.initializeRelay(), d = l.inlineAddEthereumChain(t.toString());
    !this._isAuthorized() && !d && await l.requestEthereumAccounts().promise;
    const h = await l.addEthereumChain(t.toString(), n, i, r, s, o).promise;
    return (0, ee.isErrorResponse)(h) ? !1 : (((a = h.result) === null || a === void 0 ? void 0 : a.isApproved) === !0 && this.updateProviderInfo(n[0], t), ((c = h.result) === null || c === void 0 ? void 0 : c.isApproved) === !0);
  }
  async switchEthereumChain(t) {
    const r = await (await this.initializeRelay()).switchEthereumChain(t.toString(10), this.selectedAddress || void 0).promise;
    if ((0, ee.isErrorResponse)(r)) {
      if (!r.errorCode)
        return;
      throw r.errorCode === A.standardErrorCodes.provider.unsupportedChain ? A.standardErrors.provider.unsupportedChain() : A.standardErrors.provider.custom({
        message: r.errorMessage,
        code: r.errorCode
      });
    }
    const s = r.result;
    s.isApproved && s.rpcUrl.length > 0 && this.updateProviderInfo(s.rpcUrl, t);
  }
  setAppInfo(t, n) {
    this.initializeRelay().then((r) => r.setAppInfo(t, n));
  }
  /** @deprecated Use `.request({ method: 'eth_requestAccounts' })` instead. */
  async enable() {
    var t;
    return (t = this.diagnostic) === null || t === void 0 || t.log(mt.EVENTS.ETH_ACCOUNTS_STATE, {
      method: "provider::enable",
      addresses_length: this._addresses.length,
      sessionIdHash: this._relay ? Qt.Session.hash(this._relay.session.id) : void 0
    }), this._isAuthorized() ? [...this._addresses] : await this.send("eth_requestAccounts");
  }
  async close() {
    (await this.initializeRelay()).resetAndReload();
  }
  send(t, n) {
    try {
      const r = this._send(t, n);
      if (r instanceof Promise)
        return r.catch((s) => {
          throw (0, A.serializeError)(s, t);
        });
    } catch (r) {
      throw (0, A.serializeError)(r, t);
    }
  }
  _send(t, n) {
    if (typeof t == "string") {
      const s = t, i = Array.isArray(n) ? n : n !== void 0 ? [n] : [], o = {
        jsonrpc: "2.0",
        id: 0,
        method: s,
        params: i
      };
      return this._sendRequestAsync(o).then((a) => a.result);
    }
    if (typeof n == "function") {
      const s = t, i = n;
      return this._sendAsync(s, i);
    }
    if (Array.isArray(t))
      return t.map((i) => this._sendRequest(i));
    const r = t;
    return this._sendRequest(r);
  }
  async sendAsync(t, n) {
    try {
      return this._sendAsync(t, n).catch((r) => {
        throw (0, A.serializeError)(r, t);
      });
    } catch (r) {
      return Promise.reject((0, A.serializeError)(r, t));
    }
  }
  async _sendAsync(t, n) {
    if (typeof n != "function")
      throw new Error("callback is required");
    if (Array.isArray(t)) {
      const s = n;
      this._sendMultipleRequestsAsync(t).then((i) => s(null, i)).catch((i) => s(i, null));
      return;
    }
    const r = n;
    return this._sendRequestAsync(t).then((s) => r(null, s)).catch((s) => r(s, null));
  }
  async request(t) {
    try {
      return this._request(t).catch((n) => {
        throw (0, A.serializeError)(n, t.method);
      });
    } catch (n) {
      return Promise.reject((0, A.serializeError)(n, t.method));
    }
  }
  async _request(t) {
    if (!t || typeof t != "object" || Array.isArray(t))
      throw A.standardErrors.rpc.invalidRequest({
        message: "Expected a single, non-array, object argument.",
        data: t
      });
    const { method: n, params: r } = t;
    if (typeof n != "string" || n.length === 0)
      throw A.standardErrors.rpc.invalidRequest({
        message: "'args.method' must be a non-empty string.",
        data: t
      });
    if (r !== void 0 && !Array.isArray(r) && (typeof r != "object" || r === null))
      throw A.standardErrors.rpc.invalidRequest({
        message: "'args.params' must be an object or array if provided.",
        data: t
      });
    const s = r === void 0 ? [] : r, i = this._relayEventManager.makeRequestId();
    return (await this._sendRequestAsync({
      method: n,
      params: s,
      jsonrpc: "2.0",
      id: i
    })).result;
  }
  async scanQRCode(t) {
    const r = await (await this.initializeRelay()).scanQRCode((0, S.ensureRegExpString)(t)).promise;
    if ((0, ee.isErrorResponse)(r))
      throw (0, A.serializeError)(r.errorMessage, "scanQRCode");
    if (typeof r.result != "string")
      throw (0, A.serializeError)("result was not a string", "scanQRCode");
    return r.result;
  }
  async genericRequest(t, n) {
    const s = await (await this.initializeRelay()).genericRequest(t, n).promise;
    if ((0, ee.isErrorResponse)(s))
      throw (0, A.serializeError)(s.errorMessage, "generic");
    if (typeof s.result != "string")
      throw (0, A.serializeError)("result was not a string", "generic");
    return s.result;
  }
  /**
   * @beta
   * This method is currently in beta. While it is available for use, please note that it is still under testing and may undergo significant changes.
   *
   * @remarks
   * IMPORTANT: Signature validation is not performed by this method. Users of this method are advised to perform their own signature validation.
   * Common web3 frontend libraries such as ethers.js and viem provide the `verifyMessage` utility function that can be used for signature validation.
   *
   * It combines `eth_requestAccounts` and "Sign-In with Ethereum" (EIP-4361) into a single call.
   * The returned account and signed message can be used to authenticate the user.
   *
   * @param {Object} params - An object with the following properties:
   * - `nonce` {string}: A unique string to prevent replay attacks.
   * - `statement` {string}: An optional human-readable ASCII assertion that the user will sign.
   * - `resources` {string[]}: An optional list of information the user wishes to have resolved as part of authentication by the relying party.
   *
   * @returns {Promise<ConnectAndSignInResponse>} A promise that resolves to an object with the following properties:
   * - `accounts` {string[]}: The Ethereum accounts of the user.
   * - `message` {string}: The overall message that the user signed. Hex encoded.
   * - `signature` {string}: The signature of the message, signed with the user's private key. Hex encoded.
   */
  async connectAndSignIn(t) {
    var n;
    (n = this.diagnostic) === null || n === void 0 || n.log(mt.EVENTS.ETH_ACCOUNTS_STATE, {
      method: "provider::connectAndSignIn",
      sessionIdHash: this._relay ? Qt.Session.hash(this._relay.session.id) : void 0
    });
    let r;
    try {
      const i = await this.initializeRelay();
      if (!(i instanceof Ef.MobileRelay))
        throw new Error("connectAndSignIn is only supported on mobile");
      if (r = await i.connectAndSignIn(t).promise, (0, ee.isErrorResponse)(r))
        throw new Error(r.errorMessage);
    } catch (i) {
      throw typeof i.message == "string" && i.message.match(/(denied|rejected)/i) ? A.standardErrors.provider.userRejectedRequest("User denied account authorization") : i;
    }
    if (!r.result)
      throw new Error("accounts received is empty");
    const { accounts: s } = r.result;
    return this._setAddresses(s), this.isCoinbaseBrowser || await this.switchEthereumChain(this.getChainId()), r.result;
  }
  async selectProvider(t) {
    const r = await (await this.initializeRelay()).selectProvider(t).promise;
    if ((0, ee.isErrorResponse)(r))
      throw (0, A.serializeError)(r.errorMessage, "selectProvider");
    if (typeof r.result != "string")
      throw (0, A.serializeError)("result was not a string", "selectProvider");
    return r.result;
  }
  supportsSubscriptions() {
    return !1;
  }
  subscribe() {
    throw new Error("Subscriptions are not supported");
  }
  unsubscribe() {
    throw new Error("Subscriptions are not supported");
  }
  disconnect() {
    return !0;
  }
  _sendRequest(t) {
    const n = {
      jsonrpc: "2.0",
      id: t.id
    }, { method: r } = t;
    if (n.result = this._handleSynchronousMethods(t), n.result === void 0)
      throw new Error(`Coinbase Wallet does not support calling ${r} synchronously without a callback. Please provide a callback parameter to call ${r} asynchronously.`);
    return n;
  }
  _setAddresses(t, n) {
    if (!Array.isArray(t))
      throw new Error("addresses is not an array");
    const r = t.map((s) => (0, S.ensureAddressString)(s));
    JSON.stringify(r) !== JSON.stringify(this._addresses) && (this._addresses = r, this.emit("accountsChanged", this._addresses), this._storage.setItem(Xi.LOCAL_STORAGE_ADDRESSES_KEY, r.join(" ")));
  }
  _sendRequestAsync(t) {
    return new Promise((n, r) => {
      try {
        const s = this._handleSynchronousMethods(t);
        if (s !== void 0)
          return n({
            jsonrpc: "2.0",
            id: t.id,
            result: s
          });
        const i = this._handleAsynchronousFilterMethods(t);
        if (i !== void 0) {
          i.then((a) => n(Object.assign(Object.assign({}, a), { id: t.id }))).catch((a) => r(a));
          return;
        }
        const o = this._handleSubscriptionMethods(t);
        if (o !== void 0) {
          o.then((a) => n({
            jsonrpc: "2.0",
            id: t.id,
            result: a.result
          })).catch((a) => r(a));
          return;
        }
      } catch (s) {
        return r(s);
      }
      this._handleAsynchronousMethods(t).then((s) => s && n(Object.assign(Object.assign({}, s), { id: t.id }))).catch((s) => r(s));
    });
  }
  _sendMultipleRequestsAsync(t) {
    return Promise.all(t.map((n) => this._sendRequestAsync(n)));
  }
  _handleSynchronousMethods(t) {
    const { method: n } = t, r = t.params || [];
    switch (n) {
      case "eth_accounts":
        return this._eth_accounts();
      case "eth_coinbase":
        return this._eth_coinbase();
      case "eth_uninstallFilter":
        return this._eth_uninstallFilter(r);
      case "net_version":
        return this._net_version();
      case "eth_chainId":
        return this._eth_chainId();
      default:
        return;
    }
  }
  async _handleAsynchronousMethods(t) {
    const { method: n } = t, r = t.params || [];
    switch (n) {
      case "eth_requestAccounts":
        return this._eth_requestAccounts();
      case "eth_sign":
        return this._eth_sign(r);
      case "eth_ecRecover":
        return this._eth_ecRecover(r);
      case "personal_sign":
        return this._personal_sign(r);
      case "personal_ecRecover":
        return this._personal_ecRecover(r);
      case "eth_signTransaction":
        return this._eth_signTransaction(r);
      case "eth_sendRawTransaction":
        return this._eth_sendRawTransaction(r);
      case "eth_sendTransaction":
        return this._eth_sendTransaction(r);
      case "eth_signTypedData_v1":
        return this._eth_signTypedData_v1(r);
      case "eth_signTypedData_v2":
        return this._throwUnsupportedMethodError();
      case "eth_signTypedData_v3":
        return this._eth_signTypedData_v3(r);
      case "eth_signTypedData_v4":
      case "eth_signTypedData":
        return this._eth_signTypedData_v4(r);
      case "cbWallet_arbitrary":
        return this._cbwallet_arbitrary(r);
      case "wallet_addEthereumChain":
        return this._wallet_addEthereumChain(r);
      case "wallet_switchEthereumChain":
        return this._wallet_switchEthereumChain(r);
      case "wallet_watchAsset":
        return this._wallet_watchAsset(r);
    }
    return (await this.initializeRelay()).makeEthereumJSONRPCRequest(t, this.jsonRpcUrl).catch((i) => {
      var o;
      throw (i.code === A.standardErrorCodes.rpc.methodNotFound || i.code === A.standardErrorCodes.rpc.methodNotSupported) && ((o = this.diagnostic) === null || o === void 0 || o.log(mt.EVENTS.METHOD_NOT_IMPLEMENTED, {
        method: t.method,
        sessionIdHash: this._relay ? Qt.Session.hash(this._relay.session.id) : void 0
      })), i;
    });
  }
  _handleAsynchronousFilterMethods(t) {
    const { method: n } = t, r = t.params || [];
    switch (n) {
      case "eth_newFilter":
        return this._eth_newFilter(r);
      case "eth_newBlockFilter":
        return this._eth_newBlockFilter();
      case "eth_newPendingTransactionFilter":
        return this._eth_newPendingTransactionFilter();
      case "eth_getFilterChanges":
        return this._eth_getFilterChanges(r);
      case "eth_getFilterLogs":
        return this._eth_getFilterLogs(r);
    }
  }
  _handleSubscriptionMethods(t) {
    switch (t.method) {
      case "eth_subscribe":
      case "eth_unsubscribe":
        return this._subscriptionManager.handleRequest(t);
    }
  }
  _isKnownAddress(t) {
    try {
      const n = (0, S.ensureAddressString)(t);
      return this._addresses.map((s) => (0, S.ensureAddressString)(s)).includes(n);
    } catch {
    }
    return !1;
  }
  _ensureKnownAddress(t) {
    var n;
    if (!this._isKnownAddress(t))
      throw (n = this.diagnostic) === null || n === void 0 || n.log(mt.EVENTS.UNKNOWN_ADDRESS_ENCOUNTERED), new Error("Unknown Ethereum address");
  }
  _prepareTransactionParams(t) {
    const n = t.from ? (0, S.ensureAddressString)(t.from) : this.selectedAddress;
    if (!n)
      throw new Error("Ethereum address is unavailable");
    this._ensureKnownAddress(n);
    const r = t.to ? (0, S.ensureAddressString)(t.to) : null, s = t.value != null ? (0, S.ensureBN)(t.value) : new _f.default(0), i = t.data ? (0, S.ensureBuffer)(t.data) : R.alloc(0), o = t.nonce != null ? (0, S.ensureIntNumber)(t.nonce) : null, a = t.gasPrice != null ? (0, S.ensureBN)(t.gasPrice) : null, c = t.maxFeePerGas != null ? (0, S.ensureBN)(t.maxFeePerGas) : null, l = t.maxPriorityFeePerGas != null ? (0, S.ensureBN)(t.maxPriorityFeePerGas) : null, d = t.gas != null ? (0, S.ensureBN)(t.gas) : null, h = t.chainId ? (0, S.ensureIntNumber)(t.chainId) : this.getChainId();
    return {
      fromAddress: n,
      toAddress: r,
      weiValue: s,
      data: i,
      nonce: o,
      gasPriceInWei: a,
      maxFeePerGas: c,
      maxPriorityFeePerGas: l,
      gasLimit: d,
      chainId: h
    };
  }
  _isAuthorized() {
    return this._addresses.length > 0;
  }
  _requireAuthorization() {
    if (!this._isAuthorized())
      throw A.standardErrors.provider.unauthorized({});
  }
  _throwUnsupportedMethodError() {
    throw A.standardErrors.provider.unsupportedMethod({});
  }
  async _signEthereumMessage(t, n, r, s) {
    this._ensureKnownAddress(n);
    try {
      const o = await (await this.initializeRelay()).signEthereumMessage(t, n, r, s).promise;
      if ((0, ee.isErrorResponse)(o))
        throw new Error(o.errorMessage);
      return { jsonrpc: "2.0", id: 0, result: o.result };
    } catch (i) {
      throw typeof i.message == "string" && i.message.match(/(denied|rejected)/i) ? A.standardErrors.provider.userRejectedRequest("User denied message signature") : i;
    }
  }
  async _ethereumAddressFromSignedMessage(t, n, r) {
    const i = await (await this.initializeRelay()).ethereumAddressFromSignedMessage(t, n, r).promise;
    if ((0, ee.isErrorResponse)(i))
      throw new Error(i.errorMessage);
    return { jsonrpc: "2.0", id: 0, result: i.result };
  }
  _eth_accounts() {
    return [...this._addresses];
  }
  _eth_coinbase() {
    return this.selectedAddress || null;
  }
  _net_version() {
    return this.getChainId().toString(10);
  }
  _eth_chainId() {
    return (0, S.hexStringFromIntNumber)(this.getChainId());
  }
  getChainId() {
    const t = this._storage.getItem(eo);
    if (!t)
      return (0, S.ensureIntNumber)(this._chainIdFromOpts);
    const n = parseInt(t, 10);
    return (0, S.ensureIntNumber)(n);
  }
  async _eth_requestAccounts() {
    var t;
    if ((t = this.diagnostic) === null || t === void 0 || t.log(mt.EVENTS.ETH_ACCOUNTS_STATE, {
      method: "provider::_eth_requestAccounts",
      addresses_length: this._addresses.length,
      sessionIdHash: this._relay ? Qt.Session.hash(this._relay.session.id) : void 0
    }), this._isAuthorized())
      return Promise.resolve({
        jsonrpc: "2.0",
        id: 0,
        result: this._addresses
      });
    let n;
    try {
      if (n = await (await this.initializeRelay()).requestEthereumAccounts().promise, (0, ee.isErrorResponse)(n))
        throw new Error(n.errorMessage);
    } catch (r) {
      throw typeof r.message == "string" && r.message.match(/(denied|rejected)/i) ? A.standardErrors.provider.userRejectedRequest("User denied account authorization") : r;
    }
    if (!n.result)
      throw new Error("accounts received is empty");
    return this._setAddresses(n.result), this.isCoinbaseBrowser || await this.switchEthereumChain(this.getChainId()), { jsonrpc: "2.0", id: 0, result: this._addresses };
  }
  _eth_sign(t) {
    this._requireAuthorization();
    const n = (0, S.ensureAddressString)(t[0]), r = (0, S.ensureBuffer)(t[1]);
    return this._signEthereumMessage(r, n, !1);
  }
  _eth_ecRecover(t) {
    const n = (0, S.ensureBuffer)(t[0]), r = (0, S.ensureBuffer)(t[1]);
    return this._ethereumAddressFromSignedMessage(n, r, !1);
  }
  _personal_sign(t) {
    this._requireAuthorization();
    const n = (0, S.ensureBuffer)(t[0]), r = (0, S.ensureAddressString)(t[1]);
    return this._signEthereumMessage(n, r, !0);
  }
  _personal_ecRecover(t) {
    const n = (0, S.ensureBuffer)(t[0]), r = (0, S.ensureBuffer)(t[1]);
    return this._ethereumAddressFromSignedMessage(n, r, !0);
  }
  async _eth_signTransaction(t) {
    this._requireAuthorization();
    const n = this._prepareTransactionParams(t[0] || {});
    try {
      const s = await (await this.initializeRelay()).signEthereumTransaction(n).promise;
      if ((0, ee.isErrorResponse)(s))
        throw new Error(s.errorMessage);
      return { jsonrpc: "2.0", id: 0, result: s.result };
    } catch (r) {
      throw typeof r.message == "string" && r.message.match(/(denied|rejected)/i) ? A.standardErrors.provider.userRejectedRequest("User denied transaction signature") : r;
    }
  }
  async _eth_sendRawTransaction(t) {
    const n = (0, S.ensureBuffer)(t[0]), s = await (await this.initializeRelay()).submitEthereumTransaction(n, this.getChainId()).promise;
    if ((0, ee.isErrorResponse)(s))
      throw new Error(s.errorMessage);
    return { jsonrpc: "2.0", id: 0, result: s.result };
  }
  async _eth_sendTransaction(t) {
    this._requireAuthorization();
    const n = this._prepareTransactionParams(t[0] || {});
    try {
      const s = await (await this.initializeRelay()).signAndSubmitEthereumTransaction(n).promise;
      if ((0, ee.isErrorResponse)(s))
        throw new Error(s.errorMessage);
      return { jsonrpc: "2.0", id: 0, result: s.result };
    } catch (r) {
      throw typeof r.message == "string" && r.message.match(/(denied|rejected)/i) ? A.standardErrors.provider.userRejectedRequest("User denied transaction signature") : r;
    }
  }
  async _eth_signTypedData_v1(t) {
    this._requireAuthorization();
    const n = (0, S.ensureParsedJSONObject)(t[0]), r = (0, S.ensureAddressString)(t[1]);
    this._ensureKnownAddress(r);
    const s = Yr.default.hashForSignTypedDataLegacy({ data: n }), i = JSON.stringify(n, null, 2);
    return this._signEthereumMessage(s, r, !1, i);
  }
  async _eth_signTypedData_v3(t) {
    this._requireAuthorization();
    const n = (0, S.ensureAddressString)(t[0]), r = (0, S.ensureParsedJSONObject)(t[1]);
    this._ensureKnownAddress(n);
    const s = Yr.default.hashForSignTypedData_v3({ data: r }), i = JSON.stringify(r, null, 2);
    return this._signEthereumMessage(s, n, !1, i);
  }
  async _eth_signTypedData_v4(t) {
    this._requireAuthorization();
    const n = (0, S.ensureAddressString)(t[0]), r = (0, S.ensureParsedJSONObject)(t[1]);
    this._ensureKnownAddress(n);
    const s = Yr.default.hashForSignTypedData_v4({ data: r }), i = JSON.stringify(r, null, 2);
    return this._signEthereumMessage(s, n, !1, i);
  }
  /** @deprecated */
  async _cbwallet_arbitrary(t) {
    const n = t[0], r = t[1];
    if (typeof r != "string")
      throw new Error("parameter must be a string");
    if (typeof n != "object" || n === null)
      throw new Error("parameter must be an object");
    return { jsonrpc: "2.0", id: 0, result: await this.genericRequest(n, r) };
  }
  async _wallet_addEthereumChain(t) {
    var n, r, s, i;
    const o = t[0];
    if (((n = o.rpcUrls) === null || n === void 0 ? void 0 : n.length) === 0)
      return {
        jsonrpc: "2.0",
        id: 0,
        error: { code: 2, message: "please pass in at least 1 rpcUrl" }
      };
    if (!o.chainName || o.chainName.trim() === "")
      throw A.standardErrors.rpc.invalidParams("chainName is a required field");
    if (!o.nativeCurrency)
      throw A.standardErrors.rpc.invalidParams("nativeCurrency is a required field");
    const a = parseInt(o.chainId, 16);
    return await this.addEthereumChain(a, (r = o.rpcUrls) !== null && r !== void 0 ? r : [], (s = o.blockExplorerUrls) !== null && s !== void 0 ? s : [], o.chainName, (i = o.iconUrls) !== null && i !== void 0 ? i : [], o.nativeCurrency) ? { jsonrpc: "2.0", id: 0, result: null } : {
      jsonrpc: "2.0",
      id: 0,
      error: { code: 2, message: "unable to add ethereum chain" }
    };
  }
  async _wallet_switchEthereumChain(t) {
    const n = t[0];
    return await this.switchEthereumChain(parseInt(n.chainId, 16)), { jsonrpc: "2.0", id: 0, result: null };
  }
  async _wallet_watchAsset(t) {
    const n = Array.isArray(t) ? t[0] : t;
    if (!n.type)
      throw A.standardErrors.rpc.invalidParams("Type is required");
    if ((n == null ? void 0 : n.type) !== "ERC20")
      throw A.standardErrors.rpc.invalidParams(`Asset of type '${n.type}' is not supported`);
    if (!(n != null && n.options))
      throw A.standardErrors.rpc.invalidParams("Options are required");
    if (!(n != null && n.options.address))
      throw A.standardErrors.rpc.invalidParams("Address is required");
    const r = this.getChainId(), { address: s, symbol: i, image: o, decimals: a } = n.options;
    return { jsonrpc: "2.0", id: 0, result: await this.watchAsset(n.type, s, i, a, o, r) };
  }
  _eth_uninstallFilter(t) {
    const n = (0, S.ensureHexString)(t[0]);
    return this._filterPolyfill.uninstallFilter(n);
  }
  async _eth_newFilter(t) {
    const n = t[0];
    return { jsonrpc: "2.0", id: 0, result: await this._filterPolyfill.newFilter(n) };
  }
  async _eth_newBlockFilter() {
    return { jsonrpc: "2.0", id: 0, result: await this._filterPolyfill.newBlockFilter() };
  }
  async _eth_newPendingTransactionFilter() {
    return { jsonrpc: "2.0", id: 0, result: await this._filterPolyfill.newPendingTransactionFilter() };
  }
  _eth_getFilterChanges(t) {
    const n = (0, S.ensureHexString)(t[0]);
    return this._filterPolyfill.getFilterChanges(n);
  }
  _eth_getFilterLogs(t) {
    const n = (0, S.ensureHexString)(t[0]);
    return this._filterPolyfill.getFilterLogs(n);
  }
  initializeRelay() {
    return this._relay ? Promise.resolve(this._relay) : this._relayProvider().then((t) => (t.setAccountsCallback((n, r) => this._setAddresses(n, r)), t.setChainCallback((n, r) => {
      this.updateProviderInfo(r, parseInt(n, 10));
    }), t.setDappDefaultChainCallback(this._chainIdFromOpts), this._relay = t, t));
  }
}
Xe.CoinbaseWalletProvider = Sf;
var $n = {};
Object.defineProperty($n, "__esModule", { value: !0 });
$n.RelayEventManager = void 0;
const Rf = m;
class If {
  constructor() {
    this._nextRequestId = 0, this.callbacks = /* @__PURE__ */ new Map();
  }
  makeRequestId() {
    this._nextRequestId = (this._nextRequestId + 1) % 2147483647;
    const t = this._nextRequestId, n = (0, Rf.prepend0x)(t.toString(16));
    return this.callbacks.get(n) && this.callbacks.delete(n), t;
  }
}
$n.RelayEventManager = If;
Object.defineProperty(yt, "__esModule", { value: !0 });
yt.CoinbaseWalletSDK = void 0;
const Mf = rn, Af = sn, no = m, Pf = dn, Nf = Xe, Tf = St, Lf = Pt, xf = $n, Of = It, Bf = Rt, Na = ot;
class Hn {
  /**
   * Constructor
   * @param options Coinbase Wallet SDK constructor options
   */
  constructor(t) {
    var n, r, s;
    this._appName = "", this._appLogoUrl = null, this._relay = null, this._relayEventManager = null;
    const i = t.linkAPIUrl || Af.LINK_API_URL;
    typeof t.overrideIsMetaMask > "u" ? this._overrideIsMetaMask = !1 : this._overrideIsMetaMask = t.overrideIsMetaMask, this._overrideIsCoinbaseWallet = (n = t.overrideIsCoinbaseWallet) !== null && n !== void 0 ? n : !0, this._overrideIsCoinbaseBrowser = (r = t.overrideIsCoinbaseBrowser) !== null && r !== void 0 ? r : !1, this._diagnosticLogger = t.diagnosticLogger, this._reloadOnDisconnect = (s = t.reloadOnDisconnect) !== null && s !== void 0 ? s : !0;
    const o = new URL(i), a = `${o.protocol}//${o.host}`;
    if (this._storage = new Pf.ScopedLocalStorage(`-walletlink:${a}`), this._storage.setItem("version", Hn.VERSION), this.walletExtension || this.coinbaseBrowser)
      return;
    this._relayEventManager = new xf.RelayEventManager();
    const c = (0, no.isMobileWeb)(), l = t.uiConstructor || ((h) => c ? new Lf.MobileRelayUI(h) : new Of.WalletLinkRelayUI(h)), d = {
      linkAPIUrl: i,
      version: Na.LIB_VERSION,
      darkMode: !!t.darkMode,
      headlessMode: !!t.headlessMode,
      uiConstructor: l,
      storage: this._storage,
      relayEventManager: this._relayEventManager,
      diagnosticLogger: this._diagnosticLogger,
      reloadOnDisconnect: this._reloadOnDisconnect,
      enableMobileWalletLink: t.enableMobileWalletLink
    };
    this._relay = c ? new Tf.MobileRelay(d) : new Bf.WalletLinkRelay(d), this.setAppInfo(t.appName, t.appLogoUrl), !t.headlessMode && this._relay.attachUI();
  }
  /**
   * Create a Web3 Provider object
   * @param jsonRpcUrl Ethereum JSON RPC URL (Default: "")
   * @param chainId Ethereum Chain ID (Default: 1)
   * @returns A Web3 Provider
   */
  makeWeb3Provider(t = "", n = 1) {
    const r = this.walletExtension;
    if (r)
      return this.isCipherProvider(r) || r.setProviderInfo(t, n), this._reloadOnDisconnect === !1 && typeof r.disableReloadOnDisconnect == "function" && r.disableReloadOnDisconnect(), r;
    const s = this.coinbaseBrowser;
    if (s)
      return s;
    const i = this._relay;
    if (!i || !this._relayEventManager || !this._storage)
      throw new Error("Relay not initialized, should never happen");
    return t || i.setConnectDisabled(!0), new Nf.CoinbaseWalletProvider({
      relayProvider: () => Promise.resolve(i),
      relayEventManager: this._relayEventManager,
      storage: this._storage,
      jsonRpcUrl: t,
      chainId: n,
      qrUrl: this.getQrUrl(),
      diagnosticLogger: this._diagnosticLogger,
      overrideIsMetaMask: this._overrideIsMetaMask,
      overrideIsCoinbaseWallet: this._overrideIsCoinbaseWallet,
      overrideIsCoinbaseBrowser: this._overrideIsCoinbaseBrowser
    });
  }
  /**
   * Set application information
   * @param appName Application name
   * @param appLogoUrl Application logo image URL
   */
  setAppInfo(t, n) {
    var r;
    this._appName = t || "DApp", this._appLogoUrl = n || (0, no.getFavicon)();
    const s = this.walletExtension;
    s ? this.isCipherProvider(s) || s.setAppInfo(this._appName, this._appLogoUrl) : (r = this._relay) === null || r === void 0 || r.setAppInfo(this._appName, this._appLogoUrl);
  }
  /**
   * Disconnect. After disconnecting, this will reload the web page to ensure
   * all potential stale state is cleared.
   */
  disconnect() {
    var t;
    const n = this === null || this === void 0 ? void 0 : this.walletExtension;
    n ? n.close() : (t = this._relay) === null || t === void 0 || t.resetAndReload();
  }
  /**
   * Return QR URL for mobile wallet connection, will return null if extension is installed
   */
  getQrUrl() {
    var t, n;
    return (n = (t = this._relay) === null || t === void 0 ? void 0 : t.getQRCodeUrl()) !== null && n !== void 0 ? n : null;
  }
  /**
   * Official Coinbase Wallet logo for developers to use on their frontend
   * @param type Type of wallet logo: "standard" | "circle" | "text" | "textWithLogo" | "textLight" | "textWithLogoLight"
   * @param width Width of the logo (Optional)
   * @returns SVG Data URI
   */
  getCoinbaseWalletLogo(t, n = 240) {
    return (0, Mf.walletLogo)(t, n);
  }
  get walletExtension() {
    var t;
    return (t = window.coinbaseWalletExtension) !== null && t !== void 0 ? t : window.walletLinkExtension;
  }
  get coinbaseBrowser() {
    var t, n;
    try {
      const r = (t = window.ethereum) !== null && t !== void 0 ? t : (n = window.top) === null || n === void 0 ? void 0 : n.ethereum;
      return r && "isCoinbaseBrowser" in r && r.isCoinbaseBrowser ? r : void 0;
    } catch {
      return;
    }
  }
  isCipherProvider(t) {
    return typeof t.isCipher == "boolean" && t.isCipher;
  }
}
yt.CoinbaseWalletSDK = Hn;
Hn.VERSION = Na.LIB_VERSION;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CoinbaseWalletProvider = e.CoinbaseWalletSDK = void 0;
  const t = yt, n = Xe;
  var r = yt;
  Object.defineProperty(e, "CoinbaseWalletSDK", { enumerable: !0, get: function() {
    return r.CoinbaseWalletSDK;
  } });
  var s = Xe;
  Object.defineProperty(e, "CoinbaseWalletProvider", { enumerable: !0, get: function() {
    return s.CoinbaseWalletProvider;
  } }), e.default = t.CoinbaseWalletSDK, typeof window < "u" && (window.CoinbaseWalletSDK = t.CoinbaseWalletSDK, window.CoinbaseWalletProvider = n.CoinbaseWalletProvider, window.WalletLink = t.CoinbaseWalletSDK, window.WalletLinkProvider = n.CoinbaseWalletProvider);
})(io);
const Ff = /* @__PURE__ */ La(io), Xf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Ff
}, Symbol.toStringTag, { value: "Module" }));
export {
  Xf as i
};
//# sourceMappingURL=index-DFp2HoyL.js.map
