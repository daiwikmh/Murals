"use client";
import { p as xt, k as nr, o as In, C as xe, m as Tt, g as Po } from "./index.package-BC048X0m.js";
import { e as Rt, E as To } from "./events-rGQ7b66e.js";
var hs = function(t, e, r) {
  if (r || arguments.length === 2) for (var i = 0, n = e.length, s; i < n; i++)
    (s || !(i in e)) && (s || (s = Array.prototype.slice.call(e, 0, i)), s[i] = e[i]);
  return t.concat(s || Array.prototype.slice.call(e));
}, Su = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e, r, i) {
      this.name = e, this.version = r, this.os = i, this.type = "browser";
    }
    return t;
  }()
), xu = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e) {
      this.version = e, this.type = "node", this.name = "node", this.os = xt.platform;
    }
    return t;
  }()
), Iu = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e, r, i, n) {
      this.name = e, this.version = r, this.os = i, this.bot = n, this.type = "bot-device";
    }
    return t;
  }()
), Ou = (
  /** @class */
  /* @__PURE__ */ function() {
    function t() {
      this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null;
    }
    return t;
  }()
), Pu = (
  /** @class */
  /* @__PURE__ */ function() {
    function t() {
      this.type = "react-native", this.name = "react-native", this.version = null, this.os = null;
    }
    return t;
  }()
), Tu = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/, Ru = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/, ls = 3, Nu = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", Tu]
], fs = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function Au(t) {
  return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new Pu() : typeof navigator < "u" ? Fu(navigator.userAgent) : Uu();
}
function Cu(t) {
  return t !== "" && Nu.reduce(function(e, r) {
    var i = r[0], n = r[1];
    if (e)
      return e;
    var s = n.exec(t);
    return !!s && [i, s];
  }, !1);
}
function Fu(t) {
  var e = Cu(t);
  if (!e)
    return null;
  var r = e[0], i = e[1];
  if (r === "searchbot")
    return new Ou();
  var n = i[1] && i[1].split(".").join("_").split("_").slice(0, 3);
  n ? n.length < ls && (n = hs(hs([], n, !0), Lu(ls - n.length), !0)) : n = [];
  var s = n.join("."), u = $u(t), a = Ru.exec(t);
  return a && a[1] ? new Iu(r, s, u, a[1]) : new Su(r, s, u);
}
function $u(t) {
  for (var e = 0, r = fs.length; e < r; e++) {
    var i = fs[e], n = i[0], s = i[1], u = s.exec(t);
    if (u)
      return n;
  }
  return null;
}
function Uu() {
  var t = typeof xt < "u" && xt.version;
  return t ? new xu(xt.version.slice(1)) : null;
}
function Lu(t) {
  for (var e = [], r = 0; r < t; r++)
    e.push("0");
  return e;
}
var Q = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Yi = function(t, e) {
  return Yi = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, i) {
    r.__proto__ = i;
  } || function(r, i) {
    for (var n in i) i.hasOwnProperty(n) && (r[n] = i[n]);
  }, Yi(t, e);
};
function Mu(t, e) {
  Yi(t, e);
  function r() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype, new r());
}
var Ji = function() {
  return Ji = Object.assign || function(e) {
    for (var r, i = 1, n = arguments.length; i < n; i++) {
      r = arguments[i];
      for (var s in r) Object.prototype.hasOwnProperty.call(r, s) && (e[s] = r[s]);
    }
    return e;
  }, Ji.apply(this, arguments);
};
function ju(t, e) {
  var r = {};
  for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && e.indexOf(i) < 0 && (r[i] = t[i]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var n = 0, i = Object.getOwnPropertySymbols(t); n < i.length; n++)
      e.indexOf(i[n]) < 0 && Object.prototype.propertyIsEnumerable.call(t, i[n]) && (r[i[n]] = t[i[n]]);
  return r;
}
function qu(t, e, r, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, r) : i, u;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, r, i);
  else for (var a = t.length - 1; a >= 0; a--) (u = t[a]) && (s = (n < 3 ? u(s) : n > 3 ? u(e, r, s) : u(e, r)) || s);
  return n > 3 && s && Object.defineProperty(e, r, s), s;
}
function Bu(t, e) {
  return function(r, i) {
    e(r, i, t);
  };
}
function zu(t, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(t, e);
}
function Ku(t, e, r, i) {
  function n(s) {
    return s instanceof r ? s : new r(function(u) {
      u(s);
    });
  }
  return new (r || (r = Promise))(function(s, u) {
    function a(f) {
      try {
        h(i.next(f));
      } catch (y) {
        u(y);
      }
    }
    function l(f) {
      try {
        h(i.throw(f));
      } catch (y) {
        u(y);
      }
    }
    function h(f) {
      f.done ? s(f.value) : n(f.value).then(a, l);
    }
    h((i = i.apply(t, e || [])).next());
  });
}
function Vu(t, e) {
  var r = { label: 0, sent: function() {
    if (s[0] & 1) throw s[1];
    return s[1];
  }, trys: [], ops: [] }, i, n, s, u;
  return u = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (u[Symbol.iterator] = function() {
    return this;
  }), u;
  function a(h) {
    return function(f) {
      return l([h, f]);
    };
  }
  function l(h) {
    if (i) throw new TypeError("Generator is already executing.");
    for (; r; ) try {
      if (i = 1, n && (s = h[0] & 2 ? n.return : h[0] ? n.throw || ((s = n.return) && s.call(n), 0) : n.next) && !(s = s.call(n, h[1])).done) return s;
      switch (n = 0, s && (h = [h[0] & 2, s.value]), h[0]) {
        case 0:
        case 1:
          s = h;
          break;
        case 4:
          return r.label++, { value: h[1], done: !1 };
        case 5:
          r.label++, n = h[1], h = [0];
          continue;
        case 7:
          h = r.ops.pop(), r.trys.pop();
          continue;
        default:
          if (s = r.trys, !(s = s.length > 0 && s[s.length - 1]) && (h[0] === 6 || h[0] === 2)) {
            r = 0;
            continue;
          }
          if (h[0] === 3 && (!s || h[1] > s[0] && h[1] < s[3])) {
            r.label = h[1];
            break;
          }
          if (h[0] === 6 && r.label < s[1]) {
            r.label = s[1], s = h;
            break;
          }
          if (s && r.label < s[2]) {
            r.label = s[2], r.ops.push(h);
            break;
          }
          s[2] && r.ops.pop(), r.trys.pop();
          continue;
      }
      h = e.call(t, r);
    } catch (f) {
      h = [6, f], n = 0;
    } finally {
      i = s = 0;
    }
    if (h[0] & 5) throw h[1];
    return { value: h[0] ? h[1] : void 0, done: !0 };
  }
}
function Hu(t, e, r, i) {
  i === void 0 && (i = r), t[i] = e[r];
}
function Gu(t, e) {
  for (var r in t) r !== "default" && !e.hasOwnProperty(r) && (e[r] = t[r]);
}
function Xi(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, r = e && t[e], i = 0;
  if (r) return r.call(t);
  if (t && typeof t.length == "number") return {
    next: function() {
      return t && i >= t.length && (t = void 0), { value: t && t[i++], done: !t };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Ro(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r) return t;
  var i = r.call(t), n, s = [], u;
  try {
    for (; (e === void 0 || e-- > 0) && !(n = i.next()).done; ) s.push(n.value);
  } catch (a) {
    u = { error: a };
  } finally {
    try {
      n && !n.done && (r = i.return) && r.call(i);
    } finally {
      if (u) throw u.error;
    }
  }
  return s;
}
function ku() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t = t.concat(Ro(arguments[e]));
  return t;
}
function Wu() {
  for (var t = 0, e = 0, r = arguments.length; e < r; e++) t += arguments[e].length;
  for (var i = Array(t), n = 0, e = 0; e < r; e++)
    for (var s = arguments[e], u = 0, a = s.length; u < a; u++, n++)
      i[n] = s[u];
  return i;
}
function Ur(t) {
  return this instanceof Ur ? (this.v = t, this) : new Ur(t);
}
function Yu(t, e, r) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var i = r.apply(t, e || []), n, s = [];
  return n = {}, u("next"), u("throw"), u("return"), n[Symbol.asyncIterator] = function() {
    return this;
  }, n;
  function u(g) {
    i[g] && (n[g] = function(_) {
      return new Promise(function(w, T) {
        s.push([g, _, w, T]) > 1 || a(g, _);
      });
    });
  }
  function a(g, _) {
    try {
      l(i[g](_));
    } catch (w) {
      y(s[0][3], w);
    }
  }
  function l(g) {
    g.value instanceof Ur ? Promise.resolve(g.value.v).then(h, f) : y(s[0][2], g);
  }
  function h(g) {
    a("next", g);
  }
  function f(g) {
    a("throw", g);
  }
  function y(g, _) {
    g(_), s.shift(), s.length && a(s[0][0], s[0][1]);
  }
}
function Ju(t) {
  var e, r;
  return e = {}, i("next"), i("throw", function(n) {
    throw n;
  }), i("return"), e[Symbol.iterator] = function() {
    return this;
  }, e;
  function i(n, s) {
    e[n] = t[n] ? function(u) {
      return (r = !r) ? { value: Ur(t[n](u)), done: n === "return" } : s ? s(u) : u;
    } : s;
  }
}
function Xu(t) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator], r;
  return e ? e.call(t) : (t = typeof Xi == "function" ? Xi(t) : t[Symbol.iterator](), r = {}, i("next"), i("throw"), i("return"), r[Symbol.asyncIterator] = function() {
    return this;
  }, r);
  function i(s) {
    r[s] = t[s] && function(u) {
      return new Promise(function(a, l) {
        u = t[s](u), n(a, l, u.done, u.value);
      });
    };
  }
  function n(s, u, a, l) {
    Promise.resolve(l).then(function(h) {
      s({ value: h, done: a });
    }, u);
  }
}
function Qu(t, e) {
  return Object.defineProperty ? Object.defineProperty(t, "raw", { value: e }) : t.raw = e, t;
}
function Zu(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
  return e.default = t, e;
}
function eh(t) {
  return t && t.__esModule ? t : { default: t };
}
function th(t, e) {
  if (!e.has(t))
    throw new TypeError("attempted to get private field on non-instance");
  return e.get(t);
}
function rh(t, e, r) {
  if (!e.has(t))
    throw new TypeError("attempted to set private field on non-instance");
  return e.set(t, r), r;
}
const ih = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return Ji;
  },
  __asyncDelegator: Ju,
  __asyncGenerator: Yu,
  __asyncValues: Xu,
  __await: Ur,
  __awaiter: Ku,
  __classPrivateFieldGet: th,
  __classPrivateFieldSet: rh,
  __createBinding: Hu,
  __decorate: qu,
  __exportStar: Gu,
  __extends: Mu,
  __generator: Vu,
  __importDefault: eh,
  __importStar: Zu,
  __makeTemplateObject: Qu,
  __metadata: zu,
  __param: Bu,
  __read: Ro,
  __rest: ju,
  __spread: ku,
  __spreadArrays: Wu,
  __values: Xi
}, Symbol.toStringTag, { value: "Module" })), gi = /* @__PURE__ */ nr(ih);
var Ni = {}, Ir = {}, ds;
function nh() {
  if (ds) return Ir;
  ds = 1, Object.defineProperty(Ir, "__esModule", { value: !0 }), Ir.delay = void 0;
  function t(e) {
    return new Promise((r) => {
      setTimeout(() => {
        r(!0);
      }, e);
    });
  }
  return Ir.delay = t, Ir;
}
var Qt = {}, Ai = {}, Zt = {}, ps;
function sh() {
  return ps || (ps = 1, Object.defineProperty(Zt, "__esModule", { value: !0 }), Zt.ONE_THOUSAND = Zt.ONE_HUNDRED = void 0, Zt.ONE_HUNDRED = 100, Zt.ONE_THOUSAND = 1e3), Zt;
}
var Ci = {}, gs;
function oh() {
  return gs || (gs = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ONE_YEAR = t.FOUR_WEEKS = t.THREE_WEEKS = t.TWO_WEEKS = t.ONE_WEEK = t.THIRTY_DAYS = t.SEVEN_DAYS = t.FIVE_DAYS = t.THREE_DAYS = t.ONE_DAY = t.TWENTY_FOUR_HOURS = t.TWELVE_HOURS = t.SIX_HOURS = t.THREE_HOURS = t.ONE_HOUR = t.SIXTY_MINUTES = t.THIRTY_MINUTES = t.TEN_MINUTES = t.FIVE_MINUTES = t.ONE_MINUTE = t.SIXTY_SECONDS = t.THIRTY_SECONDS = t.TEN_SECONDS = t.FIVE_SECONDS = t.ONE_SECOND = void 0, t.ONE_SECOND = 1, t.FIVE_SECONDS = 5, t.TEN_SECONDS = 10, t.THIRTY_SECONDS = 30, t.SIXTY_SECONDS = 60, t.ONE_MINUTE = t.SIXTY_SECONDS, t.FIVE_MINUTES = t.ONE_MINUTE * 5, t.TEN_MINUTES = t.ONE_MINUTE * 10, t.THIRTY_MINUTES = t.ONE_MINUTE * 30, t.SIXTY_MINUTES = t.ONE_MINUTE * 60, t.ONE_HOUR = t.SIXTY_MINUTES, t.THREE_HOURS = t.ONE_HOUR * 3, t.SIX_HOURS = t.ONE_HOUR * 6, t.TWELVE_HOURS = t.ONE_HOUR * 12, t.TWENTY_FOUR_HOURS = t.ONE_HOUR * 24, t.ONE_DAY = t.TWENTY_FOUR_HOURS, t.THREE_DAYS = t.ONE_DAY * 3, t.FIVE_DAYS = t.ONE_DAY * 5, t.SEVEN_DAYS = t.ONE_DAY * 7, t.THIRTY_DAYS = t.ONE_DAY * 30, t.ONE_WEEK = t.SEVEN_DAYS, t.TWO_WEEKS = t.ONE_WEEK * 2, t.THREE_WEEKS = t.ONE_WEEK * 3, t.FOUR_WEEKS = t.ONE_WEEK * 4, t.ONE_YEAR = t.ONE_DAY * 365;
  }(Ci)), Ci;
}
var ys;
function No() {
  return ys || (ys = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    const e = gi;
    e.__exportStar(sh(), t), e.__exportStar(oh(), t);
  }(Ai)), Ai;
}
var bs;
function ah() {
  if (bs) return Qt;
  bs = 1, Object.defineProperty(Qt, "__esModule", { value: !0 }), Qt.fromMiliseconds = Qt.toMiliseconds = void 0;
  const t = No();
  function e(i) {
    return i * t.ONE_THOUSAND;
  }
  Qt.toMiliseconds = e;
  function r(i) {
    return Math.floor(i / t.ONE_THOUSAND);
  }
  return Qt.fromMiliseconds = r, Qt;
}
var _s;
function ch() {
  return _s || (_s = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    const e = gi;
    e.__exportStar(nh(), t), e.__exportStar(ah(), t);
  }(Ni)), Ni;
}
var fr = {}, ms;
function uh() {
  if (ms) return fr;
  ms = 1, Object.defineProperty(fr, "__esModule", { value: !0 }), fr.Watch = void 0;
  class t {
    constructor() {
      this.timestamps = /* @__PURE__ */ new Map();
    }
    start(r) {
      if (this.timestamps.has(r))
        throw new Error(`Watch already started for label: ${r}`);
      this.timestamps.set(r, { started: Date.now() });
    }
    stop(r) {
      const i = this.get(r);
      if (typeof i.elapsed < "u")
        throw new Error(`Watch already stopped for label: ${r}`);
      const n = Date.now() - i.started;
      this.timestamps.set(r, { started: i.started, elapsed: n });
    }
    get(r) {
      const i = this.timestamps.get(r);
      if (typeof i > "u")
        throw new Error(`No timestamp found for label: ${r}`);
      return i;
    }
    elapsed(r) {
      const i = this.get(r);
      return i.elapsed || Date.now() - i.started;
    }
  }
  return fr.Watch = t, fr.default = t, fr;
}
var Fi = {}, Or = {}, ws;
function hh() {
  if (ws) return Or;
  ws = 1, Object.defineProperty(Or, "__esModule", { value: !0 }), Or.IWatch = void 0;
  class t {
  }
  return Or.IWatch = t, Or;
}
var vs;
function lh() {
  return vs || (vs = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), gi.__exportStar(hh(), t);
  }(Fi)), Fi;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const e = gi;
  e.__exportStar(ch(), t), e.__exportStar(uh(), t), e.__exportStar(lh(), t), e.__exportStar(No(), t);
})(Q);
var Ie = {};
Object.defineProperty(Ie, "__esModule", { value: !0 });
Ie.getLocalStorage = Ie.getLocalStorageOrThrow = Ie.getCrypto = Ie.getCryptoOrThrow = Ao = Ie.getLocation = Ie.getLocationOrThrow = Pn = Ie.getNavigator = Ie.getNavigatorOrThrow = On = Ie.getDocument = Ie.getDocumentOrThrow = Ie.getFromWindowOrThrow = Ie.getFromWindow = void 0;
function sr(t) {
  let e;
  return typeof window < "u" && typeof window[t] < "u" && (e = window[t]), e;
}
Ie.getFromWindow = sr;
function br(t) {
  const e = sr(t);
  if (!e)
    throw new Error(`${t} is not defined in Window`);
  return e;
}
Ie.getFromWindowOrThrow = br;
function fh() {
  return br("document");
}
Ie.getDocumentOrThrow = fh;
function dh() {
  return sr("document");
}
var On = Ie.getDocument = dh;
function ph() {
  return br("navigator");
}
Ie.getNavigatorOrThrow = ph;
function gh() {
  return sr("navigator");
}
var Pn = Ie.getNavigator = gh;
function yh() {
  return br("location");
}
Ie.getLocationOrThrow = yh;
function bh() {
  return sr("location");
}
var Ao = Ie.getLocation = bh;
function _h() {
  return br("crypto");
}
Ie.getCryptoOrThrow = _h;
function mh() {
  return sr("crypto");
}
Ie.getCrypto = mh;
function wh() {
  return br("localStorage");
}
Ie.getLocalStorageOrThrow = wh;
function vh() {
  return sr("localStorage");
}
Ie.getLocalStorage = vh;
var Tn = {};
Object.defineProperty(Tn, "__esModule", { value: !0 });
var Co = Tn.getWindowMetadata = void 0;
const Es = Ie;
function Eh() {
  let t, e;
  try {
    t = Es.getDocumentOrThrow(), e = Es.getLocationOrThrow();
  } catch {
    return null;
  }
  function r() {
    const y = t.getElementsByTagName("link"), g = [];
    for (let _ = 0; _ < y.length; _++) {
      const w = y[_], T = w.getAttribute("rel");
      if (T && T.toLowerCase().indexOf("icon") > -1) {
        const A = w.getAttribute("href");
        if (A)
          if (A.toLowerCase().indexOf("https:") === -1 && A.toLowerCase().indexOf("http:") === -1 && A.indexOf("//") !== 0) {
            let j = e.protocol + "//" + e.host;
            if (A.indexOf("/") === 0)
              j += A;
            else {
              const D = e.pathname.split("/");
              D.pop();
              const O = D.join("/");
              j += O + "/" + A;
            }
            g.push(j);
          } else if (A.indexOf("//") === 0) {
            const j = e.protocol + A;
            g.push(j);
          } else
            g.push(A);
      }
    }
    return g;
  }
  function i(...y) {
    const g = t.getElementsByTagName("meta");
    for (let _ = 0; _ < g.length; _++) {
      const w = g[_], T = ["itemprop", "property", "name"].map((A) => w.getAttribute(A)).filter((A) => A ? y.includes(A) : !1);
      if (T.length && T) {
        const A = w.getAttribute("content");
        if (A)
          return A;
      }
    }
    return "";
  }
  function n() {
    let y = i("name", "og:site_name", "og:title", "twitter:title");
    return y || (y = t.title), y;
  }
  function s() {
    return i("description", "og:description", "twitter:description", "keywords");
  }
  const u = n(), a = s(), l = e.origin, h = r();
  return {
    description: a,
    url: l,
    icons: h,
    name: u
  };
}
Co = Tn.getWindowMetadata = Eh;
var Lr = {}, Dh = (t) => encodeURIComponent(t).replace(/[!'()*]/g, (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`), Fo = "%[a-f0-9]{2}", Ds = new RegExp("(" + Fo + ")|([^%]+?)", "gi"), Ss = new RegExp("(" + Fo + ")+", "gi");
function Qi(t, e) {
  try {
    return [decodeURIComponent(t.join(""))];
  } catch {
  }
  if (t.length === 1)
    return t;
  e = e || 1;
  var r = t.slice(0, e), i = t.slice(e);
  return Array.prototype.concat.call([], Qi(r), Qi(i));
}
function Sh(t) {
  try {
    return decodeURIComponent(t);
  } catch {
    for (var e = t.match(Ds) || [], r = 1; r < e.length; r++)
      t = Qi(e, r).join(""), e = t.match(Ds) || [];
    return t;
  }
}
function xh(t) {
  for (var e = {
    "%FE%FF": "��",
    "%FF%FE": "��"
  }, r = Ss.exec(t); r; ) {
    try {
      e[r[0]] = decodeURIComponent(r[0]);
    } catch {
      var i = Sh(r[0]);
      i !== r[0] && (e[r[0]] = i);
    }
    r = Ss.exec(t);
  }
  e["%C2"] = "�";
  for (var n = Object.keys(e), s = 0; s < n.length; s++) {
    var u = n[s];
    t = t.replace(new RegExp(u, "g"), e[u]);
  }
  return t;
}
var Ih = function(t) {
  if (typeof t != "string")
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof t + "`");
  try {
    return t = t.replace(/\+/g, " "), decodeURIComponent(t);
  } catch {
    return xh(t);
  }
}, Oh = (t, e) => {
  if (!(typeof t == "string" && typeof e == "string"))
    throw new TypeError("Expected the arguments to be of type `string`");
  if (e === "")
    return [t];
  const r = t.indexOf(e);
  return r === -1 ? [t] : [
    t.slice(0, r),
    t.slice(r + e.length)
  ];
}, Ph = function(t, e) {
  for (var r = {}, i = Object.keys(t), n = Array.isArray(e), s = 0; s < i.length; s++) {
    var u = i[s], a = t[u];
    (n ? e.indexOf(u) !== -1 : e(u, a, t)) && (r[u] = a);
  }
  return r;
};
(function(t) {
  const e = Dh, r = Ih, i = Oh, n = Ph, s = (D) => D == null, u = Symbol("encodeFragmentIdentifier");
  function a(D) {
    switch (D.arrayFormat) {
      case "index":
        return (O) => (m, E) => {
          const p = m.length;
          return E === void 0 || D.skipNull && E === null || D.skipEmptyString && E === "" ? m : E === null ? [...m, [f(O, D), "[", p, "]"].join("")] : [
            ...m,
            [f(O, D), "[", f(p, D), "]=", f(E, D)].join("")
          ];
        };
      case "bracket":
        return (O) => (m, E) => E === void 0 || D.skipNull && E === null || D.skipEmptyString && E === "" ? m : E === null ? [...m, [f(O, D), "[]"].join("")] : [...m, [f(O, D), "[]=", f(E, D)].join("")];
      case "colon-list-separator":
        return (O) => (m, E) => E === void 0 || D.skipNull && E === null || D.skipEmptyString && E === "" ? m : E === null ? [...m, [f(O, D), ":list="].join("")] : [...m, [f(O, D), ":list=", f(E, D)].join("")];
      case "comma":
      case "separator":
      case "bracket-separator": {
        const O = D.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (m) => (E, p) => p === void 0 || D.skipNull && p === null || D.skipEmptyString && p === "" ? E : (p = p === null ? "" : p, E.length === 0 ? [[f(m, D), O, f(p, D)].join("")] : [[E, f(p, D)].join(D.arrayFormatSeparator)]);
      }
      default:
        return (O) => (m, E) => E === void 0 || D.skipNull && E === null || D.skipEmptyString && E === "" ? m : E === null ? [...m, f(O, D)] : [...m, [f(O, D), "=", f(E, D)].join("")];
    }
  }
  function l(D) {
    let O;
    switch (D.arrayFormat) {
      case "index":
        return (m, E, p) => {
          if (O = /\[(\d*)\]$/.exec(m), m = m.replace(/\[\d*\]$/, ""), !O) {
            p[m] = E;
            return;
          }
          p[m] === void 0 && (p[m] = {}), p[m][O[1]] = E;
        };
      case "bracket":
        return (m, E, p) => {
          if (O = /(\[\])$/.exec(m), m = m.replace(/\[\]$/, ""), !O) {
            p[m] = E;
            return;
          }
          if (p[m] === void 0) {
            p[m] = [E];
            return;
          }
          p[m] = [].concat(p[m], E);
        };
      case "colon-list-separator":
        return (m, E, p) => {
          if (O = /(:list)$/.exec(m), m = m.replace(/:list$/, ""), !O) {
            p[m] = E;
            return;
          }
          if (p[m] === void 0) {
            p[m] = [E];
            return;
          }
          p[m] = [].concat(p[m], E);
        };
      case "comma":
      case "separator":
        return (m, E, p) => {
          const o = typeof E == "string" && E.includes(D.arrayFormatSeparator), d = typeof E == "string" && !o && y(E, D).includes(D.arrayFormatSeparator);
          E = d ? y(E, D) : E;
          const C = o || d ? E.split(D.arrayFormatSeparator).map((F) => y(F, D)) : E === null ? E : y(E, D);
          p[m] = C;
        };
      case "bracket-separator":
        return (m, E, p) => {
          const o = /(\[\])$/.test(m);
          if (m = m.replace(/\[\]$/, ""), !o) {
            p[m] = E && y(E, D);
            return;
          }
          const d = E === null ? [] : E.split(D.arrayFormatSeparator).map((C) => y(C, D));
          if (p[m] === void 0) {
            p[m] = d;
            return;
          }
          p[m] = [].concat(p[m], d);
        };
      default:
        return (m, E, p) => {
          if (p[m] === void 0) {
            p[m] = E;
            return;
          }
          p[m] = [].concat(p[m], E);
        };
    }
  }
  function h(D) {
    if (typeof D != "string" || D.length !== 1)
      throw new TypeError("arrayFormatSeparator must be single character string");
  }
  function f(D, O) {
    return O.encode ? O.strict ? e(D) : encodeURIComponent(D) : D;
  }
  function y(D, O) {
    return O.decode ? r(D) : D;
  }
  function g(D) {
    return Array.isArray(D) ? D.sort() : typeof D == "object" ? g(Object.keys(D)).sort((O, m) => Number(O) - Number(m)).map((O) => D[O]) : D;
  }
  function _(D) {
    const O = D.indexOf("#");
    return O !== -1 && (D = D.slice(0, O)), D;
  }
  function w(D) {
    let O = "";
    const m = D.indexOf("#");
    return m !== -1 && (O = D.slice(m)), O;
  }
  function T(D) {
    D = _(D);
    const O = D.indexOf("?");
    return O === -1 ? "" : D.slice(O + 1);
  }
  function A(D, O) {
    return O.parseNumbers && !Number.isNaN(Number(D)) && typeof D == "string" && D.trim() !== "" ? D = Number(D) : O.parseBooleans && D !== null && (D.toLowerCase() === "true" || D.toLowerCase() === "false") && (D = D.toLowerCase() === "true"), D;
  }
  function j(D, O) {
    O = Object.assign({
      decode: !0,
      sort: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: !1,
      parseBooleans: !1
    }, O), h(O.arrayFormatSeparator);
    const m = l(O), E = /* @__PURE__ */ Object.create(null);
    if (typeof D != "string" || (D = D.trim().replace(/^[?#&]/, ""), !D))
      return E;
    for (const p of D.split("&")) {
      if (p === "")
        continue;
      let [o, d] = i(O.decode ? p.replace(/\+/g, " ") : p, "=");
      d = d === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(O.arrayFormat) ? d : y(d, O), m(y(o, O), d, E);
    }
    for (const p of Object.keys(E)) {
      const o = E[p];
      if (typeof o == "object" && o !== null)
        for (const d of Object.keys(o))
          o[d] = A(o[d], O);
      else
        E[p] = A(o, O);
    }
    return O.sort === !1 ? E : (O.sort === !0 ? Object.keys(E).sort() : Object.keys(E).sort(O.sort)).reduce((p, o) => {
      const d = E[o];
      return d && typeof d == "object" && !Array.isArray(d) ? p[o] = g(d) : p[o] = d, p;
    }, /* @__PURE__ */ Object.create(null));
  }
  t.extract = T, t.parse = j, t.stringify = (D, O) => {
    if (!D)
      return "";
    O = Object.assign({
      encode: !0,
      strict: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, O), h(O.arrayFormatSeparator);
    const m = (d) => O.skipNull && s(D[d]) || O.skipEmptyString && D[d] === "", E = a(O), p = {};
    for (const d of Object.keys(D))
      m(d) || (p[d] = D[d]);
    const o = Object.keys(p);
    return O.sort !== !1 && o.sort(O.sort), o.map((d) => {
      const C = D[d];
      return C === void 0 ? "" : C === null ? f(d, O) : Array.isArray(C) ? C.length === 0 && O.arrayFormat === "bracket-separator" ? f(d, O) + "[]" : C.reduce(E(d), []).join("&") : f(d, O) + "=" + f(C, O);
    }).filter((d) => d.length > 0).join("&");
  }, t.parseUrl = (D, O) => {
    O = Object.assign({
      decode: !0
    }, O);
    const [m, E] = i(D, "#");
    return Object.assign(
      {
        url: m.split("?")[0] || "",
        query: j(T(D), O)
      },
      O && O.parseFragmentIdentifier && E ? { fragmentIdentifier: y(E, O) } : {}
    );
  }, t.stringifyUrl = (D, O) => {
    O = Object.assign({
      encode: !0,
      strict: !0,
      [u]: !0
    }, O);
    const m = _(D.url).split("?")[0] || "", E = t.extract(D.url), p = t.parse(E, { sort: !1 }), o = Object.assign(p, D.query);
    let d = t.stringify(o, O);
    d && (d = `?${d}`);
    let C = w(D.url);
    return D.fragmentIdentifier && (C = `#${O[u] ? f(D.fragmentIdentifier, O) : D.fragmentIdentifier}`), `${m}${d}${C}`;
  }, t.pick = (D, O, m) => {
    m = Object.assign({
      parseFragmentIdentifier: !0,
      [u]: !1
    }, m);
    const { url: E, query: p, fragmentIdentifier: o } = t.parseUrl(D, m);
    return t.stringifyUrl({
      url: E,
      query: n(p, O),
      fragmentIdentifier: o
    }, m);
  }, t.exclude = (D, O, m) => {
    const E = Array.isArray(O) ? (p) => !O.includes(p) : (p, o) => !O(p, o);
    return t.pick(D, E, m);
  };
})(Lr);
var Rn = {}, yi = {}, ne = {}, $o = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  function e(a, l) {
    var h = a >>> 16 & 65535, f = a & 65535, y = l >>> 16 & 65535, g = l & 65535;
    return f * g + (h * g + f * y << 16 >>> 0) | 0;
  }
  t.mul = Math.imul || e;
  function r(a, l) {
    return a + l | 0;
  }
  t.add = r;
  function i(a, l) {
    return a - l | 0;
  }
  t.sub = i;
  function n(a, l) {
    return a << l | a >>> 32 - l;
  }
  t.rotl = n;
  function s(a, l) {
    return a << 32 - l | a >>> l;
  }
  t.rotr = s;
  function u(a) {
    return typeof a == "number" && isFinite(a) && Math.floor(a) === a;
  }
  t.isInteger = Number.isInteger || u, t.MAX_SAFE_INTEGER = 9007199254740991, t.isSafeInteger = function(a) {
    return t.isInteger(a) && a >= -t.MAX_SAFE_INTEGER && a <= t.MAX_SAFE_INTEGER;
  };
})($o);
Object.defineProperty(ne, "__esModule", { value: !0 });
var Uo = $o;
function Th(t, e) {
  return e === void 0 && (e = 0), (t[e + 0] << 8 | t[e + 1]) << 16 >> 16;
}
ne.readInt16BE = Th;
function Rh(t, e) {
  return e === void 0 && (e = 0), (t[e + 0] << 8 | t[e + 1]) >>> 0;
}
ne.readUint16BE = Rh;
function Nh(t, e) {
  return e === void 0 && (e = 0), (t[e + 1] << 8 | t[e]) << 16 >> 16;
}
ne.readInt16LE = Nh;
function Ah(t, e) {
  return e === void 0 && (e = 0), (t[e + 1] << 8 | t[e]) >>> 0;
}
ne.readUint16LE = Ah;
function Lo(t, e, r) {
  return e === void 0 && (e = new Uint8Array(2)), r === void 0 && (r = 0), e[r + 0] = t >>> 8, e[r + 1] = t >>> 0, e;
}
ne.writeUint16BE = Lo;
ne.writeInt16BE = Lo;
function Mo(t, e, r) {
  return e === void 0 && (e = new Uint8Array(2)), r === void 0 && (r = 0), e[r + 0] = t >>> 0, e[r + 1] = t >>> 8, e;
}
ne.writeUint16LE = Mo;
ne.writeInt16LE = Mo;
function Zi(t, e) {
  return e === void 0 && (e = 0), t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3];
}
ne.readInt32BE = Zi;
function en(t, e) {
  return e === void 0 && (e = 0), (t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3]) >>> 0;
}
ne.readUint32BE = en;
function tn(t, e) {
  return e === void 0 && (e = 0), t[e + 3] << 24 | t[e + 2] << 16 | t[e + 1] << 8 | t[e];
}
ne.readInt32LE = tn;
function rn(t, e) {
  return e === void 0 && (e = 0), (t[e + 3] << 24 | t[e + 2] << 16 | t[e + 1] << 8 | t[e]) >>> 0;
}
ne.readUint32LE = rn;
function ci(t, e, r) {
  return e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0), e[r + 0] = t >>> 24, e[r + 1] = t >>> 16, e[r + 2] = t >>> 8, e[r + 3] = t >>> 0, e;
}
ne.writeUint32BE = ci;
ne.writeInt32BE = ci;
function ui(t, e, r) {
  return e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0), e[r + 0] = t >>> 0, e[r + 1] = t >>> 8, e[r + 2] = t >>> 16, e[r + 3] = t >>> 24, e;
}
ne.writeUint32LE = ui;
ne.writeInt32LE = ui;
function Ch(t, e) {
  e === void 0 && (e = 0);
  var r = Zi(t, e), i = Zi(t, e + 4);
  return r * 4294967296 + i - (i >> 31) * 4294967296;
}
ne.readInt64BE = Ch;
function Fh(t, e) {
  e === void 0 && (e = 0);
  var r = en(t, e), i = en(t, e + 4);
  return r * 4294967296 + i;
}
ne.readUint64BE = Fh;
function $h(t, e) {
  e === void 0 && (e = 0);
  var r = tn(t, e), i = tn(t, e + 4);
  return i * 4294967296 + r - (r >> 31) * 4294967296;
}
ne.readInt64LE = $h;
function Uh(t, e) {
  e === void 0 && (e = 0);
  var r = rn(t, e), i = rn(t, e + 4);
  return i * 4294967296 + r;
}
ne.readUint64LE = Uh;
function jo(t, e, r) {
  return e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0), ci(t / 4294967296 >>> 0, e, r), ci(t >>> 0, e, r + 4), e;
}
ne.writeUint64BE = jo;
ne.writeInt64BE = jo;
function qo(t, e, r) {
  return e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0), ui(t >>> 0, e, r), ui(t / 4294967296 >>> 0, e, r + 4), e;
}
ne.writeUint64LE = qo;
ne.writeInt64LE = qo;
function Lh(t, e, r) {
  if (r === void 0 && (r = 0), t % 8 !== 0)
    throw new Error("readUintBE supports only bitLengths divisible by 8");
  if (t / 8 > e.length - r)
    throw new Error("readUintBE: array is too short for the given bitLength");
  for (var i = 0, n = 1, s = t / 8 + r - 1; s >= r; s--)
    i += e[s] * n, n *= 256;
  return i;
}
ne.readUintBE = Lh;
function Mh(t, e, r) {
  if (r === void 0 && (r = 0), t % 8 !== 0)
    throw new Error("readUintLE supports only bitLengths divisible by 8");
  if (t / 8 > e.length - r)
    throw new Error("readUintLE: array is too short for the given bitLength");
  for (var i = 0, n = 1, s = r; s < r + t / 8; s++)
    i += e[s] * n, n *= 256;
  return i;
}
ne.readUintLE = Mh;
function jh(t, e, r, i) {
  if (r === void 0 && (r = new Uint8Array(t / 8)), i === void 0 && (i = 0), t % 8 !== 0)
    throw new Error("writeUintBE supports only bitLengths divisible by 8");
  if (!Uo.isSafeInteger(e))
    throw new Error("writeUintBE value must be an integer");
  for (var n = 1, s = t / 8 + i - 1; s >= i; s--)
    r[s] = e / n & 255, n *= 256;
  return r;
}
ne.writeUintBE = jh;
function qh(t, e, r, i) {
  if (r === void 0 && (r = new Uint8Array(t / 8)), i === void 0 && (i = 0), t % 8 !== 0)
    throw new Error("writeUintLE supports only bitLengths divisible by 8");
  if (!Uo.isSafeInteger(e))
    throw new Error("writeUintLE value must be an integer");
  for (var n = 1, s = i; s < i + t / 8; s++)
    r[s] = e / n & 255, n *= 256;
  return r;
}
ne.writeUintLE = qh;
function Bh(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat32(e);
}
ne.readFloat32BE = Bh;
function zh(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat32(e, !0);
}
ne.readFloat32LE = zh;
function Kh(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat64(e);
}
ne.readFloat64BE = Kh;
function Vh(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat64(e, !0);
}
ne.readFloat64LE = Vh;
function Hh(t, e, r) {
  e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0);
  var i = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return i.setFloat32(r, t), e;
}
ne.writeFloat32BE = Hh;
function Gh(t, e, r) {
  e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0);
  var i = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return i.setFloat32(r, t, !0), e;
}
ne.writeFloat32LE = Gh;
function kh(t, e, r) {
  e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0);
  var i = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return i.setFloat64(r, t), e;
}
ne.writeFloat64BE = kh;
function Wh(t, e, r) {
  e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0);
  var i = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return i.setFloat64(r, t, !0), e;
}
ne.writeFloat64LE = Wh;
var bt = {};
Object.defineProperty(bt, "__esModule", { value: !0 });
function Yh(t) {
  for (var e = 0; e < t.length; e++)
    t[e] = 0;
  return t;
}
bt.wipe = Yh;
Object.defineProperty(yi, "__esModule", { value: !0 });
var it = ne, nn = bt, Jh = 20;
function Xh(t, e, r) {
  for (var i = 1634760805, n = 857760878, s = 2036477234, u = 1797285236, a = r[3] << 24 | r[2] << 16 | r[1] << 8 | r[0], l = r[7] << 24 | r[6] << 16 | r[5] << 8 | r[4], h = r[11] << 24 | r[10] << 16 | r[9] << 8 | r[8], f = r[15] << 24 | r[14] << 16 | r[13] << 8 | r[12], y = r[19] << 24 | r[18] << 16 | r[17] << 8 | r[16], g = r[23] << 24 | r[22] << 16 | r[21] << 8 | r[20], _ = r[27] << 24 | r[26] << 16 | r[25] << 8 | r[24], w = r[31] << 24 | r[30] << 16 | r[29] << 8 | r[28], T = e[3] << 24 | e[2] << 16 | e[1] << 8 | e[0], A = e[7] << 24 | e[6] << 16 | e[5] << 8 | e[4], j = e[11] << 24 | e[10] << 16 | e[9] << 8 | e[8], D = e[15] << 24 | e[14] << 16 | e[13] << 8 | e[12], O = i, m = n, E = s, p = u, o = a, d = l, C = h, F = f, K = y, G = g, X = _, x = w, N = T, k = A, q = j, U = D, M = 0; M < Jh; M += 2)
    O = O + o | 0, N ^= O, N = N >>> 16 | N << 16, K = K + N | 0, o ^= K, o = o >>> 20 | o << 12, m = m + d | 0, k ^= m, k = k >>> 16 | k << 16, G = G + k | 0, d ^= G, d = d >>> 20 | d << 12, E = E + C | 0, q ^= E, q = q >>> 16 | q << 16, X = X + q | 0, C ^= X, C = C >>> 20 | C << 12, p = p + F | 0, U ^= p, U = U >>> 16 | U << 16, x = x + U | 0, F ^= x, F = F >>> 20 | F << 12, E = E + C | 0, q ^= E, q = q >>> 24 | q << 8, X = X + q | 0, C ^= X, C = C >>> 25 | C << 7, p = p + F | 0, U ^= p, U = U >>> 24 | U << 8, x = x + U | 0, F ^= x, F = F >>> 25 | F << 7, m = m + d | 0, k ^= m, k = k >>> 24 | k << 8, G = G + k | 0, d ^= G, d = d >>> 25 | d << 7, O = O + o | 0, N ^= O, N = N >>> 24 | N << 8, K = K + N | 0, o ^= K, o = o >>> 25 | o << 7, O = O + d | 0, U ^= O, U = U >>> 16 | U << 16, X = X + U | 0, d ^= X, d = d >>> 20 | d << 12, m = m + C | 0, N ^= m, N = N >>> 16 | N << 16, x = x + N | 0, C ^= x, C = C >>> 20 | C << 12, E = E + F | 0, k ^= E, k = k >>> 16 | k << 16, K = K + k | 0, F ^= K, F = F >>> 20 | F << 12, p = p + o | 0, q ^= p, q = q >>> 16 | q << 16, G = G + q | 0, o ^= G, o = o >>> 20 | o << 12, E = E + F | 0, k ^= E, k = k >>> 24 | k << 8, K = K + k | 0, F ^= K, F = F >>> 25 | F << 7, p = p + o | 0, q ^= p, q = q >>> 24 | q << 8, G = G + q | 0, o ^= G, o = o >>> 25 | o << 7, m = m + C | 0, N ^= m, N = N >>> 24 | N << 8, x = x + N | 0, C ^= x, C = C >>> 25 | C << 7, O = O + d | 0, U ^= O, U = U >>> 24 | U << 8, X = X + U | 0, d ^= X, d = d >>> 25 | d << 7;
  it.writeUint32LE(O + i | 0, t, 0), it.writeUint32LE(m + n | 0, t, 4), it.writeUint32LE(E + s | 0, t, 8), it.writeUint32LE(p + u | 0, t, 12), it.writeUint32LE(o + a | 0, t, 16), it.writeUint32LE(d + l | 0, t, 20), it.writeUint32LE(C + h | 0, t, 24), it.writeUint32LE(F + f | 0, t, 28), it.writeUint32LE(K + y | 0, t, 32), it.writeUint32LE(G + g | 0, t, 36), it.writeUint32LE(X + _ | 0, t, 40), it.writeUint32LE(x + w | 0, t, 44), it.writeUint32LE(N + T | 0, t, 48), it.writeUint32LE(k + A | 0, t, 52), it.writeUint32LE(q + j | 0, t, 56), it.writeUint32LE(U + D | 0, t, 60);
}
function Bo(t, e, r, i, n) {
  if (n === void 0 && (n = 0), t.length !== 32)
    throw new Error("ChaCha: key size must be 32 bytes");
  if (i.length < r.length)
    throw new Error("ChaCha: destination is shorter than source");
  var s, u;
  if (n === 0) {
    if (e.length !== 8 && e.length !== 12)
      throw new Error("ChaCha nonce must be 8 or 12 bytes");
    s = new Uint8Array(16), u = s.length - e.length, s.set(e, u);
  } else {
    if (e.length !== 16)
      throw new Error("ChaCha nonce with counter must be 16 bytes");
    s = e, u = n;
  }
  for (var a = new Uint8Array(64), l = 0; l < r.length; l += 64) {
    Xh(a, s, t);
    for (var h = l; h < l + 64 && h < r.length; h++)
      i[h] = r[h] ^ a[h - l];
    Zh(s, 0, u);
  }
  return nn.wipe(a), n === 0 && nn.wipe(s), i;
}
yi.streamXOR = Bo;
function Qh(t, e, r, i) {
  return i === void 0 && (i = 0), nn.wipe(r), Bo(t, e, r, r, i);
}
yi.stream = Qh;
function Zh(t, e, r) {
  for (var i = 1; r--; )
    i = i + (t[e] & 255) | 0, t[e] = i & 255, i >>>= 8, e++;
  if (i > 0)
    throw new Error("ChaCha: counter overflow");
}
var zo = {}, Gt = {};
Object.defineProperty(Gt, "__esModule", { value: !0 });
function el(t, e, r) {
  return ~(t - 1) & e | t - 1 & r;
}
Gt.select = el;
function tl(t, e) {
  return (t | 0) - (e | 0) - 1 >>> 31 & 1;
}
Gt.lessOrEqual = tl;
function Ko(t, e) {
  if (t.length !== e.length)
    return 0;
  for (var r = 0, i = 0; i < t.length; i++)
    r |= t[i] ^ e[i];
  return 1 & r - 1 >>> 8;
}
Gt.compare = Ko;
function rl(t, e) {
  return t.length === 0 || e.length === 0 ? !1 : Ko(t, e) !== 0;
}
Gt.equal = rl;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = Gt, r = bt;
  t.DIGEST_LENGTH = 16;
  var i = (
    /** @class */
    function() {
      function u(a) {
        this.digestLength = t.DIGEST_LENGTH, this._buffer = new Uint8Array(16), this._r = new Uint16Array(10), this._h = new Uint16Array(10), this._pad = new Uint16Array(8), this._leftover = 0, this._fin = 0, this._finished = !1;
        var l = a[0] | a[1] << 8;
        this._r[0] = l & 8191;
        var h = a[2] | a[3] << 8;
        this._r[1] = (l >>> 13 | h << 3) & 8191;
        var f = a[4] | a[5] << 8;
        this._r[2] = (h >>> 10 | f << 6) & 7939;
        var y = a[6] | a[7] << 8;
        this._r[3] = (f >>> 7 | y << 9) & 8191;
        var g = a[8] | a[9] << 8;
        this._r[4] = (y >>> 4 | g << 12) & 255, this._r[5] = g >>> 1 & 8190;
        var _ = a[10] | a[11] << 8;
        this._r[6] = (g >>> 14 | _ << 2) & 8191;
        var w = a[12] | a[13] << 8;
        this._r[7] = (_ >>> 11 | w << 5) & 8065;
        var T = a[14] | a[15] << 8;
        this._r[8] = (w >>> 8 | T << 8) & 8191, this._r[9] = T >>> 5 & 127, this._pad[0] = a[16] | a[17] << 8, this._pad[1] = a[18] | a[19] << 8, this._pad[2] = a[20] | a[21] << 8, this._pad[3] = a[22] | a[23] << 8, this._pad[4] = a[24] | a[25] << 8, this._pad[5] = a[26] | a[27] << 8, this._pad[6] = a[28] | a[29] << 8, this._pad[7] = a[30] | a[31] << 8;
      }
      return u.prototype._blocks = function(a, l, h) {
        for (var f = this._fin ? 0 : 2048, y = this._h[0], g = this._h[1], _ = this._h[2], w = this._h[3], T = this._h[4], A = this._h[5], j = this._h[6], D = this._h[7], O = this._h[8], m = this._h[9], E = this._r[0], p = this._r[1], o = this._r[2], d = this._r[3], C = this._r[4], F = this._r[5], K = this._r[6], G = this._r[7], X = this._r[8], x = this._r[9]; h >= 16; ) {
          var N = a[l + 0] | a[l + 1] << 8;
          y += N & 8191;
          var k = a[l + 2] | a[l + 3] << 8;
          g += (N >>> 13 | k << 3) & 8191;
          var q = a[l + 4] | a[l + 5] << 8;
          _ += (k >>> 10 | q << 6) & 8191;
          var U = a[l + 6] | a[l + 7] << 8;
          w += (q >>> 7 | U << 9) & 8191;
          var M = a[l + 8] | a[l + 9] << 8;
          T += (U >>> 4 | M << 12) & 8191, A += M >>> 1 & 8191;
          var $ = a[l + 10] | a[l + 11] << 8;
          j += (M >>> 14 | $ << 2) & 8191;
          var B = a[l + 12] | a[l + 13] << 8;
          D += ($ >>> 11 | B << 5) & 8191;
          var te = a[l + 14] | a[l + 15] << 8;
          O += (B >>> 8 | te << 8) & 8191, m += te >>> 5 | f;
          var z = 0, Z = z;
          Z += y * E, Z += g * (5 * x), Z += _ * (5 * X), Z += w * (5 * G), Z += T * (5 * K), z = Z >>> 13, Z &= 8191, Z += A * (5 * F), Z += j * (5 * C), Z += D * (5 * d), Z += O * (5 * o), Z += m * (5 * p), z += Z >>> 13, Z &= 8191;
          var Y = z;
          Y += y * p, Y += g * E, Y += _ * (5 * x), Y += w * (5 * X), Y += T * (5 * G), z = Y >>> 13, Y &= 8191, Y += A * (5 * K), Y += j * (5 * F), Y += D * (5 * C), Y += O * (5 * d), Y += m * (5 * o), z += Y >>> 13, Y &= 8191;
          var ee = z;
          ee += y * o, ee += g * p, ee += _ * E, ee += w * (5 * x), ee += T * (5 * X), z = ee >>> 13, ee &= 8191, ee += A * (5 * G), ee += j * (5 * K), ee += D * (5 * F), ee += O * (5 * C), ee += m * (5 * d), z += ee >>> 13, ee &= 8191;
          var R = z;
          R += y * d, R += g * o, R += _ * p, R += w * E, R += T * (5 * x), z = R >>> 13, R &= 8191, R += A * (5 * X), R += j * (5 * G), R += D * (5 * K), R += O * (5 * F), R += m * (5 * C), z += R >>> 13, R &= 8191;
          var P = z;
          P += y * C, P += g * d, P += _ * o, P += w * p, P += T * E, z = P >>> 13, P &= 8191, P += A * (5 * x), P += j * (5 * X), P += D * (5 * G), P += O * (5 * K), P += m * (5 * F), z += P >>> 13, P &= 8191;
          var S = z;
          S += y * F, S += g * C, S += _ * d, S += w * o, S += T * p, z = S >>> 13, S &= 8191, S += A * E, S += j * (5 * x), S += D * (5 * X), S += O * (5 * G), S += m * (5 * K), z += S >>> 13, S &= 8191;
          var c = z;
          c += y * K, c += g * F, c += _ * C, c += w * d, c += T * o, z = c >>> 13, c &= 8191, c += A * p, c += j * E, c += D * (5 * x), c += O * (5 * X), c += m * (5 * G), z += c >>> 13, c &= 8191;
          var v = z;
          v += y * G, v += g * K, v += _ * F, v += w * C, v += T * d, z = v >>> 13, v &= 8191, v += A * o, v += j * p, v += D * E, v += O * (5 * x), v += m * (5 * X), z += v >>> 13, v &= 8191;
          var V = z;
          V += y * X, V += g * G, V += _ * K, V += w * F, V += T * C, z = V >>> 13, V &= 8191, V += A * d, V += j * o, V += D * p, V += O * E, V += m * (5 * x), z += V >>> 13, V &= 8191;
          var W = z;
          W += y * x, W += g * X, W += _ * G, W += w * K, W += T * F, z = W >>> 13, W &= 8191, W += A * C, W += j * d, W += D * o, W += O * p, W += m * E, z += W >>> 13, W &= 8191, z = (z << 2) + z | 0, z = z + Z | 0, Z = z & 8191, z = z >>> 13, Y += z, y = Z, g = Y, _ = ee, w = R, T = P, A = S, j = c, D = v, O = V, m = W, l += 16, h -= 16;
        }
        this._h[0] = y, this._h[1] = g, this._h[2] = _, this._h[3] = w, this._h[4] = T, this._h[5] = A, this._h[6] = j, this._h[7] = D, this._h[8] = O, this._h[9] = m;
      }, u.prototype.finish = function(a, l) {
        l === void 0 && (l = 0);
        var h = new Uint16Array(10), f, y, g, _;
        if (this._leftover) {
          for (_ = this._leftover, this._buffer[_++] = 1; _ < 16; _++)
            this._buffer[_] = 0;
          this._fin = 1, this._blocks(this._buffer, 0, 16);
        }
        for (f = this._h[1] >>> 13, this._h[1] &= 8191, _ = 2; _ < 10; _++)
          this._h[_] += f, f = this._h[_] >>> 13, this._h[_] &= 8191;
        for (this._h[0] += f * 5, f = this._h[0] >>> 13, this._h[0] &= 8191, this._h[1] += f, f = this._h[1] >>> 13, this._h[1] &= 8191, this._h[2] += f, h[0] = this._h[0] + 5, f = h[0] >>> 13, h[0] &= 8191, _ = 1; _ < 10; _++)
          h[_] = this._h[_] + f, f = h[_] >>> 13, h[_] &= 8191;
        for (h[9] -= 8192, y = (f ^ 1) - 1, _ = 0; _ < 10; _++)
          h[_] &= y;
        for (y = ~y, _ = 0; _ < 10; _++)
          this._h[_] = this._h[_] & y | h[_];
        for (this._h[0] = (this._h[0] | this._h[1] << 13) & 65535, this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535, this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535, this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535, this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535, this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535, this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535, this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535, g = this._h[0] + this._pad[0], this._h[0] = g & 65535, _ = 1; _ < 8; _++)
          g = (this._h[_] + this._pad[_] | 0) + (g >>> 16) | 0, this._h[_] = g & 65535;
        return a[l + 0] = this._h[0] >>> 0, a[l + 1] = this._h[0] >>> 8, a[l + 2] = this._h[1] >>> 0, a[l + 3] = this._h[1] >>> 8, a[l + 4] = this._h[2] >>> 0, a[l + 5] = this._h[2] >>> 8, a[l + 6] = this._h[3] >>> 0, a[l + 7] = this._h[3] >>> 8, a[l + 8] = this._h[4] >>> 0, a[l + 9] = this._h[4] >>> 8, a[l + 10] = this._h[5] >>> 0, a[l + 11] = this._h[5] >>> 8, a[l + 12] = this._h[6] >>> 0, a[l + 13] = this._h[6] >>> 8, a[l + 14] = this._h[7] >>> 0, a[l + 15] = this._h[7] >>> 8, this._finished = !0, this;
      }, u.prototype.update = function(a) {
        var l = 0, h = a.length, f;
        if (this._leftover) {
          f = 16 - this._leftover, f > h && (f = h);
          for (var y = 0; y < f; y++)
            this._buffer[this._leftover + y] = a[l + y];
          if (h -= f, l += f, this._leftover += f, this._leftover < 16)
            return this;
          this._blocks(this._buffer, 0, 16), this._leftover = 0;
        }
        if (h >= 16 && (f = h - h % 16, this._blocks(a, l, f), l += f, h -= f), h) {
          for (var y = 0; y < h; y++)
            this._buffer[this._leftover + y] = a[l + y];
          this._leftover += h;
        }
        return this;
      }, u.prototype.digest = function() {
        if (this._finished)
          throw new Error("Poly1305 was finished");
        var a = new Uint8Array(16);
        return this.finish(a), a;
      }, u.prototype.clean = function() {
        return r.wipe(this._buffer), r.wipe(this._r), r.wipe(this._h), r.wipe(this._pad), this._leftover = 0, this._fin = 0, this._finished = !0, this;
      }, u;
    }()
  );
  t.Poly1305 = i;
  function n(u, a) {
    var l = new i(u);
    l.update(a);
    var h = l.digest();
    return l.clean(), h;
  }
  t.oneTimeAuth = n;
  function s(u, a) {
    return u.length !== t.DIGEST_LENGTH || a.length !== t.DIGEST_LENGTH ? !1 : e.equal(u, a);
  }
  t.equal = s;
})(zo);
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = yi, r = zo, i = bt, n = ne, s = Gt;
  t.KEY_LENGTH = 32, t.NONCE_LENGTH = 12, t.TAG_LENGTH = 16;
  var u = new Uint8Array(16), a = (
    /** @class */
    function() {
      function l(h) {
        if (this.nonceLength = t.NONCE_LENGTH, this.tagLength = t.TAG_LENGTH, h.length !== t.KEY_LENGTH)
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        this._key = new Uint8Array(h);
      }
      return l.prototype.seal = function(h, f, y, g) {
        if (h.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        var _ = new Uint8Array(16);
        _.set(h, _.length - h.length);
        var w = new Uint8Array(32);
        e.stream(this._key, _, w, 4);
        var T = f.length + this.tagLength, A;
        if (g) {
          if (g.length !== T)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          A = g;
        } else
          A = new Uint8Array(T);
        return e.streamXOR(this._key, _, f, A, 4), this._authenticate(A.subarray(A.length - this.tagLength, A.length), w, A.subarray(0, A.length - this.tagLength), y), i.wipe(_), A;
      }, l.prototype.open = function(h, f, y, g) {
        if (h.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        if (f.length < this.tagLength)
          return null;
        var _ = new Uint8Array(16);
        _.set(h, _.length - h.length);
        var w = new Uint8Array(32);
        e.stream(this._key, _, w, 4);
        var T = new Uint8Array(this.tagLength);
        if (this._authenticate(T, w, f.subarray(0, f.length - this.tagLength), y), !s.equal(T, f.subarray(f.length - this.tagLength, f.length)))
          return null;
        var A = f.length - this.tagLength, j;
        if (g) {
          if (g.length !== A)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          j = g;
        } else
          j = new Uint8Array(A);
        return e.streamXOR(this._key, _, f.subarray(0, f.length - this.tagLength), j, 4), i.wipe(_), j;
      }, l.prototype.clean = function() {
        return i.wipe(this._key), this;
      }, l.prototype._authenticate = function(h, f, y, g) {
        var _ = new r.Poly1305(f);
        g && (_.update(g), g.length % 16 > 0 && _.update(u.subarray(g.length % 16))), _.update(y), y.length % 16 > 0 && _.update(u.subarray(y.length % 16));
        var w = new Uint8Array(8);
        g && n.writeUint64LE(g.length, w), _.update(w), n.writeUint64LE(y.length, w), _.update(w);
        for (var T = _.digest(), A = 0; A < T.length; A++)
          h[A] = T[A];
        _.clean(), i.wipe(T), i.wipe(w);
      }, l;
    }()
  );
  t.ChaCha20Poly1305 = a;
})(Rn);
var Vo = {}, Vr = {}, Nn = {};
Object.defineProperty(Nn, "__esModule", { value: !0 });
function il(t) {
  return typeof t.saveState < "u" && typeof t.restoreState < "u" && typeof t.cleanSavedState < "u";
}
Nn.isSerializableHash = il;
Object.defineProperty(Vr, "__esModule", { value: !0 });
var Ot = Nn, nl = Gt, sl = bt, Ho = (
  /** @class */
  function() {
    function t(e, r) {
      this._finished = !1, this._inner = new e(), this._outer = new e(), this.blockSize = this._outer.blockSize, this.digestLength = this._outer.digestLength;
      var i = new Uint8Array(this.blockSize);
      r.length > this.blockSize ? this._inner.update(r).finish(i).clean() : i.set(r);
      for (var n = 0; n < i.length; n++)
        i[n] ^= 54;
      this._inner.update(i);
      for (var n = 0; n < i.length; n++)
        i[n] ^= 106;
      this._outer.update(i), Ot.isSerializableHash(this._inner) && Ot.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(), this._outerKeyedState = this._outer.saveState()), sl.wipe(i);
    }
    return t.prototype.reset = function() {
      if (!Ot.isSerializableHash(this._inner) || !Ot.isSerializableHash(this._outer))
        throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
      return this._inner.restoreState(this._innerKeyedState), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, t.prototype.clean = function() {
      Ot.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState), Ot.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState), this._inner.clean(), this._outer.clean();
    }, t.prototype.update = function(e) {
      return this._inner.update(e), this;
    }, t.prototype.finish = function(e) {
      return this._finished ? (this._outer.finish(e), this) : (this._inner.finish(e), this._outer.update(e.subarray(0, this.digestLength)).finish(e), this._finished = !0, this);
    }, t.prototype.digest = function() {
      var e = new Uint8Array(this.digestLength);
      return this.finish(e), e;
    }, t.prototype.saveState = function() {
      if (!Ot.isSerializableHash(this._inner))
        throw new Error("hmac: can't saveState() because hash doesn't implement it");
      return this._inner.saveState();
    }, t.prototype.restoreState = function(e) {
      if (!Ot.isSerializableHash(this._inner) || !Ot.isSerializableHash(this._outer))
        throw new Error("hmac: can't restoreState() because hash doesn't implement it");
      return this._inner.restoreState(e), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, t.prototype.cleanSavedState = function(e) {
      if (!Ot.isSerializableHash(this._inner))
        throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
      this._inner.cleanSavedState(e);
    }, t;
  }()
);
Vr.HMAC = Ho;
function ol(t, e, r) {
  var i = new Ho(t, e);
  i.update(r);
  var n = i.digest();
  return i.clean(), n;
}
Vr.hmac = ol;
Vr.equal = nl.equal;
Object.defineProperty(Vo, "__esModule", { value: !0 });
var xs = Vr, Is = bt, al = (
  /** @class */
  function() {
    function t(e, r, i, n) {
      i === void 0 && (i = new Uint8Array(0)), this._counter = new Uint8Array(1), this._hash = e, this._info = n;
      var s = xs.hmac(this._hash, i, r);
      this._hmac = new xs.HMAC(e, s), this._buffer = new Uint8Array(this._hmac.digestLength), this._bufpos = this._buffer.length;
    }
    return t.prototype._fillBuffer = function() {
      this._counter[0]++;
      var e = this._counter[0];
      if (e === 0)
        throw new Error("hkdf: cannot expand more");
      this._hmac.reset(), e > 1 && this._hmac.update(this._buffer), this._info && this._hmac.update(this._info), this._hmac.update(this._counter), this._hmac.finish(this._buffer), this._bufpos = 0;
    }, t.prototype.expand = function(e) {
      for (var r = new Uint8Array(e), i = 0; i < r.length; i++)
        this._bufpos === this._buffer.length && this._fillBuffer(), r[i] = this._buffer[this._bufpos++];
      return r;
    }, t.prototype.clean = function() {
      this._hmac.clean(), Is.wipe(this._buffer), Is.wipe(this._counter), this._bufpos = 0;
    }, t;
  }()
), cl = Vo.HKDF = al, _r = {}, bi = {}, _i = {};
Object.defineProperty(_i, "__esModule", { value: !0 });
_i.BrowserRandomSource = void 0;
const Os = 65536;
class ul {
  constructor() {
    this.isAvailable = !1, this.isInstantiated = !1;
    const e = typeof self < "u" ? self.crypto || self.msCrypto : null;
    e && e.getRandomValues !== void 0 && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0);
  }
  randomBytes(e) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Browser random byte generator is not available.");
    const r = new Uint8Array(e);
    for (let i = 0; i < r.length; i += Os)
      this._crypto.getRandomValues(r.subarray(i, i + Math.min(r.length - i, Os)));
    return r;
  }
}
_i.BrowserRandomSource = ul;
function hl(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var mi = {};
const ll = {}, fl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: ll
}, Symbol.toStringTag, { value: "Module" })), dl = /* @__PURE__ */ nr(fl);
Object.defineProperty(mi, "__esModule", { value: !0 });
mi.NodeRandomSource = void 0;
const pl = bt;
class gl {
  constructor() {
    if (this.isAvailable = !1, this.isInstantiated = !1, typeof hl < "u") {
      const e = dl;
      e && e.randomBytes && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0);
    }
  }
  randomBytes(e) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Node.js random byte generator is not available.");
    let r = this._crypto.randomBytes(e);
    if (r.length !== e)
      throw new Error("NodeRandomSource: got fewer bytes than requested");
    const i = new Uint8Array(e);
    for (let n = 0; n < i.length; n++)
      i[n] = r[n];
    return (0, pl.wipe)(r), i;
  }
}
mi.NodeRandomSource = gl;
Object.defineProperty(bi, "__esModule", { value: !0 });
bi.SystemRandomSource = void 0;
const yl = _i, bl = mi;
class _l {
  constructor() {
    if (this.isAvailable = !1, this.name = "", this._source = new yl.BrowserRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Browser";
      return;
    }
    if (this._source = new bl.NodeRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Node";
      return;
    }
  }
  randomBytes(e) {
    if (!this.isAvailable)
      throw new Error("System random byte generator is not available.");
    return this._source.randomBytes(e);
  }
}
bi.SystemRandomSource = _l;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.randomStringForEntropy = t.randomString = t.randomUint32 = t.randomBytes = t.defaultRandomSource = void 0;
  const e = bi, r = ne, i = bt;
  t.defaultRandomSource = new e.SystemRandomSource();
  function n(h, f = t.defaultRandomSource) {
    return f.randomBytes(h);
  }
  t.randomBytes = n;
  function s(h = t.defaultRandomSource) {
    const f = n(4, h), y = (0, r.readUint32LE)(f);
    return (0, i.wipe)(f), y;
  }
  t.randomUint32 = s;
  const u = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function a(h, f = u, y = t.defaultRandomSource) {
    if (f.length < 2)
      throw new Error("randomString charset is too short");
    if (f.length > 256)
      throw new Error("randomString charset is too long");
    let g = "";
    const _ = f.length, w = 256 - 256 % _;
    for (; h > 0; ) {
      const T = n(Math.ceil(h * 256 / w), y);
      for (let A = 0; A < T.length && h > 0; A++) {
        const j = T[A];
        j < w && (g += f.charAt(j % _), h--);
      }
      (0, i.wipe)(T);
    }
    return g;
  }
  t.randomString = a;
  function l(h, f = u, y = t.defaultRandomSource) {
    const g = Math.ceil(h / (Math.log(f.length) / Math.LN2));
    return a(g, f, y);
  }
  t.randomStringForEntropy = l;
})(_r);
var wi = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = ne, r = bt;
  t.DIGEST_LENGTH = 32, t.BLOCK_SIZE = 64;
  var i = (
    /** @class */
    function() {
      function a() {
        this.digestLength = t.DIGEST_LENGTH, this.blockSize = t.BLOCK_SIZE, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return a.prototype._initState = function() {
        this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225;
      }, a.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, a.prototype.clean = function() {
        r.wipe(this._buffer), r.wipe(this._temp), this.reset();
      }, a.prototype.update = function(l, h) {
        if (h === void 0 && (h = l.length), this._finished)
          throw new Error("SHA256: can't update because hash was finished.");
        var f = 0;
        if (this._bytesHashed += h, this._bufferLength > 0) {
          for (; this._bufferLength < this.blockSize && h > 0; )
            this._buffer[this._bufferLength++] = l[f++], h--;
          this._bufferLength === this.blockSize && (s(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (h >= this.blockSize && (f = s(this._temp, this._state, l, f, h), h %= this.blockSize); h > 0; )
          this._buffer[this._bufferLength++] = l[f++], h--;
        return this;
      }, a.prototype.finish = function(l) {
        if (!this._finished) {
          var h = this._bytesHashed, f = this._bufferLength, y = h / 536870912 | 0, g = h << 3, _ = h % 64 < 56 ? 64 : 128;
          this._buffer[f] = 128;
          for (var w = f + 1; w < _ - 8; w++)
            this._buffer[w] = 0;
          e.writeUint32BE(y, this._buffer, _ - 8), e.writeUint32BE(g, this._buffer, _ - 4), s(this._temp, this._state, this._buffer, 0, _), this._finished = !0;
        }
        for (var w = 0; w < this.digestLength / 4; w++)
          e.writeUint32BE(this._state[w], l, w * 4);
        return this;
      }, a.prototype.digest = function() {
        var l = new Uint8Array(this.digestLength);
        return this.finish(l), l;
      }, a.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          state: new Int32Array(this._state),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, a.prototype.restoreState = function(l) {
        return this._state.set(l.state), this._bufferLength = l.bufferLength, l.buffer && this._buffer.set(l.buffer), this._bytesHashed = l.bytesHashed, this._finished = !1, this;
      }, a.prototype.cleanSavedState = function(l) {
        r.wipe(l.state), l.buffer && r.wipe(l.buffer), l.bufferLength = 0, l.bytesHashed = 0;
      }, a;
    }()
  );
  t.SHA256 = i;
  var n = new Int32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  function s(a, l, h, f, y) {
    for (; y >= 64; ) {
      for (var g = l[0], _ = l[1], w = l[2], T = l[3], A = l[4], j = l[5], D = l[6], O = l[7], m = 0; m < 16; m++) {
        var E = f + m * 4;
        a[m] = e.readUint32BE(h, E);
      }
      for (var m = 16; m < 64; m++) {
        var p = a[m - 2], o = (p >>> 17 | p << 15) ^ (p >>> 19 | p << 13) ^ p >>> 10;
        p = a[m - 15];
        var d = (p >>> 7 | p << 25) ^ (p >>> 18 | p << 14) ^ p >>> 3;
        a[m] = (o + a[m - 7] | 0) + (d + a[m - 16] | 0);
      }
      for (var m = 0; m < 64; m++) {
        var o = (((A >>> 6 | A << 26) ^ (A >>> 11 | A << 21) ^ (A >>> 25 | A << 7)) + (A & j ^ ~A & D) | 0) + (O + (n[m] + a[m] | 0) | 0) | 0, d = ((g >>> 2 | g << 30) ^ (g >>> 13 | g << 19) ^ (g >>> 22 | g << 10)) + (g & _ ^ g & w ^ _ & w) | 0;
        O = D, D = j, j = A, A = T + o | 0, T = w, w = _, _ = g, g = o + d | 0;
      }
      l[0] += g, l[1] += _, l[2] += w, l[3] += T, l[4] += A, l[5] += j, l[6] += D, l[7] += O, f += 64, y -= 64;
    }
    return f;
  }
  function u(a) {
    var l = new i();
    l.update(a);
    var h = l.digest();
    return l.clean(), h;
  }
  t.hash = u;
})(wi);
var An = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.sharedKey = t.generateKeyPair = t.generateKeyPairFromSeed = t.scalarMultBase = t.scalarMult = t.SHARED_KEY_LENGTH = t.SECRET_KEY_LENGTH = t.PUBLIC_KEY_LENGTH = void 0;
  const e = _r, r = bt;
  t.PUBLIC_KEY_LENGTH = 32, t.SECRET_KEY_LENGTH = 32, t.SHARED_KEY_LENGTH = 32;
  function i(m) {
    const E = new Float64Array(16);
    if (m)
      for (let p = 0; p < m.length; p++)
        E[p] = m[p];
    return E;
  }
  const n = new Uint8Array(32);
  n[0] = 9;
  const s = i([56129, 1]);
  function u(m) {
    let E = 1;
    for (let p = 0; p < 16; p++) {
      let o = m[p] + E + 65535;
      E = Math.floor(o / 65536), m[p] = o - E * 65536;
    }
    m[0] += E - 1 + 37 * (E - 1);
  }
  function a(m, E, p) {
    const o = ~(p - 1);
    for (let d = 0; d < 16; d++) {
      const C = o & (m[d] ^ E[d]);
      m[d] ^= C, E[d] ^= C;
    }
  }
  function l(m, E) {
    const p = i(), o = i();
    for (let d = 0; d < 16; d++)
      o[d] = E[d];
    u(o), u(o), u(o);
    for (let d = 0; d < 2; d++) {
      p[0] = o[0] - 65517;
      for (let F = 1; F < 15; F++)
        p[F] = o[F] - 65535 - (p[F - 1] >> 16 & 1), p[F - 1] &= 65535;
      p[15] = o[15] - 32767 - (p[14] >> 16 & 1);
      const C = p[15] >> 16 & 1;
      p[14] &= 65535, a(o, p, 1 - C);
    }
    for (let d = 0; d < 16; d++)
      m[2 * d] = o[d] & 255, m[2 * d + 1] = o[d] >> 8;
  }
  function h(m, E) {
    for (let p = 0; p < 16; p++)
      m[p] = E[2 * p] + (E[2 * p + 1] << 8);
    m[15] &= 32767;
  }
  function f(m, E, p) {
    for (let o = 0; o < 16; o++)
      m[o] = E[o] + p[o];
  }
  function y(m, E, p) {
    for (let o = 0; o < 16; o++)
      m[o] = E[o] - p[o];
  }
  function g(m, E, p) {
    let o, d, C = 0, F = 0, K = 0, G = 0, X = 0, x = 0, N = 0, k = 0, q = 0, U = 0, M = 0, $ = 0, B = 0, te = 0, z = 0, Z = 0, Y = 0, ee = 0, R = 0, P = 0, S = 0, c = 0, v = 0, V = 0, W = 0, le = 0, _e = 0, de = 0, ve = 0, Ue = 0, Re = 0, ye = p[0], pe = p[1], fe = p[2], ue = p[3], ce = p[4], ae = p[5], oe = p[6], re = p[7], he = p[8], ge = p[9], ie = p[10], me = p[11], we = p[12], De = p[13], Se = p[14], Ee = p[15];
    o = E[0], C += o * ye, F += o * pe, K += o * fe, G += o * ue, X += o * ce, x += o * ae, N += o * oe, k += o * re, q += o * he, U += o * ge, M += o * ie, $ += o * me, B += o * we, te += o * De, z += o * Se, Z += o * Ee, o = E[1], F += o * ye, K += o * pe, G += o * fe, X += o * ue, x += o * ce, N += o * ae, k += o * oe, q += o * re, U += o * he, M += o * ge, $ += o * ie, B += o * me, te += o * we, z += o * De, Z += o * Se, Y += o * Ee, o = E[2], K += o * ye, G += o * pe, X += o * fe, x += o * ue, N += o * ce, k += o * ae, q += o * oe, U += o * re, M += o * he, $ += o * ge, B += o * ie, te += o * me, z += o * we, Z += o * De, Y += o * Se, ee += o * Ee, o = E[3], G += o * ye, X += o * pe, x += o * fe, N += o * ue, k += o * ce, q += o * ae, U += o * oe, M += o * re, $ += o * he, B += o * ge, te += o * ie, z += o * me, Z += o * we, Y += o * De, ee += o * Se, R += o * Ee, o = E[4], X += o * ye, x += o * pe, N += o * fe, k += o * ue, q += o * ce, U += o * ae, M += o * oe, $ += o * re, B += o * he, te += o * ge, z += o * ie, Z += o * me, Y += o * we, ee += o * De, R += o * Se, P += o * Ee, o = E[5], x += o * ye, N += o * pe, k += o * fe, q += o * ue, U += o * ce, M += o * ae, $ += o * oe, B += o * re, te += o * he, z += o * ge, Z += o * ie, Y += o * me, ee += o * we, R += o * De, P += o * Se, S += o * Ee, o = E[6], N += o * ye, k += o * pe, q += o * fe, U += o * ue, M += o * ce, $ += o * ae, B += o * oe, te += o * re, z += o * he, Z += o * ge, Y += o * ie, ee += o * me, R += o * we, P += o * De, S += o * Se, c += o * Ee, o = E[7], k += o * ye, q += o * pe, U += o * fe, M += o * ue, $ += o * ce, B += o * ae, te += o * oe, z += o * re, Z += o * he, Y += o * ge, ee += o * ie, R += o * me, P += o * we, S += o * De, c += o * Se, v += o * Ee, o = E[8], q += o * ye, U += o * pe, M += o * fe, $ += o * ue, B += o * ce, te += o * ae, z += o * oe, Z += o * re, Y += o * he, ee += o * ge, R += o * ie, P += o * me, S += o * we, c += o * De, v += o * Se, V += o * Ee, o = E[9], U += o * ye, M += o * pe, $ += o * fe, B += o * ue, te += o * ce, z += o * ae, Z += o * oe, Y += o * re, ee += o * he, R += o * ge, P += o * ie, S += o * me, c += o * we, v += o * De, V += o * Se, W += o * Ee, o = E[10], M += o * ye, $ += o * pe, B += o * fe, te += o * ue, z += o * ce, Z += o * ae, Y += o * oe, ee += o * re, R += o * he, P += o * ge, S += o * ie, c += o * me, v += o * we, V += o * De, W += o * Se, le += o * Ee, o = E[11], $ += o * ye, B += o * pe, te += o * fe, z += o * ue, Z += o * ce, Y += o * ae, ee += o * oe, R += o * re, P += o * he, S += o * ge, c += o * ie, v += o * me, V += o * we, W += o * De, le += o * Se, _e += o * Ee, o = E[12], B += o * ye, te += o * pe, z += o * fe, Z += o * ue, Y += o * ce, ee += o * ae, R += o * oe, P += o * re, S += o * he, c += o * ge, v += o * ie, V += o * me, W += o * we, le += o * De, _e += o * Se, de += o * Ee, o = E[13], te += o * ye, z += o * pe, Z += o * fe, Y += o * ue, ee += o * ce, R += o * ae, P += o * oe, S += o * re, c += o * he, v += o * ge, V += o * ie, W += o * me, le += o * we, _e += o * De, de += o * Se, ve += o * Ee, o = E[14], z += o * ye, Z += o * pe, Y += o * fe, ee += o * ue, R += o * ce, P += o * ae, S += o * oe, c += o * re, v += o * he, V += o * ge, W += o * ie, le += o * me, _e += o * we, de += o * De, ve += o * Se, Ue += o * Ee, o = E[15], Z += o * ye, Y += o * pe, ee += o * fe, R += o * ue, P += o * ce, S += o * ae, c += o * oe, v += o * re, V += o * he, W += o * ge, le += o * ie, _e += o * me, de += o * we, ve += o * De, Ue += o * Se, Re += o * Ee, C += 38 * Y, F += 38 * ee, K += 38 * R, G += 38 * P, X += 38 * S, x += 38 * c, N += 38 * v, k += 38 * V, q += 38 * W, U += 38 * le, M += 38 * _e, $ += 38 * de, B += 38 * ve, te += 38 * Ue, z += 38 * Re, d = 1, o = C + d + 65535, d = Math.floor(o / 65536), C = o - d * 65536, o = F + d + 65535, d = Math.floor(o / 65536), F = o - d * 65536, o = K + d + 65535, d = Math.floor(o / 65536), K = o - d * 65536, o = G + d + 65535, d = Math.floor(o / 65536), G = o - d * 65536, o = X + d + 65535, d = Math.floor(o / 65536), X = o - d * 65536, o = x + d + 65535, d = Math.floor(o / 65536), x = o - d * 65536, o = N + d + 65535, d = Math.floor(o / 65536), N = o - d * 65536, o = k + d + 65535, d = Math.floor(o / 65536), k = o - d * 65536, o = q + d + 65535, d = Math.floor(o / 65536), q = o - d * 65536, o = U + d + 65535, d = Math.floor(o / 65536), U = o - d * 65536, o = M + d + 65535, d = Math.floor(o / 65536), M = o - d * 65536, o = $ + d + 65535, d = Math.floor(o / 65536), $ = o - d * 65536, o = B + d + 65535, d = Math.floor(o / 65536), B = o - d * 65536, o = te + d + 65535, d = Math.floor(o / 65536), te = o - d * 65536, o = z + d + 65535, d = Math.floor(o / 65536), z = o - d * 65536, o = Z + d + 65535, d = Math.floor(o / 65536), Z = o - d * 65536, C += d - 1 + 37 * (d - 1), d = 1, o = C + d + 65535, d = Math.floor(o / 65536), C = o - d * 65536, o = F + d + 65535, d = Math.floor(o / 65536), F = o - d * 65536, o = K + d + 65535, d = Math.floor(o / 65536), K = o - d * 65536, o = G + d + 65535, d = Math.floor(o / 65536), G = o - d * 65536, o = X + d + 65535, d = Math.floor(o / 65536), X = o - d * 65536, o = x + d + 65535, d = Math.floor(o / 65536), x = o - d * 65536, o = N + d + 65535, d = Math.floor(o / 65536), N = o - d * 65536, o = k + d + 65535, d = Math.floor(o / 65536), k = o - d * 65536, o = q + d + 65535, d = Math.floor(o / 65536), q = o - d * 65536, o = U + d + 65535, d = Math.floor(o / 65536), U = o - d * 65536, o = M + d + 65535, d = Math.floor(o / 65536), M = o - d * 65536, o = $ + d + 65535, d = Math.floor(o / 65536), $ = o - d * 65536, o = B + d + 65535, d = Math.floor(o / 65536), B = o - d * 65536, o = te + d + 65535, d = Math.floor(o / 65536), te = o - d * 65536, o = z + d + 65535, d = Math.floor(o / 65536), z = o - d * 65536, o = Z + d + 65535, d = Math.floor(o / 65536), Z = o - d * 65536, C += d - 1 + 37 * (d - 1), m[0] = C, m[1] = F, m[2] = K, m[3] = G, m[4] = X, m[5] = x, m[6] = N, m[7] = k, m[8] = q, m[9] = U, m[10] = M, m[11] = $, m[12] = B, m[13] = te, m[14] = z, m[15] = Z;
  }
  function _(m, E) {
    g(m, E, E);
  }
  function w(m, E) {
    const p = i();
    for (let o = 0; o < 16; o++)
      p[o] = E[o];
    for (let o = 253; o >= 0; o--)
      _(p, p), o !== 2 && o !== 4 && g(p, p, E);
    for (let o = 0; o < 16; o++)
      m[o] = p[o];
  }
  function T(m, E) {
    const p = new Uint8Array(32), o = new Float64Array(80), d = i(), C = i(), F = i(), K = i(), G = i(), X = i();
    for (let q = 0; q < 31; q++)
      p[q] = m[q];
    p[31] = m[31] & 127 | 64, p[0] &= 248, h(o, E);
    for (let q = 0; q < 16; q++)
      C[q] = o[q];
    d[0] = K[0] = 1;
    for (let q = 254; q >= 0; --q) {
      const U = p[q >>> 3] >>> (q & 7) & 1;
      a(d, C, U), a(F, K, U), f(G, d, F), y(d, d, F), f(F, C, K), y(C, C, K), _(K, G), _(X, d), g(d, F, d), g(F, C, G), f(G, d, F), y(d, d, F), _(C, d), y(F, K, X), g(d, F, s), f(d, d, K), g(F, F, d), g(d, K, X), g(K, C, o), _(C, G), a(d, C, U), a(F, K, U);
    }
    for (let q = 0; q < 16; q++)
      o[q + 16] = d[q], o[q + 32] = F[q], o[q + 48] = C[q], o[q + 64] = K[q];
    const x = o.subarray(32), N = o.subarray(16);
    w(x, x), g(N, N, x);
    const k = new Uint8Array(32);
    return l(k, N), k;
  }
  t.scalarMult = T;
  function A(m) {
    return T(m, n);
  }
  t.scalarMultBase = A;
  function j(m) {
    if (m.length !== t.SECRET_KEY_LENGTH)
      throw new Error(`x25519: seed must be ${t.SECRET_KEY_LENGTH} bytes`);
    const E = new Uint8Array(m);
    return {
      publicKey: A(E),
      secretKey: E
    };
  }
  t.generateKeyPairFromSeed = j;
  function D(m) {
    const E = (0, e.randomBytes)(32, m), p = j(E);
    return (0, r.wipe)(E), p;
  }
  t.generateKeyPair = D;
  function O(m, E, p = !1) {
    if (m.length !== t.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect secret key length");
    if (E.length !== t.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect public key length");
    const o = T(m, E);
    if (p) {
      let d = 0;
      for (let C = 0; C < o.length; C++)
        d |= o[C];
      if (d === 0)
        throw new Error("X25519: invalid shared key");
    }
    return o;
  }
  t.sharedKey = O;
})(An);
function ml(t, e) {
  if (t.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), i = 0; i < r.length; i++)
    r[i] = 255;
  for (var n = 0; n < t.length; n++) {
    var s = t.charAt(n), u = s.charCodeAt(0);
    if (r[u] !== 255)
      throw new TypeError(s + " is ambiguous");
    r[u] = n;
  }
  var a = t.length, l = t.charAt(0), h = Math.log(a) / Math.log(256), f = Math.log(256) / Math.log(a);
  function y(w) {
    if (w instanceof Uint8Array || (ArrayBuffer.isView(w) ? w = new Uint8Array(w.buffer, w.byteOffset, w.byteLength) : Array.isArray(w) && (w = Uint8Array.from(w))), !(w instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (w.length === 0)
      return "";
    for (var T = 0, A = 0, j = 0, D = w.length; j !== D && w[j] === 0; )
      j++, T++;
    for (var O = (D - j) * f + 1 >>> 0, m = new Uint8Array(O); j !== D; ) {
      for (var E = w[j], p = 0, o = O - 1; (E !== 0 || p < A) && o !== -1; o--, p++)
        E += 256 * m[o] >>> 0, m[o] = E % a >>> 0, E = E / a >>> 0;
      if (E !== 0)
        throw new Error("Non-zero carry");
      A = p, j++;
    }
    for (var d = O - A; d !== O && m[d] === 0; )
      d++;
    for (var C = l.repeat(T); d < O; ++d)
      C += t.charAt(m[d]);
    return C;
  }
  function g(w) {
    if (typeof w != "string")
      throw new TypeError("Expected String");
    if (w.length === 0)
      return new Uint8Array();
    var T = 0;
    if (w[T] !== " ") {
      for (var A = 0, j = 0; w[T] === l; )
        A++, T++;
      for (var D = (w.length - T) * h + 1 >>> 0, O = new Uint8Array(D); w[T]; ) {
        var m = r[w.charCodeAt(T)];
        if (m === 255)
          return;
        for (var E = 0, p = D - 1; (m !== 0 || E < j) && p !== -1; p--, E++)
          m += a * O[p] >>> 0, O[p] = m % 256 >>> 0, m = m / 256 >>> 0;
        if (m !== 0)
          throw new Error("Non-zero carry");
        j = E, T++;
      }
      if (w[T] !== " ") {
        for (var o = D - j; o !== D && O[o] === 0; )
          o++;
        for (var d = new Uint8Array(A + (D - o)), C = A; o !== D; )
          d[C++] = O[o++];
        return d;
      }
    }
  }
  function _(w) {
    var T = g(w);
    if (T)
      return T;
    throw new Error(`Non-${e} character`);
  }
  return {
    encode: y,
    decodeUnsafe: g,
    decode: _
  };
}
var wl = ml, vl = wl;
const El = (t) => {
  if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
    return t;
  if (t instanceof ArrayBuffer)
    return new Uint8Array(t);
  if (ArrayBuffer.isView(t))
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Unknown type, must be binary type");
}, Dl = (t) => new TextEncoder().encode(t), Sl = (t) => new TextDecoder().decode(t);
class xl {
  constructor(e, r, i) {
    this.name = e, this.prefix = r, this.baseEncode = i;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class Il {
  constructor(e, r, i) {
    if (this.name = e, this.prefix = r, r.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = r.codePointAt(0), this.baseDecode = i;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return Go(this, e);
  }
}
class Ol {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return Go(this, e);
  }
  decode(e) {
    const r = e[0], i = this.decoders[r];
    if (i)
      return i.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const Go = (t, e) => new Ol({
  ...t.decoders || { [t.prefix]: t },
  ...e.decoders || { [e.prefix]: e }
});
class Pl {
  constructor(e, r, i, n) {
    this.name = e, this.prefix = r, this.baseEncode = i, this.baseDecode = n, this.encoder = new xl(e, r, i), this.decoder = new Il(e, r, n);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const vi = ({ name: t, prefix: e, encode: r, decode: i }) => new Pl(t, e, r, i), Hr = ({ prefix: t, name: e, alphabet: r }) => {
  const { encode: i, decode: n } = vl(r, e);
  return vi({
    prefix: t,
    name: e,
    encode: i,
    decode: (s) => El(n(s))
  });
}, Tl = (t, e, r, i) => {
  const n = {};
  for (let f = 0; f < e.length; ++f)
    n[e[f]] = f;
  let s = t.length;
  for (; t[s - 1] === "="; )
    --s;
  const u = new Uint8Array(s * r / 8 | 0);
  let a = 0, l = 0, h = 0;
  for (let f = 0; f < s; ++f) {
    const y = n[t[f]];
    if (y === void 0)
      throw new SyntaxError(`Non-${i} character`);
    l = l << r | y, a += r, a >= 8 && (a -= 8, u[h++] = 255 & l >> a);
  }
  if (a >= r || 255 & l << 8 - a)
    throw new SyntaxError("Unexpected end of data");
  return u;
}, Rl = (t, e, r) => {
  const i = e[e.length - 1] === "=", n = (1 << r) - 1;
  let s = "", u = 0, a = 0;
  for (let l = 0; l < t.length; ++l)
    for (a = a << 8 | t[l], u += 8; u > r; )
      u -= r, s += e[n & a >> u];
  if (u && (s += e[n & a << r - u]), i)
    for (; s.length * r & 7; )
      s += "=";
  return s;
}, et = ({ name: t, prefix: e, bitsPerChar: r, alphabet: i }) => vi({
  prefix: e,
  name: t,
  encode(n) {
    return Rl(n, i, r);
  },
  decode(n) {
    return Tl(n, i, r, t);
  }
}), Nl = vi({
  prefix: "\0",
  name: "identity",
  encode: (t) => Sl(t),
  decode: (t) => Dl(t)
}), Al = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: Nl
}, Symbol.toStringTag, { value: "Module" })), Cl = et({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), Fl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2: Cl
}, Symbol.toStringTag, { value: "Module" })), $l = et({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), Ul = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8: $l
}, Symbol.toStringTag, { value: "Module" })), Ll = Hr({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), Ml = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10: Ll
}, Symbol.toStringTag, { value: "Module" })), jl = et({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), ql = et({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), Bl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16: jl,
  base16upper: ql
}, Symbol.toStringTag, { value: "Module" })), zl = et({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), Kl = et({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), Vl = et({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), Hl = et({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), Gl = et({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), kl = et({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), Wl = et({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), Yl = et({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), Jl = et({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), Xl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32: zl,
  base32hex: Gl,
  base32hexpad: Wl,
  base32hexpadupper: Yl,
  base32hexupper: kl,
  base32pad: Vl,
  base32padupper: Hl,
  base32upper: Kl,
  base32z: Jl
}, Symbol.toStringTag, { value: "Module" })), Ql = Hr({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), Zl = Hr({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), ef = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36: Ql,
  base36upper: Zl
}, Symbol.toStringTag, { value: "Module" })), tf = Hr({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), rf = Hr({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), nf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc: tf,
  base58flickr: rf
}, Symbol.toStringTag, { value: "Module" })), sf = et({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), of = et({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), af = et({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), cf = et({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), uf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: sf,
  base64pad: of,
  base64url: af,
  base64urlpad: cf
}, Symbol.toStringTag, { value: "Module" })), ko = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"), hf = ko.reduce((t, e, r) => (t[r] = e, t), []), lf = ko.reduce((t, e, r) => (t[e.codePointAt(0)] = r, t), []);
function ff(t) {
  return t.reduce((e, r) => (e += hf[r], e), "");
}
function df(t) {
  const e = [];
  for (const r of t) {
    const i = lf[r.codePointAt(0)];
    if (i === void 0)
      throw new Error(`Non-base256emoji character: ${r}`);
    e.push(i);
  }
  return new Uint8Array(e);
}
const pf = vi({
  prefix: "🚀",
  name: "base256emoji",
  encode: ff,
  decode: df
}), gf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji: pf
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const Ps = {
  ...Al,
  ...Fl,
  ...Ul,
  ...Ml,
  ...Bl,
  ...Xl,
  ...ef,
  ...nf,
  ...uf,
  ...gf
};
var Cn = {}, Wo = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = ne, r = bt;
  t.DIGEST_LENGTH = 64, t.BLOCK_SIZE = 128;
  var i = (
    /** @class */
    function() {
      function a() {
        this.digestLength = t.DIGEST_LENGTH, this.blockSize = t.BLOCK_SIZE, this._stateHi = new Int32Array(8), this._stateLo = new Int32Array(8), this._tempHi = new Int32Array(16), this._tempLo = new Int32Array(16), this._buffer = new Uint8Array(256), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return a.prototype._initState = function() {
        this._stateHi[0] = 1779033703, this._stateHi[1] = 3144134277, this._stateHi[2] = 1013904242, this._stateHi[3] = 2773480762, this._stateHi[4] = 1359893119, this._stateHi[5] = 2600822924, this._stateHi[6] = 528734635, this._stateHi[7] = 1541459225, this._stateLo[0] = 4089235720, this._stateLo[1] = 2227873595, this._stateLo[2] = 4271175723, this._stateLo[3] = 1595750129, this._stateLo[4] = 2917565137, this._stateLo[5] = 725511199, this._stateLo[6] = 4215389547, this._stateLo[7] = 327033209;
      }, a.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, a.prototype.clean = function() {
        r.wipe(this._buffer), r.wipe(this._tempHi), r.wipe(this._tempLo), this.reset();
      }, a.prototype.update = function(l, h) {
        if (h === void 0 && (h = l.length), this._finished)
          throw new Error("SHA512: can't update because hash was finished.");
        var f = 0;
        if (this._bytesHashed += h, this._bufferLength > 0) {
          for (; this._bufferLength < t.BLOCK_SIZE && h > 0; )
            this._buffer[this._bufferLength++] = l[f++], h--;
          this._bufferLength === this.blockSize && (s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (h >= this.blockSize && (f = s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, l, f, h), h %= this.blockSize); h > 0; )
          this._buffer[this._bufferLength++] = l[f++], h--;
        return this;
      }, a.prototype.finish = function(l) {
        if (!this._finished) {
          var h = this._bytesHashed, f = this._bufferLength, y = h / 536870912 | 0, g = h << 3, _ = h % 128 < 112 ? 128 : 256;
          this._buffer[f] = 128;
          for (var w = f + 1; w < _ - 8; w++)
            this._buffer[w] = 0;
          e.writeUint32BE(y, this._buffer, _ - 8), e.writeUint32BE(g, this._buffer, _ - 4), s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, _), this._finished = !0;
        }
        for (var w = 0; w < this.digestLength / 8; w++)
          e.writeUint32BE(this._stateHi[w], l, w * 8), e.writeUint32BE(this._stateLo[w], l, w * 8 + 4);
        return this;
      }, a.prototype.digest = function() {
        var l = new Uint8Array(this.digestLength);
        return this.finish(l), l;
      }, a.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          stateHi: new Int32Array(this._stateHi),
          stateLo: new Int32Array(this._stateLo),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, a.prototype.restoreState = function(l) {
        return this._stateHi.set(l.stateHi), this._stateLo.set(l.stateLo), this._bufferLength = l.bufferLength, l.buffer && this._buffer.set(l.buffer), this._bytesHashed = l.bytesHashed, this._finished = !1, this;
      }, a.prototype.cleanSavedState = function(l) {
        r.wipe(l.stateHi), r.wipe(l.stateLo), l.buffer && r.wipe(l.buffer), l.bufferLength = 0, l.bytesHashed = 0;
      }, a;
    }()
  );
  t.SHA512 = i;
  var n = new Int32Array([
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ]);
  function s(a, l, h, f, y, g, _) {
    for (var w = h[0], T = h[1], A = h[2], j = h[3], D = h[4], O = h[5], m = h[6], E = h[7], p = f[0], o = f[1], d = f[2], C = f[3], F = f[4], K = f[5], G = f[6], X = f[7], x, N, k, q, U, M, $, B; _ >= 128; ) {
      for (var te = 0; te < 16; te++) {
        var z = 8 * te + g;
        a[te] = e.readUint32BE(y, z), l[te] = e.readUint32BE(y, z + 4);
      }
      for (var te = 0; te < 80; te++) {
        var Z = w, Y = T, ee = A, R = j, P = D, S = O, c = m, v = E, V = p, W = o, le = d, _e = C, de = F, ve = K, Ue = G, Re = X;
        if (x = E, N = X, U = N & 65535, M = N >>> 16, $ = x & 65535, B = x >>> 16, x = (D >>> 14 | F << 18) ^ (D >>> 18 | F << 14) ^ (F >>> 9 | D << 23), N = (F >>> 14 | D << 18) ^ (F >>> 18 | D << 14) ^ (D >>> 9 | F << 23), U += N & 65535, M += N >>> 16, $ += x & 65535, B += x >>> 16, x = D & O ^ ~D & m, N = F & K ^ ~F & G, U += N & 65535, M += N >>> 16, $ += x & 65535, B += x >>> 16, x = n[te * 2], N = n[te * 2 + 1], U += N & 65535, M += N >>> 16, $ += x & 65535, B += x >>> 16, x = a[te % 16], N = l[te % 16], U += N & 65535, M += N >>> 16, $ += x & 65535, B += x >>> 16, M += U >>> 16, $ += M >>> 16, B += $ >>> 16, k = $ & 65535 | B << 16, q = U & 65535 | M << 16, x = k, N = q, U = N & 65535, M = N >>> 16, $ = x & 65535, B = x >>> 16, x = (w >>> 28 | p << 4) ^ (p >>> 2 | w << 30) ^ (p >>> 7 | w << 25), N = (p >>> 28 | w << 4) ^ (w >>> 2 | p << 30) ^ (w >>> 7 | p << 25), U += N & 65535, M += N >>> 16, $ += x & 65535, B += x >>> 16, x = w & T ^ w & A ^ T & A, N = p & o ^ p & d ^ o & d, U += N & 65535, M += N >>> 16, $ += x & 65535, B += x >>> 16, M += U >>> 16, $ += M >>> 16, B += $ >>> 16, v = $ & 65535 | B << 16, Re = U & 65535 | M << 16, x = R, N = _e, U = N & 65535, M = N >>> 16, $ = x & 65535, B = x >>> 16, x = k, N = q, U += N & 65535, M += N >>> 16, $ += x & 65535, B += x >>> 16, M += U >>> 16, $ += M >>> 16, B += $ >>> 16, R = $ & 65535 | B << 16, _e = U & 65535 | M << 16, T = Z, A = Y, j = ee, D = R, O = P, m = S, E = c, w = v, o = V, d = W, C = le, F = _e, K = de, G = ve, X = Ue, p = Re, te % 16 === 15)
          for (var z = 0; z < 16; z++)
            x = a[z], N = l[z], U = N & 65535, M = N >>> 16, $ = x & 65535, B = x >>> 16, x = a[(z + 9) % 16], N = l[(z + 9) % 16], U += N & 65535, M += N >>> 16, $ += x & 65535, B += x >>> 16, k = a[(z + 1) % 16], q = l[(z + 1) % 16], x = (k >>> 1 | q << 31) ^ (k >>> 8 | q << 24) ^ k >>> 7, N = (q >>> 1 | k << 31) ^ (q >>> 8 | k << 24) ^ (q >>> 7 | k << 25), U += N & 65535, M += N >>> 16, $ += x & 65535, B += x >>> 16, k = a[(z + 14) % 16], q = l[(z + 14) % 16], x = (k >>> 19 | q << 13) ^ (q >>> 29 | k << 3) ^ k >>> 6, N = (q >>> 19 | k << 13) ^ (k >>> 29 | q << 3) ^ (q >>> 6 | k << 26), U += N & 65535, M += N >>> 16, $ += x & 65535, B += x >>> 16, M += U >>> 16, $ += M >>> 16, B += $ >>> 16, a[z] = $ & 65535 | B << 16, l[z] = U & 65535 | M << 16;
      }
      x = w, N = p, U = N & 65535, M = N >>> 16, $ = x & 65535, B = x >>> 16, x = h[0], N = f[0], U += N & 65535, M += N >>> 16, $ += x & 65535, B += x >>> 16, M += U >>> 16, $ += M >>> 16, B += $ >>> 16, h[0] = w = $ & 65535 | B << 16, f[0] = p = U & 65535 | M << 16, x = T, N = o, U = N & 65535, M = N >>> 16, $ = x & 65535, B = x >>> 16, x = h[1], N = f[1], U += N & 65535, M += N >>> 16, $ += x & 65535, B += x >>> 16, M += U >>> 16, $ += M >>> 16, B += $ >>> 16, h[1] = T = $ & 65535 | B << 16, f[1] = o = U & 65535 | M << 16, x = A, N = d, U = N & 65535, M = N >>> 16, $ = x & 65535, B = x >>> 16, x = h[2], N = f[2], U += N & 65535, M += N >>> 16, $ += x & 65535, B += x >>> 16, M += U >>> 16, $ += M >>> 16, B += $ >>> 16, h[2] = A = $ & 65535 | B << 16, f[2] = d = U & 65535 | M << 16, x = j, N = C, U = N & 65535, M = N >>> 16, $ = x & 65535, B = x >>> 16, x = h[3], N = f[3], U += N & 65535, M += N >>> 16, $ += x & 65535, B += x >>> 16, M += U >>> 16, $ += M >>> 16, B += $ >>> 16, h[3] = j = $ & 65535 | B << 16, f[3] = C = U & 65535 | M << 16, x = D, N = F, U = N & 65535, M = N >>> 16, $ = x & 65535, B = x >>> 16, x = h[4], N = f[4], U += N & 65535, M += N >>> 16, $ += x & 65535, B += x >>> 16, M += U >>> 16, $ += M >>> 16, B += $ >>> 16, h[4] = D = $ & 65535 | B << 16, f[4] = F = U & 65535 | M << 16, x = O, N = K, U = N & 65535, M = N >>> 16, $ = x & 65535, B = x >>> 16, x = h[5], N = f[5], U += N & 65535, M += N >>> 16, $ += x & 65535, B += x >>> 16, M += U >>> 16, $ += M >>> 16, B += $ >>> 16, h[5] = O = $ & 65535 | B << 16, f[5] = K = U & 65535 | M << 16, x = m, N = G, U = N & 65535, M = N >>> 16, $ = x & 65535, B = x >>> 16, x = h[6], N = f[6], U += N & 65535, M += N >>> 16, $ += x & 65535, B += x >>> 16, M += U >>> 16, $ += M >>> 16, B += $ >>> 16, h[6] = m = $ & 65535 | B << 16, f[6] = G = U & 65535 | M << 16, x = E, N = X, U = N & 65535, M = N >>> 16, $ = x & 65535, B = x >>> 16, x = h[7], N = f[7], U += N & 65535, M += N >>> 16, $ += x & 65535, B += x >>> 16, M += U >>> 16, $ += M >>> 16, B += $ >>> 16, h[7] = E = $ & 65535 | B << 16, f[7] = X = U & 65535 | M << 16, g += 128, _ -= 128;
    }
    return g;
  }
  function u(a) {
    var l = new i();
    l.update(a);
    var h = l.digest();
    return l.clean(), h;
  }
  t.hash = u;
})(Wo);
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.convertSecretKeyToX25519 = t.convertPublicKeyToX25519 = t.verify = t.sign = t.extractPublicKeyFromSecretKey = t.generateKeyPair = t.generateKeyPairFromSeed = t.SEED_LENGTH = t.SECRET_KEY_LENGTH = t.PUBLIC_KEY_LENGTH = t.SIGNATURE_LENGTH = void 0;
  const e = _r, r = Wo, i = bt;
  t.SIGNATURE_LENGTH = 64, t.PUBLIC_KEY_LENGTH = 32, t.SECRET_KEY_LENGTH = 64, t.SEED_LENGTH = 32;
  function n(R) {
    const P = new Float64Array(16);
    if (R)
      for (let S = 0; S < R.length; S++)
        P[S] = R[S];
    return P;
  }
  const s = new Uint8Array(32);
  s[0] = 9;
  const u = n(), a = n([1]), l = n([
    30883,
    4953,
    19914,
    30187,
    55467,
    16705,
    2637,
    112,
    59544,
    30585,
    16505,
    36039,
    65139,
    11119,
    27886,
    20995
  ]), h = n([
    61785,
    9906,
    39828,
    60374,
    45398,
    33411,
    5274,
    224,
    53552,
    61171,
    33010,
    6542,
    64743,
    22239,
    55772,
    9222
  ]), f = n([
    54554,
    36645,
    11616,
    51542,
    42930,
    38181,
    51040,
    26924,
    56412,
    64982,
    57905,
    49316,
    21502,
    52590,
    14035,
    8553
  ]), y = n([
    26200,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214
  ]), g = n([
    41136,
    18958,
    6951,
    50414,
    58488,
    44335,
    6150,
    12099,
    55207,
    15867,
    153,
    11085,
    57099,
    20417,
    9344,
    11139
  ]);
  function _(R, P) {
    for (let S = 0; S < 16; S++)
      R[S] = P[S] | 0;
  }
  function w(R) {
    let P = 1;
    for (let S = 0; S < 16; S++) {
      let c = R[S] + P + 65535;
      P = Math.floor(c / 65536), R[S] = c - P * 65536;
    }
    R[0] += P - 1 + 37 * (P - 1);
  }
  function T(R, P, S) {
    const c = ~(S - 1);
    for (let v = 0; v < 16; v++) {
      const V = c & (R[v] ^ P[v]);
      R[v] ^= V, P[v] ^= V;
    }
  }
  function A(R, P) {
    const S = n(), c = n();
    for (let v = 0; v < 16; v++)
      c[v] = P[v];
    w(c), w(c), w(c);
    for (let v = 0; v < 2; v++) {
      S[0] = c[0] - 65517;
      for (let W = 1; W < 15; W++)
        S[W] = c[W] - 65535 - (S[W - 1] >> 16 & 1), S[W - 1] &= 65535;
      S[15] = c[15] - 32767 - (S[14] >> 16 & 1);
      const V = S[15] >> 16 & 1;
      S[14] &= 65535, T(c, S, 1 - V);
    }
    for (let v = 0; v < 16; v++)
      R[2 * v] = c[v] & 255, R[2 * v + 1] = c[v] >> 8;
  }
  function j(R, P) {
    let S = 0;
    for (let c = 0; c < 32; c++)
      S |= R[c] ^ P[c];
    return (1 & S - 1 >>> 8) - 1;
  }
  function D(R, P) {
    const S = new Uint8Array(32), c = new Uint8Array(32);
    return A(S, R), A(c, P), j(S, c);
  }
  function O(R) {
    const P = new Uint8Array(32);
    return A(P, R), P[0] & 1;
  }
  function m(R, P) {
    for (let S = 0; S < 16; S++)
      R[S] = P[2 * S] + (P[2 * S + 1] << 8);
    R[15] &= 32767;
  }
  function E(R, P, S) {
    for (let c = 0; c < 16; c++)
      R[c] = P[c] + S[c];
  }
  function p(R, P, S) {
    for (let c = 0; c < 16; c++)
      R[c] = P[c] - S[c];
  }
  function o(R, P, S) {
    let c, v, V = 0, W = 0, le = 0, _e = 0, de = 0, ve = 0, Ue = 0, Re = 0, ye = 0, pe = 0, fe = 0, ue = 0, ce = 0, ae = 0, oe = 0, re = 0, he = 0, ge = 0, ie = 0, me = 0, we = 0, De = 0, Se = 0, Ee = 0, vt = 0, It = 0, qt = 0, gt = 0, Wt = 0, Dr = 0, Yr = 0, Le = S[0], Ne = S[1], Me = S[2], je = S[3], qe = S[4], Ae = S[5], Ve = S[6], He = S[7], Ge = S[8], ke = S[9], We = S[10], ze = S[11], Be = S[12], Pe = S[13], Ye = S[14], Je = S[15];
    c = P[0], V += c * Le, W += c * Ne, le += c * Me, _e += c * je, de += c * qe, ve += c * Ae, Ue += c * Ve, Re += c * He, ye += c * Ge, pe += c * ke, fe += c * We, ue += c * ze, ce += c * Be, ae += c * Pe, oe += c * Ye, re += c * Je, c = P[1], W += c * Le, le += c * Ne, _e += c * Me, de += c * je, ve += c * qe, Ue += c * Ae, Re += c * Ve, ye += c * He, pe += c * Ge, fe += c * ke, ue += c * We, ce += c * ze, ae += c * Be, oe += c * Pe, re += c * Ye, he += c * Je, c = P[2], le += c * Le, _e += c * Ne, de += c * Me, ve += c * je, Ue += c * qe, Re += c * Ae, ye += c * Ve, pe += c * He, fe += c * Ge, ue += c * ke, ce += c * We, ae += c * ze, oe += c * Be, re += c * Pe, he += c * Ye, ge += c * Je, c = P[3], _e += c * Le, de += c * Ne, ve += c * Me, Ue += c * je, Re += c * qe, ye += c * Ae, pe += c * Ve, fe += c * He, ue += c * Ge, ce += c * ke, ae += c * We, oe += c * ze, re += c * Be, he += c * Pe, ge += c * Ye, ie += c * Je, c = P[4], de += c * Le, ve += c * Ne, Ue += c * Me, Re += c * je, ye += c * qe, pe += c * Ae, fe += c * Ve, ue += c * He, ce += c * Ge, ae += c * ke, oe += c * We, re += c * ze, he += c * Be, ge += c * Pe, ie += c * Ye, me += c * Je, c = P[5], ve += c * Le, Ue += c * Ne, Re += c * Me, ye += c * je, pe += c * qe, fe += c * Ae, ue += c * Ve, ce += c * He, ae += c * Ge, oe += c * ke, re += c * We, he += c * ze, ge += c * Be, ie += c * Pe, me += c * Ye, we += c * Je, c = P[6], Ue += c * Le, Re += c * Ne, ye += c * Me, pe += c * je, fe += c * qe, ue += c * Ae, ce += c * Ve, ae += c * He, oe += c * Ge, re += c * ke, he += c * We, ge += c * ze, ie += c * Be, me += c * Pe, we += c * Ye, De += c * Je, c = P[7], Re += c * Le, ye += c * Ne, pe += c * Me, fe += c * je, ue += c * qe, ce += c * Ae, ae += c * Ve, oe += c * He, re += c * Ge, he += c * ke, ge += c * We, ie += c * ze, me += c * Be, we += c * Pe, De += c * Ye, Se += c * Je, c = P[8], ye += c * Le, pe += c * Ne, fe += c * Me, ue += c * je, ce += c * qe, ae += c * Ae, oe += c * Ve, re += c * He, he += c * Ge, ge += c * ke, ie += c * We, me += c * ze, we += c * Be, De += c * Pe, Se += c * Ye, Ee += c * Je, c = P[9], pe += c * Le, fe += c * Ne, ue += c * Me, ce += c * je, ae += c * qe, oe += c * Ae, re += c * Ve, he += c * He, ge += c * Ge, ie += c * ke, me += c * We, we += c * ze, De += c * Be, Se += c * Pe, Ee += c * Ye, vt += c * Je, c = P[10], fe += c * Le, ue += c * Ne, ce += c * Me, ae += c * je, oe += c * qe, re += c * Ae, he += c * Ve, ge += c * He, ie += c * Ge, me += c * ke, we += c * We, De += c * ze, Se += c * Be, Ee += c * Pe, vt += c * Ye, It += c * Je, c = P[11], ue += c * Le, ce += c * Ne, ae += c * Me, oe += c * je, re += c * qe, he += c * Ae, ge += c * Ve, ie += c * He, me += c * Ge, we += c * ke, De += c * We, Se += c * ze, Ee += c * Be, vt += c * Pe, It += c * Ye, qt += c * Je, c = P[12], ce += c * Le, ae += c * Ne, oe += c * Me, re += c * je, he += c * qe, ge += c * Ae, ie += c * Ve, me += c * He, we += c * Ge, De += c * ke, Se += c * We, Ee += c * ze, vt += c * Be, It += c * Pe, qt += c * Ye, gt += c * Je, c = P[13], ae += c * Le, oe += c * Ne, re += c * Me, he += c * je, ge += c * qe, ie += c * Ae, me += c * Ve, we += c * He, De += c * Ge, Se += c * ke, Ee += c * We, vt += c * ze, It += c * Be, qt += c * Pe, gt += c * Ye, Wt += c * Je, c = P[14], oe += c * Le, re += c * Ne, he += c * Me, ge += c * je, ie += c * qe, me += c * Ae, we += c * Ve, De += c * He, Se += c * Ge, Ee += c * ke, vt += c * We, It += c * ze, qt += c * Be, gt += c * Pe, Wt += c * Ye, Dr += c * Je, c = P[15], re += c * Le, he += c * Ne, ge += c * Me, ie += c * je, me += c * qe, we += c * Ae, De += c * Ve, Se += c * He, Ee += c * Ge, vt += c * ke, It += c * We, qt += c * ze, gt += c * Be, Wt += c * Pe, Dr += c * Ye, Yr += c * Je, V += 38 * he, W += 38 * ge, le += 38 * ie, _e += 38 * me, de += 38 * we, ve += 38 * De, Ue += 38 * Se, Re += 38 * Ee, ye += 38 * vt, pe += 38 * It, fe += 38 * qt, ue += 38 * gt, ce += 38 * Wt, ae += 38 * Dr, oe += 38 * Yr, v = 1, c = V + v + 65535, v = Math.floor(c / 65536), V = c - v * 65536, c = W + v + 65535, v = Math.floor(c / 65536), W = c - v * 65536, c = le + v + 65535, v = Math.floor(c / 65536), le = c - v * 65536, c = _e + v + 65535, v = Math.floor(c / 65536), _e = c - v * 65536, c = de + v + 65535, v = Math.floor(c / 65536), de = c - v * 65536, c = ve + v + 65535, v = Math.floor(c / 65536), ve = c - v * 65536, c = Ue + v + 65535, v = Math.floor(c / 65536), Ue = c - v * 65536, c = Re + v + 65535, v = Math.floor(c / 65536), Re = c - v * 65536, c = ye + v + 65535, v = Math.floor(c / 65536), ye = c - v * 65536, c = pe + v + 65535, v = Math.floor(c / 65536), pe = c - v * 65536, c = fe + v + 65535, v = Math.floor(c / 65536), fe = c - v * 65536, c = ue + v + 65535, v = Math.floor(c / 65536), ue = c - v * 65536, c = ce + v + 65535, v = Math.floor(c / 65536), ce = c - v * 65536, c = ae + v + 65535, v = Math.floor(c / 65536), ae = c - v * 65536, c = oe + v + 65535, v = Math.floor(c / 65536), oe = c - v * 65536, c = re + v + 65535, v = Math.floor(c / 65536), re = c - v * 65536, V += v - 1 + 37 * (v - 1), v = 1, c = V + v + 65535, v = Math.floor(c / 65536), V = c - v * 65536, c = W + v + 65535, v = Math.floor(c / 65536), W = c - v * 65536, c = le + v + 65535, v = Math.floor(c / 65536), le = c - v * 65536, c = _e + v + 65535, v = Math.floor(c / 65536), _e = c - v * 65536, c = de + v + 65535, v = Math.floor(c / 65536), de = c - v * 65536, c = ve + v + 65535, v = Math.floor(c / 65536), ve = c - v * 65536, c = Ue + v + 65535, v = Math.floor(c / 65536), Ue = c - v * 65536, c = Re + v + 65535, v = Math.floor(c / 65536), Re = c - v * 65536, c = ye + v + 65535, v = Math.floor(c / 65536), ye = c - v * 65536, c = pe + v + 65535, v = Math.floor(c / 65536), pe = c - v * 65536, c = fe + v + 65535, v = Math.floor(c / 65536), fe = c - v * 65536, c = ue + v + 65535, v = Math.floor(c / 65536), ue = c - v * 65536, c = ce + v + 65535, v = Math.floor(c / 65536), ce = c - v * 65536, c = ae + v + 65535, v = Math.floor(c / 65536), ae = c - v * 65536, c = oe + v + 65535, v = Math.floor(c / 65536), oe = c - v * 65536, c = re + v + 65535, v = Math.floor(c / 65536), re = c - v * 65536, V += v - 1 + 37 * (v - 1), R[0] = V, R[1] = W, R[2] = le, R[3] = _e, R[4] = de, R[5] = ve, R[6] = Ue, R[7] = Re, R[8] = ye, R[9] = pe, R[10] = fe, R[11] = ue, R[12] = ce, R[13] = ae, R[14] = oe, R[15] = re;
  }
  function d(R, P) {
    o(R, P, P);
  }
  function C(R, P) {
    const S = n();
    let c;
    for (c = 0; c < 16; c++)
      S[c] = P[c];
    for (c = 253; c >= 0; c--)
      d(S, S), c !== 2 && c !== 4 && o(S, S, P);
    for (c = 0; c < 16; c++)
      R[c] = S[c];
  }
  function F(R, P) {
    const S = n();
    let c;
    for (c = 0; c < 16; c++)
      S[c] = P[c];
    for (c = 250; c >= 0; c--)
      d(S, S), c !== 1 && o(S, S, P);
    for (c = 0; c < 16; c++)
      R[c] = S[c];
  }
  function K(R, P) {
    const S = n(), c = n(), v = n(), V = n(), W = n(), le = n(), _e = n(), de = n(), ve = n();
    p(S, R[1], R[0]), p(ve, P[1], P[0]), o(S, S, ve), E(c, R[0], R[1]), E(ve, P[0], P[1]), o(c, c, ve), o(v, R[3], P[3]), o(v, v, h), o(V, R[2], P[2]), E(V, V, V), p(W, c, S), p(le, V, v), E(_e, V, v), E(de, c, S), o(R[0], W, le), o(R[1], de, _e), o(R[2], _e, le), o(R[3], W, de);
  }
  function G(R, P, S) {
    for (let c = 0; c < 4; c++)
      T(R[c], P[c], S);
  }
  function X(R, P) {
    const S = n(), c = n(), v = n();
    C(v, P[2]), o(S, P[0], v), o(c, P[1], v), A(R, c), R[31] ^= O(S) << 7;
  }
  function x(R, P, S) {
    _(R[0], u), _(R[1], a), _(R[2], a), _(R[3], u);
    for (let c = 255; c >= 0; --c) {
      const v = S[c / 8 | 0] >> (c & 7) & 1;
      G(R, P, v), K(P, R), K(R, R), G(R, P, v);
    }
  }
  function N(R, P) {
    const S = [n(), n(), n(), n()];
    _(S[0], f), _(S[1], y), _(S[2], a), o(S[3], f, y), x(R, S, P);
  }
  function k(R) {
    if (R.length !== t.SEED_LENGTH)
      throw new Error(`ed25519: seed must be ${t.SEED_LENGTH} bytes`);
    const P = (0, r.hash)(R);
    P[0] &= 248, P[31] &= 127, P[31] |= 64;
    const S = new Uint8Array(32), c = [n(), n(), n(), n()];
    N(c, P), X(S, c);
    const v = new Uint8Array(64);
    return v.set(R), v.set(S, 32), {
      publicKey: S,
      secretKey: v
    };
  }
  t.generateKeyPairFromSeed = k;
  function q(R) {
    const P = (0, e.randomBytes)(32, R), S = k(P);
    return (0, i.wipe)(P), S;
  }
  t.generateKeyPair = q;
  function U(R) {
    if (R.length !== t.SECRET_KEY_LENGTH)
      throw new Error(`ed25519: secret key must be ${t.SECRET_KEY_LENGTH} bytes`);
    return new Uint8Array(R.subarray(32));
  }
  t.extractPublicKeyFromSecretKey = U;
  const M = new Float64Array([
    237,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16
  ]);
  function $(R, P) {
    let S, c, v, V;
    for (c = 63; c >= 32; --c) {
      for (S = 0, v = c - 32, V = c - 12; v < V; ++v)
        P[v] += S - 16 * P[c] * M[v - (c - 32)], S = Math.floor((P[v] + 128) / 256), P[v] -= S * 256;
      P[v] += S, P[c] = 0;
    }
    for (S = 0, v = 0; v < 32; v++)
      P[v] += S - (P[31] >> 4) * M[v], S = P[v] >> 8, P[v] &= 255;
    for (v = 0; v < 32; v++)
      P[v] -= S * M[v];
    for (c = 0; c < 32; c++)
      P[c + 1] += P[c] >> 8, R[c] = P[c] & 255;
  }
  function B(R) {
    const P = new Float64Array(64);
    for (let S = 0; S < 64; S++)
      P[S] = R[S];
    for (let S = 0; S < 64; S++)
      R[S] = 0;
    $(R, P);
  }
  function te(R, P) {
    const S = new Float64Array(64), c = [n(), n(), n(), n()], v = (0, r.hash)(R.subarray(0, 32));
    v[0] &= 248, v[31] &= 127, v[31] |= 64;
    const V = new Uint8Array(64);
    V.set(v.subarray(32), 32);
    const W = new r.SHA512();
    W.update(V.subarray(32)), W.update(P);
    const le = W.digest();
    W.clean(), B(le), N(c, le), X(V, c), W.reset(), W.update(V.subarray(0, 32)), W.update(R.subarray(32)), W.update(P);
    const _e = W.digest();
    B(_e);
    for (let de = 0; de < 32; de++)
      S[de] = le[de];
    for (let de = 0; de < 32; de++)
      for (let ve = 0; ve < 32; ve++)
        S[de + ve] += _e[de] * v[ve];
    return $(V.subarray(32), S), V;
  }
  t.sign = te;
  function z(R, P) {
    const S = n(), c = n(), v = n(), V = n(), W = n(), le = n(), _e = n();
    return _(R[2], a), m(R[1], P), d(v, R[1]), o(V, v, l), p(v, v, R[2]), E(V, R[2], V), d(W, V), d(le, W), o(_e, le, W), o(S, _e, v), o(S, S, V), F(S, S), o(S, S, v), o(S, S, V), o(S, S, V), o(R[0], S, V), d(c, R[0]), o(c, c, V), D(c, v) && o(R[0], R[0], g), d(c, R[0]), o(c, c, V), D(c, v) ? -1 : (O(R[0]) === P[31] >> 7 && p(R[0], u, R[0]), o(R[3], R[0], R[1]), 0);
  }
  function Z(R, P, S) {
    const c = new Uint8Array(32), v = [n(), n(), n(), n()], V = [n(), n(), n(), n()];
    if (S.length !== t.SIGNATURE_LENGTH)
      throw new Error(`ed25519: signature must be ${t.SIGNATURE_LENGTH} bytes`);
    if (z(V, R))
      return !1;
    const W = new r.SHA512();
    W.update(S.subarray(0, 32)), W.update(R), W.update(P);
    const le = W.digest();
    return B(le), x(v, V, le), N(V, S.subarray(32)), K(v, V), X(c, v), !j(S, c);
  }
  t.verify = Z;
  function Y(R) {
    let P = [n(), n(), n(), n()];
    if (z(P, R))
      throw new Error("Ed25519: invalid public key");
    let S = n(), c = n(), v = P[1];
    E(S, a, v), p(c, a, v), C(c, c), o(S, S, c);
    let V = new Uint8Array(32);
    return A(V, S), V;
  }
  t.convertPublicKeyToX25519 = Y;
  function ee(R) {
    const P = (0, r.hash)(R.subarray(0, 32));
    P[0] &= 248, P[31] &= 127, P[31] |= 64;
    const S = new Uint8Array(P.subarray(0, 32));
    return (0, i.wipe)(P), S;
  }
  t.convertSecretKeyToX25519 = ee;
})(Cn);
const yf = "EdDSA", bf = "JWT", Yo = ".", Jo = "base64url", _f = "utf8", mf = "utf8", wf = ":", vf = "did", Ef = "key", Ts = "base58btc", Df = "z", Sf = "K36", xf = 32;
function Fn(t) {
  return globalThis.Buffer != null ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t;
}
function Xo(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Fn(globalThis.Buffer.allocUnsafe(t)) : new Uint8Array(t);
}
function sn(t, e) {
  e || (e = t.reduce((n, s) => n + s.length, 0));
  const r = Xo(e);
  let i = 0;
  for (const n of t)
    r.set(n, i), i += n.length;
  return Fn(r);
}
function Qo(t, e, r, i) {
  return {
    name: t,
    prefix: e,
    encoder: {
      name: t,
      prefix: e,
      encode: r
    },
    decoder: { decode: i }
  };
}
const Rs = Qo("utf8", "u", (t) => "u" + new TextDecoder("utf8").decode(t), (t) => new TextEncoder().encode(t.substring(1))), $i = Qo("ascii", "a", (t) => {
  let e = "a";
  for (let r = 0; r < t.length; r++)
    e += String.fromCharCode(t[r]);
  return e;
}, (t) => {
  t = t.substring(1);
  const e = Xo(t.length);
  for (let r = 0; r < t.length; r++)
    e[r] = t.charCodeAt(r);
  return e;
}), Zo = {
  utf8: Rs,
  "utf-8": Rs,
  hex: Ps.base16,
  latin1: $i,
  ascii: $i,
  binary: $i,
  ...Ps
};
function ht(t, e = "utf8") {
  const r = Zo[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString("utf8") : r.encoder.encode(t).substring(1);
}
function dt(t, e = "utf8") {
  const r = Zo[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Fn(globalThis.Buffer.from(t, "utf-8")) : r.decoder.decode(`${r.prefix}${t}`);
}
const If = (t) => JSON.stringify(t, (e, r) => typeof r == "bigint" ? r.toString() + "n" : r), Of = (t) => {
  const e = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g, r = t.replace(e, '$1"$2n"$3');
  return JSON.parse(r, (i, n) => typeof n == "string" && n.match(/^\d+n$/) ? BigInt(n.substring(0, n.length - 1)) : n);
};
function Ei(t) {
  if (typeof t != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof t}`);
  try {
    return Of(t);
  } catch {
    return t;
  }
}
function Gr(t) {
  return typeof t == "string" ? t : If(t) || "";
}
function hi(t) {
  return ht(dt(Gr(t), _f), Jo);
}
function ea(t) {
  const e = dt(Sf, Ts), r = Df + ht(sn([e, t]), Ts);
  return [vf, Ef, r].join(wf);
}
function Pf(t) {
  return ht(t, Jo);
}
function Tf(t) {
  return dt([hi(t.header), hi(t.payload)].join(Yo), mf);
}
function Rf(t) {
  return [
    hi(t.header),
    hi(t.payload),
    Pf(t.signature)
  ].join(Yo);
}
function Ns(t = _r.randomBytes(xf)) {
  return Cn.generateKeyPairFromSeed(t);
}
async function Nf(t, e, r, i, n = Q.fromMiliseconds(Date.now())) {
  const s = { alg: yf, typ: bf }, u = ea(i.publicKey), a = n + r, l = { iss: u, sub: t, aud: e, iat: n, exp: a }, h = Tf({ header: s, payload: l }), f = Cn.sign(i.secretKey, h);
  return Rf({ header: s, payload: l, signature: f });
}
const Af = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, Cf = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, Ff = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function $f(t, e) {
  if (t === "__proto__" || t === "constructor" && e && typeof e == "object" && "prototype" in e) {
    return;
  }
  return e;
}
function ri(t, e = {}) {
  if (typeof t != "string")
    return t;
  const r = t.trim();
  if (
    // eslint-disable-next-line unicorn/prefer-at
    t[0] === '"' && t.at(-1) === '"' && !t.includes("\\")
  )
    return r.slice(1, -1);
  if (r.length <= 9) {
    const i = r.toLowerCase();
    if (i === "true")
      return !0;
    if (i === "false")
      return !1;
    if (i === "undefined")
      return;
    if (i === "null")
      return null;
    if (i === "nan")
      return Number.NaN;
    if (i === "infinity")
      return Number.POSITIVE_INFINITY;
    if (i === "-infinity")
      return Number.NEGATIVE_INFINITY;
  }
  if (!Ff.test(t)) {
    if (e.strict)
      throw new SyntaxError("[destr] Invalid JSON");
    return t;
  }
  try {
    if (Af.test(t) || Cf.test(t)) {
      if (e.strict)
        throw new Error("[destr] Possible prototype pollution");
      return JSON.parse(t, $f);
    }
    return JSON.parse(t);
  } catch (i) {
    if (e.strict)
      throw i;
    return t;
  }
}
function Uf(t) {
  return !t || typeof t.then != "function" ? Promise.resolve(t) : t;
}
function Qe(t, ...e) {
  try {
    return Uf(t(...e));
  } catch (r) {
    return Promise.reject(r);
  }
}
function Lf(t) {
  const e = typeof t;
  return t === null || e !== "object" && e !== "function";
}
function Mf(t) {
  const e = Object.getPrototypeOf(t);
  return !e || e.isPrototypeOf(Object);
}
function si(t) {
  if (Lf(t))
    return String(t);
  if (Mf(t) || Array.isArray(t))
    return JSON.stringify(t);
  if (typeof t.toJSON == "function")
    return si(t.toJSON());
  throw new Error("[unstorage] Cannot stringify value!");
}
function ta() {
  if (typeof In === void 0)
    throw new TypeError("[unstorage] Buffer is not supported!");
}
const on = "base64:";
function jf(t) {
  if (typeof t == "string")
    return t;
  ta();
  const e = In.from(t).toString("base64");
  return on + e;
}
function qf(t) {
  return typeof t != "string" || !t.startsWith(on) ? t : (ta(), In.from(t.slice(on.length), "base64"));
}
function lt(t) {
  return t ? t.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") : "";
}
function Bf(...t) {
  return lt(t.join(":"));
}
function ii(t) {
  return t = lt(t), t ? t + ":" : "";
}
const zf = "memory", Kf = () => {
  const t = /* @__PURE__ */ new Map();
  return {
    name: zf,
    options: {},
    hasItem(e) {
      return t.has(e);
    },
    getItem(e) {
      return t.get(e) ?? null;
    },
    getItemRaw(e) {
      return t.get(e) ?? null;
    },
    setItem(e, r) {
      t.set(e, r);
    },
    setItemRaw(e, r) {
      t.set(e, r);
    },
    removeItem(e) {
      t.delete(e);
    },
    getKeys() {
      return Array.from(t.keys());
    },
    clear() {
      t.clear();
    },
    dispose() {
      t.clear();
    }
  };
};
function Vf(t = {}) {
  const e = {
    mounts: { "": t.driver || Kf() },
    mountpoints: [""],
    watching: !1,
    watchListeners: [],
    unwatch: {}
  }, r = (h) => {
    for (const f of e.mountpoints)
      if (h.startsWith(f))
        return {
          base: f,
          relativeKey: h.slice(f.length),
          driver: e.mounts[f]
        };
    return {
      base: "",
      relativeKey: h,
      driver: e.mounts[""]
    };
  }, i = (h, f) => e.mountpoints.filter(
    (y) => y.startsWith(h) || f && h.startsWith(y)
  ).map((y) => ({
    relativeBase: h.length > y.length ? h.slice(y.length) : void 0,
    mountpoint: y,
    driver: e.mounts[y]
  })), n = (h, f) => {
    if (e.watching) {
      f = lt(f);
      for (const y of e.watchListeners)
        y(h, f);
    }
  }, s = async () => {
    if (!e.watching) {
      e.watching = !0;
      for (const h in e.mounts)
        e.unwatch[h] = await As(
          e.mounts[h],
          n,
          h
        );
    }
  }, u = async () => {
    if (e.watching) {
      for (const h in e.unwatch)
        await e.unwatch[h]();
      e.unwatch = {}, e.watching = !1;
    }
  }, a = (h, f, y) => {
    const g = /* @__PURE__ */ new Map(), _ = (w) => {
      let T = g.get(w.base);
      return T || (T = {
        driver: w.driver,
        base: w.base,
        items: []
      }, g.set(w.base, T)), T;
    };
    for (const w of h) {
      const T = typeof w == "string", A = lt(T ? w : w.key), j = T ? void 0 : w.value, D = T || !w.options ? f : { ...f, ...w.options }, O = r(A);
      _(O).items.push({
        key: A,
        value: j,
        relativeKey: O.relativeKey,
        options: D
      });
    }
    return Promise.all([...g.values()].map((w) => y(w))).then(
      (w) => w.flat()
    );
  }, l = {
    // Item
    hasItem(h, f = {}) {
      h = lt(h);
      const { relativeKey: y, driver: g } = r(h);
      return Qe(g.hasItem, y, f);
    },
    getItem(h, f = {}) {
      h = lt(h);
      const { relativeKey: y, driver: g } = r(h);
      return Qe(g.getItem, y, f).then(
        (_) => ri(_)
      );
    },
    getItems(h, f) {
      return a(h, f, (y) => y.driver.getItems ? Qe(
        y.driver.getItems,
        y.items.map((g) => ({
          key: g.relativeKey,
          options: g.options
        })),
        f
      ).then(
        (g) => g.map((_) => ({
          key: Bf(y.base, _.key),
          value: ri(_.value)
        }))
      ) : Promise.all(
        y.items.map((g) => Qe(
          y.driver.getItem,
          g.relativeKey,
          g.options
        ).then((_) => ({
          key: g.key,
          value: ri(_)
        })))
      ));
    },
    getItemRaw(h, f = {}) {
      h = lt(h);
      const { relativeKey: y, driver: g } = r(h);
      return g.getItemRaw ? Qe(g.getItemRaw, y, f) : Qe(g.getItem, y, f).then(
        (_) => qf(_)
      );
    },
    async setItem(h, f, y = {}) {
      if (f === void 0)
        return l.removeItem(h);
      h = lt(h);
      const { relativeKey: g, driver: _ } = r(h);
      _.setItem && (await Qe(_.setItem, g, si(f), y), _.watch || n("update", h));
    },
    async setItems(h, f) {
      await a(h, f, async (y) => {
        y.driver.setItems && await Qe(
          y.driver.setItems,
          y.items.map((g) => ({
            key: g.relativeKey,
            value: si(g.value),
            options: g.options
          })),
          f
        ), y.driver.setItem && await Promise.all(
          y.items.map((g) => Qe(
            y.driver.setItem,
            g.relativeKey,
            si(g.value),
            g.options
          ))
        );
      });
    },
    async setItemRaw(h, f, y = {}) {
      if (f === void 0)
        return l.removeItem(h, y);
      h = lt(h);
      const { relativeKey: g, driver: _ } = r(h);
      if (_.setItemRaw)
        await Qe(_.setItemRaw, g, f, y);
      else if (_.setItem)
        await Qe(_.setItem, g, jf(f), y);
      else
        return;
      _.watch || n("update", h);
    },
    async removeItem(h, f = {}) {
      typeof f == "boolean" && (f = { removeMeta: f }), h = lt(h);
      const { relativeKey: y, driver: g } = r(h);
      g.removeItem && (await Qe(g.removeItem, y, f), (f.removeMeta || f.removeMata) && await Qe(g.removeItem, y + "$", f), g.watch || n("remove", h));
    },
    // Meta
    async getMeta(h, f = {}) {
      typeof f == "boolean" && (f = { nativeOnly: f }), h = lt(h);
      const { relativeKey: y, driver: g } = r(h), _ = /* @__PURE__ */ Object.create(null);
      if (g.getMeta && Object.assign(_, await Qe(g.getMeta, y, f)), !f.nativeOnly) {
        const w = await Qe(
          g.getItem,
          y + "$",
          f
        ).then((T) => ri(T));
        w && typeof w == "object" && (typeof w.atime == "string" && (w.atime = new Date(w.atime)), typeof w.mtime == "string" && (w.mtime = new Date(w.mtime)), Object.assign(_, w));
      }
      return _;
    },
    setMeta(h, f, y = {}) {
      return this.setItem(h + "$", f, y);
    },
    removeMeta(h, f = {}) {
      return this.removeItem(h + "$", f);
    },
    // Keys
    async getKeys(h, f = {}) {
      h = ii(h);
      const y = i(h, !0);
      let g = [];
      const _ = [];
      for (const w of y) {
        const A = (await Qe(
          w.driver.getKeys,
          w.relativeBase,
          f
        )).map((j) => w.mountpoint + lt(j)).filter((j) => !g.some((D) => j.startsWith(D)));
        _.push(...A), g = [
          w.mountpoint,
          ...g.filter((j) => !j.startsWith(w.mountpoint))
        ];
      }
      return h ? _.filter((w) => w.startsWith(h) && !w.endsWith("$")) : _.filter((w) => !w.endsWith("$"));
    },
    // Utils
    async clear(h, f = {}) {
      h = ii(h), await Promise.all(
        i(h, !1).map(async (y) => {
          if (y.driver.clear)
            return Qe(y.driver.clear, y.relativeBase, f);
          if (y.driver.removeItem) {
            const g = await y.driver.getKeys(y.relativeBase || "", f);
            return Promise.all(
              g.map((_) => y.driver.removeItem(_, f))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(e.mounts).map((h) => Cs(h))
      );
    },
    async watch(h) {
      return await s(), e.watchListeners.push(h), async () => {
        e.watchListeners = e.watchListeners.filter(
          (f) => f !== h
        ), e.watchListeners.length === 0 && await u();
      };
    },
    async unwatch() {
      e.watchListeners = [], await u();
    },
    // Mount
    mount(h, f) {
      if (h = ii(h), h && e.mounts[h])
        throw new Error(`already mounted at ${h}`);
      return h && (e.mountpoints.push(h), e.mountpoints.sort((y, g) => g.length - y.length)), e.mounts[h] = f, e.watching && Promise.resolve(As(f, n, h)).then((y) => {
        e.unwatch[h] = y;
      }).catch(console.error), l;
    },
    async unmount(h, f = !0) {
      h = ii(h), !(!h || !e.mounts[h]) && (e.watching && h in e.unwatch && (e.unwatch[h](), delete e.unwatch[h]), f && await Cs(e.mounts[h]), e.mountpoints = e.mountpoints.filter((y) => y !== h), delete e.mounts[h]);
    },
    getMount(h = "") {
      h = lt(h) + ":";
      const f = r(h);
      return {
        driver: f.driver,
        base: f.base
      };
    },
    getMounts(h = "", f = {}) {
      return h = lt(h), i(h, f.parents).map((g) => ({
        driver: g.driver,
        base: g.mountpoint
      }));
    }
  };
  return l;
}
function As(t, e, r) {
  return t.watch ? t.watch((i, n) => e(i, r + n)) : () => {
  };
}
async function Cs(t) {
  typeof t.dispose == "function" && await Qe(t.dispose);
}
function or(t) {
  return new Promise((e, r) => {
    t.oncomplete = t.onsuccess = () => e(t.result), t.onabort = t.onerror = () => r(t.error);
  });
}
function ra(t, e) {
  const r = indexedDB.open(t);
  r.onupgradeneeded = () => r.result.createObjectStore(e);
  const i = or(r);
  return (n, s) => i.then((u) => s(u.transaction(e, n).objectStore(e)));
}
let Ui;
function kr() {
  return Ui || (Ui = ra("keyval-store", "keyval")), Ui;
}
function Fs(t, e = kr()) {
  return e("readonly", (r) => or(r.get(t)));
}
function Hf(t, e, r = kr()) {
  return r("readwrite", (i) => (i.put(e, t), or(i.transaction)));
}
function Gf(t, e = kr()) {
  return e("readwrite", (r) => (r.delete(t), or(r.transaction)));
}
function kf(t = kr()) {
  return t("readwrite", (e) => (e.clear(), or(e.transaction)));
}
function Wf(t, e) {
  return t.openCursor().onsuccess = function() {
    this.result && (e(this.result), this.result.continue());
  }, or(t.transaction);
}
function Yf(t = kr()) {
  return t("readonly", (e) => {
    if (e.getAllKeys)
      return or(e.getAllKeys());
    const r = [];
    return Wf(e, (i) => r.push(i.key)).then(() => r);
  });
}
const Jf = "idb-keyval";
var Xf = (t = {}) => {
  const e = t.base && t.base.length > 0 ? `${t.base}:` : "", r = (n) => e + n;
  let i;
  return t.dbName && t.storeName && (i = ra(t.dbName, t.storeName)), { name: Jf, options: t, async hasItem(n) {
    return !(typeof await Fs(r(n), i) > "u");
  }, async getItem(n) {
    return await Fs(r(n), i) ?? null;
  }, setItem(n, s) {
    return Hf(r(n), s, i);
  }, removeItem(n) {
    return Gf(r(n), i);
  }, getKeys() {
    return Yf(i);
  }, clear() {
    return kf(i);
  } };
};
const Qf = "WALLET_CONNECT_V2_INDEXED_DB", Zf = "keyvaluestorage";
let ed = class {
  constructor() {
    this.indexedDb = Vf({ driver: Xf({ dbName: Qf, storeName: Zf }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((e) => [e.key, e.value]);
  }
  async getItem(e) {
    const r = await this.indexedDb.getItem(e);
    if (r !== null) return r;
  }
  async setItem(e, r) {
    await this.indexedDb.setItem(e, Gr(r));
  }
  async removeItem(e) {
    await this.indexedDb.removeItem(e);
  }
};
var Li = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof xe < "u" ? xe : typeof self < "u" ? self : {}, oi = { exports: {} };
(function() {
  let t;
  function e() {
  }
  t = e, t.prototype.getItem = function(r) {
    return this.hasOwnProperty(r) ? String(this[r]) : null;
  }, t.prototype.setItem = function(r, i) {
    this[r] = String(i);
  }, t.prototype.removeItem = function(r) {
    delete this[r];
  }, t.prototype.clear = function() {
    const r = this;
    Object.keys(r).forEach(function(i) {
      r[i] = void 0, delete r[i];
    });
  }, t.prototype.key = function(r) {
    return r = r || 0, Object.keys(this)[r];
  }, t.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof Li < "u" && Li.localStorage ? oi.exports = Li.localStorage : typeof window < "u" && window.localStorage ? oi.exports = window.localStorage : oi.exports = new e();
})();
function td(t) {
  var e;
  return [t[0], Ei((e = t[1]) != null ? e : "")];
}
class rd {
  constructor() {
    this.localStorage = oi.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(td);
  }
  async getItem(e) {
    const r = this.localStorage.getItem(e);
    if (r !== null) return Ei(r);
  }
  async setItem(e, r) {
    this.localStorage.setItem(e, Gr(r));
  }
  async removeItem(e) {
    this.localStorage.removeItem(e);
  }
}
const id = "wc_storage_version", $s = 1, nd = async (t, e, r) => {
  const i = id, n = await e.getItem(i);
  if (n && n >= $s) {
    r(e);
    return;
  }
  const s = await t.getKeys();
  if (!s.length) {
    r(e);
    return;
  }
  const u = [];
  for (; s.length; ) {
    const a = s.shift();
    if (!a) continue;
    const l = a.toLowerCase();
    if (l.includes("wc@") || l.includes("walletconnect") || l.includes("wc_") || l.includes("wallet_connect")) {
      const h = await t.getItem(a);
      await e.setItem(a, h), u.push(a);
    }
  }
  await e.setItem(i, $s), r(e), sd(t, u);
}, sd = async (t, e) => {
  e.length && e.forEach(async (r) => {
    await t.removeItem(r);
  });
};
let od = class {
  constructor() {
    this.initialized = !1, this.setInitialized = (r) => {
      this.storage = r, this.initialized = !0;
    };
    const e = new rd();
    this.storage = e;
    try {
      const r = new ed();
      nd(e, r, this.setInitialized);
    } catch {
      this.initialized = !0;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(e) {
    return await this.initialize(), this.storage.getItem(e);
  }
  async setItem(e, r) {
    return await this.initialize(), this.storage.setItem(e, r);
  }
  async removeItem(e) {
    return await this.initialize(), this.storage.removeItem(e);
  }
  async initialize() {
    this.initialized || await new Promise((e) => {
      const r = setInterval(() => {
        this.initialized && (clearInterval(r), e());
      }, 20);
    });
  }
};
var mr = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var an = function(t, e) {
  return an = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, i) {
    r.__proto__ = i;
  } || function(r, i) {
    for (var n in i) i.hasOwnProperty(n) && (r[n] = i[n]);
  }, an(t, e);
};
function ad(t, e) {
  an(t, e);
  function r() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype, new r());
}
var cn = function() {
  return cn = Object.assign || function(e) {
    for (var r, i = 1, n = arguments.length; i < n; i++) {
      r = arguments[i];
      for (var s in r) Object.prototype.hasOwnProperty.call(r, s) && (e[s] = r[s]);
    }
    return e;
  }, cn.apply(this, arguments);
};
function cd(t, e) {
  var r = {};
  for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && e.indexOf(i) < 0 && (r[i] = t[i]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var n = 0, i = Object.getOwnPropertySymbols(t); n < i.length; n++)
      e.indexOf(i[n]) < 0 && Object.prototype.propertyIsEnumerable.call(t, i[n]) && (r[i[n]] = t[i[n]]);
  return r;
}
function ud(t, e, r, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, r) : i, u;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, r, i);
  else for (var a = t.length - 1; a >= 0; a--) (u = t[a]) && (s = (n < 3 ? u(s) : n > 3 ? u(e, r, s) : u(e, r)) || s);
  return n > 3 && s && Object.defineProperty(e, r, s), s;
}
function hd(t, e) {
  return function(r, i) {
    e(r, i, t);
  };
}
function ld(t, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(t, e);
}
function fd(t, e, r, i) {
  function n(s) {
    return s instanceof r ? s : new r(function(u) {
      u(s);
    });
  }
  return new (r || (r = Promise))(function(s, u) {
    function a(f) {
      try {
        h(i.next(f));
      } catch (y) {
        u(y);
      }
    }
    function l(f) {
      try {
        h(i.throw(f));
      } catch (y) {
        u(y);
      }
    }
    function h(f) {
      f.done ? s(f.value) : n(f.value).then(a, l);
    }
    h((i = i.apply(t, e || [])).next());
  });
}
function dd(t, e) {
  var r = { label: 0, sent: function() {
    if (s[0] & 1) throw s[1];
    return s[1];
  }, trys: [], ops: [] }, i, n, s, u;
  return u = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (u[Symbol.iterator] = function() {
    return this;
  }), u;
  function a(h) {
    return function(f) {
      return l([h, f]);
    };
  }
  function l(h) {
    if (i) throw new TypeError("Generator is already executing.");
    for (; r; ) try {
      if (i = 1, n && (s = h[0] & 2 ? n.return : h[0] ? n.throw || ((s = n.return) && s.call(n), 0) : n.next) && !(s = s.call(n, h[1])).done) return s;
      switch (n = 0, s && (h = [h[0] & 2, s.value]), h[0]) {
        case 0:
        case 1:
          s = h;
          break;
        case 4:
          return r.label++, { value: h[1], done: !1 };
        case 5:
          r.label++, n = h[1], h = [0];
          continue;
        case 7:
          h = r.ops.pop(), r.trys.pop();
          continue;
        default:
          if (s = r.trys, !(s = s.length > 0 && s[s.length - 1]) && (h[0] === 6 || h[0] === 2)) {
            r = 0;
            continue;
          }
          if (h[0] === 3 && (!s || h[1] > s[0] && h[1] < s[3])) {
            r.label = h[1];
            break;
          }
          if (h[0] === 6 && r.label < s[1]) {
            r.label = s[1], s = h;
            break;
          }
          if (s && r.label < s[2]) {
            r.label = s[2], r.ops.push(h);
            break;
          }
          s[2] && r.ops.pop(), r.trys.pop();
          continue;
      }
      h = e.call(t, r);
    } catch (f) {
      h = [6, f], n = 0;
    } finally {
      i = s = 0;
    }
    if (h[0] & 5) throw h[1];
    return { value: h[0] ? h[1] : void 0, done: !0 };
  }
}
function pd(t, e, r, i) {
  i === void 0 && (i = r), t[i] = e[r];
}
function gd(t, e) {
  for (var r in t) r !== "default" && !e.hasOwnProperty(r) && (e[r] = t[r]);
}
function un(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, r = e && t[e], i = 0;
  if (r) return r.call(t);
  if (t && typeof t.length == "number") return {
    next: function() {
      return t && i >= t.length && (t = void 0), { value: t && t[i++], done: !t };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function ia(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r) return t;
  var i = r.call(t), n, s = [], u;
  try {
    for (; (e === void 0 || e-- > 0) && !(n = i.next()).done; ) s.push(n.value);
  } catch (a) {
    u = { error: a };
  } finally {
    try {
      n && !n.done && (r = i.return) && r.call(i);
    } finally {
      if (u) throw u.error;
    }
  }
  return s;
}
function yd() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t = t.concat(ia(arguments[e]));
  return t;
}
function bd() {
  for (var t = 0, e = 0, r = arguments.length; e < r; e++) t += arguments[e].length;
  for (var i = Array(t), n = 0, e = 0; e < r; e++)
    for (var s = arguments[e], u = 0, a = s.length; u < a; u++, n++)
      i[n] = s[u];
  return i;
}
function Mr(t) {
  return this instanceof Mr ? (this.v = t, this) : new Mr(t);
}
function _d(t, e, r) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var i = r.apply(t, e || []), n, s = [];
  return n = {}, u("next"), u("throw"), u("return"), n[Symbol.asyncIterator] = function() {
    return this;
  }, n;
  function u(g) {
    i[g] && (n[g] = function(_) {
      return new Promise(function(w, T) {
        s.push([g, _, w, T]) > 1 || a(g, _);
      });
    });
  }
  function a(g, _) {
    try {
      l(i[g](_));
    } catch (w) {
      y(s[0][3], w);
    }
  }
  function l(g) {
    g.value instanceof Mr ? Promise.resolve(g.value.v).then(h, f) : y(s[0][2], g);
  }
  function h(g) {
    a("next", g);
  }
  function f(g) {
    a("throw", g);
  }
  function y(g, _) {
    g(_), s.shift(), s.length && a(s[0][0], s[0][1]);
  }
}
function md(t) {
  var e, r;
  return e = {}, i("next"), i("throw", function(n) {
    throw n;
  }), i("return"), e[Symbol.iterator] = function() {
    return this;
  }, e;
  function i(n, s) {
    e[n] = t[n] ? function(u) {
      return (r = !r) ? { value: Mr(t[n](u)), done: n === "return" } : s ? s(u) : u;
    } : s;
  }
}
function wd(t) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator], r;
  return e ? e.call(t) : (t = typeof un == "function" ? un(t) : t[Symbol.iterator](), r = {}, i("next"), i("throw"), i("return"), r[Symbol.asyncIterator] = function() {
    return this;
  }, r);
  function i(s) {
    r[s] = t[s] && function(u) {
      return new Promise(function(a, l) {
        u = t[s](u), n(a, l, u.done, u.value);
      });
    };
  }
  function n(s, u, a, l) {
    Promise.resolve(l).then(function(h) {
      s({ value: h, done: a });
    }, u);
  }
}
function vd(t, e) {
  return Object.defineProperty ? Object.defineProperty(t, "raw", { value: e }) : t.raw = e, t;
}
function Ed(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
  return e.default = t, e;
}
function Dd(t) {
  return t && t.__esModule ? t : { default: t };
}
function Sd(t, e) {
  if (!e.has(t))
    throw new TypeError("attempted to get private field on non-instance");
  return e.get(t);
}
function xd(t, e, r) {
  if (!e.has(t))
    throw new TypeError("attempted to set private field on non-instance");
  return e.set(t, r), r;
}
const Id = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return cn;
  },
  __asyncDelegator: md,
  __asyncGenerator: _d,
  __asyncValues: wd,
  __await: Mr,
  __awaiter: fd,
  __classPrivateFieldGet: Sd,
  __classPrivateFieldSet: xd,
  __createBinding: pd,
  __decorate: ud,
  __exportStar: gd,
  __extends: ad,
  __generator: dd,
  __importDefault: Dd,
  __importStar: Ed,
  __makeTemplateObject: vd,
  __metadata: ld,
  __param: hd,
  __read: ia,
  __rest: cd,
  __spread: yd,
  __spreadArrays: bd,
  __values: un
}, Symbol.toStringTag, { value: "Module" })), Di = /* @__PURE__ */ nr(Id);
var Pr = {}, Mi = {}, Tr = {};
let ar = class {
};
const Od = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  IEvents: ar
}, Symbol.toStringTag, { value: "Module" })), Pd = /* @__PURE__ */ nr(Od);
var Us;
function Td() {
  if (Us) return Tr;
  Us = 1, Object.defineProperty(Tr, "__esModule", { value: !0 }), Tr.IHeartBeat = void 0;
  const t = Pd;
  class e extends t.IEvents {
    constructor(i) {
      super();
    }
  }
  return Tr.IHeartBeat = e, Tr;
}
var Ls;
function na() {
  return Ls || (Ls = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), Di.__exportStar(Td(), t);
  }(Mi)), Mi;
}
var ji = {}, er = {}, Ms;
function Rd() {
  if (Ms) return er;
  Ms = 1, Object.defineProperty(er, "__esModule", { value: !0 }), er.HEARTBEAT_EVENTS = er.HEARTBEAT_INTERVAL = void 0;
  const t = Q;
  return er.HEARTBEAT_INTERVAL = t.FIVE_SECONDS, er.HEARTBEAT_EVENTS = {
    pulse: "heartbeat_pulse"
  }, er;
}
var js;
function sa() {
  return js || (js = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), Di.__exportStar(Rd(), t);
  }(ji)), ji;
}
var qs;
function Nd() {
  if (qs) return Pr;
  qs = 1, Object.defineProperty(Pr, "__esModule", { value: !0 }), Pr.HeartBeat = void 0;
  const t = Di, e = Rt, r = Q, i = na(), n = sa();
  class s extends i.IHeartBeat {
    constructor(a) {
      super(a), this.events = new e.EventEmitter(), this.interval = n.HEARTBEAT_INTERVAL, this.interval = (a == null ? void 0 : a.interval) || n.HEARTBEAT_INTERVAL;
    }
    static init(a) {
      return t.__awaiter(this, void 0, void 0, function* () {
        const l = new s(a);
        return yield l.init(), l;
      });
    }
    init() {
      return t.__awaiter(this, void 0, void 0, function* () {
        yield this.initialize();
      });
    }
    stop() {
      clearInterval(this.intervalRef);
    }
    on(a, l) {
      this.events.on(a, l);
    }
    once(a, l) {
      this.events.once(a, l);
    }
    off(a, l) {
      this.events.off(a, l);
    }
    removeListener(a, l) {
      this.events.removeListener(a, l);
    }
    initialize() {
      return t.__awaiter(this, void 0, void 0, function* () {
        this.intervalRef = setInterval(() => this.pulse(), r.toMiliseconds(this.interval));
      });
    }
    pulse() {
      this.events.emit(n.HEARTBEAT_EVENTS.pulse);
    }
  }
  return Pr.HeartBeat = s, Pr;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const e = Di;
  e.__exportStar(Nd(), t), e.__exportStar(na(), t), e.__exportStar(sa(), t);
})(mr);
var be = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var hn = function(t, e) {
  return hn = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, i) {
    r.__proto__ = i;
  } || function(r, i) {
    for (var n in i) i.hasOwnProperty(n) && (r[n] = i[n]);
  }, hn(t, e);
};
function Ad(t, e) {
  hn(t, e);
  function r() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype, new r());
}
var ln = function() {
  return ln = Object.assign || function(e) {
    for (var r, i = 1, n = arguments.length; i < n; i++) {
      r = arguments[i];
      for (var s in r) Object.prototype.hasOwnProperty.call(r, s) && (e[s] = r[s]);
    }
    return e;
  }, ln.apply(this, arguments);
};
function Cd(t, e) {
  var r = {};
  for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && e.indexOf(i) < 0 && (r[i] = t[i]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var n = 0, i = Object.getOwnPropertySymbols(t); n < i.length; n++)
      e.indexOf(i[n]) < 0 && Object.prototype.propertyIsEnumerable.call(t, i[n]) && (r[i[n]] = t[i[n]]);
  return r;
}
function Fd(t, e, r, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, r) : i, u;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, r, i);
  else for (var a = t.length - 1; a >= 0; a--) (u = t[a]) && (s = (n < 3 ? u(s) : n > 3 ? u(e, r, s) : u(e, r)) || s);
  return n > 3 && s && Object.defineProperty(e, r, s), s;
}
function $d(t, e) {
  return function(r, i) {
    e(r, i, t);
  };
}
function Ud(t, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(t, e);
}
function Ld(t, e, r, i) {
  function n(s) {
    return s instanceof r ? s : new r(function(u) {
      u(s);
    });
  }
  return new (r || (r = Promise))(function(s, u) {
    function a(f) {
      try {
        h(i.next(f));
      } catch (y) {
        u(y);
      }
    }
    function l(f) {
      try {
        h(i.throw(f));
      } catch (y) {
        u(y);
      }
    }
    function h(f) {
      f.done ? s(f.value) : n(f.value).then(a, l);
    }
    h((i = i.apply(t, e || [])).next());
  });
}
function Md(t, e) {
  var r = { label: 0, sent: function() {
    if (s[0] & 1) throw s[1];
    return s[1];
  }, trys: [], ops: [] }, i, n, s, u;
  return u = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (u[Symbol.iterator] = function() {
    return this;
  }), u;
  function a(h) {
    return function(f) {
      return l([h, f]);
    };
  }
  function l(h) {
    if (i) throw new TypeError("Generator is already executing.");
    for (; r; ) try {
      if (i = 1, n && (s = h[0] & 2 ? n.return : h[0] ? n.throw || ((s = n.return) && s.call(n), 0) : n.next) && !(s = s.call(n, h[1])).done) return s;
      switch (n = 0, s && (h = [h[0] & 2, s.value]), h[0]) {
        case 0:
        case 1:
          s = h;
          break;
        case 4:
          return r.label++, { value: h[1], done: !1 };
        case 5:
          r.label++, n = h[1], h = [0];
          continue;
        case 7:
          h = r.ops.pop(), r.trys.pop();
          continue;
        default:
          if (s = r.trys, !(s = s.length > 0 && s[s.length - 1]) && (h[0] === 6 || h[0] === 2)) {
            r = 0;
            continue;
          }
          if (h[0] === 3 && (!s || h[1] > s[0] && h[1] < s[3])) {
            r.label = h[1];
            break;
          }
          if (h[0] === 6 && r.label < s[1]) {
            r.label = s[1], s = h;
            break;
          }
          if (s && r.label < s[2]) {
            r.label = s[2], r.ops.push(h);
            break;
          }
          s[2] && r.ops.pop(), r.trys.pop();
          continue;
      }
      h = e.call(t, r);
    } catch (f) {
      h = [6, f], n = 0;
    } finally {
      i = s = 0;
    }
    if (h[0] & 5) throw h[1];
    return { value: h[0] ? h[1] : void 0, done: !0 };
  }
}
function jd(t, e, r, i) {
  i === void 0 && (i = r), t[i] = e[r];
}
function qd(t, e) {
  for (var r in t) r !== "default" && !e.hasOwnProperty(r) && (e[r] = t[r]);
}
function fn(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, r = e && t[e], i = 0;
  if (r) return r.call(t);
  if (t && typeof t.length == "number") return {
    next: function() {
      return t && i >= t.length && (t = void 0), { value: t && t[i++], done: !t };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function oa(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r) return t;
  var i = r.call(t), n, s = [], u;
  try {
    for (; (e === void 0 || e-- > 0) && !(n = i.next()).done; ) s.push(n.value);
  } catch (a) {
    u = { error: a };
  } finally {
    try {
      n && !n.done && (r = i.return) && r.call(i);
    } finally {
      if (u) throw u.error;
    }
  }
  return s;
}
function Bd() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t = t.concat(oa(arguments[e]));
  return t;
}
function zd() {
  for (var t = 0, e = 0, r = arguments.length; e < r; e++) t += arguments[e].length;
  for (var i = Array(t), n = 0, e = 0; e < r; e++)
    for (var s = arguments[e], u = 0, a = s.length; u < a; u++, n++)
      i[n] = s[u];
  return i;
}
function jr(t) {
  return this instanceof jr ? (this.v = t, this) : new jr(t);
}
function Kd(t, e, r) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var i = r.apply(t, e || []), n, s = [];
  return n = {}, u("next"), u("throw"), u("return"), n[Symbol.asyncIterator] = function() {
    return this;
  }, n;
  function u(g) {
    i[g] && (n[g] = function(_) {
      return new Promise(function(w, T) {
        s.push([g, _, w, T]) > 1 || a(g, _);
      });
    });
  }
  function a(g, _) {
    try {
      l(i[g](_));
    } catch (w) {
      y(s[0][3], w);
    }
  }
  function l(g) {
    g.value instanceof jr ? Promise.resolve(g.value.v).then(h, f) : y(s[0][2], g);
  }
  function h(g) {
    a("next", g);
  }
  function f(g) {
    a("throw", g);
  }
  function y(g, _) {
    g(_), s.shift(), s.length && a(s[0][0], s[0][1]);
  }
}
function Vd(t) {
  var e, r;
  return e = {}, i("next"), i("throw", function(n) {
    throw n;
  }), i("return"), e[Symbol.iterator] = function() {
    return this;
  }, e;
  function i(n, s) {
    e[n] = t[n] ? function(u) {
      return (r = !r) ? { value: jr(t[n](u)), done: n === "return" } : s ? s(u) : u;
    } : s;
  }
}
function Hd(t) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator], r;
  return e ? e.call(t) : (t = typeof fn == "function" ? fn(t) : t[Symbol.iterator](), r = {}, i("next"), i("throw"), i("return"), r[Symbol.asyncIterator] = function() {
    return this;
  }, r);
  function i(s) {
    r[s] = t[s] && function(u) {
      return new Promise(function(a, l) {
        u = t[s](u), n(a, l, u.done, u.value);
      });
    };
  }
  function n(s, u, a, l) {
    Promise.resolve(l).then(function(h) {
      s({ value: h, done: a });
    }, u);
  }
}
function Gd(t, e) {
  return Object.defineProperty ? Object.defineProperty(t, "raw", { value: e }) : t.raw = e, t;
}
function kd(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
  return e.default = t, e;
}
function Wd(t) {
  return t && t.__esModule ? t : { default: t };
}
function Yd(t, e) {
  if (!e.has(t))
    throw new TypeError("attempted to get private field on non-instance");
  return e.get(t);
}
function Jd(t, e, r) {
  if (!e.has(t))
    throw new TypeError("attempted to set private field on non-instance");
  return e.set(t, r), r;
}
const Xd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return ln;
  },
  __asyncDelegator: Vd,
  __asyncGenerator: Kd,
  __asyncValues: Hd,
  __await: jr,
  __awaiter: Ld,
  __classPrivateFieldGet: Yd,
  __classPrivateFieldSet: Jd,
  __createBinding: jd,
  __decorate: Fd,
  __exportStar: qd,
  __extends: Ad,
  __generator: Md,
  __importDefault: Wd,
  __importStar: kd,
  __makeTemplateObject: Gd,
  __metadata: Ud,
  __param: $d,
  __read: oa,
  __rest: Cd,
  __spread: Bd,
  __spreadArrays: zd,
  __values: fn
}, Symbol.toStringTag, { value: "Module" })), Qd = /* @__PURE__ */ nr(Xd);
var qi, Bs;
function Zd() {
  if (Bs) return qi;
  Bs = 1;
  function t(r) {
    try {
      return JSON.stringify(r);
    } catch {
      return '"[Circular]"';
    }
  }
  qi = e;
  function e(r, i, n) {
    var s = n && n.stringify || t, u = 1;
    if (typeof r == "object" && r !== null) {
      var a = i.length + u;
      if (a === 1) return r;
      var l = new Array(a);
      l[0] = s(r);
      for (var h = 1; h < a; h++)
        l[h] = s(i[h]);
      return l.join(" ");
    }
    if (typeof r != "string")
      return r;
    var f = i.length;
    if (f === 0) return r;
    for (var y = "", g = 1 - u, _ = -1, w = r && r.length || 0, T = 0; T < w; ) {
      if (r.charCodeAt(T) === 37 && T + 1 < w) {
        switch (_ = _ > -1 ? _ : 0, r.charCodeAt(T + 1)) {
          case 100:
          case 102:
            if (g >= f || i[g] == null) break;
            _ < T && (y += r.slice(_, T)), y += Number(i[g]), _ = T + 2, T++;
            break;
          case 105:
            if (g >= f || i[g] == null) break;
            _ < T && (y += r.slice(_, T)), y += Math.floor(Number(i[g])), _ = T + 2, T++;
            break;
          case 79:
          case 111:
          case 106:
            if (g >= f || i[g] === void 0) break;
            _ < T && (y += r.slice(_, T));
            var A = typeof i[g];
            if (A === "string") {
              y += "'" + i[g] + "'", _ = T + 2, T++;
              break;
            }
            if (A === "function") {
              y += i[g].name || "<anonymous>", _ = T + 2, T++;
              break;
            }
            y += s(i[g]), _ = T + 2, T++;
            break;
          case 115:
            if (g >= f)
              break;
            _ < T && (y += r.slice(_, T)), y += String(i[g]), _ = T + 2, T++;
            break;
          case 37:
            _ < T && (y += r.slice(_, T)), y += "%", _ = T + 2, T++, g--;
            break;
        }
        ++g;
      }
      ++T;
    }
    return _ === -1 ? r : (_ < w && (y += r.slice(_)), y);
  }
  return qi;
}
var Bi, zs;
function ep() {
  if (zs) return Bi;
  zs = 1;
  const t = Zd();
  Bi = n;
  const e = E().console || {}, r = {
    mapHttpRequest: w,
    mapHttpResponse: w,
    wrapRequestSerializer: T,
    wrapResponseSerializer: T,
    wrapErrorSerializer: T,
    req: w,
    res: w,
    err: g
  };
  function i(p, o) {
    return Array.isArray(p) ? p.filter(function(C) {
      return C !== "!stdSerializers.err";
    }) : p === !0 ? Object.keys(o) : !1;
  }
  function n(p) {
    p = p || {}, p.browser = p.browser || {};
    const o = p.browser.transmit;
    if (o && typeof o.send != "function")
      throw Error("pino: transmit option must have a send function");
    const d = p.browser.write || e;
    p.browser.write && (p.browser.asObject = !0);
    const C = p.serializers || {}, F = i(p.browser.serialize, C);
    let K = p.browser.serialize;
    Array.isArray(p.browser.serialize) && p.browser.serialize.indexOf("!stdSerializers.err") > -1 && (K = !1);
    const G = ["error", "fatal", "warn", "info", "debug", "trace"];
    typeof d == "function" && (d.error = d.fatal = d.warn = d.info = d.debug = d.trace = d), p.enabled === !1 && (p.level = "silent");
    const X = p.level || "info", x = Object.create(d);
    x.log || (x.log = A), Object.defineProperty(x, "levelVal", {
      get: k
    }), Object.defineProperty(x, "level", {
      get: q,
      set: U
    });
    const N = {
      transmit: o,
      serialize: F,
      asObject: p.browser.asObject,
      levels: G,
      timestamp: _(p)
    };
    x.levels = n.levels, x.level = X, x.setMaxListeners = x.getMaxListeners = x.emit = x.addListener = x.on = x.prependListener = x.once = x.prependOnceListener = x.removeListener = x.removeAllListeners = x.listeners = x.listenerCount = x.eventNames = x.write = x.flush = A, x.serializers = C, x._serialize = F, x._stdErrSerialize = K, x.child = M, o && (x._logEvent = y());
    function k() {
      return this.level === "silent" ? 1 / 0 : this.levels.values[this.level];
    }
    function q() {
      return this._level;
    }
    function U($) {
      if ($ !== "silent" && !this.levels.values[$])
        throw Error("unknown level " + $);
      this._level = $, s(N, x, "error", "log"), s(N, x, "fatal", "error"), s(N, x, "warn", "error"), s(N, x, "info", "log"), s(N, x, "debug", "log"), s(N, x, "trace", "log");
    }
    function M($, B) {
      if (!$)
        throw new Error("missing bindings for child Pino");
      B = B || {}, F && $.serializers && (B.serializers = $.serializers);
      const te = B.serializers;
      if (F && te) {
        var z = Object.assign({}, C, te), Z = p.browser.serialize === !0 ? Object.keys(z) : F;
        delete $.serializers, l([$], Z, z, this._stdErrSerialize);
      }
      function Y(ee) {
        this._childLevel = (ee._childLevel | 0) + 1, this.error = h(ee, $, "error"), this.fatal = h(ee, $, "fatal"), this.warn = h(ee, $, "warn"), this.info = h(ee, $, "info"), this.debug = h(ee, $, "debug"), this.trace = h(ee, $, "trace"), z && (this.serializers = z, this._serialize = Z), o && (this._logEvent = y(
          [].concat(ee._logEvent.bindings, $)
        ));
      }
      return Y.prototype = this, new Y(this);
    }
    return x;
  }
  n.levels = {
    values: {
      fatal: 60,
      error: 50,
      warn: 40,
      info: 30,
      debug: 20,
      trace: 10
    },
    labels: {
      10: "trace",
      20: "debug",
      30: "info",
      40: "warn",
      50: "error",
      60: "fatal"
    }
  }, n.stdSerializers = r, n.stdTimeFunctions = Object.assign({}, { nullTime: j, epochTime: D, unixTime: O, isoTime: m });
  function s(p, o, d, C) {
    const F = Object.getPrototypeOf(o);
    o[d] = o.levelVal > o.levels.values[d] ? A : F[d] ? F[d] : e[d] || e[C] || A, u(p, o, d);
  }
  function u(p, o, d) {
    !p.transmit && o[d] === A || (o[d] = /* @__PURE__ */ function(C) {
      return function() {
        const K = p.timestamp(), G = new Array(arguments.length), X = Object.getPrototypeOf && Object.getPrototypeOf(this) === e ? e : this;
        for (var x = 0; x < G.length; x++) G[x] = arguments[x];
        if (p.serialize && !p.asObject && l(G, this._serialize, this.serializers, this._stdErrSerialize), p.asObject ? C.call(X, a(this, d, G, K)) : C.apply(X, G), p.transmit) {
          const N = p.transmit.level || o.level, k = n.levels.values[N], q = n.levels.values[d];
          if (q < k) return;
          f(this, {
            ts: K,
            methodLevel: d,
            methodValue: q,
            transmitLevel: N,
            transmitValue: n.levels.values[p.transmit.level || o.level],
            send: p.transmit.send,
            val: o.levelVal
          }, G);
        }
      };
    }(o[d]));
  }
  function a(p, o, d, C) {
    p._serialize && l(d, p._serialize, p.serializers, p._stdErrSerialize);
    const F = d.slice();
    let K = F[0];
    const G = {};
    C && (G.time = C), G.level = n.levels.values[o];
    let X = (p._childLevel | 0) + 1;
    if (X < 1 && (X = 1), K !== null && typeof K == "object") {
      for (; X-- && typeof F[0] == "object"; )
        Object.assign(G, F.shift());
      K = F.length ? t(F.shift(), F) : void 0;
    } else typeof K == "string" && (K = t(F.shift(), F));
    return K !== void 0 && (G.msg = K), G;
  }
  function l(p, o, d, C) {
    for (const F in p)
      if (C && p[F] instanceof Error)
        p[F] = n.stdSerializers.err(p[F]);
      else if (typeof p[F] == "object" && !Array.isArray(p[F]))
        for (const K in p[F])
          o && o.indexOf(K) > -1 && K in d && (p[F][K] = d[K](p[F][K]));
  }
  function h(p, o, d) {
    return function() {
      const C = new Array(1 + arguments.length);
      C[0] = o;
      for (var F = 1; F < C.length; F++)
        C[F] = arguments[F - 1];
      return p[d].apply(this, C);
    };
  }
  function f(p, o, d) {
    const C = o.send, F = o.ts, K = o.methodLevel, G = o.methodValue, X = o.val, x = p._logEvent.bindings;
    l(
      d,
      p._serialize || Object.keys(p.serializers),
      p.serializers,
      p._stdErrSerialize === void 0 ? !0 : p._stdErrSerialize
    ), p._logEvent.ts = F, p._logEvent.messages = d.filter(function(N) {
      return x.indexOf(N) === -1;
    }), p._logEvent.level.label = K, p._logEvent.level.value = G, C(K, p._logEvent, X), p._logEvent = y(x);
  }
  function y(p) {
    return {
      ts: 0,
      messages: [],
      bindings: p || [],
      level: { label: "", value: 0 }
    };
  }
  function g(p) {
    const o = {
      type: p.constructor.name,
      msg: p.message,
      stack: p.stack
    };
    for (const d in p)
      o[d] === void 0 && (o[d] = p[d]);
    return o;
  }
  function _(p) {
    return typeof p.timestamp == "function" ? p.timestamp : p.timestamp === !1 ? j : D;
  }
  function w() {
    return {};
  }
  function T(p) {
    return p;
  }
  function A() {
  }
  function j() {
    return !1;
  }
  function D() {
    return Date.now();
  }
  function O() {
    return Math.round(Date.now() / 1e3);
  }
  function m() {
    return new Date(Date.now()).toISOString();
  }
  function E() {
    function p(o) {
      return typeof o < "u" && o;
    }
    try {
      return typeof globalThis < "u" || Object.defineProperty(Object.prototype, "globalThis", {
        get: function() {
          return delete Object.prototype.globalThis, this.globalThis = this;
        },
        configurable: !0
      }), globalThis;
    } catch {
      return p(self) || p(window) || p(this) || {};
    }
  }
  return Bi;
}
var tr = {}, Ks;
function aa() {
  return Ks || (Ks = 1, Object.defineProperty(tr, "__esModule", { value: !0 }), tr.PINO_CUSTOM_CONTEXT_KEY = tr.PINO_LOGGER_DEFAULTS = void 0, tr.PINO_LOGGER_DEFAULTS = {
    level: "info"
  }, tr.PINO_CUSTOM_CONTEXT_KEY = "custom_context"), tr;
}
var ot = {}, Vs;
function tp() {
  if (Vs) return ot;
  Vs = 1, Object.defineProperty(ot, "__esModule", { value: !0 }), ot.generateChildLogger = ot.formatChildLoggerContext = ot.getLoggerContext = ot.setBrowserLoggerContext = ot.getBrowserLoggerContext = ot.getDefaultLoggerOptions = void 0;
  const t = aa();
  function e(a) {
    return Object.assign(Object.assign({}, a), { level: (a == null ? void 0 : a.level) || t.PINO_LOGGER_DEFAULTS.level });
  }
  ot.getDefaultLoggerOptions = e;
  function r(a, l = t.PINO_CUSTOM_CONTEXT_KEY) {
    return a[l] || "";
  }
  ot.getBrowserLoggerContext = r;
  function i(a, l, h = t.PINO_CUSTOM_CONTEXT_KEY) {
    return a[h] = l, a;
  }
  ot.setBrowserLoggerContext = i;
  function n(a, l = t.PINO_CUSTOM_CONTEXT_KEY) {
    let h = "";
    return typeof a.bindings > "u" ? h = r(a, l) : h = a.bindings().context || "", h;
  }
  ot.getLoggerContext = n;
  function s(a, l, h = t.PINO_CUSTOM_CONTEXT_KEY) {
    const f = n(a, h);
    return f.trim() ? `${f}/${l}` : l;
  }
  ot.formatChildLoggerContext = s;
  function u(a, l, h = t.PINO_CUSTOM_CONTEXT_KEY) {
    const f = s(a, l, h), y = a.child({ context: f });
    return i(y, f, h);
  }
  return ot.generateChildLogger = u, ot;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.pino = void 0;
  const e = Qd, r = e.__importDefault(ep());
  Object.defineProperty(t, "pino", { enumerable: !0, get: function() {
    return r.default;
  } }), e.__exportStar(aa(), t), e.__exportStar(tp(), t);
})(be);
class rp extends ar {
  constructor(e) {
    super(), this.opts = e, this.protocol = "wc", this.version = 2;
  }
}
let ip = class extends ar {
  constructor(e, r) {
    super(), this.core = e, this.logger = r, this.records = /* @__PURE__ */ new Map();
  }
}, np = class {
  constructor(e, r) {
    this.logger = e, this.core = r;
  }
};
class sp extends ar {
  constructor(e, r) {
    super(), this.relayer = e, this.logger = r;
  }
}
let op = class extends ar {
  constructor(e) {
    super();
  }
}, ap = class {
  constructor(e, r, i, n) {
    this.core = e, this.logger = r, this.name = i;
  }
};
class cp extends ar {
  constructor(e, r) {
    super(), this.relayer = e, this.logger = r;
  }
}
class up extends ar {
  constructor(e, r) {
    super(), this.core = e, this.logger = r;
  }
}
class hp {
  constructor(e, r) {
    this.projectId = e, this.logger = r;
  }
}
let lp = class {
  constructor(e, r) {
    this.projectId = e, this.logger = r;
  }
}, fp = class {
  constructor(e) {
    this.opts = e, this.protocol = "wc", this.version = 2;
  }
}, dp = class {
  constructor(e) {
    this.client = e;
  }
};
const pp = {
  waku: {
    publish: "waku_publish",
    batchPublish: "waku_batchPublish",
    subscribe: "waku_subscribe",
    batchSubscribe: "waku_batchSubscribe",
    subscription: "waku_subscription",
    unsubscribe: "waku_unsubscribe",
    batchUnsubscribe: "waku_batchUnsubscribe"
  },
  irn: {
    publish: "irn_publish",
    batchPublish: "irn_batchPublish",
    subscribe: "irn_subscribe",
    batchSubscribe: "irn_batchSubscribe",
    subscription: "irn_subscription",
    unsubscribe: "irn_unsubscribe",
    batchUnsubscribe: "irn_batchUnsubscribe"
  },
  iridium: {
    publish: "iridium_publish",
    batchPublish: "iridium_batchPublish",
    subscribe: "iridium_subscribe",
    batchSubscribe: "iridium_batchSubscribe",
    subscription: "iridium_subscription",
    unsubscribe: "iridium_unsubscribe",
    batchUnsubscribe: "iridium_batchUnsubscribe"
  }
};
function $n(t, e) {
  return t.includes(":") ? [t] : e.chains || [];
}
const Un = "base10", st = "base16", li = "base64pad", Si = "utf8", Ln = 0, kt = 1, gp = 0, Hs = 1, dn = 12, Mn = 32;
function ca() {
  const t = An.generateKeyPair();
  return { privateKey: ht(t.secretKey, st), publicKey: ht(t.publicKey, st) };
}
function fi() {
  const t = _r.randomBytes(Mn);
  return ht(t, st);
}
function ua(t, e) {
  const r = An.sharedKey(dt(t, st), dt(e, st), !0), i = new cl(wi.SHA256, r).expand(Mn);
  return ht(i, st);
}
function ha(t) {
  const e = wi.hash(dt(t, st));
  return ht(e, st);
}
function ir(t) {
  const e = wi.hash(dt(t, Si));
  return ht(e, st);
}
function la(t) {
  return dt(`${t}`, Un);
}
function wr(t) {
  return Number(ht(t, Un));
}
function fa(t) {
  const e = la(typeof t.type < "u" ? t.type : Ln);
  if (wr(e) === kt && typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const r = typeof t.senderPublicKey < "u" ? dt(t.senderPublicKey, st) : void 0, i = typeof t.iv < "u" ? dt(t.iv, st) : _r.randomBytes(dn), n = new Rn.ChaCha20Poly1305(dt(t.symKey, st)).seal(i, dt(t.message, Si));
  return pa({ type: e, sealed: n, iv: i, senderPublicKey: r });
}
function da(t) {
  const e = new Rn.ChaCha20Poly1305(dt(t.symKey, st)), { sealed: r, iv: i } = qr(t.encoded), n = e.open(i, r);
  if (n === null) throw new Error("Failed to decrypt");
  return ht(n, Si);
}
function pa(t) {
  if (wr(t.type) === kt) {
    if (typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return ht(sn([t.type, t.senderPublicKey, t.iv, t.sealed]), li);
  }
  return ht(sn([t.type, t.iv, t.sealed]), li);
}
function qr(t) {
  const e = dt(t, li), r = e.slice(gp, Hs), i = Hs;
  if (wr(r) === kt) {
    const a = i + Mn, l = a + dn, h = e.slice(i, a), f = e.slice(a, l), y = e.slice(l);
    return { type: r, sealed: y, iv: f, senderPublicKey: h };
  }
  const n = i + dn, s = e.slice(i, n), u = e.slice(n);
  return { type: r, sealed: u, iv: s };
}
function ga(t, e) {
  const r = qr(t);
  return jn({ type: wr(r.type), senderPublicKey: typeof r.senderPublicKey < "u" ? ht(r.senderPublicKey, st) : void 0, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey });
}
function jn(t) {
  const e = (t == null ? void 0 : t.type) || Ln;
  if (e === kt) {
    if (typeof (t == null ? void 0 : t.senderPublicKey) > "u") throw new Error("missing sender public key");
    if (typeof (t == null ? void 0 : t.receiverPublicKey) > "u") throw new Error("missing receiver public key");
  }
  return { type: e, senderPublicKey: t == null ? void 0 : t.senderPublicKey, receiverPublicKey: t == null ? void 0 : t.receiverPublicKey };
}
function pn(t) {
  return t.type === kt && typeof t.senderPublicKey == "string" && typeof t.receiverPublicKey == "string";
}
var yp = Object.defineProperty, Gs = Object.getOwnPropertySymbols, bp = Object.prototype.hasOwnProperty, _p = Object.prototype.propertyIsEnumerable, ks = (t, e, r) => e in t ? yp(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Ws = (t, e) => {
  for (var r in e || (e = {})) bp.call(e, r) && ks(t, r, e[r]);
  if (Gs) for (var r of Gs(e)) _p.call(e, r) && ks(t, r, e[r]);
  return t;
};
const ya = "ReactNative", pt = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" }, ba = "js";
function xi() {
  return typeof xt < "u" && typeof xt.versions < "u" && typeof xt.versions.node < "u";
}
function cr() {
  return !On() && !!Pn() && navigator.product === ya;
}
function ur() {
  return !xi() && !!Pn() && !!On();
}
function vr() {
  return cr() ? pt.reactNative : xi() ? pt.node : ur() ? pt.browser : pt.unknown;
}
function _a() {
  var t;
  try {
    return cr() && typeof xe < "u" && typeof (xe == null ? void 0 : xe.Application) < "u" ? (t = xe.Application) == null ? void 0 : t.applicationId : void 0;
  } catch {
    return;
  }
}
function ma(t, e) {
  let r = Lr.parse(t);
  return r = Ws(Ws({}, r), e), t = Lr.stringify(r), t;
}
function wa() {
  return Co() || { name: "", description: "", url: "", icons: [""] };
}
function va() {
  if (vr() === pt.reactNative && typeof xe < "u" && typeof (xe == null ? void 0 : xe.Platform) < "u") {
    const { OS: r, Version: i } = xe.Platform;
    return [r, i].join("-");
  }
  const t = Au();
  if (t === null) return "unknown";
  const e = t.os ? t.os.replace(" ", "").toLowerCase() : "unknown";
  return t.type === "browser" ? [e, t.name, t.version].join("-") : [e, t.version].join("-");
}
function Ea() {
  var t;
  const e = vr();
  return e === pt.browser ? [e, ((t = Ao()) == null ? void 0 : t.host) || "unknown"].join(":") : e;
}
function Da(t, e, r) {
  const i = va(), n = Ea();
  return [[t, e].join("-"), [ba, r].join("-"), i, n].join("/");
}
function Sa({ protocol: t, version: e, relayUrl: r, sdkVersion: i, auth: n, projectId: s, useOnCloseEvent: u, bundleId: a }) {
  const l = r.split("?"), h = Da(t, e, i), f = { auth: n, ua: h, projectId: s, useOnCloseEvent: u || void 0, origin: a || void 0 }, y = ma(l[1] || "", f);
  return l[0] + "?" + y;
}
function Vt(t, e) {
  return t.filter((r) => e.includes(r)).length === t.length;
}
function qn(t) {
  return Object.fromEntries(t.entries());
}
function Bn(t) {
  return new Map(Object.entries(t));
}
function rr(t = Q.FIVE_MINUTES, e) {
  const r = Q.toMiliseconds(t || Q.FIVE_MINUTES);
  let i, n, s;
  return { resolve: (u) => {
    s && i && (clearTimeout(s), i(u));
  }, reject: (u) => {
    s && n && (clearTimeout(s), n(u));
  }, done: () => new Promise((u, a) => {
    s = setTimeout(() => {
      a(new Error(e));
    }, r), i = u, n = a;
  }) };
}
function yr(t, e, r) {
  return new Promise(async (i, n) => {
    const s = setTimeout(() => n(new Error(r)), e);
    try {
      const u = await t;
      i(u);
    } catch (u) {
      n(u);
    }
    clearTimeout(s);
  });
}
function zn(t, e) {
  if (typeof e == "string" && e.startsWith(`${t}:`)) return e;
  if (t.toLowerCase() === "topic") {
    if (typeof e != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${e}`;
  } else if (t.toLowerCase() === "id") {
    if (typeof e != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${e}`;
  }
  throw new Error(`Unknown expirer target type: ${t}`);
}
function xa(t) {
  return zn("topic", t);
}
function Ia(t) {
  return zn("id", t);
}
function Kn(t) {
  const [e, r] = t.split(":"), i = { id: void 0, topic: void 0 };
  if (e === "topic" && typeof r == "string") i.topic = r;
  else if (e === "id" && Number.isInteger(Number(r))) i.id = Number(r);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${r}`);
  return i;
}
function ft(t, e) {
  return Q.fromMiliseconds(Date.now() + Q.toMiliseconds(t));
}
function jt(t) {
  return Date.now() >= Q.toMiliseconds(t);
}
function Fe(t, e) {
  return `${t}${e ? `:${e}` : ""}`;
}
async function Oa({ id: t, topic: e, wcDeepLink: r }) {
  try {
    if (!r) return;
    const i = typeof r == "string" ? JSON.parse(r) : r;
    let n = i == null ? void 0 : i.href;
    if (typeof n != "string") return;
    n.endsWith("/") && (n = n.slice(0, -1));
    const s = `${n}/wc?requestId=${t}&sessionTopic=${e}`, u = vr();
    u === pt.browser ? s.startsWith("https://") ? window.open(s, "_blank", "noreferrer noopener") : window.open(s, "_self", "noreferrer noopener") : u === pt.reactNative && typeof (xe == null ? void 0 : xe.Linking) < "u" && await xe.Linking.openURL(s);
  } catch {
  }
}
async function Pa(t, e) {
  try {
    return await t.getItem(e) || (ur() ? localStorage.getItem(e) : void 0);
  } catch {
  }
}
const Ta = "irn";
function di(t) {
  return (t == null ? void 0 : t.relay) || { protocol: Ta };
}
function Fr(t) {
  const e = pp[t];
  if (typeof e > "u") throw new Error(`Relay Protocol not supported: ${t}`);
  return e;
}
var mp = Object.defineProperty, wp = Object.defineProperties, vp = Object.getOwnPropertyDescriptors, Ys = Object.getOwnPropertySymbols, Ep = Object.prototype.hasOwnProperty, Dp = Object.prototype.propertyIsEnumerable, Js = (t, e, r) => e in t ? mp(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Sp = (t, e) => {
  for (var r in e || (e = {})) Ep.call(e, r) && Js(t, r, e[r]);
  if (Ys) for (var r of Ys(e)) Dp.call(e, r) && Js(t, r, e[r]);
  return t;
}, xp = (t, e) => wp(t, vp(e));
function Ra(t, e = "-") {
  const r = {}, i = "relay" + e;
  return Object.keys(t).forEach((n) => {
    if (n.startsWith(i)) {
      const s = n.replace(i, ""), u = t[n];
      r[s] = u;
    }
  }), r;
}
function gn(t) {
  t = t.includes("wc://") ? t.replace("wc://", "") : t, t = t.includes("wc:") ? t.replace("wc:", "") : t;
  const e = t.indexOf(":"), r = t.indexOf("?") !== -1 ? t.indexOf("?") : void 0, i = t.substring(0, e), n = t.substring(e + 1, r).split("@"), s = typeof r < "u" ? t.substring(r) : "", u = Lr.parse(s);
  return { protocol: i, topic: Na(n[0]), version: parseInt(n[1], 10), symKey: u.symKey, relay: Ra(u), expiryTimestamp: u.expiryTimestamp ? parseInt(u.expiryTimestamp, 10) : void 0 };
}
function Na(t) {
  return t.startsWith("//") ? t.substring(2) : t;
}
function Aa(t, e = "-") {
  const r = "relay", i = {};
  return Object.keys(t).forEach((n) => {
    const s = r + e + n;
    t[n] && (i[s] = t[n]);
  }), i;
}
function Ca(t) {
  return `${t.protocol}:${t.topic}@${t.version}?` + Lr.stringify(xp(Sp({ symKey: t.symKey }, Aa(t.relay)), { expiryTimestamp: t.expiryTimestamp }));
}
function hr(t) {
  const e = [];
  return t.forEach((r) => {
    const [i, n] = r.split(":");
    e.push(`${i}:${n}`);
  }), e;
}
function Fa(t) {
  const e = [];
  return Object.values(t).forEach((r) => {
    e.push(...hr(r.accounts));
  }), e;
}
function $a(t, e) {
  const r = [];
  return Object.values(t).forEach((i) => {
    hr(i.accounts).includes(e) && r.push(...i.methods);
  }), r;
}
function Ua(t, e) {
  const r = [];
  return Object.values(t).forEach((i) => {
    hr(i.accounts).includes(e) && r.push(...i.events);
  }), r;
}
const La = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } }, Ma = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function H(t, e) {
  const { message: r, code: i } = Ma[t];
  return { message: e ? `${r} ${e}` : r, code: i };
}
function $e(t, e) {
  const { message: r, code: i } = La[t];
  return { message: e ? `${r} ${e}` : r, code: i };
}
function Er(t, e) {
  return !!Array.isArray(t);
}
function Br(t) {
  return Object.getPrototypeOf(t) === Object.prototype && Object.keys(t).length;
}
function ut(t) {
  return typeof t > "u";
}
function Ke(t, e) {
  return e && ut(t) ? !0 : typeof t == "string" && !!t.trim().length;
}
function Ii(t, e) {
  return typeof t == "number" && !isNaN(t);
}
function ja(t, e) {
  const { requiredNamespaces: r } = e, i = Object.keys(t.namespaces), n = Object.keys(r);
  let s = !0;
  return Vt(n, i) ? (i.forEach((u) => {
    const { accounts: a, methods: l, events: h } = t.namespaces[u], f = hr(a), y = r[u];
    (!Vt($n(u, y), f) || !Vt(y.methods, l) || !Vt(y.events, h)) && (s = !1);
  }), s) : !1;
}
function zr(t) {
  return Ke(t, !1) && t.includes(":") ? t.split(":").length === 2 : !1;
}
function qa(t) {
  if (Ke(t, !1) && t.includes(":")) {
    const e = t.split(":");
    if (e.length === 3) {
      const r = e[0] + ":" + e[1];
      return !!e[2] && zr(r);
    }
  }
  return !1;
}
function Ba(t) {
  if (Ke(t, !1)) try {
    return typeof new URL(t) < "u";
  } catch {
    return !1;
  }
  return !1;
}
function za(t) {
  var e;
  return (e = t == null ? void 0 : t.proposer) == null ? void 0 : e.publicKey;
}
function Ka(t) {
  return t == null ? void 0 : t.topic;
}
function Va(t, e) {
  let r = null;
  return Ke(t == null ? void 0 : t.publicKey, !1) || (r = H("MISSING_OR_INVALID", `${e} controller public key should be a string`)), r;
}
function yn(t) {
  let e = !0;
  return Er(t) ? t.length && (e = t.every((r) => Ke(r, !1))) : e = !1, e;
}
function Ha(t, e, r) {
  let i = null;
  return Er(e) && e.length ? e.forEach((n) => {
    i || zr(n) || (i = $e("UNSUPPORTED_CHAINS", `${r}, chain ${n} should be a string and conform to "namespace:chainId" format`));
  }) : zr(t) || (i = $e("UNSUPPORTED_CHAINS", `${r}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), i;
}
function Ga(t, e, r) {
  let i = null;
  return Object.entries(t).forEach(([n, s]) => {
    if (i) return;
    const u = Ha(n, $n(n, s), `${e} ${r}`);
    u && (i = u);
  }), i;
}
function ka(t, e) {
  let r = null;
  return Er(t) ? t.forEach((i) => {
    r || qa(i) || (r = $e("UNSUPPORTED_ACCOUNTS", `${e}, account ${i} should be a string and conform to "namespace:chainId:address" format`));
  }) : r = $e("UNSUPPORTED_ACCOUNTS", `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), r;
}
function Wa(t, e) {
  let r = null;
  return Object.values(t).forEach((i) => {
    if (r) return;
    const n = ka(i == null ? void 0 : i.accounts, `${e} namespace`);
    n && (r = n);
  }), r;
}
function Ya(t, e) {
  let r = null;
  return yn(t == null ? void 0 : t.methods) ? yn(t == null ? void 0 : t.events) || (r = $e("UNSUPPORTED_EVENTS", `${e}, events should be an array of strings or empty array for no events`)) : r = $e("UNSUPPORTED_METHODS", `${e}, methods should be an array of strings or empty array for no methods`), r;
}
function Vn(t, e) {
  let r = null;
  return Object.values(t).forEach((i) => {
    if (r) return;
    const n = Ya(i, `${e}, namespace`);
    n && (r = n);
  }), r;
}
function Ja(t, e, r) {
  let i = null;
  if (t && Br(t)) {
    const n = Vn(t, e);
    n && (i = n);
    const s = Ga(t, e, r);
    s && (i = s);
  } else i = H("MISSING_OR_INVALID", `${e}, ${r} should be an object with data`);
  return i;
}
function ai(t, e) {
  let r = null;
  if (t && Br(t)) {
    const i = Vn(t, e);
    i && (r = i);
    const n = Wa(t, e);
    n && (r = n);
  } else r = H("MISSING_OR_INVALID", `${e}, namespaces should be an object with data`);
  return r;
}
function Hn(t) {
  return Ke(t.protocol, !0);
}
function Xa(t, e) {
  let r = !1;
  return t ? t && Er(t) && t.length && t.forEach((i) => {
    r = Hn(i);
  }) : r = !0, r;
}
function Qa(t) {
  return typeof t == "number";
}
function ct(t) {
  return typeof t < "u" && typeof t !== null;
}
function Za(t) {
  return !(!t || typeof t != "object" || !t.code || !Ii(t.code) || !t.message || !Ke(t.message, !1));
}
function ec(t) {
  return !(ut(t) || !Ke(t.method, !1));
}
function tc(t) {
  return !(ut(t) || ut(t.result) && ut(t.error) || !Ii(t.id) || !Ke(t.jsonrpc, !1));
}
function rc(t) {
  return !(ut(t) || !Ke(t.name, !1));
}
function bn(t, e) {
  return !(!zr(e) || !Fa(t).includes(e));
}
function ic(t, e, r) {
  return Ke(r, !1) ? $a(t, e).includes(r) : !1;
}
function nc(t, e, r) {
  return Ke(r, !1) ? Ua(t, e).includes(r) : !1;
}
function _n(t, e, r) {
  let i = null;
  const n = Ip(t), s = Op(e), u = Object.keys(n), a = Object.keys(s), l = Xs(Object.keys(t)), h = Xs(Object.keys(e)), f = l.filter((y) => !h.includes(y));
  return f.length && (i = H("NON_CONFORMING_NAMESPACES", `${r} namespaces keys don't satisfy requiredNamespaces.
      Required: ${f.toString()}
      Received: ${Object.keys(e).toString()}`)), Vt(u, a) || (i = H("NON_CONFORMING_NAMESPACES", `${r} namespaces chains don't satisfy required namespaces.
      Required: ${u.toString()}
      Approved: ${a.toString()}`)), Object.keys(e).forEach((y) => {
    if (!y.includes(":") || i) return;
    const g = hr(e[y].accounts);
    g.includes(y) || (i = H("NON_CONFORMING_NAMESPACES", `${r} namespaces accounts don't satisfy namespace accounts for ${y}
        Required: ${y}
        Approved: ${g.toString()}`));
  }), u.forEach((y) => {
    i || (Vt(n[y].methods, s[y].methods) ? Vt(n[y].events, s[y].events) || (i = H("NON_CONFORMING_NAMESPACES", `${r} namespaces events don't satisfy namespace events for ${y}`)) : i = H("NON_CONFORMING_NAMESPACES", `${r} namespaces methods don't satisfy namespace methods for ${y}`));
  }), i;
}
function Ip(t) {
  const e = {};
  return Object.keys(t).forEach((r) => {
    var i;
    r.includes(":") ? e[r] = t[r] : (i = t[r].chains) == null || i.forEach((n) => {
      e[n] = { methods: t[r].methods, events: t[r].events };
    });
  }), e;
}
function Xs(t) {
  return [...new Set(t.map((e) => e.includes(":") ? e.split(":")[0] : e))];
}
function Op(t) {
  const e = {};
  return Object.keys(t).forEach((r) => {
    if (r.includes(":")) e[r] = t[r];
    else {
      const i = hr(t[r].accounts);
      i == null || i.forEach((n) => {
        e[n] = { accounts: t[r].accounts.filter((s) => s.includes(`${n}:`)), methods: t[r].methods, events: t[r].events };
      });
    }
  }), e;
}
function sc(t, e) {
  return Ii(t) && t <= e.max && t >= e.min;
}
function mn() {
  const t = vr();
  return new Promise((e) => {
    switch (t) {
      case pt.browser:
        e(oc());
        break;
      case pt.reactNative:
        e(ac());
        break;
      case pt.node:
        e(cc());
        break;
      default:
        e(!0);
    }
  });
}
function oc() {
  return ur() && (navigator == null ? void 0 : navigator.onLine);
}
async function ac() {
  if (cr() && typeof xe < "u" && xe != null && xe.NetInfo) {
    const t = await (xe == null ? void 0 : xe.NetInfo.fetch());
    return t == null ? void 0 : t.isConnected;
  }
  return !0;
}
function cc() {
  return !0;
}
function uc(t) {
  switch (vr()) {
    case pt.browser:
      hc(t);
      break;
    case pt.reactNative:
      lc(t);
      break;
  }
}
function hc(t) {
  !cr() && ur() && (window.addEventListener("online", () => t(!0)), window.addEventListener("offline", () => t(!1)));
}
function lc(t) {
  var e;
  cr() && typeof xe < "u" && xe != null && xe.NetInfo && ((e = xe) == null || e.NetInfo.addEventListener((r) => t(r == null ? void 0 : r.isConnected)));
}
const zi = {};
let Ar = class {
  static get(e) {
    return zi[e];
  }
  static set(e, r) {
    zi[e] = r;
  }
  static delete(e) {
    delete zi[e];
  }
};
const P1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BASE10: Un,
  BASE16: st,
  BASE64: li,
  ENV_MAP: pt,
  INTERNAL_ERRORS: Ma,
  MemoryStore: Ar,
  REACT_NATIVE_PRODUCT: ya,
  RELAYER_DEFAULT_PROTOCOL: Ta,
  SDK_ERRORS: La,
  SDK_TYPE: ba,
  TYPE_0: Ln,
  TYPE_1: kt,
  UTF8: Si,
  appendToQueryString: ma,
  calcExpiry: ft,
  createDelayedPromise: rr,
  createExpiringPromise: yr,
  decodeTypeByte: wr,
  decrypt: da,
  deriveSymKey: ua,
  deserialize: qr,
  encodeTypeByte: la,
  encrypt: fa,
  engineEvent: Fe,
  formatExpirerTarget: zn,
  formatIdTarget: Ia,
  formatRelayParams: Aa,
  formatRelayRpcUrl: Sa,
  formatTopicTarget: xa,
  formatUA: Da,
  formatUri: Ca,
  generateKeyPair: ca,
  generateRandomBytes32: fi,
  getAccountsChains: hr,
  getAppMetadata: wa,
  getBrowserOnlineStatus: oc,
  getBundleId: _a,
  getChainsFromNamespace: $n,
  getDeepLink: Pa,
  getEnvironment: vr,
  getInternalError: H,
  getJavascriptID: Ea,
  getJavascriptOS: va,
  getNamespacesChains: Fa,
  getNamespacesEventsForChainId: Ua,
  getNamespacesMethodsForChainId: $a,
  getNodeOnlineStatus: cc,
  getReactNativeOnlineStatus: ac,
  getRelayProtocolApi: Fr,
  getRelayProtocolName: di,
  getSdkError: $e,
  handleDeeplinkRedirect: Oa,
  hasOverlap: Vt,
  hashKey: ha,
  hashMessage: ir,
  isBrowser: ur,
  isConformingNamespaces: _n,
  isExpired: jt,
  isNode: xi,
  isOnline: mn,
  isProposalStruct: za,
  isReactNative: cr,
  isSessionCompatible: ja,
  isSessionStruct: Ka,
  isTypeOneEnvelope: pn,
  isUndefined: ut,
  isValidAccountId: qa,
  isValidAccounts: ka,
  isValidActions: Ya,
  isValidArray: Er,
  isValidChainId: zr,
  isValidChains: Ha,
  isValidController: Va,
  isValidErrorReason: Za,
  isValidEvent: rc,
  isValidId: Qa,
  isValidNamespaceAccounts: Wa,
  isValidNamespaceActions: Vn,
  isValidNamespaceChains: Ga,
  isValidNamespaceMethodsOrEvents: yn,
  isValidNamespaces: ai,
  isValidNamespacesChainId: bn,
  isValidNamespacesEvent: nc,
  isValidNamespacesRequest: ic,
  isValidNumber: Ii,
  isValidObject: Br,
  isValidParams: ct,
  isValidRelay: Hn,
  isValidRelays: Xa,
  isValidRequest: ec,
  isValidRequestExpiry: sc,
  isValidRequiredNamespaces: Ja,
  isValidResponse: tc,
  isValidString: Ke,
  isValidUrl: Ba,
  mapToObj: qn,
  objToMap: Bn,
  parseExpirerTarget: Kn,
  parseRelayParams: Ra,
  parseTopic: Na,
  parseUri: gn,
  serialize: pa,
  subscribeToBrowserNetworkChange: hc,
  subscribeToNetworkChange: uc,
  subscribeToReactNativeNetworkChange: lc,
  validateDecoding: ga,
  validateEncoding: jn
}, Symbol.toStringTag, { value: "Module" })), Pp = "PARSE_ERROR", Tp = "INVALID_REQUEST", Rp = "METHOD_NOT_FOUND", Np = "INVALID_PARAMS", fc = "INTERNAL_ERROR", Gn = "SERVER_ERROR", Ap = [-32700, -32600, -32601, -32602, -32603], $r = {
  [Pp]: { code: -32700, message: "Parse error" },
  [Tp]: { code: -32600, message: "Invalid Request" },
  [Rp]: { code: -32601, message: "Method not found" },
  [Np]: { code: -32602, message: "Invalid params" },
  [fc]: { code: -32603, message: "Internal error" },
  [Gn]: { code: -32e3, message: "Server error" }
}, dc = Gn;
function Cp(t) {
  return Ap.includes(t);
}
function Qs(t) {
  return Object.keys($r).includes(t) ? $r[t] : $r[dc];
}
function Fp(t) {
  const e = Object.values($r).find((r) => r.code === t);
  return e || $r[dc];
}
function $p(t, e, r) {
  return t.message.includes("getaddrinfo ENOTFOUND") || t.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${r} RPC url at ${e}`) : t;
}
var pc = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var wn = function(t, e) {
  return wn = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, i) {
    r.__proto__ = i;
  } || function(r, i) {
    for (var n in i) i.hasOwnProperty(n) && (r[n] = i[n]);
  }, wn(t, e);
};
function Up(t, e) {
  wn(t, e);
  function r() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype, new r());
}
var vn = function() {
  return vn = Object.assign || function(e) {
    for (var r, i = 1, n = arguments.length; i < n; i++) {
      r = arguments[i];
      for (var s in r) Object.prototype.hasOwnProperty.call(r, s) && (e[s] = r[s]);
    }
    return e;
  }, vn.apply(this, arguments);
};
function Lp(t, e) {
  var r = {};
  for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && e.indexOf(i) < 0 && (r[i] = t[i]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var n = 0, i = Object.getOwnPropertySymbols(t); n < i.length; n++)
      e.indexOf(i[n]) < 0 && Object.prototype.propertyIsEnumerable.call(t, i[n]) && (r[i[n]] = t[i[n]]);
  return r;
}
function Mp(t, e, r, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, r) : i, u;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, r, i);
  else for (var a = t.length - 1; a >= 0; a--) (u = t[a]) && (s = (n < 3 ? u(s) : n > 3 ? u(e, r, s) : u(e, r)) || s);
  return n > 3 && s && Object.defineProperty(e, r, s), s;
}
function jp(t, e) {
  return function(r, i) {
    e(r, i, t);
  };
}
function qp(t, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(t, e);
}
function Bp(t, e, r, i) {
  function n(s) {
    return s instanceof r ? s : new r(function(u) {
      u(s);
    });
  }
  return new (r || (r = Promise))(function(s, u) {
    function a(f) {
      try {
        h(i.next(f));
      } catch (y) {
        u(y);
      }
    }
    function l(f) {
      try {
        h(i.throw(f));
      } catch (y) {
        u(y);
      }
    }
    function h(f) {
      f.done ? s(f.value) : n(f.value).then(a, l);
    }
    h((i = i.apply(t, e || [])).next());
  });
}
function zp(t, e) {
  var r = { label: 0, sent: function() {
    if (s[0] & 1) throw s[1];
    return s[1];
  }, trys: [], ops: [] }, i, n, s, u;
  return u = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (u[Symbol.iterator] = function() {
    return this;
  }), u;
  function a(h) {
    return function(f) {
      return l([h, f]);
    };
  }
  function l(h) {
    if (i) throw new TypeError("Generator is already executing.");
    for (; r; ) try {
      if (i = 1, n && (s = h[0] & 2 ? n.return : h[0] ? n.throw || ((s = n.return) && s.call(n), 0) : n.next) && !(s = s.call(n, h[1])).done) return s;
      switch (n = 0, s && (h = [h[0] & 2, s.value]), h[0]) {
        case 0:
        case 1:
          s = h;
          break;
        case 4:
          return r.label++, { value: h[1], done: !1 };
        case 5:
          r.label++, n = h[1], h = [0];
          continue;
        case 7:
          h = r.ops.pop(), r.trys.pop();
          continue;
        default:
          if (s = r.trys, !(s = s.length > 0 && s[s.length - 1]) && (h[0] === 6 || h[0] === 2)) {
            r = 0;
            continue;
          }
          if (h[0] === 3 && (!s || h[1] > s[0] && h[1] < s[3])) {
            r.label = h[1];
            break;
          }
          if (h[0] === 6 && r.label < s[1]) {
            r.label = s[1], s = h;
            break;
          }
          if (s && r.label < s[2]) {
            r.label = s[2], r.ops.push(h);
            break;
          }
          s[2] && r.ops.pop(), r.trys.pop();
          continue;
      }
      h = e.call(t, r);
    } catch (f) {
      h = [6, f], n = 0;
    } finally {
      i = s = 0;
    }
    if (h[0] & 5) throw h[1];
    return { value: h[0] ? h[1] : void 0, done: !0 };
  }
}
function Kp(t, e, r, i) {
  i === void 0 && (i = r), t[i] = e[r];
}
function Vp(t, e) {
  for (var r in t) r !== "default" && !e.hasOwnProperty(r) && (e[r] = t[r]);
}
function En(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, r = e && t[e], i = 0;
  if (r) return r.call(t);
  if (t && typeof t.length == "number") return {
    next: function() {
      return t && i >= t.length && (t = void 0), { value: t && t[i++], done: !t };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function gc(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r) return t;
  var i = r.call(t), n, s = [], u;
  try {
    for (; (e === void 0 || e-- > 0) && !(n = i.next()).done; ) s.push(n.value);
  } catch (a) {
    u = { error: a };
  } finally {
    try {
      n && !n.done && (r = i.return) && r.call(i);
    } finally {
      if (u) throw u.error;
    }
  }
  return s;
}
function Hp() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t = t.concat(gc(arguments[e]));
  return t;
}
function Gp() {
  for (var t = 0, e = 0, r = arguments.length; e < r; e++) t += arguments[e].length;
  for (var i = Array(t), n = 0, e = 0; e < r; e++)
    for (var s = arguments[e], u = 0, a = s.length; u < a; u++, n++)
      i[n] = s[u];
  return i;
}
function Kr(t) {
  return this instanceof Kr ? (this.v = t, this) : new Kr(t);
}
function kp(t, e, r) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var i = r.apply(t, e || []), n, s = [];
  return n = {}, u("next"), u("throw"), u("return"), n[Symbol.asyncIterator] = function() {
    return this;
  }, n;
  function u(g) {
    i[g] && (n[g] = function(_) {
      return new Promise(function(w, T) {
        s.push([g, _, w, T]) > 1 || a(g, _);
      });
    });
  }
  function a(g, _) {
    try {
      l(i[g](_));
    } catch (w) {
      y(s[0][3], w);
    }
  }
  function l(g) {
    g.value instanceof Kr ? Promise.resolve(g.value.v).then(h, f) : y(s[0][2], g);
  }
  function h(g) {
    a("next", g);
  }
  function f(g) {
    a("throw", g);
  }
  function y(g, _) {
    g(_), s.shift(), s.length && a(s[0][0], s[0][1]);
  }
}
function Wp(t) {
  var e, r;
  return e = {}, i("next"), i("throw", function(n) {
    throw n;
  }), i("return"), e[Symbol.iterator] = function() {
    return this;
  }, e;
  function i(n, s) {
    e[n] = t[n] ? function(u) {
      return (r = !r) ? { value: Kr(t[n](u)), done: n === "return" } : s ? s(u) : u;
    } : s;
  }
}
function Yp(t) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator], r;
  return e ? e.call(t) : (t = typeof En == "function" ? En(t) : t[Symbol.iterator](), r = {}, i("next"), i("throw"), i("return"), r[Symbol.asyncIterator] = function() {
    return this;
  }, r);
  function i(s) {
    r[s] = t[s] && function(u) {
      return new Promise(function(a, l) {
        u = t[s](u), n(a, l, u.done, u.value);
      });
    };
  }
  function n(s, u, a, l) {
    Promise.resolve(l).then(function(h) {
      s({ value: h, done: a });
    }, u);
  }
}
function Jp(t, e) {
  return Object.defineProperty ? Object.defineProperty(t, "raw", { value: e }) : t.raw = e, t;
}
function Xp(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
  return e.default = t, e;
}
function Qp(t) {
  return t && t.__esModule ? t : { default: t };
}
function Zp(t, e) {
  if (!e.has(t))
    throw new TypeError("attempted to get private field on non-instance");
  return e.get(t);
}
function eg(t, e, r) {
  if (!e.has(t))
    throw new TypeError("attempted to set private field on non-instance");
  return e.set(t, r), r;
}
const tg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return vn;
  },
  __asyncDelegator: Wp,
  __asyncGenerator: kp,
  __asyncValues: Yp,
  __await: Kr,
  __awaiter: Bp,
  __classPrivateFieldGet: Zp,
  __classPrivateFieldSet: eg,
  __createBinding: Kp,
  __decorate: Mp,
  __exportStar: Vp,
  __extends: Up,
  __generator: zp,
  __importDefault: Qp,
  __importStar: Xp,
  __makeTemplateObject: Jp,
  __metadata: qp,
  __param: jp,
  __read: gc,
  __rest: Lp,
  __spread: Hp,
  __spreadArrays: Gp,
  __values: En
}, Symbol.toStringTag, { value: "Module" })), rg = /* @__PURE__ */ nr(tg);
var Ct = {}, Zs;
function ig() {
  if (Zs) return Ct;
  Zs = 1, Object.defineProperty(Ct, "__esModule", { value: !0 }), Ct.isBrowserCryptoAvailable = Ct.getSubtleCrypto = Ct.getBrowerCrypto = void 0;
  function t() {
    return (Tt === null || Tt === void 0 ? void 0 : Tt.crypto) || (Tt === null || Tt === void 0 ? void 0 : Tt.msCrypto) || {};
  }
  Ct.getBrowerCrypto = t;
  function e() {
    const i = t();
    return i.subtle || i.webkitSubtle;
  }
  Ct.getSubtleCrypto = e;
  function r() {
    return !!t() && !!e();
  }
  return Ct.isBrowserCryptoAvailable = r, Ct;
}
var Ft = {}, eo;
function ng() {
  if (eo) return Ft;
  eo = 1, Object.defineProperty(Ft, "__esModule", { value: !0 }), Ft.isBrowser = Ft.isNode = Ft.isReactNative = void 0;
  function t() {
    return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative";
  }
  Ft.isReactNative = t;
  function e() {
    return typeof xt < "u" && typeof xt.versions < "u" && typeof xt.versions.node < "u";
  }
  Ft.isNode = e;
  function r() {
    return !t() && !e();
  }
  return Ft.isBrowser = r, Ft;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const e = rg;
  e.__exportStar(ig(), t), e.__exportStar(ng(), t);
})(pc);
function kn(t = 3) {
  const e = Date.now() * Math.pow(10, t), r = Math.floor(Math.random() * Math.pow(10, t));
  return e + r;
}
function yc(t = 6) {
  return BigInt(kn(t));
}
function gr(t, e, r) {
  return {
    id: r || kn(),
    jsonrpc: "2.0",
    method: t,
    params: e
  };
}
function Wn(t, e) {
  return {
    id: t,
    jsonrpc: "2.0",
    result: e
  };
}
function Yn(t, e, r) {
  return {
    id: t,
    jsonrpc: "2.0",
    error: sg(e)
  };
}
function sg(t, e) {
  return typeof t > "u" ? Qs(fc) : (typeof t == "string" && (t = Object.assign(Object.assign({}, Qs(Gn)), { message: t })), Cp(t.code) && (t = Fp(t.code)), t);
}
class og {
}
class ag extends og {
  constructor() {
    super();
  }
}
class cg extends ag {
  constructor(e) {
    super();
  }
}
const ug = "^https?:", hg = "^wss?:";
function lg(t) {
  const e = t.match(new RegExp(/^\w+:/, "gi"));
  if (!(!e || !e.length))
    return e[0];
}
function bc(t, e) {
  const r = lg(t);
  return typeof r > "u" ? !1 : new RegExp(e).test(r);
}
function T1(t) {
  return bc(t, ug);
}
function to(t) {
  return bc(t, hg);
}
function fg(t) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(t);
}
function _c(t) {
  return typeof t == "object" && "id" in t && "jsonrpc" in t && t.jsonrpc === "2.0";
}
function Jn(t) {
  return _c(t) && "method" in t;
}
function Oi(t) {
  return _c(t) && (Mt(t) || St(t));
}
function Mt(t) {
  return "result" in t;
}
function St(t) {
  return "error" in t;
}
class dg extends cg {
  constructor(e) {
    super(e), this.events = new Rt.EventEmitter(), this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(e), this.connection.connected && this.registerEventListeners();
  }
  async connect(e = this.connection) {
    await this.open(e);
  }
  async disconnect() {
    await this.close();
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async request(e, r) {
    return this.requestStrict(gr(e.method, e.params || [], e.id || yc().toString()), r);
  }
  async requestStrict(e, r) {
    return new Promise(async (i, n) => {
      if (!this.connection.connected)
        try {
          await this.open();
        } catch (s) {
          n(s);
        }
      this.events.on(`${e.id}`, (s) => {
        St(s) ? n(s.error) : i(s.result);
      });
      try {
        await this.connection.send(e, r);
      } catch (s) {
        n(s);
      }
    });
  }
  setConnection(e = this.connection) {
    return e;
  }
  onPayload(e) {
    this.events.emit("payload", e), Oi(e) ? this.events.emit(`${e.id}`, e) : this.events.emit("message", {
      type: e.method,
      data: e.params
    });
  }
  onClose(e) {
    e && e.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${e.code} ${e.reason ? `(${e.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(e = this.connection) {
    this.connection === e && this.connection.connected || (this.connection.connected && this.close(), typeof e == "string" && (await this.connection.open(e), e = this.connection), this.connection = this.setConnection(e), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (e) => this.onPayload(e)), this.connection.on("close", (e) => this.onClose(e)), this.connection.on("error", (e) => this.events.emit("error", e)), this.connection.on("register_error", (e) => this.onClose()), this.hasRegisteredEventListeners = !0);
  }
}
var Ki, ro;
function pg() {
  return ro || (ro = 1, Ki = function() {
    throw new Error(
      "ws does not work in the browser. Browser clients must use the native WebSocket object"
    );
  }), Ki;
}
const gg = () => typeof WebSocket < "u" ? WebSocket : typeof xe < "u" && typeof xe.WebSocket < "u" ? xe.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : pg(), yg = () => typeof WebSocket < "u" || typeof xe < "u" && typeof xe.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u", io = (t) => t.split("?")[0], no = 10, bg = gg();
class _g {
  constructor(e) {
    if (this.url = e, this.events = new Rt.EventEmitter(), this.registering = !1, !to(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    this.url = e;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    return new Promise((e, r) => {
      if (typeof this.socket > "u") {
        r(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (i) => {
        this.onClose(i), e();
      }, this.socket.close();
    });
  }
  async send(e) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(Gr(e));
    } catch (r) {
      this.onError(e.id, r);
    }
  }
  register(e = this.url) {
    if (!to(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    if (this.registering) {
      const r = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= r || this.events.listenerCount("open") >= r) && this.events.setMaxListeners(r + 1), new Promise((i, n) => {
        this.events.once("register_error", (s) => {
          this.resetMaxListeners(), n(s);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u") return n(new Error("WebSocket connection is missing or invalid"));
          i(this.socket);
        });
      });
    }
    return this.url = e, this.registering = !0, new Promise((r, i) => {
      const n = new URLSearchParams(e).get("origin"), s = pc.isReactNative() ? { headers: { origin: n } } : { rejectUnauthorized: !fg(e) }, u = new bg(e, [], s);
      yg() ? u.onerror = (a) => {
        const l = a;
        i(this.emitError(l.error));
      } : u.on("error", (a) => {
        i(this.emitError(a));
      }), u.onopen = () => {
        this.onOpen(u), r(u);
      };
    });
  }
  onOpen(e) {
    e.onmessage = (r) => this.onPayload(r), e.onclose = (r) => this.onClose(r), this.socket = e, this.registering = !1, this.events.emit("open");
  }
  onClose(e) {
    this.socket = void 0, this.registering = !1, this.events.emit("close", e);
  }
  onPayload(e) {
    if (typeof e.data > "u") return;
    const r = typeof e.data == "string" ? Ei(e.data) : e.data;
    this.events.emit("payload", r);
  }
  onError(e, r) {
    const i = this.parseError(r), n = i.message || i.toString(), s = Yn(e, n);
    this.events.emit("payload", s);
  }
  parseError(e, r = this.url) {
    return $p(e, io(r), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > no && this.events.setMaxListeners(no);
  }
  emitError(e) {
    const r = this.parseError(new Error((e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${io(this.url)}`));
    return this.events.emit("register_error", r), r;
  }
}
var pi = { exports: {} };
pi.exports;
(function(t, e) {
  var r = 200, i = "__lodash_hash_undefined__", n = 1, s = 2, u = 9007199254740991, a = "[object Arguments]", l = "[object Array]", h = "[object AsyncFunction]", f = "[object Boolean]", y = "[object Date]", g = "[object Error]", _ = "[object Function]", w = "[object GeneratorFunction]", T = "[object Map]", A = "[object Number]", j = "[object Null]", D = "[object Object]", O = "[object Promise]", m = "[object Proxy]", E = "[object RegExp]", p = "[object Set]", o = "[object String]", d = "[object Symbol]", C = "[object Undefined]", F = "[object WeakMap]", K = "[object ArrayBuffer]", G = "[object DataView]", X = "[object Float32Array]", x = "[object Float64Array]", N = "[object Int8Array]", k = "[object Int16Array]", q = "[object Int32Array]", U = "[object Uint8Array]", M = "[object Uint8ClampedArray]", $ = "[object Uint16Array]", B = "[object Uint32Array]", te = /[\\^$.*+?()[\]{}|]/g, z = /^\[object .+?Constructor\]$/, Z = /^(?:0|[1-9]\d*)$/, Y = {};
  Y[X] = Y[x] = Y[N] = Y[k] = Y[q] = Y[U] = Y[M] = Y[$] = Y[B] = !0, Y[a] = Y[l] = Y[K] = Y[f] = Y[G] = Y[y] = Y[g] = Y[_] = Y[T] = Y[A] = Y[D] = Y[E] = Y[p] = Y[o] = Y[F] = !1;
  var ee = typeof Tt == "object" && Tt && Tt.Object === Object && Tt, R = typeof self == "object" && self && self.Object === Object && self, P = ee || R || Function("return this")(), S = e && !e.nodeType && e, c = S && !0 && t && !t.nodeType && t, v = c && c.exports === S, V = v && ee.process, W = function() {
    try {
      return V && V.binding && V.binding("util");
    } catch {
    }
  }(), le = W && W.isTypedArray;
  function _e(b, I) {
    for (var L = -1, J = b == null ? 0 : b.length, Oe = 0, se = []; ++L < J; ) {
      var Ce = b[L];
      I(Ce, L, b) && (se[Oe++] = Ce);
    }
    return se;
  }
  function de(b, I) {
    for (var L = -1, J = I.length, Oe = b.length; ++L < J; )
      b[Oe + L] = I[L];
    return b;
  }
  function ve(b, I) {
    for (var L = -1, J = b == null ? 0 : b.length; ++L < J; )
      if (I(b[L], L, b))
        return !0;
    return !1;
  }
  function Ue(b, I) {
    for (var L = -1, J = Array(b); ++L < b; )
      J[L] = I(L);
    return J;
  }
  function Re(b) {
    return function(I) {
      return b(I);
    };
  }
  function ye(b, I) {
    return b.has(I);
  }
  function pe(b, I) {
    return b == null ? void 0 : b[I];
  }
  function fe(b) {
    var I = -1, L = Array(b.size);
    return b.forEach(function(J, Oe) {
      L[++I] = [Oe, J];
    }), L;
  }
  function ue(b, I) {
    return function(L) {
      return b(I(L));
    };
  }
  function ce(b) {
    var I = -1, L = Array(b.size);
    return b.forEach(function(J) {
      L[++I] = J;
    }), L;
  }
  var ae = Array.prototype, oe = Function.prototype, re = Object.prototype, he = P["__core-js_shared__"], ge = oe.toString, ie = re.hasOwnProperty, me = function() {
    var b = /[^.]+$/.exec(he && he.keys && he.keys.IE_PROTO || "");
    return b ? "Symbol(src)_1." + b : "";
  }(), we = re.toString, De = RegExp(
    "^" + ge.call(ie).replace(te, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), Se = v ? P.Buffer : void 0, Ee = P.Symbol, vt = P.Uint8Array, It = re.propertyIsEnumerable, qt = ae.splice, gt = Ee ? Ee.toStringTag : void 0, Wt = Object.getOwnPropertySymbols, Dr = Se ? Se.isBuffer : void 0, Yr = ue(Object.keys, Object), Le = lr(P, "DataView"), Ne = lr(P, "Map"), Me = lr(P, "Promise"), je = lr(P, "Set"), qe = lr(P, "WeakMap"), Ae = lr(Object, "create"), Ve = Jt(Le), He = Jt(Ne), Ge = Jt(Me), ke = Jt(je), We = Jt(qe), ze = Ee ? Ee.prototype : void 0, Be = ze ? ze.valueOf : void 0;
  function Pe(b) {
    var I = -1, L = b == null ? 0 : b.length;
    for (this.clear(); ++I < L; ) {
      var J = b[I];
      this.set(J[0], J[1]);
    }
  }
  function Ye() {
    this.__data__ = Ae ? Ae(null) : {}, this.size = 0;
  }
  function Je(b) {
    var I = this.has(b) && delete this.__data__[b];
    return this.size -= I ? 1 : 0, I;
  }
  function Lc(b) {
    var I = this.__data__;
    if (Ae) {
      var L = I[b];
      return L === i ? void 0 : L;
    }
    return ie.call(I, b) ? I[b] : void 0;
  }
  function Mc(b) {
    var I = this.__data__;
    return Ae ? I[b] !== void 0 : ie.call(I, b);
  }
  function jc(b, I) {
    var L = this.__data__;
    return this.size += this.has(b) ? 0 : 1, L[b] = Ae && I === void 0 ? i : I, this;
  }
  Pe.prototype.clear = Ye, Pe.prototype.delete = Je, Pe.prototype.get = Lc, Pe.prototype.has = Mc, Pe.prototype.set = jc;
  function Nt(b) {
    var I = -1, L = b == null ? 0 : b.length;
    for (this.clear(); ++I < L; ) {
      var J = b[I];
      this.set(J[0], J[1]);
    }
  }
  function qc() {
    this.__data__ = [], this.size = 0;
  }
  function Bc(b) {
    var I = this.__data__, L = Xr(I, b);
    if (L < 0)
      return !1;
    var J = I.length - 1;
    return L == J ? I.pop() : qt.call(I, L, 1), --this.size, !0;
  }
  function zc(b) {
    var I = this.__data__, L = Xr(I, b);
    return L < 0 ? void 0 : I[L][1];
  }
  function Kc(b) {
    return Xr(this.__data__, b) > -1;
  }
  function Vc(b, I) {
    var L = this.__data__, J = Xr(L, b);
    return J < 0 ? (++this.size, L.push([b, I])) : L[J][1] = I, this;
  }
  Nt.prototype.clear = qc, Nt.prototype.delete = Bc, Nt.prototype.get = zc, Nt.prototype.has = Kc, Nt.prototype.set = Vc;
  function Yt(b) {
    var I = -1, L = b == null ? 0 : b.length;
    for (this.clear(); ++I < L; ) {
      var J = b[I];
      this.set(J[0], J[1]);
    }
  }
  function Hc() {
    this.size = 0, this.__data__ = {
      hash: new Pe(),
      map: new (Ne || Nt)(),
      string: new Pe()
    };
  }
  function Gc(b) {
    var I = Qr(this, b).delete(b);
    return this.size -= I ? 1 : 0, I;
  }
  function kc(b) {
    return Qr(this, b).get(b);
  }
  function Wc(b) {
    return Qr(this, b).has(b);
  }
  function Yc(b, I) {
    var L = Qr(this, b), J = L.size;
    return L.set(b, I), this.size += L.size == J ? 0 : 1, this;
  }
  Yt.prototype.clear = Hc, Yt.prototype.delete = Gc, Yt.prototype.get = kc, Yt.prototype.has = Wc, Yt.prototype.set = Yc;
  function Jr(b) {
    var I = -1, L = b == null ? 0 : b.length;
    for (this.__data__ = new Yt(); ++I < L; )
      this.add(b[I]);
  }
  function Jc(b) {
    return this.__data__.set(b, i), this;
  }
  function Xc(b) {
    return this.__data__.has(b);
  }
  Jr.prototype.add = Jr.prototype.push = Jc, Jr.prototype.has = Xc;
  function Bt(b) {
    var I = this.__data__ = new Nt(b);
    this.size = I.size;
  }
  function Qc() {
    this.__data__ = new Nt(), this.size = 0;
  }
  function Zc(b) {
    var I = this.__data__, L = I.delete(b);
    return this.size = I.size, L;
  }
  function eu(b) {
    return this.__data__.get(b);
  }
  function tu(b) {
    return this.__data__.has(b);
  }
  function ru(b, I) {
    var L = this.__data__;
    if (L instanceof Nt) {
      var J = L.__data__;
      if (!Ne || J.length < r - 1)
        return J.push([b, I]), this.size = ++L.size, this;
      L = this.__data__ = new Yt(J);
    }
    return L.set(b, I), this.size = L.size, this;
  }
  Bt.prototype.clear = Qc, Bt.prototype.delete = Zc, Bt.prototype.get = eu, Bt.prototype.has = tu, Bt.prototype.set = ru;
  function iu(b, I) {
    var L = Zr(b), J = !L && _u(b), Oe = !L && !J && Ri(b), se = !L && !J && !Oe && cs(b), Ce = L || J || Oe || se, Xe = Ce ? Ue(b.length, String) : [], Ze = Xe.length;
    for (var Te in b)
      ie.call(b, Te) && !(Ce && // Safari 9 has enumerable `arguments.length` in strict mode.
      (Te == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      Oe && (Te == "offset" || Te == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      se && (Te == "buffer" || Te == "byteLength" || Te == "byteOffset") || // Skip index properties.
      du(Te, Ze))) && Xe.push(Te);
    return Xe;
  }
  function Xr(b, I) {
    for (var L = b.length; L--; )
      if (ns(b[L][0], I))
        return L;
    return -1;
  }
  function nu(b, I, L) {
    var J = I(b);
    return Zr(b) ? J : de(J, L(b));
  }
  function Sr(b) {
    return b == null ? b === void 0 ? C : j : gt && gt in Object(b) ? lu(b) : bu(b);
  }
  function es(b) {
    return xr(b) && Sr(b) == a;
  }
  function ts(b, I, L, J, Oe) {
    return b === I ? !0 : b == null || I == null || !xr(b) && !xr(I) ? b !== b && I !== I : su(b, I, L, J, ts, Oe);
  }
  function su(b, I, L, J, Oe, se) {
    var Ce = Zr(b), Xe = Zr(I), Ze = Ce ? l : zt(b), Te = Xe ? l : zt(I);
    Ze = Ze == a ? D : Ze, Te = Te == a ? D : Te;
    var yt = Ze == D, Et = Te == D, rt = Ze == Te;
    if (rt && Ri(b)) {
      if (!Ri(I))
        return !1;
      Ce = !0, yt = !1;
    }
    if (rt && !yt)
      return se || (se = new Bt()), Ce || cs(b) ? rs(b, I, L, J, Oe, se) : uu(b, I, Ze, L, J, Oe, se);
    if (!(L & n)) {
      var _t = yt && ie.call(b, "__wrapped__"), mt = Et && ie.call(I, "__wrapped__");
      if (_t || mt) {
        var Kt = _t ? b.value() : b, At = mt ? I.value() : I;
        return se || (se = new Bt()), Oe(Kt, At, L, J, se);
      }
    }
    return rt ? (se || (se = new Bt()), hu(b, I, L, J, Oe, se)) : !1;
  }
  function ou(b) {
    if (!as(b) || gu(b))
      return !1;
    var I = ss(b) ? De : z;
    return I.test(Jt(b));
  }
  function au(b) {
    return xr(b) && os(b.length) && !!Y[Sr(b)];
  }
  function cu(b) {
    if (!yu(b))
      return Yr(b);
    var I = [];
    for (var L in Object(b))
      ie.call(b, L) && L != "constructor" && I.push(L);
    return I;
  }
  function rs(b, I, L, J, Oe, se) {
    var Ce = L & n, Xe = b.length, Ze = I.length;
    if (Xe != Ze && !(Ce && Ze > Xe))
      return !1;
    var Te = se.get(b);
    if (Te && se.get(I))
      return Te == I;
    var yt = -1, Et = !0, rt = L & s ? new Jr() : void 0;
    for (se.set(b, I), se.set(I, b); ++yt < Xe; ) {
      var _t = b[yt], mt = I[yt];
      if (J)
        var Kt = Ce ? J(mt, _t, yt, I, b, se) : J(_t, mt, yt, b, I, se);
      if (Kt !== void 0) {
        if (Kt)
          continue;
        Et = !1;
        break;
      }
      if (rt) {
        if (!ve(I, function(At, Xt) {
          if (!ye(rt, Xt) && (_t === At || Oe(_t, At, L, J, se)))
            return rt.push(Xt);
        })) {
          Et = !1;
          break;
        }
      } else if (!(_t === mt || Oe(_t, mt, L, J, se))) {
        Et = !1;
        break;
      }
    }
    return se.delete(b), se.delete(I), Et;
  }
  function uu(b, I, L, J, Oe, se, Ce) {
    switch (L) {
      case G:
        if (b.byteLength != I.byteLength || b.byteOffset != I.byteOffset)
          return !1;
        b = b.buffer, I = I.buffer;
      case K:
        return !(b.byteLength != I.byteLength || !se(new vt(b), new vt(I)));
      case f:
      case y:
      case A:
        return ns(+b, +I);
      case g:
        return b.name == I.name && b.message == I.message;
      case E:
      case o:
        return b == I + "";
      case T:
        var Xe = fe;
      case p:
        var Ze = J & n;
        if (Xe || (Xe = ce), b.size != I.size && !Ze)
          return !1;
        var Te = Ce.get(b);
        if (Te)
          return Te == I;
        J |= s, Ce.set(b, I);
        var yt = rs(Xe(b), Xe(I), J, Oe, se, Ce);
        return Ce.delete(b), yt;
      case d:
        if (Be)
          return Be.call(b) == Be.call(I);
    }
    return !1;
  }
  function hu(b, I, L, J, Oe, se) {
    var Ce = L & n, Xe = is(b), Ze = Xe.length, Te = is(I), yt = Te.length;
    if (Ze != yt && !Ce)
      return !1;
    for (var Et = Ze; Et--; ) {
      var rt = Xe[Et];
      if (!(Ce ? rt in I : ie.call(I, rt)))
        return !1;
    }
    var _t = se.get(b);
    if (_t && se.get(I))
      return _t == I;
    var mt = !0;
    se.set(b, I), se.set(I, b);
    for (var Kt = Ce; ++Et < Ze; ) {
      rt = Xe[Et];
      var At = b[rt], Xt = I[rt];
      if (J)
        var us = Ce ? J(Xt, At, rt, I, b, se) : J(At, Xt, rt, b, I, se);
      if (!(us === void 0 ? At === Xt || Oe(At, Xt, L, J, se) : us)) {
        mt = !1;
        break;
      }
      Kt || (Kt = rt == "constructor");
    }
    if (mt && !Kt) {
      var ei = b.constructor, ti = I.constructor;
      ei != ti && "constructor" in b && "constructor" in I && !(typeof ei == "function" && ei instanceof ei && typeof ti == "function" && ti instanceof ti) && (mt = !1);
    }
    return se.delete(b), se.delete(I), mt;
  }
  function is(b) {
    return nu(b, vu, fu);
  }
  function Qr(b, I) {
    var L = b.__data__;
    return pu(I) ? L[typeof I == "string" ? "string" : "hash"] : L.map;
  }
  function lr(b, I) {
    var L = pe(b, I);
    return ou(L) ? L : void 0;
  }
  function lu(b) {
    var I = ie.call(b, gt), L = b[gt];
    try {
      b[gt] = void 0;
      var J = !0;
    } catch {
    }
    var Oe = we.call(b);
    return J && (I ? b[gt] = L : delete b[gt]), Oe;
  }
  var fu = Wt ? function(b) {
    return b == null ? [] : (b = Object(b), _e(Wt(b), function(I) {
      return It.call(b, I);
    }));
  } : Eu, zt = Sr;
  (Le && zt(new Le(new ArrayBuffer(1))) != G || Ne && zt(new Ne()) != T || Me && zt(Me.resolve()) != O || je && zt(new je()) != p || qe && zt(new qe()) != F) && (zt = function(b) {
    var I = Sr(b), L = I == D ? b.constructor : void 0, J = L ? Jt(L) : "";
    if (J)
      switch (J) {
        case Ve:
          return G;
        case He:
          return T;
        case Ge:
          return O;
        case ke:
          return p;
        case We:
          return F;
      }
    return I;
  });
  function du(b, I) {
    return I = I ?? u, !!I && (typeof b == "number" || Z.test(b)) && b > -1 && b % 1 == 0 && b < I;
  }
  function pu(b) {
    var I = typeof b;
    return I == "string" || I == "number" || I == "symbol" || I == "boolean" ? b !== "__proto__" : b === null;
  }
  function gu(b) {
    return !!me && me in b;
  }
  function yu(b) {
    var I = b && b.constructor, L = typeof I == "function" && I.prototype || re;
    return b === L;
  }
  function bu(b) {
    return we.call(b);
  }
  function Jt(b) {
    if (b != null) {
      try {
        return ge.call(b);
      } catch {
      }
      try {
        return b + "";
      } catch {
      }
    }
    return "";
  }
  function ns(b, I) {
    return b === I || b !== b && I !== I;
  }
  var _u = es(/* @__PURE__ */ function() {
    return arguments;
  }()) ? es : function(b) {
    return xr(b) && ie.call(b, "callee") && !It.call(b, "callee");
  }, Zr = Array.isArray;
  function mu(b) {
    return b != null && os(b.length) && !ss(b);
  }
  var Ri = Dr || Du;
  function wu(b, I) {
    return ts(b, I);
  }
  function ss(b) {
    if (!as(b))
      return !1;
    var I = Sr(b);
    return I == _ || I == w || I == h || I == m;
  }
  function os(b) {
    return typeof b == "number" && b > -1 && b % 1 == 0 && b <= u;
  }
  function as(b) {
    var I = typeof b;
    return b != null && (I == "object" || I == "function");
  }
  function xr(b) {
    return b != null && typeof b == "object";
  }
  var cs = le ? Re(le) : au;
  function vu(b) {
    return mu(b) ? iu(b) : cu(b);
  }
  function Eu() {
    return [];
  }
  function Du() {
    return !1;
  }
  t.exports = wu;
})(pi, pi.exports);
var mg = pi.exports;
const wg = /* @__PURE__ */ Po(mg);
function vg(t, e) {
  return e = e || {}, new Promise(function(r, i) {
    var n = new XMLHttpRequest(), s = [], u = [], a = {}, l = function() {
      return { ok: (n.status / 100 | 0) == 2, statusText: n.statusText, status: n.status, url: n.responseURL, text: function() {
        return Promise.resolve(n.responseText);
      }, json: function() {
        return Promise.resolve(n.responseText).then(JSON.parse);
      }, blob: function() {
        return Promise.resolve(new Blob([n.response]));
      }, clone: l, headers: { keys: function() {
        return s;
      }, entries: function() {
        return u;
      }, get: function(f) {
        return a[f.toLowerCase()];
      }, has: function(f) {
        return f.toLowerCase() in a;
      } } };
    };
    for (var h in n.open(e.method || "get", t, !0), n.onload = function() {
      n.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(f, y, g) {
        s.push(y = y.toLowerCase()), u.push([y, g]), a[y] = a[y] ? a[y] + "," + g : g;
      }), r(l());
    }, n.onerror = i, n.withCredentials = e.credentials == "include", e.headers) n.setRequestHeader(h, e.headers[h]);
    n.send(e.body || null);
  });
}
const Eg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: vg
}, Symbol.toStringTag, { value: "Module" })), so = /* @__PURE__ */ nr(Eg);
var Dg = self.fetch || (self.fetch = so.default || so);
const Sg = /* @__PURE__ */ Po(Dg);
function xg(t, e) {
  if (t.length >= 255) throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), i = 0; i < r.length; i++) r[i] = 255;
  for (var n = 0; n < t.length; n++) {
    var s = t.charAt(n), u = s.charCodeAt(0);
    if (r[u] !== 255) throw new TypeError(s + " is ambiguous");
    r[u] = n;
  }
  var a = t.length, l = t.charAt(0), h = Math.log(a) / Math.log(256), f = Math.log(256) / Math.log(a);
  function y(w) {
    if (w instanceof Uint8Array || (ArrayBuffer.isView(w) ? w = new Uint8Array(w.buffer, w.byteOffset, w.byteLength) : Array.isArray(w) && (w = Uint8Array.from(w))), !(w instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (w.length === 0) return "";
    for (var T = 0, A = 0, j = 0, D = w.length; j !== D && w[j] === 0; ) j++, T++;
    for (var O = (D - j) * f + 1 >>> 0, m = new Uint8Array(O); j !== D; ) {
      for (var E = w[j], p = 0, o = O - 1; (E !== 0 || p < A) && o !== -1; o--, p++) E += 256 * m[o] >>> 0, m[o] = E % a >>> 0, E = E / a >>> 0;
      if (E !== 0) throw new Error("Non-zero carry");
      A = p, j++;
    }
    for (var d = O - A; d !== O && m[d] === 0; ) d++;
    for (var C = l.repeat(T); d < O; ++d) C += t.charAt(m[d]);
    return C;
  }
  function g(w) {
    if (typeof w != "string") throw new TypeError("Expected String");
    if (w.length === 0) return new Uint8Array();
    var T = 0;
    if (w[T] !== " ") {
      for (var A = 0, j = 0; w[T] === l; ) A++, T++;
      for (var D = (w.length - T) * h + 1 >>> 0, O = new Uint8Array(D); w[T]; ) {
        var m = r[w.charCodeAt(T)];
        if (m === 255) return;
        for (var E = 0, p = D - 1; (m !== 0 || E < j) && p !== -1; p--, E++) m += a * O[p] >>> 0, O[p] = m % 256 >>> 0, m = m / 256 >>> 0;
        if (m !== 0) throw new Error("Non-zero carry");
        j = E, T++;
      }
      if (w[T] !== " ") {
        for (var o = D - j; o !== D && O[o] === 0; ) o++;
        for (var d = new Uint8Array(A + (D - o)), C = A; o !== D; ) d[C++] = O[o++];
        return d;
      }
    }
  }
  function _(w) {
    var T = g(w);
    if (T) return T;
    throw new Error(`Non-${e} character`);
  }
  return { encode: y, decodeUnsafe: g, decode: _ };
}
var Ig = xg, Og = Ig;
const mc = (t) => {
  if (t instanceof Uint8Array && t.constructor.name === "Uint8Array") return t;
  if (t instanceof ArrayBuffer) return new Uint8Array(t);
  if (ArrayBuffer.isView(t)) return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Unknown type, must be binary type");
}, Pg = (t) => new TextEncoder().encode(t), Tg = (t) => new TextDecoder().decode(t);
class Rg {
  constructor(e, r, i) {
    this.name = e, this.prefix = r, this.baseEncode = i;
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class Ng {
  constructor(e, r, i) {
    if (this.name = e, this.prefix = r, r.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = r.codePointAt(0), this.baseDecode = i;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return wc(this, e);
  }
}
class Ag {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return wc(this, e);
  }
  decode(e) {
    const r = e[0], i = this.decoders[r];
    if (i) return i.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const wc = (t, e) => new Ag({ ...t.decoders || { [t.prefix]: t }, ...e.decoders || { [e.prefix]: e } });
class Cg {
  constructor(e, r, i, n) {
    this.name = e, this.prefix = r, this.baseEncode = i, this.baseDecode = n, this.encoder = new Rg(e, r, i), this.decoder = new Ng(e, r, n);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const Pi = ({ name: t, prefix: e, encode: r, decode: i }) => new Cg(t, e, r, i), Wr = ({ prefix: t, name: e, alphabet: r }) => {
  const { encode: i, decode: n } = Og(r, e);
  return Pi({ prefix: t, name: e, encode: i, decode: (s) => mc(n(s)) });
}, Fg = (t, e, r, i) => {
  const n = {};
  for (let f = 0; f < e.length; ++f) n[e[f]] = f;
  let s = t.length;
  for (; t[s - 1] === "="; ) --s;
  const u = new Uint8Array(s * r / 8 | 0);
  let a = 0, l = 0, h = 0;
  for (let f = 0; f < s; ++f) {
    const y = n[t[f]];
    if (y === void 0) throw new SyntaxError(`Non-${i} character`);
    l = l << r | y, a += r, a >= 8 && (a -= 8, u[h++] = 255 & l >> a);
  }
  if (a >= r || 255 & l << 8 - a) throw new SyntaxError("Unexpected end of data");
  return u;
}, $g = (t, e, r) => {
  const i = e[e.length - 1] === "=", n = (1 << r) - 1;
  let s = "", u = 0, a = 0;
  for (let l = 0; l < t.length; ++l) for (a = a << 8 | t[l], u += 8; u > r; ) u -= r, s += e[n & a >> u];
  if (u && (s += e[n & a << r - u]), i) for (; s.length * r & 7; ) s += "=";
  return s;
}, tt = ({ name: t, prefix: e, bitsPerChar: r, alphabet: i }) => Pi({ prefix: e, name: t, encode(n) {
  return $g(n, i, r);
}, decode(n) {
  return Fg(n, i, r, t);
} }), Ug = Pi({ prefix: "\0", name: "identity", encode: (t) => Tg(t), decode: (t) => Pg(t) });
var Lg = Object.freeze({ __proto__: null, identity: Ug });
const Mg = tt({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var jg = Object.freeze({ __proto__: null, base2: Mg });
const qg = tt({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var Bg = Object.freeze({ __proto__: null, base8: qg });
const zg = Wr({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Kg = Object.freeze({ __proto__: null, base10: zg });
const Vg = tt({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), Hg = tt({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Gg = Object.freeze({ __proto__: null, base16: Vg, base16upper: Hg });
const kg = tt({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), Wg = tt({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), Yg = tt({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), Jg = tt({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), Xg = tt({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), Qg = tt({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), Zg = tt({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), ey = tt({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), ty = tt({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var ry = Object.freeze({ __proto__: null, base32: kg, base32upper: Wg, base32pad: Yg, base32padupper: Jg, base32hex: Xg, base32hexupper: Qg, base32hexpad: Zg, base32hexpadupper: ey, base32z: ty });
const iy = Wr({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), ny = Wr({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var sy = Object.freeze({ __proto__: null, base36: iy, base36upper: ny });
const oy = Wr({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), ay = Wr({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var cy = Object.freeze({ __proto__: null, base58btc: oy, base58flickr: ay });
const uy = tt({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), hy = tt({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), ly = tt({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), fy = tt({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var dy = Object.freeze({ __proto__: null, base64: uy, base64pad: hy, base64url: ly, base64urlpad: fy });
const vc = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"), py = vc.reduce((t, e, r) => (t[r] = e, t), []), gy = vc.reduce((t, e, r) => (t[e.codePointAt(0)] = r, t), []);
function yy(t) {
  return t.reduce((e, r) => (e += py[r], e), "");
}
function by(t) {
  const e = [];
  for (const r of t) {
    const i = gy[r.codePointAt(0)];
    if (i === void 0) throw new Error(`Non-base256emoji character: ${r}`);
    e.push(i);
  }
  return new Uint8Array(e);
}
const _y = Pi({ prefix: "🚀", name: "base256emoji", encode: yy, decode: by });
var my = Object.freeze({ __proto__: null, base256emoji: _y }), wy = Ec, oo = 128, vy = 127, Ey = ~vy, Dy = Math.pow(2, 31);
function Ec(t, e, r) {
  e = e || [], r = r || 0;
  for (var i = r; t >= Dy; ) e[r++] = t & 255 | oo, t /= 128;
  for (; t & Ey; ) e[r++] = t & 255 | oo, t >>>= 7;
  return e[r] = t | 0, Ec.bytes = r - i + 1, e;
}
var Sy = Dn, xy = 128, ao = 127;
function Dn(t, i) {
  var r = 0, i = i || 0, n = 0, s = i, u, a = t.length;
  do {
    if (s >= a) throw Dn.bytes = 0, new RangeError("Could not decode varint");
    u = t[s++], r += n < 28 ? (u & ao) << n : (u & ao) * Math.pow(2, n), n += 7;
  } while (u >= xy);
  return Dn.bytes = s - i, r;
}
var Iy = Math.pow(2, 7), Oy = Math.pow(2, 14), Py = Math.pow(2, 21), Ty = Math.pow(2, 28), Ry = Math.pow(2, 35), Ny = Math.pow(2, 42), Ay = Math.pow(2, 49), Cy = Math.pow(2, 56), Fy = Math.pow(2, 63), $y = function(t) {
  return t < Iy ? 1 : t < Oy ? 2 : t < Py ? 3 : t < Ty ? 4 : t < Ry ? 5 : t < Ny ? 6 : t < Ay ? 7 : t < Cy ? 8 : t < Fy ? 9 : 10;
}, Uy = { encode: wy, decode: Sy, encodingLength: $y }, Dc = Uy;
const co = (t, e, r = 0) => (Dc.encode(t, e, r), e), uo = (t) => Dc.encodingLength(t), Sn = (t, e) => {
  const r = e.byteLength, i = uo(t), n = i + uo(r), s = new Uint8Array(n + r);
  return co(t, s, 0), co(r, s, i), s.set(e, n), new Ly(t, r, e, s);
};
class Ly {
  constructor(e, r, i, n) {
    this.code = e, this.size = r, this.digest = i, this.bytes = n;
  }
}
const Sc = ({ name: t, code: e, encode: r }) => new My(t, e, r);
class My {
  constructor(e, r, i) {
    this.name = e, this.code = r, this.encode = i;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const r = this.encode(e);
      return r instanceof Uint8Array ? Sn(this.code, r) : r.then((i) => Sn(this.code, i));
    } else throw Error("Unknown type, must be binary type");
  }
}
const xc = (t) => async (e) => new Uint8Array(await crypto.subtle.digest(t, e)), jy = Sc({ name: "sha2-256", code: 18, encode: xc("SHA-256") }), qy = Sc({ name: "sha2-512", code: 19, encode: xc("SHA-512") });
var By = Object.freeze({ __proto__: null, sha256: jy, sha512: qy });
const Ic = 0, zy = "identity", Oc = mc, Ky = (t) => Sn(Ic, Oc(t)), Vy = { code: Ic, name: zy, encode: Oc, digest: Ky };
var Hy = Object.freeze({ __proto__: null, identity: Vy });
new TextEncoder(), new TextDecoder();
const ho = { ...Lg, ...jg, ...Bg, ...Kg, ...Gg, ...ry, ...sy, ...cy, ...dy, ...my };
({ ...By, ...Hy });
function Pc(t) {
  return globalThis.Buffer != null ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t;
}
function Gy(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Pc(globalThis.Buffer.allocUnsafe(t)) : new Uint8Array(t);
}
function Tc(t, e, r, i) {
  return { name: t, prefix: e, encoder: { name: t, prefix: e, encode: r }, decoder: { decode: i } };
}
const lo = Tc("utf8", "u", (t) => "u" + new TextDecoder("utf8").decode(t), (t) => new TextEncoder().encode(t.substring(1))), Vi = Tc("ascii", "a", (t) => {
  let e = "a";
  for (let r = 0; r < t.length; r++) e += String.fromCharCode(t[r]);
  return e;
}, (t) => {
  t = t.substring(1);
  const e = Gy(t.length);
  for (let r = 0; r < t.length; r++) e[r] = t.charCodeAt(r);
  return e;
}), ky = { utf8: lo, "utf-8": lo, hex: ho.base16, latin1: Vi, ascii: Vi, binary: Vi, ...ho };
function Wy(t, e = "utf8") {
  const r = ky[e];
  if (!r) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Pc(globalThis.Buffer.from(t, "utf-8")) : r.decoder.decode(`${r.prefix}${t}`);
}
const Rc = "wc", Yy = 2, Xn = "core", Ht = `${Rc}@2:${Xn}:`, Jy = { name: Xn, logger: "error" }, Xy = { database: ":memory:" }, Qy = "crypto", fo = "client_ed25519_seed", Zy = Q.ONE_DAY, e0 = "keychain", t0 = "0.3", r0 = "messages", i0 = "0.3", n0 = Q.SIX_HOURS, s0 = "publisher", Nc = "irn", o0 = "error", Ac = "wss://relay.walletconnect.com", po = "wss://relay.walletconnect.org", a0 = "relayer", nt = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" }, c0 = "_subscription", $t = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" }, u0 = Q.ONE_SECOND, h0 = "2.11.2", l0 = 1e4, f0 = "0.3", d0 = "WALLETCONNECT_CLIENT_ID", Dt = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" }, p0 = "subscription", g0 = "0.3", y0 = Q.FIVE_SECONDS * 1e3, b0 = "pairing", _0 = "0.3", Rr = { wc_pairingDelete: { req: { ttl: Q.ONE_DAY, prompt: !1, tag: 1e3 }, res: { ttl: Q.ONE_DAY, prompt: !1, tag: 1001 } }, wc_pairingPing: { req: { ttl: Q.THIRTY_SECONDS, prompt: !1, tag: 1002 }, res: { ttl: Q.THIRTY_SECONDS, prompt: !1, tag: 1003 } }, unregistered_method: { req: { ttl: Q.ONE_DAY, prompt: !1, tag: 0 }, res: { ttl: Q.ONE_DAY, prompt: !1, tag: 0 } } }, Cr = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" }, Pt = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" }, m0 = "history", w0 = "0.3", v0 = "expirer", wt = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" }, E0 = "0.3", Hi = "verify-api", pr = "https://verify.walletconnect.com", xn = "https://verify.walletconnect.org", D0 = [pr, xn], S0 = "echo", x0 = "https://echo.walletconnect.com";
class I0 {
  constructor(e, r) {
    this.core = e, this.logger = r, this.keychain = /* @__PURE__ */ new Map(), this.name = e0, this.version = t0, this.initialized = !1, this.storagePrefix = Ht, this.init = async () => {
      if (!this.initialized) {
        const i = await this.getKeyChain();
        typeof i < "u" && (this.keychain = i), this.initialized = !0;
      }
    }, this.has = (i) => (this.isInitialized(), this.keychain.has(i)), this.set = async (i, n) => {
      this.isInitialized(), this.keychain.set(i, n), await this.persist();
    }, this.get = (i) => {
      this.isInitialized();
      const n = this.keychain.get(i);
      if (typeof n > "u") {
        const { message: s } = H("NO_MATCHING_KEY", `${this.name}: ${i}`);
        throw new Error(s);
      }
      return n;
    }, this.del = async (i) => {
      this.isInitialized(), this.keychain.delete(i), await this.persist();
    }, this.core = e, this.logger = be.generateChildLogger(r, this.name);
  }
  get context() {
    return be.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, qn(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Bn(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = H("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class O0 {
  constructor(e, r, i) {
    this.core = e, this.logger = r, this.name = Qy, this.initialized = !1, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = !0);
    }, this.hasKeys = (n) => (this.isInitialized(), this.keychain.has(n)), this.getClientId = async () => {
      this.isInitialized();
      const n = await this.getClientSeed(), s = Ns(n);
      return ea(s.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const n = ca();
      return this.setPrivateKey(n.publicKey, n.privateKey);
    }, this.signJWT = async (n) => {
      this.isInitialized();
      const s = await this.getClientSeed(), u = Ns(s), a = fi();
      return await Nf(a, n, Zy, u);
    }, this.generateSharedKey = (n, s, u) => {
      this.isInitialized();
      const a = this.getPrivateKey(n), l = ua(a, s);
      return this.setSymKey(l, u);
    }, this.setSymKey = async (n, s) => {
      this.isInitialized();
      const u = s || ha(n);
      return await this.keychain.set(u, n), u;
    }, this.deleteKeyPair = async (n) => {
      this.isInitialized(), await this.keychain.del(n);
    }, this.deleteSymKey = async (n) => {
      this.isInitialized(), await this.keychain.del(n);
    }, this.encode = async (n, s, u) => {
      this.isInitialized();
      const a = jn(u), l = Gr(s);
      if (pn(a)) {
        const g = a.senderPublicKey, _ = a.receiverPublicKey;
        n = await this.generateSharedKey(g, _);
      }
      const h = this.getSymKey(n), { type: f, senderPublicKey: y } = a;
      return fa({ type: f, symKey: h, message: l, senderPublicKey: y });
    }, this.decode = async (n, s, u) => {
      this.isInitialized();
      const a = ga(s, u);
      if (pn(a)) {
        const l = a.receiverPublicKey, h = a.senderPublicKey;
        n = await this.generateSharedKey(l, h);
      }
      try {
        const l = this.getSymKey(n), h = da({ symKey: l, encoded: s });
        return Ei(h);
      } catch (l) {
        this.logger.error(`Failed to decode message from topic: '${n}', clientId: '${await this.getClientId()}'`), this.logger.error(l);
      }
    }, this.getPayloadType = (n) => {
      const s = qr(n);
      return wr(s.type);
    }, this.getPayloadSenderPublicKey = (n) => {
      const s = qr(n);
      return s.senderPublicKey ? ht(s.senderPublicKey, st) : void 0;
    }, this.core = e, this.logger = be.generateChildLogger(r, this.name), this.keychain = i || new I0(this.core, this.logger);
  }
  get context() {
    return be.getLoggerContext(this.logger);
  }
  async setPrivateKey(e, r) {
    return await this.keychain.set(e, r), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(fo);
    } catch {
      e = fi(), await this.keychain.set(fo, e);
    }
    return Wy(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = H("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class P0 extends np {
  constructor(e, r) {
    super(e, r), this.logger = e, this.core = r, this.messages = /* @__PURE__ */ new Map(), this.name = r0, this.version = i0, this.initialized = !1, this.storagePrefix = Ht, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const i = await this.getRelayerMessages();
          typeof i < "u" && (this.messages = i), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (i) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i);
        } finally {
          this.initialized = !0;
        }
      }
    }, this.set = async (i, n) => {
      this.isInitialized();
      const s = ir(n);
      let u = this.messages.get(i);
      return typeof u > "u" && (u = {}), typeof u[s] < "u" || (u[s] = n, this.messages.set(i, u), await this.persist()), s;
    }, this.get = (i) => {
      this.isInitialized();
      let n = this.messages.get(i);
      return typeof n > "u" && (n = {}), n;
    }, this.has = (i, n) => {
      this.isInitialized();
      const s = this.get(i), u = ir(n);
      return typeof s[u] < "u";
    }, this.del = async (i) => {
      this.isInitialized(), this.messages.delete(i), await this.persist();
    }, this.logger = be.generateChildLogger(e, this.name), this.core = r;
  }
  get context() {
    return be.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, qn(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Bn(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = H("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class T0 extends sp {
  constructor(e, r) {
    super(e, r), this.relayer = e, this.logger = r, this.events = new Rt.EventEmitter(), this.name = s0, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = Q.toMiliseconds(Q.TEN_SECONDS * 2), this.needsTransportRestart = !1, this.publish = async (i, n, s) => {
      var u;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i, message: n, opts: s } });
      try {
        const a = (s == null ? void 0 : s.ttl) || n0, l = di(s), h = (s == null ? void 0 : s.prompt) || !1, f = (s == null ? void 0 : s.tag) || 0, y = (s == null ? void 0 : s.id) || yc().toString(), g = { topic: i, message: n, opts: { ttl: a, relay: l, prompt: h, tag: f, id: y } }, _ = setTimeout(() => this.queue.set(y, g), this.publishTimeout);
        try {
          await await yr(this.rpcPublish(i, n, a, l, h, f, y), this.publishTimeout, `Failed to publish payload, please try again. id:${y} tag:${f}`), this.removeRequestFromQueue(y), this.relayer.events.emit(nt.publish, g);
        } catch (w) {
          if (this.logger.debug("Publishing Payload stalled"), this.needsTransportRestart = !0, (u = s == null ? void 0 : s.internal) != null && u.throwOnFailedPublish) throw this.removeRequestFromQueue(y), w;
          return;
        } finally {
          clearTimeout(_);
        }
        this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i, message: n, opts: s } });
      } catch (a) {
        throw this.logger.debug("Failed to Publish Payload"), this.logger.error(a), a;
      }
    }, this.on = (i, n) => {
      this.events.on(i, n);
    }, this.once = (i, n) => {
      this.events.once(i, n);
    }, this.off = (i, n) => {
      this.events.off(i, n);
    }, this.removeListener = (i, n) => {
      this.events.removeListener(i, n);
    }, this.relayer = e, this.logger = be.generateChildLogger(r, this.name), this.registerEventListeners();
  }
  get context() {
    return be.getLoggerContext(this.logger);
  }
  rpcPublish(e, r, i, n, s, u, a) {
    var l, h, f, y;
    const g = { method: Fr(n.protocol).publish, params: { topic: e, message: r, ttl: i, prompt: s, tag: u }, id: a };
    return ut((l = g.params) == null ? void 0 : l.prompt) && ((h = g.params) == null || delete h.prompt), ut((f = g.params) == null ? void 0 : f.tag) && ((y = g.params) == null || delete y.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: g }), this.relayer.request(g);
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e) => {
      const { topic: r, message: i, opts: n } = e;
      await this.publish(r, i, n);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(mr.HEARTBEAT_EVENTS.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = !1, this.relayer.events.emit(nt.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(nt.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
}
class R0 {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e, r) => {
      const i = this.get(e);
      this.exists(e, r) || this.map.set(e, [...i, r]);
    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, r) => this.get(e).includes(r), this.delete = (e, r) => {
      if (typeof r > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e)) return;
      const i = this.get(e);
      if (!this.exists(e, r)) return;
      const n = i.filter((s) => s !== r);
      if (!n.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, n);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
}
var N0 = Object.defineProperty, A0 = Object.defineProperties, C0 = Object.getOwnPropertyDescriptors, go = Object.getOwnPropertySymbols, F0 = Object.prototype.hasOwnProperty, $0 = Object.prototype.propertyIsEnumerable, yo = (t, e, r) => e in t ? N0(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Nr = (t, e) => {
  for (var r in e || (e = {})) F0.call(e, r) && yo(t, r, e[r]);
  if (go) for (var r of go(e)) $0.call(e, r) && yo(t, r, e[r]);
  return t;
}, Gi = (t, e) => A0(t, C0(e));
class U0 extends cp {
  constructor(e, r) {
    super(e, r), this.relayer = e, this.logger = r, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new R0(), this.events = new Rt.EventEmitter(), this.name = p0, this.version = g0, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = Ht, this.subscribeTimeout = 1e4, this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId());
    }, this.subscribe = async (i, n) => {
      await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i, opts: n } });
      try {
        const s = di(n), u = { topic: i, relay: s };
        this.pending.set(i, u);
        const a = await this.rpcSubscribe(i, s);
        return this.onSubscribe(a, u), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i, opts: n } }), a;
      } catch (s) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(s), s;
      }
    }, this.unsubscribe = async (i, n) => {
      await this.restartToComplete(), this.isInitialized(), typeof (n == null ? void 0 : n.id) < "u" ? await this.unsubscribeById(i, n.id, n) : await this.unsubscribeByTopic(i, n);
    }, this.isSubscribed = async (i) => {
      if (this.topics.includes(i)) return !0;
      const n = `${this.pendingSubscriptionWatchLabel}_${i}`;
      return await new Promise((s, u) => {
        const a = new Q.Watch();
        a.start(n);
        const l = setInterval(() => {
          !this.pending.has(i) && this.topics.includes(i) && (clearInterval(l), a.stop(n), s(!0)), a.elapsed(n) >= y0 && (clearInterval(l), a.stop(n), u(new Error("Subscription resolution timeout")));
        }, this.pollingInterval);
      }).catch(() => !1);
    }, this.on = (i, n) => {
      this.events.on(i, n);
    }, this.once = (i, n) => {
      this.events.once(i, n);
    }, this.off = (i, n) => {
      this.events.off(i, n);
    }, this.removeListener = (i, n) => {
      this.events.removeListener(i, n);
    }, this.restart = async () => {
      this.restartInProgress = !0, await this.restore(), await this.reset(), this.restartInProgress = !1;
    }, this.relayer = e, this.logger = be.generateChildLogger(r, this.name), this.clientId = "";
  }
  get context() {
    return be.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, r) {
    let i = !1;
    try {
      i = this.getSubscription(e).topic === r;
    } catch {
    }
    return i;
  }
  onEnable() {
    this.cached = [], this.initialized = !0;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, r) {
    const i = this.topicMap.get(e);
    await Promise.all(i.map(async (n) => await this.unsubscribeById(e, n, r)));
  }
  async unsubscribeById(e, r, i) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: r, opts: i } });
    try {
      const n = di(i);
      await this.rpcUnsubscribe(e, r, n);
      const s = $e("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, r, s), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: r, opts: i } });
    } catch (n) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(n), n;
    }
  }
  async rpcSubscribe(e, r) {
    const i = { method: Fr(r.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i });
    try {
      await await yr(this.relayer.request(i), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(nt.connection_stalled);
    }
    return ir(e + this.clientId);
  }
  async rpcBatchSubscribe(e) {
    if (!e.length) return;
    const r = e[0].relay, i = { method: Fr(r.protocol).batchSubscribe, params: { topics: e.map((n) => n.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i });
    try {
      return await await yr(this.relayer.request(i), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Payload stalled"), this.relayer.events.emit(nt.connection_stalled);
    }
  }
  rpcUnsubscribe(e, r, i) {
    const n = { method: Fr(i.protocol).unsubscribe, params: { topic: e, id: r } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n }), this.relayer.request(n);
  }
  onSubscribe(e, r) {
    this.setSubscription(e, Gi(Nr({}, r), { id: e })), this.pending.delete(r.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((r) => {
      this.setSubscription(r.id, Nr({}, r)), this.pending.delete(r.topic);
    });
  }
  async onUnsubscribe(e, r, i) {
    this.events.removeAllListeners(r), this.hasSubscription(r, e) && this.deleteSubscription(r, i), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, r) {
    this.subscriptions.has(e) || (this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: r }), this.addSubscription(e, r));
  }
  addSubscription(e, r) {
    this.subscriptions.set(e, Nr({}, r)), this.topicMap.set(r.topic, e), this.events.emit(Dt.created, r);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const r = this.subscriptions.get(e);
    if (!r) {
      const { message: i } = H("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i);
    }
    return r;
  }
  deleteSubscription(e, r) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: r });
    const i = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(i.topic, e), this.events.emit(Dt.deleted, Gi(Nr({}, i), { reason: r }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(Dt.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let r = 0; r < e; r++) {
        const i = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(i);
      }
    }
    this.events.emit(Dt.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length) return;
      if (this.subscriptions.size) {
        const { message: r } = H("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    if (!e.length) return;
    const r = await this.rpcBatchSubscribe(e);
    Er(r) && this.onBatchSubscribe(r.map((i, n) => Gi(Nr({}, e[n]), { id: i })));
  }
  async onConnect() {
    this.restartInProgress || (await this.restart(), this.onEnable());
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || this.relayer.transportExplicitlyClosed) return;
    const e = [];
    this.pending.forEach((r) => {
      e.push(r);
    }), await this.batchSubscribe(e);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(mr.HEARTBEAT_EVENTS.pulse, async () => {
      await this.checkPending();
    }), this.relayer.on(nt.connect, async () => {
      await this.onConnect();
    }), this.relayer.on(nt.disconnect, () => {
      this.onDisconnect();
    }), this.events.on(Dt.created, async (e) => {
      const r = Dt.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), await this.persist();
    }), this.events.on(Dt.deleted, async (e) => {
      const r = Dt.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = H("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    this.restartInProgress && await new Promise((e) => {
      const r = setInterval(() => {
        this.restartInProgress || (clearInterval(r), e());
      }, this.pollingInterval);
    });
  }
}
var L0 = Object.defineProperty, bo = Object.getOwnPropertySymbols, M0 = Object.prototype.hasOwnProperty, j0 = Object.prototype.propertyIsEnumerable, _o = (t, e, r) => e in t ? L0(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, q0 = (t, e) => {
  for (var r in e || (e = {})) M0.call(e, r) && _o(t, r, e[r]);
  if (bo) for (var r of bo(e)) j0.call(e, r) && _o(t, r, e[r]);
  return t;
};
class B0 extends op {
  constructor(e) {
    super(e), this.protocol = "wc", this.version = 2, this.events = new Rt.EventEmitter(), this.name = a0, this.transportExplicitlyClosed = !1, this.initialized = !1, this.connectionAttemptInProgress = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled"], this.hasExperiencedNetworkDisruption = !1, this.requestsInFlight = /* @__PURE__ */ new Map(), this.request = async (r) => {
      this.logger.debug("Publishing Request Payload");
      const i = r.id;
      try {
        await this.toEstablishConnection();
        const n = this.provider.request(r);
        return this.requestsInFlight.set(i, { promise: n, request: r }), await n;
      } catch (n) {
        throw this.logger.debug("Failed to Publish Request"), this.logger.error(n), n;
      } finally {
        this.requestsInFlight.delete(i);
      }
    }, this.onPayloadHandler = (r) => {
      this.onProviderPayload(r);
    }, this.onConnectHandler = () => {
      this.events.emit(nt.connect);
    }, this.onDisconnectHandler = () => {
      this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (r) => {
      this.logger.error(r), this.events.emit(nt.error, r), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on($t.payload, this.onPayloadHandler), this.provider.on($t.connect, this.onConnectHandler), this.provider.on($t.disconnect, this.onDisconnectHandler), this.provider.on($t.error, this.onProviderErrorHandler);
    }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? be.generateChildLogger(e.logger, this.name) : be.pino(be.getDefaultLoggerOptions({ level: e.logger || o0 })), this.messages = new P0(this.logger, e.core), this.subscriber = new U0(this, this.logger), this.publisher = new T0(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || Ac, this.projectId = e.projectId, this.bundleId = _a(), this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), this.registerEventListeners(), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);
    try {
      await this.transportOpen();
    } catch {
      this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${po}...`), await this.restartTransport(po);
    }
    this.initialized = !0, setTimeout(async () => {
      this.subscriber.topics.length === 0 && (this.logger.info("No topics subscribed to after init, closing transport"), await this.transportClose(), this.transportExplicitlyClosed = !1);
    }, l0);
  }
  get context() {
    return be.getLoggerContext(this.logger);
  }
  get connected() {
    return this.provider.connection.connected;
  }
  get connecting() {
    return this.provider.connection.connecting;
  }
  async publish(e, r, i) {
    this.isInitialized(), await this.publisher.publish(e, r, i), await this.recordMessageEvent({ topic: e, message: r, publishedAt: Date.now() });
  }
  async subscribe(e, r) {
    var i;
    this.isInitialized();
    let n = ((i = this.subscriber.topicMap.get(e)) == null ? void 0 : i[0]) || "";
    if (n) return n;
    let s;
    const u = (a) => {
      a.topic === e && (this.subscriber.off(Dt.created, u), s());
    };
    return await Promise.all([new Promise((a) => {
      s = a, this.subscriber.on(Dt.created, u);
    }), new Promise(async (a) => {
      n = await this.subscriber.subscribe(e, r), a();
    })]), n;
  }
  async unsubscribe(e, r) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, r);
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async transportClose() {
    this.requestsInFlight.size > 0 && (this.logger.debug("Waiting for all in-flight requests to finish before closing transport..."), this.requestsInFlight.forEach(async (e) => {
      await e.promise;
    })), this.transportExplicitlyClosed = !0, this.hasExperiencedNetworkDisruption && this.connected ? await yr(this.provider.disconnect(), 1e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.connected && await this.provider.disconnect();
  }
  async transportOpen(e) {
    if (this.transportExplicitlyClosed = !1, await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress) {
      e && e !== this.relayUrl && (this.relayUrl = e, await this.transportClose(), await this.createProvider()), this.connectionAttemptInProgress = !0;
      try {
        await Promise.all([new Promise((r) => {
          if (!this.initialized) return r();
          this.subscriber.once(Dt.resubscribed, () => {
            r();
          });
        }), new Promise(async (r, i) => {
          try {
            await yr(this.provider.connect(), 1e4, `Socket stalled when trying to connect to ${this.relayUrl}`);
          } catch (n) {
            i(n);
            return;
          }
          r();
        })]);
      } catch (r) {
        this.logger.error(r);
        const i = r;
        if (!this.isConnectionStalled(i.message)) throw r;
        this.provider.events.emit($t.disconnect);
      } finally {
        this.connectionAttemptInProgress = !1, this.hasExperiencedNetworkDisruption = !1;
      }
    }
  }
  async restartTransport(e) {
    await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.transportClose(), await this.createProvider(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await mn()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  isConnectionStalled(e) {
    return this.staleConnectionErrors.some((r) => e.includes(r));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new dg(new _g(Sa({ sdkVersion: h0, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: !0, bundleId: this.bundleId }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: r, message: i } = e;
    await this.messages.set(r, i);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: r, message: i } = e;
    if (!i || i.length === 0) return this.logger.debug(`Ignoring invalid/empty message: ${i}`), !0;
    if (!await this.subscriber.isSubscribed(r)) return this.logger.debug(`Ignoring message for non-subscribed topic ${r}`), !0;
    const n = this.messages.has(r, i);
    return n && this.logger.debug(`Ignoring duplicate message: ${i}`), n;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), Jn(e)) {
      if (!e.method.endsWith(c0)) return;
      const r = e.params, { topic: i, message: n, publishedAt: s } = r.data, u = { topic: i, message: n, publishedAt: s };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(q0({ type: "event", event: r.id }, u)), this.events.emit(r.id, u), await this.acknowledgePayload(e), await this.onMessageEvent(u);
    } else Oi(e) && this.events.emit(nt.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(nt.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const r = Wn(e.id, !0);
    await this.provider.connection.send(r);
  }
  unregisterProviderListeners() {
    this.provider.off($t.payload, this.onPayloadHandler), this.provider.off($t.connect, this.onConnectHandler), this.provider.off($t.disconnect, this.onDisconnectHandler), this.provider.off($t.error, this.onProviderErrorHandler);
  }
  async registerEventListeners() {
    this.events.on(nt.connection_stalled, () => {
      this.restartTransport().catch((r) => this.logger.error(r));
    });
    let e = await mn();
    uc(async (r) => {
      this.initialized && e !== r && (e = r, r ? await this.restartTransport().catch((i) => this.logger.error(i)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportClose().catch((i) => this.logger.error(i))));
    });
  }
  onProviderDisconnect() {
    this.events.emit(nt.disconnect), this.attemptToReconnect();
  }
  attemptToReconnect() {
    this.transportExplicitlyClosed || (this.logger.info("attemptToReconnect called. Connecting..."), setTimeout(async () => {
      await this.restartTransport().catch((e) => this.logger.error(e));
    }, Q.toMiliseconds(u0)));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = H("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
      if (this.connectionAttemptInProgress) return await new Promise((e) => {
        const r = setInterval(() => {
          this.connected && (clearInterval(r), e());
        }, this.connectionStatusPollingInterval);
      });
      await this.restartTransport();
    }
  }
}
var z0 = Object.defineProperty, mo = Object.getOwnPropertySymbols, K0 = Object.prototype.hasOwnProperty, V0 = Object.prototype.propertyIsEnumerable, wo = (t, e, r) => e in t ? z0(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, vo = (t, e) => {
  for (var r in e || (e = {})) K0.call(e, r) && wo(t, r, e[r]);
  if (mo) for (var r of mo(e)) V0.call(e, r) && wo(t, r, e[r]);
  return t;
};
class Ti extends ap {
  constructor(e, r, i, n = Ht, s = void 0) {
    super(e, r, i, n), this.core = e, this.logger = r, this.name = i, this.map = /* @__PURE__ */ new Map(), this.version = f0, this.cached = [], this.initialized = !1, this.storagePrefix = Ht, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((u) => {
        this.getKey && u !== null && !ut(u) ? this.map.set(this.getKey(u), u) : za(u) ? this.map.set(u.id, u) : Ka(u) && this.map.set(u.topic, u);
      }), this.cached = [], this.initialized = !0);
    }, this.set = async (u, a) => {
      this.isInitialized(), this.map.has(u) ? await this.update(u, a) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: u, value: a }), this.map.set(u, a), await this.persist());
    }, this.get = (u) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: u }), this.getData(u)), this.getAll = (u) => (this.isInitialized(), u ? this.values.filter((a) => Object.keys(u).every((l) => wg(a[l], u[l]))) : this.values), this.update = async (u, a) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: u, update: a });
      const l = vo(vo({}, this.getData(u)), a);
      this.map.set(u, l), await this.persist();
    }, this.delete = async (u, a) => {
      this.isInitialized(), this.map.has(u) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: u, reason: a }), this.map.delete(u), await this.persist());
    }, this.logger = be.generateChildLogger(r, this.name), this.storagePrefix = n, this.getKey = s;
  }
  get context() {
    return be.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const r = this.map.get(e);
    if (!r) {
      const { message: i } = H("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(i), new Error(i);
    }
    return r;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length) return;
      if (this.map.size) {
        const { message: r } = H("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = H("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class H0 {
  constructor(e, r) {
    this.core = e, this.logger = r, this.name = b0, this.version = _0, this.events = new To(), this.initialized = !1, this.storagePrefix = Ht, this.ignoredPayloadTypes = [kt], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace("Initialized"));
    }, this.register = ({ methods: i }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i])];
    }, this.create = async () => {
      this.isInitialized();
      const i = fi(), n = await this.core.crypto.setSymKey(i), s = ft(Q.FIVE_MINUTES), u = { protocol: Nc }, a = { topic: n, expiry: s, relay: u, active: !1 }, l = Ca({ protocol: this.core.protocol, version: this.core.version, topic: n, symKey: i, relay: u, expiryTimestamp: s });
      return await this.pairings.set(n, a), await this.core.relayer.subscribe(n), this.core.expirer.set(n, s), { topic: n, uri: l };
    }, this.pair = async (i) => {
      this.isInitialized(), this.isValidPair(i);
      const { topic: n, symKey: s, relay: u, expiryTimestamp: a } = gn(i.uri);
      let l;
      if (this.pairings.keys.includes(n) && (l = this.pairings.get(n), l.active)) throw new Error(`Pairing already exists: ${n}. Please try again with a new connection URI.`);
      const h = a || ft(Q.FIVE_MINUTES), f = { topic: n, relay: u, expiry: h, active: !1 };
      return await this.pairings.set(n, f), this.core.expirer.set(n, h), i.activatePairing && await this.activate({ topic: n }), this.events.emit(Cr.create, f), this.core.crypto.keychain.has(n) || (await this.core.crypto.setSymKey(s, n), await this.core.relayer.subscribe(n, { relay: u })), f;
    }, this.activate = async ({ topic: i }) => {
      this.isInitialized();
      const n = ft(Q.THIRTY_DAYS);
      await this.pairings.update(i, { active: !0, expiry: n }), this.core.expirer.set(i, n);
    }, this.ping = async (i) => {
      this.isInitialized(), await this.isValidPing(i);
      const { topic: n } = i;
      if (this.pairings.keys.includes(n)) {
        const s = await this.sendRequest(n, "wc_pairingPing", {}), { done: u, resolve: a, reject: l } = rr();
        this.events.once(Fe("pairing_ping", s), ({ error: h }) => {
          h ? l(h) : a();
        }), await u();
      }
    }, this.updateExpiry = async ({ topic: i, expiry: n }) => {
      this.isInitialized(), await this.pairings.update(i, { expiry: n });
    }, this.updateMetadata = async ({ topic: i, metadata: n }) => {
      this.isInitialized(), await this.pairings.update(i, { peerMetadata: n });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (i) => {
      this.isInitialized(), await this.isValidDisconnect(i);
      const { topic: n } = i;
      this.pairings.keys.includes(n) && (await this.sendRequest(n, "wc_pairingDelete", $e("USER_DISCONNECTED")), await this.deletePairing(n));
    }, this.sendRequest = async (i, n, s) => {
      const u = gr(n, s), a = await this.core.crypto.encode(i, u), l = Rr[n].req;
      return this.core.history.set(i, u), this.core.relayer.publish(i, a, l), u.id;
    }, this.sendResult = async (i, n, s) => {
      const u = Wn(i, s), a = await this.core.crypto.encode(n, u), l = await this.core.history.get(n, i), h = Rr[l.request.method].res;
      await this.core.relayer.publish(n, a, h), await this.core.history.resolve(u);
    }, this.sendError = async (i, n, s) => {
      const u = Yn(i, s), a = await this.core.crypto.encode(n, u), l = await this.core.history.get(n, i), h = Rr[l.request.method] ? Rr[l.request.method].res : Rr.unregistered_method.res;
      await this.core.relayer.publish(n, a, h), await this.core.history.resolve(u);
    }, this.deletePairing = async (i, n) => {
      await this.core.relayer.unsubscribe(i), await Promise.all([this.pairings.delete(i, $e("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i), n ? Promise.resolve() : this.core.expirer.del(i)]);
    }, this.cleanup = async () => {
      const i = this.pairings.getAll().filter((n) => jt(n.expiry));
      await Promise.all(i.map((n) => this.deletePairing(n.topic)));
    }, this.onRelayEventRequest = (i) => {
      const { topic: n, payload: s } = i;
      switch (s.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(n, s);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(n, s);
        default:
          return this.onUnknownRpcMethodRequest(n, s);
      }
    }, this.onRelayEventResponse = async (i) => {
      const { topic: n, payload: s } = i, u = (await this.core.history.get(n, s.id)).request.method;
      switch (u) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(n, s);
        default:
          return this.onUnknownRpcMethodResponse(u);
      }
    }, this.onPairingPingRequest = async (i, n) => {
      const { id: s } = n;
      try {
        this.isValidPing({ topic: i }), await this.sendResult(s, i, !0), this.events.emit(Cr.ping, { id: s, topic: i });
      } catch (u) {
        await this.sendError(s, i, u), this.logger.error(u);
      }
    }, this.onPairingPingResponse = (i, n) => {
      const { id: s } = n;
      setTimeout(() => {
        Mt(n) ? this.events.emit(Fe("pairing_ping", s), {}) : St(n) && this.events.emit(Fe("pairing_ping", s), { error: n.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (i, n) => {
      const { id: s } = n;
      try {
        this.isValidDisconnect({ topic: i }), await this.deletePairing(i), this.events.emit(Cr.delete, { id: s, topic: i });
      } catch (u) {
        await this.sendError(s, i, u), this.logger.error(u);
      }
    }, this.onUnknownRpcMethodRequest = async (i, n) => {
      const { id: s, method: u } = n;
      try {
        if (this.registeredMethods.includes(u)) return;
        const a = $e("WC_METHOD_UNSUPPORTED", u);
        await this.sendError(s, i, a), this.logger.error(a);
      } catch (a) {
        await this.sendError(s, i, a), this.logger.error(a);
      }
    }, this.onUnknownRpcMethodResponse = (i) => {
      this.registeredMethods.includes(i) || this.logger.error($e("WC_METHOD_UNSUPPORTED", i));
    }, this.isValidPair = (i) => {
      var n;
      if (!ct(i)) {
        const { message: u } = H("MISSING_OR_INVALID", `pair() params: ${i}`);
        throw new Error(u);
      }
      if (!Ba(i.uri)) {
        const { message: u } = H("MISSING_OR_INVALID", `pair() uri: ${i.uri}`);
        throw new Error(u);
      }
      const s = gn(i.uri);
      if (!((n = s == null ? void 0 : s.relay) != null && n.protocol)) {
        const { message: u } = H("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw new Error(u);
      }
      if (!(s != null && s.symKey)) {
        const { message: u } = H("MISSING_OR_INVALID", "pair() uri#symKey");
        throw new Error(u);
      }
      if (s != null && s.expiryTimestamp && Q.toMiliseconds(s == null ? void 0 : s.expiryTimestamp) < Date.now()) {
        const { message: u } = H("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(u);
      }
    }, this.isValidPing = async (i) => {
      if (!ct(i)) {
        const { message: s } = H("MISSING_OR_INVALID", `ping() params: ${i}`);
        throw new Error(s);
      }
      const { topic: n } = i;
      await this.isValidPairingTopic(n);
    }, this.isValidDisconnect = async (i) => {
      if (!ct(i)) {
        const { message: s } = H("MISSING_OR_INVALID", `disconnect() params: ${i}`);
        throw new Error(s);
      }
      const { topic: n } = i;
      await this.isValidPairingTopic(n);
    }, this.isValidPairingTopic = async (i) => {
      if (!Ke(i, !1)) {
        const { message: n } = H("MISSING_OR_INVALID", `pairing topic should be a string: ${i}`);
        throw new Error(n);
      }
      if (!this.pairings.keys.includes(i)) {
        const { message: n } = H("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i}`);
        throw new Error(n);
      }
      if (jt(this.pairings.get(i).expiry)) {
        await this.deletePairing(i);
        const { message: n } = H("EXPIRED", `pairing topic: ${i}`);
        throw new Error(n);
      }
    }, this.core = e, this.logger = be.generateChildLogger(r, this.name), this.pairings = new Ti(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return be.getLoggerContext(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = H("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(nt.message, async (e) => {
      const { topic: r, message: i } = e;
      if (!this.pairings.keys.includes(r) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i))) return;
      const n = await this.core.crypto.decode(r, i);
      try {
        Jn(n) ? (this.core.history.set(r, n), this.onRelayEventRequest({ topic: r, payload: n })) : Oi(n) && (await this.core.history.resolve(n), await this.onRelayEventResponse({ topic: r, payload: n }), this.core.history.delete(r, n.id));
      } catch (s) {
        this.logger.error(s);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(wt.expired, async (e) => {
      const { topic: r } = Kn(e.target);
      r && this.pairings.keys.includes(r) && (await this.deletePairing(r, !0), this.events.emit(Cr.expire, { topic: r }));
    });
  }
}
class G0 extends ip {
  constructor(e, r) {
    super(e, r), this.core = e, this.logger = r, this.records = /* @__PURE__ */ new Map(), this.events = new Rt.EventEmitter(), this.name = m0, this.version = w0, this.cached = [], this.initialized = !1, this.storagePrefix = Ht, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i) => this.records.set(i.id, i)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.set = (i, n, s) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i, request: n, chainId: s }), this.records.has(n.id)) return;
      const u = { id: n.id, topic: i, request: { method: n.method, params: n.params || null }, chainId: s, expiry: ft(Q.THIRTY_DAYS) };
      this.records.set(u.id, u), this.events.emit(Pt.created, u);
    }, this.resolve = async (i) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i }), !this.records.has(i.id)) return;
      const n = await this.getRecord(i.id);
      typeof n.response > "u" && (n.response = St(i) ? { error: i.error } : { result: i.result }, this.records.set(n.id, n), this.events.emit(Pt.updated, n));
    }, this.get = async (i, n) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i, id: n }), await this.getRecord(n)), this.delete = (i, n) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: n }), this.values.forEach((s) => {
        if (s.topic === i) {
          if (typeof n < "u" && s.id !== n) return;
          this.records.delete(s.id), this.events.emit(Pt.deleted, s);
        }
      });
    }, this.exists = async (i, n) => (this.isInitialized(), this.records.has(n) ? (await this.getRecord(n)).topic === i : !1), this.on = (i, n) => {
      this.events.on(i, n);
    }, this.once = (i, n) => {
      this.events.once(i, n);
    }, this.off = (i, n) => {
      this.events.off(i, n);
    }, this.removeListener = (i, n) => {
      this.events.removeListener(i, n);
    }, this.logger = be.generateChildLogger(r, this.name);
  }
  get context() {
    return be.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((r) => {
      if (typeof r.response < "u") return;
      const i = { topic: r.topic, request: gr(r.request.method, r.request.params, r.id), chainId: r.chainId };
      return e.push(i);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const r = this.records.get(e);
    if (!r) {
      const { message: i } = H("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i);
    }
    return r;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(Pt.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length) return;
      if (this.records.size) {
        const { message: r } = H("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(Pt.created, (e) => {
      const r = Pt.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: e }), this.persist();
    }), this.events.on(Pt.updated, (e) => {
      const r = Pt.updated;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: e }), this.persist();
    }), this.events.on(Pt.deleted, (e) => {
      const r = Pt.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: e }), this.persist();
    }), this.core.heartbeat.on(mr.HEARTBEAT_EVENTS.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.records.forEach((e) => {
        Q.toMiliseconds(e.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${e.id}`), this.delete(e.topic, e.id));
      });
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = H("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class k0 extends up {
  constructor(e, r) {
    super(e, r), this.core = e, this.logger = r, this.expirations = /* @__PURE__ */ new Map(), this.events = new Rt.EventEmitter(), this.name = v0, this.version = E0, this.cached = [], this.initialized = !1, this.storagePrefix = Ht, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i) => this.expirations.set(i.target, i)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.has = (i) => {
      try {
        const n = this.formatTarget(i);
        return typeof this.getExpiration(n) < "u";
      } catch {
        return !1;
      }
    }, this.set = (i, n) => {
      this.isInitialized();
      const s = this.formatTarget(i), u = { target: s, expiry: n };
      this.expirations.set(s, u), this.checkExpiry(s, u), this.events.emit(wt.created, { target: s, expiration: u });
    }, this.get = (i) => {
      this.isInitialized();
      const n = this.formatTarget(i);
      return this.getExpiration(n);
    }, this.del = (i) => {
      if (this.isInitialized(), this.has(i)) {
        const n = this.formatTarget(i), s = this.getExpiration(n);
        this.expirations.delete(n), this.events.emit(wt.deleted, { target: n, expiration: s });
      }
    }, this.on = (i, n) => {
      this.events.on(i, n);
    }, this.once = (i, n) => {
      this.events.once(i, n);
    }, this.off = (i, n) => {
      this.events.off(i, n);
    }, this.removeListener = (i, n) => {
      this.events.removeListener(i, n);
    }, this.logger = be.generateChildLogger(r, this.name);
  }
  get context() {
    return be.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string") return xa(e);
    if (typeof e == "number") return Ia(e);
    const { message: r } = H("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(r);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(wt.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length) return;
      if (this.expirations.size) {
        const { message: r } = H("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const r = this.expirations.get(e);
    if (!r) {
      const { message: i } = H("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(i), new Error(i);
    }
    return r;
  }
  checkExpiry(e, r) {
    const { expiry: i } = r;
    Q.toMiliseconds(i) - Date.now() <= 0 && this.expire(e, r);
  }
  expire(e, r) {
    this.expirations.delete(e), this.events.emit(wt.expired, { target: e, expiration: r });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, r) => this.checkExpiry(r, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(mr.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(wt.created, (e) => {
      const r = wt.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), this.persist();
    }), this.events.on(wt.expired, (e) => {
      const r = wt.expired;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), this.persist();
    }), this.events.on(wt.deleted, (e) => {
      const r = wt.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = H("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class W0 extends hp {
  constructor(e, r) {
    super(e, r), this.projectId = e, this.logger = r, this.name = Hi, this.initialized = !1, this.queue = [], this.verifyDisabled = !1, this.init = async (i) => {
      if (this.verifyDisabled || cr() || !ur()) return;
      const n = this.getVerifyUrl(i == null ? void 0 : i.verifyUrl);
      this.verifyUrl !== n && this.removeIframe(), this.verifyUrl = n;
      try {
        await this.createIframe();
      } catch (s) {
        this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(s);
      }
      if (!this.initialized) {
        this.removeIframe(), this.verifyUrl = xn;
        try {
          await this.createIframe();
        } catch (s) {
          this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(s), this.verifyDisabled = !0;
        }
      }
    }, this.register = async (i) => {
      this.initialized ? this.sendPost(i.attestationId) : (this.addToQueue(i.attestationId), await this.init());
    }, this.resolve = async (i) => {
      if (this.isDevEnv) return "";
      const n = this.getVerifyUrl(i == null ? void 0 : i.verifyUrl);
      let s;
      try {
        s = await this.fetchAttestation(i.attestationId, n);
      } catch (u) {
        this.logger.info(`failed to resolve attestation: ${i.attestationId} from url: ${n}`), this.logger.info(u), s = await this.fetchAttestation(i.attestationId, xn);
      }
      return s;
    }, this.fetchAttestation = async (i, n) => {
      this.logger.info(`resolving attestation: ${i} from url: ${n}`);
      const s = this.startAbortTimer(Q.ONE_SECOND * 2), u = await fetch(`${n}/attestation/${i}`, { signal: this.abortController.signal });
      return clearTimeout(s), u.status === 200 ? await u.json() : void 0;
    }, this.addToQueue = (i) => {
      this.queue.push(i);
    }, this.processQueue = () => {
      this.queue.length !== 0 && (this.queue.forEach((i) => this.sendPost(i)), this.queue = []);
    }, this.sendPost = (i) => {
      var n;
      try {
        if (!this.iframe) return;
        (n = this.iframe.contentWindow) == null || n.postMessage(i, "*"), this.logger.info(`postMessage sent: ${i} ${this.verifyUrl}`);
      } catch {
      }
    }, this.createIframe = async () => {
      let i;
      const n = (s) => {
        s.data === "verify_ready" && (this.initialized = !0, this.processQueue(), window.removeEventListener("message", n), i());
      };
      await Promise.race([new Promise((s) => {
        if (document.getElementById(Hi)) return s();
        window.addEventListener("message", n);
        const u = document.createElement("iframe");
        u.id = Hi, u.src = `${this.verifyUrl}/${this.projectId}`, u.style.display = "none", document.body.append(u), this.iframe = u, i = s;
      }), new Promise((s, u) => setTimeout(() => {
        window.removeEventListener("message", n), u("verify iframe load timeout");
      }, Q.toMiliseconds(Q.FIVE_SECONDS)))]);
    }, this.removeIframe = () => {
      this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = !1);
    }, this.getVerifyUrl = (i) => {
      let n = i || pr;
      return D0.includes(n) || (this.logger.info(`verify url: ${n}, not included in trusted list, assigning default: ${pr}`), n = pr), n;
    }, this.logger = be.generateChildLogger(r, this.name), this.verifyUrl = pr, this.abortController = new AbortController(), this.isDevEnv = xi() && xt.env.IS_VITEST;
  }
  get context() {
    return be.getLoggerContext(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), Q.toMiliseconds(e));
  }
}
class Y0 extends lp {
  constructor(e, r) {
    super(e, r), this.projectId = e, this.logger = r, this.context = S0, this.registerDeviceToken = async (i) => {
      const { clientId: n, token: s, notificationType: u, enableEncrypted: a = !1 } = i, l = `${x0}/${this.projectId}/clients`;
      await Sg(l, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: n, type: u, token: s, always_raw: a }) });
    }, this.logger = be.generateChildLogger(r, this.context);
  }
}
var J0 = Object.defineProperty, Eo = Object.getOwnPropertySymbols, X0 = Object.prototype.hasOwnProperty, Q0 = Object.prototype.propertyIsEnumerable, Do = (t, e, r) => e in t ? J0(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, So = (t, e) => {
  for (var r in e || (e = {})) X0.call(e, r) && Do(t, r, e[r]);
  if (Eo) for (var r of Eo(e)) Q0.call(e, r) && Do(t, r, e[r]);
  return t;
};
class Qn extends rp {
  constructor(e) {
    super(e), this.protocol = Rc, this.version = Yy, this.name = Xn, this.events = new Rt.EventEmitter(), this.initialized = !1, this.on = (i, n) => this.events.on(i, n), this.once = (i, n) => this.events.once(i, n), this.off = (i, n) => this.events.off(i, n), this.removeListener = (i, n) => this.events.removeListener(i, n), this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || Ac, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const r = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : be.pino(be.getDefaultLoggerOptions({ level: (e == null ? void 0 : e.logger) || Jy.logger }));
    this.logger = be.generateChildLogger(r, this.name), this.heartbeat = new mr.HeartBeat(), this.crypto = new O0(this, this.logger, e == null ? void 0 : e.keychain), this.history = new G0(this, this.logger), this.expirer = new k0(this, this.logger), this.storage = e != null && e.storage ? e.storage : new od(So(So({}, Xy), e == null ? void 0 : e.storageOptions)), this.relayer = new B0({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new H0(this, this.logger), this.verify = new W0(this.projectId || "", this.logger), this.echoClient = new Y0(this.projectId || "", this.logger);
  }
  static async init(e) {
    const r = new Qn(e);
    await r.initialize();
    const i = await r.crypto.getClientId();
    return await r.storage.setItem(d0, i), r;
  }
  get context() {
    return be.getLoggerContext(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = !0, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
}
const Z0 = Qn, Cc = "wc", Fc = 2, $c = "client", Zn = `${Cc}@${Fc}:${$c}:`, ki = { name: $c, logger: "error", controller: !1, relayUrl: "wss://relay.walletconnect.com" }, xo = "WALLETCONNECT_DEEPLINK_CHOICE", e1 = "proposal", t1 = "Proposal expired", r1 = "session", ni = Q.SEVEN_DAYS, i1 = "engine", Ut = { wc_sessionPropose: { req: { ttl: Q.FIVE_MINUTES, prompt: !0, tag: 1100 }, res: { ttl: Q.FIVE_MINUTES, prompt: !1, tag: 1101 } }, wc_sessionSettle: { req: { ttl: Q.FIVE_MINUTES, prompt: !1, tag: 1102 }, res: { ttl: Q.FIVE_MINUTES, prompt: !1, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: Q.ONE_DAY, prompt: !1, tag: 1104 }, res: { ttl: Q.ONE_DAY, prompt: !1, tag: 1105 } }, wc_sessionExtend: { req: { ttl: Q.ONE_DAY, prompt: !1, tag: 1106 }, res: { ttl: Q.ONE_DAY, prompt: !1, tag: 1107 } }, wc_sessionRequest: { req: { ttl: Q.FIVE_MINUTES, prompt: !0, tag: 1108 }, res: { ttl: Q.FIVE_MINUTES, prompt: !1, tag: 1109 } }, wc_sessionEvent: { req: { ttl: Q.FIVE_MINUTES, prompt: !0, tag: 1110 }, res: { ttl: Q.FIVE_MINUTES, prompt: !1, tag: 1111 } }, wc_sessionDelete: { req: { ttl: Q.ONE_DAY, prompt: !1, tag: 1112 }, res: { ttl: Q.ONE_DAY, prompt: !1, tag: 1113 } }, wc_sessionPing: { req: { ttl: Q.THIRTY_SECONDS, prompt: !1, tag: 1114 }, res: { ttl: Q.THIRTY_SECONDS, prompt: !1, tag: 1115 } } }, Wi = { min: Q.FIVE_MINUTES, max: Q.SEVEN_DAYS }, Lt = { idle: "IDLE", active: "ACTIVE" }, n1 = "request", s1 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"];
var o1 = Object.defineProperty, a1 = Object.defineProperties, c1 = Object.getOwnPropertyDescriptors, Io = Object.getOwnPropertySymbols, u1 = Object.prototype.hasOwnProperty, h1 = Object.prototype.propertyIsEnumerable, Oo = (t, e, r) => e in t ? o1(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, at = (t, e) => {
  for (var r in e || (e = {})) u1.call(e, r) && Oo(t, r, e[r]);
  if (Io) for (var r of Io(e)) h1.call(e, r) && Oo(t, r, e[r]);
  return t;
}, dr = (t, e) => a1(t, c1(e));
class l1 extends dp {
  constructor(e) {
    super(e), this.name = i1, this.events = new To(), this.initialized = !1, this.ignoredPayloadTypes = [kt], this.requestQueue = { state: Lt.idle, queue: [] }, this.sessionRequestQueue = { state: Lt.idle, queue: [] }, this.requestQueueDelay = Q.ONE_SECOND, this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({ methods: Object.keys(Ut) }), this.initialized = !0, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, Q.toMiliseconds(this.requestQueueDelay)));
    }, this.connect = async (r) => {
      await this.isInitialized();
      const i = dr(at({}, r), { requiredNamespaces: r.requiredNamespaces || {}, optionalNamespaces: r.optionalNamespaces || {} });
      await this.isValidConnect(i);
      const { pairingTopic: n, requiredNamespaces: s, optionalNamespaces: u, sessionProperties: a, relays: l } = i;
      let h = n, f, y = !1;
      if (h && (y = this.client.core.pairing.pairings.get(h).active), !h || !y) {
        const { topic: m, uri: E } = await this.client.core.pairing.create();
        h = m, f = E;
      }
      const g = await this.client.core.crypto.generateKeyPair(), _ = Ut.wc_sessionPropose.req.ttl || Q.FIVE_MINUTES, w = ft(_), T = at({ requiredNamespaces: s, optionalNamespaces: u, relays: l ?? [{ protocol: Nc }], proposer: { publicKey: g, metadata: this.client.metadata }, expiryTimestamp: w }, a && { sessionProperties: a }), { reject: A, resolve: j, done: D } = rr(_, t1);
      if (this.events.once(Fe("session_connect"), async ({ error: m, session: E }) => {
        if (m) A(m);
        else if (E) {
          E.self.publicKey = g;
          const p = dr(at({}, E), { requiredNamespaces: T.requiredNamespaces, optionalNamespaces: T.optionalNamespaces });
          await this.client.session.set(E.topic, p), await this.setExpiry(E.topic, E.expiry), h && await this.client.core.pairing.updateMetadata({ topic: h, metadata: E.peer.metadata }), j(p);
        }
      }), !h) {
        const { message: m } = H("NO_MATCHING_KEY", `connect() pairing topic: ${h}`);
        throw new Error(m);
      }
      const O = await this.sendRequest({ topic: h, method: "wc_sessionPropose", params: T, throwOnFailedPublish: !0 });
      return await this.setProposal(O, at({ id: O }, T)), { uri: f, approval: D };
    }, this.pair = async (r) => (await this.isInitialized(), await this.client.core.pairing.pair(r)), this.approve = async (r) => {
      await this.isInitialized(), await this.isValidApprove(r);
      const { id: i, relayProtocol: n, namespaces: s, sessionProperties: u } = r, a = this.client.proposal.get(i);
      let { pairingTopic: l, proposer: h, requiredNamespaces: f, optionalNamespaces: y } = a;
      l = l || "";
      const g = await this.client.core.crypto.generateKeyPair(), _ = h.publicKey, w = await this.client.core.crypto.generateSharedKey(g, _);
      l && i && (await this.client.core.pairing.updateMetadata({ topic: l, metadata: h.metadata }), await this.sendResult({ id: i, topic: l, result: { relay: { protocol: n ?? "irn" }, responderPublicKey: g } }), await this.client.proposal.delete(i, $e("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: l }));
      const T = at({ relay: { protocol: n ?? "irn" }, namespaces: s, pairingTopic: l, controller: { publicKey: g, metadata: this.client.metadata }, expiry: ft(ni) }, u && { sessionProperties: u });
      await this.client.core.relayer.subscribe(w);
      const A = dr(at({}, T), { topic: w, requiredNamespaces: f, optionalNamespaces: y, pairingTopic: l, acknowledged: !1, self: T.controller, peer: { publicKey: h.publicKey, metadata: h.metadata }, controller: g });
      await this.client.session.set(w, A);
      try {
        await this.sendRequest({ topic: w, method: "wc_sessionSettle", params: T, throwOnFailedPublish: !0 });
      } catch (j) {
        throw this.client.logger.error(j), this.client.session.delete(w, $e("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(w), j;
      }
      return await this.setExpiry(w, ft(ni)), { topic: w, acknowledged: () => new Promise((j) => setTimeout(() => j(this.client.session.get(w)), 500)) };
    }, this.reject = async (r) => {
      await this.isInitialized(), await this.isValidReject(r);
      const { id: i, reason: n } = r, { pairingTopic: s } = this.client.proposal.get(i);
      s && (await this.sendError(i, s, n), await this.client.proposal.delete(i, $e("USER_DISCONNECTED")));
    }, this.update = async (r) => {
      await this.isInitialized(), await this.isValidUpdate(r);
      const { topic: i, namespaces: n } = r, s = await this.sendRequest({ topic: i, method: "wc_sessionUpdate", params: { namespaces: n } }), { done: u, resolve: a, reject: l } = rr();
      return this.events.once(Fe("session_update", s), ({ error: h }) => {
        h ? l(h) : a();
      }), await this.client.session.update(i, { namespaces: n }), { acknowledged: u };
    }, this.extend = async (r) => {
      await this.isInitialized(), await this.isValidExtend(r);
      const { topic: i } = r, n = await this.sendRequest({ topic: i, method: "wc_sessionExtend", params: {} }), { done: s, resolve: u, reject: a } = rr();
      return this.events.once(Fe("session_extend", n), ({ error: l }) => {
        l ? a(l) : u();
      }), await this.setExpiry(i, ft(ni)), { acknowledged: s };
    }, this.request = async (r) => {
      await this.isInitialized(), await this.isValidRequest(r);
      const { chainId: i, request: n, topic: s, expiry: u = Ut.wc_sessionRequest.req.ttl } = r, a = kn(), { done: l, resolve: h, reject: f } = rr(u, "Request expired. Please try again.");
      return this.events.once(Fe("session_request", a), ({ error: y, result: g }) => {
        y ? f(y) : h(g);
      }), await Promise.all([new Promise(async (y) => {
        await this.sendRequest({ clientRpcId: a, topic: s, method: "wc_sessionRequest", params: { request: dr(at({}, n), { expiryTimestamp: ft(u) }), chainId: i }, expiry: u, throwOnFailedPublish: !0 }).catch((g) => f(g)), this.client.events.emit("session_request_sent", { topic: s, request: n, chainId: i, id: a }), y();
      }), new Promise(async (y) => {
        const g = await Pa(this.client.core.storage, xo);
        Oa({ id: a, topic: s, wcDeepLink: g }), y();
      }), l()]).then((y) => y[2]);
    }, this.respond = async (r) => {
      await this.isInitialized(), await this.isValidRespond(r);
      const { topic: i, response: n } = r, { id: s } = n;
      Mt(n) ? await this.sendResult({ id: s, topic: i, result: n.result, throwOnFailedPublish: !0 }) : St(n) && await this.sendError(s, i, n.error), this.cleanupAfterResponse(r);
    }, this.ping = async (r) => {
      await this.isInitialized(), await this.isValidPing(r);
      const { topic: i } = r;
      if (this.client.session.keys.includes(i)) {
        const n = await this.sendRequest({ topic: i, method: "wc_sessionPing", params: {} }), { done: s, resolve: u, reject: a } = rr();
        this.events.once(Fe("session_ping", n), ({ error: l }) => {
          l ? a(l) : u();
        }), await s();
      } else this.client.core.pairing.pairings.keys.includes(i) && await this.client.core.pairing.ping({ topic: i });
    }, this.emit = async (r) => {
      await this.isInitialized(), await this.isValidEmit(r);
      const { topic: i, event: n, chainId: s } = r;
      await this.sendRequest({ topic: i, method: "wc_sessionEvent", params: { event: n, chainId: s } });
    }, this.disconnect = async (r) => {
      await this.isInitialized(), await this.isValidDisconnect(r);
      const { topic: i } = r;
      if (this.client.session.keys.includes(i)) await this.sendRequest({ topic: i, method: "wc_sessionDelete", params: $e("USER_DISCONNECTED"), throwOnFailedPublish: !0 }), await this.deleteSession({ topic: i, emitEvent: !1 });
      else if (this.client.core.pairing.pairings.keys.includes(i)) await this.client.core.pairing.disconnect({ topic: i });
      else {
        const { message: n } = H("MISMATCHED_TOPIC", `Session or pairing topic not found: ${i}`);
        throw new Error(n);
      }
    }, this.find = (r) => (this.isInitialized(), this.client.session.getAll().filter((i) => ja(i, r))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.cleanupDuplicatePairings = async (r) => {
      if (r.pairingTopic) try {
        const i = this.client.core.pairing.pairings.get(r.pairingTopic), n = this.client.core.pairing.pairings.getAll().filter((s) => {
          var u, a;
          return ((u = s.peerMetadata) == null ? void 0 : u.url) && ((a = s.peerMetadata) == null ? void 0 : a.url) === r.peer.metadata.url && s.topic && s.topic !== i.topic;
        });
        if (n.length === 0) return;
        this.client.logger.info(`Cleaning up ${n.length} duplicate pairing(s)`), await Promise.all(n.map((s) => this.client.core.pairing.disconnect({ topic: s.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (i) {
        this.client.logger.error(i);
      }
    }, this.deleteSession = async (r) => {
      const { topic: i, expirerHasDeleted: n = !1, emitEvent: s = !0, id: u = 0 } = r, { self: a } = this.client.session.get(i);
      await this.client.core.relayer.unsubscribe(i), await this.client.session.delete(i, $e("USER_DISCONNECTED")), this.client.core.crypto.keychain.has(a.publicKey) && await this.client.core.crypto.deleteKeyPair(a.publicKey), this.client.core.crypto.keychain.has(i) && await this.client.core.crypto.deleteSymKey(i), n || this.client.core.expirer.del(i), this.client.core.storage.removeItem(xo).catch((l) => this.client.logger.warn(l)), this.getPendingSessionRequests().forEach((l) => {
        l.topic === i && this.deletePendingSessionRequest(l.id, $e("USER_DISCONNECTED"));
      }), s && this.client.events.emit("session_delete", { id: u, topic: i });
    }, this.deleteProposal = async (r, i) => {
      await Promise.all([this.client.proposal.delete(r, $e("USER_DISCONNECTED")), i ? Promise.resolve() : this.client.core.expirer.del(r)]);
    }, this.deletePendingSessionRequest = async (r, i, n = !1) => {
      await Promise.all([this.client.pendingRequest.delete(r, i), n ? Promise.resolve() : this.client.core.expirer.del(r)]), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((s) => s.id !== r), n && (this.sessionRequestQueue.state = Lt.idle, this.client.events.emit("session_request_expire", { id: r }));
    }, this.setExpiry = async (r, i) => {
      this.client.session.keys.includes(r) && await this.client.session.update(r, { expiry: i }), this.client.core.expirer.set(r, i);
    }, this.setProposal = async (r, i) => {
      await this.client.proposal.set(r, i), this.client.core.expirer.set(r, ft(Ut.wc_sessionPropose.req.ttl));
    }, this.setPendingSessionRequest = async (r) => {
      const { id: i, topic: n, params: s, verifyContext: u } = r, a = s.request.expiryTimestamp || ft(Ut.wc_sessionRequest.req.ttl);
      await this.client.pendingRequest.set(i, { id: i, topic: n, params: s, verifyContext: u }), a && this.client.core.expirer.set(i, a);
    }, this.sendRequest = async (r) => {
      const { topic: i, method: n, params: s, expiry: u, relayRpcId: a, clientRpcId: l, throwOnFailedPublish: h } = r, f = gr(n, s, l);
      if (ur() && s1.includes(n)) {
        const _ = ir(JSON.stringify(f));
        this.client.core.verify.register({ attestationId: _ });
      }
      const y = await this.client.core.crypto.encode(i, f), g = Ut[n].req;
      return u && (g.ttl = u), a && (g.id = a), this.client.core.history.set(i, f), h ? (g.internal = dr(at({}, g.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(i, y, g)) : this.client.core.relayer.publish(i, y, g).catch((_) => this.client.logger.error(_)), f.id;
    }, this.sendResult = async (r) => {
      const { id: i, topic: n, result: s, throwOnFailedPublish: u } = r, a = Wn(i, s), l = await this.client.core.crypto.encode(n, a), h = await this.client.core.history.get(n, i), f = Ut[h.request.method].res;
      u ? (f.internal = dr(at({}, f.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(n, l, f)) : this.client.core.relayer.publish(n, l, f).catch((y) => this.client.logger.error(y)), await this.client.core.history.resolve(a);
    }, this.sendError = async (r, i, n) => {
      const s = Yn(r, n), u = await this.client.core.crypto.encode(i, s), a = await this.client.core.history.get(i, r), l = Ut[a.request.method].res;
      this.client.core.relayer.publish(i, u, l), await this.client.core.history.resolve(s);
    }, this.cleanup = async () => {
      const r = [], i = [];
      this.client.session.getAll().forEach((n) => {
        let s = !1;
        jt(n.expiry) && (s = !0), this.client.core.crypto.keychain.has(n.topic) || (s = !0), s && r.push(n.topic);
      }), this.client.proposal.getAll().forEach((n) => {
        jt(n.expiryTimestamp) && i.push(n.id);
      }), await Promise.all([...r.map((n) => this.deleteSession({ topic: n })), ...i.map((n) => this.deleteProposal(n))]);
    }, this.onRelayEventRequest = async (r) => {
      this.requestQueue.queue.push(r), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === Lt.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = Lt.active;
        const r = this.requestQueue.queue.shift();
        if (r) try {
          this.processRequest(r), await new Promise((i) => setTimeout(i, 300));
        } catch (i) {
          this.client.logger.warn(i);
        }
      }
      this.requestQueue.state = Lt.idle;
    }, this.processRequest = (r) => {
      const { topic: i, payload: n } = r, s = n.method;
      switch (s) {
        case "wc_sessionPropose":
          return this.onSessionProposeRequest(i, n);
        case "wc_sessionSettle":
          return this.onSessionSettleRequest(i, n);
        case "wc_sessionUpdate":
          return this.onSessionUpdateRequest(i, n);
        case "wc_sessionExtend":
          return this.onSessionExtendRequest(i, n);
        case "wc_sessionPing":
          return this.onSessionPingRequest(i, n);
        case "wc_sessionDelete":
          return this.onSessionDeleteRequest(i, n);
        case "wc_sessionRequest":
          return this.onSessionRequest(i, n);
        case "wc_sessionEvent":
          return this.onSessionEventRequest(i, n);
        default:
          return this.client.logger.info(`Unsupported request method ${s}`);
      }
    }, this.onRelayEventResponse = async (r) => {
      const { topic: i, payload: n } = r, s = (await this.client.core.history.get(i, n.id)).request.method;
      switch (s) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(i, n);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(i, n);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(i, n);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(i, n);
        case "wc_sessionPing":
          return this.onSessionPingResponse(i, n);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(i, n);
        default:
          return this.client.logger.info(`Unsupported response method ${s}`);
      }
    }, this.onRelayEventUnknownPayload = (r) => {
      const { topic: i } = r, { message: n } = H("MISSING_OR_INVALID", `Decoded payload on topic ${i} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(n);
    }, this.onSessionProposeRequest = async (r, i) => {
      const { params: n, id: s } = i;
      try {
        this.isValidConnect(at({}, i.params));
        const u = n.expiryTimestamp || ft(Ut.wc_sessionPropose.req.ttl), a = at({ id: s, pairingTopic: r, expiryTimestamp: u }, n);
        await this.setProposal(s, a);
        const l = ir(JSON.stringify(i)), h = await this.getVerifyContext(l, a.proposer.metadata);
        this.client.events.emit("session_proposal", { id: s, params: a, verifyContext: h });
      } catch (u) {
        await this.sendError(s, r, u), this.client.logger.error(u);
      }
    }, this.onSessionProposeResponse = async (r, i) => {
      const { id: n } = i;
      if (Mt(i)) {
        const { result: s } = i;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: s });
        const u = this.client.proposal.get(n);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: u });
        const a = u.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: a });
        const l = s.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: l });
        const h = await this.client.core.crypto.generateSharedKey(a, l);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: h });
        const f = await this.client.core.relayer.subscribe(h);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: f }), await this.client.core.pairing.activate({ topic: r });
      } else St(i) && (await this.client.proposal.delete(n, $e("USER_DISCONNECTED")), this.events.emit(Fe("session_connect"), { error: i.error }));
    }, this.onSessionSettleRequest = async (r, i) => {
      const { id: n, params: s } = i;
      try {
        this.isValidSessionSettleRequest(s);
        const { relay: u, controller: a, expiry: l, namespaces: h, sessionProperties: f, pairingTopic: y } = i.params, g = at({ topic: r, relay: u, expiry: l, namespaces: h, acknowledged: !0, pairingTopic: y, requiredNamespaces: {}, optionalNamespaces: {}, controller: a.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: a.publicKey, metadata: a.metadata } }, f && { sessionProperties: f });
        await this.sendResult({ id: i.id, topic: r, result: !0 }), this.events.emit(Fe("session_connect"), { session: g }), this.cleanupDuplicatePairings(g);
      } catch (u) {
        await this.sendError(n, r, u), this.client.logger.error(u);
      }
    }, this.onSessionSettleResponse = async (r, i) => {
      const { id: n } = i;
      Mt(i) ? (await this.client.session.update(r, { acknowledged: !0 }), this.events.emit(Fe("session_approve", n), {})) : St(i) && (await this.client.session.delete(r, $e("USER_DISCONNECTED")), this.events.emit(Fe("session_approve", n), { error: i.error }));
    }, this.onSessionUpdateRequest = async (r, i) => {
      const { params: n, id: s } = i;
      try {
        const u = `${r}_session_update`, a = Ar.get(u);
        if (a && this.isRequestOutOfSync(a, s)) {
          this.client.logger.info(`Discarding out of sync request - ${s}`);
          return;
        }
        this.isValidUpdate(at({ topic: r }, n)), await this.client.session.update(r, { namespaces: n.namespaces }), await this.sendResult({ id: s, topic: r, result: !0 }), this.client.events.emit("session_update", { id: s, topic: r, params: n }), Ar.set(u, s);
      } catch (u) {
        await this.sendError(s, r, u), this.client.logger.error(u);
      }
    }, this.isRequestOutOfSync = (r, i) => parseInt(i.toString().slice(0, -3)) <= parseInt(r.toString().slice(0, -3)), this.onSessionUpdateResponse = (r, i) => {
      const { id: n } = i;
      Mt(i) ? this.events.emit(Fe("session_update", n), {}) : St(i) && this.events.emit(Fe("session_update", n), { error: i.error });
    }, this.onSessionExtendRequest = async (r, i) => {
      const { id: n } = i;
      try {
        this.isValidExtend({ topic: r }), await this.setExpiry(r, ft(ni)), await this.sendResult({ id: n, topic: r, result: !0 }), this.client.events.emit("session_extend", { id: n, topic: r });
      } catch (s) {
        await this.sendError(n, r, s), this.client.logger.error(s);
      }
    }, this.onSessionExtendResponse = (r, i) => {
      const { id: n } = i;
      Mt(i) ? this.events.emit(Fe("session_extend", n), {}) : St(i) && this.events.emit(Fe("session_extend", n), { error: i.error });
    }, this.onSessionPingRequest = async (r, i) => {
      const { id: n } = i;
      try {
        this.isValidPing({ topic: r }), await this.sendResult({ id: n, topic: r, result: !0 }), this.client.events.emit("session_ping", { id: n, topic: r });
      } catch (s) {
        await this.sendError(n, r, s), this.client.logger.error(s);
      }
    }, this.onSessionPingResponse = (r, i) => {
      const { id: n } = i;
      setTimeout(() => {
        Mt(i) ? this.events.emit(Fe("session_ping", n), {}) : St(i) && this.events.emit(Fe("session_ping", n), { error: i.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (r, i) => {
      const { id: n } = i;
      try {
        this.isValidDisconnect({ topic: r, reason: i.params }), await Promise.all([new Promise((s) => {
          this.client.core.relayer.once(nt.publish, async () => {
            s(await this.deleteSession({ topic: r, id: n }));
          });
        }), this.sendResult({ id: n, topic: r, result: !0 }), this.cleanupPendingSentRequestsForTopic({ topic: r, error: $e("USER_DISCONNECTED") })]);
      } catch (s) {
        this.client.logger.error(s);
      }
    }, this.onSessionRequest = async (r, i) => {
      const { id: n, params: s } = i;
      try {
        this.isValidRequest(at({ topic: r }, s));
        const u = ir(JSON.stringify(gr("wc_sessionRequest", s, n))), a = this.client.session.get(r), l = await this.getVerifyContext(u, a.peer.metadata), h = { id: n, topic: r, params: s, verifyContext: l };
        await this.setPendingSessionRequest(h), this.addSessionRequestToSessionRequestQueue(h), this.processSessionRequestQueue();
      } catch (u) {
        await this.sendError(n, r, u), this.client.logger.error(u);
      }
    }, this.onSessionRequestResponse = (r, i) => {
      const { id: n } = i;
      Mt(i) ? this.events.emit(Fe("session_request", n), { result: i.result }) : St(i) && this.events.emit(Fe("session_request", n), { error: i.error });
    }, this.onSessionEventRequest = async (r, i) => {
      const { id: n, params: s } = i;
      try {
        const u = `${r}_session_event_${s.event.name}`, a = Ar.get(u);
        if (a && this.isRequestOutOfSync(a, n)) {
          this.client.logger.info(`Discarding out of sync request - ${n}`);
          return;
        }
        this.isValidEmit(at({ topic: r }, s)), this.client.events.emit("session_event", { id: n, topic: r, params: s }), Ar.set(u, n);
      } catch (u) {
        await this.sendError(n, r, u), this.client.logger.error(u);
      }
    }, this.addSessionRequestToSessionRequestQueue = (r) => {
      this.sessionRequestQueue.queue.push(r);
    }, this.cleanupAfterResponse = (r) => {
      this.deletePendingSessionRequest(r.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = Lt.idle, this.processSessionRequestQueue();
      }, Q.toMiliseconds(this.requestQueueDelay));
    }, this.cleanupPendingSentRequestsForTopic = ({ topic: r, error: i }) => {
      const n = this.client.core.history.pending;
      n.length > 0 && n.filter((s) => s.topic === r && s.request.method === "wc_sessionRequest").forEach((s) => {
        this.events.emit(Fe("session_request", s.request.id), { error: i });
      });
    }, this.processSessionRequestQueue = () => {
      if (this.sessionRequestQueue.state === Lt.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const r = this.sessionRequestQueue.queue[0];
      if (!r) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = Lt.active, this.client.events.emit("session_request", r);
      } catch (i) {
        this.client.logger.error(i);
      }
    }, this.onPairingCreated = (r) => {
      if (r.active) return;
      const i = this.client.proposal.getAll().find((n) => n.pairingTopic === r.topic);
      i && this.onSessionProposeRequest(r.topic, gr("wc_sessionPropose", { requiredNamespaces: i.requiredNamespaces, optionalNamespaces: i.optionalNamespaces, relays: i.relays, proposer: i.proposer, sessionProperties: i.sessionProperties }, i.id));
    }, this.isValidConnect = async (r) => {
      if (!ct(r)) {
        const { message: l } = H("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(r)}`);
        throw new Error(l);
      }
      const { pairingTopic: i, requiredNamespaces: n, optionalNamespaces: s, sessionProperties: u, relays: a } = r;
      if (ut(i) || await this.isValidPairingTopic(i), !Xa(a)) {
        const { message: l } = H("MISSING_OR_INVALID", `connect() relays: ${a}`);
        throw new Error(l);
      }
      !ut(n) && Br(n) !== 0 && this.validateNamespaces(n, "requiredNamespaces"), !ut(s) && Br(s) !== 0 && this.validateNamespaces(s, "optionalNamespaces"), ut(u) || this.validateSessionProps(u, "sessionProperties");
    }, this.validateNamespaces = (r, i) => {
      const n = Ja(r, "connect()", i);
      if (n) throw new Error(n.message);
    }, this.isValidApprove = async (r) => {
      if (!ct(r)) throw new Error(H("MISSING_OR_INVALID", `approve() params: ${r}`).message);
      const { id: i, namespaces: n, relayProtocol: s, sessionProperties: u } = r;
      await this.isValidProposalId(i);
      const a = this.client.proposal.get(i), l = ai(n, "approve()");
      if (l) throw new Error(l.message);
      const h = _n(a.requiredNamespaces, n, "approve()");
      if (h) throw new Error(h.message);
      if (!Ke(s, !0)) {
        const { message: f } = H("MISSING_OR_INVALID", `approve() relayProtocol: ${s}`);
        throw new Error(f);
      }
      ut(u) || this.validateSessionProps(u, "sessionProperties");
    }, this.isValidReject = async (r) => {
      if (!ct(r)) {
        const { message: s } = H("MISSING_OR_INVALID", `reject() params: ${r}`);
        throw new Error(s);
      }
      const { id: i, reason: n } = r;
      if (await this.isValidProposalId(i), !Za(n)) {
        const { message: s } = H("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(n)}`);
        throw new Error(s);
      }
    }, this.isValidSessionSettleRequest = (r) => {
      if (!ct(r)) {
        const { message: h } = H("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${r}`);
        throw new Error(h);
      }
      const { relay: i, controller: n, namespaces: s, expiry: u } = r;
      if (!Hn(i)) {
        const { message: h } = H("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(h);
      }
      const a = Va(n, "onSessionSettleRequest()");
      if (a) throw new Error(a.message);
      const l = ai(s, "onSessionSettleRequest()");
      if (l) throw new Error(l.message);
      if (jt(u)) {
        const { message: h } = H("EXPIRED", "onSessionSettleRequest()");
        throw new Error(h);
      }
    }, this.isValidUpdate = async (r) => {
      if (!ct(r)) {
        const { message: l } = H("MISSING_OR_INVALID", `update() params: ${r}`);
        throw new Error(l);
      }
      const { topic: i, namespaces: n } = r;
      await this.isValidSessionTopic(i);
      const s = this.client.session.get(i), u = ai(n, "update()");
      if (u) throw new Error(u.message);
      const a = _n(s.requiredNamespaces, n, "update()");
      if (a) throw new Error(a.message);
    }, this.isValidExtend = async (r) => {
      if (!ct(r)) {
        const { message: n } = H("MISSING_OR_INVALID", `extend() params: ${r}`);
        throw new Error(n);
      }
      const { topic: i } = r;
      await this.isValidSessionTopic(i);
    }, this.isValidRequest = async (r) => {
      if (!ct(r)) {
        const { message: l } = H("MISSING_OR_INVALID", `request() params: ${r}`);
        throw new Error(l);
      }
      const { topic: i, request: n, chainId: s, expiry: u } = r;
      await this.isValidSessionTopic(i);
      const { namespaces: a } = this.client.session.get(i);
      if (!bn(a, s)) {
        const { message: l } = H("MISSING_OR_INVALID", `request() chainId: ${s}`);
        throw new Error(l);
      }
      if (!ec(n)) {
        const { message: l } = H("MISSING_OR_INVALID", `request() ${JSON.stringify(n)}`);
        throw new Error(l);
      }
      if (!ic(a, s, n.method)) {
        const { message: l } = H("MISSING_OR_INVALID", `request() method: ${n.method}`);
        throw new Error(l);
      }
      if (u && !sc(u, Wi)) {
        const { message: l } = H("MISSING_OR_INVALID", `request() expiry: ${u}. Expiry must be a number (in seconds) between ${Wi.min} and ${Wi.max}`);
        throw new Error(l);
      }
    }, this.isValidRespond = async (r) => {
      var i;
      if (!ct(r)) {
        const { message: u } = H("MISSING_OR_INVALID", `respond() params: ${r}`);
        throw new Error(u);
      }
      const { topic: n, response: s } = r;
      try {
        await this.isValidSessionTopic(n);
      } catch (u) {
        throw (i = r == null ? void 0 : r.response) != null && i.id && this.cleanupAfterResponse(r), u;
      }
      if (!tc(s)) {
        const { message: u } = H("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(s)}`);
        throw new Error(u);
      }
    }, this.isValidPing = async (r) => {
      if (!ct(r)) {
        const { message: n } = H("MISSING_OR_INVALID", `ping() params: ${r}`);
        throw new Error(n);
      }
      const { topic: i } = r;
      await this.isValidSessionOrPairingTopic(i);
    }, this.isValidEmit = async (r) => {
      if (!ct(r)) {
        const { message: a } = H("MISSING_OR_INVALID", `emit() params: ${r}`);
        throw new Error(a);
      }
      const { topic: i, event: n, chainId: s } = r;
      await this.isValidSessionTopic(i);
      const { namespaces: u } = this.client.session.get(i);
      if (!bn(u, s)) {
        const { message: a } = H("MISSING_OR_INVALID", `emit() chainId: ${s}`);
        throw new Error(a);
      }
      if (!rc(n)) {
        const { message: a } = H("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(n)}`);
        throw new Error(a);
      }
      if (!nc(u, s, n.name)) {
        const { message: a } = H("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(n)}`);
        throw new Error(a);
      }
    }, this.isValidDisconnect = async (r) => {
      if (!ct(r)) {
        const { message: n } = H("MISSING_OR_INVALID", `disconnect() params: ${r}`);
        throw new Error(n);
      }
      const { topic: i } = r;
      await this.isValidSessionOrPairingTopic(i);
    }, this.getVerifyContext = async (r, i) => {
      const n = { verified: { verifyUrl: i.verifyUrl || pr, validation: "UNKNOWN", origin: i.url || "" } };
      try {
        const s = await this.client.core.verify.resolve({ attestationId: r, verifyUrl: i.verifyUrl });
        s && (n.verified.origin = s.origin, n.verified.isScam = s.isScam, n.verified.validation = s.origin === new URL(i.url).origin ? "VALID" : "INVALID");
      } catch (s) {
        this.client.logger.info(s);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(n)}`), n;
    }, this.validateSessionProps = (r, i) => {
      Object.values(r).forEach((n) => {
        if (!Ke(n, !1)) {
          const { message: s } = H("MISSING_OR_INVALID", `${i} must be in Record<string, string> format. Received: ${JSON.stringify(n)}`);
          throw new Error(s);
        }
      });
    };
  }
  async isInitialized() {
    if (!this.initialized) {
      const { message: e } = H("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(nt.message, async (e) => {
      const { topic: r, message: i } = e;
      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(i))) return;
      const n = await this.client.core.crypto.decode(r, i);
      try {
        Jn(n) ? (this.client.core.history.set(r, n), this.onRelayEventRequest({ topic: r, payload: n })) : Oi(n) ? (await this.client.core.history.resolve(n), await this.onRelayEventResponse({ topic: r, payload: n }), this.client.core.history.delete(r, n.id)) : this.onRelayEventUnknownPayload({ topic: r, payload: n });
      } catch (s) {
        this.client.logger.error(s);
      }
    });
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(wt.expired, async (e) => {
      const { topic: r, id: i } = Kn(e.target);
      if (i && this.client.pendingRequest.keys.includes(i)) return await this.deletePendingSessionRequest(i, H("EXPIRED"), !0);
      r ? this.client.session.keys.includes(r) && (await this.deleteSession({ topic: r, expirerHasDeleted: !0 }), this.client.events.emit("session_expire", { topic: r })) : i && (await this.deleteProposal(i, !0), this.client.events.emit("proposal_expire", { id: i }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(Cr.create, (e) => this.onPairingCreated(e));
  }
  isValidPairingTopic(e) {
    if (!Ke(e, !1)) {
      const { message: r } = H("MISSING_OR_INVALID", `pairing topic should be a string: ${e}`);
      throw new Error(r);
    }
    if (!this.client.core.pairing.pairings.keys.includes(e)) {
      const { message: r } = H("NO_MATCHING_KEY", `pairing topic doesn't exist: ${e}`);
      throw new Error(r);
    }
    if (jt(this.client.core.pairing.pairings.get(e).expiry)) {
      const { message: r } = H("EXPIRED", `pairing topic: ${e}`);
      throw new Error(r);
    }
  }
  async isValidSessionTopic(e) {
    if (!Ke(e, !1)) {
      const { message: r } = H("MISSING_OR_INVALID", `session topic should be a string: ${e}`);
      throw new Error(r);
    }
    if (!this.client.session.keys.includes(e)) {
      const { message: r } = H("NO_MATCHING_KEY", `session topic doesn't exist: ${e}`);
      throw new Error(r);
    }
    if (jt(this.client.session.get(e).expiry)) {
      await this.deleteSession({ topic: e });
      const { message: r } = H("EXPIRED", `session topic: ${e}`);
      throw new Error(r);
    }
    if (!this.client.core.crypto.keychain.has(e)) {
      const { message: r } = H("MISSING_OR_INVALID", `session topic does not exist in keychain: ${e}`);
      throw await this.deleteSession({ topic: e }), new Error(r);
    }
  }
  async isValidSessionOrPairingTopic(e) {
    if (this.client.session.keys.includes(e)) await this.isValidSessionTopic(e);
    else if (this.client.core.pairing.pairings.keys.includes(e)) this.isValidPairingTopic(e);
    else if (Ke(e, !1)) {
      const { message: r } = H("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${e}`);
      throw new Error(r);
    } else {
      const { message: r } = H("MISSING_OR_INVALID", `session or pairing topic should be a string: ${e}`);
      throw new Error(r);
    }
  }
  async isValidProposalId(e) {
    if (!Qa(e)) {
      const { message: r } = H("MISSING_OR_INVALID", `proposal id should be a number: ${e}`);
      throw new Error(r);
    }
    if (!this.client.proposal.keys.includes(e)) {
      const { message: r } = H("NO_MATCHING_KEY", `proposal id doesn't exist: ${e}`);
      throw new Error(r);
    }
    if (jt(this.client.proposal.get(e).expiryTimestamp)) {
      await this.deleteProposal(e);
      const { message: r } = H("EXPIRED", `proposal id: ${e}`);
      throw new Error(r);
    }
  }
}
class f1 extends Ti {
  constructor(e, r) {
    super(e, r, e1, Zn), this.core = e, this.logger = r;
  }
}
class d1 extends Ti {
  constructor(e, r) {
    super(e, r, r1, Zn), this.core = e, this.logger = r;
  }
}
class p1 extends Ti {
  constructor(e, r) {
    super(e, r, n1, Zn, (i) => i.id), this.core = e, this.logger = r;
  }
}
class Uc extends fp {
  constructor(e) {
    super(e), this.protocol = Cc, this.version = Fc, this.name = ki.name, this.events = new Rt.EventEmitter(), this.on = (i, n) => this.events.on(i, n), this.once = (i, n) => this.events.once(i, n), this.off = (i, n) => this.events.off(i, n), this.removeListener = (i, n) => this.events.removeListener(i, n), this.removeAllListeners = (i) => this.events.removeAllListeners(i), this.connect = async (i) => {
      try {
        return await this.engine.connect(i);
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.pair = async (i) => {
      try {
        return await this.engine.pair(i);
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.approve = async (i) => {
      try {
        return await this.engine.approve(i);
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.reject = async (i) => {
      try {
        return await this.engine.reject(i);
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.update = async (i) => {
      try {
        return await this.engine.update(i);
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.extend = async (i) => {
      try {
        return await this.engine.extend(i);
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.request = async (i) => {
      try {
        return await this.engine.request(i);
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.respond = async (i) => {
      try {
        return await this.engine.respond(i);
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.ping = async (i) => {
      try {
        return await this.engine.ping(i);
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.emit = async (i) => {
      try {
        return await this.engine.emit(i);
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.disconnect = async (i) => {
      try {
        return await this.engine.disconnect(i);
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.find = (i) => {
      try {
        return this.engine.find(i);
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.name = (e == null ? void 0 : e.name) || ki.name, this.metadata = (e == null ? void 0 : e.metadata) || wa();
    const r = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : be.pino(be.getDefaultLoggerOptions({ level: (e == null ? void 0 : e.logger) || ki.logger }));
    this.core = (e == null ? void 0 : e.core) || new Z0(e), this.logger = be.generateChildLogger(r, this.name), this.session = new d1(this.core, this.logger), this.proposal = new f1(this.core, this.logger), this.pendingRequest = new p1(this.core, this.logger), this.engine = new l1(this);
  }
  static async init(e) {
    const r = new Uc(e);
    return await r.initialize(), r;
  }
  get context() {
    return be.getLoggerContext(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({ verifyUrl: this.metadata.verifyUrl }), this.logger.info("SignClient Initialization Success");
    } catch (e) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(e.message), e;
    }
  }
}
export {
  cg as I,
  Uc as Q,
  $e as U,
  ep as a,
  Ei as b,
  gr as c,
  St as d,
  Oi as e,
  Yn as f,
  yc as g,
  Wn as h,
  T1 as i,
  t1 as j,
  hl as k,
  P1 as l,
  $p as p,
  dl as r,
  Gr as s
};
//# sourceMappingURL=index.es-DXdhvOMr.js.map
