"use client";
var tD = Object.defineProperty;
var pC = (e) => {
  throw TypeError(e);
};
var nD = (e, t, n) => t in e ? tD(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var pr = (e, t, n) => nD(e, typeof t != "symbol" ? t + "" : t, n), km = (e, t, n) => t.has(e) || pC("Cannot " + n);
var X = (e, t, n) => (km(e, t, "read from private field"), n ? n.call(e) : t.get(e)), Ye = (e, t, n) => t.has(e) ? pC("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n), Pe = (e, t, n, r) => (km(e, t, "write to private field"), r ? r.call(e, n) : t.set(e, n), n), mt = (e, t, n) => (km(e, t, "access private method"), n);
var Cf = (e, t, n, r) => ({
  set _(i) {
    Pe(e, t, i, n);
  },
  get _() {
    return X(e, t, r);
  }
});
import * as P from "react";
import I, { createElement as Rr, isValidElement as $l, Fragment as Tc, cloneElement as rD, Children as sA, createContext as Ge, useContext as we, useState as Oe, useRef as It, useEffect as Te, useCallback as Ie, useMemo as J, useSyncExternalStore as Dr, useLayoutEffect as js, useReducer as _c, useId as M0, Component as iD, useInsertionEffect as aA, forwardRef as lA, memo as Td, useDeferredValue as sh, StrictMode as oD } from "react";
import * as Sp from "react-dom";
import cA, { createPortal as uA, flushSync as dA } from "react-dom";
function sD(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var fA = { exports: {} }, yn = fA.exports = {}, Li, Ui;
function bv() {
  throw new Error("setTimeout has not been defined");
}
function wv() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? Li = setTimeout : Li = bv;
  } catch {
    Li = bv;
  }
  try {
    typeof clearTimeout == "function" ? Ui = clearTimeout : Ui = wv;
  } catch {
    Ui = wv;
  }
})();
function hA(e) {
  if (Li === setTimeout)
    return setTimeout(e, 0);
  if ((Li === bv || !Li) && setTimeout)
    return Li = setTimeout, setTimeout(e, 0);
  try {
    return Li(e, 0);
  } catch {
    try {
      return Li.call(null, e, 0);
    } catch {
      return Li.call(this, e, 0);
    }
  }
}
function aD(e) {
  if (Ui === clearTimeout)
    return clearTimeout(e);
  if ((Ui === wv || !Ui) && clearTimeout)
    return Ui = clearTimeout, clearTimeout(e);
  try {
    return Ui(e);
  } catch {
    try {
      return Ui.call(null, e);
    } catch {
      return Ui.call(this, e);
    }
  }
}
var vo = [], El = !1, ra, ah = -1;
function lD() {
  !El || !ra || (El = !1, ra.length ? vo = ra.concat(vo) : ah = -1, vo.length && pA());
}
function pA() {
  if (!El) {
    var e = hA(lD);
    El = !0;
    for (var t = vo.length; t; ) {
      for (ra = vo, vo = []; ++ah < t; )
        ra && ra[ah].run();
      ah = -1, t = vo.length;
    }
    ra = null, El = !1, aD(e);
  }
}
yn.nextTick = function(e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var n = 1; n < arguments.length; n++)
      t[n - 1] = arguments[n];
  vo.push(new yA(e, t)), vo.length === 1 && !El && hA(pA);
};
function yA(e, t) {
  this.fun = e, this.array = t;
}
yA.prototype.run = function() {
  this.fun.apply(null, this.array);
};
yn.title = "browser";
yn.browser = !0;
yn.env = {};
yn.argv = [];
yn.version = "";
yn.versions = {};
function Fo() {
}
yn.on = Fo;
yn.addListener = Fo;
yn.once = Fo;
yn.off = Fo;
yn.removeListener = Fo;
yn.removeAllListeners = Fo;
yn.emit = Fo;
yn.prependListener = Fo;
yn.prependOnceListener = Fo;
yn.listeners = function(e) {
  return [];
};
yn.binding = function(e) {
  throw new Error("process.binding is not supported");
};
yn.cwd = function() {
  return "/";
};
yn.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
yn.umask = function() {
  return 0;
};
var cD = fA.exports;
const ke = /* @__PURE__ */ sD(cD);
var pu = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function F0(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function Wve(e) {
  if (e.__esModule) return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[r];
      }
    });
  }), n;
}
var xv = { exports: {} }, Jc = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var yC;
function uD() {
  if (yC) return Jc;
  yC = 1;
  var e = I, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, l, c) {
    var u, d = {}, f = null, h = null;
    c !== void 0 && (f = "" + c), l.key !== void 0 && (f = "" + l.key), l.ref !== void 0 && (h = l.ref);
    for (u in l) r.call(l, u) && !o.hasOwnProperty(u) && (d[u] = l[u]);
    if (a && a.defaultProps) for (u in l = a.defaultProps, l) d[u] === void 0 && (d[u] = l[u]);
    return { $$typeof: t, type: a, key: f, ref: h, props: d, _owner: i.current };
  }
  return Jc.Fragment = n, Jc.jsx = s, Jc.jsxs = s, Jc;
}
var Xc = {}, mC;
function dD() {
  return mC || (mC = 1, ke.env.NODE_ENV !== "production" && function() {
    var e = I, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), u = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), p = Symbol.iterator, m = "@@iterator";
    function g(j) {
      if (j === null || typeof j != "object")
        return null;
      var te = p && j[p] || j[m];
      return typeof te == "function" ? te : null;
    }
    var v = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(j) {
      {
        for (var te = arguments.length, le = new Array(te > 1 ? te - 1 : 0), ge = 1; ge < te; ge++)
          le[ge - 1] = arguments[ge];
        x("error", j, le);
      }
    }
    function x(j, te, le) {
      {
        var ge = v.ReactDebugCurrentFrame, me = ge.getStackAddendum();
        me !== "" && (te += "%s", le = le.concat([me]));
        var Ee = le.map(function(Ce) {
          return String(Ce);
        });
        Ee.unshift("Warning: " + te), Function.prototype.apply.call(console[j], console, Ee);
      }
    }
    var C = !1, S = !1, k = !1, A = !1, b = !1, T;
    T = Symbol.for("react.module.reference");
    function R(j) {
      return !!(typeof j == "string" || typeof j == "function" || j === r || j === o || b || j === i || j === c || j === u || A || j === h || C || S || k || typeof j == "object" && j !== null && (j.$$typeof === f || j.$$typeof === d || j.$$typeof === s || j.$$typeof === a || j.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      j.$$typeof === T || j.getModuleId !== void 0));
    }
    function B(j, te, le) {
      var ge = j.displayName;
      if (ge)
        return ge;
      var me = te.displayName || te.name || "";
      return me !== "" ? le + "(" + me + ")" : le;
    }
    function O(j) {
      return j.displayName || "Context";
    }
    function L(j) {
      if (j == null)
        return null;
      if (typeof j.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof j == "function")
        return j.displayName || j.name || null;
      if (typeof j == "string")
        return j;
      switch (j) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case o:
          return "Profiler";
        case i:
          return "StrictMode";
        case c:
          return "Suspense";
        case u:
          return "SuspenseList";
      }
      if (typeof j == "object")
        switch (j.$$typeof) {
          case a:
            var te = j;
            return O(te) + ".Consumer";
          case s:
            var le = j;
            return O(le._context) + ".Provider";
          case l:
            return B(j, j.render, "ForwardRef");
          case d:
            var ge = j.displayName || null;
            return ge !== null ? ge : L(j.type) || "Memo";
          case f: {
            var me = j, Ee = me._payload, Ce = me._init;
            try {
              return L(Ce(Ee));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var V = Object.assign, N = 0, M, U, F, $, ie, he, ae;
    function se() {
    }
    se.__reactDisabledLog = !0;
    function oe() {
      {
        if (N === 0) {
          M = console.log, U = console.info, F = console.warn, $ = console.error, ie = console.group, he = console.groupCollapsed, ae = console.groupEnd;
          var j = {
            configurable: !0,
            enumerable: !0,
            value: se,
            writable: !0
          };
          Object.defineProperties(console, {
            info: j,
            log: j,
            warn: j,
            error: j,
            group: j,
            groupCollapsed: j,
            groupEnd: j
          });
        }
        N++;
      }
    }
    function ye() {
      {
        if (N--, N === 0) {
          var j = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: V({}, j, {
              value: M
            }),
            info: V({}, j, {
              value: U
            }),
            warn: V({}, j, {
              value: F
            }),
            error: V({}, j, {
              value: $
            }),
            group: V({}, j, {
              value: ie
            }),
            groupCollapsed: V({}, j, {
              value: he
            }),
            groupEnd: V({}, j, {
              value: ae
            })
          });
        }
        N < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ve = v.ReactCurrentDispatcher, Be;
    function it(j, te, le) {
      {
        if (Be === void 0)
          try {
            throw Error();
          } catch (me) {
            var ge = me.stack.trim().match(/\n( *(at )?)/);
            Be = ge && ge[1] || "";
          }
        return `
` + Be + j;
      }
    }
    var lt = !1, yt;
    {
      var gt = typeof WeakMap == "function" ? WeakMap : Map;
      yt = new gt();
    }
    function vt(j, te) {
      if (!j || lt)
        return "";
      {
        var le = yt.get(j);
        if (le !== void 0)
          return le;
      }
      var ge;
      lt = !0;
      var me = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Ee;
      Ee = ve.current, ve.current = null, oe();
      try {
        if (te) {
          var Ce = function() {
            throw Error();
          };
          if (Object.defineProperty(Ce.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Ce, []);
            } catch (on) {
              ge = on;
            }
            Reflect.construct(j, [], Ce);
          } else {
            try {
              Ce.call();
            } catch (on) {
              ge = on;
            }
            j.call(Ce.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (on) {
            ge = on;
          }
          j();
        }
      } catch (on) {
        if (on && ge && typeof on.stack == "string") {
          for (var xe = on.stack.split(`
`), et = ge.stack.split(`
`), We = xe.length - 1, Ke = et.length - 1; We >= 1 && Ke >= 0 && xe[We] !== et[Ke]; )
            Ke--;
          for (; We >= 1 && Ke >= 0; We--, Ke--)
            if (xe[We] !== et[Ke]) {
              if (We !== 1 || Ke !== 1)
                do
                  if (We--, Ke--, Ke < 0 || xe[We] !== et[Ke]) {
                    var rt = `
` + xe[We].replace(" at new ", " at ");
                    return j.displayName && rt.includes("<anonymous>") && (rt = rt.replace("<anonymous>", j.displayName)), typeof j == "function" && yt.set(j, rt), rt;
                  }
                while (We >= 1 && Ke >= 0);
              break;
            }
        }
      } finally {
        lt = !1, ve.current = Ee, ye(), Error.prepareStackTrace = me;
      }
      var Bt = j ? j.displayName || j.name : "", Tt = Bt ? it(Bt) : "";
      return typeof j == "function" && yt.set(j, Tt), Tt;
    }
    function ot(j, te, le) {
      return vt(j, !1);
    }
    function Le(j) {
      var te = j.prototype;
      return !!(te && te.isReactComponent);
    }
    function tt(j, te, le) {
      if (j == null)
        return "";
      if (typeof j == "function")
        return vt(j, Le(j));
      if (typeof j == "string")
        return it(j);
      switch (j) {
        case c:
          return it("Suspense");
        case u:
          return it("SuspenseList");
      }
      if (typeof j == "object")
        switch (j.$$typeof) {
          case l:
            return ot(j.render);
          case d:
            return tt(j.type, te, le);
          case f: {
            var ge = j, me = ge._payload, Ee = ge._init;
            try {
              return tt(Ee(me), te, le);
            } catch {
            }
          }
        }
      return "";
    }
    var jt = Object.prototype.hasOwnProperty, rn = {}, en = v.ReactDebugCurrentFrame;
    function Gt(j) {
      if (j) {
        var te = j._owner, le = tt(j.type, j._source, te ? te.type : null);
        en.setExtraStackFrame(le);
      } else
        en.setExtraStackFrame(null);
    }
    function jn(j, te, le, ge, me) {
      {
        var Ee = Function.call.bind(jt);
        for (var Ce in j)
          if (Ee(j, Ce)) {
            var xe = void 0;
            try {
              if (typeof j[Ce] != "function") {
                var et = Error((ge || "React class") + ": " + le + " type `" + Ce + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof j[Ce] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw et.name = "Invariant Violation", et;
              }
              xe = j[Ce](te, Ce, ge, le, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (We) {
              xe = We;
            }
            xe && !(xe instanceof Error) && (Gt(me), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ge || "React class", le, Ce, typeof xe), Gt(null)), xe instanceof Error && !(xe.message in rn) && (rn[xe.message] = !0, Gt(me), w("Failed %s type: %s", le, xe.message), Gt(null));
          }
      }
    }
    var tr = Array.isArray;
    function Ot(j) {
      return tr(j);
    }
    function qt(j) {
      {
        var te = typeof Symbol == "function" && Symbol.toStringTag, le = te && j[Symbol.toStringTag] || j.constructor.name || "Object";
        return le;
      }
    }
    function Cn(j) {
      try {
        return Ve(j), !1;
      } catch {
        return !0;
      }
    }
    function Ve(j) {
      return "" + j;
    }
    function nt(j) {
      if (Cn(j))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", qt(j)), Ve(j);
    }
    var je = v.ReactCurrentOwner, st = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, tn, D, E;
    E = {};
    function _(j) {
      if (jt.call(j, "ref")) {
        var te = Object.getOwnPropertyDescriptor(j, "ref").get;
        if (te && te.isReactWarning)
          return !1;
      }
      return j.ref !== void 0;
    }
    function q(j) {
      if (jt.call(j, "key")) {
        var te = Object.getOwnPropertyDescriptor(j, "key").get;
        if (te && te.isReactWarning)
          return !1;
      }
      return j.key !== void 0;
    }
    function Z(j, te) {
      if (typeof j.ref == "string" && je.current && te && je.current.stateNode !== te) {
        var le = L(je.current.type);
        E[le] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', L(je.current.type), j.ref), E[le] = !0);
      }
    }
    function re(j, te) {
      {
        var le = function() {
          tn || (tn = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", te));
        };
        le.isReactWarning = !0, Object.defineProperty(j, "key", {
          get: le,
          configurable: !0
        });
      }
    }
    function pe(j, te) {
      {
        var le = function() {
          D || (D = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", te));
        };
        le.isReactWarning = !0, Object.defineProperty(j, "ref", {
          get: le,
          configurable: !0
        });
      }
    }
    var He = function(j, te, le, ge, me, Ee, Ce) {
      var xe = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: j,
        key: te,
        ref: le,
        props: Ce,
        // Record the component responsible for creating this element.
        _owner: Ee
      };
      return xe._store = {}, Object.defineProperty(xe._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(xe, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ge
      }), Object.defineProperty(xe, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: me
      }), Object.freeze && (Object.freeze(xe.props), Object.freeze(xe)), xe;
    };
    function xt(j, te, le, ge, me) {
      {
        var Ee, Ce = {}, xe = null, et = null;
        le !== void 0 && (nt(le), xe = "" + le), q(te) && (nt(te.key), xe = "" + te.key), _(te) && (et = te.ref, Z(te, me));
        for (Ee in te)
          jt.call(te, Ee) && !st.hasOwnProperty(Ee) && (Ce[Ee] = te[Ee]);
        if (j && j.defaultProps) {
          var We = j.defaultProps;
          for (Ee in We)
            Ce[Ee] === void 0 && (Ce[Ee] = We[Ee]);
        }
        if (xe || et) {
          var Ke = typeof j == "function" ? j.displayName || j.name || "Unknown" : j;
          xe && re(Ce, Ke), et && pe(Ce, Ke);
        }
        return He(j, xe, et, me, ge, je.current, Ce);
      }
    }
    var St = v.ReactCurrentOwner, Ct = v.ReactDebugCurrentFrame;
    function Ze(j) {
      if (j) {
        var te = j._owner, le = tt(j.type, j._source, te ? te.type : null);
        Ct.setExtraStackFrame(le);
      } else
        Ct.setExtraStackFrame(null);
    }
    var Di;
    Di = !1;
    function kn(j) {
      return typeof j == "object" && j !== null && j.$$typeof === t;
    }
    function hi() {
      {
        if (St.current) {
          var j = L(St.current.type);
          if (j)
            return `

Check the render method of \`` + j + "`.";
        }
        return "";
      }
    }
    function so(j) {
      return "";
    }
    var ao = {};
    function Go(j) {
      {
        var te = hi();
        if (!te) {
          var le = typeof j == "string" ? j : j.displayName || j.name;
          le && (te = `

Check the top-level render call using <` + le + ">.");
        }
        return te;
      }
    }
    function lo(j, te) {
      {
        if (!j._store || j._store.validated || j.key != null)
          return;
        j._store.validated = !0;
        var le = Go(te);
        if (ao[le])
          return;
        ao[le] = !0;
        var ge = "";
        j && j._owner && j._owner !== St.current && (ge = " It was passed a child from " + L(j._owner.type) + "."), Ze(j), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', le, ge), Ze(null);
      }
    }
    function Mn(j, te) {
      {
        if (typeof j != "object")
          return;
        if (Ot(j))
          for (var le = 0; le < j.length; le++) {
            var ge = j[le];
            kn(ge) && lo(ge, te);
          }
        else if (kn(j))
          j._store && (j._store.validated = !0);
        else if (j) {
          var me = g(j);
          if (typeof me == "function" && me !== j.entries)
            for (var Ee = me.call(j), Ce; !(Ce = Ee.next()).done; )
              kn(Ce.value) && lo(Ce.value, te);
        }
      }
    }
    function ji(j) {
      {
        var te = j.type;
        if (te == null || typeof te == "string")
          return;
        var le;
        if (typeof te == "function")
          le = te.propTypes;
        else if (typeof te == "object" && (te.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        te.$$typeof === d))
          le = te.propTypes;
        else
          return;
        if (le) {
          var ge = L(te);
          jn(le, j.props, "prop", ge, j);
        } else if (te.PropTypes !== void 0 && !Di) {
          Di = !0;
          var me = L(te);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", me || "Unknown");
        }
        typeof te.getDefaultProps == "function" && !te.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Mi(j) {
      {
        for (var te = Object.keys(j.props), le = 0; le < te.length; le++) {
          var ge = te[le];
          if (ge !== "children" && ge !== "key") {
            Ze(j), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ge), Ze(null);
            break;
          }
        }
        j.ref !== null && (Ze(j), w("Invalid attribute `ref` supplied to `React.Fragment`."), Ze(null));
      }
    }
    var co = {};
    function Ho(j, te, le, ge, me, Ee) {
      {
        var Ce = R(j);
        if (!Ce) {
          var xe = "";
          (j === void 0 || typeof j == "object" && j !== null && Object.keys(j).length === 0) && (xe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var et = so();
          et ? xe += et : xe += hi();
          var We;
          j === null ? We = "null" : Ot(j) ? We = "array" : j !== void 0 && j.$$typeof === t ? (We = "<" + (L(j.type) || "Unknown") + " />", xe = " Did you accidentally export a JSX literal instead of a component?") : We = typeof j, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", We, xe);
        }
        var Ke = xt(j, te, le, me, Ee);
        if (Ke == null)
          return Ke;
        if (Ce) {
          var rt = te.children;
          if (rt !== void 0)
            if (ge)
              if (Ot(rt)) {
                for (var Bt = 0; Bt < rt.length; Bt++)
                  Mn(rt[Bt], j);
                Object.freeze && Object.freeze(rt);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Mn(rt, j);
        }
        if (jt.call(te, "key")) {
          var Tt = L(j), on = Object.keys(te).filter(function(Lr) {
            return Lr !== "key";
          }), Rn = on.length > 0 ? "{key: someKey, " + on.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!co[Tt + Rn]) {
            var pi = on.length > 0 ? "{" + on.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Rn, Tt, pi, Tt), co[Tt + Rn] = !0;
          }
        }
        return j === r ? Mi(Ke) : ji(Ke), Ke;
      }
    }
    function Ws(j, te, le) {
      return Ho(j, te, le, !0);
    }
    function Q(j, te, le) {
      return Ho(j, te, le, !1);
    }
    var ee = Q, Y = Ws;
    Xc.Fragment = r, Xc.jsx = ee, Xc.jsxs = Y;
  }()), Xc;
}
ke.env.NODE_ENV === "production" ? xv.exports = uD() : xv.exports = dD();
var y = xv.exports, Ic = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(e) {
    return this.listeners.add(e), this.onSubscribe(), () => {
      this.listeners.delete(e), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, Wl = typeof window > "u" || "Deno" in globalThis;
function Yr() {
}
function fD(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Cv(e) {
  return typeof e == "number" && e >= 0 && e !== 1 / 0;
}
function mA(e, t) {
  return Math.max(e + (t || 0) - Date.now(), 0);
}
function Sl(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Ci(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function gC(e, t) {
  const {
    type: n = "all",
    exact: r,
    fetchStatus: i,
    predicate: o,
    queryKey: s,
    stale: a
  } = e;
  if (s) {
    if (r) {
      if (t.queryHash !== L0(s, t.options))
        return !1;
    } else if (!ju(t.queryKey, s))
      return !1;
  }
  if (n !== "all") {
    const l = t.isActive();
    if (n === "active" && !l || n === "inactive" && l)
      return !1;
  }
  return !(typeof a == "boolean" && t.isStale() !== a || i && i !== t.state.fetchStatus || o && !o(t));
}
function vC(e, t) {
  const { exact: n, status: r, predicate: i, mutationKey: o } = e;
  if (o) {
    if (!t.options.mutationKey)
      return !1;
    if (n) {
      if (Ea(t.options.mutationKey) !== Ea(o))
        return !1;
    } else if (!ju(t.options.mutationKey, o))
      return !1;
  }
  return !(r && t.state.status !== r || i && !i(t));
}
function L0(e, t) {
  return ((t == null ? void 0 : t.queryKeyHashFn) || Ea)(e);
}
function Ea(e) {
  return JSON.stringify(
    e,
    (t, n) => Ev(n) ? Object.keys(n).sort().reduce((r, i) => (r[i] = n[i], r), {}) : n
  );
}
function ju(e, t) {
  return e === t ? !0 : typeof e != typeof t ? !1 : e && t && typeof e == "object" && typeof t == "object" ? !Object.keys(t).some((n) => !ju(e[n], t[n])) : !1;
}
function kv(e, t) {
  if (e === t)
    return e;
  const n = bC(e) && bC(t);
  if (n || Ev(e) && Ev(t)) {
    const r = n ? e : Object.keys(e), i = r.length, o = n ? t : Object.keys(t), s = o.length, a = n ? [] : {};
    let l = 0;
    for (let c = 0; c < s; c++) {
      const u = n ? c : o[c];
      (!n && r.includes(u) || n) && e[u] === void 0 && t[u] === void 0 ? (a[u] = void 0, l++) : (a[u] = kv(e[u], t[u]), a[u] === e[u] && e[u] !== void 0 && l++);
    }
    return i === s && l === i ? e : a;
  }
  return t;
}
function Rh(e, t) {
  if (!t || Object.keys(e).length !== Object.keys(t).length)
    return !1;
  for (const n in e)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function bC(e) {
  return Array.isArray(e) && e.length === Object.keys(e).length;
}
function Ev(e) {
  if (!wC(e))
    return !1;
  const t = e.constructor;
  if (t === void 0)
    return !0;
  const n = t.prototype;
  return !(!wC(n) || !n.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(e) !== Object.prototype);
}
function wC(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function hD(e) {
  return new Promise((t) => {
    setTimeout(t, e);
  });
}
function Sv(e, t, n) {
  if (typeof n.structuralSharing == "function")
    return n.structuralSharing(e, t);
  if (n.structuralSharing !== !1) {
    if (ke.env.NODE_ENV !== "production")
      try {
        return kv(e, t);
      } catch {
      }
    return kv(e, t);
  }
  return t;
}
function pD(e, t, n = 0) {
  const r = [...e, t];
  return n && r.length > n ? r.slice(1) : r;
}
function yD(e, t, n = 0) {
  const r = [t, ...e];
  return n && r.length > n ? r.slice(0, -1) : r;
}
var Av = Symbol();
function gA(e, t) {
  return ke.env.NODE_ENV !== "production" && e.queryFn, !e.queryFn && (t != null && t.initialPromise) ? () => t.initialPromise : !e.queryFn || e.queryFn === Av ? () => Promise.reject(new Error(`Missing queryFn: '${e.queryHash}'`)) : e.queryFn;
}
var da, os, Pl, YS, mD = (YS = class extends Ic {
  constructor() {
    super();
    Ye(this, da);
    Ye(this, os);
    Ye(this, Pl);
    Pe(this, Pl, (t) => {
      if (!Wl && window.addEventListener) {
        const n = () => t();
        return window.addEventListener("visibilitychange", n, !1), () => {
          window.removeEventListener("visibilitychange", n);
        };
      }
    });
  }
  onSubscribe() {
    X(this, os) || this.setEventListener(X(this, Pl));
  }
  onUnsubscribe() {
    var t;
    this.hasListeners() || ((t = X(this, os)) == null || t.call(this), Pe(this, os, void 0));
  }
  setEventListener(t) {
    var n;
    Pe(this, Pl, t), (n = X(this, os)) == null || n.call(this), Pe(this, os, t((r) => {
      typeof r == "boolean" ? this.setFocused(r) : this.onFocus();
    }));
  }
  setFocused(t) {
    X(this, da) !== t && (Pe(this, da, t), this.onFocus());
  }
  onFocus() {
    const t = this.isFocused();
    this.listeners.forEach((n) => {
      n(t);
    });
  }
  isFocused() {
    var t;
    return typeof X(this, da) == "boolean" ? X(this, da) : ((t = globalThis.document) == null ? void 0 : t.visibilityState) !== "hidden";
  }
}, da = new WeakMap(), os = new WeakMap(), Pl = new WeakMap(), YS), U0 = new mD(), Ol, ss, Bl, QS, gD = (QS = class extends Ic {
  constructor() {
    super();
    Ye(this, Ol, !0);
    Ye(this, ss);
    Ye(this, Bl);
    Pe(this, Bl, (t) => {
      if (!Wl && window.addEventListener) {
        const n = () => t(!0), r = () => t(!1);
        return window.addEventListener("online", n, !1), window.addEventListener("offline", r, !1), () => {
          window.removeEventListener("online", n), window.removeEventListener("offline", r);
        };
      }
    });
  }
  onSubscribe() {
    X(this, ss) || this.setEventListener(X(this, Bl));
  }
  onUnsubscribe() {
    var t;
    this.hasListeners() || ((t = X(this, ss)) == null || t.call(this), Pe(this, ss, void 0));
  }
  setEventListener(t) {
    var n;
    Pe(this, Bl, t), (n = X(this, ss)) == null || n.call(this), Pe(this, ss, t(this.setOnline.bind(this)));
  }
  setOnline(t) {
    X(this, Ol) !== t && (Pe(this, Ol, t), this.listeners.forEach((r) => {
      r(t);
    }));
  }
  isOnline() {
    return X(this, Ol);
  }
}, Ol = new WeakMap(), ss = new WeakMap(), Bl = new WeakMap(), QS), Ph = new gD();
function vD(e) {
  return Math.min(1e3 * 2 ** e, 3e4);
}
function vA(e) {
  return (e ?? "online") === "online" ? Ph.isOnline() : !0;
}
var bA = class extends Error {
  constructor(e) {
    super("CancelledError"), this.revert = e == null ? void 0 : e.revert, this.silent = e == null ? void 0 : e.silent;
  }
};
function Em(e) {
  return e instanceof bA;
}
function wA(e) {
  let t = !1, n = 0, r = !1, i, o, s;
  const a = new Promise((v, w) => {
    o = v, s = w;
  }), l = (v) => {
    var w;
    r || (p(new bA(v)), (w = e.abort) == null || w.call(e));
  }, c = () => {
    t = !0;
  }, u = () => {
    t = !1;
  }, d = () => U0.isFocused() && (e.networkMode === "always" || Ph.isOnline()) && e.canRun(), f = () => vA(e.networkMode) && e.canRun(), h = (v) => {
    var w;
    r || (r = !0, (w = e.onSuccess) == null || w.call(e, v), i == null || i(), o(v));
  }, p = (v) => {
    var w;
    r || (r = !0, (w = e.onError) == null || w.call(e, v), i == null || i(), s(v));
  }, m = () => new Promise((v) => {
    var w;
    i = (x) => {
      (r || d()) && v(x);
    }, (w = e.onPause) == null || w.call(e);
  }).then(() => {
    var v;
    i = void 0, r || (v = e.onContinue) == null || v.call(e);
  }), g = () => {
    if (r)
      return;
    let v;
    const w = n === 0 ? e.initialPromise : void 0;
    try {
      v = w ?? e.fn();
    } catch (x) {
      v = Promise.reject(x);
    }
    Promise.resolve(v).then(h).catch((x) => {
      var b;
      if (r)
        return;
      const C = e.retry ?? (Wl ? 0 : 3), S = e.retryDelay ?? vD, k = typeof S == "function" ? S(n, x) : S, A = C === !0 || typeof C == "number" && n < C || typeof C == "function" && C(n, x);
      if (t || !A) {
        p(x);
        return;
      }
      n++, (b = e.onFail) == null || b.call(e, n, x), hD(k).then(() => d() ? void 0 : m()).then(() => {
        t ? p(x) : g();
      });
    });
  };
  return {
    promise: a,
    cancel: l,
    continue: () => (i == null || i(), a),
    cancelRetry: c,
    continueRetry: u,
    canStart: f,
    start: () => (f() ? g() : m().then(g), a)
  };
}
function bD() {
  let e = [], t = 0, n = (a) => {
    a();
  }, r = (a) => {
    a();
  }, i = (a) => setTimeout(a, 0);
  const o = (a) => {
    t ? e.push(a) : i(() => {
      n(a);
    });
  }, s = () => {
    const a = e;
    e = [], a.length && i(() => {
      r(() => {
        a.forEach((l) => {
          n(l);
        });
      });
    });
  };
  return {
    batch: (a) => {
      let l;
      t++;
      try {
        l = a();
      } finally {
        t--, t || s();
      }
      return l;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (a) => (...l) => {
      o(() => {
        a(...l);
      });
    },
    schedule: o,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (a) => {
      n = a;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (a) => {
      r = a;
    },
    setScheduler: (a) => {
      i = a;
    }
  };
}
var En = bD(), fa, JS, xA = (JS = class {
  constructor() {
    Ye(this, fa);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), Cv(this.gcTime) && Pe(this, fa, setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(e) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      e ?? (Wl ? 1 / 0 : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    X(this, fa) && (clearTimeout(X(this, fa)), Pe(this, fa, void 0));
  }
}, fa = new WeakMap(), JS), Nl, Dl, Kr, qn, kd, ha, wi, yo, XS, wD = (XS = class extends xA {
  constructor(t) {
    super();
    Ye(this, wi);
    Ye(this, Nl);
    Ye(this, Dl);
    Ye(this, Kr);
    Ye(this, qn);
    Ye(this, kd);
    Ye(this, ha);
    Pe(this, ha, !1), Pe(this, kd, t.defaultOptions), this.setOptions(t.options), this.observers = [], Pe(this, Kr, t.cache), this.queryKey = t.queryKey, this.queryHash = t.queryHash, Pe(this, Nl, xD(this.options)), this.state = t.state ?? X(this, Nl), this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    var t;
    return (t = X(this, qn)) == null ? void 0 : t.promise;
  }
  setOptions(t) {
    this.options = { ...X(this, kd), ...t }, this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && X(this, Kr).remove(this);
  }
  setData(t, n) {
    const r = Sv(this.state.data, t, this.options);
    return mt(this, wi, yo).call(this, {
      data: r,
      type: "success",
      dataUpdatedAt: n == null ? void 0 : n.updatedAt,
      manual: n == null ? void 0 : n.manual
    }), r;
  }
  setState(t, n) {
    mt(this, wi, yo).call(this, { type: "setState", state: t, setStateOptions: n });
  }
  cancel(t) {
    var r, i;
    const n = (r = X(this, qn)) == null ? void 0 : r.promise;
    return (i = X(this, qn)) == null || i.cancel(t), n ? n.then(Yr).catch(Yr) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(X(this, Nl));
  }
  isActive() {
    return this.observers.some(
      (t) => Ci(t.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 && !this.isActive();
  }
  isStale() {
    return this.state.isInvalidated ? !0 : this.getObserversCount() > 0 ? this.observers.some(
      (t) => t.getCurrentResult().isStale
    ) : this.state.data === void 0;
  }
  isStaleByTime(t = 0) {
    return this.state.isInvalidated || this.state.data === void 0 || !mA(this.state.dataUpdatedAt, t);
  }
  onFocus() {
    var n;
    const t = this.observers.find((r) => r.shouldFetchOnWindowFocus());
    t == null || t.refetch({ cancelRefetch: !1 }), (n = X(this, qn)) == null || n.continue();
  }
  onOnline() {
    var n;
    const t = this.observers.find((r) => r.shouldFetchOnReconnect());
    t == null || t.refetch({ cancelRefetch: !1 }), (n = X(this, qn)) == null || n.continue();
  }
  addObserver(t) {
    this.observers.includes(t) || (this.observers.push(t), this.clearGcTimeout(), X(this, Kr).notify({ type: "observerAdded", query: this, observer: t }));
  }
  removeObserver(t) {
    this.observers.includes(t) && (this.observers = this.observers.filter((n) => n !== t), this.observers.length || (X(this, qn) && (X(this, ha) ? X(this, qn).cancel({ revert: !0 }) : X(this, qn).cancelRetry()), this.scheduleGc()), X(this, Kr).notify({ type: "observerRemoved", query: this, observer: t }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || mt(this, wi, yo).call(this, { type: "invalidate" });
  }
  fetch(t, n) {
    var l, c, u;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && (n != null && n.cancelRefetch))
        this.cancel({ silent: !0 });
      else if (X(this, qn))
        return X(this, qn).continueRetry(), X(this, qn).promise;
    }
    if (t && this.setOptions(t), !this.options.queryFn) {
      const d = this.observers.find((f) => f.options.queryFn);
      d && this.setOptions(d.options);
    }
    ke.env.NODE_ENV !== "production" && Array.isArray(this.options.queryKey);
    const r = new AbortController(), i = (d) => {
      Object.defineProperty(d, "signal", {
        enumerable: !0,
        get: () => (Pe(this, ha, !0), r.signal)
      });
    }, o = () => {
      const d = gA(this.options, n), f = {
        queryKey: this.queryKey,
        meta: this.meta
      };
      return i(f), Pe(this, ha, !1), this.options.persister ? this.options.persister(
        d,
        f,
        this
      ) : d(f);
    }, s = {
      fetchOptions: n,
      options: this.options,
      queryKey: this.queryKey,
      state: this.state,
      fetchFn: o
    };
    i(s), (l = this.options.behavior) == null || l.onFetch(
      s,
      this
    ), Pe(this, Dl, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((c = s.fetchOptions) == null ? void 0 : c.meta)) && mt(this, wi, yo).call(this, { type: "fetch", meta: (u = s.fetchOptions) == null ? void 0 : u.meta });
    const a = (d) => {
      var f, h, p, m;
      Em(d) && d.silent || mt(this, wi, yo).call(this, {
        type: "error",
        error: d
      }), Em(d) || ((h = (f = X(this, Kr).config).onError) == null || h.call(
        f,
        d,
        this
      ), (m = (p = X(this, Kr).config).onSettled) == null || m.call(
        p,
        this.state.data,
        d,
        this
      )), this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1;
    };
    return Pe(this, qn, wA({
      initialPromise: n == null ? void 0 : n.initialPromise,
      fn: s.fetchFn,
      abort: r.abort.bind(r),
      onSuccess: (d) => {
        var f, h, p, m;
        if (d === void 0) {
          ke.env.NODE_ENV, a(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        try {
          this.setData(d);
        } catch (g) {
          a(g);
          return;
        }
        (h = (f = X(this, Kr).config).onSuccess) == null || h.call(f, d, this), (m = (p = X(this, Kr).config).onSettled) == null || m.call(
          p,
          d,
          this.state.error,
          this
        ), this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1;
      },
      onError: a,
      onFail: (d, f) => {
        mt(this, wi, yo).call(this, { type: "failed", failureCount: d, error: f });
      },
      onPause: () => {
        mt(this, wi, yo).call(this, { type: "pause" });
      },
      onContinue: () => {
        mt(this, wi, yo).call(this, { type: "continue" });
      },
      retry: s.options.retry,
      retryDelay: s.options.retryDelay,
      networkMode: s.options.networkMode,
      canRun: () => !0
    })), X(this, qn).start();
  }
}, Nl = new WeakMap(), Dl = new WeakMap(), Kr = new WeakMap(), qn = new WeakMap(), kd = new WeakMap(), ha = new WeakMap(), wi = new WeakSet(), yo = function(t) {
  const n = (r) => {
    switch (t.type) {
      case "failed":
        return {
          ...r,
          fetchFailureCount: t.failureCount,
          fetchFailureReason: t.error
        };
      case "pause":
        return {
          ...r,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...r,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...r,
          ...CA(r.data, this.options),
          fetchMeta: t.meta ?? null
        };
      case "success":
        return {
          ...r,
          data: t.data,
          dataUpdateCount: r.dataUpdateCount + 1,
          dataUpdatedAt: t.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: !1,
          status: "success",
          ...!t.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
      case "error":
        const i = t.error;
        return Em(i) && i.revert && X(this, Dl) ? { ...X(this, Dl), fetchStatus: "idle" } : {
          ...r,
          error: i,
          errorUpdateCount: r.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: r.fetchFailureCount + 1,
          fetchFailureReason: i,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...r,
          isInvalidated: !0
        };
      case "setState":
        return {
          ...r,
          ...t.state
        };
    }
  };
  this.state = n(this.state), En.batch(() => {
    this.observers.forEach((r) => {
      r.onQueryUpdate();
    }), X(this, Kr).notify({ query: this, type: "updated", action: t });
  });
}, XS);
function CA(e, t) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: vA(t.networkMode) ? "fetching" : "paused",
    ...e === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function xD(e) {
  const t = typeof e.initialData == "function" ? e.initialData() : e.initialData, n = t !== void 0, r = n ? typeof e.initialDataUpdatedAt == "function" ? e.initialDataUpdatedAt() : e.initialDataUpdatedAt : 0;
  return {
    data: t,
    dataUpdateCount: 0,
    dataUpdatedAt: n ? r ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: n ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var zi, ZS, CD = (ZS = class extends Ic {
  constructor(t = {}) {
    super();
    Ye(this, zi);
    this.config = t, Pe(this, zi, /* @__PURE__ */ new Map());
  }
  build(t, n, r) {
    const i = n.queryKey, o = n.queryHash ?? L0(i, n);
    let s = this.get(o);
    return s || (s = new wD({
      cache: this,
      queryKey: i,
      queryHash: o,
      options: t.defaultQueryOptions(n),
      state: r,
      defaultOptions: t.getQueryDefaults(i)
    }), this.add(s)), s;
  }
  add(t) {
    X(this, zi).has(t.queryHash) || (X(this, zi).set(t.queryHash, t), this.notify({
      type: "added",
      query: t
    }));
  }
  remove(t) {
    const n = X(this, zi).get(t.queryHash);
    n && (t.destroy(), n === t && X(this, zi).delete(t.queryHash), this.notify({ type: "removed", query: t }));
  }
  clear() {
    En.batch(() => {
      this.getAll().forEach((t) => {
        this.remove(t);
      });
    });
  }
  get(t) {
    return X(this, zi).get(t);
  }
  getAll() {
    return [...X(this, zi).values()];
  }
  find(t) {
    const n = { exact: !0, ...t };
    return this.getAll().find(
      (r) => gC(n, r)
    );
  }
  findAll(t = {}) {
    const n = this.getAll();
    return Object.keys(t).length > 0 ? n.filter((r) => gC(t, r)) : n;
  }
  notify(t) {
    En.batch(() => {
      this.listeners.forEach((n) => {
        n(t);
      });
    });
  }
  onFocus() {
    En.batch(() => {
      this.getAll().forEach((t) => {
        t.onFocus();
      });
    });
  }
  onOnline() {
    En.batch(() => {
      this.getAll().forEach((t) => {
        t.onOnline();
      });
    });
  }
}, zi = new WeakMap(), ZS), Vi, rr, pa, qi, es, eA, kD = (eA = class extends xA {
  constructor(t) {
    super();
    Ye(this, qi);
    Ye(this, Vi);
    Ye(this, rr);
    Ye(this, pa);
    this.mutationId = t.mutationId, Pe(this, rr, t.mutationCache), Pe(this, Vi, []), this.state = t.state || kA(), this.setOptions(t.options), this.scheduleGc();
  }
  setOptions(t) {
    this.options = t, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(t) {
    X(this, Vi).includes(t) || (X(this, Vi).push(t), this.clearGcTimeout(), X(this, rr).notify({
      type: "observerAdded",
      mutation: this,
      observer: t
    }));
  }
  removeObserver(t) {
    Pe(this, Vi, X(this, Vi).filter((n) => n !== t)), this.scheduleGc(), X(this, rr).notify({
      type: "observerRemoved",
      mutation: this,
      observer: t
    });
  }
  optionalRemove() {
    X(this, Vi).length || (this.state.status === "pending" ? this.scheduleGc() : X(this, rr).remove(this));
  }
  continue() {
    var t;
    return ((t = X(this, pa)) == null ? void 0 : t.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(t) {
    var i, o, s, a, l, c, u, d, f, h, p, m, g, v, w, x, C, S, k, A;
    Pe(this, pa, wA({
      fn: () => this.options.mutationFn ? this.options.mutationFn(t) : Promise.reject(new Error("No mutationFn found")),
      onFail: (b, T) => {
        mt(this, qi, es).call(this, { type: "failed", failureCount: b, error: T });
      },
      onPause: () => {
        mt(this, qi, es).call(this, { type: "pause" });
      },
      onContinue: () => {
        mt(this, qi, es).call(this, { type: "continue" });
      },
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => X(this, rr).canRun(this)
    }));
    const n = this.state.status === "pending", r = !X(this, pa).canStart();
    try {
      if (!n) {
        mt(this, qi, es).call(this, { type: "pending", variables: t, isPaused: r }), await ((o = (i = X(this, rr).config).onMutate) == null ? void 0 : o.call(
          i,
          t,
          this
        ));
        const T = await ((a = (s = this.options).onMutate) == null ? void 0 : a.call(s, t));
        T !== this.state.context && mt(this, qi, es).call(this, {
          type: "pending",
          context: T,
          variables: t,
          isPaused: r
        });
      }
      const b = await X(this, pa).start();
      return await ((c = (l = X(this, rr).config).onSuccess) == null ? void 0 : c.call(
        l,
        b,
        t,
        this.state.context,
        this
      )), await ((d = (u = this.options).onSuccess) == null ? void 0 : d.call(u, b, t, this.state.context)), await ((h = (f = X(this, rr).config).onSettled) == null ? void 0 : h.call(
        f,
        b,
        null,
        this.state.variables,
        this.state.context,
        this
      )), await ((m = (p = this.options).onSettled) == null ? void 0 : m.call(p, b, null, t, this.state.context)), mt(this, qi, es).call(this, { type: "success", data: b }), b;
    } catch (b) {
      try {
        throw await ((v = (g = X(this, rr).config).onError) == null ? void 0 : v.call(
          g,
          b,
          t,
          this.state.context,
          this
        )), await ((x = (w = this.options).onError) == null ? void 0 : x.call(
          w,
          b,
          t,
          this.state.context
        )), await ((S = (C = X(this, rr).config).onSettled) == null ? void 0 : S.call(
          C,
          void 0,
          b,
          this.state.variables,
          this.state.context,
          this
        )), await ((A = (k = this.options).onSettled) == null ? void 0 : A.call(
          k,
          void 0,
          b,
          t,
          this.state.context
        )), b;
      } finally {
        mt(this, qi, es).call(this, { type: "error", error: b });
      }
    } finally {
      X(this, rr).runNext(this);
    }
  }
}, Vi = new WeakMap(), rr = new WeakMap(), pa = new WeakMap(), qi = new WeakSet(), es = function(t) {
  const n = (r) => {
    switch (t.type) {
      case "failed":
        return {
          ...r,
          failureCount: t.failureCount,
          failureReason: t.error
        };
      case "pause":
        return {
          ...r,
          isPaused: !0
        };
      case "continue":
        return {
          ...r,
          isPaused: !1
        };
      case "pending":
        return {
          ...r,
          context: t.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: t.isPaused,
          status: "pending",
          variables: t.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...r,
          data: t.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: !1
        };
      case "error":
        return {
          ...r,
          data: void 0,
          error: t.error,
          failureCount: r.failureCount + 1,
          failureReason: t.error,
          isPaused: !1,
          status: "error"
        };
    }
  };
  this.state = n(this.state), En.batch(() => {
    X(this, Vi).forEach((r) => {
      r.onMutationUpdate(t);
    }), X(this, rr).notify({
      mutation: this,
      type: "updated",
      action: t
    });
  });
}, eA);
function kA() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var Tr, Ed, tA, ED = (tA = class extends Ic {
  constructor(t = {}) {
    super();
    Ye(this, Tr);
    Ye(this, Ed);
    this.config = t, Pe(this, Tr, /* @__PURE__ */ new Map()), Pe(this, Ed, Date.now());
  }
  build(t, n, r) {
    const i = new kD({
      mutationCache: this,
      mutationId: ++Cf(this, Ed)._,
      options: t.defaultMutationOptions(n),
      state: r
    });
    return this.add(i), i;
  }
  add(t) {
    const n = kf(t), r = X(this, Tr).get(n) ?? [];
    r.push(t), X(this, Tr).set(n, r), this.notify({ type: "added", mutation: t });
  }
  remove(t) {
    var r;
    const n = kf(t);
    if (X(this, Tr).has(n)) {
      const i = (r = X(this, Tr).get(n)) == null ? void 0 : r.filter((o) => o !== t);
      i && (i.length === 0 ? X(this, Tr).delete(n) : X(this, Tr).set(n, i));
    }
    this.notify({ type: "removed", mutation: t });
  }
  canRun(t) {
    var r;
    const n = (r = X(this, Tr).get(kf(t))) == null ? void 0 : r.find((i) => i.state.status === "pending");
    return !n || n === t;
  }
  runNext(t) {
    var r;
    const n = (r = X(this, Tr).get(kf(t))) == null ? void 0 : r.find((i) => i !== t && i.state.isPaused);
    return (n == null ? void 0 : n.continue()) ?? Promise.resolve();
  }
  clear() {
    En.batch(() => {
      this.getAll().forEach((t) => {
        this.remove(t);
      });
    });
  }
  getAll() {
    return [...X(this, Tr).values()].flat();
  }
  find(t) {
    const n = { exact: !0, ...t };
    return this.getAll().find(
      (r) => vC(n, r)
    );
  }
  findAll(t = {}) {
    return this.getAll().filter((n) => vC(t, n));
  }
  notify(t) {
    En.batch(() => {
      this.listeners.forEach((n) => {
        n(t);
      });
    });
  }
  resumePausedMutations() {
    const t = this.getAll().filter((n) => n.state.isPaused);
    return En.batch(
      () => Promise.all(
        t.map((n) => n.continue().catch(Yr))
      )
    );
  }
}, Tr = new WeakMap(), Ed = new WeakMap(), tA);
function kf(e) {
  var t;
  return ((t = e.options.scope) == null ? void 0 : t.id) ?? String(e.mutationId);
}
function Oh(e) {
  return {
    onFetch: (t, n) => {
      var u, d, f, h, p;
      const r = t.options, i = (f = (d = (u = t.fetchOptions) == null ? void 0 : u.meta) == null ? void 0 : d.fetchMore) == null ? void 0 : f.direction, o = ((h = t.state.data) == null ? void 0 : h.pages) || [], s = ((p = t.state.data) == null ? void 0 : p.pageParams) || [];
      let a = { pages: [], pageParams: [] }, l = 0;
      const c = async () => {
        let m = !1;
        const g = (x) => {
          Object.defineProperty(x, "signal", {
            enumerable: !0,
            get: () => (t.signal.aborted ? m = !0 : t.signal.addEventListener("abort", () => {
              m = !0;
            }), t.signal)
          });
        }, v = gA(t.options, t.fetchOptions), w = async (x, C, S) => {
          if (m)
            return Promise.reject();
          if (C == null && x.pages.length)
            return Promise.resolve(x);
          const k = {
            queryKey: t.queryKey,
            pageParam: C,
            direction: S ? "backward" : "forward",
            meta: t.options.meta
          };
          g(k);
          const A = await v(
            k
          ), { maxPages: b } = t.options, T = S ? yD : pD;
          return {
            pages: T(x.pages, A, b),
            pageParams: T(x.pageParams, C, b)
          };
        };
        if (i && o.length) {
          const x = i === "backward", C = x ? EA : Tv, S = {
            pages: o,
            pageParams: s
          }, k = C(r, S);
          a = await w(S, k, x);
        } else {
          const x = e ?? o.length;
          do {
            const C = l === 0 ? s[0] ?? r.initialPageParam : Tv(r, a);
            if (l > 0 && C == null)
              break;
            a = await w(a, C), l++;
          } while (l < x);
        }
        return a;
      };
      t.options.persister ? t.fetchFn = () => {
        var m, g;
        return (g = (m = t.options).persister) == null ? void 0 : g.call(
          m,
          c,
          {
            queryKey: t.queryKey,
            meta: t.options.meta,
            signal: t.signal
          },
          n
        );
      } : t.fetchFn = c;
    }
  };
}
function Tv(e, { pages: t, pageParams: n }) {
  const r = t.length - 1;
  return t.length > 0 ? e.getNextPageParam(
    t[r],
    t,
    n[r],
    n
  ) : void 0;
}
function EA(e, { pages: t, pageParams: n }) {
  var r;
  return t.length > 0 ? (r = e.getPreviousPageParam) == null ? void 0 : r.call(e, t[0], t, n[0], n) : void 0;
}
function SD(e, t) {
  return t ? Tv(e, t) != null : !1;
}
function AD(e, t) {
  return !t || !e.getPreviousPageParam ? !1 : EA(e, t) != null;
}
var sn, as, ls, jl, Ml, cs, Fl, Ll, nA, TD = (nA = class {
  constructor(e = {}) {
    Ye(this, sn);
    Ye(this, as);
    Ye(this, ls);
    Ye(this, jl);
    Ye(this, Ml);
    Ye(this, cs);
    Ye(this, Fl);
    Ye(this, Ll);
    Pe(this, sn, e.queryCache || new CD()), Pe(this, as, e.mutationCache || new ED()), Pe(this, ls, e.defaultOptions || {}), Pe(this, jl, /* @__PURE__ */ new Map()), Pe(this, Ml, /* @__PURE__ */ new Map()), Pe(this, cs, 0);
  }
  mount() {
    Cf(this, cs)._++, X(this, cs) === 1 && (Pe(this, Fl, U0.subscribe(async (e) => {
      e && (await this.resumePausedMutations(), X(this, sn).onFocus());
    })), Pe(this, Ll, Ph.subscribe(async (e) => {
      e && (await this.resumePausedMutations(), X(this, sn).onOnline());
    })));
  }
  unmount() {
    var e, t;
    Cf(this, cs)._--, X(this, cs) === 0 && ((e = X(this, Fl)) == null || e.call(this), Pe(this, Fl, void 0), (t = X(this, Ll)) == null || t.call(this), Pe(this, Ll, void 0));
  }
  isFetching(e) {
    return X(this, sn).findAll({ ...e, fetchStatus: "fetching" }).length;
  }
  isMutating(e) {
    return X(this, as).findAll({ ...e, status: "pending" }).length;
  }
  getQueryData(e) {
    var n;
    const t = this.defaultQueryOptions({ queryKey: e });
    return (n = X(this, sn).get(t.queryHash)) == null ? void 0 : n.state.data;
  }
  ensureQueryData(e) {
    const t = this.getQueryData(e.queryKey);
    if (t === void 0)
      return this.fetchQuery(e);
    {
      const n = this.defaultQueryOptions(e), r = X(this, sn).build(this, n);
      return e.revalidateIfStale && r.isStaleByTime(Sl(n.staleTime, r)) && this.prefetchQuery(n), Promise.resolve(t);
    }
  }
  getQueriesData(e) {
    return X(this, sn).findAll(e).map(({ queryKey: t, state: n }) => {
      const r = n.data;
      return [t, r];
    });
  }
  setQueryData(e, t, n) {
    const r = this.defaultQueryOptions({ queryKey: e }), i = X(this, sn).get(
      r.queryHash
    ), o = i == null ? void 0 : i.state.data, s = fD(t, o);
    if (s !== void 0)
      return X(this, sn).build(this, r).setData(s, { ...n, manual: !0 });
  }
  setQueriesData(e, t, n) {
    return En.batch(
      () => X(this, sn).findAll(e).map(({ queryKey: r }) => [
        r,
        this.setQueryData(r, t, n)
      ])
    );
  }
  getQueryState(e) {
    var n;
    const t = this.defaultQueryOptions({ queryKey: e });
    return (n = X(this, sn).get(t.queryHash)) == null ? void 0 : n.state;
  }
  removeQueries(e) {
    const t = X(this, sn);
    En.batch(() => {
      t.findAll(e).forEach((n) => {
        t.remove(n);
      });
    });
  }
  resetQueries(e, t) {
    const n = X(this, sn), r = {
      type: "active",
      ...e
    };
    return En.batch(() => (n.findAll(e).forEach((i) => {
      i.reset();
    }), this.refetchQueries(r, t)));
  }
  cancelQueries(e = {}, t = {}) {
    const n = { revert: !0, ...t }, r = En.batch(
      () => X(this, sn).findAll(e).map((i) => i.cancel(n))
    );
    return Promise.all(r).then(Yr).catch(Yr);
  }
  invalidateQueries(e = {}, t = {}) {
    return En.batch(() => {
      if (X(this, sn).findAll(e).forEach((r) => {
        r.invalidate();
      }), e.refetchType === "none")
        return Promise.resolve();
      const n = {
        ...e,
        type: e.refetchType ?? e.type ?? "active"
      };
      return this.refetchQueries(n, t);
    });
  }
  refetchQueries(e = {}, t) {
    const n = {
      ...t,
      cancelRefetch: (t == null ? void 0 : t.cancelRefetch) ?? !0
    }, r = En.batch(
      () => X(this, sn).findAll(e).filter((i) => !i.isDisabled()).map((i) => {
        let o = i.fetch(void 0, n);
        return n.throwOnError || (o = o.catch(Yr)), i.state.fetchStatus === "paused" ? Promise.resolve() : o;
      })
    );
    return Promise.all(r).then(Yr);
  }
  fetchQuery(e) {
    const t = this.defaultQueryOptions(e);
    t.retry === void 0 && (t.retry = !1);
    const n = X(this, sn).build(this, t);
    return n.isStaleByTime(
      Sl(t.staleTime, n)
    ) ? n.fetch(t) : Promise.resolve(n.state.data);
  }
  prefetchQuery(e) {
    return this.fetchQuery(e).then(Yr).catch(Yr);
  }
  fetchInfiniteQuery(e) {
    return e.behavior = Oh(e.pages), this.fetchQuery(e);
  }
  prefetchInfiniteQuery(e) {
    return this.fetchInfiniteQuery(e).then(Yr).catch(Yr);
  }
  ensureInfiniteQueryData(e) {
    return e.behavior = Oh(e.pages), this.ensureQueryData(e);
  }
  resumePausedMutations() {
    return Ph.isOnline() ? X(this, as).resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return X(this, sn);
  }
  getMutationCache() {
    return X(this, as);
  }
  getDefaultOptions() {
    return X(this, ls);
  }
  setDefaultOptions(e) {
    Pe(this, ls, e);
  }
  setQueryDefaults(e, t) {
    X(this, jl).set(Ea(e), {
      queryKey: e,
      defaultOptions: t
    });
  }
  getQueryDefaults(e) {
    const t = [...X(this, jl).values()];
    let n = {};
    return t.forEach((r) => {
      ju(e, r.queryKey) && (n = { ...n, ...r.defaultOptions });
    }), n;
  }
  setMutationDefaults(e, t) {
    X(this, Ml).set(Ea(e), {
      mutationKey: e,
      defaultOptions: t
    });
  }
  getMutationDefaults(e) {
    const t = [...X(this, Ml).values()];
    let n = {};
    return t.forEach((r) => {
      ju(e, r.mutationKey) && (n = { ...n, ...r.defaultOptions });
    }), n;
  }
  defaultQueryOptions(e) {
    if (e._defaulted)
      return e;
    const t = {
      ...X(this, ls).queries,
      ...this.getQueryDefaults(e.queryKey),
      ...e,
      _defaulted: !0
    };
    return t.queryHash || (t.queryHash = L0(
      t.queryKey,
      t
    )), t.refetchOnReconnect === void 0 && (t.refetchOnReconnect = t.networkMode !== "always"), t.throwOnError === void 0 && (t.throwOnError = !!t.suspense), !t.networkMode && t.persister && (t.networkMode = "offlineFirst"), t.enabled !== !0 && t.queryFn === Av && (t.enabled = !1), t;
  }
  defaultMutationOptions(e) {
    return e != null && e._defaulted ? e : {
      ...X(this, ls).mutations,
      ...(e == null ? void 0 : e.mutationKey) && this.getMutationDefaults(e.mutationKey),
      ...e,
      _defaulted: !0
    };
  }
  clear() {
    X(this, sn).clear(), X(this, as).clear();
  }
}, sn = new WeakMap(), as = new WeakMap(), ls = new WeakMap(), jl = new WeakMap(), Ml = new WeakMap(), cs = new WeakMap(), Fl = new WeakMap(), Ll = new WeakMap(), nA), mr, Et, Sd, ir, ya, Ul, $i, Ad, zl, Vl, ma, ga, us, ql, Nt, yu, _v, Iv, Rv, Pv, Ov, Bv, Nv, AA, rA, SA = (rA = class extends Ic {
  constructor(t, n) {
    super();
    Ye(this, Nt);
    Ye(this, mr);
    Ye(this, Et);
    Ye(this, Sd);
    Ye(this, ir);
    Ye(this, ya);
    Ye(this, Ul);
    Ye(this, $i);
    Ye(this, Ad);
    Ye(this, zl);
    // This property keeps track of the last query with defined data.
    // It will be used to pass the previous data and query to the placeholder function between renders.
    Ye(this, Vl);
    Ye(this, ma);
    Ye(this, ga);
    Ye(this, us);
    Ye(this, ql, /* @__PURE__ */ new Set());
    this.options = n, Pe(this, mr, t), Pe(this, $i, null), this.bindMethods(), this.setOptions(n);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    this.listeners.size === 1 && (X(this, Et).addObserver(this), xC(X(this, Et), this.options) ? mt(this, Nt, yu).call(this) : this.updateResult(), mt(this, Nt, Pv).call(this));
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return Dv(
      X(this, Et),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return Dv(
      X(this, Et),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), mt(this, Nt, Ov).call(this), mt(this, Nt, Bv).call(this), X(this, Et).removeObserver(this);
  }
  setOptions(t, n) {
    const r = this.options, i = X(this, Et);
    if (this.options = X(this, mr).defaultQueryOptions(t), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof Ci(this.options.enabled, X(this, Et)) != "boolean")
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    mt(this, Nt, Nv).call(this), X(this, Et).setOptions(this.options), r._defaulted && !Rh(this.options, r) && X(this, mr).getQueryCache().notify({
      type: "observerOptionsUpdated",
      query: X(this, Et),
      observer: this
    });
    const o = this.hasListeners();
    o && CC(
      X(this, Et),
      i,
      this.options,
      r
    ) && mt(this, Nt, yu).call(this), this.updateResult(n), o && (X(this, Et) !== i || Ci(this.options.enabled, X(this, Et)) !== Ci(r.enabled, X(this, Et)) || Sl(this.options.staleTime, X(this, Et)) !== Sl(r.staleTime, X(this, Et))) && mt(this, Nt, _v).call(this);
    const s = mt(this, Nt, Iv).call(this);
    o && (X(this, Et) !== i || Ci(this.options.enabled, X(this, Et)) !== Ci(r.enabled, X(this, Et)) || s !== X(this, us)) && mt(this, Nt, Rv).call(this, s);
  }
  getOptimisticResult(t) {
    const n = X(this, mr).getQueryCache().build(X(this, mr), t), r = this.createResult(n, t);
    return ID(this, r) && (Pe(this, ir, r), Pe(this, Ul, this.options), Pe(this, ya, X(this, Et).state)), r;
  }
  getCurrentResult() {
    return X(this, ir);
  }
  trackResult(t, n) {
    const r = {};
    return Object.keys(t).forEach((i) => {
      Object.defineProperty(r, i, {
        configurable: !1,
        enumerable: !0,
        get: () => (this.trackProp(i), n == null || n(i), t[i])
      });
    }), r;
  }
  trackProp(t) {
    X(this, ql).add(t);
  }
  getCurrentQuery() {
    return X(this, Et);
  }
  refetch({ ...t } = {}) {
    return this.fetch({
      ...t
    });
  }
  fetchOptimistic(t) {
    const n = X(this, mr).defaultQueryOptions(t), r = X(this, mr).getQueryCache().build(X(this, mr), n);
    return r.isFetchingOptimistic = !0, r.fetch().then(() => this.createResult(r, n));
  }
  fetch(t) {
    return mt(this, Nt, yu).call(this, {
      ...t,
      cancelRefetch: t.cancelRefetch ?? !0
    }).then(() => (this.updateResult(), X(this, ir)));
  }
  createResult(t, n) {
    var A;
    const r = X(this, Et), i = this.options, o = X(this, ir), s = X(this, ya), a = X(this, Ul), c = t !== r ? t.state : X(this, Sd), { state: u } = t;
    let d = { ...u }, f = !1, h;
    if (n._optimisticResults) {
      const b = this.hasListeners(), T = !b && xC(t, n), R = b && CC(t, r, n, i);
      (T || R) && (d = {
        ...d,
        ...CA(u.data, t.options)
      }), n._optimisticResults === "isRestoring" && (d.fetchStatus = "idle");
    }
    let { error: p, errorUpdatedAt: m, status: g } = d;
    if (n.select && d.data !== void 0)
      if (o && d.data === (s == null ? void 0 : s.data) && n.select === X(this, Ad))
        h = X(this, zl);
      else
        try {
          Pe(this, Ad, n.select), h = n.select(d.data), h = Sv(o == null ? void 0 : o.data, h, n), Pe(this, zl, h), Pe(this, $i, null);
        } catch (b) {
          Pe(this, $i, b);
        }
    else
      h = d.data;
    if (n.placeholderData !== void 0 && h === void 0 && g === "pending") {
      let b;
      if (o != null && o.isPlaceholderData && n.placeholderData === (a == null ? void 0 : a.placeholderData))
        b = o.data;
      else if (b = typeof n.placeholderData == "function" ? n.placeholderData(
        (A = X(this, Vl)) == null ? void 0 : A.state.data,
        X(this, Vl)
      ) : n.placeholderData, n.select && b !== void 0)
        try {
          b = n.select(b), Pe(this, $i, null);
        } catch (T) {
          Pe(this, $i, T);
        }
      b !== void 0 && (g = "success", h = Sv(
        o == null ? void 0 : o.data,
        b,
        n
      ), f = !0);
    }
    X(this, $i) && (p = X(this, $i), h = X(this, zl), m = Date.now(), g = "error");
    const v = d.fetchStatus === "fetching", w = g === "pending", x = g === "error", C = w && v, S = h !== void 0;
    return {
      status: g,
      fetchStatus: d.fetchStatus,
      isPending: w,
      isSuccess: g === "success",
      isError: x,
      isInitialLoading: C,
      isLoading: C,
      data: h,
      dataUpdatedAt: d.dataUpdatedAt,
      error: p,
      errorUpdatedAt: m,
      failureCount: d.fetchFailureCount,
      failureReason: d.fetchFailureReason,
      errorUpdateCount: d.errorUpdateCount,
      isFetched: d.dataUpdateCount > 0 || d.errorUpdateCount > 0,
      isFetchedAfterMount: d.dataUpdateCount > c.dataUpdateCount || d.errorUpdateCount > c.errorUpdateCount,
      isFetching: v,
      isRefetching: v && !w,
      isLoadingError: x && !S,
      isPaused: d.fetchStatus === "paused",
      isPlaceholderData: f,
      isRefetchError: x && S,
      isStale: z0(t, n),
      refetch: this.refetch
    };
  }
  updateResult(t) {
    const n = X(this, ir), r = this.createResult(X(this, Et), this.options);
    if (Pe(this, ya, X(this, Et).state), Pe(this, Ul, this.options), X(this, ya).data !== void 0 && Pe(this, Vl, X(this, Et)), Rh(r, n))
      return;
    Pe(this, ir, r);
    const i = {}, o = () => {
      if (!n)
        return !0;
      const { notifyOnChangeProps: s } = this.options, a = typeof s == "function" ? s() : s;
      if (a === "all" || !a && !X(this, ql).size)
        return !0;
      const l = new Set(
        a ?? X(this, ql)
      );
      return this.options.throwOnError && l.add("error"), Object.keys(X(this, ir)).some((c) => {
        const u = c;
        return X(this, ir)[u] !== n[u] && l.has(u);
      });
    };
    (t == null ? void 0 : t.listeners) !== !1 && o() && (i.listeners = !0), mt(this, Nt, AA).call(this, { ...i, ...t });
  }
  onQueryUpdate() {
    this.updateResult(), this.hasListeners() && mt(this, Nt, Pv).call(this);
  }
}, mr = new WeakMap(), Et = new WeakMap(), Sd = new WeakMap(), ir = new WeakMap(), ya = new WeakMap(), Ul = new WeakMap(), $i = new WeakMap(), Ad = new WeakMap(), zl = new WeakMap(), Vl = new WeakMap(), ma = new WeakMap(), ga = new WeakMap(), us = new WeakMap(), ql = new WeakMap(), Nt = new WeakSet(), yu = function(t) {
  mt(this, Nt, Nv).call(this);
  let n = X(this, Et).fetch(
    this.options,
    t
  );
  return t != null && t.throwOnError || (n = n.catch(Yr)), n;
}, _v = function() {
  mt(this, Nt, Ov).call(this);
  const t = Sl(
    this.options.staleTime,
    X(this, Et)
  );
  if (Wl || X(this, ir).isStale || !Cv(t))
    return;
  const r = mA(X(this, ir).dataUpdatedAt, t) + 1;
  Pe(this, ma, setTimeout(() => {
    X(this, ir).isStale || this.updateResult();
  }, r));
}, Iv = function() {
  return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(X(this, Et)) : this.options.refetchInterval) ?? !1;
}, Rv = function(t) {
  mt(this, Nt, Bv).call(this), Pe(this, us, t), !(Wl || Ci(this.options.enabled, X(this, Et)) === !1 || !Cv(X(this, us)) || X(this, us) === 0) && Pe(this, ga, setInterval(() => {
    (this.options.refetchIntervalInBackground || U0.isFocused()) && mt(this, Nt, yu).call(this);
  }, X(this, us)));
}, Pv = function() {
  mt(this, Nt, _v).call(this), mt(this, Nt, Rv).call(this, mt(this, Nt, Iv).call(this));
}, Ov = function() {
  X(this, ma) && (clearTimeout(X(this, ma)), Pe(this, ma, void 0));
}, Bv = function() {
  X(this, ga) && (clearInterval(X(this, ga)), Pe(this, ga, void 0));
}, Nv = function() {
  const t = X(this, mr).getQueryCache().build(X(this, mr), this.options);
  if (t === X(this, Et))
    return;
  const n = X(this, Et);
  Pe(this, Et, t), Pe(this, Sd, t.state), this.hasListeners() && (n == null || n.removeObserver(this), t.addObserver(this));
}, AA = function(t) {
  En.batch(() => {
    t.listeners && this.listeners.forEach((n) => {
      n(X(this, ir));
    }), X(this, mr).getQueryCache().notify({
      query: X(this, Et),
      type: "observerResultsUpdated"
    });
  });
}, rA);
function _D(e, t) {
  return Ci(t.enabled, e) !== !1 && e.state.data === void 0 && !(e.state.status === "error" && t.retryOnMount === !1);
}
function xC(e, t) {
  return _D(e, t) || e.state.data !== void 0 && Dv(e, t, t.refetchOnMount);
}
function Dv(e, t, n) {
  if (Ci(t.enabled, e) !== !1) {
    const r = typeof n == "function" ? n(e) : n;
    return r === "always" || r !== !1 && z0(e, t);
  }
  return !1;
}
function CC(e, t, n, r) {
  return (e !== t || Ci(r.enabled, e) === !1) && (!n.suspense || e.state.status !== "error") && z0(e, n);
}
function z0(e, t) {
  return Ci(t.enabled, e) !== !1 && e.isStaleByTime(Sl(t.staleTime, e));
}
function ID(e, t) {
  return !Rh(e.getCurrentResult(), t);
}
var RD = class extends SA {
  constructor(e, t) {
    super(e, t);
  }
  bindMethods() {
    super.bindMethods(), this.fetchNextPage = this.fetchNextPage.bind(this), this.fetchPreviousPage = this.fetchPreviousPage.bind(this);
  }
  setOptions(e, t) {
    super.setOptions(
      {
        ...e,
        behavior: Oh()
      },
      t
    );
  }
  getOptimisticResult(e) {
    return e.behavior = Oh(), super.getOptimisticResult(e);
  }
  fetchNextPage(e) {
    return this.fetch({
      ...e,
      meta: {
        fetchMore: { direction: "forward" }
      }
    });
  }
  fetchPreviousPage(e) {
    return this.fetch({
      ...e,
      meta: {
        fetchMore: { direction: "backward" }
      }
    });
  }
  createResult(e, t) {
    var p, m;
    const { state: n } = e, r = super.createResult(e, t), { isFetching: i, isRefetching: o, isError: s, isRefetchError: a } = r, l = (m = (p = n.fetchMeta) == null ? void 0 : p.fetchMore) == null ? void 0 : m.direction, c = s && l === "forward", u = i && l === "forward", d = s && l === "backward", f = i && l === "backward";
    return {
      ...r,
      fetchNextPage: this.fetchNextPage,
      fetchPreviousPage: this.fetchPreviousPage,
      hasNextPage: SD(t, n.data),
      hasPreviousPage: AD(t, n.data),
      isFetchNextPageError: c,
      isFetchingNextPage: u,
      isFetchPreviousPageError: d,
      isFetchingPreviousPage: f,
      isRefetchError: a && !c && !d,
      isRefetching: o && !u && !f
    };
  }
}, ds, fs, gr, mo, To, lh, jv, iA, PD = (iA = class extends Ic {
  constructor(n, r) {
    super();
    Ye(this, To);
    Ye(this, ds);
    Ye(this, fs);
    Ye(this, gr);
    Ye(this, mo);
    Pe(this, ds, n), this.setOptions(r), this.bindMethods(), mt(this, To, lh).call(this);
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this);
  }
  setOptions(n) {
    var i;
    const r = this.options;
    this.options = X(this, ds).defaultMutationOptions(n), Rh(this.options, r) || X(this, ds).getMutationCache().notify({
      type: "observerOptionsUpdated",
      mutation: X(this, gr),
      observer: this
    }), r != null && r.mutationKey && this.options.mutationKey && Ea(r.mutationKey) !== Ea(this.options.mutationKey) ? this.reset() : ((i = X(this, gr)) == null ? void 0 : i.state.status) === "pending" && X(this, gr).setOptions(this.options);
  }
  onUnsubscribe() {
    var n;
    this.hasListeners() || (n = X(this, gr)) == null || n.removeObserver(this);
  }
  onMutationUpdate(n) {
    mt(this, To, lh).call(this), mt(this, To, jv).call(this, n);
  }
  getCurrentResult() {
    return X(this, fs);
  }
  reset() {
    var n;
    (n = X(this, gr)) == null || n.removeObserver(this), Pe(this, gr, void 0), mt(this, To, lh).call(this), mt(this, To, jv).call(this);
  }
  mutate(n, r) {
    var i;
    return Pe(this, mo, r), (i = X(this, gr)) == null || i.removeObserver(this), Pe(this, gr, X(this, ds).getMutationCache().build(X(this, ds), this.options)), X(this, gr).addObserver(this), X(this, gr).execute(n);
  }
}, ds = new WeakMap(), fs = new WeakMap(), gr = new WeakMap(), mo = new WeakMap(), To = new WeakSet(), lh = function() {
  var r;
  const n = ((r = X(this, gr)) == null ? void 0 : r.state) ?? kA();
  Pe(this, fs, {
    ...n,
    isPending: n.status === "pending",
    isSuccess: n.status === "success",
    isError: n.status === "error",
    isIdle: n.status === "idle",
    mutate: this.mutate,
    reset: this.reset
  });
}, jv = function(n) {
  En.batch(() => {
    var r, i, o, s, a, l, c, u;
    if (X(this, mo) && this.hasListeners()) {
      const d = X(this, fs).variables, f = X(this, fs).context;
      (n == null ? void 0 : n.type) === "success" ? ((i = (r = X(this, mo)).onSuccess) == null || i.call(r, n.data, d, f), (s = (o = X(this, mo)).onSettled) == null || s.call(o, n.data, null, d, f)) : (n == null ? void 0 : n.type) === "error" && ((l = (a = X(this, mo)).onError) == null || l.call(a, n.error, d, f), (u = (c = X(this, mo)).onSettled) == null || u.call(
        c,
        void 0,
        n.error,
        d,
        f
      ));
    }
    this.listeners.forEach((d) => {
      d(X(this, fs));
    });
  });
}, iA), TA = P.createContext(
  void 0
), _A = (e) => {
  const t = P.useContext(TA);
  if (!t)
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  return t;
}, OD = ({
  client: e,
  children: t
}) => (P.useEffect(() => (e.mount(), () => {
  e.unmount();
}), [e]), /* @__PURE__ */ y.jsx(TA.Provider, { value: e, children: t })), IA = P.createContext(!1), BD = () => P.useContext(IA);
IA.Provider;
function ND() {
  let e = !1;
  return {
    clearReset: () => {
      e = !1;
    },
    reset: () => {
      e = !0;
    },
    isReset: () => e
  };
}
var DD = P.createContext(ND()), jD = () => P.useContext(DD);
function RA(e, t) {
  return typeof e == "function" ? e(...t) : !!e;
}
function MD() {
}
var FD = (e, t) => {
  (e.suspense || e.throwOnError) && (t.isReset() || (e.retryOnMount = !1));
}, LD = (e) => {
  P.useEffect(() => {
    e.clearReset();
  }, [e]);
}, UD = ({
  result: e,
  errorResetBoundary: t,
  throwOnError: n,
  query: r
}) => e.isError && !t.isReset() && !e.isFetching && r && RA(n, [e.error, r]), zD = (e) => {
  e.suspense && (typeof e.staleTime != "number" && (e.staleTime = 1e3), typeof e.gcTime == "number" && (e.gcTime = Math.max(e.gcTime, 1e3)));
}, VD = (e, t) => (e == null ? void 0 : e.suspense) && t.isPending, qD = (e, t, n) => t.fetchOptimistic(e).catch(() => {
  n.clearReset();
});
function PA(e, t, n) {
  var c, u, d, f;
  if (ke.env.NODE_ENV !== "production" && (typeof e != "object" || Array.isArray(e)))
    throw new Error(
      'Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'
    );
  const r = _A(), i = BD(), o = jD(), s = r.defaultQueryOptions(e);
  (u = (c = r.getDefaultOptions().queries) == null ? void 0 : c._experimental_beforeQuery) == null || u.call(
    c,
    s
  ), s._optimisticResults = i ? "isRestoring" : "optimistic", zD(s), FD(s, o), LD(o);
  const [a] = P.useState(
    () => new t(
      r,
      s
    )
  ), l = a.getOptimisticResult(s);
  if (P.useSyncExternalStore(
    P.useCallback(
      (h) => {
        const p = i ? () => {
        } : a.subscribe(En.batchCalls(h));
        return a.updateResult(), p;
      },
      [a, i]
    ),
    () => a.getCurrentResult(),
    () => a.getCurrentResult()
  ), P.useEffect(() => {
    a.setOptions(s, { listeners: !1 });
  }, [s, a]), VD(s, l))
    throw qD(s, a, o);
  if (UD({
    result: l,
    errorResetBoundary: o,
    throwOnError: s.throwOnError,
    query: r.getQueryCache().get(s.queryHash)
  }))
    throw l.error;
  return (f = (d = r.getDefaultOptions().queries) == null ? void 0 : d._experimental_afterQuery) == null || f.call(
    d,
    s,
    l
  ), s.notifyOnChangeProps ? l : a.trackResult(l);
}
function Ut(e, t) {
  return PA(e, SA);
}
function li(e, t) {
  const n = _A(), [r] = P.useState(
    () => new PD(
      n,
      e
    )
  );
  P.useEffect(() => {
    r.setOptions(e);
  }, [r, e]);
  const i = P.useSyncExternalStore(
    P.useCallback(
      (s) => r.subscribe(En.batchCalls(s)),
      [r]
    ),
    () => r.getCurrentResult(),
    () => r.getCurrentResult()
  ), o = P.useCallback(
    (s, a) => {
      r.mutate(s, a).catch(MD);
    },
    [r]
  );
  if (i.error && RA(r.options.throwOnError, [i.error]))
    throw i.error;
  return { ...i, mutate: o, mutateAsync: i.mutate };
}
function $D(e, t) {
  return PA(
    e,
    RD
  );
}
const WD = {
  type: "logger",
  log(e) {
    this.output("log", e);
  },
  warn(e) {
    this.output("warn", e);
  },
  error(e) {
    this.output("error", e);
  },
  output(e, t) {
    console && console[e];
  }
};
class Bh {
  constructor(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(t, n);
  }
  init(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = n.prefix || "i18next:", this.logger = t || WD, this.options = n, this.debug = n.debug;
  }
  log() {
    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
      n[r] = arguments[r];
    return this.forward(n, "log", "", !0);
  }
  warn() {
    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
      n[r] = arguments[r];
    return this.forward(n, "warn", "", !0);
  }
  error() {
    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
      n[r] = arguments[r];
    return this.forward(n, "error", "");
  }
  deprecate() {
    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
      n[r] = arguments[r];
    return this.forward(n, "warn", "WARNING DEPRECATED: ", !0);
  }
  forward(t, n, r, i) {
    return i && !this.debug ? null : (typeof t[0] == "string" && (t[0] = `${r}${this.prefix} ${t[0]}`), this.logger[n](t));
  }
  create(t) {
    return new Bh(this.logger, {
      prefix: `${this.prefix}:${t}:`,
      ...this.options
    });
  }
  clone(t) {
    return t = t || this.options, t.prefix = t.prefix || this.prefix, new Bh(this.logger, t);
  }
}
var Hi = new Bh();
let Ap = class {
  constructor() {
    this.observers = {};
  }
  on(t, n) {
    return t.split(" ").forEach((r) => {
      this.observers[r] || (this.observers[r] = /* @__PURE__ */ new Map());
      const i = this.observers[r].get(n) || 0;
      this.observers[r].set(n, i + 1);
    }), this;
  }
  off(t, n) {
    if (this.observers[t]) {
      if (!n) {
        delete this.observers[t];
        return;
      }
      this.observers[t].delete(n);
    }
  }
  emit(t) {
    for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
      r[i - 1] = arguments[i];
    this.observers[t] && Array.from(this.observers[t].entries()).forEach((s) => {
      let [a, l] = s;
      for (let c = 0; c < l; c++)
        a(...r);
    }), this.observers["*"] && Array.from(this.observers["*"].entries()).forEach((s) => {
      let [a, l] = s;
      for (let c = 0; c < l; c++)
        a.apply(a, [t, ...r]);
    });
  }
};
const Zc = () => {
  let e, t;
  const n = new Promise((r, i) => {
    e = r, t = i;
  });
  return n.resolve = e, n.reject = t, n;
}, kC = (e) => e == null ? "" : "" + e, GD = (e, t, n) => {
  e.forEach((r) => {
    t[r] && (n[r] = t[r]);
  });
}, HD = /###/g, EC = (e) => e && e.indexOf("###") > -1 ? e.replace(HD, ".") : e, SC = (e) => !e || typeof e == "string", Au = (e, t, n) => {
  const r = typeof t != "string" ? t : t.split(".");
  let i = 0;
  for (; i < r.length - 1; ) {
    if (SC(e)) return {};
    const o = EC(r[i]);
    !e[o] && n && (e[o] = new n()), Object.prototype.hasOwnProperty.call(e, o) ? e = e[o] : e = {}, ++i;
  }
  return SC(e) ? {} : {
    obj: e,
    k: EC(r[i])
  };
}, AC = (e, t, n) => {
  const {
    obj: r,
    k: i
  } = Au(e, t, Object);
  if (r !== void 0 || t.length === 1) {
    r[i] = n;
    return;
  }
  let o = t[t.length - 1], s = t.slice(0, t.length - 1), a = Au(e, s, Object);
  for (; a.obj === void 0 && s.length; )
    o = `${s[s.length - 1]}.${o}`, s = s.slice(0, s.length - 1), a = Au(e, s, Object), a && a.obj && typeof a.obj[`${a.k}.${o}`] < "u" && (a.obj = void 0);
  a.obj[`${a.k}.${o}`] = n;
}, KD = (e, t, n, r) => {
  const {
    obj: i,
    k: o
  } = Au(e, t, Object);
  i[o] = i[o] || [], i[o].push(n);
}, Nh = (e, t) => {
  const {
    obj: n,
    k: r
  } = Au(e, t);
  if (n)
    return n[r];
}, YD = (e, t, n) => {
  const r = Nh(e, n);
  return r !== void 0 ? r : Nh(t, n);
}, OA = (e, t, n) => {
  for (const r in t)
    r !== "__proto__" && r !== "constructor" && (r in e ? typeof e[r] == "string" || e[r] instanceof String || typeof t[r] == "string" || t[r] instanceof String ? n && (e[r] = t[r]) : OA(e[r], t[r], n) : e[r] = t[r]);
  return e;
}, Ja = (e) => e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var QD = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
const JD = (e) => typeof e == "string" ? e.replace(/[&<>"'\/]/g, (t) => QD[t]) : e;
class XD {
  constructor(t) {
    this.capacity = t, this.regExpMap = /* @__PURE__ */ new Map(), this.regExpQueue = [];
  }
  getRegExp(t) {
    const n = this.regExpMap.get(t);
    if (n !== void 0)
      return n;
    const r = new RegExp(t);
    return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()), this.regExpMap.set(t, r), this.regExpQueue.push(t), r;
  }
}
const ZD = [" ", ",", "?", "!", ";"], ej = new XD(20), tj = (e, t, n) => {
  t = t || "", n = n || "";
  const r = ZD.filter((s) => t.indexOf(s) < 0 && n.indexOf(s) < 0);
  if (r.length === 0) return !0;
  const i = ej.getRegExp(`(${r.map((s) => s === "?" ? "\\?" : s).join("|")})`);
  let o = !i.test(e);
  if (!o) {
    const s = e.indexOf(n);
    s > 0 && !i.test(e.substring(0, s)) && (o = !0);
  }
  return o;
}, Mv = function(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!e) return;
  if (e[t]) return e[t];
  const r = t.split(n);
  let i = e;
  for (let o = 0; o < r.length; ) {
    if (!i || typeof i != "object")
      return;
    let s, a = "";
    for (let l = o; l < r.length; ++l)
      if (l !== o && (a += n), a += r[l], s = i[a], s !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof s) > -1 && l < r.length - 1)
          continue;
        o += l - o + 1;
        break;
      }
    i = s;
  }
  return i;
}, Dh = (e) => e && e.indexOf("_") > 0 ? e.replace("_", "-") : e;
class TC extends Ap {
  constructor(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super(), this.data = t || {}, this.options = n, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0);
  }
  addNamespaces(t) {
    this.options.ns.indexOf(t) < 0 && this.options.ns.push(t);
  }
  removeNamespaces(t) {
    const n = this.options.ns.indexOf(t);
    n > -1 && this.options.ns.splice(n, 1);
  }
  getResource(t, n, r) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const o = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator, s = i.ignoreJSONStructure !== void 0 ? i.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let a;
    t.indexOf(".") > -1 ? a = t.split(".") : (a = [t, n], r && (Array.isArray(r) ? a.push(...r) : typeof r == "string" && o ? a.push(...r.split(o)) : a.push(r)));
    const l = Nh(this.data, a);
    return !l && !n && !r && t.indexOf(".") > -1 && (t = a[0], n = a[1], r = a.slice(2).join(".")), l || !s || typeof r != "string" ? l : Mv(this.data && this.data[t] && this.data[t][n], r, o);
  }
  addResource(t, n, r, i) {
    let o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: !1
    };
    const s = o.keySeparator !== void 0 ? o.keySeparator : this.options.keySeparator;
    let a = [t, n];
    r && (a = a.concat(s ? r.split(s) : r)), t.indexOf(".") > -1 && (a = t.split("."), i = n, n = a[1]), this.addNamespaces(n), AC(this.data, a, i), o.silent || this.emit("added", t, n, r, i);
  }
  addResources(t, n, r) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: !1
    };
    for (const o in r)
      (typeof r[o] == "string" || Array.isArray(r[o])) && this.addResource(t, n, o, r[o], {
        silent: !0
      });
    i.silent || this.emit("added", t, n, r);
  }
  addResourceBundle(t, n, r, i, o) {
    let s = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: !1,
      skipCopy: !1
    }, a = [t, n];
    t.indexOf(".") > -1 && (a = t.split("."), i = r, r = n, n = a[1]), this.addNamespaces(n);
    let l = Nh(this.data, a) || {};
    s.skipCopy || (r = JSON.parse(JSON.stringify(r))), i ? OA(l, r, o) : l = {
      ...l,
      ...r
    }, AC(this.data, a, l), s.silent || this.emit("added", t, n, r);
  }
  removeResourceBundle(t, n) {
    this.hasResourceBundle(t, n) && delete this.data[t][n], this.removeNamespaces(n), this.emit("removed", t, n);
  }
  hasResourceBundle(t, n) {
    return this.getResource(t, n) !== void 0;
  }
  getResourceBundle(t, n) {
    return n || (n = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? {
      ...this.getResource(t, n)
    } : this.getResource(t, n);
  }
  getDataByLanguage(t) {
    return this.data[t];
  }
  hasLanguageSomeTranslations(t) {
    const n = this.getDataByLanguage(t);
    return !!(n && Object.keys(n) || []).find((i) => n[i] && Object.keys(n[i]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var BA = {
  processors: {},
  addPostProcessor(e) {
    this.processors[e.name] = e;
  },
  handle(e, t, n, r, i) {
    return e.forEach((o) => {
      this.processors[o] && (t = this.processors[o].process(t, n, r, i));
    }), t;
  }
};
const _C = {};
class jh extends Ap {
  constructor(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), GD(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], t, this), this.options = n, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.logger = Hi.create("translator");
  }
  changeLanguage(t) {
    t && (this.language = t);
  }
  exists(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (t == null)
      return !1;
    const r = this.resolve(t, n);
    return r && r.res !== void 0;
  }
  extractFromKey(t, n) {
    let r = n.nsSeparator !== void 0 ? n.nsSeparator : this.options.nsSeparator;
    r === void 0 && (r = ":");
    const i = n.keySeparator !== void 0 ? n.keySeparator : this.options.keySeparator;
    let o = n.ns || this.options.defaultNS || [];
    const s = r && t.indexOf(r) > -1, a = !this.options.userDefinedKeySeparator && !n.keySeparator && !this.options.userDefinedNsSeparator && !n.nsSeparator && !tj(t, r, i);
    if (s && !a) {
      const l = t.match(this.interpolator.nestingRegexp);
      if (l && l.length > 0)
        return {
          key: t,
          namespaces: o
        };
      const c = t.split(r);
      (r !== i || r === i && this.options.ns.indexOf(c[0]) > -1) && (o = c.shift()), t = c.join(i);
    }
    return typeof o == "string" && (o = [o]), {
      key: t,
      namespaces: o
    };
  }
  translate(t, n, r) {
    if (typeof n != "object" && this.options.overloadTranslationOptionHandler && (n = this.options.overloadTranslationOptionHandler(arguments)), typeof n == "object" && (n = {
      ...n
    }), n || (n = {}), t == null) return "";
    Array.isArray(t) || (t = [String(t)]);
    const i = n.returnDetails !== void 0 ? n.returnDetails : this.options.returnDetails, o = n.keySeparator !== void 0 ? n.keySeparator : this.options.keySeparator, {
      key: s,
      namespaces: a
    } = this.extractFromKey(t[t.length - 1], n), l = a[a.length - 1], c = n.lng || this.language, u = n.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (c && c.toLowerCase() === "cimode") {
      if (u) {
        const C = n.nsSeparator || this.options.nsSeparator;
        return i ? {
          res: `${l}${C}${s}`,
          usedKey: s,
          exactUsedKey: s,
          usedLng: c,
          usedNS: l,
          usedParams: this.getUsedParamsDetails(n)
        } : `${l}${C}${s}`;
      }
      return i ? {
        res: s,
        usedKey: s,
        exactUsedKey: s,
        usedLng: c,
        usedNS: l,
        usedParams: this.getUsedParamsDetails(n)
      } : s;
    }
    const d = this.resolve(t, n);
    let f = d && d.res;
    const h = d && d.usedKey || s, p = d && d.exactUsedKey || s, m = Object.prototype.toString.apply(f), g = ["[object Number]", "[object Function]", "[object RegExp]"], v = n.joinArrays !== void 0 ? n.joinArrays : this.options.joinArrays, w = !this.i18nFormat || this.i18nFormat.handleAsObject;
    if (w && f && (typeof f != "string" && typeof f != "boolean" && typeof f != "number") && g.indexOf(m) < 0 && !(typeof v == "string" && Array.isArray(f))) {
      if (!n.returnObjects && !this.options.returnObjects) {
        this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        const C = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(h, f, {
          ...n,
          ns: a
        }) : `key '${s} (${this.language})' returned an object instead of string.`;
        return i ? (d.res = C, d.usedParams = this.getUsedParamsDetails(n), d) : C;
      }
      if (o) {
        const C = Array.isArray(f), S = C ? [] : {}, k = C ? p : h;
        for (const A in f)
          if (Object.prototype.hasOwnProperty.call(f, A)) {
            const b = `${k}${o}${A}`;
            S[A] = this.translate(b, {
              ...n,
              joinArrays: !1,
              ns: a
            }), S[A] === b && (S[A] = f[A]);
          }
        f = S;
      }
    } else if (w && typeof v == "string" && Array.isArray(f))
      f = f.join(v), f && (f = this.extendTranslation(f, t, n, r));
    else {
      let C = !1, S = !1;
      const k = n.count !== void 0 && typeof n.count != "string", A = jh.hasDefaultValue(n), b = k ? this.pluralResolver.getSuffix(c, n.count, n) : "", T = n.ordinal && k ? this.pluralResolver.getSuffix(c, n.count, {
        ordinal: !1
      }) : "", R = k && !n.ordinal && n.count === 0 && this.pluralResolver.shouldUseIntlApi(), B = R && n[`defaultValue${this.options.pluralSeparator}zero`] || n[`defaultValue${b}`] || n[`defaultValue${T}`] || n.defaultValue;
      !this.isValidLookup(f) && A && (C = !0, f = B), this.isValidLookup(f) || (S = !0, f = s);
      const L = (n.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && S ? void 0 : f, V = A && B !== f && this.options.updateMissing;
      if (S || C || V) {
        if (this.logger.log(V ? "updateKey" : "missingKey", c, l, s, V ? B : f), o) {
          const F = this.resolve(s, {
            ...n,
            keySeparator: !1
          });
          F && F.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let N = [];
        const M = this.languageUtils.getFallbackCodes(this.options.fallbackLng, n.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && M && M[0])
          for (let F = 0; F < M.length; F++)
            N.push(M[F]);
        else this.options.saveMissingTo === "all" ? N = this.languageUtils.toResolveHierarchy(n.lng || this.language) : N.push(n.lng || this.language);
        const U = (F, $, ie) => {
          const he = A && ie !== f ? ie : L;
          this.options.missingKeyHandler ? this.options.missingKeyHandler(F, l, $, he, V, n) : this.backendConnector && this.backendConnector.saveMissing && this.backendConnector.saveMissing(F, l, $, he, V, n), this.emit("missingKey", F, l, $, f);
        };
        this.options.saveMissing && (this.options.saveMissingPlurals && k ? N.forEach((F) => {
          const $ = this.pluralResolver.getSuffixes(F, n);
          R && n[`defaultValue${this.options.pluralSeparator}zero`] && $.indexOf(`${this.options.pluralSeparator}zero`) < 0 && $.push(`${this.options.pluralSeparator}zero`), $.forEach((ie) => {
            U([F], s + ie, n[`defaultValue${ie}`] || B);
          });
        }) : U(N, s, B));
      }
      f = this.extendTranslation(f, t, n, d, r), S && f === s && this.options.appendNamespaceToMissingKey && (f = `${l}:${s}`), (S || C) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? f = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${l}:${s}` : s, C ? f : void 0) : f = this.options.parseMissingKeyHandler(f));
    }
    return i ? (d.res = f, d.usedParams = this.getUsedParamsDetails(n), d) : f;
  }
  extendTranslation(t, n, r, i, o) {
    var s = this;
    if (this.i18nFormat && this.i18nFormat.parse)
      t = this.i18nFormat.parse(t, {
        ...this.options.interpolation.defaultVariables,
        ...r
      }, r.lng || this.language || i.usedLng, i.usedNS, i.usedKey, {
        resolved: i
      });
    else if (!r.skipInterpolation) {
      r.interpolation && this.interpolator.init({
        ...r,
        interpolation: {
          ...this.options.interpolation,
          ...r.interpolation
        }
      });
      const c = typeof t == "string" && (r && r.interpolation && r.interpolation.skipOnVariables !== void 0 ? r.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let u;
      if (c) {
        const f = t.match(this.interpolator.nestingRegexp);
        u = f && f.length;
      }
      let d = r.replace && typeof r.replace != "string" ? r.replace : r;
      if (this.options.interpolation.defaultVariables && (d = {
        ...this.options.interpolation.defaultVariables,
        ...d
      }), t = this.interpolator.interpolate(t, d, r.lng || this.language || i.usedLng, r), c) {
        const f = t.match(this.interpolator.nestingRegexp), h = f && f.length;
        u < h && (r.nest = !1);
      }
      !r.lng && this.options.compatibilityAPI !== "v1" && i && i.res && (r.lng = this.language || i.usedLng), r.nest !== !1 && (t = this.interpolator.nest(t, function() {
        for (var f = arguments.length, h = new Array(f), p = 0; p < f; p++)
          h[p] = arguments[p];
        return o && o[0] === h[0] && !r.context ? (s.logger.warn(`It seems you are nesting recursively key: ${h[0]} in key: ${n[0]}`), null) : s.translate(...h, n);
      }, r)), r.interpolation && this.interpolator.reset();
    }
    const a = r.postProcess || this.options.postProcess, l = typeof a == "string" ? [a] : a;
    return t != null && l && l.length && r.applyPostProcessor !== !1 && (t = BA.handle(l, t, n, this.options && this.options.postProcessPassResolved ? {
      i18nResolved: {
        ...i,
        usedParams: this.getUsedParamsDetails(r)
      },
      ...r
    } : r, this)), t;
  }
  resolve(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r, i, o, s, a;
    return typeof t == "string" && (t = [t]), t.forEach((l) => {
      if (this.isValidLookup(r)) return;
      const c = this.extractFromKey(l, n), u = c.key;
      i = u;
      let d = c.namespaces;
      this.options.fallbackNS && (d = d.concat(this.options.fallbackNS));
      const f = n.count !== void 0 && typeof n.count != "string", h = f && !n.ordinal && n.count === 0 && this.pluralResolver.shouldUseIntlApi(), p = n.context !== void 0 && (typeof n.context == "string" || typeof n.context == "number") && n.context !== "", m = n.lngs ? n.lngs : this.languageUtils.toResolveHierarchy(n.lng || this.language, n.fallbackLng);
      d.forEach((g) => {
        this.isValidLookup(r) || (a = g, !_C[`${m[0]}-${g}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(a) && (_C[`${m[0]}-${g}`] = !0, this.logger.warn(`key "${i}" for languages "${m.join(", ")}" won't get resolved as namespace "${a}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), m.forEach((v) => {
          if (this.isValidLookup(r)) return;
          s = v;
          const w = [u];
          if (this.i18nFormat && this.i18nFormat.addLookupKeys)
            this.i18nFormat.addLookupKeys(w, u, v, g, n);
          else {
            let C;
            f && (C = this.pluralResolver.getSuffix(v, n.count, n));
            const S = `${this.options.pluralSeparator}zero`, k = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (f && (w.push(u + C), n.ordinal && C.indexOf(k) === 0 && w.push(u + C.replace(k, this.options.pluralSeparator)), h && w.push(u + S)), p) {
              const A = `${u}${this.options.contextSeparator}${n.context}`;
              w.push(A), f && (w.push(A + C), n.ordinal && C.indexOf(k) === 0 && w.push(A + C.replace(k, this.options.pluralSeparator)), h && w.push(A + S));
            }
          }
          let x;
          for (; x = w.pop(); )
            this.isValidLookup(r) || (o = x, r = this.getResource(v, g, x, n));
        }));
      });
    }), {
      res: r,
      usedKey: i,
      exactUsedKey: o,
      usedLng: s,
      usedNS: a
    };
  }
  isValidLookup(t) {
    return t !== void 0 && !(!this.options.returnNull && t === null) && !(!this.options.returnEmptyString && t === "");
  }
  getResource(t, n, r) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(t, n, r, i) : this.resourceStore.getResource(t, n, r, i);
  }
  getUsedParamsDetails() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const n = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"], r = t.replace && typeof t.replace != "string";
    let i = r ? t.replace : t;
    if (r && typeof t.count < "u" && (i.count = t.count), this.options.interpolation.defaultVariables && (i = {
      ...this.options.interpolation.defaultVariables,
      ...i
    }), !r) {
      i = {
        ...i
      };
      for (const o of n)
        delete i[o];
    }
    return i;
  }
  static hasDefaultValue(t) {
    const n = "defaultValue";
    for (const r in t)
      if (Object.prototype.hasOwnProperty.call(t, r) && n === r.substring(0, n.length) && t[r] !== void 0)
        return !0;
    return !1;
  }
}
const Sm = (e) => e.charAt(0).toUpperCase() + e.slice(1);
class IC {
  constructor(t) {
    this.options = t, this.supportedLngs = this.options.supportedLngs || !1, this.logger = Hi.create("languageUtils");
  }
  getScriptPartFromCode(t) {
    if (t = Dh(t), !t || t.indexOf("-") < 0) return null;
    const n = t.split("-");
    return n.length === 2 || (n.pop(), n[n.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(n.join("-"));
  }
  getLanguagePartFromCode(t) {
    if (t = Dh(t), !t || t.indexOf("-") < 0) return t;
    const n = t.split("-");
    return this.formatLanguageCode(n[0]);
  }
  formatLanguageCode(t) {
    if (typeof t == "string" && t.indexOf("-") > -1) {
      const n = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
      let r = t.split("-");
      return this.options.lowerCaseLng ? r = r.map((i) => i.toLowerCase()) : r.length === 2 ? (r[0] = r[0].toLowerCase(), r[1] = r[1].toUpperCase(), n.indexOf(r[1].toLowerCase()) > -1 && (r[1] = Sm(r[1].toLowerCase()))) : r.length === 3 && (r[0] = r[0].toLowerCase(), r[1].length === 2 && (r[1] = r[1].toUpperCase()), r[0] !== "sgn" && r[2].length === 2 && (r[2] = r[2].toUpperCase()), n.indexOf(r[1].toLowerCase()) > -1 && (r[1] = Sm(r[1].toLowerCase())), n.indexOf(r[2].toLowerCase()) > -1 && (r[2] = Sm(r[2].toLowerCase()))), r.join("-");
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? t.toLowerCase() : t;
  }
  isSupportedCode(t) {
    return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (t = this.getLanguagePartFromCode(t)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(t) > -1;
  }
  getBestMatchFromCodes(t) {
    if (!t) return null;
    let n;
    return t.forEach((r) => {
      if (n) return;
      const i = this.formatLanguageCode(r);
      (!this.options.supportedLngs || this.isSupportedCode(i)) && (n = i);
    }), !n && this.options.supportedLngs && t.forEach((r) => {
      if (n) return;
      const i = this.getLanguagePartFromCode(r);
      if (this.isSupportedCode(i)) return n = i;
      n = this.options.supportedLngs.find((o) => {
        if (o === i) return o;
        if (!(o.indexOf("-") < 0 && i.indexOf("-") < 0) && (o.indexOf("-") > 0 && i.indexOf("-") < 0 && o.substring(0, o.indexOf("-")) === i || o.indexOf(i) === 0 && i.length > 1))
          return o;
      });
    }), n || (n = this.getFallbackCodes(this.options.fallbackLng)[0]), n;
  }
  getFallbackCodes(t, n) {
    if (!t) return [];
    if (typeof t == "function" && (t = t(n)), typeof t == "string" && (t = [t]), Array.isArray(t)) return t;
    if (!n) return t.default || [];
    let r = t[n];
    return r || (r = t[this.getScriptPartFromCode(n)]), r || (r = t[this.formatLanguageCode(n)]), r || (r = t[this.getLanguagePartFromCode(n)]), r || (r = t.default), r || [];
  }
  toResolveHierarchy(t, n) {
    const r = this.getFallbackCodes(n || this.options.fallbackLng || [], t), i = [], o = (s) => {
      s && (this.isSupportedCode(s) ? i.push(s) : this.logger.warn(`rejecting language code not found in supportedLngs: ${s}`));
    };
    return typeof t == "string" && (t.indexOf("-") > -1 || t.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && o(this.formatLanguageCode(t)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && o(this.getScriptPartFromCode(t)), this.options.load !== "currentOnly" && o(this.getLanguagePartFromCode(t))) : typeof t == "string" && o(this.formatLanguageCode(t)), r.forEach((s) => {
      i.indexOf(s) < 0 && o(this.formatLanguageCode(s));
    }), i;
  }
}
let nj = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}], rj = {
  1: (e) => +(e > 1),
  2: (e) => +(e != 1),
  3: (e) => 0,
  4: (e) => e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2,
  5: (e) => e == 0 ? 0 : e == 1 ? 1 : e == 2 ? 2 : e % 100 >= 3 && e % 100 <= 10 ? 3 : e % 100 >= 11 ? 4 : 5,
  6: (e) => e == 1 ? 0 : e >= 2 && e <= 4 ? 1 : 2,
  7: (e) => e == 1 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2,
  8: (e) => e == 1 ? 0 : e == 2 ? 1 : e != 8 && e != 11 ? 2 : 3,
  9: (e) => +(e >= 2),
  10: (e) => e == 1 ? 0 : e == 2 ? 1 : e < 7 ? 2 : e < 11 ? 3 : 4,
  11: (e) => e == 1 || e == 11 ? 0 : e == 2 || e == 12 ? 1 : e > 2 && e < 20 ? 2 : 3,
  12: (e) => +(e % 10 != 1 || e % 100 == 11),
  13: (e) => +(e !== 0),
  14: (e) => e == 1 ? 0 : e == 2 ? 1 : e == 3 ? 2 : 3,
  15: (e) => e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2,
  16: (e) => e % 10 == 1 && e % 100 != 11 ? 0 : e !== 0 ? 1 : 2,
  17: (e) => e == 1 || e % 10 == 1 && e % 100 != 11 ? 0 : 1,
  18: (e) => e == 0 ? 0 : e == 1 ? 1 : 2,
  19: (e) => e == 1 ? 0 : e == 0 || e % 100 > 1 && e % 100 < 11 ? 1 : e % 100 > 10 && e % 100 < 20 ? 2 : 3,
  20: (e) => e == 1 ? 0 : e == 0 || e % 100 > 0 && e % 100 < 20 ? 1 : 2,
  21: (e) => e % 100 == 1 ? 1 : e % 100 == 2 ? 2 : e % 100 == 3 || e % 100 == 4 ? 3 : 0,
  22: (e) => e == 1 ? 0 : e == 2 ? 1 : (e < 0 || e > 10) && e % 10 == 0 ? 2 : 3
};
const ij = ["v1", "v2", "v3"], oj = ["v4"], RC = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
}, sj = () => {
  const e = {};
  return nj.forEach((t) => {
    t.lngs.forEach((n) => {
      e[n] = {
        numbers: t.nr,
        plurals: rj[t.fc]
      };
    });
  }), e;
};
class aj {
  constructor(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = t, this.options = n, this.logger = Hi.create("pluralResolver"), (!this.options.compatibilityJSON || oj.includes(this.options.compatibilityJSON)) && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = sj(), this.pluralRulesCache = {};
  }
  addRule(t, n) {
    this.rules[t] = n;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.shouldUseIntlApi())
      try {
        const r = Dh(t === "dev" ? "en" : t), i = n.ordinal ? "ordinal" : "cardinal", o = JSON.stringify({
          cleanedCode: r,
          type: i
        });
        if (o in this.pluralRulesCache)
          return this.pluralRulesCache[o];
        const s = new Intl.PluralRules(r, {
          type: i
        });
        return this.pluralRulesCache[o] = s, s;
      } catch {
        return;
      }
    return this.rules[t] || this.rules[this.languageUtils.getLanguagePartFromCode(t)];
  }
  needsPlural(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const r = this.getRule(t, n);
    return this.shouldUseIntlApi() ? r && r.resolvedOptions().pluralCategories.length > 1 : r && r.numbers.length > 1;
  }
  getPluralFormsOfKey(t, n) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(t, r).map((i) => `${n}${i}`);
  }
  getSuffixes(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const r = this.getRule(t, n);
    return r ? this.shouldUseIntlApi() ? r.resolvedOptions().pluralCategories.sort((i, o) => RC[i] - RC[o]).map((i) => `${this.options.prepend}${n.ordinal ? `ordinal${this.options.prepend}` : ""}${i}`) : r.numbers.map((i) => this.getSuffix(t, i, n)) : [];
  }
  getSuffix(t, n) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const i = this.getRule(t, r);
    return i ? this.shouldUseIntlApi() ? `${this.options.prepend}${r.ordinal ? `ordinal${this.options.prepend}` : ""}${i.select(n)}` : this.getSuffixRetroCompatible(i, n) : (this.logger.warn(`no plural rule found for: ${t}`), "");
  }
  getSuffixRetroCompatible(t, n) {
    const r = t.noAbs ? t.plurals(n) : t.plurals(Math.abs(n));
    let i = t.numbers[r];
    this.options.simplifyPluralSuffix && t.numbers.length === 2 && t.numbers[0] === 1 && (i === 2 ? i = "plural" : i === 1 && (i = ""));
    const o = () => this.options.prepend && i.toString() ? this.options.prepend + i.toString() : i.toString();
    return this.options.compatibilityJSON === "v1" ? i === 1 ? "" : typeof i == "number" ? `_plural_${i.toString()}` : o() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && t.numbers.length === 2 && t.numbers[0] === 1 ? o() : this.options.prepend && r.toString() ? this.options.prepend + r.toString() : r.toString();
  }
  shouldUseIntlApi() {
    return !ij.includes(this.options.compatibilityJSON);
  }
}
const PC = function(e, t, n) {
  let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".", i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, o = YD(e, t, n);
  return !o && i && typeof n == "string" && (o = Mv(e, n, r), o === void 0 && (o = Mv(t, n, r))), o;
}, Am = (e) => e.replace(/\$/g, "$$$$");
class lj {
  constructor() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = Hi.create("interpolator"), this.options = t, this.format = t.interpolation && t.interpolation.format || ((n) => n), this.init(t);
  }
  init() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    t.interpolation || (t.interpolation = {
      escapeValue: !0
    });
    const {
      escape: n,
      escapeValue: r,
      useRawValueToEscape: i,
      prefix: o,
      prefixEscaped: s,
      suffix: a,
      suffixEscaped: l,
      formatSeparator: c,
      unescapeSuffix: u,
      unescapePrefix: d,
      nestingPrefix: f,
      nestingPrefixEscaped: h,
      nestingSuffix: p,
      nestingSuffixEscaped: m,
      nestingOptionsSeparator: g,
      maxReplaces: v,
      alwaysFormat: w
    } = t.interpolation;
    this.escape = n !== void 0 ? n : JD, this.escapeValue = r !== void 0 ? r : !0, this.useRawValueToEscape = i !== void 0 ? i : !1, this.prefix = o ? Ja(o) : s || "{{", this.suffix = a ? Ja(a) : l || "}}", this.formatSeparator = c || ",", this.unescapePrefix = u ? "" : d || "-", this.unescapeSuffix = this.unescapePrefix ? "" : u || "", this.nestingPrefix = f ? Ja(f) : h || Ja("$t("), this.nestingSuffix = p ? Ja(p) : m || Ja(")"), this.nestingOptionsSeparator = g || ",", this.maxReplaces = v || 1e3, this.alwaysFormat = w !== void 0 ? w : !1, this.resetRegExp();
  }
  reset() {
    this.options && this.init(this.options);
  }
  resetRegExp() {
    const t = (n, r) => n && n.source === r ? (n.lastIndex = 0, n) : new RegExp(r, "g");
    this.regexp = t(this.regexp, `${this.prefix}(.+?)${this.suffix}`), this.regexpUnescape = t(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`), this.nestingRegexp = t(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
  }
  interpolate(t, n, r, i) {
    let o, s, a;
    const l = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {}, c = (h) => {
      if (h.indexOf(this.formatSeparator) < 0) {
        const v = PC(n, l, h, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(v, void 0, r, {
          ...i,
          ...n,
          interpolationkey: h
        }) : v;
      }
      const p = h.split(this.formatSeparator), m = p.shift().trim(), g = p.join(this.formatSeparator).trim();
      return this.format(PC(n, l, m, this.options.keySeparator, this.options.ignoreJSONStructure), g, r, {
        ...i,
        ...n,
        interpolationkey: m
      });
    };
    this.resetRegExp();
    const u = i && i.missingInterpolationHandler || this.options.missingInterpolationHandler, d = i && i.interpolation && i.interpolation.skipOnVariables !== void 0 ? i.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    return [{
      regex: this.regexpUnescape,
      safeValue: (h) => Am(h)
    }, {
      regex: this.regexp,
      safeValue: (h) => this.escapeValue ? Am(this.escape(h)) : Am(h)
    }].forEach((h) => {
      for (a = 0; o = h.regex.exec(t); ) {
        const p = o[1].trim();
        if (s = c(p), s === void 0)
          if (typeof u == "function") {
            const g = u(t, o, i);
            s = typeof g == "string" ? g : "";
          } else if (i && Object.prototype.hasOwnProperty.call(i, p))
            s = "";
          else if (d) {
            s = o[0];
            continue;
          } else
            this.logger.warn(`missed to pass in variable ${p} for interpolating ${t}`), s = "";
        else typeof s != "string" && !this.useRawValueToEscape && (s = kC(s));
        const m = h.safeValue(s);
        if (t = t.replace(o[0], m), d ? (h.regex.lastIndex += s.length, h.regex.lastIndex -= o[0].length) : h.regex.lastIndex = 0, a++, a >= this.maxReplaces)
          break;
      }
    }), t;
  }
  nest(t, n) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i, o, s;
    const a = (l, c) => {
      const u = this.nestingOptionsSeparator;
      if (l.indexOf(u) < 0) return l;
      const d = l.split(new RegExp(`${u}[ ]*{`));
      let f = `{${d[1]}`;
      l = d[0], f = this.interpolate(f, s);
      const h = f.match(/'/g), p = f.match(/"/g);
      (h && h.length % 2 === 0 && !p || p.length % 2 !== 0) && (f = f.replace(/'/g, '"'));
      try {
        s = JSON.parse(f), c && (s = {
          ...c,
          ...s
        });
      } catch (m) {
        return this.logger.warn(`failed parsing options string in nesting for key ${l}`, m), `${l}${u}${f}`;
      }
      return s.defaultValue && s.defaultValue.indexOf(this.prefix) > -1 && delete s.defaultValue, l;
    };
    for (; i = this.nestingRegexp.exec(t); ) {
      let l = [];
      s = {
        ...r
      }, s = s.replace && typeof s.replace != "string" ? s.replace : s, s.applyPostProcessor = !1, delete s.defaultValue;
      let c = !1;
      if (i[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(i[1])) {
        const u = i[1].split(this.formatSeparator).map((d) => d.trim());
        i[1] = u.shift(), l = u, c = !0;
      }
      if (o = n(a.call(this, i[1].trim(), s), s), o && i[0] === t && typeof o != "string") return o;
      typeof o != "string" && (o = kC(o)), o || (this.logger.warn(`missed to resolve ${i[1]} for nesting ${t}`), o = ""), c && (o = l.reduce((u, d) => this.format(u, d, r.lng, {
        ...r,
        interpolationkey: i[1].trim()
      }), o.trim())), t = t.replace(i[0], o), this.regexp.lastIndex = 0;
    }
    return t;
  }
}
const cj = (e) => {
  let t = e.toLowerCase().trim();
  const n = {};
  if (e.indexOf("(") > -1) {
    const r = e.split("(");
    t = r[0].toLowerCase().trim();
    const i = r[1].substring(0, r[1].length - 1);
    t === "currency" && i.indexOf(":") < 0 ? n.currency || (n.currency = i.trim()) : t === "relativetime" && i.indexOf(":") < 0 ? n.range || (n.range = i.trim()) : i.split(";").forEach((s) => {
      if (s) {
        const [a, ...l] = s.split(":"), c = l.join(":").trim().replace(/^'+|'+$/g, ""), u = a.trim();
        n[u] || (n[u] = c), c === "false" && (n[u] = !1), c === "true" && (n[u] = !0), isNaN(c) || (n[u] = parseInt(c, 10));
      }
    });
  }
  return {
    formatName: t,
    formatOptions: n
  };
}, Xa = (e) => {
  const t = {};
  return (n, r, i) => {
    let o = i;
    i && i.interpolationkey && i.formatParams && i.formatParams[i.interpolationkey] && i[i.interpolationkey] && (o = {
      ...o,
      [i.interpolationkey]: void 0
    });
    const s = r + JSON.stringify(o);
    let a = t[s];
    return a || (a = e(Dh(r), i), t[s] = a), a(n);
  };
};
class uj {
  constructor() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = Hi.create("formatter"), this.options = t, this.formats = {
      number: Xa((n, r) => {
        const i = new Intl.NumberFormat(n, {
          ...r
        });
        return (o) => i.format(o);
      }),
      currency: Xa((n, r) => {
        const i = new Intl.NumberFormat(n, {
          ...r,
          style: "currency"
        });
        return (o) => i.format(o);
      }),
      datetime: Xa((n, r) => {
        const i = new Intl.DateTimeFormat(n, {
          ...r
        });
        return (o) => i.format(o);
      }),
      relativetime: Xa((n, r) => {
        const i = new Intl.RelativeTimeFormat(n, {
          ...r
        });
        return (o) => i.format(o, r.range || "day");
      }),
      list: Xa((n, r) => {
        const i = new Intl.ListFormat(n, {
          ...r
        });
        return (o) => i.format(o);
      })
    }, this.init(t);
  }
  init(t) {
    const r = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    }).interpolation;
    this.formatSeparator = r.formatSeparator ? r.formatSeparator : r.formatSeparator || ",";
  }
  add(t, n) {
    this.formats[t.toLowerCase().trim()] = n;
  }
  addCached(t, n) {
    this.formats[t.toLowerCase().trim()] = Xa(n);
  }
  format(t, n, r) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const o = n.split(this.formatSeparator);
    if (o.length > 1 && o[0].indexOf("(") > 1 && o[0].indexOf(")") < 0 && o.find((a) => a.indexOf(")") > -1)) {
      const a = o.findIndex((l) => l.indexOf(")") > -1);
      o[0] = [o[0], ...o.splice(1, a)].join(this.formatSeparator);
    }
    return o.reduce((a, l) => {
      const {
        formatName: c,
        formatOptions: u
      } = cj(l);
      if (this.formats[c]) {
        let d = a;
        try {
          const f = i && i.formatParams && i.formatParams[i.interpolationkey] || {}, h = f.locale || f.lng || i.locale || i.lng || r;
          d = this.formats[c](a, h, {
            ...u,
            ...i,
            ...f
          });
        } catch (f) {
          this.logger.warn(f);
        }
        return d;
      } else
        this.logger.warn(`there was no format function for ${c}`);
      return a;
    }, t);
  }
}
const dj = (e, t) => {
  e.pending[t] !== void 0 && (delete e.pending[t], e.pendingCount--);
};
class fj extends Ap {
  constructor(t, n, r) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super(), this.backend = t, this.store = n, this.services = r, this.languageUtils = r.languageUtils, this.options = i, this.logger = Hi.create("backendConnector"), this.waitingReads = [], this.maxParallelReads = i.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = i.maxRetries >= 0 ? i.maxRetries : 5, this.retryTimeout = i.retryTimeout >= 1 ? i.retryTimeout : 350, this.state = {}, this.queue = [], this.backend && this.backend.init && this.backend.init(r, i.backend, i);
  }
  queueLoad(t, n, r, i) {
    const o = {}, s = {}, a = {}, l = {};
    return t.forEach((c) => {
      let u = !0;
      n.forEach((d) => {
        const f = `${c}|${d}`;
        !r.reload && this.store.hasResourceBundle(c, d) ? this.state[f] = 2 : this.state[f] < 0 || (this.state[f] === 1 ? s[f] === void 0 && (s[f] = !0) : (this.state[f] = 1, u = !1, s[f] === void 0 && (s[f] = !0), o[f] === void 0 && (o[f] = !0), l[d] === void 0 && (l[d] = !0)));
      }), u || (a[c] = !0);
    }), (Object.keys(o).length || Object.keys(s).length) && this.queue.push({
      pending: s,
      pendingCount: Object.keys(s).length,
      loaded: {},
      errors: [],
      callback: i
    }), {
      toLoad: Object.keys(o),
      pending: Object.keys(s),
      toLoadLanguages: Object.keys(a),
      toLoadNamespaces: Object.keys(l)
    };
  }
  loaded(t, n, r) {
    const i = t.split("|"), o = i[0], s = i[1];
    n && this.emit("failedLoading", o, s, n), !n && r && this.store.addResourceBundle(o, s, r, void 0, void 0, {
      skipCopy: !0
    }), this.state[t] = n ? -1 : 2, n && r && (this.state[t] = 0);
    const a = {};
    this.queue.forEach((l) => {
      KD(l.loaded, [o], s), dj(l, t), n && l.errors.push(n), l.pendingCount === 0 && !l.done && (Object.keys(l.loaded).forEach((c) => {
        a[c] || (a[c] = {});
        const u = l.loaded[c];
        u.length && u.forEach((d) => {
          a[c][d] === void 0 && (a[c][d] = !0);
        });
      }), l.done = !0, l.errors.length ? l.callback(l.errors) : l.callback());
    }), this.emit("loaded", a), this.queue = this.queue.filter((l) => !l.done);
  }
  read(t, n, r) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout, s = arguments.length > 5 ? arguments[5] : void 0;
    if (!t.length) return s(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng: t,
        ns: n,
        fcName: r,
        tried: i,
        wait: o,
        callback: s
      });
      return;
    }
    this.readingCalls++;
    const a = (c, u) => {
      if (this.readingCalls--, this.waitingReads.length > 0) {
        const d = this.waitingReads.shift();
        this.read(d.lng, d.ns, d.fcName, d.tried, d.wait, d.callback);
      }
      if (c && u && i < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, t, n, r, i + 1, o * 2, s);
        }, o);
        return;
      }
      s(c, u);
    }, l = this.backend[r].bind(this.backend);
    if (l.length === 2) {
      try {
        const c = l(t, n);
        c && typeof c.then == "function" ? c.then((u) => a(null, u)).catch(a) : a(null, c);
      } catch (c) {
        a(c);
      }
      return;
    }
    return l(t, n, a);
  }
  prepareLoading(t, n) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend)
      return this.logger.warn("No backend was added via i18next.use. Will not load resources."), i && i();
    typeof t == "string" && (t = this.languageUtils.toResolveHierarchy(t)), typeof n == "string" && (n = [n]);
    const o = this.queueLoad(t, n, r, i);
    if (!o.toLoad.length)
      return o.pending.length || i(), null;
    o.toLoad.forEach((s) => {
      this.loadOne(s);
    });
  }
  load(t, n, r) {
    this.prepareLoading(t, n, {}, r);
  }
  reload(t, n, r) {
    this.prepareLoading(t, n, {
      reload: !0
    }, r);
  }
  loadOne(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const r = t.split("|"), i = r[0], o = r[1];
    this.read(i, o, "read", void 0, void 0, (s, a) => {
      s && this.logger.warn(`${n}loading namespace ${o} for language ${i} failed`, s), !s && a && this.logger.log(`${n}loaded namespace ${o} for language ${i}`, a), this.loaded(t, s, a);
    });
  }
  saveMissing(t, n, r, i, o) {
    let s = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {}, a = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(n)) {
      this.logger.warn(`did not save key "${r}" as the namespace "${n}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (!(r == null || r === "")) {
      if (this.backend && this.backend.create) {
        const l = {
          ...s,
          isUpdate: o
        }, c = this.backend.create.bind(this.backend);
        if (c.length < 6)
          try {
            let u;
            c.length === 5 ? u = c(t, n, r, i, l) : u = c(t, n, r, i), u && typeof u.then == "function" ? u.then((d) => a(null, d)).catch(a) : a(null, u);
          } catch (u) {
            a(u);
          }
        else
          c(t, n, r, i, a, l);
      }
      !t || !t[0] || this.store.addResource(t[0], n, r, i);
    }
  }
}
const OC = () => ({
  debug: !1,
  initImmediate: !0,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: !1,
  supportedLngs: !1,
  nonExplicitSupportedLngs: !1,
  load: "all",
  preload: !1,
  simplifyPluralSuffix: !0,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: !1,
  saveMissing: !1,
  updateMissing: !1,
  saveMissingTo: "fallback",
  saveMissingPlurals: !0,
  missingKeyHandler: !1,
  missingInterpolationHandler: !1,
  postProcess: !1,
  postProcessPassResolved: !1,
  returnNull: !1,
  returnEmptyString: !0,
  returnObjects: !1,
  joinArrays: !1,
  returnedObjectHandler: !1,
  parseMissingKeyHandler: !1,
  appendNamespaceToMissingKey: !1,
  appendNamespaceToCIMode: !1,
  overloadTranslationOptionHandler: (e) => {
    let t = {};
    if (typeof e[1] == "object" && (t = e[1]), typeof e[1] == "string" && (t.defaultValue = e[1]), typeof e[2] == "string" && (t.tDescription = e[2]), typeof e[2] == "object" || typeof e[3] == "object") {
      const n = e[3] || e[2];
      Object.keys(n).forEach((r) => {
        t[r] = n[r];
      });
    }
    return t;
  },
  interpolation: {
    escapeValue: !0,
    format: (e) => e,
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: !0
  }
}), BC = (e) => (typeof e.ns == "string" && (e.ns = [e.ns]), typeof e.fallbackLng == "string" && (e.fallbackLng = [e.fallbackLng]), typeof e.fallbackNS == "string" && (e.fallbackNS = [e.fallbackNS]), e.supportedLngs && e.supportedLngs.indexOf("cimode") < 0 && (e.supportedLngs = e.supportedLngs.concat(["cimode"])), e), Ef = () => {
}, hj = (e) => {
  Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((n) => {
    typeof e[n] == "function" && (e[n] = e[n].bind(e));
  });
};
let NA = class Fv extends Ap {
  constructor() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 ? arguments[1] : void 0;
    if (super(), this.options = BC(t), this.services = {}, this.logger = Hi, this.modules = {
      external: []
    }, hj(this), n && !this.isInitialized && !t.isClone) {
      if (!this.options.initImmediate)
        return this.init(t, n), this;
      setTimeout(() => {
        this.init(t, n);
      }, 0);
    }
  }
  init() {
    var t = this;
    let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = arguments.length > 1 ? arguments[1] : void 0;
    this.isInitializing = !0, typeof n == "function" && (r = n, n = {}), !n.defaultNS && n.defaultNS !== !1 && n.ns && (typeof n.ns == "string" ? n.defaultNS = n.ns : n.ns.indexOf("translation") < 0 && (n.defaultNS = n.ns[0]));
    const i = OC();
    this.options = {
      ...i,
      ...this.options,
      ...BC(n)
    }, this.options.compatibilityAPI !== "v1" && (this.options.interpolation = {
      ...i.interpolation,
      ...this.options.interpolation
    }), n.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = n.keySeparator), n.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = n.nsSeparator);
    const o = (u) => u ? typeof u == "function" ? new u() : u : null;
    if (!this.options.isClone) {
      this.modules.logger ? Hi.init(o(this.modules.logger), this.options) : Hi.init(null, this.options);
      let u;
      this.modules.formatter ? u = this.modules.formatter : typeof Intl < "u" && (u = uj);
      const d = new IC(this.options);
      this.store = new TC(this.options.resources, this.options);
      const f = this.services;
      f.logger = Hi, f.resourceStore = this.store, f.languageUtils = d, f.pluralResolver = new aj(d, {
        prepend: this.options.pluralSeparator,
        compatibilityJSON: this.options.compatibilityJSON,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      }), u && (!this.options.interpolation.format || this.options.interpolation.format === i.interpolation.format) && (f.formatter = o(u), f.formatter.init(f, this.options), this.options.interpolation.format = f.formatter.format.bind(f.formatter)), f.interpolator = new lj(this.options), f.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      }, f.backendConnector = new fj(o(this.modules.backend), f.resourceStore, f, this.options), f.backendConnector.on("*", function(h) {
        for (var p = arguments.length, m = new Array(p > 1 ? p - 1 : 0), g = 1; g < p; g++)
          m[g - 1] = arguments[g];
        t.emit(h, ...m);
      }), this.modules.languageDetector && (f.languageDetector = o(this.modules.languageDetector), f.languageDetector.init && f.languageDetector.init(f, this.options.detection, this.options)), this.modules.i18nFormat && (f.i18nFormat = o(this.modules.i18nFormat), f.i18nFormat.init && f.i18nFormat.init(this)), this.translator = new jh(this.services, this.options), this.translator.on("*", function(h) {
        for (var p = arguments.length, m = new Array(p > 1 ? p - 1 : 0), g = 1; g < p; g++)
          m[g - 1] = arguments[g];
        t.emit(h, ...m);
      }), this.modules.external.forEach((h) => {
        h.init && h.init(this);
      });
    }
    if (this.format = this.options.interpolation.format, r || (r = Ef), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const u = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      u.length > 0 && u[0] !== "dev" && (this.options.lng = u[0]);
    }
    !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"), ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach((u) => {
      this[u] = function() {
        return t.store[u](...arguments);
      };
    }), ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach((u) => {
      this[u] = function() {
        return t.store[u](...arguments), t;
      };
    });
    const l = Zc(), c = () => {
      const u = (d, f) => {
        this.isInitializing = !1, this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"), this.isInitialized = !0, this.options.isClone || this.logger.log("initialized", this.options), this.emit("initialized", this.options), l.resolve(f), r(d, f);
      };
      if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized) return u(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, u);
    };
    return this.options.resources || !this.options.initImmediate ? c() : setTimeout(c, 0), l;
  }
  loadResources(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ef;
    const i = typeof t == "string" ? t : this.language;
    if (typeof t == "function" && (r = t), !this.options.resources || this.options.partialBundledLanguages) {
      if (i && i.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return r();
      const o = [], s = (a) => {
        if (!a || a === "cimode") return;
        this.services.languageUtils.toResolveHierarchy(a).forEach((c) => {
          c !== "cimode" && o.indexOf(c) < 0 && o.push(c);
        });
      };
      i ? s(i) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach((l) => s(l)), this.options.preload && this.options.preload.forEach((a) => s(a)), this.services.backendConnector.load(o, this.options.ns, (a) => {
        !a && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language), r(a);
      });
    } else
      r(null);
  }
  reloadResources(t, n, r) {
    const i = Zc();
    return typeof t == "function" && (r = t, t = void 0), typeof n == "function" && (r = n, n = void 0), t || (t = this.languages), n || (n = this.options.ns), r || (r = Ef), this.services.backendConnector.reload(t, n, (o) => {
      i.resolve(), r(o);
    }), i;
  }
  use(t) {
    if (!t) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!t.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    return t.type === "backend" && (this.modules.backend = t), (t.type === "logger" || t.log && t.warn && t.error) && (this.modules.logger = t), t.type === "languageDetector" && (this.modules.languageDetector = t), t.type === "i18nFormat" && (this.modules.i18nFormat = t), t.type === "postProcessor" && BA.addPostProcessor(t), t.type === "formatter" && (this.modules.formatter = t), t.type === "3rdParty" && this.modules.external.push(t), this;
  }
  setResolvedLanguage(t) {
    if (!(!t || !this.languages) && !(["cimode", "dev"].indexOf(t) > -1))
      for (let n = 0; n < this.languages.length; n++) {
        const r = this.languages[n];
        if (!(["cimode", "dev"].indexOf(r) > -1) && this.store.hasLanguageSomeTranslations(r)) {
          this.resolvedLanguage = r;
          break;
        }
      }
  }
  changeLanguage(t, n) {
    var r = this;
    this.isLanguageChangingTo = t;
    const i = Zc();
    this.emit("languageChanging", t);
    const o = (l) => {
      this.language = l, this.languages = this.services.languageUtils.toResolveHierarchy(l), this.resolvedLanguage = void 0, this.setResolvedLanguage(l);
    }, s = (l, c) => {
      c ? (o(c), this.translator.changeLanguage(c), this.isLanguageChangingTo = void 0, this.emit("languageChanged", c), this.logger.log("languageChanged", c)) : this.isLanguageChangingTo = void 0, i.resolve(function() {
        return r.t(...arguments);
      }), n && n(l, function() {
        return r.t(...arguments);
      });
    }, a = (l) => {
      !t && !l && this.services.languageDetector && (l = []);
      const c = typeof l == "string" ? l : this.services.languageUtils.getBestMatchFromCodes(l);
      c && (this.language || o(c), this.translator.language || this.translator.changeLanguage(c), this.services.languageDetector && this.services.languageDetector.cacheUserLanguage && this.services.languageDetector.cacheUserLanguage(c)), this.loadResources(c, (u) => {
        s(u, c);
      });
    };
    return !t && this.services.languageDetector && !this.services.languageDetector.async ? a(this.services.languageDetector.detect()) : !t && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(a) : this.services.languageDetector.detect(a) : a(t), i;
  }
  getFixedT(t, n, r) {
    var i = this;
    const o = function(s, a) {
      let l;
      if (typeof a != "object") {
        for (var c = arguments.length, u = new Array(c > 2 ? c - 2 : 0), d = 2; d < c; d++)
          u[d - 2] = arguments[d];
        l = i.options.overloadTranslationOptionHandler([s, a].concat(u));
      } else
        l = {
          ...a
        };
      l.lng = l.lng || o.lng, l.lngs = l.lngs || o.lngs, l.ns = l.ns || o.ns, l.keyPrefix !== "" && (l.keyPrefix = l.keyPrefix || r || o.keyPrefix);
      const f = i.options.keySeparator || ".";
      let h;
      return l.keyPrefix && Array.isArray(s) ? h = s.map((p) => `${l.keyPrefix}${f}${p}`) : h = l.keyPrefix ? `${l.keyPrefix}${f}${s}` : s, i.t(h, l);
    };
    return typeof t == "string" ? o.lng = t : o.lngs = t, o.ns = n, o.keyPrefix = r, o;
  }
  t() {
    return this.translator && this.translator.translate(...arguments);
  }
  exists() {
    return this.translator && this.translator.exists(...arguments);
  }
  setDefaultNamespace(t) {
    this.options.defaultNS = t;
  }
  hasLoadedNamespace(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized)
      return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
    if (!this.languages || !this.languages.length)
      return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
    const r = n.lng || this.resolvedLanguage || this.languages[0], i = this.options ? this.options.fallbackLng : !1, o = this.languages[this.languages.length - 1];
    if (r.toLowerCase() === "cimode") return !0;
    const s = (a, l) => {
      const c = this.services.backendConnector.state[`${a}|${l}`];
      return c === -1 || c === 0 || c === 2;
    };
    if (n.precheck) {
      const a = n.precheck(this, s);
      if (a !== void 0) return a;
    }
    return !!(this.hasResourceBundle(r, t) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || s(r, t) && (!i || s(o, t)));
  }
  loadNamespaces(t, n) {
    const r = Zc();
    return this.options.ns ? (typeof t == "string" && (t = [t]), t.forEach((i) => {
      this.options.ns.indexOf(i) < 0 && this.options.ns.push(i);
    }), this.loadResources((i) => {
      r.resolve(), n && n(i);
    }), r) : (n && n(), Promise.resolve());
  }
  loadLanguages(t, n) {
    const r = Zc();
    typeof t == "string" && (t = [t]);
    const i = this.options.preload || [], o = t.filter((s) => i.indexOf(s) < 0 && this.services.languageUtils.isSupportedCode(s));
    return o.length ? (this.options.preload = i.concat(o), this.loadResources((s) => {
      r.resolve(), n && n(s);
    }), r) : (n && n(), Promise.resolve());
  }
  dir(t) {
    if (t || (t = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !t) return "rtl";
    const n = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"], r = this.services && this.services.languageUtils || new IC(OC());
    return n.indexOf(r.getLanguagePartFromCode(t)) > -1 || t.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 ? arguments[1] : void 0;
    return new Fv(t, n);
  }
  cloneInstance() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ef;
    const r = t.forkResourceStore;
    r && delete t.forkResourceStore;
    const i = {
      ...this.options,
      ...t,
      isClone: !0
    }, o = new Fv(i);
    return (t.debug !== void 0 || t.prefix !== void 0) && (o.logger = o.logger.clone(t)), ["store", "services", "language"].forEach((a) => {
      o[a] = this[a];
    }), o.services = {
      ...this.services
    }, o.services.utils = {
      hasLoadedNamespace: o.hasLoadedNamespace.bind(o)
    }, r && (o.store = new TC(this.store.data, i), o.services.resourceStore = o.store), o.translator = new jh(o.services, i), o.translator.on("*", function(a) {
      for (var l = arguments.length, c = new Array(l > 1 ? l - 1 : 0), u = 1; u < l; u++)
        c[u - 1] = arguments[u];
      o.emit(a, ...c);
    }), o.init(i, n), o.translator.options = i, o.translator.backendConnector.services.utils = {
      hasLoadedNamespace: o.hasLoadedNamespace.bind(o)
    }, o;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
};
const hr = NA.createInstance();
hr.createInstance = NA.createInstance;
const pj = hr.createInstance;
hr.dir;
hr.init;
hr.loadResources;
hr.reloadResources;
hr.use;
hr.changeLanguage;
hr.getFixedT;
hr.t;
hr.exists;
hr.setDefaultNamespace;
hr.hasLoadedNamespace;
hr.loadNamespaces;
hr.loadLanguages;
const {
  slice: yj,
  forEach: mj
} = [];
function gj(e) {
  return mj.call(yj.call(arguments, 1), (t) => {
    if (t)
      for (const n in t)
        e[n] === void 0 && (e[n] = t[n]);
  }), e;
}
const NC = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/, vj = (e, t, n) => {
  const r = n || {};
  r.path = r.path || "/";
  const i = encodeURIComponent(t);
  let o = `${e}=${i}`;
  if (r.maxAge > 0) {
    const s = r.maxAge - 0;
    if (Number.isNaN(s)) throw new Error("maxAge should be a Number");
    o += `; Max-Age=${Math.floor(s)}`;
  }
  if (r.domain) {
    if (!NC.test(r.domain))
      throw new TypeError("option domain is invalid");
    o += `; Domain=${r.domain}`;
  }
  if (r.path) {
    if (!NC.test(r.path))
      throw new TypeError("option path is invalid");
    o += `; Path=${r.path}`;
  }
  if (r.expires) {
    if (typeof r.expires.toUTCString != "function")
      throw new TypeError("option expires is invalid");
    o += `; Expires=${r.expires.toUTCString()}`;
  }
  if (r.httpOnly && (o += "; HttpOnly"), r.secure && (o += "; Secure"), r.sameSite)
    switch (typeof r.sameSite == "string" ? r.sameSite.toLowerCase() : r.sameSite) {
      case !0:
        o += "; SameSite=Strict";
        break;
      case "lax":
        o += "; SameSite=Lax";
        break;
      case "strict":
        o += "; SameSite=Strict";
        break;
      case "none":
        o += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  return o;
}, DC = {
  create(e, t, n, r) {
    let i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      path: "/",
      sameSite: "strict"
    };
    n && (i.expires = /* @__PURE__ */ new Date(), i.expires.setTime(i.expires.getTime() + n * 60 * 1e3)), r && (i.domain = r), document.cookie = vj(e, encodeURIComponent(t), i);
  },
  read(e) {
    const t = `${e}=`, n = document.cookie.split(";");
    for (let r = 0; r < n.length; r++) {
      let i = n[r];
      for (; i.charAt(0) === " "; ) i = i.substring(1, i.length);
      if (i.indexOf(t) === 0) return i.substring(t.length, i.length);
    }
    return null;
  },
  remove(e) {
    this.create(e, "", -1);
  }
};
var bj = {
  name: "cookie",
  // Deconstruct the options object and extract the lookupCookie property
  lookup(e) {
    let {
      lookupCookie: t
    } = e;
    if (t && typeof document < "u")
      return DC.read(t) || void 0;
  },
  // Deconstruct the options object and extract the lookupCookie, cookieMinutes, cookieDomain, and cookieOptions properties
  cacheUserLanguage(e, t) {
    let {
      lookupCookie: n,
      cookieMinutes: r,
      cookieDomain: i,
      cookieOptions: o
    } = t;
    n && typeof document < "u" && DC.create(n, e, r, i, o);
  }
}, wj = {
  name: "querystring",
  // Deconstruct the options object and extract the lookupQuerystring property
  lookup(e) {
    var r;
    let {
      lookupQuerystring: t
    } = e, n;
    if (typeof window < "u") {
      let {
        search: i
      } = window.location;
      !window.location.search && ((r = window.location.hash) == null ? void 0 : r.indexOf("?")) > -1 && (i = window.location.hash.substring(window.location.hash.indexOf("?")));
      const s = i.substring(1).split("&");
      for (let a = 0; a < s.length; a++) {
        const l = s[a].indexOf("=");
        l > 0 && s[a].substring(0, l) === t && (n = s[a].substring(l + 1));
      }
    }
    return n;
  }
};
let eu = null;
const jC = () => {
  if (eu !== null) return eu;
  try {
    eu = window !== "undefined" && window.localStorage !== null;
    const e = "i18next.translate.boo";
    window.localStorage.setItem(e, "foo"), window.localStorage.removeItem(e);
  } catch {
    eu = !1;
  }
  return eu;
};
var xj = {
  name: "localStorage",
  // Deconstruct the options object and extract the lookupLocalStorage property
  lookup(e) {
    let {
      lookupLocalStorage: t
    } = e;
    if (t && jC())
      return window.localStorage.getItem(t) || void 0;
  },
  // Deconstruct the options object and extract the lookupLocalStorage property
  cacheUserLanguage(e, t) {
    let {
      lookupLocalStorage: n
    } = t;
    n && jC() && window.localStorage.setItem(n, e);
  }
};
let tu = null;
const MC = () => {
  if (tu !== null) return tu;
  try {
    tu = window !== "undefined" && window.sessionStorage !== null;
    const e = "i18next.translate.boo";
    window.sessionStorage.setItem(e, "foo"), window.sessionStorage.removeItem(e);
  } catch {
    tu = !1;
  }
  return tu;
};
var Cj = {
  name: "sessionStorage",
  lookup(e) {
    let {
      lookupSessionStorage: t
    } = e;
    if (t && MC())
      return window.sessionStorage.getItem(t) || void 0;
  },
  cacheUserLanguage(e, t) {
    let {
      lookupSessionStorage: n
    } = t;
    n && MC() && window.sessionStorage.setItem(n, e);
  }
}, kj = {
  name: "navigator",
  lookup(e) {
    const t = [];
    if (typeof navigator < "u") {
      const {
        languages: n,
        userLanguage: r,
        language: i
      } = navigator;
      if (n)
        for (let o = 0; o < n.length; o++)
          t.push(n[o]);
      r && t.push(r), i && t.push(i);
    }
    return t.length > 0 ? t : void 0;
  }
}, Ej = {
  name: "htmlTag",
  // Deconstruct the options object and extract the htmlTag property
  lookup(e) {
    let {
      htmlTag: t
    } = e, n;
    const r = t || (typeof document < "u" ? document.documentElement : null);
    return r && typeof r.getAttribute == "function" && (n = r.getAttribute("lang")), n;
  }
}, Sj = {
  name: "path",
  // Deconstruct the options object and extract the lookupFromPathIndex property
  lookup(e) {
    var i;
    let {
      lookupFromPathIndex: t
    } = e;
    if (typeof window > "u") return;
    const n = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
    return Array.isArray(n) ? (i = n[typeof t == "number" ? t : 0]) == null ? void 0 : i.replace("/", "") : void 0;
  }
}, Aj = {
  name: "subdomain",
  lookup(e) {
    var i, o;
    let {
      lookupFromSubdomainIndex: t
    } = e;
    const n = typeof t == "number" ? t + 1 : 1, r = typeof window < "u" && ((o = (i = window.location) == null ? void 0 : i.hostname) == null ? void 0 : o.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i));
    if (r)
      return r[n];
  }
};
function Tj() {
  return {
    order: ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"],
    lookupQuerystring: "lng",
    lookupCookie: "i18next",
    lookupLocalStorage: "i18nextLng",
    lookupSessionStorage: "i18nextLng",
    // cache user language
    caches: ["localStorage"],
    excludeCacheFor: ["cimode"],
    // cookieMinutes: 10,
    // cookieDomain: 'myDomain'
    convertDetectedLanguage: (e) => e
  };
}
class DA {
  constructor(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.type = "languageDetector", this.detectors = {}, this.init(t, n);
  }
  init(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    this.services = t || {
      languageUtils: {}
    }, this.options = gj(n, this.options || {}, Tj()), typeof this.options.convertDetectedLanguage == "string" && this.options.convertDetectedLanguage.indexOf("15897") > -1 && (this.options.convertDetectedLanguage = (i) => i.replace("-", "_")), this.options.lookupFromUrlIndex && (this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex), this.i18nOptions = r, this.addDetector(bj), this.addDetector(wj), this.addDetector(xj), this.addDetector(Cj), this.addDetector(kj), this.addDetector(Ej), this.addDetector(Sj), this.addDetector(Aj);
  }
  addDetector(t) {
    return this.detectors[t.name] = t, this;
  }
  detect(t) {
    t || (t = this.options.order);
    let n = [];
    return t.forEach((r) => {
      if (this.detectors[r]) {
        let i = this.detectors[r].lookup(this.options);
        i && typeof i == "string" && (i = [i]), i && (n = n.concat(i));
      }
    }), n = n.map((r) => this.options.convertDetectedLanguage(r)), this.services.languageUtils.getBestMatchFromCodes ? n : n.length > 0 ? n[0] : null;
  }
  cacheUserLanguage(t, n) {
    n || (n = this.options.caches), n && (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(t) > -1 || n.forEach((r) => {
      this.detectors[r] && this.detectors[r].cacheUserLanguage(t, this.options);
    }));
  }
}
DA.type = "languageDetector";
var _j = {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  embed: !0,
  hr: !0,
  img: !0,
  input: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0
};
const Ij = /* @__PURE__ */ F0(_j);
var Rj = /\s([^'"/\s><]+?)[\s/>]|([^\s=]+)=\s?(".*?"|'.*?')/g;
function FC(e) {
  var t = { type: "tag", name: "", voidElement: !1, attrs: {}, children: [] }, n = e.match(/<\/?([^\s]+?)[/\s>]/);
  if (n && (t.name = n[1], (Ij[n[1]] || e.charAt(e.length - 2) === "/") && (t.voidElement = !0), t.name.startsWith("!--"))) {
    var r = e.indexOf("-->");
    return { type: "comment", comment: r !== -1 ? e.slice(4, r) : "" };
  }
  for (var i = new RegExp(Rj), o = null; (o = i.exec(e)) !== null; ) if (o[0].trim()) if (o[1]) {
    var s = o[1].trim(), a = [s, ""];
    s.indexOf("=") > -1 && (a = s.split("=")), t.attrs[a[0]] = a[1], i.lastIndex--;
  } else o[2] && (t.attrs[o[2]] = o[3].trim().substring(1, o[3].length - 1));
  return t;
}
var Pj = /<[a-zA-Z0-9\-\!\/](?:"[^"]*"|'[^']*'|[^'">])*>/g, Oj = /^\s*$/, Bj = /* @__PURE__ */ Object.create(null);
function jA(e, t) {
  switch (t.type) {
    case "text":
      return e + t.content;
    case "tag":
      return e += "<" + t.name + (t.attrs ? function(n) {
        var r = [];
        for (var i in n) r.push(i + '="' + n[i] + '"');
        return r.length ? " " + r.join(" ") : "";
      }(t.attrs) : "") + (t.voidElement ? "/>" : ">"), t.voidElement ? e : e + t.children.reduce(jA, "") + "</" + t.name + ">";
    case "comment":
      return e + "<!--" + t.comment + "-->";
  }
}
var Nj = { parse: function(e, t) {
  t || (t = {}), t.components || (t.components = Bj);
  var n, r = [], i = [], o = -1, s = !1;
  if (e.indexOf("<") !== 0) {
    var a = e.indexOf("<");
    r.push({ type: "text", content: a === -1 ? e : e.substring(0, a) });
  }
  return e.replace(Pj, function(l, c) {
    if (s) {
      if (l !== "</" + n.name + ">") return;
      s = !1;
    }
    var u, d = l.charAt(1) !== "/", f = l.startsWith("<!--"), h = c + l.length, p = e.charAt(h);
    if (f) {
      var m = FC(l);
      return o < 0 ? (r.push(m), r) : ((u = i[o]).children.push(m), r);
    }
    if (d && (o++, (n = FC(l)).type === "tag" && t.components[n.name] && (n.type = "component", s = !0), n.voidElement || s || !p || p === "<" || n.children.push({ type: "text", content: e.slice(h, e.indexOf("<", h)) }), o === 0 && r.push(n), (u = i[o - 1]) && u.children.push(n), i[o] = n), (!d || n.voidElement) && (o > -1 && (n.voidElement || n.name === l.slice(2, -1)) && (o--, n = o === -1 ? r : i[o]), !s && p !== "<" && p)) {
      u = o === -1 ? r : i[o].children;
      var g = e.indexOf("<", h), v = e.slice(h, g === -1 ? void 0 : g);
      Oj.test(v) && (v = " "), (g > -1 && o + u.length >= 0 || v !== " ") && u.push({ type: "text", content: v });
    }
  }), r;
}, stringify: function(e) {
  return e.reduce(function(t, n) {
    return t + jA("", n);
  }, "");
} };
const ch = (...e) => {
  console != null && console.warn && Zr(e[0]) && (e[0] = `react-i18next:: ${e[0]}`);
}, LC = {}, Mh = (...e) => {
  Zr(e[0]) && LC[e[0]] || (Zr(e[0]) && (LC[e[0]] = /* @__PURE__ */ new Date()), ch(...e));
}, MA = (e, t) => () => {
  if (e.isInitialized)
    t();
  else {
    const n = () => {
      setTimeout(() => {
        e.off("initialized", n);
      }, 0), t();
    };
    e.on("initialized", n);
  }
}, UC = (e, t, n) => {
  e.loadNamespaces(t, MA(e, n));
}, zC = (e, t, n, r) => {
  Zr(n) && (n = [n]), n.forEach((i) => {
    e.options.ns.indexOf(i) < 0 && e.options.ns.push(i);
  }), e.loadLanguages(t, MA(e, r));
}, Dj = (e, t, n = {}) => !t.languages || !t.languages.length ? (Mh("i18n.languages were undefined or empty", t.languages), !0) : t.hasLoadedNamespace(e, {
  lng: n.lng,
  precheck: (r, i) => {
    var o;
    if (((o = n.bindI18n) == null ? void 0 : o.indexOf("languageChanging")) > -1 && r.services.backendConnector.backend && r.isLanguageChangingTo && !i(r.isLanguageChangingTo, e)) return !1;
  }
}), Zr = (e) => typeof e == "string", fl = (e) => typeof e == "object" && e !== null, jj = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g, Mj = {
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"',
  "&nbsp;": " ",
  "&#160;": " ",
  "&copy;": "©",
  "&#169;": "©",
  "&reg;": "®",
  "&#174;": "®",
  "&hellip;": "…",
  "&#8230;": "…",
  "&#x2F;": "/",
  "&#47;": "/"
}, Fj = (e) => Mj[e], Lj = (e) => e.replace(jj, Fj);
let Lv = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: !0,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: !0,
  unescape: Lj
};
const Uj = (e = {}) => {
  Lv = {
    ...Lv,
    ...e
  };
}, FA = () => Lv;
let LA;
const zj = (e) => {
  LA = e;
}, V0 = () => LA, Tm = (e, t) => {
  var r;
  if (!e) return !1;
  const n = ((r = e.props) == null ? void 0 : r.children) ?? e.children;
  return t ? n.length > 0 : !!n;
}, _m = (e) => {
  var n, r;
  if (!e) return [];
  const t = ((n = e.props) == null ? void 0 : n.children) ?? e.children;
  return (r = e.props) != null && r.i18nIsDynamicList ? hl(t) : t;
}, Vj = (e) => Array.isArray(e) && e.every($l), hl = (e) => Array.isArray(e) ? e : [e], qj = (e, t) => {
  const n = {
    ...t
  };
  return n.props = Object.assign(e.props, t.props), n;
}, UA = (e, t) => {
  if (!e) return "";
  let n = "";
  const r = hl(e), i = t != null && t.transSupportBasicHtmlNodes ? t.transKeepBasicHtmlNodesFor ?? [] : [];
  return r.forEach((o, s) => {
    if (Zr(o))
      n += `${o}`;
    else if ($l(o)) {
      const {
        props: a,
        type: l
      } = o, c = Object.keys(a).length, u = i.indexOf(l) > -1, d = a.children;
      if (!d && u && !c)
        n += `<${l}/>`;
      else if (!d && (!u || c) || a.i18nIsDynamicList)
        n += `<${s}></${s}>`;
      else if (u && c === 1 && Zr(d))
        n += `<${l}>${d}</${l}>`;
      else {
        const f = UA(d, t);
        n += `<${s}>${f}</${s}>`;
      }
    } else if (o === null)
      ch("Trans: the passed in value is invalid - seems you passed in a null child.");
    else if (fl(o)) {
      const {
        format: a,
        ...l
      } = o, c = Object.keys(l);
      if (c.length === 1) {
        const u = a ? `${c[0]}, ${a}` : c[0];
        n += `{{${u}}}`;
      } else
        ch("react-i18next: the passed in object contained more than one variable - the object should look like {{ value, format }} where format is optional.", o);
    } else
      ch("Trans: the passed in value is invalid - seems you passed in a variable like {number} - please pass in variables for interpolation as full objects like {{number}}.", o);
  }), n;
}, $j = (e, t, n, r, i, o) => {
  if (t === "") return [];
  const s = r.transKeepBasicHtmlNodesFor || [], a = t && new RegExp(s.map((g) => `<${g}`).join("|")).test(t);
  if (!e && !a && !o) return [t];
  const l = {}, c = (g) => {
    hl(g).forEach((w) => {
      Zr(w) || (Tm(w) ? c(_m(w)) : fl(w) && !$l(w) && Object.assign(l, w));
    });
  };
  c(e);
  const u = Nj.parse(`<0>${t}</0>`), d = {
    ...l,
    ...i
  }, f = (g, v, w) => {
    var S;
    const x = _m(g), C = p(x, v.children, w);
    return Vj(x) && C.length === 0 || (S = g.props) != null && S.i18nIsDynamicList ? x : C;
  }, h = (g, v, w, x, C) => {
    g.dummy ? (g.children = v, w.push(rD(g, {
      key: x
    }, C ? void 0 : v))) : w.push(...sA.map([g], (S) => {
      const k = {
        ...S.props
      };
      return delete k.i18nIsDynamicList, Rr(S.type, {
        ...k,
        key: x,
        ref: S.ref
      }, C ? null : v);
    }));
  }, p = (g, v, w) => {
    const x = hl(g);
    return hl(v).reduce((S, k, A) => {
      var T, R;
      const b = ((R = (T = k.children) == null ? void 0 : T[0]) == null ? void 0 : R.content) && n.services.interpolator.interpolate(k.children[0].content, d, n.language);
      if (k.type === "tag") {
        let B = x[parseInt(k.name, 10)];
        w.length === 1 && !B && (B = w[0][k.name]), B || (B = {});
        const O = Object.keys(k.attrs).length !== 0 ? qj({
          props: k.attrs
        }, B) : B, L = $l(O), V = L && Tm(k, !0) && !k.voidElement, N = a && fl(O) && O.dummy && !L, M = fl(e) && Object.hasOwnProperty.call(e, k.name);
        if (Zr(O)) {
          const U = n.services.interpolator.interpolate(O, d, n.language);
          S.push(U);
        } else if (Tm(O) || V) {
          const U = f(O, k, w);
          h(O, U, S, A);
        } else if (N) {
          const U = p(x, k.children, w);
          h(O, U, S, A);
        } else if (Number.isNaN(parseFloat(k.name)))
          if (M) {
            const U = f(O, k, w);
            h(O, U, S, A, k.voidElement);
          } else if (r.transSupportBasicHtmlNodes && s.indexOf(k.name) > -1)
            if (k.voidElement)
              S.push(Rr(k.name, {
                key: `${k.name}-${A}`
              }));
            else {
              const U = p(x, k.children, w);
              S.push(Rr(k.name, {
                key: `${k.name}-${A}`
              }, U));
            }
          else if (k.voidElement)
            S.push(`<${k.name} />`);
          else {
            const U = p(x, k.children, w);
            S.push(`<${k.name}>${U}</${k.name}>`);
          }
        else if (fl(O) && !L) {
          const U = k.children[0] ? b : null;
          U && S.push(U);
        } else
          h(O, b, S, A, k.children.length !== 1 || !b);
      } else if (k.type === "text") {
        const B = r.transWrapTextNodes, O = o ? r.unescape(n.services.interpolator.interpolate(k.content, d, n.language)) : n.services.interpolator.interpolate(k.content, d, n.language);
        B ? S.push(Rr(B, {
          key: `${k.name}-${A}`
        }, O)) : S.push(O);
      }
      return S;
    }, []);
  }, m = p([{
    dummy: !0,
    children: e || []
  }], u, hl(e || []));
  return _m(m[0]);
};
function Wj({
  children: e,
  count: t,
  parent: n,
  i18nKey: r,
  context: i,
  tOptions: o = {},
  values: s,
  defaults: a,
  components: l,
  ns: c,
  i18n: u,
  t: d,
  shouldUnescape: f,
  ...h
}) {
  var B, O, L, V, N, M;
  const p = u || V0();
  if (!p)
    return Mh("You will need to pass in an i18next instance by using i18nextReactModule"), e;
  const m = d || p.t.bind(p) || ((U) => U), g = {
    ...FA(),
    ...(B = p.options) == null ? void 0 : B.react
  };
  let v = c || m.ns || ((O = p.options) == null ? void 0 : O.defaultNS);
  v = Zr(v) ? [v] : v || ["translation"];
  const w = UA(e, g), x = a || w || g.transEmptyNodeValue || r, {
    hashTransKey: C
  } = g, S = r || (C ? C(w || x) : w || x);
  (V = (L = p.options) == null ? void 0 : L.interpolation) != null && V.defaultVariables && (s = s && Object.keys(s).length > 0 ? {
    ...s,
    ...p.options.interpolation.defaultVariables
  } : {
    ...p.options.interpolation.defaultVariables
  });
  const k = s || t !== void 0 && !((M = (N = p.options) == null ? void 0 : N.interpolation) != null && M.alwaysFormat) || !e ? o.interpolation : {
    interpolation: {
      ...o.interpolation,
      prefix: "#$?",
      suffix: "?$#"
    }
  }, A = {
    ...o,
    context: i || o.context,
    count: t,
    ...s,
    ...k,
    defaultValue: x,
    ns: v
  }, b = S ? m(S, A) : x;
  l && Object.keys(l).forEach((U) => {
    const F = l[U];
    if (typeof F.type == "function" || !F.props || !F.props.children || b.indexOf(`${U}/>`) < 0 && b.indexOf(`${U} />`) < 0) return;
    function $() {
      return Rr(Tc, null, F);
    }
    l[U] = Rr($);
  });
  const T = $j(l || e, b, p, g, A, f), R = n ?? g.defaultTransParent;
  return R ? Rr(R, h, T) : T;
}
const Gj = {
  type: "3rdParty",
  init(e) {
    Uj(e.options.react), zj(e);
  }
}, q0 = Ge();
class Hj {
  constructor() {
    this.usedNamespaces = {};
  }
  addUsedNamespaces(t) {
    t.forEach((n) => {
      var r;
      (r = this.usedNamespaces)[n] ?? (r[n] = !0);
    });
  }
  getUsedNamespaces() {
    return Object.keys(this.usedNamespaces);
  }
}
function Wn({
  children: e,
  count: t,
  parent: n,
  i18nKey: r,
  context: i,
  tOptions: o = {},
  values: s,
  defaults: a,
  components: l,
  ns: c,
  i18n: u,
  t: d,
  shouldUnescape: f,
  ...h
}) {
  var w;
  const {
    i18n: p,
    defaultNS: m
  } = we(q0) || {}, g = u || p || V0(), v = d || (g == null ? void 0 : g.t.bind(g));
  return Wj({
    children: e,
    count: t,
    parent: n,
    i18nKey: r,
    context: i,
    tOptions: o,
    values: s,
    defaults: a,
    components: l,
    ns: c || (v == null ? void 0 : v.ns) || m || ((w = g == null ? void 0 : g.options) == null ? void 0 : w.defaultNS),
    i18n: g,
    t: d,
    shouldUnescape: f,
    ...h
  });
}
const Kj = (e, t) => {
  const n = It();
  return Te(() => {
    n.current = e;
  }, [e, t]), n.current;
}, zA = (e, t, n, r) => e.getFixedT(t, n, r), Yj = (e, t, n, r) => Ie(zA(e, t, n, r), [e, t, n, r]), ze = (e, t = {}) => {
  var C, S, k, A;
  const {
    i18n: n
  } = t, {
    i18n: r,
    defaultNS: i
  } = we(q0) || {}, o = n || r || V0();
  if (o && !o.reportNamespaces && (o.reportNamespaces = new Hj()), !o) {
    Mh("You will need to pass in an i18next instance by using initReactI18next");
    const b = (R, B) => Zr(B) ? B : fl(B) && Zr(B.defaultValue) ? B.defaultValue : Array.isArray(R) ? R[R.length - 1] : R, T = [b, {}, !1];
    return T.t = b, T.i18n = {}, T.ready = !1, T;
  }
  (C = o.options.react) != null && C.wait && Mh("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  const s = {
    ...FA(),
    ...o.options.react,
    ...t
  }, {
    useSuspense: a,
    keyPrefix: l
  } = s;
  let c = i || ((S = o.options) == null ? void 0 : S.defaultNS);
  c = Zr(c) ? [c] : c || ["translation"], (A = (k = o.reportNamespaces).addUsedNamespaces) == null || A.call(k, c);
  const u = (o.isInitialized || o.initializedStoreOnce) && c.every((b) => Dj(b, o, s)), d = Yj(o, t.lng || null, s.nsMode === "fallback" ? c : c[0], l), f = () => d, h = () => zA(o, t.lng || null, s.nsMode === "fallback" ? c : c[0], l), [p, m] = Oe(f);
  let g = c.join();
  t.lng && (g = `${t.lng}${g}`);
  const v = Kj(g), w = It(!0);
  Te(() => {
    const {
      bindI18n: b,
      bindI18nStore: T
    } = s;
    w.current = !0, !u && !a && (t.lng ? zC(o, t.lng, c, () => {
      w.current && m(h);
    }) : UC(o, c, () => {
      w.current && m(h);
    })), u && v && v !== g && w.current && m(h);
    const R = () => {
      w.current && m(h);
    };
    return b && (o == null || o.on(b, R)), T && (o == null || o.store.on(T, R)), () => {
      w.current = !1, o && (b == null || b.split(" ").forEach((B) => o.off(B, R))), T && o && T.split(" ").forEach((B) => o.store.off(B, R));
    };
  }, [o, g]), Te(() => {
    w.current && u && m(f);
  }, [o, l, u]);
  const x = [p, o, u];
  if (x.t = p, x.i18n = o, x.ready = u, u || !u && !a) return x;
  throw new Promise((b) => {
    t.lng ? zC(o, t.lng, c, () => b()) : UC(o, c, () => b());
  });
};
function Qj({
  i18n: e,
  defaultNS: t,
  children: n
}) {
  const r = J(() => ({
    i18n: e,
    defaultNS: t
  }), [e, t]);
  return Rr(q0.Provider, {
    value: r
  }, n);
}
const Uv = globalThis || void 0 || self;
function VA(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: Jj } = Object.prototype, { getPrototypeOf: $0 } = Object, Tp = /* @__PURE__ */ ((e) => (t) => {
  const n = Jj.call(t);
  return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Ri = (e) => (e = e.toLowerCase(), (t) => Tp(t) === e), _p = (e) => (t) => typeof t === e, { isArray: Rc } = Array, Mu = _p("undefined");
function Xj(e) {
  return e !== null && !Mu(e) && e.constructor !== null && !Mu(e.constructor) && Pr(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const qA = Ri("ArrayBuffer");
function Zj(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && qA(e.buffer), t;
}
const eM = _p("string"), Pr = _p("function"), $A = _p("number"), Ip = (e) => e !== null && typeof e == "object", tM = (e) => e === !0 || e === !1, uh = (e) => {
  if (Tp(e) !== "object")
    return !1;
  const t = $0(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, nM = Ri("Date"), rM = Ri("File"), iM = Ri("Blob"), oM = Ri("FileList"), sM = (e) => Ip(e) && Pr(e.pipe), aM = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || Pr(e.append) && ((t = Tp(e)) === "formdata" || // detect form-data instance
  t === "object" && Pr(e.toString) && e.toString() === "[object FormData]"));
}, lM = Ri("URLSearchParams"), [cM, uM, dM, fM] = ["ReadableStream", "Request", "Response", "Headers"].map(Ri), hM = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function _d(e, t, { allOwnKeys: n = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let r, i;
  if (typeof e != "object" && (e = [e]), Rc(e))
    for (r = 0, i = e.length; r < i; r++)
      t.call(null, e[r], r, e);
  else {
    const o = n ? Object.getOwnPropertyNames(e) : Object.keys(e), s = o.length;
    let a;
    for (r = 0; r < s; r++)
      a = o[r], t.call(null, e[a], a, e);
  }
}
function WA(e, t) {
  t = t.toLowerCase();
  const n = Object.keys(e);
  let r = n.length, i;
  for (; r-- > 0; )
    if (i = n[r], t === i.toLowerCase())
      return i;
  return null;
}
const ia = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : Uv, GA = (e) => !Mu(e) && e !== ia;
function zv() {
  const { caseless: e } = GA(this) && this || {}, t = {}, n = (r, i) => {
    const o = e && WA(t, i) || i;
    uh(t[o]) && uh(r) ? t[o] = zv(t[o], r) : uh(r) ? t[o] = zv({}, r) : Rc(r) ? t[o] = r.slice() : t[o] = r;
  };
  for (let r = 0, i = arguments.length; r < i; r++)
    arguments[r] && _d(arguments[r], n);
  return t;
}
const pM = (e, t, n, { allOwnKeys: r } = {}) => (_d(t, (i, o) => {
  n && Pr(i) ? e[o] = VA(i, n) : e[o] = i;
}, { allOwnKeys: r }), e), yM = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), mM = (e, t, n, r) => {
  e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), n && Object.assign(e.prototype, n);
}, gM = (e, t, n, r) => {
  let i, o, s;
  const a = {};
  if (t = t || {}, e == null) return t;
  do {
    for (i = Object.getOwnPropertyNames(e), o = i.length; o-- > 0; )
      s = i[o], (!r || r(s, e, t)) && !a[s] && (t[s] = e[s], a[s] = !0);
    e = n !== !1 && $0(e);
  } while (e && (!n || n(e, t)) && e !== Object.prototype);
  return t;
}, vM = (e, t, n) => {
  e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
  const r = e.indexOf(t, n);
  return r !== -1 && r === n;
}, bM = (e) => {
  if (!e) return null;
  if (Rc(e)) return e;
  let t = e.length;
  if (!$A(t)) return null;
  const n = new Array(t);
  for (; t-- > 0; )
    n[t] = e[t];
  return n;
}, wM = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && $0(Uint8Array)), xM = (e, t) => {
  const r = (e && e[Symbol.iterator]).call(e);
  let i;
  for (; (i = r.next()) && !i.done; ) {
    const o = i.value;
    t.call(e, o[0], o[1]);
  }
}, CM = (e, t) => {
  let n;
  const r = [];
  for (; (n = e.exec(t)) !== null; )
    r.push(n);
  return r;
}, kM = Ri("HTMLFormElement"), EM = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(n, r, i) {
    return r.toUpperCase() + i;
  }
), VC = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), SM = Ri("RegExp"), HA = (e, t) => {
  const n = Object.getOwnPropertyDescriptors(e), r = {};
  _d(n, (i, o) => {
    let s;
    (s = t(i, o, e)) !== !1 && (r[o] = s || i);
  }), Object.defineProperties(e, r);
}, AM = (e) => {
  HA(e, (t, n) => {
    if (Pr(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const r = e[n];
    if (Pr(r)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, TM = (e, t) => {
  const n = {}, r = (i) => {
    i.forEach((o) => {
      n[o] = !0;
    });
  };
  return Rc(e) ? r(e) : r(String(e).split(t)), n;
}, _M = () => {
}, IM = (e, t) => e != null && Number.isFinite(e = +e) ? e : t, Im = "abcdefghijklmnopqrstuvwxyz", qC = "0123456789", KA = {
  DIGIT: qC,
  ALPHA: Im,
  ALPHA_DIGIT: Im + Im.toUpperCase() + qC
}, RM = (e = 16, t = KA.ALPHA_DIGIT) => {
  let n = "";
  const { length: r } = t;
  for (; e--; )
    n += t[Math.random() * r | 0];
  return n;
};
function PM(e) {
  return !!(e && Pr(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const OM = (e) => {
  const t = new Array(10), n = (r, i) => {
    if (Ip(r)) {
      if (t.indexOf(r) >= 0)
        return;
      if (!("toJSON" in r)) {
        t[i] = r;
        const o = Rc(r) ? [] : {};
        return _d(r, (s, a) => {
          const l = n(s, i + 1);
          !Mu(l) && (o[a] = l);
        }), t[i] = void 0, o;
      }
    }
    return r;
  };
  return n(e, 0);
}, BM = Ri("AsyncFunction"), NM = (e) => e && (Ip(e) || Pr(e)) && Pr(e.then) && Pr(e.catch), YA = ((e, t) => e ? setImmediate : t ? ((n, r) => (ia.addEventListener("message", ({ source: i, data: o }) => {
  i === ia && o === n && r.length && r.shift()();
}, !1), (i) => {
  r.push(i), ia.postMessage(n, "*");
}))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(
  typeof setImmediate == "function",
  Pr(ia.postMessage)
), DM = typeof queueMicrotask < "u" ? queueMicrotask.bind(ia) : typeof ke < "u" && ke.nextTick || YA, fe = {
  isArray: Rc,
  isArrayBuffer: qA,
  isBuffer: Xj,
  isFormData: aM,
  isArrayBufferView: Zj,
  isString: eM,
  isNumber: $A,
  isBoolean: tM,
  isObject: Ip,
  isPlainObject: uh,
  isReadableStream: cM,
  isRequest: uM,
  isResponse: dM,
  isHeaders: fM,
  isUndefined: Mu,
  isDate: nM,
  isFile: rM,
  isBlob: iM,
  isRegExp: SM,
  isFunction: Pr,
  isStream: sM,
  isURLSearchParams: lM,
  isTypedArray: wM,
  isFileList: oM,
  forEach: _d,
  merge: zv,
  extend: pM,
  trim: hM,
  stripBOM: yM,
  inherits: mM,
  toFlatObject: gM,
  kindOf: Tp,
  kindOfTest: Ri,
  endsWith: vM,
  toArray: bM,
  forEachEntry: xM,
  matchAll: CM,
  isHTMLForm: kM,
  hasOwnProperty: VC,
  hasOwnProp: VC,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: HA,
  freezeMethods: AM,
  toObjectSet: TM,
  toCamelCase: EM,
  noop: _M,
  toFiniteNumber: IM,
  findKey: WA,
  global: ia,
  isContextDefined: GA,
  ALPHABET: KA,
  generateString: RM,
  isSpecCompliantForm: PM,
  toJSONObject: OM,
  isAsyncFn: BM,
  isThenable: NM,
  setImmediate: YA,
  asap: DM
};
var In = {}, Rp = {};
Rp.byteLength = FM;
Rp.toByteArray = UM;
Rp.fromByteArray = qM;
var Wi = [], Hr = [], jM = typeof Uint8Array < "u" ? Uint8Array : Array, Rm = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var Za = 0, MM = Rm.length; Za < MM; ++Za)
  Wi[Za] = Rm[Za], Hr[Rm.charCodeAt(Za)] = Za;
Hr[45] = 62;
Hr[95] = 63;
function QA(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var n = e.indexOf("=");
  n === -1 && (n = t);
  var r = n === t ? 0 : 4 - n % 4;
  return [n, r];
}
function FM(e) {
  var t = QA(e), n = t[0], r = t[1];
  return (n + r) * 3 / 4 - r;
}
function LM(e, t, n) {
  return (t + n) * 3 / 4 - n;
}
function UM(e) {
  var t, n = QA(e), r = n[0], i = n[1], o = new jM(LM(e, r, i)), s = 0, a = i > 0 ? r - 4 : r, l;
  for (l = 0; l < a; l += 4)
    t = Hr[e.charCodeAt(l)] << 18 | Hr[e.charCodeAt(l + 1)] << 12 | Hr[e.charCodeAt(l + 2)] << 6 | Hr[e.charCodeAt(l + 3)], o[s++] = t >> 16 & 255, o[s++] = t >> 8 & 255, o[s++] = t & 255;
  return i === 2 && (t = Hr[e.charCodeAt(l)] << 2 | Hr[e.charCodeAt(l + 1)] >> 4, o[s++] = t & 255), i === 1 && (t = Hr[e.charCodeAt(l)] << 10 | Hr[e.charCodeAt(l + 1)] << 4 | Hr[e.charCodeAt(l + 2)] >> 2, o[s++] = t >> 8 & 255, o[s++] = t & 255), o;
}
function zM(e) {
  return Wi[e >> 18 & 63] + Wi[e >> 12 & 63] + Wi[e >> 6 & 63] + Wi[e & 63];
}
function VM(e, t, n) {
  for (var r, i = [], o = t; o < n; o += 3)
    r = (e[o] << 16 & 16711680) + (e[o + 1] << 8 & 65280) + (e[o + 2] & 255), i.push(zM(r));
  return i.join("");
}
function qM(e) {
  for (var t, n = e.length, r = n % 3, i = [], o = 16383, s = 0, a = n - r; s < a; s += o)
    i.push(VM(e, s, s + o > a ? a : s + o));
  return r === 1 ? (t = e[n - 1], i.push(
    Wi[t >> 2] + Wi[t << 4 & 63] + "=="
  )) : r === 2 && (t = (e[n - 2] << 8) + e[n - 1], i.push(
    Wi[t >> 10] + Wi[t >> 4 & 63] + Wi[t << 2 & 63] + "="
  )), i.join("");
}
var W0 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
W0.read = function(e, t, n, r, i) {
  var o, s, a = i * 8 - r - 1, l = (1 << a) - 1, c = l >> 1, u = -7, d = n ? i - 1 : 0, f = n ? -1 : 1, h = e[t + d];
  for (d += f, o = h & (1 << -u) - 1, h >>= -u, u += a; u > 0; o = o * 256 + e[t + d], d += f, u -= 8)
    ;
  for (s = o & (1 << -u) - 1, o >>= -u, u += r; u > 0; s = s * 256 + e[t + d], d += f, u -= 8)
    ;
  if (o === 0)
    o = 1 - c;
  else {
    if (o === l)
      return s ? NaN : (h ? -1 : 1) * (1 / 0);
    s = s + Math.pow(2, r), o = o - c;
  }
  return (h ? -1 : 1) * s * Math.pow(2, o - r);
};
W0.write = function(e, t, n, r, i, o) {
  var s, a, l, c = o * 8 - i - 1, u = (1 << c) - 1, d = u >> 1, f = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, h = r ? 0 : o - 1, p = r ? 1 : -1, m = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, s = u) : (s = Math.floor(Math.log(t) / Math.LN2), t * (l = Math.pow(2, -s)) < 1 && (s--, l *= 2), s + d >= 1 ? t += f / l : t += f * Math.pow(2, 1 - d), t * l >= 2 && (s++, l /= 2), s + d >= u ? (a = 0, s = u) : s + d >= 1 ? (a = (t * l - 1) * Math.pow(2, i), s = s + d) : (a = t * Math.pow(2, d - 1) * Math.pow(2, i), s = 0)); i >= 8; e[n + h] = a & 255, h += p, a /= 256, i -= 8)
    ;
  for (s = s << i | a, c += i; c > 0; e[n + h] = s & 255, h += p, s /= 256, c -= 8)
    ;
  e[n + h - p] |= m * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  const t = Rp, n = W0, r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = u, e.SlowBuffer = S, e.INSPECT_MAX_BYTES = 50;
  const i = 2147483647;
  e.kMaxLength = i;
  const { Uint8Array: o, ArrayBuffer: s, SharedArrayBuffer: a } = globalThis;
  u.TYPED_ARRAY_SUPPORT = l(), !u.TYPED_ARRAY_SUPPORT && typeof console < "u";
  function l() {
    try {
      const D = new o(1), E = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(E, o.prototype), Object.setPrototypeOf(D, E), D.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(u.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (u.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(u.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (u.isBuffer(this))
        return this.byteOffset;
    }
  });
  function c(D) {
    if (D > i)
      throw new RangeError('The value "' + D + '" is invalid for option "size"');
    const E = new o(D);
    return Object.setPrototypeOf(E, u.prototype), E;
  }
  function u(D, E, _) {
    if (typeof D == "number") {
      if (typeof E == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return p(D);
    }
    return d(D, E, _);
  }
  u.poolSize = 8192;
  function d(D, E, _) {
    if (typeof D == "string")
      return m(D, E);
    if (s.isView(D))
      return v(D);
    if (D == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof D
      );
    if (Ve(D, s) || D && Ve(D.buffer, s) || typeof a < "u" && (Ve(D, a) || D && Ve(D.buffer, a)))
      return w(D, E, _);
    if (typeof D == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const q = D.valueOf && D.valueOf();
    if (q != null && q !== D)
      return u.from(q, E, _);
    const Z = x(D);
    if (Z) return Z;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof D[Symbol.toPrimitive] == "function")
      return u.from(D[Symbol.toPrimitive]("string"), E, _);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof D
    );
  }
  u.from = function(D, E, _) {
    return d(D, E, _);
  }, Object.setPrototypeOf(u.prototype, o.prototype), Object.setPrototypeOf(u, o);
  function f(D) {
    if (typeof D != "number")
      throw new TypeError('"size" argument must be of type number');
    if (D < 0)
      throw new RangeError('The value "' + D + '" is invalid for option "size"');
  }
  function h(D, E, _) {
    return f(D), D <= 0 ? c(D) : E !== void 0 ? typeof _ == "string" ? c(D).fill(E, _) : c(D).fill(E) : c(D);
  }
  u.alloc = function(D, E, _) {
    return h(D, E, _);
  };
  function p(D) {
    return f(D), c(D < 0 ? 0 : C(D) | 0);
  }
  u.allocUnsafe = function(D) {
    return p(D);
  }, u.allocUnsafeSlow = function(D) {
    return p(D);
  };
  function m(D, E) {
    if ((typeof E != "string" || E === "") && (E = "utf8"), !u.isEncoding(E))
      throw new TypeError("Unknown encoding: " + E);
    const _ = k(D, E) | 0;
    let q = c(_);
    const Z = q.write(D, E);
    return Z !== _ && (q = q.slice(0, Z)), q;
  }
  function g(D) {
    const E = D.length < 0 ? 0 : C(D.length) | 0, _ = c(E);
    for (let q = 0; q < E; q += 1)
      _[q] = D[q] & 255;
    return _;
  }
  function v(D) {
    if (Ve(D, o)) {
      const E = new o(D);
      return w(E.buffer, E.byteOffset, E.byteLength);
    }
    return g(D);
  }
  function w(D, E, _) {
    if (E < 0 || D.byteLength < E)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (D.byteLength < E + (_ || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let q;
    return E === void 0 && _ === void 0 ? q = new o(D) : _ === void 0 ? q = new o(D, E) : q = new o(D, E, _), Object.setPrototypeOf(q, u.prototype), q;
  }
  function x(D) {
    if (u.isBuffer(D)) {
      const E = C(D.length) | 0, _ = c(E);
      return _.length === 0 || D.copy(_, 0, 0, E), _;
    }
    if (D.length !== void 0)
      return typeof D.length != "number" || nt(D.length) ? c(0) : g(D);
    if (D.type === "Buffer" && Array.isArray(D.data))
      return g(D.data);
  }
  function C(D) {
    if (D >= i)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
    return D | 0;
  }
  function S(D) {
    return +D != D && (D = 0), u.alloc(+D);
  }
  u.isBuffer = function(E) {
    return E != null && E._isBuffer === !0 && E !== u.prototype;
  }, u.compare = function(E, _) {
    if (Ve(E, o) && (E = u.from(E, E.offset, E.byteLength)), Ve(_, o) && (_ = u.from(_, _.offset, _.byteLength)), !u.isBuffer(E) || !u.isBuffer(_))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (E === _) return 0;
    let q = E.length, Z = _.length;
    for (let re = 0, pe = Math.min(q, Z); re < pe; ++re)
      if (E[re] !== _[re]) {
        q = E[re], Z = _[re];
        break;
      }
    return q < Z ? -1 : Z < q ? 1 : 0;
  }, u.isEncoding = function(E) {
    switch (String(E).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, u.concat = function(E, _) {
    if (!Array.isArray(E))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (E.length === 0)
      return u.alloc(0);
    let q;
    if (_ === void 0)
      for (_ = 0, q = 0; q < E.length; ++q)
        _ += E[q].length;
    const Z = u.allocUnsafe(_);
    let re = 0;
    for (q = 0; q < E.length; ++q) {
      let pe = E[q];
      if (Ve(pe, o))
        re + pe.length > Z.length ? (u.isBuffer(pe) || (pe = u.from(pe)), pe.copy(Z, re)) : o.prototype.set.call(
          Z,
          pe,
          re
        );
      else if (u.isBuffer(pe))
        pe.copy(Z, re);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      re += pe.length;
    }
    return Z;
  };
  function k(D, E) {
    if (u.isBuffer(D))
      return D.length;
    if (s.isView(D) || Ve(D, s))
      return D.byteLength;
    if (typeof D != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof D
      );
    const _ = D.length, q = arguments.length > 2 && arguments[2] === !0;
    if (!q && _ === 0) return 0;
    let Z = !1;
    for (; ; )
      switch (E) {
        case "ascii":
        case "latin1":
        case "binary":
          return _;
        case "utf8":
        case "utf-8":
          return jn(D).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return _ * 2;
        case "hex":
          return _ >>> 1;
        case "base64":
          return qt(D).length;
        default:
          if (Z)
            return q ? -1 : jn(D).length;
          E = ("" + E).toLowerCase(), Z = !0;
      }
  }
  u.byteLength = k;
  function A(D, E, _) {
    let q = !1;
    if ((E === void 0 || E < 0) && (E = 0), E > this.length || ((_ === void 0 || _ > this.length) && (_ = this.length), _ <= 0) || (_ >>>= 0, E >>>= 0, _ <= E))
      return "";
    for (D || (D = "utf8"); ; )
      switch (D) {
        case "hex":
          return ae(this, E, _);
        case "utf8":
        case "utf-8":
          return U(this, E, _);
        case "ascii":
          return ie(this, E, _);
        case "latin1":
        case "binary":
          return he(this, E, _);
        case "base64":
          return M(this, E, _);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return se(this, E, _);
        default:
          if (q) throw new TypeError("Unknown encoding: " + D);
          D = (D + "").toLowerCase(), q = !0;
      }
  }
  u.prototype._isBuffer = !0;
  function b(D, E, _) {
    const q = D[E];
    D[E] = D[_], D[_] = q;
  }
  u.prototype.swap16 = function() {
    const E = this.length;
    if (E % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let _ = 0; _ < E; _ += 2)
      b(this, _, _ + 1);
    return this;
  }, u.prototype.swap32 = function() {
    const E = this.length;
    if (E % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let _ = 0; _ < E; _ += 4)
      b(this, _, _ + 3), b(this, _ + 1, _ + 2);
    return this;
  }, u.prototype.swap64 = function() {
    const E = this.length;
    if (E % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let _ = 0; _ < E; _ += 8)
      b(this, _, _ + 7), b(this, _ + 1, _ + 6), b(this, _ + 2, _ + 5), b(this, _ + 3, _ + 4);
    return this;
  }, u.prototype.toString = function() {
    const E = this.length;
    return E === 0 ? "" : arguments.length === 0 ? U(this, 0, E) : A.apply(this, arguments);
  }, u.prototype.toLocaleString = u.prototype.toString, u.prototype.equals = function(E) {
    if (!u.isBuffer(E)) throw new TypeError("Argument must be a Buffer");
    return this === E ? !0 : u.compare(this, E) === 0;
  }, u.prototype.inspect = function() {
    let E = "";
    const _ = e.INSPECT_MAX_BYTES;
    return E = this.toString("hex", 0, _).replace(/(.{2})/g, "$1 ").trim(), this.length > _ && (E += " ... "), "<Buffer " + E + ">";
  }, r && (u.prototype[r] = u.prototype.inspect), u.prototype.compare = function(E, _, q, Z, re) {
    if (Ve(E, o) && (E = u.from(E, E.offset, E.byteLength)), !u.isBuffer(E))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof E
      );
    if (_ === void 0 && (_ = 0), q === void 0 && (q = E ? E.length : 0), Z === void 0 && (Z = 0), re === void 0 && (re = this.length), _ < 0 || q > E.length || Z < 0 || re > this.length)
      throw new RangeError("out of range index");
    if (Z >= re && _ >= q)
      return 0;
    if (Z >= re)
      return -1;
    if (_ >= q)
      return 1;
    if (_ >>>= 0, q >>>= 0, Z >>>= 0, re >>>= 0, this === E) return 0;
    let pe = re - Z, He = q - _;
    const xt = Math.min(pe, He), St = this.slice(Z, re), Ct = E.slice(_, q);
    for (let Ze = 0; Ze < xt; ++Ze)
      if (St[Ze] !== Ct[Ze]) {
        pe = St[Ze], He = Ct[Ze];
        break;
      }
    return pe < He ? -1 : He < pe ? 1 : 0;
  };
  function T(D, E, _, q, Z) {
    if (D.length === 0) return -1;
    if (typeof _ == "string" ? (q = _, _ = 0) : _ > 2147483647 ? _ = 2147483647 : _ < -2147483648 && (_ = -2147483648), _ = +_, nt(_) && (_ = Z ? 0 : D.length - 1), _ < 0 && (_ = D.length + _), _ >= D.length) {
      if (Z) return -1;
      _ = D.length - 1;
    } else if (_ < 0)
      if (Z) _ = 0;
      else return -1;
    if (typeof E == "string" && (E = u.from(E, q)), u.isBuffer(E))
      return E.length === 0 ? -1 : R(D, E, _, q, Z);
    if (typeof E == "number")
      return E = E & 255, typeof o.prototype.indexOf == "function" ? Z ? o.prototype.indexOf.call(D, E, _) : o.prototype.lastIndexOf.call(D, E, _) : R(D, [E], _, q, Z);
    throw new TypeError("val must be string, number or Buffer");
  }
  function R(D, E, _, q, Z) {
    let re = 1, pe = D.length, He = E.length;
    if (q !== void 0 && (q = String(q).toLowerCase(), q === "ucs2" || q === "ucs-2" || q === "utf16le" || q === "utf-16le")) {
      if (D.length < 2 || E.length < 2)
        return -1;
      re = 2, pe /= 2, He /= 2, _ /= 2;
    }
    function xt(Ct, Ze) {
      return re === 1 ? Ct[Ze] : Ct.readUInt16BE(Ze * re);
    }
    let St;
    if (Z) {
      let Ct = -1;
      for (St = _; St < pe; St++)
        if (xt(D, St) === xt(E, Ct === -1 ? 0 : St - Ct)) {
          if (Ct === -1 && (Ct = St), St - Ct + 1 === He) return Ct * re;
        } else
          Ct !== -1 && (St -= St - Ct), Ct = -1;
    } else
      for (_ + He > pe && (_ = pe - He), St = _; St >= 0; St--) {
        let Ct = !0;
        for (let Ze = 0; Ze < He; Ze++)
          if (xt(D, St + Ze) !== xt(E, Ze)) {
            Ct = !1;
            break;
          }
        if (Ct) return St;
      }
    return -1;
  }
  u.prototype.includes = function(E, _, q) {
    return this.indexOf(E, _, q) !== -1;
  }, u.prototype.indexOf = function(E, _, q) {
    return T(this, E, _, q, !0);
  }, u.prototype.lastIndexOf = function(E, _, q) {
    return T(this, E, _, q, !1);
  };
  function B(D, E, _, q) {
    _ = Number(_) || 0;
    const Z = D.length - _;
    q ? (q = Number(q), q > Z && (q = Z)) : q = Z;
    const re = E.length;
    q > re / 2 && (q = re / 2);
    let pe;
    for (pe = 0; pe < q; ++pe) {
      const He = parseInt(E.substr(pe * 2, 2), 16);
      if (nt(He)) return pe;
      D[_ + pe] = He;
    }
    return pe;
  }
  function O(D, E, _, q) {
    return Cn(jn(E, D.length - _), D, _, q);
  }
  function L(D, E, _, q) {
    return Cn(tr(E), D, _, q);
  }
  function V(D, E, _, q) {
    return Cn(qt(E), D, _, q);
  }
  function N(D, E, _, q) {
    return Cn(Ot(E, D.length - _), D, _, q);
  }
  u.prototype.write = function(E, _, q, Z) {
    if (_ === void 0)
      Z = "utf8", q = this.length, _ = 0;
    else if (q === void 0 && typeof _ == "string")
      Z = _, q = this.length, _ = 0;
    else if (isFinite(_))
      _ = _ >>> 0, isFinite(q) ? (q = q >>> 0, Z === void 0 && (Z = "utf8")) : (Z = q, q = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const re = this.length - _;
    if ((q === void 0 || q > re) && (q = re), E.length > 0 && (q < 0 || _ < 0) || _ > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    Z || (Z = "utf8");
    let pe = !1;
    for (; ; )
      switch (Z) {
        case "hex":
          return B(this, E, _, q);
        case "utf8":
        case "utf-8":
          return O(this, E, _, q);
        case "ascii":
        case "latin1":
        case "binary":
          return L(this, E, _, q);
        case "base64":
          return V(this, E, _, q);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return N(this, E, _, q);
        default:
          if (pe) throw new TypeError("Unknown encoding: " + Z);
          Z = ("" + Z).toLowerCase(), pe = !0;
      }
  }, u.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function M(D, E, _) {
    return E === 0 && _ === D.length ? t.fromByteArray(D) : t.fromByteArray(D.slice(E, _));
  }
  function U(D, E, _) {
    _ = Math.min(D.length, _);
    const q = [];
    let Z = E;
    for (; Z < _; ) {
      const re = D[Z];
      let pe = null, He = re > 239 ? 4 : re > 223 ? 3 : re > 191 ? 2 : 1;
      if (Z + He <= _) {
        let xt, St, Ct, Ze;
        switch (He) {
          case 1:
            re < 128 && (pe = re);
            break;
          case 2:
            xt = D[Z + 1], (xt & 192) === 128 && (Ze = (re & 31) << 6 | xt & 63, Ze > 127 && (pe = Ze));
            break;
          case 3:
            xt = D[Z + 1], St = D[Z + 2], (xt & 192) === 128 && (St & 192) === 128 && (Ze = (re & 15) << 12 | (xt & 63) << 6 | St & 63, Ze > 2047 && (Ze < 55296 || Ze > 57343) && (pe = Ze));
            break;
          case 4:
            xt = D[Z + 1], St = D[Z + 2], Ct = D[Z + 3], (xt & 192) === 128 && (St & 192) === 128 && (Ct & 192) === 128 && (Ze = (re & 15) << 18 | (xt & 63) << 12 | (St & 63) << 6 | Ct & 63, Ze > 65535 && Ze < 1114112 && (pe = Ze));
        }
      }
      pe === null ? (pe = 65533, He = 1) : pe > 65535 && (pe -= 65536, q.push(pe >>> 10 & 1023 | 55296), pe = 56320 | pe & 1023), q.push(pe), Z += He;
    }
    return $(q);
  }
  const F = 4096;
  function $(D) {
    const E = D.length;
    if (E <= F)
      return String.fromCharCode.apply(String, D);
    let _ = "", q = 0;
    for (; q < E; )
      _ += String.fromCharCode.apply(
        String,
        D.slice(q, q += F)
      );
    return _;
  }
  function ie(D, E, _) {
    let q = "";
    _ = Math.min(D.length, _);
    for (let Z = E; Z < _; ++Z)
      q += String.fromCharCode(D[Z] & 127);
    return q;
  }
  function he(D, E, _) {
    let q = "";
    _ = Math.min(D.length, _);
    for (let Z = E; Z < _; ++Z)
      q += String.fromCharCode(D[Z]);
    return q;
  }
  function ae(D, E, _) {
    const q = D.length;
    (!E || E < 0) && (E = 0), (!_ || _ < 0 || _ > q) && (_ = q);
    let Z = "";
    for (let re = E; re < _; ++re)
      Z += je[D[re]];
    return Z;
  }
  function se(D, E, _) {
    const q = D.slice(E, _);
    let Z = "";
    for (let re = 0; re < q.length - 1; re += 2)
      Z += String.fromCharCode(q[re] + q[re + 1] * 256);
    return Z;
  }
  u.prototype.slice = function(E, _) {
    const q = this.length;
    E = ~~E, _ = _ === void 0 ? q : ~~_, E < 0 ? (E += q, E < 0 && (E = 0)) : E > q && (E = q), _ < 0 ? (_ += q, _ < 0 && (_ = 0)) : _ > q && (_ = q), _ < E && (_ = E);
    const Z = this.subarray(E, _);
    return Object.setPrototypeOf(Z, u.prototype), Z;
  };
  function oe(D, E, _) {
    if (D % 1 !== 0 || D < 0) throw new RangeError("offset is not uint");
    if (D + E > _) throw new RangeError("Trying to access beyond buffer length");
  }
  u.prototype.readUintLE = u.prototype.readUIntLE = function(E, _, q) {
    E = E >>> 0, _ = _ >>> 0, q || oe(E, _, this.length);
    let Z = this[E], re = 1, pe = 0;
    for (; ++pe < _ && (re *= 256); )
      Z += this[E + pe] * re;
    return Z;
  }, u.prototype.readUintBE = u.prototype.readUIntBE = function(E, _, q) {
    E = E >>> 0, _ = _ >>> 0, q || oe(E, _, this.length);
    let Z = this[E + --_], re = 1;
    for (; _ > 0 && (re *= 256); )
      Z += this[E + --_] * re;
    return Z;
  }, u.prototype.readUint8 = u.prototype.readUInt8 = function(E, _) {
    return E = E >>> 0, _ || oe(E, 1, this.length), this[E];
  }, u.prototype.readUint16LE = u.prototype.readUInt16LE = function(E, _) {
    return E = E >>> 0, _ || oe(E, 2, this.length), this[E] | this[E + 1] << 8;
  }, u.prototype.readUint16BE = u.prototype.readUInt16BE = function(E, _) {
    return E = E >>> 0, _ || oe(E, 2, this.length), this[E] << 8 | this[E + 1];
  }, u.prototype.readUint32LE = u.prototype.readUInt32LE = function(E, _) {
    return E = E >>> 0, _ || oe(E, 4, this.length), (this[E] | this[E + 1] << 8 | this[E + 2] << 16) + this[E + 3] * 16777216;
  }, u.prototype.readUint32BE = u.prototype.readUInt32BE = function(E, _) {
    return E = E >>> 0, _ || oe(E, 4, this.length), this[E] * 16777216 + (this[E + 1] << 16 | this[E + 2] << 8 | this[E + 3]);
  }, u.prototype.readBigUInt64LE = st(function(E) {
    E = E >>> 0, jt(E, "offset");
    const _ = this[E], q = this[E + 7];
    (_ === void 0 || q === void 0) && rn(E, this.length - 8);
    const Z = _ + this[++E] * 2 ** 8 + this[++E] * 2 ** 16 + this[++E] * 2 ** 24, re = this[++E] + this[++E] * 2 ** 8 + this[++E] * 2 ** 16 + q * 2 ** 24;
    return BigInt(Z) + (BigInt(re) << BigInt(32));
  }), u.prototype.readBigUInt64BE = st(function(E) {
    E = E >>> 0, jt(E, "offset");
    const _ = this[E], q = this[E + 7];
    (_ === void 0 || q === void 0) && rn(E, this.length - 8);
    const Z = _ * 2 ** 24 + this[++E] * 2 ** 16 + this[++E] * 2 ** 8 + this[++E], re = this[++E] * 2 ** 24 + this[++E] * 2 ** 16 + this[++E] * 2 ** 8 + q;
    return (BigInt(Z) << BigInt(32)) + BigInt(re);
  }), u.prototype.readIntLE = function(E, _, q) {
    E = E >>> 0, _ = _ >>> 0, q || oe(E, _, this.length);
    let Z = this[E], re = 1, pe = 0;
    for (; ++pe < _ && (re *= 256); )
      Z += this[E + pe] * re;
    return re *= 128, Z >= re && (Z -= Math.pow(2, 8 * _)), Z;
  }, u.prototype.readIntBE = function(E, _, q) {
    E = E >>> 0, _ = _ >>> 0, q || oe(E, _, this.length);
    let Z = _, re = 1, pe = this[E + --Z];
    for (; Z > 0 && (re *= 256); )
      pe += this[E + --Z] * re;
    return re *= 128, pe >= re && (pe -= Math.pow(2, 8 * _)), pe;
  }, u.prototype.readInt8 = function(E, _) {
    return E = E >>> 0, _ || oe(E, 1, this.length), this[E] & 128 ? (255 - this[E] + 1) * -1 : this[E];
  }, u.prototype.readInt16LE = function(E, _) {
    E = E >>> 0, _ || oe(E, 2, this.length);
    const q = this[E] | this[E + 1] << 8;
    return q & 32768 ? q | 4294901760 : q;
  }, u.prototype.readInt16BE = function(E, _) {
    E = E >>> 0, _ || oe(E, 2, this.length);
    const q = this[E + 1] | this[E] << 8;
    return q & 32768 ? q | 4294901760 : q;
  }, u.prototype.readInt32LE = function(E, _) {
    return E = E >>> 0, _ || oe(E, 4, this.length), this[E] | this[E + 1] << 8 | this[E + 2] << 16 | this[E + 3] << 24;
  }, u.prototype.readInt32BE = function(E, _) {
    return E = E >>> 0, _ || oe(E, 4, this.length), this[E] << 24 | this[E + 1] << 16 | this[E + 2] << 8 | this[E + 3];
  }, u.prototype.readBigInt64LE = st(function(E) {
    E = E >>> 0, jt(E, "offset");
    const _ = this[E], q = this[E + 7];
    (_ === void 0 || q === void 0) && rn(E, this.length - 8);
    const Z = this[E + 4] + this[E + 5] * 2 ** 8 + this[E + 6] * 2 ** 16 + (q << 24);
    return (BigInt(Z) << BigInt(32)) + BigInt(_ + this[++E] * 2 ** 8 + this[++E] * 2 ** 16 + this[++E] * 2 ** 24);
  }), u.prototype.readBigInt64BE = st(function(E) {
    E = E >>> 0, jt(E, "offset");
    const _ = this[E], q = this[E + 7];
    (_ === void 0 || q === void 0) && rn(E, this.length - 8);
    const Z = (_ << 24) + // Overflow
    this[++E] * 2 ** 16 + this[++E] * 2 ** 8 + this[++E];
    return (BigInt(Z) << BigInt(32)) + BigInt(this[++E] * 2 ** 24 + this[++E] * 2 ** 16 + this[++E] * 2 ** 8 + q);
  }), u.prototype.readFloatLE = function(E, _) {
    return E = E >>> 0, _ || oe(E, 4, this.length), n.read(this, E, !0, 23, 4);
  }, u.prototype.readFloatBE = function(E, _) {
    return E = E >>> 0, _ || oe(E, 4, this.length), n.read(this, E, !1, 23, 4);
  }, u.prototype.readDoubleLE = function(E, _) {
    return E = E >>> 0, _ || oe(E, 8, this.length), n.read(this, E, !0, 52, 8);
  }, u.prototype.readDoubleBE = function(E, _) {
    return E = E >>> 0, _ || oe(E, 8, this.length), n.read(this, E, !1, 52, 8);
  };
  function ye(D, E, _, q, Z, re) {
    if (!u.isBuffer(D)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (E > Z || E < re) throw new RangeError('"value" argument is out of bounds');
    if (_ + q > D.length) throw new RangeError("Index out of range");
  }
  u.prototype.writeUintLE = u.prototype.writeUIntLE = function(E, _, q, Z) {
    if (E = +E, _ = _ >>> 0, q = q >>> 0, !Z) {
      const He = Math.pow(2, 8 * q) - 1;
      ye(this, E, _, q, He, 0);
    }
    let re = 1, pe = 0;
    for (this[_] = E & 255; ++pe < q && (re *= 256); )
      this[_ + pe] = E / re & 255;
    return _ + q;
  }, u.prototype.writeUintBE = u.prototype.writeUIntBE = function(E, _, q, Z) {
    if (E = +E, _ = _ >>> 0, q = q >>> 0, !Z) {
      const He = Math.pow(2, 8 * q) - 1;
      ye(this, E, _, q, He, 0);
    }
    let re = q - 1, pe = 1;
    for (this[_ + re] = E & 255; --re >= 0 && (pe *= 256); )
      this[_ + re] = E / pe & 255;
    return _ + q;
  }, u.prototype.writeUint8 = u.prototype.writeUInt8 = function(E, _, q) {
    return E = +E, _ = _ >>> 0, q || ye(this, E, _, 1, 255, 0), this[_] = E & 255, _ + 1;
  }, u.prototype.writeUint16LE = u.prototype.writeUInt16LE = function(E, _, q) {
    return E = +E, _ = _ >>> 0, q || ye(this, E, _, 2, 65535, 0), this[_] = E & 255, this[_ + 1] = E >>> 8, _ + 2;
  }, u.prototype.writeUint16BE = u.prototype.writeUInt16BE = function(E, _, q) {
    return E = +E, _ = _ >>> 0, q || ye(this, E, _, 2, 65535, 0), this[_] = E >>> 8, this[_ + 1] = E & 255, _ + 2;
  }, u.prototype.writeUint32LE = u.prototype.writeUInt32LE = function(E, _, q) {
    return E = +E, _ = _ >>> 0, q || ye(this, E, _, 4, 4294967295, 0), this[_ + 3] = E >>> 24, this[_ + 2] = E >>> 16, this[_ + 1] = E >>> 8, this[_] = E & 255, _ + 4;
  }, u.prototype.writeUint32BE = u.prototype.writeUInt32BE = function(E, _, q) {
    return E = +E, _ = _ >>> 0, q || ye(this, E, _, 4, 4294967295, 0), this[_] = E >>> 24, this[_ + 1] = E >>> 16, this[_ + 2] = E >>> 8, this[_ + 3] = E & 255, _ + 4;
  };
  function ve(D, E, _, q, Z) {
    tt(E, q, Z, D, _, 7);
    let re = Number(E & BigInt(4294967295));
    D[_++] = re, re = re >> 8, D[_++] = re, re = re >> 8, D[_++] = re, re = re >> 8, D[_++] = re;
    let pe = Number(E >> BigInt(32) & BigInt(4294967295));
    return D[_++] = pe, pe = pe >> 8, D[_++] = pe, pe = pe >> 8, D[_++] = pe, pe = pe >> 8, D[_++] = pe, _;
  }
  function Be(D, E, _, q, Z) {
    tt(E, q, Z, D, _, 7);
    let re = Number(E & BigInt(4294967295));
    D[_ + 7] = re, re = re >> 8, D[_ + 6] = re, re = re >> 8, D[_ + 5] = re, re = re >> 8, D[_ + 4] = re;
    let pe = Number(E >> BigInt(32) & BigInt(4294967295));
    return D[_ + 3] = pe, pe = pe >> 8, D[_ + 2] = pe, pe = pe >> 8, D[_ + 1] = pe, pe = pe >> 8, D[_] = pe, _ + 8;
  }
  u.prototype.writeBigUInt64LE = st(function(E, _ = 0) {
    return ve(this, E, _, BigInt(0), BigInt("0xffffffffffffffff"));
  }), u.prototype.writeBigUInt64BE = st(function(E, _ = 0) {
    return Be(this, E, _, BigInt(0), BigInt("0xffffffffffffffff"));
  }), u.prototype.writeIntLE = function(E, _, q, Z) {
    if (E = +E, _ = _ >>> 0, !Z) {
      const xt = Math.pow(2, 8 * q - 1);
      ye(this, E, _, q, xt - 1, -xt);
    }
    let re = 0, pe = 1, He = 0;
    for (this[_] = E & 255; ++re < q && (pe *= 256); )
      E < 0 && He === 0 && this[_ + re - 1] !== 0 && (He = 1), this[_ + re] = (E / pe >> 0) - He & 255;
    return _ + q;
  }, u.prototype.writeIntBE = function(E, _, q, Z) {
    if (E = +E, _ = _ >>> 0, !Z) {
      const xt = Math.pow(2, 8 * q - 1);
      ye(this, E, _, q, xt - 1, -xt);
    }
    let re = q - 1, pe = 1, He = 0;
    for (this[_ + re] = E & 255; --re >= 0 && (pe *= 256); )
      E < 0 && He === 0 && this[_ + re + 1] !== 0 && (He = 1), this[_ + re] = (E / pe >> 0) - He & 255;
    return _ + q;
  }, u.prototype.writeInt8 = function(E, _, q) {
    return E = +E, _ = _ >>> 0, q || ye(this, E, _, 1, 127, -128), E < 0 && (E = 255 + E + 1), this[_] = E & 255, _ + 1;
  }, u.prototype.writeInt16LE = function(E, _, q) {
    return E = +E, _ = _ >>> 0, q || ye(this, E, _, 2, 32767, -32768), this[_] = E & 255, this[_ + 1] = E >>> 8, _ + 2;
  }, u.prototype.writeInt16BE = function(E, _, q) {
    return E = +E, _ = _ >>> 0, q || ye(this, E, _, 2, 32767, -32768), this[_] = E >>> 8, this[_ + 1] = E & 255, _ + 2;
  }, u.prototype.writeInt32LE = function(E, _, q) {
    return E = +E, _ = _ >>> 0, q || ye(this, E, _, 4, 2147483647, -2147483648), this[_] = E & 255, this[_ + 1] = E >>> 8, this[_ + 2] = E >>> 16, this[_ + 3] = E >>> 24, _ + 4;
  }, u.prototype.writeInt32BE = function(E, _, q) {
    return E = +E, _ = _ >>> 0, q || ye(this, E, _, 4, 2147483647, -2147483648), E < 0 && (E = 4294967295 + E + 1), this[_] = E >>> 24, this[_ + 1] = E >>> 16, this[_ + 2] = E >>> 8, this[_ + 3] = E & 255, _ + 4;
  }, u.prototype.writeBigInt64LE = st(function(E, _ = 0) {
    return ve(this, E, _, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), u.prototype.writeBigInt64BE = st(function(E, _ = 0) {
    return Be(this, E, _, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function it(D, E, _, q, Z, re) {
    if (_ + q > D.length) throw new RangeError("Index out of range");
    if (_ < 0) throw new RangeError("Index out of range");
  }
  function lt(D, E, _, q, Z) {
    return E = +E, _ = _ >>> 0, Z || it(D, E, _, 4), n.write(D, E, _, q, 23, 4), _ + 4;
  }
  u.prototype.writeFloatLE = function(E, _, q) {
    return lt(this, E, _, !0, q);
  }, u.prototype.writeFloatBE = function(E, _, q) {
    return lt(this, E, _, !1, q);
  };
  function yt(D, E, _, q, Z) {
    return E = +E, _ = _ >>> 0, Z || it(D, E, _, 8), n.write(D, E, _, q, 52, 8), _ + 8;
  }
  u.prototype.writeDoubleLE = function(E, _, q) {
    return yt(this, E, _, !0, q);
  }, u.prototype.writeDoubleBE = function(E, _, q) {
    return yt(this, E, _, !1, q);
  }, u.prototype.copy = function(E, _, q, Z) {
    if (!u.isBuffer(E)) throw new TypeError("argument should be a Buffer");
    if (q || (q = 0), !Z && Z !== 0 && (Z = this.length), _ >= E.length && (_ = E.length), _ || (_ = 0), Z > 0 && Z < q && (Z = q), Z === q || E.length === 0 || this.length === 0) return 0;
    if (_ < 0)
      throw new RangeError("targetStart out of bounds");
    if (q < 0 || q >= this.length) throw new RangeError("Index out of range");
    if (Z < 0) throw new RangeError("sourceEnd out of bounds");
    Z > this.length && (Z = this.length), E.length - _ < Z - q && (Z = E.length - _ + q);
    const re = Z - q;
    return this === E && typeof o.prototype.copyWithin == "function" ? this.copyWithin(_, q, Z) : o.prototype.set.call(
      E,
      this.subarray(q, Z),
      _
    ), re;
  }, u.prototype.fill = function(E, _, q, Z) {
    if (typeof E == "string") {
      if (typeof _ == "string" ? (Z = _, _ = 0, q = this.length) : typeof q == "string" && (Z = q, q = this.length), Z !== void 0 && typeof Z != "string")
        throw new TypeError("encoding must be a string");
      if (typeof Z == "string" && !u.isEncoding(Z))
        throw new TypeError("Unknown encoding: " + Z);
      if (E.length === 1) {
        const pe = E.charCodeAt(0);
        (Z === "utf8" && pe < 128 || Z === "latin1") && (E = pe);
      }
    } else typeof E == "number" ? E = E & 255 : typeof E == "boolean" && (E = Number(E));
    if (_ < 0 || this.length < _ || this.length < q)
      throw new RangeError("Out of range index");
    if (q <= _)
      return this;
    _ = _ >>> 0, q = q === void 0 ? this.length : q >>> 0, E || (E = 0);
    let re;
    if (typeof E == "number")
      for (re = _; re < q; ++re)
        this[re] = E;
    else {
      const pe = u.isBuffer(E) ? E : u.from(E, Z), He = pe.length;
      if (He === 0)
        throw new TypeError('The value "' + E + '" is invalid for argument "value"');
      for (re = 0; re < q - _; ++re)
        this[re + _] = pe[re % He];
    }
    return this;
  };
  const gt = {};
  function vt(D, E, _) {
    gt[D] = class extends _ {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: E.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${D}]`, this.stack, delete this.name;
      }
      get code() {
        return D;
      }
      set code(Z) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: Z,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${D}]: ${this.message}`;
      }
    };
  }
  vt(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(D) {
      return D ? `${D} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), vt(
    "ERR_INVALID_ARG_TYPE",
    function(D, E) {
      return `The "${D}" argument must be of type number. Received type ${typeof E}`;
    },
    TypeError
  ), vt(
    "ERR_OUT_OF_RANGE",
    function(D, E, _) {
      let q = `The value of "${D}" is out of range.`, Z = _;
      return Number.isInteger(_) && Math.abs(_) > 2 ** 32 ? Z = ot(String(_)) : typeof _ == "bigint" && (Z = String(_), (_ > BigInt(2) ** BigInt(32) || _ < -(BigInt(2) ** BigInt(32))) && (Z = ot(Z)), Z += "n"), q += ` It must be ${E}. Received ${Z}`, q;
    },
    RangeError
  );
  function ot(D) {
    let E = "", _ = D.length;
    const q = D[0] === "-" ? 1 : 0;
    for (; _ >= q + 4; _ -= 3)
      E = `_${D.slice(_ - 3, _)}${E}`;
    return `${D.slice(0, _)}${E}`;
  }
  function Le(D, E, _) {
    jt(E, "offset"), (D[E] === void 0 || D[E + _] === void 0) && rn(E, D.length - (_ + 1));
  }
  function tt(D, E, _, q, Z, re) {
    if (D > _ || D < E) {
      const pe = typeof E == "bigint" ? "n" : "";
      let He;
      throw E === 0 || E === BigInt(0) ? He = `>= 0${pe} and < 2${pe} ** ${(re + 1) * 8}${pe}` : He = `>= -(2${pe} ** ${(re + 1) * 8 - 1}${pe}) and < 2 ** ${(re + 1) * 8 - 1}${pe}`, new gt.ERR_OUT_OF_RANGE("value", He, D);
    }
    Le(q, Z, re);
  }
  function jt(D, E) {
    if (typeof D != "number")
      throw new gt.ERR_INVALID_ARG_TYPE(E, "number", D);
  }
  function rn(D, E, _) {
    throw Math.floor(D) !== D ? (jt(D, _), new gt.ERR_OUT_OF_RANGE("offset", "an integer", D)) : E < 0 ? new gt.ERR_BUFFER_OUT_OF_BOUNDS() : new gt.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${E}`,
      D
    );
  }
  const en = /[^+/0-9A-Za-z-_]/g;
  function Gt(D) {
    if (D = D.split("=")[0], D = D.trim().replace(en, ""), D.length < 2) return "";
    for (; D.length % 4 !== 0; )
      D = D + "=";
    return D;
  }
  function jn(D, E) {
    E = E || 1 / 0;
    let _;
    const q = D.length;
    let Z = null;
    const re = [];
    for (let pe = 0; pe < q; ++pe) {
      if (_ = D.charCodeAt(pe), _ > 55295 && _ < 57344) {
        if (!Z) {
          if (_ > 56319) {
            (E -= 3) > -1 && re.push(239, 191, 189);
            continue;
          } else if (pe + 1 === q) {
            (E -= 3) > -1 && re.push(239, 191, 189);
            continue;
          }
          Z = _;
          continue;
        }
        if (_ < 56320) {
          (E -= 3) > -1 && re.push(239, 191, 189), Z = _;
          continue;
        }
        _ = (Z - 55296 << 10 | _ - 56320) + 65536;
      } else Z && (E -= 3) > -1 && re.push(239, 191, 189);
      if (Z = null, _ < 128) {
        if ((E -= 1) < 0) break;
        re.push(_);
      } else if (_ < 2048) {
        if ((E -= 2) < 0) break;
        re.push(
          _ >> 6 | 192,
          _ & 63 | 128
        );
      } else if (_ < 65536) {
        if ((E -= 3) < 0) break;
        re.push(
          _ >> 12 | 224,
          _ >> 6 & 63 | 128,
          _ & 63 | 128
        );
      } else if (_ < 1114112) {
        if ((E -= 4) < 0) break;
        re.push(
          _ >> 18 | 240,
          _ >> 12 & 63 | 128,
          _ >> 6 & 63 | 128,
          _ & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return re;
  }
  function tr(D) {
    const E = [];
    for (let _ = 0; _ < D.length; ++_)
      E.push(D.charCodeAt(_) & 255);
    return E;
  }
  function Ot(D, E) {
    let _, q, Z;
    const re = [];
    for (let pe = 0; pe < D.length && !((E -= 2) < 0); ++pe)
      _ = D.charCodeAt(pe), q = _ >> 8, Z = _ % 256, re.push(Z), re.push(q);
    return re;
  }
  function qt(D) {
    return t.toByteArray(Gt(D));
  }
  function Cn(D, E, _, q) {
    let Z;
    for (Z = 0; Z < q && !(Z + _ >= E.length || Z >= D.length); ++Z)
      E[Z + _] = D[Z];
    return Z;
  }
  function Ve(D, E) {
    return D instanceof E || D != null && D.constructor != null && D.constructor.name != null && D.constructor.name === E.name;
  }
  function nt(D) {
    return D !== D;
  }
  const je = function() {
    const D = "0123456789abcdef", E = new Array(256);
    for (let _ = 0; _ < 16; ++_) {
      const q = _ * 16;
      for (let Z = 0; Z < 16; ++Z)
        E[q + Z] = D[_] + D[Z];
    }
    return E;
  }();
  function st(D) {
    return typeof BigInt > "u" ? tn : D;
  }
  function tn() {
    throw new Error("BigInt not supported");
  }
})(In);
const JA = In.Buffer, $M = In.Blob, WM = In.BlobOptions, GM = In.Buffer, HM = In.File, KM = In.FileOptions, YM = In.INSPECT_MAX_BYTES, QM = In.SlowBuffer, JM = In.TranscodeEncoding, XM = In.atob, ZM = In.btoa, eF = In.constants, tF = In.isAscii, nF = In.isUtf8, rF = In.kMaxLength, iF = In.kStringMaxLength, oF = In.resolveObjectURL, sF = In.transcode, Yve = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Blob: $M,
  BlobOptions: WM,
  Buffer: GM,
  File: HM,
  FileOptions: KM,
  INSPECT_MAX_BYTES: YM,
  SlowBuffer: QM,
  TranscodeEncoding: JM,
  atob: XM,
  btoa: ZM,
  constants: eF,
  default: JA,
  isAscii: tF,
  isUtf8: nF,
  kMaxLength: rF,
  kStringMaxLength: iF,
  resolveObjectURL: oF,
  transcode: sF
}, Symbol.toStringTag, { value: "Module" }));
function ht(e, t, n, r, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), i && (this.response = i, this.status = i.status ? i.status : null);
}
fe.inherits(ht, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: fe.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const XA = ht.prototype, ZA = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  ZA[e] = { value: e };
});
Object.defineProperties(ht, ZA);
Object.defineProperty(XA, "isAxiosError", { value: !0 });
ht.from = (e, t, n, r, i, o) => {
  const s = Object.create(XA);
  return fe.toFlatObject(e, s, function(l) {
    return l !== Error.prototype;
  }, (a) => a !== "isAxiosError"), ht.call(s, e.message, t, n, r, i), s.cause = e, s.name = e.name, o && Object.assign(s, o), s;
};
const aF = null;
function Vv(e) {
  return fe.isPlainObject(e) || fe.isArray(e);
}
function e2(e) {
  return fe.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function $C(e, t, n) {
  return e ? e.concat(t).map(function(i, o) {
    return i = e2(i), !n && o ? "[" + i + "]" : i;
  }).join(n ? "." : "") : t;
}
function lF(e) {
  return fe.isArray(e) && !e.some(Vv);
}
const cF = fe.toFlatObject(fe, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function Pp(e, t, n) {
  if (!fe.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), n = fe.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(m, g) {
    return !fe.isUndefined(g[m]);
  });
  const r = n.metaTokens, i = n.visitor || u, o = n.dots, s = n.indexes, l = (n.Blob || typeof Blob < "u" && Blob) && fe.isSpecCompliantForm(t);
  if (!fe.isFunction(i))
    throw new TypeError("visitor must be a function");
  function c(p) {
    if (p === null) return "";
    if (fe.isDate(p))
      return p.toISOString();
    if (!l && fe.isBlob(p))
      throw new ht("Blob is not supported. Use a Buffer instead.");
    return fe.isArrayBuffer(p) || fe.isTypedArray(p) ? l && typeof Blob == "function" ? new Blob([p]) : JA.from(p) : p;
  }
  function u(p, m, g) {
    let v = p;
    if (p && !g && typeof p == "object") {
      if (fe.endsWith(m, "{}"))
        m = r ? m : m.slice(0, -2), p = JSON.stringify(p);
      else if (fe.isArray(p) && lF(p) || (fe.isFileList(p) || fe.endsWith(m, "[]")) && (v = fe.toArray(p)))
        return m = e2(m), v.forEach(function(x, C) {
          !(fe.isUndefined(x) || x === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            s === !0 ? $C([m], C, o) : s === null ? m : m + "[]",
            c(x)
          );
        }), !1;
    }
    return Vv(p) ? !0 : (t.append($C(g, m, o), c(p)), !1);
  }
  const d = [], f = Object.assign(cF, {
    defaultVisitor: u,
    convertValue: c,
    isVisitable: Vv
  });
  function h(p, m) {
    if (!fe.isUndefined(p)) {
      if (d.indexOf(p) !== -1)
        throw Error("Circular reference detected in " + m.join("."));
      d.push(p), fe.forEach(p, function(v, w) {
        (!(fe.isUndefined(v) || v === null) && i.call(
          t,
          v,
          fe.isString(w) ? w.trim() : w,
          m,
          f
        )) === !0 && h(v, m ? m.concat(w) : [w]);
      }), d.pop();
    }
  }
  if (!fe.isObject(e))
    throw new TypeError("data must be an object");
  return h(e), t;
}
function WC(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(r) {
    return t[r];
  });
}
function G0(e, t) {
  this._pairs = [], e && Pp(e, this, t);
}
const t2 = G0.prototype;
t2.append = function(t, n) {
  this._pairs.push([t, n]);
};
t2.toString = function(t) {
  const n = t ? function(r) {
    return t.call(this, r, WC);
  } : WC;
  return this._pairs.map(function(i) {
    return n(i[0]) + "=" + n(i[1]);
  }, "").join("&");
};
function uF(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function n2(e, t, n) {
  if (!t)
    return e;
  const r = n && n.encode || uF, i = n && n.serialize;
  let o;
  if (i ? o = i(t, n) : o = fe.isURLSearchParams(t) ? t.toString() : new G0(t, n).toString(r), o) {
    const s = e.indexOf("#");
    s !== -1 && (e = e.slice(0, s)), e += (e.indexOf("?") === -1 ? "?" : "&") + o;
  }
  return e;
}
class GC {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, n, r) {
    return this.handlers.push({
      fulfilled: t,
      rejected: n,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    fe.forEach(this.handlers, function(r) {
      r !== null && t(r);
    });
  }
}
const r2 = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, dF = typeof URLSearchParams < "u" ? URLSearchParams : G0, fF = typeof FormData < "u" ? FormData : null, hF = typeof Blob < "u" ? Blob : null, pF = {
  isBrowser: !0,
  classes: {
    URLSearchParams: dF,
    FormData: fF,
    Blob: hF
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, H0 = typeof window < "u" && typeof document < "u", qv = typeof navigator == "object" && navigator || void 0, yF = H0 && (!qv || ["ReactNative", "NativeScript", "NS"].indexOf(qv.product) < 0), mF = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", gF = H0 && window.location.href || "http://localhost", vF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: H0,
  hasStandardBrowserEnv: yF,
  hasStandardBrowserWebWorkerEnv: mF,
  navigator: qv,
  origin: gF
}, Symbol.toStringTag, { value: "Module" })), xr = {
  ...vF,
  ...pF
};
function bF(e, t) {
  return Pp(e, new xr.classes.URLSearchParams(), Object.assign({
    visitor: function(n, r, i, o) {
      return xr.isNode && fe.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : o.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function wF(e) {
  return fe.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function xF(e) {
  const t = {}, n = Object.keys(e);
  let r;
  const i = n.length;
  let o;
  for (r = 0; r < i; r++)
    o = n[r], t[o] = e[o];
  return t;
}
function i2(e) {
  function t(n, r, i, o) {
    let s = n[o++];
    if (s === "__proto__") return !0;
    const a = Number.isFinite(+s), l = o >= n.length;
    return s = !s && fe.isArray(i) ? i.length : s, l ? (fe.hasOwnProp(i, s) ? i[s] = [i[s], r] : i[s] = r, !a) : ((!i[s] || !fe.isObject(i[s])) && (i[s] = []), t(n, r, i[s], o) && fe.isArray(i[s]) && (i[s] = xF(i[s])), !a);
  }
  if (fe.isFormData(e) && fe.isFunction(e.entries)) {
    const n = {};
    return fe.forEachEntry(e, (r, i) => {
      t(wF(r), i, n, 0);
    }), n;
  }
  return null;
}
function CF(e, t, n) {
  if (fe.isString(e))
    try {
      return (t || JSON.parse)(e), fe.trim(e);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (n || JSON.stringify)(e);
}
const Id = {
  transitional: r2,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(t, n) {
    const r = n.getContentType() || "", i = r.indexOf("application/json") > -1, o = fe.isObject(t);
    if (o && fe.isHTMLForm(t) && (t = new FormData(t)), fe.isFormData(t))
      return i ? JSON.stringify(i2(t)) : t;
    if (fe.isArrayBuffer(t) || fe.isBuffer(t) || fe.isStream(t) || fe.isFile(t) || fe.isBlob(t) || fe.isReadableStream(t))
      return t;
    if (fe.isArrayBufferView(t))
      return t.buffer;
    if (fe.isURLSearchParams(t))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let a;
    if (o) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return bF(t, this.formSerializer).toString();
      if ((a = fe.isFileList(t)) || r.indexOf("multipart/form-data") > -1) {
        const l = this.env && this.env.FormData;
        return Pp(
          a ? { "files[]": t } : t,
          l && new l(),
          this.formSerializer
        );
      }
    }
    return o || i ? (n.setContentType("application/json", !1), CF(t)) : t;
  }],
  transformResponse: [function(t) {
    const n = this.transitional || Id.transitional, r = n && n.forcedJSONParsing, i = this.responseType === "json";
    if (fe.isResponse(t) || fe.isReadableStream(t))
      return t;
    if (t && fe.isString(t) && (r && !this.responseType || i)) {
      const s = !(n && n.silentJSONParsing) && i;
      try {
        return JSON.parse(t);
      } catch (a) {
        if (s)
          throw a.name === "SyntaxError" ? ht.from(a, ht.ERR_BAD_RESPONSE, this, null, this.response) : a;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: xr.classes.FormData,
    Blob: xr.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
fe.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  Id.headers[e] = {};
});
const kF = fe.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), EF = (e) => {
  const t = {};
  let n, r, i;
  return e && e.split(`
`).forEach(function(s) {
    i = s.indexOf(":"), n = s.substring(0, i).trim().toLowerCase(), r = s.substring(i + 1).trim(), !(!n || t[n] && kF[n]) && (n === "set-cookie" ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r);
  }), t;
}, HC = Symbol("internals");
function nu(e) {
  return e && String(e).trim().toLowerCase();
}
function dh(e) {
  return e === !1 || e == null ? e : fe.isArray(e) ? e.map(dh) : String(e);
}
function SF(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = n.exec(e); )
    t[r[1]] = r[2];
  return t;
}
const AF = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function Pm(e, t, n, r, i) {
  if (fe.isFunction(r))
    return r.call(this, t, n);
  if (i && (t = n), !!fe.isString(t)) {
    if (fe.isString(r))
      return t.indexOf(r) !== -1;
    if (fe.isRegExp(r))
      return r.test(t);
  }
}
function TF(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r);
}
function _F(e, t) {
  const n = fe.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(e, r + n, {
      value: function(i, o, s) {
        return this[r].call(this, t, i, o, s);
      },
      configurable: !0
    });
  });
}
let Cr = class {
  constructor(t) {
    t && this.set(t);
  }
  set(t, n, r) {
    const i = this;
    function o(a, l, c) {
      const u = nu(l);
      if (!u)
        throw new Error("header name must be a non-empty string");
      const d = fe.findKey(i, u);
      (!d || i[d] === void 0 || c === !0 || c === void 0 && i[d] !== !1) && (i[d || l] = dh(a));
    }
    const s = (a, l) => fe.forEach(a, (c, u) => o(c, u, l));
    if (fe.isPlainObject(t) || t instanceof this.constructor)
      s(t, n);
    else if (fe.isString(t) && (t = t.trim()) && !AF(t))
      s(EF(t), n);
    else if (fe.isHeaders(t))
      for (const [a, l] of t.entries())
        o(l, a, r);
    else
      t != null && o(n, t, r);
    return this;
  }
  get(t, n) {
    if (t = nu(t), t) {
      const r = fe.findKey(this, t);
      if (r) {
        const i = this[r];
        if (!n)
          return i;
        if (n === !0)
          return SF(i);
        if (fe.isFunction(n))
          return n.call(this, i, r);
        if (fe.isRegExp(n))
          return n.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, n) {
    if (t = nu(t), t) {
      const r = fe.findKey(this, t);
      return !!(r && this[r] !== void 0 && (!n || Pm(this, this[r], r, n)));
    }
    return !1;
  }
  delete(t, n) {
    const r = this;
    let i = !1;
    function o(s) {
      if (s = nu(s), s) {
        const a = fe.findKey(r, s);
        a && (!n || Pm(r, r[a], a, n)) && (delete r[a], i = !0);
      }
    }
    return fe.isArray(t) ? t.forEach(o) : o(t), i;
  }
  clear(t) {
    const n = Object.keys(this);
    let r = n.length, i = !1;
    for (; r--; ) {
      const o = n[r];
      (!t || Pm(this, this[o], o, t, !0)) && (delete this[o], i = !0);
    }
    return i;
  }
  normalize(t) {
    const n = this, r = {};
    return fe.forEach(this, (i, o) => {
      const s = fe.findKey(r, o);
      if (s) {
        n[s] = dh(i), delete n[o];
        return;
      }
      const a = t ? TF(o) : String(o).trim();
      a !== o && delete n[o], n[a] = dh(i), r[a] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const n = /* @__PURE__ */ Object.create(null);
    return fe.forEach(this, (r, i) => {
      r != null && r !== !1 && (n[i] = t && fe.isArray(r) ? r.join(", ") : r);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...n) {
    const r = new this(t);
    return n.forEach((i) => r.set(i)), r;
  }
  static accessor(t) {
    const r = (this[HC] = this[HC] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function o(s) {
      const a = nu(s);
      r[a] || (_F(i, s), r[a] = !0);
    }
    return fe.isArray(t) ? t.forEach(o) : o(t), this;
  }
};
Cr.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
fe.reduceDescriptors(Cr.prototype, ({ value: e }, t) => {
  let n = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(r) {
      this[n] = r;
    }
  };
});
fe.freezeMethods(Cr);
function Om(e, t) {
  const n = this || Id, r = t || n, i = Cr.from(r.headers);
  let o = r.data;
  return fe.forEach(e, function(a) {
    o = a.call(n, o, i.normalize(), t ? t.status : void 0);
  }), i.normalize(), o;
}
function o2(e) {
  return !!(e && e.__CANCEL__);
}
function Pc(e, t, n) {
  ht.call(this, e ?? "canceled", ht.ERR_CANCELED, t, n), this.name = "CanceledError";
}
fe.inherits(Pc, ht, {
  __CANCEL__: !0
});
function s2(e, t, n) {
  const r = n.config.validateStatus;
  !n.status || !r || r(n.status) ? e(n) : t(new ht(
    "Request failed with status code " + n.status,
    [ht.ERR_BAD_REQUEST, ht.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
function IF(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function RF(e, t) {
  e = e || 10;
  const n = new Array(e), r = new Array(e);
  let i = 0, o = 0, s;
  return t = t !== void 0 ? t : 1e3, function(l) {
    const c = Date.now(), u = r[o];
    s || (s = c), n[i] = l, r[i] = c;
    let d = o, f = 0;
    for (; d !== i; )
      f += n[d++], d = d % e;
    if (i = (i + 1) % e, i === o && (o = (o + 1) % e), c - s < t)
      return;
    const h = u && c - u;
    return h ? Math.round(f * 1e3 / h) : void 0;
  };
}
function PF(e, t) {
  let n = 0, r = 1e3 / t, i, o;
  const s = (c, u = Date.now()) => {
    n = u, i = null, o && (clearTimeout(o), o = null), e.apply(null, c);
  };
  return [(...c) => {
    const u = Date.now(), d = u - n;
    d >= r ? s(c, u) : (i = c, o || (o = setTimeout(() => {
      o = null, s(i);
    }, r - d)));
  }, () => i && s(i)];
}
const Fh = (e, t, n = 3) => {
  let r = 0;
  const i = RF(50, 250);
  return PF((o) => {
    const s = o.loaded, a = o.lengthComputable ? o.total : void 0, l = s - r, c = i(l), u = s <= a;
    r = s;
    const d = {
      loaded: s,
      total: a,
      progress: a ? s / a : void 0,
      bytes: l,
      rate: c || void 0,
      estimated: c && a && u ? (a - s) / c : void 0,
      event: o,
      lengthComputable: a != null,
      [t ? "download" : "upload"]: !0
    };
    e(d);
  }, n);
}, KC = (e, t) => {
  const n = e != null;
  return [(r) => t[0]({
    lengthComputable: n,
    total: e,
    loaded: r
  }), t[1]];
}, YC = (e) => (...t) => fe.asap(() => e(...t)), OF = xr.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const t = xr.navigator && /(msie|trident)/i.test(xr.navigator.userAgent), n = document.createElement("a");
    let r;
    function i(o) {
      let s = o;
      return t && (n.setAttribute("href", s), s = n.href), n.setAttribute("href", s), {
        href: n.href,
        protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
        host: n.host,
        search: n.search ? n.search.replace(/^\?/, "") : "",
        hash: n.hash ? n.hash.replace(/^#/, "") : "",
        hostname: n.hostname,
        port: n.port,
        pathname: n.pathname.charAt(0) === "/" ? n.pathname : "/" + n.pathname
      };
    }
    return r = i(window.location.href), function(s) {
      const a = fe.isString(s) ? i(s) : s;
      return a.protocol === r.protocol && a.host === r.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function() {
    return function() {
      return !0;
    };
  }()
), BF = xr.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, n, r, i, o) {
      const s = [e + "=" + encodeURIComponent(t)];
      fe.isNumber(n) && s.push("expires=" + new Date(n).toGMTString()), fe.isString(r) && s.push("path=" + r), fe.isString(i) && s.push("domain=" + i), o === !0 && s.push("secure"), document.cookie = s.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function NF(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function DF(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function a2(e, t) {
  return e && !NF(t) ? DF(e, t) : t;
}
const QC = (e) => e instanceof Cr ? { ...e } : e;
function Sa(e, t) {
  t = t || {};
  const n = {};
  function r(c, u, d) {
    return fe.isPlainObject(c) && fe.isPlainObject(u) ? fe.merge.call({ caseless: d }, c, u) : fe.isPlainObject(u) ? fe.merge({}, u) : fe.isArray(u) ? u.slice() : u;
  }
  function i(c, u, d) {
    if (fe.isUndefined(u)) {
      if (!fe.isUndefined(c))
        return r(void 0, c, d);
    } else return r(c, u, d);
  }
  function o(c, u) {
    if (!fe.isUndefined(u))
      return r(void 0, u);
  }
  function s(c, u) {
    if (fe.isUndefined(u)) {
      if (!fe.isUndefined(c))
        return r(void 0, c);
    } else return r(void 0, u);
  }
  function a(c, u, d) {
    if (d in t)
      return r(c, u);
    if (d in e)
      return r(void 0, c);
  }
  const l = {
    url: o,
    method: o,
    data: o,
    baseURL: s,
    transformRequest: s,
    transformResponse: s,
    paramsSerializer: s,
    timeout: s,
    timeoutMessage: s,
    withCredentials: s,
    withXSRFToken: s,
    adapter: s,
    responseType: s,
    xsrfCookieName: s,
    xsrfHeaderName: s,
    onUploadProgress: s,
    onDownloadProgress: s,
    decompress: s,
    maxContentLength: s,
    maxBodyLength: s,
    beforeRedirect: s,
    transport: s,
    httpAgent: s,
    httpsAgent: s,
    cancelToken: s,
    socketPath: s,
    responseEncoding: s,
    validateStatus: a,
    headers: (c, u) => i(QC(c), QC(u), !0)
  };
  return fe.forEach(Object.keys(Object.assign({}, e, t)), function(u) {
    const d = l[u] || i, f = d(e[u], t[u], u);
    fe.isUndefined(f) && d !== a || (n[u] = f);
  }), n;
}
const l2 = (e) => {
  const t = Sa({}, e);
  let { data: n, withXSRFToken: r, xsrfHeaderName: i, xsrfCookieName: o, headers: s, auth: a } = t;
  t.headers = s = Cr.from(s), t.url = n2(a2(t.baseURL, t.url), e.params, e.paramsSerializer), a && s.set(
    "Authorization",
    "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : ""))
  );
  let l;
  if (fe.isFormData(n)) {
    if (xr.hasStandardBrowserEnv || xr.hasStandardBrowserWebWorkerEnv)
      s.setContentType(void 0);
    else if ((l = s.getContentType()) !== !1) {
      const [c, ...u] = l ? l.split(";").map((d) => d.trim()).filter(Boolean) : [];
      s.setContentType([c || "multipart/form-data", ...u].join("; "));
    }
  }
  if (xr.hasStandardBrowserEnv && (r && fe.isFunction(r) && (r = r(t)), r || r !== !1 && OF(t.url))) {
    const c = i && o && BF.read(o);
    c && s.set(i, c);
  }
  return t;
}, jF = typeof XMLHttpRequest < "u", MF = jF && function(e) {
  return new Promise(function(n, r) {
    const i = l2(e);
    let o = i.data;
    const s = Cr.from(i.headers).normalize();
    let { responseType: a, onUploadProgress: l, onDownloadProgress: c } = i, u, d, f, h, p;
    function m() {
      h && h(), p && p(), i.cancelToken && i.cancelToken.unsubscribe(u), i.signal && i.signal.removeEventListener("abort", u);
    }
    let g = new XMLHttpRequest();
    g.open(i.method.toUpperCase(), i.url, !0), g.timeout = i.timeout;
    function v() {
      if (!g)
        return;
      const x = Cr.from(
        "getAllResponseHeaders" in g && g.getAllResponseHeaders()
      ), S = {
        data: !a || a === "text" || a === "json" ? g.responseText : g.response,
        status: g.status,
        statusText: g.statusText,
        headers: x,
        config: e,
        request: g
      };
      s2(function(A) {
        n(A), m();
      }, function(A) {
        r(A), m();
      }, S), g = null;
    }
    "onloadend" in g ? g.onloadend = v : g.onreadystatechange = function() {
      !g || g.readyState !== 4 || g.status === 0 && !(g.responseURL && g.responseURL.indexOf("file:") === 0) || setTimeout(v);
    }, g.onabort = function() {
      g && (r(new ht("Request aborted", ht.ECONNABORTED, e, g)), g = null);
    }, g.onerror = function() {
      r(new ht("Network Error", ht.ERR_NETWORK, e, g)), g = null;
    }, g.ontimeout = function() {
      let C = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
      const S = i.transitional || r2;
      i.timeoutErrorMessage && (C = i.timeoutErrorMessage), r(new ht(
        C,
        S.clarifyTimeoutError ? ht.ETIMEDOUT : ht.ECONNABORTED,
        e,
        g
      )), g = null;
    }, o === void 0 && s.setContentType(null), "setRequestHeader" in g && fe.forEach(s.toJSON(), function(C, S) {
      g.setRequestHeader(S, C);
    }), fe.isUndefined(i.withCredentials) || (g.withCredentials = !!i.withCredentials), a && a !== "json" && (g.responseType = i.responseType), c && ([f, p] = Fh(c, !0), g.addEventListener("progress", f)), l && g.upload && ([d, h] = Fh(l), g.upload.addEventListener("progress", d), g.upload.addEventListener("loadend", h)), (i.cancelToken || i.signal) && (u = (x) => {
      g && (r(!x || x.type ? new Pc(null, e, g) : x), g.abort(), g = null);
    }, i.cancelToken && i.cancelToken.subscribe(u), i.signal && (i.signal.aborted ? u() : i.signal.addEventListener("abort", u)));
    const w = IF(i.url);
    if (w && xr.protocols.indexOf(w) === -1) {
      r(new ht("Unsupported protocol " + w + ":", ht.ERR_BAD_REQUEST, e));
      return;
    }
    g.send(o || null);
  });
}, FF = (e, t) => {
  const { length: n } = e = e ? e.filter(Boolean) : [];
  if (t || n) {
    let r = new AbortController(), i;
    const o = function(c) {
      if (!i) {
        i = !0, a();
        const u = c instanceof Error ? c : this.reason;
        r.abort(u instanceof ht ? u : new Pc(u instanceof Error ? u.message : u));
      }
    };
    let s = t && setTimeout(() => {
      s = null, o(new ht(`timeout ${t} of ms exceeded`, ht.ETIMEDOUT));
    }, t);
    const a = () => {
      e && (s && clearTimeout(s), s = null, e.forEach((c) => {
        c.unsubscribe ? c.unsubscribe(o) : c.removeEventListener("abort", o);
      }), e = null);
    };
    e.forEach((c) => c.addEventListener("abort", o));
    const { signal: l } = r;
    return l.unsubscribe = () => fe.asap(a), l;
  }
}, LF = function* (e, t) {
  let n = e.byteLength;
  if (!t || n < t) {
    yield e;
    return;
  }
  let r = 0, i;
  for (; r < n; )
    i = r + t, yield e.slice(r, i), r = i;
}, UF = async function* (e, t) {
  for await (const n of zF(e))
    yield* LF(n, t);
}, zF = async function* (e) {
  if (e[Symbol.asyncIterator]) {
    yield* e;
    return;
  }
  const t = e.getReader();
  try {
    for (; ; ) {
      const { done: n, value: r } = await t.read();
      if (n)
        break;
      yield r;
    }
  } finally {
    await t.cancel();
  }
}, JC = (e, t, n, r) => {
  const i = UF(e, t);
  let o = 0, s, a = (l) => {
    s || (s = !0, r && r(l));
  };
  return new ReadableStream({
    async pull(l) {
      try {
        const { done: c, value: u } = await i.next();
        if (c) {
          a(), l.close();
          return;
        }
        let d = u.byteLength;
        if (n) {
          let f = o += d;
          n(f);
        }
        l.enqueue(new Uint8Array(u));
      } catch (c) {
        throw a(c), c;
      }
    },
    cancel(l) {
      return a(l), i.return();
    }
  }, {
    highWaterMark: 2
  });
}, Op = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", c2 = Op && typeof ReadableStream == "function", VF = Op && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer())), u2 = (e, ...t) => {
  try {
    return !!e(...t);
  } catch {
    return !1;
  }
}, qF = c2 && u2(() => {
  let e = !1;
  const t = new Request(xr.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return e = !0, "half";
    }
  }).headers.has("Content-Type");
  return e && !t;
}), XC = 64 * 1024, $v = c2 && u2(() => fe.isReadableStream(new Response("").body)), Lh = {
  stream: $v && ((e) => e.body)
};
Op && ((e) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
    !Lh[t] && (Lh[t] = fe.isFunction(e[t]) ? (n) => n[t]() : (n, r) => {
      throw new ht(`Response type '${t}' is not supported`, ht.ERR_NOT_SUPPORT, r);
    });
  });
})(new Response());
const $F = async (e) => {
  if (e == null)
    return 0;
  if (fe.isBlob(e))
    return e.size;
  if (fe.isSpecCompliantForm(e))
    return (await new Request(xr.origin, {
      method: "POST",
      body: e
    }).arrayBuffer()).byteLength;
  if (fe.isArrayBufferView(e) || fe.isArrayBuffer(e))
    return e.byteLength;
  if (fe.isURLSearchParams(e) && (e = e + ""), fe.isString(e))
    return (await VF(e)).byteLength;
}, WF = async (e, t) => {
  const n = fe.toFiniteNumber(e.getContentLength());
  return n ?? $F(t);
}, GF = Op && (async (e) => {
  let {
    url: t,
    method: n,
    data: r,
    signal: i,
    cancelToken: o,
    timeout: s,
    onDownloadProgress: a,
    onUploadProgress: l,
    responseType: c,
    headers: u,
    withCredentials: d = "same-origin",
    fetchOptions: f
  } = l2(e);
  c = c ? (c + "").toLowerCase() : "text";
  let h = FF([i, o && o.toAbortSignal()], s), p;
  const m = h && h.unsubscribe && (() => {
    h.unsubscribe();
  });
  let g;
  try {
    if (l && qF && n !== "get" && n !== "head" && (g = await WF(u, r)) !== 0) {
      let S = new Request(t, {
        method: "POST",
        body: r,
        duplex: "half"
      }), k;
      if (fe.isFormData(r) && (k = S.headers.get("content-type")) && u.setContentType(k), S.body) {
        const [A, b] = KC(
          g,
          Fh(YC(l))
        );
        r = JC(S.body, XC, A, b);
      }
    }
    fe.isString(d) || (d = d ? "include" : "omit");
    const v = "credentials" in Request.prototype;
    p = new Request(t, {
      ...f,
      signal: h,
      method: n.toUpperCase(),
      headers: u.normalize().toJSON(),
      body: r,
      duplex: "half",
      credentials: v ? d : void 0
    });
    let w = await fetch(p);
    const x = $v && (c === "stream" || c === "response");
    if ($v && (a || x && m)) {
      const S = {};
      ["status", "statusText", "headers"].forEach((T) => {
        S[T] = w[T];
      });
      const k = fe.toFiniteNumber(w.headers.get("content-length")), [A, b] = a && KC(
        k,
        Fh(YC(a), !0)
      ) || [];
      w = new Response(
        JC(w.body, XC, A, () => {
          b && b(), m && m();
        }),
        S
      );
    }
    c = c || "text";
    let C = await Lh[fe.findKey(Lh, c) || "text"](w, e);
    return !x && m && m(), await new Promise((S, k) => {
      s2(S, k, {
        data: C,
        headers: Cr.from(w.headers),
        status: w.status,
        statusText: w.statusText,
        config: e,
        request: p
      });
    });
  } catch (v) {
    throw m && m(), v && v.name === "TypeError" && /fetch/i.test(v.message) ? Object.assign(
      new ht("Network Error", ht.ERR_NETWORK, e, p),
      {
        cause: v.cause || v
      }
    ) : ht.from(v, v && v.code, e, p);
  }
}), Wv = {
  http: aF,
  xhr: MF,
  fetch: GF
};
fe.forEach(Wv, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const ZC = (e) => `- ${e}`, HF = (e) => fe.isFunction(e) || e === null || e === !1, d2 = {
  getAdapter: (e) => {
    e = fe.isArray(e) ? e : [e];
    const { length: t } = e;
    let n, r;
    const i = {};
    for (let o = 0; o < t; o++) {
      n = e[o];
      let s;
      if (r = n, !HF(n) && (r = Wv[(s = String(n)).toLowerCase()], r === void 0))
        throw new ht(`Unknown adapter '${s}'`);
      if (r)
        break;
      i[s || "#" + o] = r;
    }
    if (!r) {
      const o = Object.entries(i).map(
        ([a, l]) => `adapter ${a} ` + (l === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let s = t ? o.length > 1 ? `since :
` + o.map(ZC).join(`
`) : " " + ZC(o[0]) : "as no adapter specified";
      throw new ht(
        "There is no suitable adapter to dispatch the request " + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return r;
  },
  adapters: Wv
};
function Bm(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new Pc(null, e);
}
function ek(e) {
  return Bm(e), e.headers = Cr.from(e.headers), e.data = Om.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), d2.getAdapter(e.adapter || Id.adapter)(e).then(function(r) {
    return Bm(e), r.data = Om.call(
      e,
      e.transformResponse,
      r
    ), r.headers = Cr.from(r.headers), r;
  }, function(r) {
    return o2(r) || (Bm(e), r && r.response && (r.response.data = Om.call(
      e,
      e.transformResponse,
      r.response
    ), r.response.headers = Cr.from(r.response.headers))), Promise.reject(r);
  });
}
const f2 = "1.7.7", K0 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  K0[e] = function(r) {
    return typeof r === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const tk = {};
K0.transitional = function(t, n, r) {
  function i(o, s) {
    return "[Axios v" + f2 + "] Transitional option '" + o + "'" + s + (r ? ". " + r : "");
  }
  return (o, s, a) => {
    if (t === !1)
      throw new ht(
        i(s, " has been removed" + (n ? " in " + n : "")),
        ht.ERR_DEPRECATED
      );
    return n && !tk[s] && (tk[s] = !0), t ? t(o, s, a) : !0;
  };
};
function KF(e, t, n) {
  if (typeof e != "object")
    throw new ht("options must be an object", ht.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(e);
  let i = r.length;
  for (; i-- > 0; ) {
    const o = r[i], s = t[o];
    if (s) {
      const a = e[o], l = a === void 0 || s(a, o, e);
      if (l !== !0)
        throw new ht("option " + o + " must be " + l, ht.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new ht("Unknown option " + o, ht.ERR_BAD_OPTION);
  }
}
const Gv = {
  assertOptions: KF,
  validators: K0
}, Ko = Gv.validators;
let va = class {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new GC(),
      response: new GC()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(t, n) {
    try {
      return await this._request(t, n);
    } catch (r) {
      if (r instanceof Error) {
        let i;
        Error.captureStackTrace ? Error.captureStackTrace(i = {}) : i = new Error();
        const o = i.stack ? i.stack.replace(/^.+\n/, "") : "";
        try {
          r.stack ? o && !String(r.stack).endsWith(o.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + o) : r.stack = o;
        } catch {
        }
      }
      throw r;
    }
  }
  _request(t, n) {
    typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = Sa(this.defaults, n);
    const { transitional: r, paramsSerializer: i, headers: o } = n;
    r !== void 0 && Gv.assertOptions(r, {
      silentJSONParsing: Ko.transitional(Ko.boolean),
      forcedJSONParsing: Ko.transitional(Ko.boolean),
      clarifyTimeoutError: Ko.transitional(Ko.boolean)
    }, !1), i != null && (fe.isFunction(i) ? n.paramsSerializer = {
      serialize: i
    } : Gv.assertOptions(i, {
      encode: Ko.function,
      serialize: Ko.function
    }, !0)), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let s = o && fe.merge(
      o.common,
      o[n.method]
    );
    o && fe.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (p) => {
        delete o[p];
      }
    ), n.headers = Cr.concat(s, o);
    const a = [];
    let l = !0;
    this.interceptors.request.forEach(function(m) {
      typeof m.runWhen == "function" && m.runWhen(n) === !1 || (l = l && m.synchronous, a.unshift(m.fulfilled, m.rejected));
    });
    const c = [];
    this.interceptors.response.forEach(function(m) {
      c.push(m.fulfilled, m.rejected);
    });
    let u, d = 0, f;
    if (!l) {
      const p = [ek.bind(this), void 0];
      for (p.unshift.apply(p, a), p.push.apply(p, c), f = p.length, u = Promise.resolve(n); d < f; )
        u = u.then(p[d++], p[d++]);
      return u;
    }
    f = a.length;
    let h = n;
    for (d = 0; d < f; ) {
      const p = a[d++], m = a[d++];
      try {
        h = p(h);
      } catch (g) {
        m.call(this, g);
        break;
      }
    }
    try {
      u = ek.call(this, h);
    } catch (p) {
      return Promise.reject(p);
    }
    for (d = 0, f = c.length; d < f; )
      u = u.then(c[d++], c[d++]);
    return u;
  }
  getUri(t) {
    t = Sa(this.defaults, t);
    const n = a2(t.baseURL, t.url);
    return n2(n, t.params, t.paramsSerializer);
  }
};
fe.forEach(["delete", "get", "head", "options"], function(t) {
  va.prototype[t] = function(n, r) {
    return this.request(Sa(r || {}, {
      method: t,
      url: n,
      data: (r || {}).data
    }));
  };
});
fe.forEach(["post", "put", "patch"], function(t) {
  function n(r) {
    return function(o, s, a) {
      return this.request(Sa(a || {}, {
        method: t,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: o,
        data: s
      }));
    };
  }
  va.prototype[t] = n(), va.prototype[t + "Form"] = n(!0);
});
let YF = class h2 {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(o) {
      n = o;
    });
    const r = this;
    this.promise.then((i) => {
      if (!r._listeners) return;
      let o = r._listeners.length;
      for (; o-- > 0; )
        r._listeners[o](i);
      r._listeners = null;
    }), this.promise.then = (i) => {
      let o;
      const s = new Promise((a) => {
        r.subscribe(a), o = a;
      }).then(i);
      return s.cancel = function() {
        r.unsubscribe(o);
      }, s;
    }, t(function(o, s, a) {
      r.reason || (r.reason = new Pc(o, s, a), n(r.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(t);
    n !== -1 && this._listeners.splice(n, 1);
  }
  toAbortSignal() {
    const t = new AbortController(), n = (r) => {
      t.abort(r);
    };
    return this.subscribe(n), t.signal.unsubscribe = () => this.unsubscribe(n), t.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new h2(function(i) {
        t = i;
      }),
      cancel: t
    };
  }
};
function QF(e) {
  return function(n) {
    return e.apply(null, n);
  };
}
function JF(e) {
  return fe.isObject(e) && e.isAxiosError === !0;
}
const Hv = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(Hv).forEach(([e, t]) => {
  Hv[t] = e;
});
function p2(e) {
  const t = new va(e), n = VA(va.prototype.request, t);
  return fe.extend(n, va.prototype, t, { allOwnKeys: !0 }), fe.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(i) {
    return p2(Sa(e, i));
  }, n;
}
const pn = p2(Id);
pn.Axios = va;
pn.CanceledError = Pc;
pn.CancelToken = YF;
pn.isCancel = o2;
pn.VERSION = f2;
pn.toFormData = Pp;
pn.AxiosError = ht;
pn.Cancel = pn.CanceledError;
pn.all = function(t) {
  return Promise.all(t);
};
pn.spread = QF;
pn.isAxiosError = JF;
pn.mergeConfig = Sa;
pn.AxiosHeaders = Cr;
pn.formToJSON = (e) => i2(fe.isHTMLForm(e) ? new FormData(e) : e);
pn.getAdapter = d2.getAdapter;
pn.HttpStatusCode = Hv;
pn.default = pn;
const {
  Axios: Xve,
  AxiosError: Zve,
  CanceledError: ebe,
  isCancel: tbe,
  CancelToken: nbe,
  VERSION: rbe,
  all: ibe,
  Cancel: obe,
  isAxiosError: _o,
  spread: sbe,
  toFormData: abe,
  AxiosHeaders: lbe,
  HttpStatusCode: cbe,
  formToJSON: ube,
  getAdapter: dbe,
  mergeConfig: fbe
} = pn, G = {
  of(e) {
    return Je(e);
  },
  empty() {
    return _t;
  },
  zero() {
    return _t;
  },
  fromNullable(e) {
    return e == null ? _t : Je(e);
  },
  fromFalsy(e) {
    return e ? Je(e) : _t;
  },
  fromPredicate(e, t) {
    switch (arguments.length) {
      case 1:
        return (n) => G.fromPredicate(e, n);
      default:
        return e(t) ? Je(t) : _t;
    }
  },
  mapMaybe(e, t) {
    switch (arguments.length) {
      case 1:
        return (n) => G.mapMaybe(e, n);
      default:
        return G.catMaybes(t.map(e));
    }
  },
  catMaybes(e) {
    let t = [];
    for (const n of e)
      n.isJust() && t.push(n.extract());
    return t;
  },
  encase(e) {
    try {
      return Je(e());
    } catch {
      return _t;
    }
  },
  isMaybe(e) {
    return e instanceof Y0 || e instanceof Q0;
  },
  sequence(e) {
    let t = [];
    for (const n of e)
      if (n.isJust())
        t.push(n.extract());
      else
        return _t;
    return Je(t);
  },
  "fantasy-land/of"(e) {
    return this.of(e);
  },
  "fantasy-land/empty"() {
    return this.empty();
  },
  "fantasy-land/zero"() {
    return this.zero();
  }
};
class Y0 {
  constructor(t) {
    this.__value = t, this["fantasy-land/equals"] = this.equals, this["fantasy-land/map"] = this.map, this["fantasy-land/ap"] = this.ap, this["fantasy-land/alt"] = this.alt, this["fantasy-land/chain"] = this.chain, this["fantasy-land/reduce"] = this.reduce, this["fantasy-land/extend"] = this.extend, this["fantasy-land/filter"] = this.filter;
  }
  isJust() {
    return !0;
  }
  isNothing() {
    return !1;
  }
  inspect() {
    return `Just(${this.__value})`;
  }
  toString() {
    return this.inspect();
  }
  toJSON() {
    const t = this.__value;
    return t instanceof Date ? t.toJSON() : t;
  }
  equals(t) {
    return this.extract() === t.extract();
  }
  map(t) {
    return Je(t(this.__value));
  }
  ap(t) {
    return t.isJust() ? this.map(t.extract()) : _t;
  }
  alt(t) {
    return this;
  }
  altLazy(t) {
    return this;
  }
  chain(t) {
    return t(this.__value);
  }
  chainNullable(t) {
    return G.fromNullable(t(this.__value));
  }
  join() {
    return this.__value;
  }
  reduce(t, n) {
    return t(n, this.__value);
  }
  extend(t) {
    return Je(t(this));
  }
  unsafeCoerce() {
    return this.__value;
  }
  caseOf(t) {
    return "_" in t ? t._() : t.Just(this.__value);
  }
  orDefault(t) {
    return this.__value;
  }
  orDefaultLazy(t) {
    return this.__value;
  }
  toList() {
    return [this.__value];
  }
  mapOrDefault(t, n) {
    return t(this.__value);
  }
  extract() {
    return this.__value;
  }
  extractNullable() {
    return this.__value;
  }
  toEither(t) {
    return _e(this.__value);
  }
  ifJust(t) {
    return t(this.__value), this;
  }
  ifNothing(t) {
    return this;
  }
  filter(t) {
    return t(this.__value) ? Je(this.__value) : _t;
  }
}
Y0.prototype.constructor = G;
class Q0 {
  constructor() {
    this["fantasy-land/equals"] = this.equals, this["fantasy-land/map"] = this.map, this["fantasy-land/ap"] = this.ap, this["fantasy-land/alt"] = this.alt, this["fantasy-land/chain"] = this.chain, this["fantasy-land/reduce"] = this.reduce, this["fantasy-land/extend"] = this.extend, this["fantasy-land/filter"] = this.filter;
  }
  isJust() {
    return !1;
  }
  isNothing() {
    return !0;
  }
  inspect() {
    return "Nothing";
  }
  toString() {
    return this.inspect();
  }
  toJSON() {
    return this.__value;
  }
  equals(t) {
    return this.extract() === t.extract();
  }
  map(t) {
    return _t;
  }
  ap(t) {
    return _t;
  }
  alt(t) {
    return t;
  }
  altLazy(t) {
    return t();
  }
  chain(t) {
    return _t;
  }
  chainNullable(t) {
    return _t;
  }
  join() {
    return _t;
  }
  reduce(t, n) {
    return n;
  }
  extend(t) {
    return _t;
  }
  unsafeCoerce() {
    throw new Error("Maybe#unsafeCoerce was ran on a Nothing");
  }
  caseOf(t) {
    return "_" in t ? t._() : t.Nothing();
  }
  orDefault(t) {
    return t;
  }
  orDefaultLazy(t) {
    return t();
  }
  toList() {
    return [];
  }
  mapOrDefault(t, n) {
    return n;
  }
  extract() {
  }
  extractNullable() {
    return null;
  }
  toEither(t) {
    return Xe(t);
  }
  ifJust(t) {
    return this;
  }
  ifNothing(t) {
    return t(), this;
  }
  filter(t) {
    return _t;
  }
}
Q0.prototype.constructor = G;
const Je = (e) => new Y0(e), _t = new Q0(), Hn = {
  of(e) {
    return _e(e);
  },
  lefts(e) {
    let t = [];
    for (const n of e)
      n.isLeft() && t.push(n.extract());
    return t;
  },
  rights(e) {
    let t = [];
    for (const n of e)
      n.isRight() && t.push(n.extract());
    return t;
  },
  encase(e) {
    try {
      return _e(e());
    } catch (t) {
      return Xe(t);
    }
  },
  sequence(e) {
    let t = [];
    for (const n of e) {
      if (n.isLeft())
        return n;
      t.push(n.extract());
    }
    return _e(t);
  },
  isEither(e) {
    return e instanceof X0 || e instanceof J0;
  },
  "fantasy-land/of"(e) {
    return Hn.of(e);
  }
};
class J0 {
  constructor(t) {
    this.__value = t, this._ = "R", this["fantasy-land/bimap"] = this.bimap, this["fantasy-land/map"] = this.map, this["fantasy-land/ap"] = this.ap, this["fantasy-land/equals"] = this.equals, this["fantasy-land/chain"] = this.chain, this["fantasy-land/alt"] = this.alt, this["fantasy-land/reduce"] = this.reduce, this["fantasy-land/extend"] = this.extend;
  }
  isLeft() {
    return !1;
  }
  isRight() {
    return !0;
  }
  toJSON() {
    return this.__value;
  }
  inspect() {
    return `Right(${this.__value})`;
  }
  toString() {
    return this.inspect();
  }
  bimap(t, n) {
    return _e(n(this.__value));
  }
  map(t) {
    return _e(t(this.__value));
  }
  mapLeft(t) {
    return this;
  }
  ap(t) {
    return t.isRight() ? this.map(t.extract()) : t;
  }
  equals(t) {
    return t.isRight() ? this.__value === t.extract() : !1;
  }
  chain(t) {
    return t(this.__value);
  }
  chainLeft(t) {
    return this;
  }
  join() {
    return this.__value;
  }
  alt(t) {
    return this;
  }
  altLazy(t) {
    return this;
  }
  reduce(t, n) {
    return t(n, this.__value);
  }
  extend(t) {
    return _e(t(this));
  }
  unsafeCoerce() {
    return this.__value;
  }
  caseOf(t) {
    return "_" in t ? t._() : t.Right(this.__value);
  }
  leftOrDefault(t) {
    return t;
  }
  orDefault(t) {
    return this.__value;
  }
  orDefaultLazy(t) {
    return this.__value;
  }
  leftOrDefaultLazy(t) {
    return t();
  }
  ifLeft(t) {
    return this;
  }
  ifRight(t) {
    return t(this.__value), this;
  }
  toMaybe() {
    return Je(this.__value);
  }
  leftToMaybe() {
    return _t;
  }
  extract() {
    return this.__value;
  }
  swap() {
    return Xe(this.__value);
  }
}
J0.prototype.constructor = Hn;
class X0 {
  constructor(t) {
    this.__value = t, this._ = "L", this["fantasy-land/bimap"] = this.bimap, this["fantasy-land/map"] = this.map, this["fantasy-land/ap"] = this.ap, this["fantasy-land/equals"] = this.equals, this["fantasy-land/chain"] = this.chain, this["fantasy-land/alt"] = this.alt, this["fantasy-land/reduce"] = this.reduce, this["fantasy-land/extend"] = this.extend;
  }
  isLeft() {
    return !0;
  }
  isRight() {
    return !1;
  }
  toJSON() {
    return this.__value;
  }
  inspect() {
    return `Left(${JSON.stringify(this.__value)})`;
  }
  toString() {
    return this.inspect();
  }
  bimap(t, n) {
    return Xe(t(this.__value));
  }
  map(t) {
    return this;
  }
  mapLeft(t) {
    return Xe(t(this.__value));
  }
  ap(t) {
    return t.isLeft() ? t : this;
  }
  equals(t) {
    return t.isLeft() ? t.extract() === this.__value : !1;
  }
  chain(t) {
    return this;
  }
  chainLeft(t) {
    return t(this.__value);
  }
  join() {
    return this;
  }
  alt(t) {
    return t;
  }
  altLazy(t) {
    return t();
  }
  reduce(t, n) {
    return n;
  }
  extend(t) {
    return this;
  }
  unsafeCoerce() {
    throw this.__value instanceof Error ? this.__value : new Error("Either#unsafeCoerce was ran on a Left");
  }
  caseOf(t) {
    return "_" in t ? t._() : t.Left(this.__value);
  }
  leftOrDefault(t) {
    return this.__value;
  }
  orDefault(t) {
    return t;
  }
  orDefaultLazy(t) {
    return t();
  }
  leftOrDefaultLazy(t) {
    return this.__value;
  }
  ifLeft(t) {
    return t(this.__value), this;
  }
  ifRight(t) {
    return this;
  }
  toMaybe() {
    return _t;
  }
  leftToMaybe() {
    return Je(this.__value);
  }
  extract() {
    return this.__value;
  }
  swap() {
    return _e(this.__value);
  }
}
X0.prototype.constructor = Hn;
const Xe = (e) => new X0(e), _e = (e) => new J0(e), Rd = (e) => e, Al = {
  LT: "LT",
  EQ: "EQ",
  GT: "GT"
}, XF = (e, t) => e > t ? Al.GT : e < t ? Al.LT : Al.EQ, ZF = (e) => {
  switch (e) {
    case Al.LT:
      return -1;
    case Al.EQ:
      return 0;
    case Al.GT:
      return 1;
  }
}, eL = (e) => e, Nm = Object.assign(eL, {
  fromArray: (e) => Nm.isNonEmpty(e) ? Je(e) : _t,
  unsafeCoerce: (e) => {
    if (Nm.isNonEmpty(e))
      return e;
    throw new Error("NonEmptyList#unsafeCoerce was ran on an empty array");
  },
  fromTuple: (e) => Nm(e.toArray()),
  head: (e) => e[0],
  last: (e) => e[e.length - 1],
  isNonEmpty: (e) => e.length > 0,
  tail: (e) => e.slice(1)
}), fh = (e, t) => typeof t == "bigint" ? t.toString() : t, y2 = (e) => typeof e == "object" && e !== null && !Array.isArray(e), Ms = (e, t) => {
  let n = "";
  switch (typeof t) {
    case "undefined":
      n = "undefined";
      break;
    case "object":
      n = t === null ? "null" : Array.isArray(t) ? "an array with value " + JSON.stringify(t, fh) : "an object with value " + JSON.stringify(t, fh);
      break;
    case "boolean":
      n = "a boolean";
      break;
    case "symbol":
      n = "a symbol";
      break;
    case "function":
      n = "a function";
      break;
    case "bigint":
      n = `a bigint with value ${t.toString()}`;
  }
  return n = n || `a ${typeof t} with value ${JSON.stringify(t, fh)}`, `Expected ${e}, but received ${n}`;
}, tL = (e) => {
  var n;
  return Object.keys(e).length === 1 && ((n = e.oneOf) == null ? void 0 : n.length) === 1 && typeof e.oneOf[0] == "object" && (Object.assign(e, e.oneOf[0]), delete e.oneOf), e;
}, nL = (e) => {
  if (Array.isArray(e.oneOf))
    for (let t = 0; t < e.oneOf.length; t++) {
      const n = e.oneOf[t];
      if (typeof n == "object" && n.oneOf)
        return e.oneOf.splice(t, 1), e.oneOf.push(...n.oneOf), m2(e);
    }
  return e;
}, m2 = (e) => (nL(e), tL(e), e), wn = {
  /** Creates a codec for any JSON object */
  interface(e) {
    const t = Object.keys(e), n = (i) => {
      if (!y2(i))
        return Xe(Ms("an object", i));
      const o = {};
      for (const s of t) {
        if (!i.hasOwnProperty(s) && !e[s]._isOptional)
          return Xe(`Problem with property "${s}": it does not exist in received object ${JSON.stringify(i, fh)}`);
        const a = e[s].decode(i[s]);
        if (a.isLeft())
          return Xe(`Problem with the value of property "${s}": ${a.extract()}`);
        const l = a.extract();
        l !== void 0 && (o[s] = l);
      }
      return _e(o);
    };
    return {
      decode: n,
      encode: (i) => {
        const o = {};
        for (const s of t)
          o[s] = e[s].encode(i[s]);
        return o;
      },
      unsafeDecode: (i) => n(i).mapLeft(Error).unsafeCoerce(),
      schema: () => t.reduce((i, o) => (e[o]._isOptional || i.required.push(o), i.properties[o] = m2(e[o].schema()), i), {
        type: "object",
        properties: {},
        required: []
      })
    };
  },
  /** Creates a codec for any type, you can add your own deserialization/validation logic in the decode argument */
  custom({ decode: e, encode: t, schema: n }) {
    return {
      decode: e,
      encode: t,
      unsafeDecode: (r) => e(r).mapLeft(Error).unsafeCoerce(),
      schema: n ?? (() => ({}))
    };
  }
}, lr = wn.custom({
  decode: (e) => typeof e == "string" ? _e(e) : Xe(Ms("a string", e)),
  encode: Rd,
  schema: () => ({ type: "string" })
}), Tu = wn.custom({
  decode: (e) => typeof e == "number" ? _e(e) : Xe(Ms("a number", e)),
  encode: Rd,
  schema: () => ({ type: "number" })
}), rL = wn.custom({
  decode: (e) => e === void 0 ? _e(e) : Xe(Ms("an undefined", e)),
  encode: Rd
}), Dm = (e) => ({
  ...oL([e, rL]),
  schema: e.schema,
  _isOptional: !0
}), iL = wn.custom({
  decode: (e) => typeof e == "boolean" ? _e(e) : Xe(Ms("a boolean", e)),
  encode: Rd,
  schema: () => ({ type: "boolean" })
}), oL = (e) => wn.custom({
  decode: (t) => {
    let n = [];
    for (const r of e) {
      const i = r.decode(t);
      if (i.isRight())
        return i;
      n.push(i.extract());
    }
    return Xe(`One of the following problems occured: ${n.map((r, i) => `(${i}) ${r}`).join(", ")}`);
  },
  encode: (t) => {
    for (const n of e)
      if (Hn.encase(() => n.encode(t)).mapLeft((i) => "").chain(n.decode).isRight())
        return n.encode(t);
    return t;
  },
  schema: () => ({ oneOf: e.map((t) => t.schema()) })
}), nk = (e) => wn.custom({
  decode: (t) => {
    if (Array.isArray(t)) {
      const n = [];
      for (let r = 0; r < t.length; r++) {
        const i = e.decode(t[r]);
        if (i.isRight())
          n.push(i.extract());
        else
          return Xe(`Problem with the value at index ${r}: ${i.extract()}`);
      }
      return _e(n);
    } else
      return Xe(Ms("an array", t));
  },
  encode: (t) => t.map(e.encode),
  schema: () => ({
    type: "array",
    items: e.schema()
  })
}), sL = wn.custom({
  decode: (e) => lr.decode(e).chain((t) => isFinite(+t) ? _e(t) : Xe(Ms("a number", e))),
  encode: Rd,
  schema: Tu.schema
}), jm = (e, t) => wn.custom({
  decode: (n) => {
    const r = {}, i = e === Tu ? sL : e;
    if (!y2(n))
      return Xe(Ms("an object", n));
    for (const o of Object.keys(n))
      if (n.hasOwnProperty(o)) {
        const s = i.decode(o), a = t.decode(n[o]);
        if (s.isRight() && a.isRight())
          r[s.extract()] = a.extract();
        else {
          if (s.isLeft())
            return Xe(`Problem with key type of property "${o}": ${s.extract()}`);
          if (a.isLeft())
            return Xe(`Problem with the value of property "${o}": ${a.extract()}`);
        }
      }
    return _e(r);
  },
  encode: (n) => {
    const r = {};
    for (const i in n)
      n.hasOwnProperty(i) && (r[e.encode(i)] = t.encode(n[i]));
    return r;
  },
  schema: () => ({
    type: "object",
    additionalProperties: t.schema()
  })
});
class g2 {
  constructor(t, n) {
    this.first = t, this.second = n, this.length = 2, this["fantasy-land/equals"] = this.equals, this["fantasy-land/bimap"] = this.bimap, this["fantasy-land/map"] = this.map, this["fantasy-land/reduce"] = this.reduce, this["fantasy-land/ap"] = this.ap, this[0] = t, this[1] = n;
  }
  *[Symbol.iterator]() {
    yield this.first, yield this.second;
  }
  toJSON() {
    return this.toArray();
  }
  inspect() {
    return `Tuple(${JSON.stringify(this.first)}, ${JSON.stringify(this.second)})`;
  }
  toString() {
    return this.inspect();
  }
  fst() {
    return this.first;
  }
  snd() {
    return this.second;
  }
  equals(t) {
    return this.first === t.fst() && this.second === t.snd();
  }
  bimap(t, n) {
    return ki(t(this.first), n(this.second));
  }
  mapFirst(t) {
    return ki(t(this.first), this.second);
  }
  map(t) {
    return ki(this.first, t(this.second));
  }
  reduce(t, n) {
    return t(n, this.second);
  }
  toArray() {
    return [this.first, this.second];
  }
  swap() {
    return ki(this.second, this.first);
  }
  ap(t) {
    return ki(this.first, t.snd()(this.second));
  }
  every(t) {
    return t(this.first) && t(this.second);
  }
  some(t) {
    return t(this.first) || t(this.second);
  }
}
const ki = Object.assign((e, t) => new g2(e, t), {
  fromArray: ([e, t]) => ki(e, t),
  fanout: (...e) => {
    const [t, n, r] = e;
    switch (e.length) {
      case 3:
        return ki(t(r), n(r));
      case 2:
        return (i) => ki.fanout(t, n, i);
      default:
        return (i) => (o) => ki.fanout(t, i, o);
    }
  }
});
g2.prototype.constructor = ki;
const aL = (e) => e.length > 0 ? Je(e[0]) : _t, lL = (e) => e.length > 0 ? Je(e[e.length - 1]) : _t, cL = (e) => e.length > 0 ? Je(e.slice(1)) : _t, uL = (e) => e.length > 0 ? Je(e.slice(0, -1)) : _t, dL = (e) => e.length > 0 ? Je(ki(e[0], e.slice(1))) : _t, fL = (e) => e.reduce((t, n) => t + n, 0);
function v2(e, t) {
  switch (arguments.length) {
    case 1:
      return (n) => v2(e, n);
    default:
      return G.fromNullable(t.find(e));
  }
}
function b2(e, t) {
  switch (arguments.length) {
    case 1:
      return (n) => b2(e, n);
    default:
      return G.fromPredicate((n) => n !== -1, t.findIndex(e));
  }
}
function w2(e, t) {
  switch (arguments.length) {
    case 1:
      return (n) => w2(e, n);
    default:
      return t[e] === void 0 ? _t : Je(t[e]);
  }
}
function x2(e, t) {
  switch (arguments.length) {
    case 1:
      return (n) => x2(e, n);
    default:
      return [...t].sort((n, r) => ZF(e(n, r)));
  }
}
const pt = {
  init: uL,
  uncons: dL,
  at: w2,
  head: aL,
  last: lL,
  tail: cL,
  find: v2,
  findIndex: b2,
  sum: fL,
  sort: x2
};
var C2;
const k2 = {
  liftEither(e) {
    if (e.isRight())
      return Promise.resolve(e.extract());
    throw e.extract();
  },
  fromPromise(e) {
    return e.then(k2.liftEither);
  },
  throwE(e) {
    throw e;
  }
};
class E2 {
  constructor(t) {
    this.runPromise = t, this[C2] = "EitherAsync", this["fantasy-land/chain"] = this.chain, this["fantasy-land/alt"] = this.alt, this.then = (n, r) => this.run().then(n, r);
  }
  leftOrDefault(t) {
    return this.run().then((n) => n.leftOrDefault(t));
  }
  orDefault(t) {
    return this.run().then((n) => n.orDefault(t));
  }
  join() {
    return de(async (t) => {
      const n = await this;
      if (n.isRight()) {
        const r = await n.extract();
        return t.liftEither(r);
      }
      return t.liftEither(n);
    });
  }
  ap(t) {
    return de(async (n) => {
      const r = await t;
      if (r.isRight()) {
        const i = await this.run();
        return i.isRight() ? r.extract()(i.extract()) : n.liftEither(i);
      }
      return n.liftEither(r);
    });
  }
  alt(t) {
    return de(async (n) => {
      const r = await this.run();
      if (r.isRight())
        return r.extract();
      {
        const i = await t;
        return n.liftEither(i);
      }
    });
  }
  extend(t) {
    return de(async (n) => {
      const r = await this.run();
      if (r.isRight()) {
        const i = de.liftEither(r);
        return n.liftEither(_e(t(i)));
      }
      return n.liftEither(r);
    });
  }
  async run() {
    try {
      return _e(await this.runPromise(k2));
    } catch (t) {
      return Xe(t);
    }
  }
  bimap(t, n) {
    return de(async (r) => {
      const i = await this.run();
      try {
        return await r.liftEither(i.bimap(t, n));
      } catch (o) {
        throw await o;
      }
    });
  }
  map(t) {
    return de((n) => this.runPromise(n).then(t));
  }
  mapLeft(t) {
    return de(async (n) => {
      try {
        return await this.runPromise(n);
      } catch (r) {
        throw await t(r);
      }
    });
  }
  chain(t) {
    return de(async (n) => {
      const r = await this.runPromise(n);
      return n.fromPromise(t(r));
    });
  }
  chainLeft(t) {
    return de(async (n) => {
      try {
        return await this.runPromise(n);
      } catch (r) {
        return n.fromPromise(t(r));
      }
    });
  }
  toMaybeAsync() {
    return Fn(async ({ liftMaybe: t }) => {
      const n = await this.run();
      return t(n.toMaybe());
    });
  }
  swap() {
    return de(async (t) => {
      const n = await this.run();
      return n.isRight() && t.throwE(n.extract()), t.liftEither(_e(n.extract()));
    });
  }
  ifLeft(t) {
    return de(async (n) => {
      const r = await this.run();
      return r.ifLeft(t), n.liftEither(r);
    });
  }
  ifRight(t) {
    return de(async (n) => {
      const r = await this.run();
      return r.ifRight(t), n.liftEither(r);
    });
  }
  void() {
    return this.map((t) => {
    });
  }
  caseOf(t) {
    return this.run().then((n) => n.caseOf(t));
  }
  finally(t) {
    return de(({ fromPromise: n }) => n(this.run().finally(t)));
  }
}
C2 = Symbol.toStringTag;
const de = Object.assign((e) => new E2(e), {
  fromPromise: (e) => de(({ fromPromise: t }) => t(e())),
  liftEither: (e) => de(({ liftEither: t }) => t(e)),
  lefts: (e) => Promise.all(e.map((t) => t.run())).then(Hn.lefts),
  rights: (e) => Promise.all(e.map((t) => t.run())).then(Hn.rights),
  sequence: (e) => de(async (t) => {
    let n = [];
    for await (const r of e) {
      if (r.isLeft())
        return t.liftEither(r);
      n.push(r.extract());
    }
    return t.liftEither(_e(n));
  }),
  all: (e) => de.fromPromise(async () => Promise.all(e).then(Hn.sequence))
});
E2.prototype.constructor = de;
var S2;
const A2 = {
  liftMaybe(e) {
    if (e.isJust())
      return Promise.resolve(e.extract());
    throw _t;
  },
  fromPromise(e) {
    return e.then(A2.liftMaybe);
  }
};
class T2 {
  constructor(t) {
    this.runPromise = t, this[S2] = "MaybeAsync", this["fantasy-land/chain"] = this.chain, this["fantasy-land/filter"] = this.filter, this["fantasy-land/alt"] = this.alt;
  }
  orDefault(t) {
    return this.run().then((n) => n.orDefault(t));
  }
  join() {
    return Fn(async (t) => {
      const n = await this.run();
      if (n.isJust()) {
        const r = await n.extract();
        return t.liftMaybe(r);
      }
      return t.liftMaybe(_t);
    });
  }
  ap(t) {
    return Fn(async (n) => {
      const r = await t;
      if (r.isJust()) {
        const i = await this.run();
        return i.isJust() ? r.extract()(i.extract()) : n.liftMaybe(_t);
      }
      return n.liftMaybe(_t);
    });
  }
  alt(t) {
    return Fn(async (n) => {
      const r = await this.run();
      if (r.isJust())
        return r.extract();
      {
        const i = await t;
        return n.liftMaybe(i);
      }
    });
  }
  extend(t) {
    return Fn(async (n) => {
      const r = await this.run();
      if (r.isJust()) {
        const i = Fn.liftMaybe(r);
        return n.liftMaybe(Je(t(i)));
      }
      return n.liftMaybe(_t);
    });
  }
  filter(t) {
    return Fn(async (n) => {
      const r = await this.run();
      return n.liftMaybe(r.filter(t));
    });
  }
  async run() {
    try {
      return Je(await this.runPromise(A2));
    } catch {
      return _t;
    }
  }
  map(t) {
    return Fn((n) => this.runPromise(n).then(t));
  }
  chain(t) {
    return Fn(async (n) => {
      const r = await this.runPromise(n);
      return n.fromPromise(t(r));
    });
  }
  toEitherAsync(t) {
    return de(async ({ liftEither: n }) => {
      const r = await this.run();
      return n(r.toEither(t));
    });
  }
  ifJust(t) {
    return Fn(async (n) => {
      const r = await this.run();
      return r.ifJust(t), n.liftMaybe(r);
    });
  }
  ifNothing(t) {
    return Fn(async (n) => {
      const r = await this.run();
      return r.ifNothing(t), n.liftMaybe(r);
    });
  }
  void() {
    return this.map((t) => {
    });
  }
  caseOf(t) {
    return this.run().then((n) => n.caseOf(t));
  }
  finally(t) {
    return Fn(({ fromPromise: n }) => n(this.run().finally(t)));
  }
  then(t, n) {
    return this.run().then(t, n);
  }
}
S2 = Symbol.toStringTag;
const Fn = Object.assign((e) => new T2(e), {
  catMaybes: (e) => Promise.all(e).then(G.catMaybes),
  fromPromise: (e) => Fn(({ fromPromise: t }) => t(e())),
  liftMaybe: (e) => Fn(({ liftMaybe: t }) => t(e))
});
T2.prototype.constructor = Fn;
var hL = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, Mm = Math.ceil, qr = Math.floor, yr = "[BigNumber Error] ", rk = yr + "Number primitive has more than 15 significant digits: ", vi = 1e14, dt = 14, Fm = 9007199254740991, Lm = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], Yo = 1e7, Pn = 1e9;
function _2(e) {
  var t, n, r, i = w.prototype = { constructor: w, toString: null, valueOf: null }, o = new w(1), s = 20, a = 4, l = -7, c = 21, u = -1e7, d = 1e7, f = !1, h = 1, p = 0, m = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: " ",
    // non-breaking space
    suffix: ""
  }, g = "0123456789abcdefghijklmnopqrstuvwxyz", v = !0;
  function w(b, T) {
    var R, B, O, L, V, N, M, U, F = this;
    if (!(F instanceof w)) return new w(b, T);
    if (T == null) {
      if (b && b._isBigNumber === !0) {
        F.s = b.s, !b.c || b.e > d ? F.c = F.e = null : b.e < u ? F.c = [F.e = 0] : (F.e = b.e, F.c = b.c.slice());
        return;
      }
      if ((N = typeof b == "number") && b * 0 == 0) {
        if (F.s = 1 / b < 0 ? (b = -b, -1) : 1, b === ~~b) {
          for (L = 0, V = b; V >= 10; V /= 10, L++) ;
          L > d ? F.c = F.e = null : (F.e = L, F.c = [b]);
          return;
        }
        U = String(b);
      } else {
        if (!hL.test(U = String(b))) return r(F, U, N);
        F.s = U.charCodeAt(0) == 45 ? (U = U.slice(1), -1) : 1;
      }
      (L = U.indexOf(".")) > -1 && (U = U.replace(".", "")), (V = U.search(/e/i)) > 0 ? (L < 0 && (L = V), L += +U.slice(V + 1), U = U.substring(0, V)) : L < 0 && (L = U.length);
    } else {
      if (nn(T, 2, g.length, "Base"), T == 10 && v)
        return F = new w(b), k(F, s + F.e + 1, a);
      if (U = String(b), N = typeof b == "number") {
        if (b * 0 != 0) return r(F, U, N, T);
        if (F.s = 1 / b < 0 ? (U = U.slice(1), -1) : 1, w.DEBUG && U.replace(/^0\.0*|\./, "").length > 15)
          throw Error(rk + b);
      } else
        F.s = U.charCodeAt(0) === 45 ? (U = U.slice(1), -1) : 1;
      for (R = g.slice(0, T), L = V = 0, M = U.length; V < M; V++)
        if (R.indexOf(B = U.charAt(V)) < 0) {
          if (B == ".") {
            if (V > L) {
              L = M;
              continue;
            }
          } else if (!O && (U == U.toUpperCase() && (U = U.toLowerCase()) || U == U.toLowerCase() && (U = U.toUpperCase()))) {
            O = !0, V = -1, L = 0;
            continue;
          }
          return r(F, String(b), N, T);
        }
      N = !1, U = n(U, T, 10, F.s), (L = U.indexOf(".")) > -1 ? U = U.replace(".", "") : L = U.length;
    }
    for (V = 0; U.charCodeAt(V) === 48; V++) ;
    for (M = U.length; U.charCodeAt(--M) === 48; ) ;
    if (U = U.slice(V, ++M)) {
      if (M -= V, N && w.DEBUG && M > 15 && (b > Fm || b !== qr(b)))
        throw Error(rk + F.s * b);
      if ((L = L - V - 1) > d)
        F.c = F.e = null;
      else if (L < u)
        F.c = [F.e = 0];
      else {
        if (F.e = L, F.c = [], V = (L + 1) % dt, L < 0 && (V += dt), V < M) {
          for (V && F.c.push(+U.slice(0, V)), M -= dt; V < M; )
            F.c.push(+U.slice(V, V += dt));
          V = dt - (U = U.slice(V)).length;
        } else
          V -= M;
        for (; V--; U += "0") ;
        F.c.push(+U);
      }
    } else
      F.c = [F.e = 0];
  }
  w.clone = _2, w.ROUND_UP = 0, w.ROUND_DOWN = 1, w.ROUND_CEIL = 2, w.ROUND_FLOOR = 3, w.ROUND_HALF_UP = 4, w.ROUND_HALF_DOWN = 5, w.ROUND_HALF_EVEN = 6, w.ROUND_HALF_CEIL = 7, w.ROUND_HALF_FLOOR = 8, w.EUCLID = 9, w.config = w.set = function(b) {
    var T, R;
    if (b != null)
      if (typeof b == "object") {
        if (b.hasOwnProperty(T = "DECIMAL_PLACES") && (R = b[T], nn(R, 0, Pn, T), s = R), b.hasOwnProperty(T = "ROUNDING_MODE") && (R = b[T], nn(R, 0, 8, T), a = R), b.hasOwnProperty(T = "EXPONENTIAL_AT") && (R = b[T], R && R.pop ? (nn(R[0], -Pn, 0, T), nn(R[1], 0, Pn, T), l = R[0], c = R[1]) : (nn(R, -Pn, Pn, T), l = -(c = R < 0 ? -R : R))), b.hasOwnProperty(T = "RANGE"))
          if (R = b[T], R && R.pop)
            nn(R[0], -Pn, -1, T), nn(R[1], 1, Pn, T), u = R[0], d = R[1];
          else if (nn(R, -Pn, Pn, T), R)
            u = -(d = R < 0 ? -R : R);
          else
            throw Error(yr + T + " cannot be zero: " + R);
        if (b.hasOwnProperty(T = "CRYPTO"))
          if (R = b[T], R === !!R)
            if (R)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                f = R;
              else
                throw f = !R, Error(yr + "crypto unavailable");
            else
              f = R;
          else
            throw Error(yr + T + " not true or false: " + R);
        if (b.hasOwnProperty(T = "MODULO_MODE") && (R = b[T], nn(R, 0, 9, T), h = R), b.hasOwnProperty(T = "POW_PRECISION") && (R = b[T], nn(R, 0, Pn, T), p = R), b.hasOwnProperty(T = "FORMAT"))
          if (R = b[T], typeof R == "object") m = R;
          else throw Error(yr + T + " not an object: " + R);
        if (b.hasOwnProperty(T = "ALPHABET"))
          if (R = b[T], typeof R == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(R))
            v = R.slice(0, 10) == "0123456789", g = R;
          else
            throw Error(yr + T + " invalid: " + R);
      } else
        throw Error(yr + "Object expected: " + b);
    return {
      DECIMAL_PLACES: s,
      ROUNDING_MODE: a,
      EXPONENTIAL_AT: [l, c],
      RANGE: [u, d],
      CRYPTO: f,
      MODULO_MODE: h,
      POW_PRECISION: p,
      FORMAT: m,
      ALPHABET: g
    };
  }, w.isBigNumber = function(b) {
    if (!b || b._isBigNumber !== !0) return !1;
    if (!w.DEBUG) return !0;
    var T, R, B = b.c, O = b.e, L = b.s;
    e: if ({}.toString.call(B) == "[object Array]") {
      if ((L === 1 || L === -1) && O >= -Pn && O <= Pn && O === qr(O)) {
        if (B[0] === 0) {
          if (O === 0 && B.length === 1) return !0;
          break e;
        }
        if (T = (O + 1) % dt, T < 1 && (T += dt), String(B[0]).length == T) {
          for (T = 0; T < B.length; T++)
            if (R = B[T], R < 0 || R >= vi || R !== qr(R)) break e;
          if (R !== 0) return !0;
        }
      }
    } else if (B === null && O === null && (L === null || L === 1 || L === -1))
      return !0;
    throw Error(yr + "Invalid BigNumber: " + b);
  }, w.maximum = w.max = function() {
    return C(arguments, -1);
  }, w.minimum = w.min = function() {
    return C(arguments, 1);
  }, w.random = function() {
    var b = 9007199254740992, T = Math.random() * b & 2097151 ? function() {
      return qr(Math.random() * b);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(R) {
      var B, O, L, V, N, M = 0, U = [], F = new w(o);
      if (R == null ? R = s : nn(R, 0, Pn), V = Mm(R / dt), f)
        if (crypto.getRandomValues) {
          for (B = crypto.getRandomValues(new Uint32Array(V *= 2)); M < V; )
            N = B[M] * 131072 + (B[M + 1] >>> 11), N >= 9e15 ? (O = crypto.getRandomValues(new Uint32Array(2)), B[M] = O[0], B[M + 1] = O[1]) : (U.push(N % 1e14), M += 2);
          M = V / 2;
        } else if (crypto.randomBytes) {
          for (B = crypto.randomBytes(V *= 7); M < V; )
            N = (B[M] & 31) * 281474976710656 + B[M + 1] * 1099511627776 + B[M + 2] * 4294967296 + B[M + 3] * 16777216 + (B[M + 4] << 16) + (B[M + 5] << 8) + B[M + 6], N >= 9e15 ? crypto.randomBytes(7).copy(B, M) : (U.push(N % 1e14), M += 7);
          M = V / 7;
        } else
          throw f = !1, Error(yr + "crypto unavailable");
      if (!f)
        for (; M < V; )
          N = T(), N < 9e15 && (U[M++] = N % 1e14);
      for (V = U[--M], R %= dt, V && R && (N = Lm[dt - R], U[M] = qr(V / N) * N); U[M] === 0; U.pop(), M--) ;
      if (M < 0)
        U = [L = 0];
      else {
        for (L = -1; U[0] === 0; U.splice(0, 1), L -= dt) ;
        for (M = 1, N = U[0]; N >= 10; N /= 10, M++) ;
        M < dt && (L -= dt - M);
      }
      return F.e = L, F.c = U, F;
    };
  }(), w.sum = function() {
    for (var b = 1, T = arguments, R = new w(T[0]); b < T.length; ) R = R.plus(T[b++]);
    return R;
  }, n = /* @__PURE__ */ function() {
    var b = "0123456789";
    function T(R, B, O, L) {
      for (var V, N = [0], M, U = 0, F = R.length; U < F; ) {
        for (M = N.length; M--; N[M] *= B) ;
        for (N[0] += L.indexOf(R.charAt(U++)), V = 0; V < N.length; V++)
          N[V] > O - 1 && (N[V + 1] == null && (N[V + 1] = 0), N[V + 1] += N[V] / O | 0, N[V] %= O);
      }
      return N.reverse();
    }
    return function(R, B, O, L, V) {
      var N, M, U, F, $, ie, he, ae, se = R.indexOf("."), oe = s, ye = a;
      for (se >= 0 && (F = p, p = 0, R = R.replace(".", ""), ae = new w(B), ie = ae.pow(R.length - se), p = F, ae.c = T(
        uo(Ur(ie.c), ie.e, "0"),
        10,
        O,
        b
      ), ae.e = ae.c.length), he = T(R, B, O, V ? (N = g, b) : (N = b, g)), U = F = he.length; he[--F] == 0; he.pop()) ;
      if (!he[0]) return N.charAt(0);
      if (se < 0 ? --U : (ie.c = he, ie.e = U, ie.s = L, ie = t(ie, ae, oe, ye, O), he = ie.c, $ = ie.r, U = ie.e), M = U + oe + 1, se = he[M], F = O / 2, $ = $ || M < 0 || he[M + 1] != null, $ = ye < 4 ? (se != null || $) && (ye == 0 || ye == (ie.s < 0 ? 3 : 2)) : se > F || se == F && (ye == 4 || $ || ye == 6 && he[M - 1] & 1 || ye == (ie.s < 0 ? 8 : 7)), M < 1 || !he[0])
        R = $ ? uo(N.charAt(1), -oe, N.charAt(0)) : N.charAt(0);
      else {
        if (he.length = M, $)
          for (--O; ++he[--M] > O; )
            he[M] = 0, M || (++U, he = [1].concat(he));
        for (F = he.length; !he[--F]; ) ;
        for (se = 0, R = ""; se <= F; R += N.charAt(he[se++])) ;
        R = uo(R, U, N.charAt(0));
      }
      return R;
    };
  }(), t = /* @__PURE__ */ function() {
    function b(B, O, L) {
      var V, N, M, U, F = 0, $ = B.length, ie = O % Yo, he = O / Yo | 0;
      for (B = B.slice(); $--; )
        M = B[$] % Yo, U = B[$] / Yo | 0, V = he * M + U * ie, N = ie * M + V % Yo * Yo + F, F = (N / L | 0) + (V / Yo | 0) + he * U, B[$] = N % L;
      return F && (B = [F].concat(B)), B;
    }
    function T(B, O, L, V) {
      var N, M;
      if (L != V)
        M = L > V ? 1 : -1;
      else
        for (N = M = 0; N < L; N++)
          if (B[N] != O[N]) {
            M = B[N] > O[N] ? 1 : -1;
            break;
          }
      return M;
    }
    function R(B, O, L, V) {
      for (var N = 0; L--; )
        B[L] -= N, N = B[L] < O[L] ? 1 : 0, B[L] = N * V + B[L] - O[L];
      for (; !B[0] && B.length > 1; B.splice(0, 1)) ;
    }
    return function(B, O, L, V, N) {
      var M, U, F, $, ie, he, ae, se, oe, ye, ve, Be, it, lt, yt, gt, vt, ot = B.s == O.s ? 1 : -1, Le = B.c, tt = O.c;
      if (!Le || !Le[0] || !tt || !tt[0])
        return new w(
          // Return NaN if either NaN, or both Infinity or 0.
          !B.s || !O.s || (Le ? tt && Le[0] == tt[0] : !tt) ? NaN : (
            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            Le && Le[0] == 0 || !tt ? ot * 0 : ot / 0
          )
        );
      for (se = new w(ot), oe = se.c = [], U = B.e - O.e, ot = L + U + 1, N || (N = vi, U = $r(B.e / dt) - $r(O.e / dt), ot = ot / dt | 0), F = 0; tt[F] == (Le[F] || 0); F++) ;
      if (tt[F] > (Le[F] || 0) && U--, ot < 0)
        oe.push(1), $ = !0;
      else {
        for (lt = Le.length, gt = tt.length, F = 0, ot += 2, ie = qr(N / (tt[0] + 1)), ie > 1 && (tt = b(tt, ie, N), Le = b(Le, ie, N), gt = tt.length, lt = Le.length), it = gt, ye = Le.slice(0, gt), ve = ye.length; ve < gt; ye[ve++] = 0) ;
        vt = tt.slice(), vt = [0].concat(vt), yt = tt[0], tt[1] >= N / 2 && yt++;
        do {
          if (ie = 0, M = T(tt, ye, gt, ve), M < 0) {
            if (Be = ye[0], gt != ve && (Be = Be * N + (ye[1] || 0)), ie = qr(Be / yt), ie > 1)
              for (ie >= N && (ie = N - 1), he = b(tt, ie, N), ae = he.length, ve = ye.length; T(he, ye, ae, ve) == 1; )
                ie--, R(he, gt < ae ? vt : tt, ae, N), ae = he.length, M = 1;
            else
              ie == 0 && (M = ie = 1), he = tt.slice(), ae = he.length;
            if (ae < ve && (he = [0].concat(he)), R(ye, he, ve, N), ve = ye.length, M == -1)
              for (; T(tt, ye, gt, ve) < 1; )
                ie++, R(ye, gt < ve ? vt : tt, ve, N), ve = ye.length;
          } else M === 0 && (ie++, ye = [0]);
          oe[F++] = ie, ye[0] ? ye[ve++] = Le[it] || 0 : (ye = [Le[it]], ve = 1);
        } while ((it++ < lt || ye[0] != null) && ot--);
        $ = ye[0] != null, oe[0] || oe.splice(0, 1);
      }
      if (N == vi) {
        for (F = 1, ot = oe[0]; ot >= 10; ot /= 10, F++) ;
        k(se, L + (se.e = F + U * dt - 1) + 1, V, $);
      } else
        se.e = U, se.r = +$;
      return se;
    };
  }();
  function x(b, T, R, B) {
    var O, L, V, N, M;
    if (R == null ? R = a : nn(R, 0, 8), !b.c) return b.toString();
    if (O = b.c[0], V = b.e, T == null)
      M = Ur(b.c), M = B == 1 || B == 2 && (V <= l || V >= c) ? Af(M, V) : uo(M, V, "0");
    else if (b = k(new w(b), T, R), L = b.e, M = Ur(b.c), N = M.length, B == 1 || B == 2 && (T <= L || L <= l)) {
      for (; N < T; M += "0", N++) ;
      M = Af(M, L);
    } else if (T -= V, M = uo(M, L, "0"), L + 1 > N) {
      if (--T > 0) for (M += "."; T--; M += "0") ;
    } else if (T += L - N, T > 0)
      for (L + 1 == N && (M += "."); T--; M += "0") ;
    return b.s < 0 && O ? "-" + M : M;
  }
  function C(b, T) {
    for (var R, B, O = 1, L = new w(b[0]); O < b.length; O++)
      B = new w(b[O]), (!B.s || (R = Ks(L, B)) === T || R === 0 && L.s === T) && (L = B);
    return L;
  }
  function S(b, T, R) {
    for (var B = 1, O = T.length; !T[--O]; T.pop()) ;
    for (O = T[0]; O >= 10; O /= 10, B++) ;
    return (R = B + R * dt - 1) > d ? b.c = b.e = null : R < u ? b.c = [b.e = 0] : (b.e = R, b.c = T), b;
  }
  r = /* @__PURE__ */ function() {
    var b = /^(-?)0([xbo])(?=\w[\w.]*$)/i, T = /^([^.]+)\.$/, R = /^\.([^.]+)$/, B = /^-?(Infinity|NaN)$/, O = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(L, V, N, M) {
      var U, F = N ? V : V.replace(O, "");
      if (B.test(F))
        L.s = isNaN(F) ? null : F < 0 ? -1 : 1;
      else {
        if (!N && (F = F.replace(b, function($, ie, he) {
          return U = (he = he.toLowerCase()) == "x" ? 16 : he == "b" ? 2 : 8, !M || M == U ? ie : $;
        }), M && (U = M, F = F.replace(T, "$1").replace(R, "0.$1")), V != F))
          return new w(F, U);
        if (w.DEBUG)
          throw Error(yr + "Not a" + (M ? " base " + M : "") + " number: " + V);
        L.s = null;
      }
      L.c = L.e = null;
    };
  }();
  function k(b, T, R, B) {
    var O, L, V, N, M, U, F, $ = b.c, ie = Lm;
    if ($) {
      e: {
        for (O = 1, N = $[0]; N >= 10; N /= 10, O++) ;
        if (L = T - O, L < 0)
          L += dt, V = T, M = $[U = 0], F = qr(M / ie[O - V - 1] % 10);
        else if (U = Mm((L + 1) / dt), U >= $.length)
          if (B) {
            for (; $.length <= U; $.push(0)) ;
            M = F = 0, O = 1, L %= dt, V = L - dt + 1;
          } else
            break e;
        else {
          for (M = N = $[U], O = 1; N >= 10; N /= 10, O++) ;
          L %= dt, V = L - dt + O, F = V < 0 ? 0 : qr(M / ie[O - V - 1] % 10);
        }
        if (B = B || T < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        $[U + 1] != null || (V < 0 ? M : M % ie[O - V - 1]), B = R < 4 ? (F || B) && (R == 0 || R == (b.s < 0 ? 3 : 2)) : F > 5 || F == 5 && (R == 4 || B || R == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (L > 0 ? V > 0 ? M / ie[O - V] : 0 : $[U - 1]) % 10 & 1 || R == (b.s < 0 ? 8 : 7)), T < 1 || !$[0])
          return $.length = 0, B ? (T -= b.e + 1, $[0] = ie[(dt - T % dt) % dt], b.e = -T || 0) : $[0] = b.e = 0, b;
        if (L == 0 ? ($.length = U, N = 1, U--) : ($.length = U + 1, N = ie[dt - L], $[U] = V > 0 ? qr(M / ie[O - V] % ie[V]) * N : 0), B)
          for (; ; )
            if (U == 0) {
              for (L = 1, V = $[0]; V >= 10; V /= 10, L++) ;
              for (V = $[0] += N, N = 1; V >= 10; V /= 10, N++) ;
              L != N && (b.e++, $[0] == vi && ($[0] = 1));
              break;
            } else {
              if ($[U] += N, $[U] != vi) break;
              $[U--] = 0, N = 1;
            }
        for (L = $.length; $[--L] === 0; $.pop()) ;
      }
      b.e > d ? b.c = b.e = null : b.e < u && (b.c = [b.e = 0]);
    }
    return b;
  }
  function A(b) {
    var T, R = b.e;
    return R === null ? b.toString() : (T = Ur(b.c), T = R <= l || R >= c ? Af(T, R) : uo(T, R, "0"), b.s < 0 ? "-" + T : T);
  }
  return i.absoluteValue = i.abs = function() {
    var b = new w(this);
    return b.s < 0 && (b.s = 1), b;
  }, i.comparedTo = function(b, T) {
    return Ks(this, new w(b, T));
  }, i.decimalPlaces = i.dp = function(b, T) {
    var R, B, O, L = this;
    if (b != null)
      return nn(b, 0, Pn), T == null ? T = a : nn(T, 0, 8), k(new w(L), b + L.e + 1, T);
    if (!(R = L.c)) return null;
    if (B = ((O = R.length - 1) - $r(this.e / dt)) * dt, O = R[O]) for (; O % 10 == 0; O /= 10, B--) ;
    return B < 0 && (B = 0), B;
  }, i.dividedBy = i.div = function(b, T) {
    return t(this, new w(b, T), s, a);
  }, i.dividedToIntegerBy = i.idiv = function(b, T) {
    return t(this, new w(b, T), 0, 1);
  }, i.exponentiatedBy = i.pow = function(b, T) {
    var R, B, O, L, V, N, M, U, F, $ = this;
    if (b = new w(b), b.c && !b.isInteger())
      throw Error(yr + "Exponent not an integer: " + A(b));
    if (T != null && (T = new w(T)), N = b.e > 14, !$.c || !$.c[0] || $.c[0] == 1 && !$.e && $.c.length == 1 || !b.c || !b.c[0])
      return F = new w(Math.pow(+A($), N ? b.s * (2 - Sf(b)) : +A(b))), T ? F.mod(T) : F;
    if (M = b.s < 0, T) {
      if (T.c ? !T.c[0] : !T.s) return new w(NaN);
      B = !M && $.isInteger() && T.isInteger(), B && ($ = $.mod(T));
    } else {
      if (b.e > 9 && ($.e > 0 || $.e < -1 || ($.e == 0 ? $.c[0] > 1 || N && $.c[1] >= 24e7 : $.c[0] < 8e13 || N && $.c[0] <= 9999975e7)))
        return L = $.s < 0 && Sf(b) ? -0 : 0, $.e > -1 && (L = 1 / L), new w(M ? 1 / L : L);
      p && (L = Mm(p / dt + 2));
    }
    for (N ? (R = new w(0.5), M && (b.s = 1), U = Sf(b)) : (O = Math.abs(+A(b)), U = O % 2), F = new w(o); ; ) {
      if (U) {
        if (F = F.times($), !F.c) break;
        L ? F.c.length > L && (F.c.length = L) : B && (F = F.mod(T));
      }
      if (O) {
        if (O = qr(O / 2), O === 0) break;
        U = O % 2;
      } else if (b = b.times(R), k(b, b.e + 1, 1), b.e > 14)
        U = Sf(b);
      else {
        if (O = +A(b), O === 0) break;
        U = O % 2;
      }
      $ = $.times($), L ? $.c && $.c.length > L && ($.c.length = L) : B && ($ = $.mod(T));
    }
    return B ? F : (M && (F = o.div(F)), T ? F.mod(T) : L ? k(F, p, a, V) : F);
  }, i.integerValue = function(b) {
    var T = new w(this);
    return b == null ? b = a : nn(b, 0, 8), k(T, T.e + 1, b);
  }, i.isEqualTo = i.eq = function(b, T) {
    return Ks(this, new w(b, T)) === 0;
  }, i.isFinite = function() {
    return !!this.c;
  }, i.isGreaterThan = i.gt = function(b, T) {
    return Ks(this, new w(b, T)) > 0;
  }, i.isGreaterThanOrEqualTo = i.gte = function(b, T) {
    return (T = Ks(this, new w(b, T))) === 1 || T === 0;
  }, i.isInteger = function() {
    return !!this.c && $r(this.e / dt) > this.c.length - 2;
  }, i.isLessThan = i.lt = function(b, T) {
    return Ks(this, new w(b, T)) < 0;
  }, i.isLessThanOrEqualTo = i.lte = function(b, T) {
    return (T = Ks(this, new w(b, T))) === -1 || T === 0;
  }, i.isNaN = function() {
    return !this.s;
  }, i.isNegative = function() {
    return this.s < 0;
  }, i.isPositive = function() {
    return this.s > 0;
  }, i.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, i.minus = function(b, T) {
    var R, B, O, L, V = this, N = V.s;
    if (b = new w(b, T), T = b.s, !N || !T) return new w(NaN);
    if (N != T)
      return b.s = -T, V.plus(b);
    var M = V.e / dt, U = b.e / dt, F = V.c, $ = b.c;
    if (!M || !U) {
      if (!F || !$) return F ? (b.s = -T, b) : new w($ ? V : NaN);
      if (!F[0] || !$[0])
        return $[0] ? (b.s = -T, b) : new w(F[0] ? V : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          a == 3 ? -0 : 0
        ));
    }
    if (M = $r(M), U = $r(U), F = F.slice(), N = M - U) {
      for ((L = N < 0) ? (N = -N, O = F) : (U = M, O = $), O.reverse(), T = N; T--; O.push(0)) ;
      O.reverse();
    } else
      for (B = (L = (N = F.length) < (T = $.length)) ? N : T, N = T = 0; T < B; T++)
        if (F[T] != $[T]) {
          L = F[T] < $[T];
          break;
        }
    if (L && (O = F, F = $, $ = O, b.s = -b.s), T = (B = $.length) - (R = F.length), T > 0) for (; T--; F[R++] = 0) ;
    for (T = vi - 1; B > N; ) {
      if (F[--B] < $[B]) {
        for (R = B; R && !F[--R]; F[R] = T) ;
        --F[R], F[B] += vi;
      }
      F[B] -= $[B];
    }
    for (; F[0] == 0; F.splice(0, 1), --U) ;
    return F[0] ? S(b, F, U) : (b.s = a == 3 ? -1 : 1, b.c = [b.e = 0], b);
  }, i.modulo = i.mod = function(b, T) {
    var R, B, O = this;
    return b = new w(b, T), !O.c || !b.s || b.c && !b.c[0] ? new w(NaN) : !b.c || O.c && !O.c[0] ? new w(O) : (h == 9 ? (B = b.s, b.s = 1, R = t(O, b, 0, 3), b.s = B, R.s *= B) : R = t(O, b, 0, h), b = O.minus(R.times(b)), !b.c[0] && h == 1 && (b.s = O.s), b);
  }, i.multipliedBy = i.times = function(b, T) {
    var R, B, O, L, V, N, M, U, F, $, ie, he, ae, se, oe, ye = this, ve = ye.c, Be = (b = new w(b, T)).c;
    if (!ve || !Be || !ve[0] || !Be[0])
      return !ye.s || !b.s || ve && !ve[0] && !Be || Be && !Be[0] && !ve ? b.c = b.e = b.s = null : (b.s *= ye.s, !ve || !Be ? b.c = b.e = null : (b.c = [0], b.e = 0)), b;
    for (B = $r(ye.e / dt) + $r(b.e / dt), b.s *= ye.s, M = ve.length, $ = Be.length, M < $ && (ae = ve, ve = Be, Be = ae, O = M, M = $, $ = O), O = M + $, ae = []; O--; ae.push(0)) ;
    for (se = vi, oe = Yo, O = $; --O >= 0; ) {
      for (R = 0, ie = Be[O] % oe, he = Be[O] / oe | 0, V = M, L = O + V; L > O; )
        U = ve[--V] % oe, F = ve[V] / oe | 0, N = he * U + F * ie, U = ie * U + N % oe * oe + ae[L] + R, R = (U / se | 0) + (N / oe | 0) + he * F, ae[L--] = U % se;
      ae[L] = R;
    }
    return R ? ++B : ae.splice(0, 1), S(b, ae, B);
  }, i.negated = function() {
    var b = new w(this);
    return b.s = -b.s || null, b;
  }, i.plus = function(b, T) {
    var R, B = this, O = B.s;
    if (b = new w(b, T), T = b.s, !O || !T) return new w(NaN);
    if (O != T)
      return b.s = -T, B.minus(b);
    var L = B.e / dt, V = b.e / dt, N = B.c, M = b.c;
    if (!L || !V) {
      if (!N || !M) return new w(O / 0);
      if (!N[0] || !M[0]) return M[0] ? b : new w(N[0] ? B : O * 0);
    }
    if (L = $r(L), V = $r(V), N = N.slice(), O = L - V) {
      for (O > 0 ? (V = L, R = M) : (O = -O, R = N), R.reverse(); O--; R.push(0)) ;
      R.reverse();
    }
    for (O = N.length, T = M.length, O - T < 0 && (R = M, M = N, N = R, T = O), O = 0; T; )
      O = (N[--T] = N[T] + M[T] + O) / vi | 0, N[T] = vi === N[T] ? 0 : N[T] % vi;
    return O && (N = [O].concat(N), ++V), S(b, N, V);
  }, i.precision = i.sd = function(b, T) {
    var R, B, O, L = this;
    if (b != null && b !== !!b)
      return nn(b, 1, Pn), T == null ? T = a : nn(T, 0, 8), k(new w(L), b, T);
    if (!(R = L.c)) return null;
    if (O = R.length - 1, B = O * dt + 1, O = R[O]) {
      for (; O % 10 == 0; O /= 10, B--) ;
      for (O = R[0]; O >= 10; O /= 10, B++) ;
    }
    return b && L.e + 1 > B && (B = L.e + 1), B;
  }, i.shiftedBy = function(b) {
    return nn(b, -Fm, Fm), this.times("1e" + b);
  }, i.squareRoot = i.sqrt = function() {
    var b, T, R, B, O, L = this, V = L.c, N = L.s, M = L.e, U = s + 4, F = new w("0.5");
    if (N !== 1 || !V || !V[0])
      return new w(!N || N < 0 && (!V || V[0]) ? NaN : V ? L : 1 / 0);
    if (N = Math.sqrt(+A(L)), N == 0 || N == 1 / 0 ? (T = Ur(V), (T.length + M) % 2 == 0 && (T += "0"), N = Math.sqrt(+T), M = $r((M + 1) / 2) - (M < 0 || M % 2), N == 1 / 0 ? T = "5e" + M : (T = N.toExponential(), T = T.slice(0, T.indexOf("e") + 1) + M), R = new w(T)) : R = new w(N + ""), R.c[0]) {
      for (M = R.e, N = M + U, N < 3 && (N = 0); ; )
        if (O = R, R = F.times(O.plus(t(L, O, U, 1))), Ur(O.c).slice(0, N) === (T = Ur(R.c)).slice(0, N))
          if (R.e < M && --N, T = T.slice(N - 3, N + 1), T == "9999" || !B && T == "4999") {
            if (!B && (k(O, O.e + s + 2, 0), O.times(O).eq(L))) {
              R = O;
              break;
            }
            U += 4, N += 4, B = 1;
          } else {
            (!+T || !+T.slice(1) && T.charAt(0) == "5") && (k(R, R.e + s + 2, 1), b = !R.times(R).eq(L));
            break;
          }
    }
    return k(R, R.e + s + 1, a, b);
  }, i.toExponential = function(b, T) {
    return b != null && (nn(b, 0, Pn), b++), x(this, b, T, 1);
  }, i.toFixed = function(b, T) {
    return b != null && (nn(b, 0, Pn), b = b + this.e + 1), x(this, b, T);
  }, i.toFormat = function(b, T, R) {
    var B, O = this;
    if (R == null)
      b != null && T && typeof T == "object" ? (R = T, T = null) : b && typeof b == "object" ? (R = b, b = T = null) : R = m;
    else if (typeof R != "object")
      throw Error(yr + "Argument not an object: " + R);
    if (B = O.toFixed(b, T), O.c) {
      var L, V = B.split("."), N = +R.groupSize, M = +R.secondaryGroupSize, U = R.groupSeparator || "", F = V[0], $ = V[1], ie = O.s < 0, he = ie ? F.slice(1) : F, ae = he.length;
      if (M && (L = N, N = M, M = L, ae -= L), N > 0 && ae > 0) {
        for (L = ae % N || N, F = he.substr(0, L); L < ae; L += N) F += U + he.substr(L, N);
        M > 0 && (F += U + he.slice(L)), ie && (F = "-" + F);
      }
      B = $ ? F + (R.decimalSeparator || "") + ((M = +R.fractionGroupSize) ? $.replace(
        new RegExp("\\d{" + M + "}\\B", "g"),
        "$&" + (R.fractionGroupSeparator || "")
      ) : $) : F;
    }
    return (R.prefix || "") + B + (R.suffix || "");
  }, i.toFraction = function(b) {
    var T, R, B, O, L, V, N, M, U, F, $, ie, he = this, ae = he.c;
    if (b != null && (N = new w(b), !N.isInteger() && (N.c || N.s !== 1) || N.lt(o)))
      throw Error(yr + "Argument " + (N.isInteger() ? "out of range: " : "not an integer: ") + A(N));
    if (!ae) return new w(he);
    for (T = new w(o), U = R = new w(o), B = M = new w(o), ie = Ur(ae), L = T.e = ie.length - he.e - 1, T.c[0] = Lm[(V = L % dt) < 0 ? dt + V : V], b = !b || N.comparedTo(T) > 0 ? L > 0 ? T : U : N, V = d, d = 1 / 0, N = new w(ie), M.c[0] = 0; F = t(N, T, 0, 1), O = R.plus(F.times(B)), O.comparedTo(b) != 1; )
      R = B, B = O, U = M.plus(F.times(O = U)), M = O, T = N.minus(F.times(O = T)), N = O;
    return O = t(b.minus(R), B, 0, 1), M = M.plus(O.times(U)), R = R.plus(O.times(B)), M.s = U.s = he.s, L = L * 2, $ = t(U, B, L, a).minus(he).abs().comparedTo(
      t(M, R, L, a).minus(he).abs()
    ) < 1 ? [U, B] : [M, R], d = V, $;
  }, i.toNumber = function() {
    return +A(this);
  }, i.toPrecision = function(b, T) {
    return b != null && nn(b, 1, Pn), x(this, b, T, 2);
  }, i.toString = function(b) {
    var T, R = this, B = R.s, O = R.e;
    return O === null ? B ? (T = "Infinity", B < 0 && (T = "-" + T)) : T = "NaN" : (b == null ? T = O <= l || O >= c ? Af(Ur(R.c), O) : uo(Ur(R.c), O, "0") : b === 10 && v ? (R = k(new w(R), s + O + 1, a), T = uo(Ur(R.c), R.e, "0")) : (nn(b, 2, g.length, "Base"), T = n(uo(Ur(R.c), O, "0"), 10, b, B, !0)), B < 0 && R.c[0] && (T = "-" + T)), T;
  }, i.valueOf = i.toJSON = function() {
    return A(this);
  }, i._isBigNumber = !0, i[Symbol.toStringTag] = "BigNumber", i[Symbol.for("nodejs.util.inspect.custom")] = i.valueOf, e != null && w.set(e), w;
}
function $r(e) {
  var t = e | 0;
  return e > 0 || e === t ? t : t - 1;
}
function Ur(e) {
  for (var t, n, r = 1, i = e.length, o = e[0] + ""; r < i; ) {
    for (t = e[r++] + "", n = dt - t.length; n--; t = "0" + t) ;
    o += t;
  }
  for (i = o.length; o.charCodeAt(--i) === 48; ) ;
  return o.slice(0, i + 1 || 1);
}
function Ks(e, t) {
  var n, r, i = e.c, o = t.c, s = e.s, a = t.s, l = e.e, c = t.e;
  if (!s || !a) return null;
  if (n = i && !i[0], r = o && !o[0], n || r) return n ? r ? 0 : -a : s;
  if (s != a) return s;
  if (n = s < 0, r = l == c, !i || !o) return r ? 0 : !i ^ n ? 1 : -1;
  if (!r) return l > c ^ n ? 1 : -1;
  for (a = (l = i.length) < (c = o.length) ? l : c, s = 0; s < a; s++) if (i[s] != o[s]) return i[s] > o[s] ^ n ? 1 : -1;
  return l == c ? 0 : l > c ^ n ? 1 : -1;
}
function nn(e, t, n, r) {
  if (e < t || e > n || e !== qr(e))
    throw Error(yr + (r || "Argument") + (typeof e == "number" ? e < t || e > n ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(e));
}
function Sf(e) {
  var t = e.c.length - 1;
  return $r(e.e / dt) == t && e.c[t] % 2 != 0;
}
function Af(e, t) {
  return (e.length > 1 ? e.charAt(0) + "." + e.slice(1) : e) + (t < 0 ? "e" : "e+") + t;
}
function uo(e, t, n) {
  var r, i;
  if (t < 0) {
    for (i = n + "."; ++t; i += n) ;
    e = i + e;
  } else if (r = e.length, ++t > r) {
    for (i = n, t -= r; --t; i += n) ;
    e += i;
  } else t < r && (e = e.slice(0, t) + "." + e.slice(t));
  return e;
}
var Re = _2();
const hbe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BigNumber: Re,
  default: Re
}, Symbol.toStringTag, { value: "Module" })), ik = "https://assets.stakek.it", Vt = {
  appName: "StakeKit",
  appIcon: `${ik}/stakekit/sk-icon_320x320.png`,
  appUrl: "https://stakek.it",
  currency: "USD",
  queryClient: {
    staleTime: 1e3 * 5,
    cacheTime: 1e3 * 60 * 5
  },
  walletConnectV2: {
    projectId: "10a5257c04d1d3097ff768a139c95f50"
  },
  appPrefix: "sk-widget",
  env: {
    apiUrl: "https://api.stakek.it/",
    isTestMode: !1,
    isDevMode: !1,
    forceAddress: void 0
  },
  assetsUrl: ik,
  zerion: {
    tracking: "2cbed59baa70c46f7cadef7b05eb1bc3",
    iconsByAddress: "https://token-icons.s3.amazonaws.com/",
    iconsByNetwork: "https://chain-icons.s3.amazonaws.com/"
  }
}, Tn = G.fromNullable(
  typeof window > "u" ? null : window
);
Re.config({
  FORMAT: {
    prefix: "",
    decimalSeparator: ".",
    groupSeparator: ",",
    groupSize: 3,
    secondaryGroupSize: 0,
    fractionGroupSeparator: " ",
    fractionGroupSize: 0,
    suffix: ""
  }
});
const Sn = (e, t) => Je(Re(e)).map(
  (n) => t ? n.decimalPlaces(t, Re.ROUND_DOWN) : n
).map((n) => n.toFormat()).unsafeCoerce(), Xn = (e) => Sn(e, 6), Kv = (e) => (e * 100).toFixed(2), Um = ["#6B69D6", "#F1C40F", "#1ABC9C", "#E74C3C"], pL = (e) => {
  const t = e.charCodeAt(0);
  return Um[t % Um.length] ?? Um[0];
}, pbe = () => Tn.map((e) => e.parent !== e).orDefault(!1), Pd = /* @__PURE__ */ (() => {
  let e = null;
  return () => typeof e == "boolean" ? e : Tn.map((t) => {
    try {
      e = !!new URLSearchParams(t.self.location.search).get("embed");
    } catch {
      e = !1;
    }
    return !!e;
  }).orDefault(!1);
})(), hs = (e) => `${Vt.assetsUrl}/networks/${e}.svg`, Fa = (e) => `${Vt.assetsUrl}/tokens/${e}.svg`, I2 = (e) => new Promise((t) => setTimeout(t, e)), Bp = (e) => Object.fromEntries(e), Np = (e) => Object.entries(e);
function Uh(e, t) {
  const n = (t == null ? void 0 : t.leadingChars) ?? 4, r = (t == null ? void 0 : t.trailingChars) ?? 4;
  return e.length < n + r ? e : `${e.substring(0, n)}…${e.substring(
    e.length - r
  )}`;
}
const yL = () => {
  let e = !1;
  const t = () => {
    try {
      return typeof window > "u" ? !1 : (document.createEvent("TouchEvent"), !0);
    } catch {
      return !1;
    }
  };
  return e = typeof window > "u" ? !1 : !!(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(
    navigator.userAgent
  ) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(
    navigator.userAgent.substring(0, 4)
  ) || t()), e;
}, mL = (e, t) => t.multipliedBy(e).dividedBy(1e4), gL = (e) => Re(e).dividedBy(100).toNumber(), vL = (e, t) => {
  const n = /* @__PURE__ */ new Date(), r = new Date(n);
  r.setDate(n.getDate() - 1);
  const i = (c) => c.toLocaleDateString(t.language, {
    year: "numeric",
    month: "long",
    day: "numeric"
  }), o = {}, s = {};
  e.forEach((c) => {
    const u = new Date(c);
    let d;
    u.toDateString() === n.toDateString() ? d = "today" : u.toDateString() === r.toDateString() ? d = "yesterday" : d = i(u), s[d] ? s[d]++ : (s[d] = 1, o[d] = d);
  });
  const a = Object.values(o), l = Object.values(s);
  return [a, l];
}, bL = (e) => {
  var t, n;
  return !!(_o(e) && e.response && ((t = e.response) == null ? void 0 : t.status) >= 400 && ((n = e.response) == null ? void 0 : n.status) < 500);
}, Yv = (e) => {
  var t;
  return !!((t = e.response) != null && t.status && e.response.status >= 500);
}, wL = ({
  error: e,
  retryCount: t,
  retryTimes: n
}) => _o(e) && Yv(e) && t < n, Kn = ({
  fn: e,
  retryTimes: t = 2,
  shouldRetry: n,
  retryWaitForMs: r
}) => {
  let i = 0;
  return de(async () => {
    try {
      return await e();
    } catch (s) {
      let a = s;
      for (; (n == null ? void 0 : n(s, i)) ?? wL({ error: a, retryCount: i, retryTimes: t }); )
        try {
          return await I2((r == null ? void 0 : r()) ?? 2 ** (i + 1) * 1e3), await e();
        } catch (l) {
          a = l, i++;
        }
      throw a;
    }
  });
};
var Gi = {
  CANCELED: "CANCELED",
  CREATED: "CREATED",
  WAITING_FOR_NEXT: "WAITING_FOR_NEXT",
  PROCESSING: "PROCESSING",
  FAILED: "FAILED",
  SUCCESS: "SUCCESS"
}, oa = {
  STAKE: "STAKE",
  UNSTAKE: "UNSTAKE",
  CLAIM_REWARDS: "CLAIM_REWARDS",
  RESTAKE_REWARDS: "RESTAKE_REWARDS",
  WITHDRAW: "WITHDRAW",
  RESTAKE: "RESTAKE",
  CLAIM_UNSTAKED: "CLAIM_UNSTAKED",
  UNLOCK_LOCKED: "UNLOCK_LOCKED",
  STAKE_LOCKED: "STAKE_LOCKED",
  VOTE: "VOTE",
  REVOKE: "REVOKE",
  VOTE_LOCKED: "VOTE_LOCKED",
  REVOTE: "REVOTE",
  REBOND: "REBOND",
  MIGRATE: "MIGRATE"
}, xL = {
  GEO_LOCATION: "GEO_LOCATION"
}, ok = {
  NOT_FOUND: "NOT_FOUND",
  CREATED: "CREATED",
  BLOCKED: "BLOCKED",
  WAITING_FOR_SIGNATURE: "WAITING_FOR_SIGNATURE",
  SIGNED: "SIGNED",
  BROADCASTED: "BROADCASTED",
  PENDING: "PENDING",
  CONFIRMED: "CONFIRMED",
  FAILED: "FAILED",
  SKIPPED: "SKIPPED"
}, R2 = Ge(void 0), CL = ({
  children: e,
  ...t
}) => /* @__PURE__ */ y.jsx(R2.Provider, { value: t, children: e }), kL = () => {
  const e = we(R2);
  if (!e)
    throw new Error("ApiClient must be used within a ApiHooksProvider");
  return e;
}, EL = "https://api.stakek.it/", SL = ({
  baseURL: e,
  path: t,
  params: n
}) => {
  const r = new URL(e);
  if (r.pathname = t, n) {
    const i = new URLSearchParams();
    Object.keys(n).forEach((o) => {
      const s = n[o];
      s == null || s === "" || i.append(o, n[o]);
    }), r.search = i.toString();
  }
  return r.toString();
}, Wt = () => {
  const {
    fetchInstance: e,
    apiKey: t,
    baseURL: n = EL
  } = kL();
  return ({
    url: r,
    data: i,
    method: o,
    params: s,
    headers: a,
    signal: l
  }) => e(SL({ baseURL: n, path: r, params: s }), {
    method: o,
    data: i,
    headers: { ...a, "X-API-KEY": t },
    signal: l
  });
}, AL = () => {
  const e = Wt();
  return (t) => e({ url: "/v2/health", method: "GET", signal: t });
}, TL = () => ["/v2/health"], _L = (e) => {
  const { query: t } = e ?? {}, n = (t == null ? void 0 : t.queryKey) ?? TL(), r = AL();
  return { queryKey: n, queryFn: ({ signal: o }) => r(o), ...t };
}, IL = (e) => {
  const t = _L(e), n = Ut(t);
  return n.queryKey = t.queryKey, n;
}, RL = () => {
  const e = Wt();
  return (t) => e({
    url: "/v1/actions/enter",
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: t
  });
}, PL = () => {
  const e = Wt();
  return (t) => e({
    url: "/v1/actions/exit",
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: t
  });
}, OL = () => {
  const e = Wt();
  return (t) => e({
    url: "/v1/actions/pending",
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: t
  });
}, BL = () => {
  const e = Wt();
  return (t) => e({
    url: "/v1/actions/enter/estimate-gas",
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: t
  });
}, NL = (e) => [
  "/v1/actions/enter/estimate-gas",
  e
], DL = (e, t) => {
  const { query: n } = t ?? {}, r = (n == null ? void 0 : n.queryKey) ?? NL(e), i = BL();
  return { queryKey: r, queryFn: () => i(e), ...n };
}, jL = (e, t) => {
  const n = DL(
    e,
    t
  ), r = Ut(n);
  return r.queryKey = n.queryKey, r;
}, ML = () => {
  const e = Wt();
  return (t) => e({
    url: "/v1/actions/exit/estimate-gas",
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: t
  });
}, FL = (e) => [
  "/v1/actions/exit/estimate-gas",
  e
], LL = (e, t) => {
  const { query: n } = t ?? {}, r = (n == null ? void 0 : n.queryKey) ?? FL(e), i = ML();
  return { queryKey: r, queryFn: () => i(e), ...n };
}, UL = (e, t) => {
  const n = LL(
    e,
    t
  ), r = Ut(n);
  return r.queryKey = n.queryKey, r;
}, zL = () => {
  const e = Wt();
  return (t, n) => e({ url: "/v1/actions", method: "GET", params: t, signal: n });
}, VL = (e) => ["/v1/actions", ...e ? [e] : []], qL = () => {
  const e = Wt();
  return (t) => e({
    url: "/v1/actions/pending/estimate-gas",
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: t
  });
}, $L = (e) => [
  "/v1/actions/pending/estimate-gas",
  e
], WL = (e, t) => {
  const { query: n } = t ?? {}, r = (n == null ? void 0 : n.queryKey) ?? $L(e), i = qL();
  return { queryKey: r, queryFn: () => i(e), ...n };
}, GL = (e, t) => {
  const n = WL(
    e,
    t
  ), r = Ut(n);
  return r.queryKey = n.queryKey, r;
}, HL = () => {
  const e = Wt();
  return (t, n) => e({
    url: `/v1/transactions/${t}`,
    method: "GET",
    signal: n
  });
}, KL = () => {
  const e = Wt();
  return (t, n) => e({
    url: `/v1/transactions/${t}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: n
  });
}, YL = () => {
  const e = Wt();
  return (t, n) => e({
    url: `/v1/transactions/${t}/submit`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: n
  });
}, QL = () => {
  const e = Wt();
  return (t, n) => e({
    url: `/v1/transactions/${t}/submit_hash`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: n
  });
}, JL = () => {
  const e = Wt();
  return (t, n) => e({
    url: `/v1/transactions/${t}/status`,
    method: "GET",
    signal: n
  });
}, XL = () => {
  const e = Wt();
  return (t, n) => e({
    url: `/v1/transactions/gas/${t}`,
    method: "GET",
    signal: n
  });
}, ZL = () => {
  const e = Wt();
  return (t, n) => e({
    url: `/v1/transactions/verification/${t}`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: n
  });
}, Z0 = () => {
  const e = Wt();
  return (t, n) => e({ url: "/v1/tokens", method: "GET", params: t, signal: n });
}, P2 = (e) => ["/v1/tokens", ...e ? [e] : []], e7 = () => {
  const e = Wt();
  return (t) => e({
    url: "/v1/tokens/prices",
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: t
  });
}, t7 = (e) => ["/v1/tokens/prices", e], n7 = (e, t) => {
  const { query: n } = t ?? {}, r = (n == null ? void 0 : n.queryKey) ?? t7(e), i = e7();
  return { queryKey: r, queryFn: () => i(e), ...n };
}, r7 = (e, t) => {
  const n = n7(
    e,
    t
  ), r = Ut(n);
  return r.queryKey = n.queryKey, r;
}, i7 = () => {
  const e = Wt();
  return (t) => e({
    url: "/v1/tokens/balances",
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: t
  });
}, ew = () => {
  const e = Wt();
  return (t) => e({
    url: "/v1/tokens/balances/scan",
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: t
  });
}, tw = (e) => ["/v1/tokens/balances/scan", e], o7 = () => {
  const e = Wt();
  return (t) => e({
    url: "/v1/yields/balances/scan",
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: t
  });
}, nw = (e) => ["/v1/yields/balances/scan", e], s7 = (e, t) => {
  const { query: n } = t ?? {}, r = (n == null ? void 0 : n.queryKey) ?? nw(e), i = o7();
  return { queryKey: r, queryFn: () => i(e), ...n };
}, a7 = (e, t) => {
  const n = s7(
    e,
    t
  ), r = Ut(n);
  return r.queryKey = n.queryKey, r;
}, l7 = () => {
  const e = Wt();
  return (t) => e({
    url: "/v1/yields/enabled/networks",
    method: "GET",
    signal: t
  });
}, c7 = () => {
  const e = Wt();
  return (t, n) => e({
    url: "/v1/yields/validators",
    method: "GET",
    params: t,
    signal: n
  });
}, u7 = (e) => ["/v1/yields/validators", ...e ? [e] : []], d7 = (e, t) => {
  const { query: n } = t ?? {}, r = (n == null ? void 0 : n.queryKey) ?? u7(e), i = c7();
  return { queryKey: r, queryFn: ({ signal: s }) => i(e, s), ...n };
}, f7 = (e, t) => {
  const n = d7(e, t), r = Ut(n);
  return r.queryKey = n.queryKey, r;
}, Fs = () => {
  const e = Wt();
  return (t, n, r) => e({
    url: `/v1/yields/${t}`,
    method: "GET",
    params: n,
    signal: r
  });
}, h7 = () => {
  const e = Wt();
  return (t, n, r) => e({
    url: `/v1/yields/${t}/balances`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: n,
    params: r
  });
}, p7 = () => {
  const e = Wt();
  return (t, n) => e({
    url: `/v1/yields/${t}/fee-configuration`,
    method: "GET",
    signal: n
  });
}, y7 = (e) => [`/v1/yields/${e}/fee-configuration`], m7 = (e, t) => {
  const { query: n } = {}, r = (n == null ? void 0 : n.queryKey) ?? y7(e), i = p7();
  return {
    queryKey: r,
    queryFn: ({ signal: s }) => i(e, s),
    enabled: !!e,
    ...n
  };
}, rw = (e, t) => {
  const n = m7(
    e
  ), r = Ut(n);
  return r.queryKey = n.queryKey, r;
};
const hh = /* @__PURE__ */ new Map(), Qv = /* @__PURE__ */ new Map(), g7 = (e) => (Qv.set(e, e), () => {
  Qv.delete(e);
}), v7 = () => {
  Qv.forEach((e) => e());
}, b7 = () => {
  if (hh.size === 0) return Promise.resolve();
  let e;
  return new Promise((t) => {
    e = g7(() => t(null));
  }).then(() => e());
}, w7 = (e) => e.interceptors.request.use(async (t) => (await b7(), t)), x7 = () => {
  const e = {};
  return hh.set(e, e), () => {
    hh.delete(e), hh.size === 0 && v7();
  };
};
let zh = !1;
const Jv = /* @__PURE__ */ new Map(), C7 = () => Jv.forEach((e) => e(zh)), k7 = (e) => (Jv.set(e, e), () => Jv.delete(e)), E7 = (e) => e.interceptors.response.use(void 0, (t) => {
  var n, r;
  if (((n = t == null ? void 0 : t.response) == null ? void 0 : n.status) === 403 && ((r = t.response.data) == null ? void 0 : r.type) === xL.GEO_LOCATION) {
    const i = t.response.data, o = i.regionCode ?? "";
    zh = {
      tags: new Set(i.tags ?? []),
      countryCode: i.countryCode ?? "",
      regionCode: o
    }, C7();
  }
  return Promise.reject(t);
}), S7 = () => Dr(
  Ie((e) => {
    const t = k7(e);
    return () => {
      t();
    };
  }, []),
  Ie(() => zh, []),
  Ie(() => zh, [])
);
var Xv = function(e, t) {
  return Xv = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i]);
  }, Xv(e, t);
};
function La(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  Xv(e, t);
  function n() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n());
}
var Jr = function() {
  return Jr = Object.assign || function(t) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, Jr.apply(this, arguments);
};
function Dp(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
}
function O2(e, t, n, r) {
  var i = arguments.length, o = i < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, n) : r, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(e, t, n, r);
  else for (var a = e.length - 1; a >= 0; a--) (s = e[a]) && (o = (i < 3 ? s(o) : i > 3 ? s(t, n, o) : s(t, n)) || o);
  return i > 3 && o && Object.defineProperty(t, n, o), o;
}
function B2(e, t) {
  return function(n, r) {
    t(n, r, e);
  };
}
function A7(e, t, n, r, i, o) {
  function s(v) {
    if (v !== void 0 && typeof v != "function") throw new TypeError("Function expected");
    return v;
  }
  for (var a = r.kind, l = a === "getter" ? "get" : a === "setter" ? "set" : "value", c = !t && e ? r.static ? e : e.prototype : null, u = t || (c ? Object.getOwnPropertyDescriptor(c, r.name) : {}), d, f = !1, h = n.length - 1; h >= 0; h--) {
    var p = {};
    for (var m in r) p[m] = m === "access" ? {} : r[m];
    for (var m in r.access) p.access[m] = r.access[m];
    p.addInitializer = function(v) {
      if (f) throw new TypeError("Cannot add initializers after decoration has completed");
      o.push(s(v || null));
    };
    var g = (0, n[h])(a === "accessor" ? { get: u.get, set: u.set } : u[l], p);
    if (a === "accessor") {
      if (g === void 0) continue;
      if (g === null || typeof g != "object") throw new TypeError("Object expected");
      (d = s(g.get)) && (u.get = d), (d = s(g.set)) && (u.set = d), (d = s(g.init)) && i.unshift(d);
    } else (d = s(g)) && (a === "field" ? i.unshift(d) : u[l] = d);
  }
  c && Object.defineProperty(c, r.name, u), f = !0;
}
function T7(e, t, n) {
  for (var r = arguments.length > 2, i = 0; i < t.length; i++)
    n = r ? t[i].call(e, n) : t[i].call(e);
  return r ? n : void 0;
}
function _7(e) {
  return typeof e == "symbol" ? e : "".concat(e);
}
function I7(e, t, n) {
  return typeof t == "symbol" && (t = t.description ? "[".concat(t.description, "]") : ""), Object.defineProperty(e, "name", { configurable: !0, value: n ? "".concat(n, " ", t) : t });
}
function N2(e, t) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(e, t);
}
function D2(e, t, n, r) {
  function i(o) {
    return o instanceof n ? o : new n(function(s) {
      s(o);
    });
  }
  return new (n || (n = Promise))(function(o, s) {
    function a(u) {
      try {
        c(r.next(u));
      } catch (d) {
        s(d);
      }
    }
    function l(u) {
      try {
        c(r.throw(u));
      } catch (d) {
        s(d);
      }
    }
    function c(u) {
      u.done ? o(u.value) : i(u.value).then(a, l);
    }
    c((r = r.apply(e, t || [])).next());
  });
}
function j2(e, t) {
  var n = { label: 0, sent: function() {
    if (o[0] & 1) throw o[1];
    return o[1];
  }, trys: [], ops: [] }, r, i, o, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(c) {
    return function(u) {
      return l([c, u]);
    };
  }
  function l(c) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; s && (s = 0, c[0] && (n = 0)), n; ) try {
      if (r = 1, i && (o = c[0] & 2 ? i.return : c[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) && !(o = o.call(i, c[1])).done) return o;
      switch (i = 0, o && (c = [c[0] & 2, o.value]), c[0]) {
        case 0:
        case 1:
          o = c;
          break;
        case 4:
          return n.label++, { value: c[1], done: !1 };
        case 5:
          n.label++, i = c[1], c = [0];
          continue;
        case 7:
          c = n.ops.pop(), n.trys.pop();
          continue;
        default:
          if (o = n.trys, !(o = o.length > 0 && o[o.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            n = 0;
            continue;
          }
          if (c[0] === 3 && (!o || c[1] > o[0] && c[1] < o[3])) {
            n.label = c[1];
            break;
          }
          if (c[0] === 6 && n.label < o[1]) {
            n.label = o[1], o = c;
            break;
          }
          if (o && n.label < o[2]) {
            n.label = o[2], n.ops.push(c);
            break;
          }
          o[2] && n.ops.pop(), n.trys.pop();
          continue;
      }
      c = t.call(e, n);
    } catch (u) {
      c = [6, u], i = 0;
    } finally {
      r = o = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}
var jp = Object.create ? function(e, t, n, r) {
  r === void 0 && (r = n);
  var i = Object.getOwnPropertyDescriptor(t, n);
  (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return t[n];
  } }), Object.defineProperty(e, r, i);
} : function(e, t, n, r) {
  r === void 0 && (r = n), e[r] = t[n];
};
function M2(e, t) {
  for (var n in e) n !== "default" && !Object.prototype.hasOwnProperty.call(t, n) && jp(t, e, n);
}
function Aa(e) {
  var t = typeof Symbol == "function" && Symbol.iterator, n = t && e[t], r = 0;
  if (n) return n.call(e);
  if (e && typeof e.length == "number") return {
    next: function() {
      return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e };
    }
  };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Gl(e, t) {
  var n = typeof Symbol == "function" && e[Symbol.iterator];
  if (!n) return e;
  var r = n.call(e), i, o = [], s;
  try {
    for (; (t === void 0 || t-- > 0) && !(i = r.next()).done; ) o.push(i.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      i && !i.done && (n = r.return) && n.call(r);
    } finally {
      if (s) throw s.error;
    }
  }
  return o;
}
function F2() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e = e.concat(Gl(arguments[t]));
  return e;
}
function L2() {
  for (var e = 0, t = 0, n = arguments.length; t < n; t++) e += arguments[t].length;
  for (var r = Array(e), i = 0, t = 0; t < n; t++)
    for (var o = arguments[t], s = 0, a = o.length; s < a; s++, i++)
      r[i] = o[s];
  return r;
}
function Hl(e, t, n) {
  if (n || arguments.length === 2) for (var r = 0, i = t.length, o; r < i; r++)
    (o || !(r in t)) && (o || (o = Array.prototype.slice.call(t, 0, r)), o[r] = t[r]);
  return e.concat(o || Array.prototype.slice.call(t));
}
function Kl(e) {
  return this instanceof Kl ? (this.v = e, this) : new Kl(e);
}
function U2(e, t, n) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(e, t || []), i, o = [];
  return i = {}, s("next"), s("throw"), s("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function s(f) {
    r[f] && (i[f] = function(h) {
      return new Promise(function(p, m) {
        o.push([f, h, p, m]) > 1 || a(f, h);
      });
    });
  }
  function a(f, h) {
    try {
      l(r[f](h));
    } catch (p) {
      d(o[0][3], p);
    }
  }
  function l(f) {
    f.value instanceof Kl ? Promise.resolve(f.value.v).then(c, u) : d(o[0][2], f);
  }
  function c(f) {
    a("next", f);
  }
  function u(f) {
    a("throw", f);
  }
  function d(f, h) {
    f(h), o.shift(), o.length && a(o[0][0], o[0][1]);
  }
}
function z2(e) {
  var t, n;
  return t = {}, r("next"), r("throw", function(i) {
    throw i;
  }), r("return"), t[Symbol.iterator] = function() {
    return this;
  }, t;
  function r(i, o) {
    t[i] = e[i] ? function(s) {
      return (n = !n) ? { value: Kl(e[i](s)), done: !1 } : o ? o(s) : s;
    } : o;
  }
}
function V2(e) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var t = e[Symbol.asyncIterator], n;
  return t ? t.call(e) : (e = typeof Aa == "function" ? Aa(e) : e[Symbol.iterator](), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function() {
    return this;
  }, n);
  function r(o) {
    n[o] = e[o] && function(s) {
      return new Promise(function(a, l) {
        s = e[o](s), i(a, l, s.done, s.value);
      });
    };
  }
  function i(o, s, a, l) {
    Promise.resolve(l).then(function(c) {
      o({ value: c, done: a });
    }, s);
  }
}
function q2(e, t) {
  return Object.defineProperty ? Object.defineProperty(e, "raw", { value: t }) : e.raw = t, e;
}
var R7 = Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
};
function $2(e) {
  if (e && e.__esModule) return e;
  var t = {};
  if (e != null) for (var n in e) n !== "default" && Object.prototype.hasOwnProperty.call(e, n) && jp(t, e, n);
  return R7(t, e), t;
}
function W2(e) {
  return e && e.__esModule ? e : { default: e };
}
function G2(e, t, n, r) {
  if (n === "a" && !r) throw new TypeError("Private accessor was defined without a getter");
  if (typeof t == "function" ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? r : n === "a" ? r.call(e) : r ? r.value : t.get(e);
}
function H2(e, t, n, r, i) {
  if (r === "m") throw new TypeError("Private method is not writable");
  if (r === "a" && !i) throw new TypeError("Private accessor was defined without a setter");
  if (typeof t == "function" ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return r === "a" ? i.call(e, n) : i ? i.value = n : t.set(e, n), n;
}
function K2(e, t) {
  if (t === null || typeof t != "object" && typeof t != "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof e == "function" ? t === e : e.has(t);
}
function Y2(e, t, n) {
  if (t != null) {
    if (typeof t != "object" && typeof t != "function") throw new TypeError("Object expected.");
    var r;
    if (n) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      r = t[Symbol.asyncDispose];
    }
    if (r === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      r = t[Symbol.dispose];
    }
    if (typeof r != "function") throw new TypeError("Object not disposable.");
    e.stack.push({ value: t, dispose: r, async: n });
  } else n && e.stack.push({ async: !0 });
  return t;
}
var P7 = typeof SuppressedError == "function" ? SuppressedError : function(e, t, n) {
  var r = new Error(n);
  return r.name = "SuppressedError", r.error = e, r.suppressed = t, r;
};
function Q2(e) {
  function t(r) {
    e.error = e.hasError ? new P7(r, e.error, "An error was suppressed during disposal.") : r, e.hasError = !0;
  }
  function n() {
    for (; e.stack.length; ) {
      var r = e.stack.pop();
      try {
        var i = r.dispose && r.dispose.call(r.value);
        if (r.async) return Promise.resolve(i).then(n, function(o) {
          return t(o), n();
        });
      } catch (o) {
        t(o);
      }
    }
    if (e.hasError) throw e.error;
  }
  return n();
}
const O7 = {
  __extends: La,
  __assign: Jr,
  __rest: Dp,
  __decorate: O2,
  __param: B2,
  __metadata: N2,
  __awaiter: D2,
  __generator: j2,
  __createBinding: jp,
  __exportStar: M2,
  __values: Aa,
  __read: Gl,
  __spread: F2,
  __spreadArrays: L2,
  __spreadArray: Hl,
  __await: Kl,
  __asyncGenerator: U2,
  __asyncDelegator: z2,
  __asyncValues: V2,
  __makeTemplateObject: q2,
  __importStar: $2,
  __importDefault: W2,
  __classPrivateFieldGet: G2,
  __classPrivateFieldSet: H2,
  __classPrivateFieldIn: K2,
  __addDisposableResource: Y2,
  __disposeResources: Q2
}, ybe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  __addDisposableResource: Y2,
  get __assign() {
    return Jr;
  },
  __asyncDelegator: z2,
  __asyncGenerator: U2,
  __asyncValues: V2,
  __await: Kl,
  __awaiter: D2,
  __classPrivateFieldGet: G2,
  __classPrivateFieldIn: K2,
  __classPrivateFieldSet: H2,
  __createBinding: jp,
  __decorate: O2,
  __disposeResources: Q2,
  __esDecorate: A7,
  __exportStar: M2,
  __extends: La,
  __generator: j2,
  __importDefault: W2,
  __importStar: $2,
  __makeTemplateObject: q2,
  __metadata: N2,
  __param: B2,
  __propKey: _7,
  __read: Gl,
  __rest: Dp,
  __runInitializers: T7,
  __setFunctionName: I7,
  __spread: F2,
  __spreadArray: Hl,
  __spreadArrays: L2,
  __values: Aa,
  default: O7
}, Symbol.toStringTag, { value: "Module" }));
function xo(e) {
  return typeof e == "function";
}
function J2(e) {
  var t = function(r) {
    Error.call(r), r.stack = new Error().stack;
  }, n = e(t);
  return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n;
}
var zm = J2(function(e) {
  return function(n) {
    e(this), this.message = n ? n.length + ` errors occurred during unsubscription:
` + n.map(function(r, i) {
      return i + 1 + ") " + r.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = n;
  };
});
function Zv(e, t) {
  if (e) {
    var n = e.indexOf(t);
    0 <= n && e.splice(n, 1);
  }
}
var Mp = function() {
  function e(t) {
    this.initialTeardown = t, this.closed = !1, this._parentage = null, this._finalizers = null;
  }
  return e.prototype.unsubscribe = function() {
    var t, n, r, i, o;
    if (!this.closed) {
      this.closed = !0;
      var s = this._parentage;
      if (s)
        if (this._parentage = null, Array.isArray(s))
          try {
            for (var a = Aa(s), l = a.next(); !l.done; l = a.next()) {
              var c = l.value;
              c.remove(this);
            }
          } catch (m) {
            t = { error: m };
          } finally {
            try {
              l && !l.done && (n = a.return) && n.call(a);
            } finally {
              if (t) throw t.error;
            }
          }
        else
          s.remove(this);
      var u = this.initialTeardown;
      if (xo(u))
        try {
          u();
        } catch (m) {
          o = m instanceof zm ? m.errors : [m];
        }
      var d = this._finalizers;
      if (d) {
        this._finalizers = null;
        try {
          for (var f = Aa(d), h = f.next(); !h.done; h = f.next()) {
            var p = h.value;
            try {
              sk(p);
            } catch (m) {
              o = o ?? [], m instanceof zm ? o = Hl(Hl([], Gl(o)), Gl(m.errors)) : o.push(m);
            }
          }
        } catch (m) {
          r = { error: m };
        } finally {
          try {
            h && !h.done && (i = f.return) && i.call(f);
          } finally {
            if (r) throw r.error;
          }
        }
      }
      if (o)
        throw new zm(o);
    }
  }, e.prototype.add = function(t) {
    var n;
    if (t && t !== this)
      if (this.closed)
        sk(t);
      else {
        if (t instanceof e) {
          if (t.closed || t._hasParent(this))
            return;
          t._addParent(this);
        }
        (this._finalizers = (n = this._finalizers) !== null && n !== void 0 ? n : []).push(t);
      }
  }, e.prototype._hasParent = function(t) {
    var n = this._parentage;
    return n === t || Array.isArray(n) && n.includes(t);
  }, e.prototype._addParent = function(t) {
    var n = this._parentage;
    this._parentage = Array.isArray(n) ? (n.push(t), n) : n ? [n, t] : t;
  }, e.prototype._removeParent = function(t) {
    var n = this._parentage;
    n === t ? this._parentage = null : Array.isArray(n) && Zv(n, t);
  }, e.prototype.remove = function(t) {
    var n = this._finalizers;
    n && Zv(n, t), t instanceof e && t._removeParent(this);
  }, e.EMPTY = function() {
    var t = new e();
    return t.closed = !0, t;
  }(), e;
}(), X2 = Mp.EMPTY;
function Z2(e) {
  return e instanceof Mp || e && "closed" in e && xo(e.remove) && xo(e.add) && xo(e.unsubscribe);
}
function sk(e) {
  xo(e) ? e() : e.unsubscribe();
}
var eT = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: !1,
  useDeprecatedNextContext: !1
}, tT = {
  setTimeout: function(e, t) {
    for (var n = [], r = 2; r < arguments.length; r++)
      n[r - 2] = arguments[r];
    return setTimeout.apply(void 0, Hl([e, t], Gl(n)));
  },
  clearTimeout: function(e) {
    var t = tT.delegate;
    return ((t == null ? void 0 : t.clearTimeout) || clearTimeout)(e);
  },
  delegate: void 0
};
function B7(e) {
  tT.setTimeout(function() {
    throw e;
  });
}
function ak() {
}
function ph(e) {
  e();
}
var nT = function(e) {
  La(t, e);
  function t(n) {
    var r = e.call(this) || this;
    return r.isStopped = !1, n ? (r.destination = n, Z2(n) && n.add(r)) : r.destination = M7, r;
  }
  return t.create = function(n, r, i) {
    return new eb(n, r, i);
  }, t.prototype.next = function(n) {
    this.isStopped || this._next(n);
  }, t.prototype.error = function(n) {
    this.isStopped || (this.isStopped = !0, this._error(n));
  }, t.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, t.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, e.prototype.unsubscribe.call(this), this.destination = null);
  }, t.prototype._next = function(n) {
    this.destination.next(n);
  }, t.prototype._error = function(n) {
    try {
      this.destination.error(n);
    } finally {
      this.unsubscribe();
    }
  }, t.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, t;
}(Mp), N7 = Function.prototype.bind;
function Vm(e, t) {
  return N7.call(e, t);
}
var D7 = function() {
  function e(t) {
    this.partialObserver = t;
  }
  return e.prototype.next = function(t) {
    var n = this.partialObserver;
    if (n.next)
      try {
        n.next(t);
      } catch (r) {
        Tf(r);
      }
  }, e.prototype.error = function(t) {
    var n = this.partialObserver;
    if (n.error)
      try {
        n.error(t);
      } catch (r) {
        Tf(r);
      }
    else
      Tf(t);
  }, e.prototype.complete = function() {
    var t = this.partialObserver;
    if (t.complete)
      try {
        t.complete();
      } catch (n) {
        Tf(n);
      }
  }, e;
}(), eb = function(e) {
  La(t, e);
  function t(n, r, i) {
    var o = e.call(this) || this, s;
    if (xo(n) || !n)
      s = {
        next: n ?? void 0,
        error: r ?? void 0,
        complete: i ?? void 0
      };
    else {
      var a;
      o && eT.useDeprecatedNextContext ? (a = Object.create(n), a.unsubscribe = function() {
        return o.unsubscribe();
      }, s = {
        next: n.next && Vm(n.next, a),
        error: n.error && Vm(n.error, a),
        complete: n.complete && Vm(n.complete, a)
      }) : s = n;
    }
    return o.destination = new D7(s), o;
  }
  return t;
}(nT);
function Tf(e) {
  B7(e);
}
function j7(e) {
  throw e;
}
var M7 = {
  closed: !0,
  next: ak,
  error: j7,
  complete: ak
}, F7 = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function L7(e) {
  return e;
}
function U7(e) {
  return e.length === 0 ? L7 : e.length === 1 ? e[0] : function(n) {
    return e.reduce(function(r, i) {
      return i(r);
    }, n);
  };
}
var lk = function() {
  function e(t) {
    t && (this._subscribe = t);
  }
  return e.prototype.lift = function(t) {
    var n = new e();
    return n.source = this, n.operator = t, n;
  }, e.prototype.subscribe = function(t, n, r) {
    var i = this, o = V7(t) ? t : new eb(t, n, r);
    return ph(function() {
      var s = i, a = s.operator, l = s.source;
      o.add(a ? a.call(o, l) : l ? i._subscribe(o) : i._trySubscribe(o));
    }), o;
  }, e.prototype._trySubscribe = function(t) {
    try {
      return this._subscribe(t);
    } catch (n) {
      t.error(n);
    }
  }, e.prototype.forEach = function(t, n) {
    var r = this;
    return n = ck(n), new n(function(i, o) {
      var s = new eb({
        next: function(a) {
          try {
            t(a);
          } catch (l) {
            o(l), s.unsubscribe();
          }
        },
        error: o,
        complete: i
      });
      r.subscribe(s);
    });
  }, e.prototype._subscribe = function(t) {
    var n;
    return (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(t);
  }, e.prototype[F7] = function() {
    return this;
  }, e.prototype.pipe = function() {
    for (var t = [], n = 0; n < arguments.length; n++)
      t[n] = arguments[n];
    return U7(t)(this);
  }, e.prototype.toPromise = function(t) {
    var n = this;
    return t = ck(t), new t(function(r, i) {
      var o;
      n.subscribe(function(s) {
        return o = s;
      }, function(s) {
        return i(s);
      }, function() {
        return r(o);
      });
    });
  }, e.create = function(t) {
    return new e(t);
  }, e;
}();
function ck(e) {
  var t;
  return (t = e ?? eT.Promise) !== null && t !== void 0 ? t : Promise;
}
function z7(e) {
  return e && xo(e.next) && xo(e.error) && xo(e.complete);
}
function V7(e) {
  return e && e instanceof nT || z7(e) && Z2(e);
}
var q7 = J2(function(e) {
  return function() {
    e(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
  };
}), rT = function(e) {
  La(t, e);
  function t() {
    var n = e.call(this) || this;
    return n.closed = !1, n.currentObservers = null, n.observers = [], n.isStopped = !1, n.hasError = !1, n.thrownError = null, n;
  }
  return t.prototype.lift = function(n) {
    var r = new uk(this, this);
    return r.operator = n, r;
  }, t.prototype._throwIfClosed = function() {
    if (this.closed)
      throw new q7();
  }, t.prototype.next = function(n) {
    var r = this;
    ph(function() {
      var i, o;
      if (r._throwIfClosed(), !r.isStopped) {
        r.currentObservers || (r.currentObservers = Array.from(r.observers));
        try {
          for (var s = Aa(r.currentObservers), a = s.next(); !a.done; a = s.next()) {
            var l = a.value;
            l.next(n);
          }
        } catch (c) {
          i = { error: c };
        } finally {
          try {
            a && !a.done && (o = s.return) && o.call(s);
          } finally {
            if (i) throw i.error;
          }
        }
      }
    });
  }, t.prototype.error = function(n) {
    var r = this;
    ph(function() {
      if (r._throwIfClosed(), !r.isStopped) {
        r.hasError = r.isStopped = !0, r.thrownError = n;
        for (var i = r.observers; i.length; )
          i.shift().error(n);
      }
    });
  }, t.prototype.complete = function() {
    var n = this;
    ph(function() {
      if (n._throwIfClosed(), !n.isStopped) {
        n.isStopped = !0;
        for (var r = n.observers; r.length; )
          r.shift().complete();
      }
    });
  }, t.prototype.unsubscribe = function() {
    this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;
  }, Object.defineProperty(t.prototype, "observed", {
    get: function() {
      var n;
      return ((n = this.observers) === null || n === void 0 ? void 0 : n.length) > 0;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._trySubscribe = function(n) {
    return this._throwIfClosed(), e.prototype._trySubscribe.call(this, n);
  }, t.prototype._subscribe = function(n) {
    return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n);
  }, t.prototype._innerSubscribe = function(n) {
    var r = this, i = this, o = i.hasError, s = i.isStopped, a = i.observers;
    return o || s ? X2 : (this.currentObservers = null, a.push(n), new Mp(function() {
      r.currentObservers = null, Zv(a, n);
    }));
  }, t.prototype._checkFinalizedStatuses = function(n) {
    var r = this, i = r.hasError, o = r.thrownError, s = r.isStopped;
    i ? n.error(o) : s && n.complete();
  }, t.prototype.asObservable = function() {
    var n = new lk();
    return n.source = this, n;
  }, t.create = function(n, r) {
    return new uk(n, r);
  }, t;
}(lk), uk = function(e) {
  La(t, e);
  function t(n, r) {
    var i = e.call(this) || this;
    return i.destination = n, i.source = r, i;
  }
  return t.prototype.next = function(n) {
    var r, i;
    (i = (r = this.destination) === null || r === void 0 ? void 0 : r.next) === null || i === void 0 || i.call(r, n);
  }, t.prototype.error = function(n) {
    var r, i;
    (i = (r = this.destination) === null || r === void 0 ? void 0 : r.error) === null || i === void 0 || i.call(r, n);
  }, t.prototype.complete = function() {
    var n, r;
    (r = (n = this.destination) === null || n === void 0 ? void 0 : n.complete) === null || r === void 0 || r.call(n);
  }, t.prototype._subscribe = function(n) {
    var r, i;
    return (i = (r = this.source) === null || r === void 0 ? void 0 : r.subscribe(n)) !== null && i !== void 0 ? i : X2;
  }, t;
}(rT), Ua = function(e) {
  La(t, e);
  function t(n) {
    var r = e.call(this) || this;
    return r._value = n, r;
  }
  return Object.defineProperty(t.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._subscribe = function(n) {
    var r = e.prototype._subscribe.call(this, n);
    return !r.closed && n.next(this._value), r;
  }, t.prototype.getValue = function() {
    var n = this, r = n.hasError, i = n.thrownError, o = n._value;
    if (r)
      throw i;
    return this._throwIfClosed(), o;
  }, t.prototype.next = function(n) {
    e.prototype.next.call(this, this._value = n);
  }, t;
}(rT);
const mu = new Ua(null), $7 = (e, t) => e.interceptors.response.use(void 0, (n) => {
  var r, i, o;
  return t.exists(`errors.${(i = (r = n == null ? void 0 : n.response) == null ? void 0 : r.data) == null ? void 0 : i.message}`) && !((o = n == null ? void 0 : n.config) != null && o.url.includes("gas-estimate")) && mu.next(n.response.data), Promise.reject(n);
}), W7 = () => ({ error: Dr(
  Ie((n) => {
    const r = mu.subscribe(n);
    return () => {
      r.unsubscribe();
    };
  }, []),
  Ie(() => mu.value, []),
  Ie(() => mu.value, [])
), resetError: () => mu.next(null) }), iT = Ge(
  void 0
), G7 = ({
  children: e,
  ...t
}) => {
  var r;
  (r = t.wagmi) != null && r.__customConnectors__ && (t.wagmi.__customConnectors__ = void 0);
  const { i18n: n } = ze();
  return js(() => {
    t.language && n.changeLanguage(t.language);
  }, [t.language, n]), /* @__PURE__ */ y.jsx(iT.Provider, { value: t, children: e });
}, bt = () => {
  const e = we(iT);
  if (!e)
    throw new Error(
      "useSettings must be used within a SettingsContextProvider"
    );
  return e;
}, oT = Ge(void 0), H7 = ({ children: e }) => {
  const { apiKey: t } = bt(), { i18n: n } = ze(), [r] = Oe(() => {
    const o = pn.create({
      baseURL: Vt.env.apiUrl,
      headers: { "X-API-KEY": t },
      adapter: "fetch"
    });
    return w7(o), E7(o), $7(o, n), o;
  }), i = Ie(
    (o, s) => r(o, s).then((a) => a.data),
    [r]
  );
  return /* @__PURE__ */ y.jsx(oT.Provider, { value: r, children: /* @__PURE__ */ y.jsx(
    CL,
    {
      apiKey: t,
      baseURL: Vt.env.apiUrl,
      fetchInstance: i,
      children: e
    }
  ) });
}, Fp = () => {
  const e = we(oT);
  if (!e)
    throw new Error("ApiClient must be used within a ApiHooksProvider");
  return e;
}, K7 = {
  stake_kit: "StakeKit",
  max: "Max",
  min: "Min",
  available: "available",
  balance: "Balance",
  yearly: "Yearly",
  monthly: "Monthly",
  review: "Review",
  receive: "Receive",
  fees: "Fees",
  none: "None",
  confirm: "Confirm",
  cancel: "Cancel",
  ok: "Ok",
  something_went_wrong: "Something went wrong",
  not_enough_gas_token: "Not enough gas token",
  retry: "Try Again",
  unsupported_network: "Unsupported network",
  points: "Points",
  continue: "Continue",
  powered_by: "Powered by <span0>{{name}}</span0>"
}, Y7 = {
  disabled_chain_info: "Add account"
}, Q7 = {
  get_started: "Connect your wallet to get started…",
  connect_wallet: "Connect Wallet",
  ledger_add_account: "Add account"
}, J7 = {
  date_group_labels: {
    today: "Today",
    yesterday: "Yesterday"
  },
  review: {
    transactions: "Transactions",
    retry: "Retry",
    continue: "Continue",
    unknown_error: "Unknown error",
    terms_of_use: "By clicking {{action}} you agree to <underline0>Terms of Use</underline0> and understand the Risk Disclosures",
    in_progress: "In Progress"
  },
  no_previous_activity: "No previous activity in StakeKit"
}, X7 = {
  earn: "Earn",
  estimated_reward: "Estimated rewards",
  earn_with: "Earn with",
  additional_info: "Additional info",
  referral_code: {
    title: "Your referral link:"
  },
  rewards: {
    receive: "You'll receive <symbols1></symbols1> via",
    yearly: "Estimated Yearly Earnings",
    monthly: "Estimated Monthly Earnings"
  },
  tron_resources: {
    label: "Resource",
    placeholder: "Select resource"
  },
  reward_rate_estimate_tooltip: "Reward rate can't be accurately estimated",
  unstake_before: "You already have delegated your balance to a validator. Unstake and try again",
  no_opportunities: "No yield opportunities for this token",
  selected_validators_one: "{{providerName}}",
  selected_validators_other: "{{providerName}} + {{count}} more",
  native_staking: {
    earn_after_warmup_one: "You’ll start earning {{count}} day after you supply your assets",
    earn_after_warmup_other: "You’ll start earning {{count}} days after you supply your assets",
    earn_rewards_auto: "Earned rewards are distributed each {{rewardSchedule}} and accrue to your position automatically",
    earn_rewards_manual: "Earned rewards are distributed each {{rewardSchedule}} and need to be claimed manually. Your earnings compound, if you claim and restake quickly",
    unstake_time_immediately: "When unstaking, your assets will be available immediately",
    unstake_time_days: "When unstaking it takes {{cooldownPeriodDays}} days for your tokens to be available"
  },
  vault: {
    description: "When you deposit {{stakeToken}} you'll receive {{depositToken}}. You can trade this liquid asset at any time",
    earn_after_warmup_one: "You’ll start earning {{count}} day after you supply your assets",
    earn_after_warmup_other: "You’ll start earning {{count}} days after you supply your assets",
    earn_yield_auto: "Earned yield is updated each {{rewardSchedule}} and accrues automatically",
    earn_yield_manual: "Earned yield is updated each {{rewardSchedule}} and needs to be claimed manually",
    withdrawn_time_immediately: "When withdrawing, your assets will be available immediately",
    withdrawn_time_days: "When withdrawing it takes {{cooldownPeriodDays}} days for your assets will be available"
  },
  lend: {
    description: "When you supply {{stakeToken}} you'll receive {{rewardTokens}}. You can borrow against the supplied assets on {{providerName}}",
    description_compound: "When you supply {{stakeToken}} you'll receive {{rewardTokens}}",
    earn_after_warmup_one: "You’ll start earning {{count}} day after you supply your assets",
    earn_after_warmup_other: "You’ll start earning {{count}} days after you supply your assets",
    earn_interest_auto: "Earned interest is distributed each {{rewardSchedule}} and accrues automatically",
    earn_interest_manual: "Earned interest is distributed each {{rewardSchedule}} and needs to be claimed manually",
    withdrawn_time_immediately: "Upon withdrawing, your assets will be available immediately",
    withdrawn_time_days: "After withdrawing, your assets will be available in {{cooldownPeriodDays}} days"
  },
  liquid_stake: {
    description: "When you liquid stake {{stakeToken}} you'll receive {{rewardTokens}}. You can trade this liquid asset at any time",
    earn_after_warmup_one: "You’ll start earning {{count}} day after you stake",
    earn_after_warmup_other: "You’ll start earning {{count}} days after you stake",
    earn_rewards_auto: "Earned rewards are distributed each {{rewardSchedule}} and accrue to your position automatically",
    earn_rewards_manual: "Earned rewards are distributed each {{rewardSchedule}} and need to be claimed manually",
    unstake_time_immediately: "When unstaking, your assets will be available immediately",
    unstake_time_days: "When unstaking it takes {{cooldownPeriodDays}} days for your tokens to be available",
    unstake_time_days_with_claim_days: "When unstaking it takes {{cooldownPeriodDays}} days for your tokens to be available. They need to be claimed within {{claimDays}} days, otherwise they’ll need to be staked again.",
    withdrawn_not_available: "Withdrawals aren't available at the moment. To exit your position you can sell {{rewardTokens}} any time on DEXs"
  },
  restake: {
    description: "When you deposit {{stakeToken}} you'll receive {{rewardTokens}}. You can trade this liquid asset at any time",
    earn_after_warmup_one: "You’ll start earning {{count}} day after you stake",
    earn_after_warmup_other: "You’ll start earning {{count}} days after you stake",
    earn_rewards_auto: "Earned rewards are distributed each {{rewardSchedule}} and accrue to your position automatically",
    earn_rewards_manual: "Earned rewards are distributed each {{rewardSchedule}} and need to be claimed manually",
    unstake_time_immediately: "When unstaking, your assets will be available immediately",
    unstake_time_days: "When unstaking it takes {{cooldownPeriodDays}} days for your tokens to be available",
    withdrawn_not_available: "Withdrawals aren't available at the moment. To exit your position you can sell {{rewardTokens}} any time on DEXs"
  },
  extra_tezos: "You can use or send staked XTZ as normal",
  reward_type_varialbe: "{{symbol}} staking rewards rate varies based on the trading and transaction fees the protocol earns which can’t be accurately estimated",
  opportunity_search_title: "Select a yield",
  validator_search_title_one: "Select validator",
  validator_search_title_other: "Select validators",
  reward_token: "You'll receive <symbols1></symbols1> <highlight2>via {{providerName}}</highlight2>",
  tabs: {
    earn: "Earn",
    positions: "Manage",
    activity: "Activity"
  },
  validators_preferred: "Preferred",
  validators_other: "All validators",
  validators_view_all: "View all",
  validators_inactive: "Inactive",
  validators_jailed: "Jailed",
  validators_staked_balance: "Validator stake",
  validators_voting_power: "Voting power",
  validators_address: "Address",
  validators_comission: "Commission",
  validators_website: "Website"
}, Z7 = {
  estimated_reward: "Estimated rewards",
  estimated_gas_fee: "Estimated gas fee",
  wallet_fee: "{{wallet}} fee",
  claim: "Claim",
  terms_of_use: "By clicking confirm you agree to <underline0>Terms of Use</underline0> and understand the Risk Disclosures",
  amount_and_earn: "<highlight0>{{amount}}</highlight0> <highlight1>{{tokenSymbol}}</highlight1> & earn <highlight3>{{interestRate}}</highlight3>",
  additional_info: "Additional info",
  deposit_fee: "Deposit fee",
  management_fee: "Management fee",
  performance_fee: "Performance fee",
  deposit_fee_explanation: "A flat fee deducted at deposit, reducing the principal.",
  management_fee_explanation: "A flat annual fee deducted from vault deposits by minting new shares, diluting participants. Calculated based on time since the last harvest and applied during harvest.",
  performance_fee_explanation: "A fee deducted from earnings when a vault harvests a strategy. It’s only applied after surpassing a variable threshold."
}, e9 = {
  title: "Follow Steps",
  sign_transaction: "Sign transaction",
  sign_transaction_desc: "Go back to connected wallet to approve transaction",
  transaction_status: "Transaction status",
  transaction_status_desc: "Checking transaction status",
  finalize_stake: "Finalize stake",
  send_to_finalize_stake: "Send transaction to finalize your stake",
  approve: "Approve",
  approve_desc: "Approve this transaction in your wallet",
  submitting: "Submitting transaction",
  submitted: "Submitted",
  pending: "Pending",
  completed: "Completed",
  failed: "Failed",
  tx_of_one: "Transaction - {{type}}",
  tx_of_other: "Transaction {{current}} / {{count}} - {{type}}",
  skipped: "Skipped",
  approve_error: "Something went wrong. Check if wallet is connected",
  tx_type: {
    SWAP: "SWAP",
    DEPOSIT: "DEPOSIT",
    APPROVAL: "APPROVAL",
    STAKE: "STAKE",
    CLAIM_UNSTAKED: "CLAIM UNSTAKED",
    CLAIM_REWARDS: "CLAIM REWARDS",
    RESTAKE_REWARDS: "RESTAKE REWARDS",
    UNSTAKE: "UNSTAKE",
    SPLIT: "SPLIT",
    MERGE: "MERGE",
    LOCK: "LOCK",
    UNLOCK: "UNLOCK",
    SUPPLY: "SUPPLY",
    BRIDGE: "BRIDGE",
    VOTE: "VOTE",
    REVOKE: "REVOKE",
    RESTAKE: "RESTAKE",
    REBOND: "REBOND",
    WITHDRAW: "WITHDRAW",
    CREATE_ACCOUNT: "CREATE ACCOUNT",
    REVEAL: "REVEAL",
    MIGRATE: "MIGRATE",
    UTXO_P_TO_C_IMPORT: "UTXO P TO C IMPORT",
    UTXO_C_TO_P_IMPORT: "UTXO C TO P IMPORT",
    UNFREEZE_LEGACY: "UNFREEZE LEGACY",
    UNFREEZE_LEGACY_BANDWIDTH: "UNFREEZE LEGACY BANDWIDTH",
    UNFREEZE_LEGACY_ENERGY: "UNFREEZE LEGACY ENERGY",
    UNFREEZE_BANDWIDTH: "UNFREEZE BANDWIDTH",
    UNFREEZE_ENERGY: "UNFREEZE ENERGY",
    FREEZE_BANDWIDTH: "FREEZE BANDWIDTH",
    FREEZE_ENERGY: "FREEZE ENERGY",
    UNDELEGATE_BANDWIDTH: "UNDELEGATE BANDWIDTH",
    UNDELEGATE_ENERGY: "UNDELEGATE ENERGY",
    P2P_NODE_REQUEST: "P2P NODE REQUEST",
    LUGANODES_PROVISION: "LUGANODES PROVISION",
    LUGANODES_EXIT_REQUEST: "LUGANODES EXIT REQUEST",
    INFSTONES_PROVISION: "INFSTONES PROVISION",
    INFSTONES_EXIT_REQUEST: "INFSTONES EXIT REQUEST",
    INFSTONES_CLAIM_REQUEST: "INFSTONES CLAIM REQUEST"
  }
}, t9 = {
  successfully_staked: "Successfully {{action}} {{amount}} {{tokenNetwork}}",
  successfully_unstaked: "Successfully {{action}} {{amount}} {{tokenNetwork}}",
  successfully_pending_action: "Successfully {{pendingAction}} {{amount}} {{tokenNetwork}}",
  view_transaction: "View {{type}} transaction",
  via: "via {{providerName}}",
  stake: {
    staking: "staked",
    "liquid-staking": "staked",
    vault: "deposited",
    lending: "supplied",
    restaking: "restaked",
    pooled_staking: "staked",
    native_staking: "staked"
  },
  unstake: {
    staking: "unstaked",
    "liquid-staking": "unstaked",
    vault: "withdrawn",
    lending: "withdrawn",
    restaking: "unstaked",
    pooled_staking: "unstaked",
    native_staking: "unstaked"
  },
  pending_action: {
    stake: "staked",
    unstake: "unstaked",
    claim_rewards: "claimed rewards",
    restake_rewards: "restaked rewards",
    withdraw: "withdrawn",
    restake: "restaked",
    claim_unstaked: "claimed unstaked",
    unlock_locked: "unlocked locked",
    unlock_locked_legacy: "unlocked locked",
    stake_locked: "staked locked",
    vote: "voted",
    revoke: "Revoke",
    vote_locked: "Vote locked",
    revote: "Revote",
    rebond: "Rebond",
    migrate: "Migrate"
  }
}, n9 = {
  geo_block: {
    title: "Geo Block",
    ofac: "This feature is not available in {{countryName}}. {{countryName}} is on the Office of Foreign Assets Control (“OFAC”) list of sanctioned countries. You can learn more about OFAC and its sanctions programs here <link0>https://ofac.treasury.gov/sanctions-programs-and-country-information</link0>.",
    ofsi: "This feature is not available in {{countryName}}. {{countryName}} is on the U.K.’s Office of Financial Sanctions Implementation (“OFSI”) list of sanctioned countries. You can learn more about OFSI and its sanctions programs here <link0>https://www.gov.uk/government/collections/financial-sanctions-regime-specific-consolidated-lists-and-releases</link0>.",
    pending_litigation: "This feature is currently unavailable in {{nameOfRegion}} due to pending litigation on the subject of staking cryptocurrencies",
    crypto_ban: "This feature is not available in {{countryName}}. {{countryName}} has implemented firm regulations against the use of cryptocurrencies. Please refer to official {{countryName}} resources to learn more.",
    staking_ban: "This feature is not available in {{countryName}}. The Securities and Exchange Commission (“SEC”) of {{countryName}} has restricted digital asset business operators from offering staking services. You can learn more about the SEC regualtions here <link0>https://www.sec.or.th/TH/Pages/News_Detail.aspx?SECID=10018</link0>.",
    ofsi_crypto_ban: "This feature is not available in {{countryName}}. {{countryName}} is on the U.K.’s Office of Financial Sanctions Implementation (“OFSI”) list of sanctioned countries. You can learn more about OFSI and its sanctions programs here <link0>https://www.gov.uk/government/collections/financial-sanctions-regime-specific-consolidated-lists-and-releases</link0>. {{countryName}} has further implemented firm regulations against the use of cryptocurrencies.",
    ofac_ofsi: "This feature is not available in {{countryName}}. {{countryName}} is on both the Office of Foreign Assets Control (“OFAC”) list of sanctioned countries, as well as the U.K.’s Office of Financial Sanctions Implementation (“OFSI”) list of sanctioned countries. You can learn more about OFAC and its sanctions programs here <link0>https://ofac.treasury.gov/sanctions-programs-and-country-information</link0>, as well as OFSI and its sanctions programs here <link>https://www.gov.uk/government/collections/financial-sanctions-regime-specific-consolidated-lists-and-releases</link>.",
    default: "This feature is not available in {{countryName}}."
  },
  get_in_touch: {
    title: "Need help or have a questions?",
    button: "Get in touch"
  },
  what_is_stakekit: {
    title: "What is StakeKit?",
    description: "StakeKit is a platform that allows you to easily earn self-custodial yield across all major networks and tokens. From staking and liquid staking, to yield vaults and lending. StakeKit abstracts all complexity so that every yield is accessible in merely 3 clicks. And best of all, it’s fully self-custodial.<br0/><br0/>You can find more information about StakeKit on our <link0>website</link0> or in our <link1>FAQ section.</link1>"
  },
  under_maintenance: {
    title: "Under Maintenance",
    description: "StakeKit is currently undergoing routine maintenance. Our service is expected to be back up and running in approximately 5-10 minutes.",
    description2: "We appreciate your patience and encourage you to check back shortly!"
  }
}, r9 = {
  title: "My Positions",
  via_one: "via {{providerName}}",
  via_other: "via {{providerName}} + {{count}} more",
  connect_wallet: "Connect wallet",
  no_current_positions: "No current positions",
  claim_rewards: "Claim rewards",
  action_required: "Action required",
  dont_see_position: "Don't see a position?",
  import_validator: "Import a validator you have staked with to view your position",
  import_button: "Import",
  import_validator_modal_title: "Import validator",
  import_validator_already_imported: "Imported",
  search_for_validators: "Search for validators by address or name"
}, i9 = {
  native_staking: {
    title: "Native Staking",
    review: "Stake",
    cta: "Stake"
  },
  pooled_staking: {
    title: "Pooled Staking",
    review: "Stake",
    cta: "Stake"
  },
  staking: {
    title: "Stake",
    review: "Stake",
    cta: "Stake"
  },
  "liquid-staking": {
    title: "Liquid Staking",
    review: "Liquid Staking",
    cta: "Stake"
  },
  vault: {
    title: "Vault",
    review: "Deposit",
    cta: "Deposit"
  },
  lending: {
    title: "Lending",
    review: "Supply",
    cta: "Supply"
  },
  restaking: {
    title: "Restaking",
    review: "Deposit",
    cta: "Deposit"
  }
}, o9 = {
  labels: {
    hasFrozenV1: {
      label: "Frozen 1.0",
      details: "{{amount}} TRX are frozen with Legacy Stake 1.0. To migrate to 2.0: Simply unstake {{amount}} TRX in StakeKit and stake again (StakeKit automatically prioritizes unstaking of Stake 1.0 balance)"
    }
  },
  via: "{{stakeType}} via {{providerName}}",
  rewards: "Rewards",
  available_to: "<bold>{{amount}} {{symbol}}</bold> available to {{pendingAction, lowercase}}",
  claim: "Claim",
  unstake: "Unstake",
  withdraw: "Withdraw",
  available: "{{amount}} {{symbol}} available",
  select_validators: {
    submit: "Submit"
  },
  stake_type: {
    staking: "Staked",
    "liquid-staking": "Liquid staked",
    lending: "Deposited",
    vault: "Deposited",
    restaking: "Restaked"
  },
  unstake_label: {
    staking: "Unstake",
    "liquid-staking": "Unstake",
    lending: "Withdraw",
    vault: "Withdraw",
    restaking: "Unstake"
  },
  balance_type: {
    available: "Available",
    staked: "Staked",
    staked_yearn_or_deposit: "Deposited",
    unstaking: "Unstaking",
    unstaking_yearn_or_deposit: "Withdrawing",
    unstaked: "Unstaked",
    unstaked_yearn_or_deposit: "Withdrawn",
    preparing: "Preparing",
    rewards: "Rewards",
    locked: "Locked",
    unlocking: "Unlocking"
  },
  unstaking_days_one: "{{count}} day remaining",
  unstaking_days_other: "{{count}} days remaining",
  pending_action: {
    stake: "Stake",
    unstake: "Unstake",
    claim_rewards: "Claim rewards",
    restake_rewards: "Restake rewards",
    withdraw: "Withdraw",
    restake: "Restake",
    claim_unstaked: "Claim unstaked",
    unlock_locked: "Unlock",
    unlock_locked_legacy: "Unlock",
    stake_locked: "Stake",
    vote: "Vote",
    revoke: "Revoke",
    vote_locked: "Vote",
    revote: "Revote",
    rebond: "Rebond",
    migrate: "Migrate"
  },
  pending_action_button: {
    stake: "Stake",
    unstake: "Unstake",
    claim_rewards: "Claim",
    restake_rewards: "Restake",
    withdraw: "Withdraw",
    restake: "Restake",
    claim_unstaked: "Claim",
    unlock_locked: "Unlock",
    unlock_locked_legacy: "Unlock",
    stake_locked: "Stake",
    vote: "Vote",
    revoke: "Revoke",
    vote_locked: "Vote locked",
    revote: "Revote",
    rebond: "Rebond",
    migrate: "Migrate"
  },
  unstake_sign: {
    title: "Verify Ownership",
    description: "You need to verify ownership of this address to proceed with this action. You will be prompted to sign a message that will be used to verify that you own this address."
  }
}, s9 = {
  terms_of_use: "By clicking confirm your agree to <underline0>Terms of Use</underline0> and understand the Risk Disclosures",
  unstake_from: "Unstake from {{providerName}}"
}, a9 = {
  pending_action_type: {
    stake: "Stake with {{providerName}}",
    unstake: "Unstake from {{providerName}}",
    claim_rewards: "Claim rewards from {{providerName}}",
    restake_rewards: "Restake rewards with {{providerName}}",
    withdraw: "Withdraw from {{providerName}}",
    restake: "Restake with {{providerName}}",
    claim_unstaked: "Claim unstaked from {{providerName}}",
    unlock_locked: "Unlock locked from {{providerName}}",
    unlock_locked_legacy: "Unlock locked from {{providerName}}",
    stake_locked: "Stake locked with {{providerName}}",
    vote: "Vote with {{providerName}}",
    revoke: "Revoke with {{providerName}}",
    vote_locked: "Vote locked with {{providerName}}",
    revote: "Revote with {{providerName}}",
    rebond: "Rebond with {{providerName}}",
    migrate: "Migrate from {{providerName}}"
  }
}, l9 = {
  title: "Select token",
  n_available_opps: "{{count}} available opportunities"
}, c9 = {
  title: "Referral check",
  body: "Enter your referral code to continue",
  submit: "Submit"
}, u9 = {
  solution: "Potential solution:"
}, d9 = {
  shared: K7,
  chain_modal: Y7,
  init: Q7,
  activity: J7,
  details: X7,
  review: Z7,
  steps: e9,
  complete: t9,
  help_modals: n9,
  positions: r9,
  yield_types: i9,
  position_details: o9,
  unstake_review: s9,
  pending_action_review: a9,
  select_token: l9,
  referral_lock: c9,
  error_modal: u9
}, f9 = {
  stake_kit: "StakeKit",
  max: "Max",
  min: "Min",
  available: "disponible",
  balance: "Solde",
  yearly: "Annuel",
  monthly: "Mensuel",
  review: "Revoir",
  receive: "Recevoir",
  fees: "Frais",
  none: "Aucun",
  confirm: "Confirmer",
  cancel: "Annuler",
  ok: "Ok",
  something_went_wrong: "Une erreur s'est produite",
  not_enough_gas_token: "Gas insuffisant",
  retry: "Réessayer",
  unsupported_network: "Réseau non supporté",
  points: "Points",
  continue: "Continuer",
  powered_by: "Alimenté par <span0>{{name}}</span0>"
}, h9 = {
  disabled_chain_info: "Ajoutez un portefeuille"
}, p9 = {
  get_started: "Connectez votre portefeuille pour commencer…",
  connect_wallet: "Connectez un portefeuille",
  ledger_add_account: "Ajoutez un portefeuille"
}, y9 = {
  date_group_labels: {
    today: "Aujourd'hui",
    yesterday: "Hier"
  },
  review: {
    transactions: "Transactions",
    retry: "Réessayer",
    continue: "Continuer",
    unknown_error: "Erreur inconnue",
    terms_of_use: "En cliquant sur {{action}} vous acceptez les <underline0>Conditions d'utilisation</underline0> et comprenez les Informations sur les Risques",
    in_progress: "En cours"
  },
  no_previous_activity: "Aucune activité précédente dans StakeKit"
}, m9 = {
  earn: "Earn",
  estimated_reward: "Récompenses estimées",
  staked_via: "Earn avec",
  additional_info: "Infos supplémentaires",
  referral_code: {
    title: "Votre lien de parrainage :"
  },
  rewards: {
    receive: "Vous recevrez des <symbols1></symbols1> via",
    yearly: "Gains annuels estimés",
    monthly: "Gains mensuels estimés"
  },
  tron_resources: {
    label: "Ressource",
    placeholder: "Sélectionnez une ressource"
  },
  reward_rate_estimate_tooltip: "Le taux de récompense ne peut pas être estimé de façon précise",
  unstake_before: "Vous avez déjà délégué vos fonds à un validateur. Déstakez et réessayez",
  no_opportunities: "Pas d'opportunité de yield pour ce token",
  selected_validators_one: "{{providerName}}",
  selected_validators_other: "{{providerName}} + {{count}} autres",
  native_staking: {
    earn_after_warmup_one: "Vous commencerez à être récompensé {{count}} jour après avoir fourni vos actifs",
    earn_after_warmup_other: "Vous commencerez à être récompensé {{count}} jours après avoir fourni vos actifs",
    earn_rewards_auto: "Les récompenses gagnées sont distribuées chaque {{rewardSchedule}} et cumulées à votre position automatiquement",
    earn_rewards_manual: "Les récompenses gagnées sont distribuées chaque {{rewardSchedule}} et doivent être réclamées manuellement. Vos gains se cumulent, si vous les réclamez et restakez rapidement",
    unstake_time_immediately: "En les déstakant, vos actifs seront disponibles immédiatement",
    unstake_time_days: "En les déstakant, vos tokens seront disponibles sous {{cooldownPeriodDays}} jours"
  },
  vault: {
    description: "En déposant du {{stakeToken}} vous recevrez du {{depositToken}}. Vous pouvez trader cet actif liquide à tout moment",
    earn_after_warmup_one: "Vous commencerez à être récompensé {{count}} jour après avoir fourni vos actifs",
    earn_after_warmup_other: "Vous commencerez à être récompensé {{count}} jours après avoir fourni vos actifs",
    earn_yield_auto: "Le yield gagné est mis à jour chaque {{rewardSchedule}} et se cumule automatiquement",
    earn_yield_manual: "Le yield gagné est mis à jour chaque {{rewardSchedule}} et doit être réclamé manuellement",
    withdrawn_time_immediately: "En les retirant, vos actifs seront disponibles immédiatement",
    withdrawn_time_days: "En les retirant, vos actifs seront disponibles sous {{cooldownPeriodDays}} jours"
  },
  lend: {
    description: "En fournissant du {{stakeToken}} vous recevrez des {{rewardTokens}}. Vous pouvez emprunter contre les actifs fournis sur {{providerName}}",
    description_compound: "En fournissant du {{stakeToken}} vous recevrez du {{rewardTokens}}",
    earn_after_warmup_one: "Vous commencerez à être récompensé {{count}} jour après avoir fourni vos actifs",
    earn_after_warmup_other: "Vous commencerez à être récompensé {{count}} jours après avoir fourni vos actifs",
    earn_interest_auto: "Les intérêts gagnés sont distribués chaque {{rewardSchedule}} et se cumulent automatiquement",
    earn_interest_manual: "Les intérêts gagnés sont distribués chaque {{rewardSchedule}} et doivent être réclamés manuellement",
    withdrawn_time_immediately: "En les retirant, vos actifs seront disponibles immédiatement",
    withdrawn_time_days: "Après leur retrait, vos actifs seront disponibles sous {{cooldownPeriodDays}} jours"
  },
  liquid_stake: {
    description: "En stakant du {{stakeToken}} vous recevrez des {{rewardTokens}}. Vous pouvez trader cet actif liquide à tout moment",
    earn_after_warmup_one: "Vous commencerez à être récompensé {{count}} jour après avoir staké",
    earn_after_warmup_other: "Vous commencerez à être récompensé {{count}} jours après avoir staké",
    earn_rewards_auto: "Les récompenses gagnées sont distribuées chaque {{rewardSchedule}} et cumulées à votre position automatiquement",
    earn_rewards_manual: "Les récompenses gagnées sont distribuées chaque {{rewardSchedule}} et doivent être réclamées manuellement",
    unstake_time_immediately: "En les déstakant, vos actifs seront disponibles immédiatement",
    unstake_time_days: "En les déstakant, vos tokens seront disponibles sous {{cooldownPeriodDays}} jours",
    unstake_time_days_with_claim_days: "En les déstakant, vos tokens seront disponibles sous {{cooldownPeriodDays}} jours. Vous devez les réclamer sous {{claimDays}} jours, sans quoi il faudra les staker à nouveau.",
    withdrawn_not_available: "Les retraits ne sont pas disponibles pour le moment. Pour liquider votre position, vous pouvez vendre {{rewardTokens}} à tout moment sur les DEXs"
  },
  restake: {
    description: "En déposant du {{stakeToken}} vous recevrez des {{rewardTokens}}. Vous pouvez trader cet actif liquide à tout moment",
    earn_after_warmup_one: "Vous commencerez à être récompensé {{count}} jour après avoir staké",
    earn_after_warmup_other: "Vous commencerez à être récompensé {{count}} jours après avoir staké",
    earn_rewards_auto: "Les récompenses gagnées sont distribuées chaque {{rewardSchedule}} et cumulées à votre position automatiquement",
    earn_rewards_manual: "Les récompenses gagnées sont distribuées chaque {{rewardSchedule}} et doivent être réclamées manuellement",
    unstake_time_immediately: "En les déstakant, vos actifs seront disponibles immédiatement",
    unstake_time_days: "En les déstakant, vos tokens seront disponibles sous {{cooldownPeriodDays}} jours",
    withdrawn_not_available: "Les retraits ne sont pas disponibles pour le moment. Pour liquider votre position, vous pouvez vendre {{rewardTokens}} à tout moment sur les DEXs"
  },
  extra_tezos: "Vous pouvez utiliser ou envoyer des XTZ stakés normalement",
  reward_type_varialbe: " Le taux de récompense de staking de {{symbol}} varie selon les trades et les frais de transaction que le protocole gagne, ce qui ne peut être estimé précisément",
  opportunity_search_title: "Sélectionnez un rendement",
  validator_search_title_one: "Sélectionnez un validateur",
  validator_search_title_other: "Sélectionnez des validateurs",
  reward_token: "Vous recevrez des <symbols1></symbols1> <highlight2>via {{providerName}}</highlight2>",
  tabs: {
    earn: "Earn",
    positions: "Manage",
    activity: "Activity"
  },
  validators_preferred: "Préférés",
  validators_other: "Tous les validateurs",
  validators_view_all: "Tout voir",
  validators_inactive: "Inactif",
  validators_jailed: "Banni",
  validators_staked_balance: "Solde validateur",
  validators_voting_power: "Droit de vote",
  validators_address: "Adresse",
  validators_comission: "Commission",
  validators_website: "Site web"
}, g9 = {
  estimated_reward: "Récompenses estimées",
  estimated_gas_fee: "Frais de gas estimés",
  wallet_fee: "Frais de {{wallet}}",
  claim: "Réclamer",
  terms_of_use: "En cliquant sur Confirmer vous acceptez les <underline0>Conditions d'utilisation</underline0> et comprenez les Informations sur les Risques",
  amount_and_earn: "<highlight0>{{amount}}</highlight0> <highlight1>{{tokenSymbol}}</highlight1> & earn <highlight3>{{interestRate}}</highlight3>",
  additional_info: "Infos supplémentaires",
  deposit_fee: "Frais de Dépôt",
  management_fee: "Frais de Gestion",
  performance_fee: "Frais de Performance",
  deposit_fee_explanation: "Une commission fixe déduite lors du dépôt, réduisant le capital investi.",
  management_fee_explanation: "Une commission annuelle fixe déduite des dépôts du vault en émettant de nouvelles parts, ce qui dilue les participants. Calculée en fonction du temps écoulé depuis la dernière récolte et appliquée lors de la récolte.",
  performance_fee_explanation: "Une commission déduite des gains lorsqu’un vault récolte une stratégie. Elle n’est appliquée qu’après avoir dépassé un seuil variable."
}, v9 = {
  title: "Suivi des étapes",
  sign_transaction: "Signez la transaction",
  sign_transaction_desc: "Retournez sur le portefeuille connecté pour autoriser la transaction",
  transaction_status: "Statut de la transaction",
  transaction_status_desc: "Vérification du statut de la transaction",
  finalize_stake: "Finalisez le staking",
  send_to_finalize_stake: "Envoyez la transaction pour finaliser le staking",
  approve: "Autoriser",
  approve_desc: "Autorisez cette transaction dans votre portefeuille",
  submitting: "Envoi de la transaction",
  submitted: "Envoyée",
  pending: "En cours",
  completed: "Complétée",
  failed: "Echouée",
  tx_of_one: "Transaction - {{type}}",
  tx_of_other: "Transaction {{current}} / {{count}} - {{type}}",
  skipped: "Ignorée",
  approve_error: "Une erreur s'est produite. Vérifiez si le portefeuille est bien connecté",
  tx_type: {
    SWAP: "ÉCHANGE",
    DEPOSIT: "DÉPÔT",
    APPROVAL: "APPROBATION",
    STAKE: "MISE",
    CLAIM_UNSTAKED: "RÉCLAMER NON MIS",
    CLAIM_REWARDS: "RÉCLAMER RÉCOMPENSES",
    RESTAKE_REWARDS: "REMISE DES RÉCOMPENSES",
    UNSTAKE: "RETIRER",
    SPLIT: "DIVISER",
    MERGE: "FUSIONNER",
    LOCK: "VERROUILLER",
    UNLOCK: "DÉVERROUILLER",
    SUPPLY: "FOURNIR",
    BRIDGE: "PONT",
    VOTE: "VOTER",
    REVOKE: "RÉVOQUER",
    RESTAKE: "REMISE",
    REBOND: "RELIER",
    WITHDRAW: "RETIRER",
    CREATE_ACCOUNT: "CRÉER UN COMPTE",
    REVEAL: "RÉVÉLER",
    MIGRATE: "MIGRER",
    UTXO_P_TO_C_IMPORT: "IMPORTER UTXO P VERS C",
    UTXO_C_TO_P_IMPORT: "IMPORTER UTXO C VERS P",
    UNFREEZE_LEGACY: "DÉGELER LÉGACY",
    UNFREEZE_LEGACY_BANDWIDTH: "DÉGELER BANDE PASSANTE LÉGACY",
    UNFREEZE_LEGACY_ENERGY: "DÉGELER ÉNERGIE LÉGACY",
    UNFREEZE_BANDWIDTH: "DÉGELER BANDE PASSANTE",
    UNFREEZE_ENERGY: "DÉGELER ÉNERGIE",
    FREEZE_BANDWIDTH: "GELER BANDE PASSANTE",
    FREEZE_ENERGY: "GELER ÉNERGIE",
    UNDELEGATE_BANDWIDTH: "DÉLÉGUER BANDE PASSANTE",
    UNDELEGATE_ENERGY: "DÉLÉGUER ÉNERGIE",
    P2P_NODE_REQUEST: "DEMANDE NŒUD P2P",
    LUGANODES_PROVISION: "FOURNITURE LUGANODES",
    LUGANODES_EXIT_REQUEST: "DEMANDE DE SORTIE LUGANODES",
    INFSTONES_PROVISION: "FOURNITURE INFSTONES",
    INFSTONES_EXIT_REQUEST: "DEMANDE DE SORTIE INFSTONES",
    INFSTONES_CLAIM_REQUEST: "DEMANDE DE RÉCLAMATION INFSTONES"
  }
}, b9 = {
  successfully_staked: "{{amount}} {{tokenNetwork}} {{action}} avec succès",
  successfully_unstaked: "{{amount}} {{tokenNetwork}} {{action}} avec succès",
  successfully_pending_action: "{{amount}} {{tokenNetwork}} {{pendingAction}} avec succès",
  view_transaction: "Voir la transaction {{type}}",
  via: "via {{providerName}}",
  stake: {
    staking: "staké",
    "liquid-staking": "staké",
    vault: "déposé",
    lending: "fourni",
    restaking: "restaké",
    pooled_staking: "staké",
    native_staking: "staké"
  },
  unstake: {
    staking: "déstaké",
    "liquid-staking": "déstaké",
    vault: "retiré",
    lending: "retiré",
    restaking: "déstaké",
    pooled_staking: "déstaké",
    native_staking: "déstaké"
  },
  pending_action: {
    stake: "staké",
    unstake: "déstaké",
    claim_rewards: "récompenses réclamées",
    restake_rewards: "récompenses restakées",
    withdraw: "reitré",
    restake: "restaké",
    claim_unstaked: "déstakés réclamés",
    unlock_locked: "bloqués débloqués",
    unlock_locked_legacy: "bloqués débloqués",
    stake_locked: "bloqués stakés",
    vote: "voté",
    revoke: "Révoquer",
    vote_locked: "Voter bloqué",
    revote: "Revoter",
    rebond: "Re-staker",
    migrate: "Migrer"
  }
}, w9 = {
  geo_block: {
    title: "Bloquage Géographique",
    ofac: "Cette fonctionnalité n'est pas disponible en {{countryName}}. {{countryName}} figure sur la liste des pays sanctionnés par l'Office of Foreign Assets Control (“OFAC”). Vous pouvez en apprendre plus sur l'OFAC et ses programmes de sanctions via ce lien : <link0>https://ofac.treasury.gov/sanctions-programs-and-country-information</link0>.",
    ofsi: "Cette fonctionnalité n'est pas disponible en {{countryName}}. {{countryName}} figure sur la liste des pays sanctionnés par l'Office of Financial Sanctions Implementation (“OFSI”) britannique. Vous pouvez en apprendre plus sur l'OFSI et ses programmes de sanctions via ce lien : <link0>https://www.gov.uk/government/collections/financial-sanctions-regime-specific-consolidated-lists-and-releases</link0>.",
    pending_litigation: "Cette fonctionnalité n'est actuellement pas disponible en {{nameOfRegion}} du fait des litiges en cours au sujet du staking des cryptomonnaies",
    crypto_ban: "Cette fonctionnalité n'est pas disponible en {{countryName}}. {{countryName}} a mis en place une régulation stricte à l'usage des cryptomonnaies. Merci de vous référer aux ressources officielles de {{countryName}} pour en savoir plus.",
    staking_ban: "Cette fonctionnalité n'est pas disponible en {{countryName}}. La Securities and Exchange Commission (“SEC”) de {{countryName}} a interdit aux opérateurs d'actifs numériques d'offrir des services de staking. Vous pouvez en apprendre plus sur les régulations de la SEC via ce lien : <link0>https://www.sec.or.th/TH/Pages/News_Detail.aspx?SECID=10018</link0>.",
    ofsi_crypto_ban: "Cette fonctionnalité n'est pas disponible en {{countryName}}. {{countryName}} figure sur la liste des pays sanctionnés par l'Office of Financial Sanctions Implementation (“OFSI”) britannique. Vous pouvez en apprendre plus sur l'OFSI et ses programmes de sanctions via ce lien : <link0>https://www.gov.uk/government/collections/financial-sanctions-regime-specific-consolidated-lists-and-releases</link0>. {{countryName}} a aussi mis en place une régulatin stricte concernant l'usage des cryptomonnaies.",
    ofac_ofsi: "Cette fonctionnalité n'est pas disponible en {{countryName}}. {{countryName}} figure sur les listes des pays sanctionnés par l'Office of Foreign Assets Control (“OFAC”) et de l'Office of Financial Sanctions Implementation (“OFSI”) britannique. Vous pouvez en apprendre plus sur l'OFAC et ses programmes de sanctions via ce lien : <link0>https://ofac.treasury.gov/sanctions-programs-and-country-information</link0>, ainsi que sur ceux de l'OFSI via ce lien : <link>https://www.gov.uk/government/collections/financial-sanctions-regime-specific-consolidated-lists-and-releases</link>.",
    default: "Cette fonctionnalité n'est pas disponible en {{countryName}}."
  },
  get_in_touch: {
    title: "Une question ? Besoin d'aide ?",
    button: "Contactez-nous"
  },
  what_is_stakekit: {
    title: "Qu'est-ce que StakeKit ?",
    description: "StakeKit est une plateforme qui vous permet d'engendrer facilement des rendements en propre à travers les réseaux et tokens les plus importants. Du staking au staking liquide, en passant par les vaults et le lending. StakeKit abstrait toute la complexité, rendant les gains accessibles en moins de 3 clics. Et cerise sur le gâteau, vous restez propriétaires de vos fonds.<br0/><br0/>Vous trouverez plus d'informations à propos de StakeKit sur notre <link0>site web</link0> ou dans notre <link1>FAQ.</link1>"
  },
  under_maintenance: {
    title: "En maintenance",
    description: "StakeKit est actuellement en maintenance de routine. Notre service devrait être de retour en ligne dans environ 5 à 10 minutes.",
    description2: "Nous apprécions votre patience et vous encourageons à revenir bientôt !"
  }
}, x9 = {
  title: "Mes Positions",
  via_one: "via {{providerName}}",
  via_other: "via {{providerName}} + {{count}} autres",
  connect_wallet: "Connecter un portefeuille",
  no_current_positions: "Aucune position",
  claim_rewards: "Réclamer les récompenses",
  action_required: "Action requise",
  dont_see_position: "Vous ne voyez pas une position?",
  import_validator: "Importez un validateur à qui vous avez délégué des fonds pour voir votre position",
  import_button: "Importer",
  import_validator_modal_title: "Importer un validateur",
  import_validator_already_imported: "Importé",
  search_for_validators: "Rechercher des validateurs par adresse ou nom"
}, C9 = {
  native_staking: {
    title: "Staking Native",
    review: "Staker",
    cta: "Staker"
  },
  pooled_staking: {
    title: "Staking Pooled",
    review: "Staker",
    cta: "Staker"
  },
  staking: {
    title: "Staking",
    review: "Staker",
    cta: "Staker"
  },
  "liquid-staking": {
    title: "Staking Liquide",
    review: "Staker",
    cta: "Staker"
  },
  vault: {
    title: "Vault",
    review: "Déposer",
    cta: "Déposer"
  },
  lending: {
    title: "Lending",
    review: "Fournir",
    cta: "Fournir"
  },
  restaking: {
    title: "Restaking",
    review: "Déposer",
    cta: "Déposer"
  }
}, k9 = {
  labels: {
    hasFrozenV1: {
      label: "Gelé 1.0",
      details: "{{amount}} TRX sont gelés avec Legacy Stake 1.0. Pour migrer vers 2.0 : Il suffit de déstaker {{amount}} TRX dans StakeKit et de les staker à nouveau (StakeKit priorise automatiquement le déstaking du solde de Stake 1.0)"
    }
  },
  via: "{{stakeType}} via {{providerName}}",
  rewards: "Récompenses",
  available_to: "<bold>{{amount}} {{symbol}}</bold> disponibles pour {{pendingAction, lowercase}}",
  claim: "Réclamer",
  unstake: "Déstaker",
  withdraw: "Retirer",
  available: "{{amount}} {{symbol}} disponibles",
  select_validators: {
    submit: "Envoyer"
  },
  stake_type: {
    staking: "Staké",
    "liquid-staking": "Staké",
    lending: "Déposé",
    vault: "Déposé",
    restaking: "Restaké"
  },
  unstake_label: {
    staking: "Déstaker",
    "liquid-staking": "Déstaker",
    lending: "Retirer",
    vault: "Retirer",
    restaking: "Déstaker"
  },
  balance_type: {
    available: "Disponible",
    staked: "Staké",
    staked_yearn_or_deposit: "Déposé",
    unstaking: "En cours de déstaking",
    unstaking_yearn_or_deposit: "En cours de retrait",
    unstaked: "Déstaké",
    unstaked_yearn_or_deposit: "Retiré",
    preparing: "En cours de préparation",
    rewards: "Récompenses",
    locked: "Bloqué",
    unlocking: "En cours de déblocage"
  },
  unstaking_days_one: "{{count}} jour restant",
  unstaking_days_other: "{{count}} jours restants",
  pending_action: {
    stake: "Staker",
    unstake: "Déstaker",
    claim_rewards: "Réclamer les récompenses",
    restake_rewards: "Restaker les récompenses",
    withdraw: "Retirer",
    restake: "Restaker",
    claim_unstaked: "Réclamer les déstakés",
    unlock_locked: "Débloquer",
    unlock_locked_legacy: "Débloquer",
    stake_locked: "Staker",
    vote: "Voter",
    revoke: "Révoquer",
    vote_locked: "Voter",
    revote: "Revoter",
    rebond: "Re-staker",
    migrate: "Migrer"
  },
  pending_action_button: {
    stake: "Staker",
    unstake: "Déstaker",
    claim_rewards: "Réclamer",
    restake_rewards: "Restaker",
    withdraw: "Retirer",
    restake: "Restaker",
    claim_unstaked: "Réclamer",
    unlock_locked: "Débloquer",
    unlock_locked_legacy: "Débloquer",
    stake_locked: "Staker",
    vote: "Voter",
    revoke: "Révoquer",
    vote_locked: "Voter bloqué",
    revote: "Revoter",
    rebond: "Re-staker",
    migrate: "Migrer"
  },
  unstake_sign: {
    title: "Vérifier la propriété",
    description: "Vous devez vérifier la propriété de cette adresse avant de procéder. Vous serez invité(e) à signer un message qui sera utilisé pour confirmer que vous possédez bien cette adresse."
  }
}, E9 = {
  terms_of_use: "En cliquant sur Confirmer vous acceptez les <underline0>Conditions d'utilisation</underline0> et comprenez les Informations sur les Risques",
  unstake_from: "Déstaker de {{providerName}}"
}, S9 = {
  pending_action_type: {
    stake: "Staker avec {{providerName}}",
    unstake: "Déstaker de {{providerName}}",
    claim_rewards: "Réclamer les récompenses de {{providerName}}",
    restake_rewards: "Restaker les récompenses avec {{providerName}}",
    withdraw: "Retirer de {{providerName}}",
    restake: "Restaker avec {{providerName}}",
    claim_unstaked: "Réclamer le déstaké de {{providerName}}",
    unlock_locked: "Débloquer le bloqué de {{providerName}}",
    unlock_locked_legacy: "Débloquer le bloqué de {{providerName}}",
    stake_locked: "Staker le bloqué avec {{providerName}}",
    vote: "Voter avec {{providerName}}",
    revoke: "Révoquer avec {{providerName}}",
    vote_locked: "Voter bloqué avec {{providerName}}",
    revote: "Revoter avec {{providerName}}",
    rebond: "Re-staker avec {{providerName}}",
    migrate: "Migrer de {{providerName}}"
  }
}, A9 = {
  title: "Sélectionner un token",
  n_available_opps: "{{count}} opportunités disponibles"
}, T9 = {
  title: "Vérification du parrainage",
  body: "Saisissez votre code de parrainage pour continuer",
  submit: "Envoyer"
}, _9 = {
  solution: "Solution potentielle :"
}, I9 = {
  shared: f9,
  chain_modal: h9,
  init: p9,
  activity: y9,
  details: m9,
  review: g9,
  steps: v9,
  complete: b9,
  help_modals: w9,
  positions: x9,
  yield_types: C9,
  position_details: k9,
  unstake_review: E9,
  pending_action_review: S9,
  select_token: A9,
  referral_lock: T9,
  error_modal: _9
}, iw = pj(), dk = {
  en: { translation: d9 },
  fr: { translation: I9 }
};
iw.use(Gj).use(DA).init({
  resources: dk,
  supportedLngs: Object.keys(dk),
  fallbackLng: "en",
  interpolation: { escapeValue: !1 },
  detection: { order: ["navigator", "localStorage"] }
});
var oA;
(oA = iw.services.formatter) == null || oA.add(
  "lowercase",
  (e, t, n) => e.toLowerCase()
);
const R9 = () => {
  const e = Fp(), { i18n: t } = ze(), [n] = t.language.split("-");
  return Ut({
    queryKey: ["error-translations", n],
    staleTime: Number.POSITIVE_INFINITY,
    gcTime: Number.POSITIVE_INFINITY,
    queryFn: () => Kn({
      fn: () => e.get(
        `https://i18n.stakek.it/locales/${n}/errors.json`
      )
    }).ifRight(
      (r) => t.addResourceBundle(t.language, "translation", {
        errors: r.data
      })
    )
  });
};
G.fromRecord = (e) => {
  const t = {};
  for (const n in e) {
    const r = e[n];
    if (r.isJust())
      t[n] = r.extract();
    else
      return _t;
  }
  return Je(t);
};
var Ue;
(function(e) {
  e.Ethereum = "ethereum", e.EthereumGoerli = "ethereum-goerli", e.EthereumHolesky = "ethereum-holesky", e.Arbitrum = "arbitrum", e.Base = "base", e.Gnosis = "gnosis", e.Optimism = "optimism", e.Polygon = "polygon", e.Starknet = "starknet", e.zkSync = "zksync", e.Linea = "linea", e.AvalancheC = "avalanche-c", e.AvalancheCAtomic = "avalanche-c-atomic", e.AvalancheP = "avalanche-p", e.Binance = "binance", e.Celo = "celo", e.Fantom = "fantom", e.Harmony = "harmony", e.Moonriver = "moonriver", e.OKC = "okc", e.Viction = "viction", e.Core = "core";
})(Ue || (Ue = {}));
var qe;
(function(e) {
  e.Agoric = "agoric", e.Akash = "akash", e.Axelar = "axelar", e.BandProtocol = "band-protocol", e.Bitsong = "bitsong", e.Canto = "canto", e.Chihuahua = "chihuahua", e.Comdex = "comdex", e.Coreum = "coreum", e.Cosmos = "cosmos", e.Crescent = "crescent", e.Cronos = "cronos", e.Cudos = "cudos", e.Desmos = "desmos", e.Dydx = "dydx", e.Evmos = "evmos", e.FetchAi = "fetch-ai", e.GravityBridge = "gravity-bridge", e.Injective = "injective", e.IRISnet = "irisnet", e.Juno = "juno", e.Kava = "kava", e.KiNetwork = "ki-network", e.MarsProtocol = "mars-protocol", e.NYM = "nym", e.OKExChain = "okex-chain", e.Onomy = "onomy", e.Osmosis = "osmosis", e.Persistence = "persistence", e.Quicksilver = "quicksilver", e.Regen = "regen", e.Secret = "secret", e.Sentinel = "sentinel", e.Sommelier = "sommelier", e.StaFi = "stafi", e.Stargaze = "stargaze", e.Stride = "stride", e.Teritori = "teritori", e.TGrade = "tgrade", e.Umee = "umee", e.Sei = "sei", e.Mantra = "mantra";
})(qe || (qe = {}));
var Ta;
(function(e) {
  e.Polkadot = "polkadot", e.Westend = "westend", e.Kusama = "kusama";
})(Ta || (Ta = {}));
var Jt;
(function(e) {
  e.BinanceBeacon = "binancebeacon", e.Cardano = "cardano", e.Near = "near", e.Solana = "solana", e.Tezos = "tezos", e.Tron = "tron", e.Ton = "ton", e.TonTestnet = "ton-testnet";
})(Jt || (Jt = {}));
const W = {
  ...Ue,
  ...qe,
  ...Ta,
  ...Jt
};
var fk;
(function(e) {
  e.slow = "slow", e.average = "average", e.fast = "fast", e.custom = "custom";
})(fk || (fk = {}));
var hk;
(function(e) {
  e.wei = "wei", e.gwei = "gwei";
})(hk || (hk = {}));
var Se;
(function(e) {
  e.ATOM = "ATOM", e.uatom = "uatom", e.AKT = "AKT", e.uakt = "uakt", e.KAVA = "KAVA", e.ukava = "ukava", e.OSMO = "OSMO", e.uosmo = "uosmo", e.JUNO = "JUNO", e.ujuno = "ujuno", e.XPRT = "XPRT", e.uxprt = "uxprt", e.STARS = "STARS", e.ustars = "ustars", e.AXL = "AXL", e.uaxl = "uaxl", e.NOM = "NOM", e.anom = "anom", e.QCK = "QCK", e.uqck = "uqck", e.BLD = "BLD", e.ubld = "ubld", e.BAND = "BAND", e.uband = "uband", e.BTSG = "BTSG", e.ubtsg = "ubtsg", e.CANTO = "CANTO", e.acanto = "acanto", e.CMDX = "CMDX", e.ucmdx = "ucmdx", e.CRE = "CRE", e.ucre = "ucre", e.CRO = "CRO", e.basecro = "basecro", e.CUDOS = "CUDOS", e.acudos = "acudos", e.DVPN = "DVPN", e.udvpn = "udvpn", e.EVMOS = "EVMOS", e.aevmos = "aevmos", e.FET = "FET", e.afet = "afet", e.GRAVITON = "GRAVITON", e.ugraviton = "ugraviton", e.HUAHUA = "HUAHUA", e.uhuahua = "uhuahua", e.INJ = "INJ", e.inj = "inj", e.IRIS = "IRIS", e.uiris = "uiris", e.XKI = "XKI", e.uxki = "uxki", e.MARS = "MARS", e.umars = "umars", e.NYM = "NYM", e.unym = "unym", e.OKT = "OKT", e.aokt = "wei", e.REGEN = "REGEN", e.uregen = "uregen", e.SCRT = "SCRT", e.uscrt = "uscrt", e.SOMM = "SOMM", e.usomm = "usomm", e.FIS = "FIS", e.ufis = "ufis", e.STRD = "STRD", e.ustrd = "ustrd", e.TORI = "TORI", e.utori = "utori", e.TGD = "TGD", e.utgd = "utgd", e.UMEE = "UMEE", e.uumee = "uumee", e.CORE = "CORE", e.ucore = "ucore", e.DSM = "DSM", e.udsm = "udsm", e.DYDX = "DYDX", e.adydx = "adydx", e.SEI = "SEI", e.usei = "usei", e.OM = "OM", e.uom = "uom";
})(Se || (Se = {}));
const Ae = {
  [W.Akash]: {
    network: W.Akash,
    chainId: "akashnet-2",
    name: "Akash",
    denom: Se.AKT,
    minimalDenom: Se.uakt,
    decimals: 6,
    bech32Prefix: "akash",
    coinGeckoId: "akash-network"
  },
  [W.Cosmos]: {
    network: W.Cosmos,
    chainId: "cosmoshub-4",
    name: "Cosmos",
    denom: Se.ATOM,
    minimalDenom: Se.uatom,
    decimals: 6,
    bech32Prefix: "cosmos",
    coinGeckoId: "cosmos"
  },
  [W.Kava]: {
    network: W.Kava,
    chainId: "kava-9",
    name: "Kava",
    denom: Se.KAVA,
    minimalDenom: Se.ukava,
    decimals: 6,
    bech32Prefix: "kava",
    coinGeckoId: "kava"
  },
  [W.Osmosis]: {
    network: W.Osmosis,
    chainId: "osmosis-1",
    name: "Osmosis",
    denom: Se.OSMO,
    minimalDenom: Se.uosmo,
    decimals: 6,
    bech32Prefix: "osmo",
    coinGeckoId: "osmosis"
  },
  [W.Juno]: {
    network: W.Juno,
    chainId: "juno-1",
    name: "Juno",
    denom: Se.JUNO,
    minimalDenom: Se.ujuno,
    decimals: 6,
    bech32Prefix: "juno",
    coinGeckoId: "juno-network"
  },
  [W.Stargaze]: {
    network: W.Stargaze,
    chainId: "stargaze-1",
    name: "Stargaze",
    denom: Se.STARS,
    minimalDenom: Se.ustars,
    decimals: 6,
    bech32Prefix: "stars",
    coinGeckoId: "stargaze"
  },
  [W.Persistence]: {
    network: W.Persistence,
    chainId: "core-1",
    name: "Persistence",
    denom: Se.XPRT,
    minimalDenom: Se.uxprt,
    decimals: 6,
    bech32Prefix: "persistence",
    coinGeckoId: "persistence"
  },
  [W.Axelar]: {
    network: W.Axelar,
    chainId: "axelar-dojo-1",
    name: "Axelar",
    denom: Se.AXL,
    minimalDenom: Se.uaxl,
    decimals: 6,
    bech32Prefix: "axelar",
    coinGeckoId: "axelar"
  },
  [W.Onomy]: {
    network: W.Onomy,
    chainId: "onomy-mainnet-1",
    name: "Onomy",
    denom: Se.NOM,
    minimalDenom: Se.anom,
    decimals: 18,
    bech32Prefix: "onomy",
    coinGeckoId: "onomy-protocol"
  },
  [W.Quicksilver]: {
    network: W.Quicksilver,
    chainId: "quicksilver-2",
    name: "Quicksilver",
    denom: Se.QCK,
    minimalDenom: Se.uqck,
    decimals: 6,
    bech32Prefix: "quick",
    coinGeckoId: "quicksilver"
  },
  [W.Agoric]: {
    network: W.Agoric,
    chainId: "agoric-3",
    name: "Agoric",
    denom: Se.BLD,
    minimalDenom: Se.ubld,
    decimals: 6,
    bech32Prefix: "agoric",
    coinGeckoId: "agoric"
  },
  [W.BandProtocol]: {
    network: W.BandProtocol,
    chainId: "laozi-mainnet",
    name: "Band Protocol",
    denom: Se.BAND,
    minimalDenom: Se.uband,
    decimals: 6,
    bech32Prefix: "band",
    coinGeckoId: "band-protocol"
  },
  [W.Bitsong]: {
    network: W.Bitsong,
    chainId: "bitsong-2b",
    name: "BitSong",
    denom: Se.BTSG,
    minimalDenom: Se.ubtsg,
    decimals: 6,
    bech32Prefix: "bitsong",
    coinGeckoId: "bitsong"
  },
  [W.Canto]: {
    network: W.Canto,
    chainId: "canto_7700-1",
    name: "Canto",
    denom: Se.CANTO,
    minimalDenom: Se.acanto,
    decimals: 18,
    bech32Prefix: "canto",
    coinGeckoId: "canto"
  },
  [W.Chihuahua]: {
    network: W.Chihuahua,
    chainId: "chihuahua-1",
    name: "Chihuahua",
    denom: Se.HUAHUA,
    minimalDenom: Se.uhuahua,
    decimals: 6,
    bech32Prefix: "chihuahua",
    coinGeckoId: "chihuahua-token"
  },
  [W.Comdex]: {
    network: W.Comdex,
    chainId: "comdex-1",
    name: "Comdex",
    denom: Se.CMDX,
    minimalDenom: Se.ucmdx,
    decimals: 6,
    bech32Prefix: "comdex",
    coinGeckoId: "comdex"
  },
  [W.Crescent]: {
    network: W.Crescent,
    chainId: "crescent-1",
    name: "Crescent",
    denom: Se.CRE,
    minimalDenom: Se.ucre,
    decimals: 6,
    bech32Prefix: "cre",
    coinGeckoId: "crescent-network"
  },
  [W.Cronos]: {
    network: W.Cronos,
    chainId: "crypto-org-chain-mainnet-1",
    name: "Crypto.org Chain",
    denom: Se.CRO,
    minimalDenom: Se.basecro,
    decimals: 18,
    bech32Prefix: "cro",
    coinGeckoId: "crypto-com-chain"
  },
  [W.Cudos]: {
    network: W.Cudos,
    chainId: "cudos-1",
    name: "Cudos",
    denom: Se.CUDOS,
    minimalDenom: Se.acudos,
    decimals: 18,
    bech32Prefix: "cudos",
    coinGeckoId: "cudos"
  },
  [W.Evmos]: {
    network: W.Evmos,
    chainId: "evmos_9001-2",
    name: "Evmos",
    denom: Se.EVMOS,
    minimalDenom: Se.aevmos,
    decimals: 18,
    bech32Prefix: "evmos",
    coinGeckoId: "evmos"
  },
  [W.FetchAi]: {
    network: W.FetchAi,
    chainId: "fetchhub-4",
    name: "Fetch.ai",
    denom: Se.FET,
    minimalDenom: Se.afet,
    decimals: 18,
    bech32Prefix: "fetch",
    coinGeckoId: "fetch-ai"
  },
  [W.GravityBridge]: {
    network: W.GravityBridge,
    chainId: "gravity-bridge-3",
    name: "Gravity Bridge",
    denom: Se.GRAVITON,
    minimalDenom: Se.ugraviton,
    decimals: 6,
    bech32Prefix: "gravity",
    coinGeckoId: "graviton"
  },
  [W.Injective]: {
    network: W.Injective,
    chainId: "injective-1",
    name: "Injective",
    denom: Se.INJ,
    minimalDenom: Se.inj,
    decimals: 18,
    bech32Prefix: "inj",
    coinGeckoId: "injective-protocol"
  },
  [W.IRISnet]: {
    network: W.IRISnet,
    chainId: "irishub-1",
    name: "IRISnet",
    denom: Se.IRIS,
    minimalDenom: Se.uiris,
    decimals: 6,
    bech32Prefix: "iaa",
    coinGeckoId: "iris-network"
  },
  [W.KiNetwork]: {
    network: W.KiNetwork,
    chainId: "kichain-2",
    name: "Ki",
    denom: Se.XKI,
    minimalDenom: Se.uxki,
    decimals: 6,
    bech32Prefix: "ki",
    coinGeckoId: "ki"
  },
  [W.MarsProtocol]: {
    network: W.MarsProtocol,
    chainId: "mars-1",
    name: "Mars Hub",
    denom: Se.MARS,
    minimalDenom: Se.umars,
    decimals: 6,
    bech32Prefix: "mars",
    coinGeckoId: "mars-protocol"
  },
  [W.NYM]: {
    network: W.NYM,
    chainId: "nyx",
    name: "Nym",
    denom: Se.NYM,
    minimalDenom: Se.unym,
    decimals: 6,
    bech32Prefix: "n",
    coinGeckoId: "nym"
  },
  [W.OKExChain]: {
    network: W.OKExChain,
    chainId: "exchain-66",
    name: "OKExChain",
    denom: Se.OKT,
    minimalDenom: Se.aokt,
    decimals: 18,
    bech32Prefix: "ex",
    coinGeckoId: "oec-token"
  },
  [W.Regen]: {
    network: W.Regen,
    chainId: "regen-1",
    name: "Regen",
    denom: Se.REGEN,
    minimalDenom: Se.uregen,
    decimals: 6,
    bech32Prefix: "regen",
    coinGeckoId: "regen"
  },
  [W.Secret]: {
    network: W.Secret,
    chainId: "secret-4",
    name: "Secret Network",
    denom: Se.SCRT,
    minimalDenom: Se.uscrt,
    decimals: 6,
    bech32Prefix: "secret",
    coinGeckoId: "secret"
  },
  [W.Sentinel]: {
    network: W.Sentinel,
    chainId: "sentinelhub-2",
    name: "Sentinel",
    denom: Se.DVPN,
    minimalDenom: Se.udvpn,
    decimals: 6,
    bech32Prefix: "sent",
    coinGeckoId: "sentinel"
  },
  [W.Sommelier]: {
    network: W.Sommelier,
    chainId: "sommelier-3",
    name: "Sommelier",
    denom: Se.SOMM,
    minimalDenom: Se.usomm,
    decimals: 6,
    bech32Prefix: "somm",
    coinGeckoId: "sommelier"
  },
  [W.StaFi]: {
    network: W.StaFi,
    chainId: "stafihub-1",
    name: "StaFi Hub",
    denom: Se.FIS,
    minimalDenom: Se.ufis,
    decimals: 6,
    bech32Prefix: "stafi",
    coinGeckoId: "stafi"
  },
  [W.Stride]: {
    network: W.Stride,
    chainId: "stride-1",
    name: "Stride",
    denom: Se.STRD,
    minimalDenom: Se.ustrd,
    decimals: 6,
    bech32Prefix: "stride",
    coinGeckoId: "stride"
  },
  [W.Teritori]: {
    network: W.Teritori,
    chainId: "teritori-1",
    name: "Teritori",
    denom: Se.TORI,
    minimalDenom: Se.utori,
    decimals: 6,
    bech32Prefix: "tori",
    coinGeckoId: "teritori"
  },
  [W.TGrade]: {
    network: W.TGrade,
    chainId: "tgrade-mainnet-1",
    name: "Tgrade",
    denom: Se.TGD,
    minimalDenom: Se.utgd,
    decimals: 6,
    bech32Prefix: "tgrade",
    coinGeckoId: "tgrade"
  },
  [W.Umee]: {
    network: W.Umee,
    chainId: "umee-1",
    name: "Umee",
    denom: Se.UMEE,
    minimalDenom: Se.uumee,
    decimals: 6,
    bech32Prefix: "umee",
    coinGeckoId: "umee"
  },
  [W.Coreum]: {
    network: W.Coreum,
    chainId: "coreum-mainnet-1",
    name: "Coreum",
    denom: Se.CORE,
    minimalDenom: Se.ucore,
    decimals: 6,
    bech32Prefix: "core",
    coinGeckoId: "coreum"
  },
  [W.Desmos]: {
    network: W.Desmos,
    chainId: "desmos-mainnet",
    name: "Desmos",
    denom: Se.DSM,
    minimalDenom: Se.udsm,
    decimals: 6,
    bech32Prefix: "desmos",
    coinGeckoId: "desmos"
  },
  [W.Dydx]: {
    network: W.Dydx,
    chainId: "dydx-mainnet-1",
    name: "dydx",
    denom: Se.DYDX,
    minimalDenom: Se.adydx,
    decimals: 18,
    bech32Prefix: "dydx",
    coinGeckoId: "dydx-chain"
  },
  [W.Sei]: {
    network: W.Sei,
    chainId: "pacific-1",
    name: "sei",
    denom: Se.SEI,
    minimalDenom: Se.usei,
    decimals: 6,
    bech32Prefix: "sei",
    coinGeckoId: "sei-network"
  },
  [W.Mantra]: {
    network: W.Mantra,
    chainId: "mantra-1",
    name: "mantra",
    denom: Se.OM,
    minimalDenom: Se.uom,
    decimals: 6,
    bech32Prefix: "mantra",
    coinGeckoId: "mantra-dao"
  }
};
W.Ethereum + "", W.Solana + "", W.Celo + "", W.Optimism + "", W.AvalancheC + "", W.Fantom + "", W.Polygon + "", W.Binance + "", W.Harmony + "", W.Arbitrum + "", W.Tezos + "", W.Cardano + "", W.Starknet + "", W.Base + "", W.Linea + "", W.zkSync + "", W.Core + "", W.Cosmos + "", Ae[W.Cosmos].coinGeckoId, W.Kava + "", Ae[W.Kava].coinGeckoId, W.Osmosis + "", Ae[W.Osmosis].coinGeckoId, W.Stargaze + "", Ae[W.Stargaze].coinGeckoId, W.Juno + "", Ae[W.Juno].coinGeckoId, W.Persistence + "", Ae[W.Persistence].coinGeckoId, W.Axelar + "", Ae[W.Axelar].coinGeckoId, W.Onomy + "", Ae[W.Onomy].coinGeckoId, W.Agoric + "", Ae[W.Agoric].coinGeckoId, W.BandProtocol + "", Ae[W.BandProtocol].coinGeckoId, W.Bitsong + "", Ae[W.Bitsong].coinGeckoId, W.Canto + "", Ae[W.Canto].coinGeckoId, W.Chihuahua + "", Ae[W.Chihuahua].coinGeckoId, W.Comdex + "", Ae[W.Comdex].coinGeckoId, W.Crescent + "", Ae[W.Crescent].coinGeckoId, W.Cronos + "", Ae[W.Cronos].coinGeckoId, W.Cudos + "", Ae[W.Cudos].coinGeckoId, W.Evmos + "", Ae[W.Evmos].coinGeckoId, W.FetchAi + "", Ae[W.FetchAi].coinGeckoId, W.GravityBridge + "", Ae[W.GravityBridge].coinGeckoId, W.Injective + "", Ae[W.Injective].coinGeckoId, W.IRISnet + "", Ae[W.IRISnet].coinGeckoId, W.KiNetwork + "", Ae[W.KiNetwork].coinGeckoId, W.MarsProtocol + "", Ae[W.MarsProtocol].coinGeckoId, W.NYM + "", Ae[W.NYM].coinGeckoId, W.OKExChain + "", Ae[W.OKExChain].coinGeckoId, W.Regen + "", Ae[W.Regen].coinGeckoId, W.Secret + "", Ae[W.Secret].coinGeckoId, W.Sentinel + "", Ae[W.Sentinel].coinGeckoId, W.Sommelier + "", Ae[W.Sommelier].coinGeckoId, W.StaFi + "", Ae[W.StaFi].coinGeckoId, W.Stride + "", Ae[W.Stride].coinGeckoId, W.Teritori + "", Ae[W.Teritori].coinGeckoId, W.TGrade + "", Ae[W.TGrade].coinGeckoId, W.Umee + "", Ae[W.Umee].coinGeckoId, W.Coreum + "", Ae[W.Coreum].coinGeckoId, W.Desmos + "", Ae[W.Desmos].coinGeckoId, W.Dydx + "", Ae[W.Dydx].coinGeckoId, W.Sei + "", Ae[W.Sei].coinGeckoId, W.Mantra + "", Ae[W.Mantra].coinGeckoId;
W.Arbitrum + "", W.AvalancheC + "", W.Binance + "", W.Celo + "", W.Ethereum + "", W.EthereumGoerli + "", W.EthereumHolesky + "", W.Fantom + "", W.Near + "", W.Harmony + "", W.Optimism + "", W.Polygon + "", W.Akash + "", W.Solana + "", W.Tezos + "", W.Starknet + "", W.Viction + "", W.Base + "", W.Linea + "", W.zkSync + "", W.Core + "", W.Cosmos + "", Ae[W.Cosmos].chainId, W.Kava + "", Ae[W.Kava].chainId, W.Osmosis + "", Ae[W.Osmosis].chainId, W.Stargaze + "", Ae[W.Stargaze].chainId, W.Juno + "", Ae[W.Juno].chainId, W.Persistence + "", Ae[W.Persistence].chainId, W.Axelar + "", Ae[W.Axelar].chainId, W.Onomy + "", Ae[W.Onomy].chainId, W.Agoric + "", Ae[W.Agoric].chainId, W.BandProtocol + "", Ae[W.BandProtocol].chainId, W.Bitsong + "", Ae[W.Bitsong].chainId, W.Canto + "", Ae[W.Canto].chainId, W.Chihuahua + "", Ae[W.Chihuahua].chainId, W.Comdex + "", Ae[W.Comdex].chainId, W.Crescent + "", Ae[W.Crescent].chainId, W.Cronos + "", Ae[W.Cronos].chainId, W.Cudos + "", Ae[W.Cudos].chainId, W.Evmos + "", Ae[W.Evmos].chainId, W.FetchAi + "", Ae[W.FetchAi].chainId, W.GravityBridge + "", Ae[W.GravityBridge].chainId, W.Injective + "", Ae[W.Injective].chainId, W.IRISnet + "", Ae[W.IRISnet].chainId, W.KiNetwork + "", Ae[W.KiNetwork].chainId, W.MarsProtocol + "", Ae[W.MarsProtocol].chainId, W.NYM + "", Ae[W.NYM].chainId, W.OKExChain + "", Ae[W.OKExChain].chainId, W.Regen + "", Ae[W.Regen].chainId, W.Secret + "", Ae[W.Secret].chainId, W.Sentinel + "", Ae[W.Sentinel].chainId, W.Sommelier + "", Ae[W.Sommelier].chainId, W.StaFi + "", Ae[W.StaFi].chainId, W.Stride + "", Ae[W.Stride].chainId, W.Teritori + "", Ae[W.Teritori].chainId, W.TGrade + "", Ae[W.TGrade].chainId, W.Umee + "", Ae[W.Umee].chainId, W.Coreum + "", Ae[W.Coreum].chainId, W.Desmos + "", Ae[W.Desmos].chainId, W.Dydx + "", Ae[W.Dydx].chainId, W.Sei + "", Ae[W.Sei].chainId, W.Mantra + "", Ae[W.Mantra].chainId;
const sT = [
  qe.Akash,
  qe.Cosmos,
  qe.Juno,
  qe.Kava,
  qe.Osmosis,
  qe.Stargaze,
  qe.Onomy,
  qe.Persistence,
  qe.Axelar,
  qe.Quicksilver,
  qe.Agoric,
  qe.BandProtocol,
  qe.Bitsong,
  qe.Chihuahua,
  qe.Comdex,
  qe.Crescent,
  qe.Cronos,
  qe.Cudos,
  qe.FetchAi,
  qe.GravityBridge,
  qe.IRISnet,
  qe.KiNetwork,
  qe.MarsProtocol,
  qe.Regen,
  qe.Secret,
  qe.Sentinel,
  qe.Sommelier,
  qe.Teritori,
  qe.Umee,
  qe.Coreum,
  qe.Desmos,
  qe.Dydx,
  qe.Injective,
  qe.Sei,
  qe.Mantra
], P9 = new Set(sT), O9 = [
  Ue.AvalancheC,
  Ue.Arbitrum,
  Ue.Binance,
  Ue.Celo,
  Ue.Ethereum,
  Ue.EthereumGoerli,
  Ue.Harmony,
  Ue.Optimism,
  Ue.Polygon,
  Ue.Viction,
  Ue.EthereumHolesky,
  Ue.Base,
  Ue.Linea,
  Ue.Core
], B9 = new Set(O9), N9 = [
  Jt.Near,
  Jt.Tezos,
  Jt.Solana,
  Jt.Tron,
  Jt.Ton
], D9 = new Set(N9), j9 = [Ta.Polkadot], M9 = new Set(j9), aT = (e) => P9.has(e) || B9.has(e) || D9.has(e) || M9.has(e), mbe = {
  near: {
    "*": {
      currencyId: "near",
      family: "near",
      skChainName: Jt.Near
    }
  },
  tezos: {
    "*": {
      currencyId: "tezos",
      family: "tezos",
      skChainName: Jt.Tezos
    }
  },
  solana: {
    "*": {
      currencyId: "solana",
      family: "solana",
      skChainName: Jt.Solana
    }
  },
  tron: {
    "*": {
      currencyId: "tron",
      family: "tron",
      skChainName: Jt.Tron
    }
  },
  ton: {
    "*": {
      currencyId: "ton",
      family: "ton",
      skChainName: Jt.Ton
    }
  },
  polkadot: {
    "*": {
      currencyId: "polkadot",
      family: "polkadot",
      skChainName: Ta.Polkadot
    }
  },
  celo: {
    "*": {
      currencyId: "celo",
      family: "celo",
      skChainName: Ue.Celo
    }
  },
  crypto_org: {
    "*": {
      currencyId: "crypto_org",
      family: "crypto_org",
      skChainName: qe.Cronos
    }
  },
  ethereum: {
    ethereum: {
      currencyId: "ethereum",
      family: "ethereum",
      skChainName: Ue.Ethereum
    },
    polygon: {
      currencyId: "polygon",
      family: "ethereum",
      skChainName: Ue.Polygon
    },
    arbitrum: {
      currencyId: "arbitrum",
      family: "ethereum",
      skChainName: Ue.Arbitrum
    },
    optimism: {
      currencyId: "optimism",
      family: "ethereum",
      skChainName: Ue.Optimism
    },
    "avalanche-c": {
      currencyId: "avalanche_c_chain",
      family: "ethereum",
      skChainName: Ue.AvalancheC
    },
    ethereum_holesky: {
      currencyId: "ethereum_holesky",
      family: "ethereum",
      skChainName: Ue.EthereumHolesky
    }
  },
  cosmos: {
    cosmos: {
      currencyId: "cosmos",
      family: "cosmos",
      skChainName: qe.Cosmos
    },
    osmo: {
      currencyId: "osmo",
      family: "cosmos",
      skChainName: qe.Osmosis
    },
    coreum: {
      currencyId: "coreum",
      family: "cosmos",
      skChainName: qe.Coreum
    },
    axelar: {
      currencyId: "axelar",
      family: "cosmos",
      skChainName: qe.Axelar
    },
    stargaze: {
      currencyId: "stargaze",
      family: "cosmos",
      skChainName: qe.Stargaze
    },
    secret_network: {
      currencyId: "secret_network",
      family: "cosmos",
      skChainName: qe.Secret
    },
    umee: {
      currencyId: "umee",
      family: "cosmos",
      skChainName: qe.Umee
    },
    desmos: {
      currencyId: "desmos",
      family: "cosmos",
      skChainName: qe.Desmos
    },
    onomy: {
      currencyId: "onomy",
      family: "cosmos",
      skChainName: qe.Onomy
    },
    quicksilver: {
      currencyId: "quicksilver",
      family: "cosmos",
      skChainName: qe.Quicksilver
    },
    persistence: {
      currencyId: "persistence",
      family: "cosmos",
      skChainName: qe.Persistence
    },
    dydx: {
      currencyId: "dydx",
      family: "cosmos",
      skChainName: qe.Dydx
    },
    injective: {
      currencyId: "injective",
      family: "cosmos",
      skChainName: qe.Injective
    },
    sei: {
      currencyId: "sei",
      family: "cosmos",
      skChainName: qe.Sei
    },
    mantra: {
      currencyId: "mantra",
      family: "cosmos",
      skChainName: qe.Mantra
    }
  }
}, F9 = () => {
  const { externalProviders: e } = bt();
  return J(
    () => lT({
      externalProviderInitToken: e == null ? void 0 : e.initToken
    }),
    [e == null ? void 0 : e.initToken]
  );
}, L9 = wn.custom({
  decode: (e) => lr.decode(e).chain(
    (t) => t in oa ? _e(t) : Xe("invalid pending action")
  ),
  encode: (e) => e
}), U9 = wn.custom({
  decode: (e) => lr.decode(e).chain((t) => aT(t) ? _e(t) : Xe("invalid chain")),
  encode: (e) => e
}), z9 = /^(?!.*\.\.)[a-zA-Z0-9-_.]*$/, Ys = wn.custom({
  decode: (e) => lr.decode(e).chain(
    (t) => z9.test(t) ? _e(t) : Xe("invalid string value")
  ),
  encode: (e) => e
}), V9 = wn.custom({
  decode: (e) => lr.decode(e).chain((t) => {
    const [n, r, ...i] = t.split("-");
    return !n || !r || !i.toString() ? Xe("invalid yieldId format") : _e(t);
  }),
  encode: (e) => e
}), q9 = wn.custom({
  decode: (e) => e === "earn" || e === "positions" ? _e(e) : Xe("invalid chain"),
  encode: (e) => e
}), $9 = wn.custom({
  decode: (e) => lr.decode(e).map((t) => decodeURIComponent(t)),
  encode: (e) => e
}), lT = ({
  externalProviderInitToken: e
}) => Tn.map((t) => new URL(t.location.href)).map((t) => ({
  network: Ys.decode(t.searchParams.get("network")).alt(
    Ys.decode(t.searchParams.get("token")).chain(
      (n) => n.includes("-") ? _e(n.split("-").slice(0, -1).join("-")) : Xe("invalid TokenString")
    )
  ).chain(U9.decode).toMaybe().extractNullable(),
  token: lr.decode(t.searchParams.get("token") ?? e).toMaybe().extractNullable(),
  yieldId: Ys.decode(t.searchParams.get("yieldId")).chain(V9.decode).toMaybe().extractNullable(),
  balanceId: Ys.decode(t.searchParams.get("balanceId")).toMaybe().extractNullable(),
  validator: lr.decode(t.searchParams.get("validator")).toMaybe().extractNullable(),
  pendingaction: Ys.decode(t.searchParams.get("pendingaction")).chain(L9.decode).toMaybe().extractNullable(),
  referralCode: Ys.decode(t.searchParams.get("ref")).toMaybe().extractNullable(),
  accountId: $9.decode(t.searchParams.get("accountId")).toMaybe().extractNullable(),
  tab: Ys.decode(t.searchParams.get("tab")).chain(q9.decode).toMaybe().extractNullable()
})), W9 = () => new TD({
  defaultOptions: {
    queries: {
      gcTime: Vt.queryClient.cacheTime,
      staleTime: Vt.queryClient.staleTime,
      retry: (e, t) => _o(t) ? !!(Yv(t) && e < 2) : !1,
      refetchOnWindowFocus: !1
    },
    mutations: {
      retry: (e, t) => _o(t) ? !!(Yv(t) && e < 2) : !1
    }
  }
}), cT = Ge(void 0), G9 = ({ children: e }) => {
  const [t] = Oe(W9);
  return /* @__PURE__ */ y.jsx(cT.Provider, { value: t, children: /* @__PURE__ */ y.jsx(OD, { client: t, children: e }) });
}, ci = () => {
  const e = we(cT);
  if (!e)
    throw new Error(
      "useSKQueryClient must be used within a QueryClientContextProvider"
    );
  return e;
}, H9 = () => {
  const e = It(!1);
  return Te(() => (e.current = !1, () => {
    e.current = !0;
  }), []), Ie(() => e.current, []);
}, uT = {
  id: "safe",
  name: "Safe",
  type: "safe"
}, ow = (e) => e.id === uT.id;
class K9 extends Error {
  constructor(n) {
    super("Safe tx failed");
    pr(this, "_tag", "SafeFailedError");
    pr(this, "type");
    this.type = n;
  }
}
var pk = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"', Y9 = {
  rounded: `SFRounded, ui-rounded, "SF Pro Rounded", ${pk}`,
  system: pk
}, ru = {
  large: {
    actionButton: "9999px",
    connectButton: "12px",
    modal: "24px",
    modalMobile: "28px"
  },
  medium: {
    actionButton: "10px",
    connectButton: "8px",
    modal: "16px",
    modalMobile: "18px"
  },
  none: {
    actionButton: "0px",
    connectButton: "0px",
    modal: "0px",
    modalMobile: "0px"
  },
  small: {
    actionButton: "4px",
    connectButton: "4px",
    modal: "8px",
    modalMobile: "8px"
  }
}, Q9 = {
  large: {
    modalOverlay: "blur(20px)"
  },
  none: {
    modalOverlay: "blur(0px)"
  },
  small: {
    modalOverlay: "blur(4px)"
  }
}, dT = ({
  borderRadius: e = "large",
  fontStack: t = "rounded",
  overlayBlur: n = "none"
}) => ({
  blurs: {
    modalOverlay: Q9[n].modalOverlay
  },
  fonts: {
    body: Y9[t]
  },
  radii: {
    actionButton: ru[e].actionButton,
    connectButton: ru[e].connectButton,
    menuButton: ru[e].connectButton,
    modal: ru[e].modal,
    modalMobile: ru[e].modalMobile
  }
}), yh = "#1A1B1F", fT = {
  blue: { accentColor: "#3898FF", accentColorForeground: "#FFF" },
  green: { accentColor: "#4BD166", accentColorForeground: yh },
  orange: { accentColor: "#FF983D", accentColorForeground: yh },
  pink: { accentColor: "#FF7AB8", accentColorForeground: yh },
  purple: { accentColor: "#7A70FF", accentColorForeground: "#FFF" },
  red: { accentColor: "#FF6257", accentColorForeground: "#FFF" }
}, yk = fT.blue, hT = ({
  accentColor: e = yk.accentColor,
  accentColorForeground: t = yk.accentColorForeground,
  ...n
} = {}) => ({
  ...dT(n),
  colors: {
    accentColor: e,
    accentColorForeground: t,
    actionButtonBorder: "rgba(255, 255, 255, 0.04)",
    actionButtonBorderMobile: "rgba(255, 255, 255, 0.08)",
    actionButtonSecondaryBackground: "rgba(255, 255, 255, 0.08)",
    closeButton: "rgba(224, 232, 255, 0.6)",
    closeButtonBackground: "rgba(255, 255, 255, 0.08)",
    connectButtonBackground: yh,
    connectButtonBackgroundError: "#FF494A",
    connectButtonInnerBackground: "linear-gradient(0deg, rgba(255, 255, 255, 0.075), rgba(255, 255, 255, 0.15))",
    connectButtonText: "#FFF",
    connectButtonTextError: "#FFF",
    connectionIndicator: "#30E000",
    downloadBottomCardBackground: "linear-gradient(126deg, rgba(0, 0, 0, 0) 9.49%, rgba(120, 120, 120, 0.2) 71.04%), #1A1B1F",
    downloadTopCardBackground: "linear-gradient(126deg, rgba(120, 120, 120, 0.2) 9.49%, rgba(0, 0, 0, 0) 71.04%), #1A1B1F",
    error: "#FF494A",
    generalBorder: "rgba(255, 255, 255, 0.08)",
    generalBorderDim: "rgba(255, 255, 255, 0.04)",
    menuItemBackground: "rgba(224, 232, 255, 0.1)",
    modalBackdrop: "rgba(0, 0, 0, 0.5)",
    modalBackground: "#1A1B1F",
    modalBorder: "rgba(255, 255, 255, 0.08)",
    modalText: "#FFF",
    modalTextDim: "rgba(224, 232, 255, 0.3)",
    modalTextSecondary: "rgba(255, 255, 255, 0.6)",
    profileAction: "rgba(224, 232, 255, 0.1)",
    profileActionHover: "rgba(224, 232, 255, 0.2)",
    profileForeground: "rgba(224, 232, 255, 0.05)",
    selectedOptionBorder: "rgba(224, 232, 255, 0.1)",
    standby: "#FFD641"
  },
  shadows: {
    connectButton: "0px 4px 12px rgba(0, 0, 0, 0.1)",
    dialog: "0px 8px 32px rgba(0, 0, 0, 0.32)",
    profileDetailsAction: "0px 2px 6px rgba(37, 41, 46, 0.04)",
    selectedOption: "0px 2px 6px rgba(0, 0, 0, 0.24)",
    selectedWallet: "0px 2px 6px rgba(0, 0, 0, 0.24)",
    walletLogo: "0px 2px 16px rgba(0, 0, 0, 0.16)"
  }
});
hT.accentColors = fT;
var pT = {
  blue: { accentColor: "#0E76FD", accentColorForeground: "#FFF" },
  green: { accentColor: "#1DB847", accentColorForeground: "#FFF" },
  orange: { accentColor: "#FF801F", accentColorForeground: "#FFF" },
  pink: { accentColor: "#FF5CA0", accentColorForeground: "#FFF" },
  purple: { accentColor: "#5F5AFA", accentColorForeground: "#FFF" },
  red: { accentColor: "#FA423C", accentColorForeground: "#FFF" }
}, mk = pT.blue, sw = ({
  accentColor: e = mk.accentColor,
  accentColorForeground: t = mk.accentColorForeground,
  ...n
} = {}) => ({
  ...dT(n),
  colors: {
    accentColor: e,
    accentColorForeground: t,
    actionButtonBorder: "rgba(0, 0, 0, 0.04)",
    actionButtonBorderMobile: "rgba(0, 0, 0, 0.06)",
    actionButtonSecondaryBackground: "rgba(0, 0, 0, 0.06)",
    closeButton: "rgba(60, 66, 66, 0.8)",
    closeButtonBackground: "rgba(0, 0, 0, 0.06)",
    connectButtonBackground: "#FFF",
    connectButtonBackgroundError: "#FF494A",
    connectButtonInnerBackground: "linear-gradient(0deg, rgba(0, 0, 0, 0.03), rgba(0, 0, 0, 0.06))",
    connectButtonText: "#25292E",
    connectButtonTextError: "#FFF",
    connectionIndicator: "#30E000",
    downloadBottomCardBackground: "linear-gradient(126deg, rgba(255, 255, 255, 0) 9.49%, rgba(171, 171, 171, 0.04) 71.04%), #FFFFFF",
    downloadTopCardBackground: "linear-gradient(126deg, rgba(171, 171, 171, 0.2) 9.49%, rgba(255, 255, 255, 0) 71.04%), #FFFFFF",
    error: "#FF494A",
    generalBorder: "rgba(0, 0, 0, 0.06)",
    generalBorderDim: "rgba(0, 0, 0, 0.03)",
    menuItemBackground: "rgba(60, 66, 66, 0.1)",
    modalBackdrop: "rgba(0, 0, 0, 0.3)",
    modalBackground: "#FFF",
    modalBorder: "transparent",
    modalText: "#25292E",
    modalTextDim: "rgba(60, 66, 66, 0.3)",
    modalTextSecondary: "rgba(60, 66, 66, 0.6)",
    profileAction: "#FFF",
    profileActionHover: "rgba(255, 255, 255, 0.5)",
    profileForeground: "rgba(60, 66, 66, 0.06)",
    selectedOptionBorder: "rgba(60, 66, 66, 0.1)",
    standby: "#FFD641"
  },
  shadows: {
    connectButton: "0px 4px 12px rgba(0, 0, 0, 0.1)",
    dialog: "0px 8px 32px rgba(0, 0, 0, 0.32)",
    profileDetailsAction: "0px 2px 6px rgba(37, 41, 46, 0.04)",
    selectedOption: "0px 2px 6px rgba(0, 0, 0, 0.24)",
    selectedWallet: "0px 2px 6px rgba(0, 0, 0, 0.12)",
    walletLogo: "0px 2px 16px rgba(0, 0, 0, 0.16)"
  }
});
sw.accentColors = pT;
var gk = `{
  "connect_wallet": {
    "label": "Connect Wallet",
    "wrong_network": {
      "label": "Wrong network"
    }
  },

  "intro": {
    "title": "What is a Wallet?",
    "description": "A wallet is used to send, receive, store, and display digital assets. It's also a new way to log in, without needing to create new accounts and passwords on every website.",
    "digital_asset": {
      "title": "A Home for your Digital Assets",
      "description": "Wallets are used to send, receive, store, and display digital assets like Ethereum and NFTs."
    },
    "login": {
      "title": "A New Way to Log In",
      "description": "Instead of creating new accounts and passwords on every website, just connect your wallet."
    },
    "get": {
      "label": "Get a Wallet"
    },
    "learn_more": {
      "label": "Learn More"
    }
  },

  "sign_in": {
    "label": "Verify your account",
    "description": "To finish connecting, you must sign a message in your wallet to verify that you are the owner of this account.",
    "message": {
      "send": "Sign message",
      "preparing": "Preparing message...",
      "cancel": "Cancel",
      "preparing_error": "Error preparing message, please retry!"
    },
    "signature": {
      "waiting": "Waiting for signature...",
      "verifying": "Verifying signature...",
      "signing_error": "Error signing message, please retry!",
      "verifying_error": "Error verifying signature, please retry!",
      "oops_error": "Oops, something went wrong!"
    }
  },

  "connect": {
    "label": "Connect",
    "title": "Connect a Wallet",
    "new_to_ethereum": {
      "description": "New to Ethereum wallets?",
      "learn_more": {
        "label": "Learn More"
      }
    },
    "learn_more": {
      "label": "Learn more"
    },
    "recent": "Recent",
    "status": {
      "opening": "Opening %{wallet}...",
      "connecting": "Connecting",
      "connect_mobile": "Continue in %{wallet}",
      "not_installed": "%{wallet} is not installed",
      "not_available": "%{wallet} is not available",
      "confirm": "Confirm connection in the extension",
      "confirm_mobile": "Accept connection request in the wallet"
    },
    "secondary_action": {
      "get": {
        "description": "Don't have %{wallet}?",
        "label": "GET"
      },
      "install": {
        "label": "INSTALL"
      },
      "retry": {
        "label": "RETRY"
      }
    },
    "walletconnect": {
      "description": {
        "full": "Need the official WalletConnect modal?",
        "compact": "Need the WalletConnect modal?"
      },
      "open": {
        "label": "OPEN"
      }
    }
  },

  "connect_scan": {
    "title": "Scan with %{wallet}",
    "fallback_title": "Scan with your phone"
  },

  "connector_group": {
    "installed": "Installed",
    "recommended": "Recommended",
    "other": "Other",
    "popular": "Popular",
    "more": "More",
    "others": "Others"
  },

  "get": {
    "title": "Get a Wallet",
    "action": {
      "label": "GET"
    },
    "mobile": {
      "description": "Mobile Wallet"
    },
    "extension": {
      "description": "Browser Extension"
    },
    "mobile_and_extension": {
      "description": "Mobile Wallet and Extension"
    },
    "mobile_and_desktop": {
      "description": "Mobile and Desktop Wallet"
    },
    "looking_for": {
      "title": "Not what you're looking for?",
      "mobile": {
        "description": "Select a wallet on the main screen to get started with a different wallet provider."
      },
      "desktop": {
        "compact_description": "Select a wallet on the main screen to get started with a different wallet provider.",
        "wide_description": "Select a wallet on the left to get started with a different wallet provider."
      }
    }
  },

  "get_options": {
    "title": "Get started with %{wallet}",
    "short_title": "Get %{wallet}",
    "mobile": {
      "title": "%{wallet} for Mobile",
      "description": "Use the mobile wallet to explore the world of Ethereum.",
      "download": {
        "label": "Get the app"
      }
    },
    "extension": {
      "title": "%{wallet} for %{browser}",
      "description": "Access your wallet right from your favorite web browser.",
      "download": {
        "label": "Add to %{browser}"
      }
    },
    "desktop": {
      "title": "%{wallet} for %{platform}",
      "description": "Access your wallet natively from your powerful desktop.",
      "download": {
        "label": "Add to %{platform}"
      }
    }
  },

  "get_mobile": {
    "title": "Install %{wallet}",
    "description": "Scan with your phone to download on iOS or Android",
    "continue": {
      "label": "Continue"
    }
  },

  "get_instructions": {
    "mobile": {
      "connect": {
        "label": "Connect"
      },
      "learn_more": {
        "label": "Learn More"
      }
    },
    "extension": {
      "refresh": {
        "label": "Refresh"
      },
      "learn_more": {
        "label": "Learn More"
      }
    },
    "desktop": {
      "connect": {
        "label": "Connect"
      },
      "learn_more": {
        "label": "Learn More"
      }
    }
  },

  "chains": {
    "title": "Switch Networks",
    "wrong_network": "Wrong network detected, switch or disconnect to continue.",
    "confirm": "Confirm in Wallet",
    "confirm_error": "Error switching chain",
    "switching_not_supported": "Your wallet does not support switching networks from %{appName}. Try switching networks from within your wallet instead.",
    "switching_not_supported_fallback": "Your wallet does not support switching networks from this app. Try switching networks from within your wallet instead.",
    "disconnect": "Disconnect",
    "connected": "Connected"
  },

  "profile": {
    "disconnect": {
      "label": "Disconnect"
    },
    "copy_address": {
      "label": "Copy Address",
      "copied": "Copied!"
    },
    "explorer": {
      "label": "View more on explorer"
    },
    "transactions": {
      "description": "%{appName} transactions will appear here...",
      "description_fallback": "Your transactions will appear here...",
      "recent": {
        "title": "Recent Transactions"
      },
      "clear": {
        "label": "Clear All"
      }
    }
  },

  "wallet_connectors": {
    "argent": {
      "qr_code": {
        "step1": {
          "description": "Put Argent on your home screen for faster access to your wallet.",
          "title": "Open the Argent app"
        },
        "step2": {
          "description": "Create a wallet and username, or import an existing wallet.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "After you scan, a connection prompt will appear for you to connect your wallet.",
          "title": "Tap the Scan QR button"
        }
      }
    },

    "bifrost": {
      "qr_code": {
        "step1": {
          "description": "We recommend putting Bifrost Wallet on your home screen for quicker access.",
          "title": "Open the Bifrost Wallet app"
        },
        "step2": {
          "description": "Create or import a wallet using your recovery phrase.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "After you scan, a connection prompt will appear for you to connect your wallet.",
          "title": "Tap the scan button"
        }
      }
    },

    "bitget": {
      "qr_code": {
        "step1": {
          "description": "We recommend putting Bitget Wallet on your home screen for quicker access.",
          "title": "Open the Bitget Wallet app"
        },
        "step2": {
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "After you scan, a connection prompt will appear for you to connect your wallet.",
          "title": "Tap the scan button"
        }
      },

      "extension": {
        "step1": {
          "description": "We recommend pinning Bitget Wallet to your taskbar for quicker access to your wallet.",
          "title": "Install the Bitget Wallet extension"
        },
        "step2": {
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension.",
          "title": "Refresh your browser"
        }
      }
    },

    "bitski": {
      "extension": {
        "step1": {
          "description": "We recommend pinning Bitski to your taskbar for quicker access to your wallet.",
          "title": "Install the Bitski extension"
        },
        "step2": {
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension.",
          "title": "Refresh your browser"
        }
      }
    },

    "bitverse": {
      "qr_code": {
        "step1": {
          "title": "Open the Bitverse Wallet app",
          "description": "Add Bitverse Wallet to your home screen for faster access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Create a new wallet or import an existing one."
        },
        "step3": {
          "title": "Tap the QR icon and scan",
          "description": "Tap the QR icon on your homescreen, scan the code and confirm the prompt to connect."
        }
      }
    },

    "bloom": {
      "desktop": {
        "step1": {
          "title": "Open the Bloom Wallet app",
          "description": "We recommend putting Bloom Wallet on your home screen for quicker access."
        },
        "step2": {
          "description": "Create or import a wallet using your recovery phrase.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "After you have a wallet, click on Connect to connect via Bloom. A connection prompt in the app will appear for you to confirm the connection.",
          "title": "Click on Connect"
        }
      },
      "qr_code": {
        "step1": {
          "title": "Open the Bloom Wallet app",
          "description": "We recommend putting Bloom Wallet on your home screen for quicker access."
        },
        "step2": {
          "description": "Create or import a wallet using your recovery phrase.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "After you have a wallet, click on Connect to connect via Bloom. A connection prompt in the app will appear for you to confirm the connection.",
          "title": "Click on Connect"
        }
      }
    },

    "bybit": {
      "qr_code": {
        "step1": {
          "description": "We recommend putting Bybit on your home screen for faster access to your wallet.",
          "title": "Open the Bybit app"
        },
        "step2": {
          "description": "You can easily backup your wallet using our backup feature on your phone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "After you scan, a connection prompt will appear for you to connect your wallet.",
          "title": "Tap the scan button"
        }
      },

      "extension": {
        "step1": {
          "description": "Click at the top right of your browser and pin Bybit Wallet for easy access.",
          "title": "Install the Bybit Wallet extension"
        },
        "step2": {
          "description": "Create a new wallet or import an existing one.",
          "title": "Create or Import a wallet"
        },
        "step3": {
          "description": "Once you set up Bybit Wallet, click below to refresh the browser and load up the extension.",
          "title": "Refresh your browser"
        }
      }
    },

    "coin98": {
      "qr_code": {
        "step1": {
          "description": "We recommend putting Coin98 Wallet on your home screen for faster access to your wallet.",
          "title": "Open the Coin98 Wallet app"
        },
        "step2": {
          "description": "You can easily backup your wallet using our backup feature on your phone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "After you scan, a connection prompt will appear for you to connect your wallet.",
          "title": "Tap the WalletConnect button"
        }
      },

      "extension": {
        "step1": {
          "description": "Click at the top right of your browser and pin Coin98 Wallet for easy access.",
          "title": "Install the Coin98 Wallet extension"
        },
        "step2": {
          "description": "Create a new wallet or import an existing one.",
          "title": "Create or Import a wallet"
        },
        "step3": {
          "description": "Once you set up Coin98 Wallet, click below to refresh the browser and load up the extension.",
          "title": "Refresh your browser"
        }
      }
    },

    "coinbase": {
      "qr_code": {
        "step1": {
          "description": "We recommend putting Coinbase Wallet on your home screen for quicker access.",
          "title": "Open the Coinbase Wallet app"
        },
        "step2": {
          "description": "You can easily backup your wallet using the cloud backup feature.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "After you scan, a connection prompt will appear for you to connect your wallet.",
          "title": "Tap the scan button"
        }
      },

      "extension": {
        "step1": {
          "description": "We recommend pinning Coinbase Wallet to your taskbar for quicker access to your wallet.",
          "title": "Install the Coinbase Wallet extension"
        },
        "step2": {
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension.",
          "title": "Refresh your browser"
        }
      }
    },

    "compass": {
      "extension": {
        "step1": {
          "description": "We recommend pinning Compass Wallet to your taskbar for quicker access to your wallet.",
          "title": "Install the Compass Wallet extension"
        },
        "step2": {
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension.",
          "title": "Refresh your browser"
        }
      }
    },

    "core": {
      "qr_code": {
        "step1": {
          "description": "We recommend putting Core on your home screen for faster access to your wallet.",
          "title": "Open the Core app"
        },
        "step2": {
          "description": "You can easily backup your wallet using our backup feature on your phone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "After you scan, a connection prompt will appear for you to connect your wallet.",
          "title": "Tap the WalletConnect button"
        }
      },

      "extension": {
        "step1": {
          "description": "We recommend pinning Core to your taskbar for quicker access to your wallet.",
          "title": "Install the Core extension"
        },
        "step2": {
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension.",
          "title": "Refresh your browser"
        }
      }
    },

    "fox": {
      "qr_code": {
        "step1": {
          "description": "We recommend putting FoxWallet on your home screen for quicker access.",
          "title": "Open the FoxWallet app"
        },
        "step2": {
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "After you scan, a connection prompt will appear for you to connect your wallet.",
          "title": "Tap the scan button"
        }
      }
    },

    "frontier": {
      "qr_code": {
        "step1": {
          "description": "We recommend putting Frontier Wallet on your home screen for quicker access.",
          "title": "Open the Frontier Wallet app"
        },
        "step2": {
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "After you scan, a connection prompt will appear for you to connect your wallet.",
          "title": "Tap the scan button"
        }
      },

      "extension": {
        "step1": {
          "description": "We recommend pinning Frontier Wallet to your taskbar for quicker access to your wallet.",
          "title": "Install the Frontier Wallet extension"
        },
        "step2": {
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension.",
          "title": "Refresh your browser"
        }
      }
    },

    "im_token": {
      "qr_code": {
        "step1": {
          "title": "Open the imToken app",
          "description": "Put imToken app on your home screen for faster access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Create a new wallet or import an existing one."
        },
        "step3": {
          "title": "Tap Scanner Icon in top right corner",
          "description": "Choose New Connection, then scan the QR code and confirm the prompt to connect."
        }
      }
    },

    "kaikas": {
      "extension": {
        "step1": {
          "description": "We recommend pinning Kaikas to your taskbar for quicker access to your wallet.",
          "title": "Install the Kaikas extension"
        },
        "step2": {
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension.",
          "title": "Refresh your browser"
        }
      },
      "qr_code": {
        "step1": {
          "title": "Open the Kaikas app",
          "description": "Put Kaikas app on your home screen for faster access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Create a new wallet or import an existing one."
        },
        "step3": {
          "title": "Tap Scanner Icon in top right corner",
          "description": "Choose New Connection, then scan the QR code and confirm the prompt to connect."
        }
      }
    },

    "kraken": {
      "qr_code": {
        "step1": {
          "title": "Open the Kraken Wallet app",
          "description": "Add Kraken Wallet to your home screen for faster access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Create a new wallet or import an existing one."
        },
        "step3": {
          "title": "Tap the QR icon and scan",
          "description": "Tap the QR icon on your homescreen, scan the code and confirm the prompt to connect."
        }
      }
    },

    "kresus": {
      "qr_code": {
        "step1": {
          "title": "Open the Kresus Wallet app",
          "description": "Add Kresus Wallet to your home screen for faster access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Create a new wallet or import an existing one."
        },
        "step3": {
          "title": "Tap the QR icon and scan",
          "description": "Tap the QR icon on your homescreen, scan the code and confirm the prompt to connect."
        }
      }
    },

    "magicEden": {
      "extension": {
        "step1": {
          "title": "Install the Magic Eden extension",
          "description": "We recommend pinning Magic Eden to your taskbar for easier access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret recovery phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "metamask": {
      "qr_code": {
        "step1": {
          "title": "Open the MetaMask app",
          "description": "We recommend putting MetaMask on your home screen for quicker access."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Tap the scan button",
          "description": "After you scan, a connection prompt will appear for you to connect your wallet."
        }
      },

      "extension": {
        "step1": {
          "title": "Install the MetaMask extension",
          "description": "We recommend pinning MetaMask to your taskbar for quicker access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "nestwallet": {
      "extension": {
        "step1": {
          "title": "Install the NestWallet extension",
          "description": "We recommend pinning NestWallet to your taskbar for quicker access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "okx": {
      "qr_code": {
        "step1": {
          "title": "Open the OKX Wallet app",
          "description": "We recommend putting OKX Wallet on your home screen for quicker access."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Tap the scan button",
          "description": "After you scan, a connection prompt will appear for you to connect your wallet."
        }
      },

      "extension": {
        "step1": {
          "title": "Install the OKX Wallet extension",
          "description": "We recommend pinning OKX Wallet to your taskbar for quicker access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "omni": {
      "qr_code": {
        "step1": {
          "title": "Open the Omni app",
          "description": "Add Omni to your home screen for faster access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Create a new wallet or import an existing one."
        },
        "step3": {
          "title": "Tap the QR icon and scan",
          "description": "Tap the QR icon on your home screen, scan the code and confirm the prompt to connect."
        }
      }
    },

    "1inch": {
      "qr_code": {
        "step1": {
          "description": "Put 1inch Wallet on your home screen for faster access to your wallet.",
          "title": "Open the 1inch Wallet app"
        },
        "step2": {
          "description": "Create a wallet and username, or import an existing wallet.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "After you scan, a connection prompt will appear for you to connect your wallet.",
          "title": "Tap the Scan QR button"
        }
      }
    },

    "token_pocket": {
      "qr_code": {
        "step1": {
          "title": "Open the TokenPocket app",
          "description": "We recommend putting TokenPocket on your home screen for quicker access."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Tap the scan button",
          "description": "After you scan, a connection prompt will appear for you to connect your wallet."
        }
      },

      "extension": {
        "step1": {
          "title": "Install the TokenPocket extension",
          "description": "We recommend pinning TokenPocket to your taskbar for quicker access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "trust": {
      "qr_code": {
        "step1": {
          "title": "Open the Trust Wallet app",
          "description": "Put Trust Wallet on your home screen for faster access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Create a new wallet or import an existing one."
        },
        "step3": {
          "title": "Tap WalletConnect in Settings",
          "description": "Choose New Connection, then scan the QR code and confirm the prompt to connect."
        }
      },

      "extension": {
        "step1": {
          "title": "Install the Trust Wallet extension",
          "description": "Click at the top right of your browser and pin Trust Wallet for easy access."
        },
        "step2": {
          "title": "Create or Import a wallet",
          "description": "Create a new wallet or import an existing one."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up Trust Wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "uniswap": {
      "qr_code": {
        "step1": {
          "title": "Open the Uniswap app",
          "description": "Add Uniswap Wallet to your home screen for faster access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Create a new wallet or import an existing one."
        },
        "step3": {
          "title": "Tap the QR icon and scan",
          "description": "Tap the QR icon on your homescreen, scan the code and confirm the prompt to connect."
        }
      }
    },

    "zerion": {
      "qr_code": {
        "step1": {
          "title": "Open the Zerion app",
          "description": "We recommend putting Zerion on your home screen for quicker access."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Tap the scan button",
          "description": "After you scan, a connection prompt will appear for you to connect your wallet."
        }
      },

      "extension": {
        "step1": {
          "title": "Install the Zerion extension",
          "description": "We recommend pinning Zerion to your taskbar for quicker access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "rainbow": {
      "qr_code": {
        "step1": {
          "title": "Open the Rainbow app",
          "description": "We recommend putting Rainbow on your home screen for faster access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "You can easily backup your wallet using our backup feature on your phone."
        },
        "step3": {
          "title": "Tap the scan button",
          "description": "After you scan, a connection prompt will appear for you to connect your wallet."
        }
      }
    },

    "enkrypt": {
      "extension": {
        "step1": {
          "description": "We recommend pinning Enkrypt Wallet to your taskbar for quicker access to your wallet.",
          "title": "Install the Enkrypt Wallet extension"
        },
        "step2": {
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension.",
          "title": "Refresh your browser"
        }
      }
    },

    "frame": {
      "extension": {
        "step1": {
          "description": "We recommend pinning Frame to your taskbar for quicker access to your wallet.",
          "title": "Install Frame & the companion extension"
        },
        "step2": {
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension.",
          "title": "Refresh your browser"
        }
      }
    },

    "one_key": {
      "extension": {
        "step1": {
          "title": "Install the OneKey Wallet extension",
          "description": "We recommend pinning OneKey Wallet to your taskbar for quicker access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "phantom": {
      "extension": {
        "step1": {
          "title": "Install the Phantom extension",
          "description": "We recommend pinning Phantom to your taskbar for easier access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret recovery phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "rabby": {
      "extension": {
        "step1": {
          "title": "Install the Rabby extension",
          "description": "We recommend pinning Rabby to your taskbar for quicker access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "ronin": {
      "qr_code": {
        "step1": {
          "description": "We recommend putting Ronin Wallet on your home screen for quicker access.",
          "title": "Open the Ronin Wallet app"
        },
        "step2": {
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "After you scan, a connection prompt will appear for you to connect your wallet.",
          "title": "Tap the scan button"
        }
      },

      "extension": {
        "step1": {
          "description": "We recommend pinning Ronin Wallet to your taskbar for quicker access to your wallet.",
          "title": "Install the Ronin Wallet extension"
        },
        "step2": {
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
          "title": "Create or Import a Wallet"
        },
        "step3": {
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension.",
          "title": "Refresh your browser"
        }
      }
    },

    "ramper": {
      "extension": {
        "step1": {
          "title": "Install the Ramper extension",
          "description": "We recommend pinning Ramper to your taskbar for easier access to your wallet."
        },
        "step2": {
          "title": "Create a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "safeheron": {
      "extension": {
        "step1": {
          "title": "Install the Core extension",
          "description": "We recommend pinning Safeheron to your taskbar for quicker access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "taho": {
      "extension": {
        "step1": {
          "title": "Install the Taho extension",
          "description": "We recommend pinning Taho to your taskbar for quicker access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "talisman": {
      "extension": {
        "step1": {
          "title": "Install the Talisman extension",
          "description": "We recommend pinning Talisman to your taskbar for quicker access to your wallet."
        },
        "step2": {
          "title": "Create or Import an Ethereum Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your recovery phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "xdefi": {
      "extension": {
        "step1": {
          "title": "Install the XDEFI Wallet extension",
          "description": "We recommend pinning XDEFI Wallet to your taskbar for quicker access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "zeal": {
      "extension": {
        "step1": {
          "title": "Install the Zeal extension",
          "description": "We recommend pinning Zeal to your taskbar for quicker access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "safepal": {
      "extension": {
        "step1": {
          "title": "Install the SafePal Wallet extension",
          "description": "Click at the top right of your browser and pin SafePal Wallet for easy access."
        },
        "step2": {
          "title": "Create or Import a wallet",
          "description": "Create a new wallet or import an existing one."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up SafePal Wallet, click below to refresh the browser and load up the extension."
        }
      },
      "qr_code": {
        "step1": {
          "title": "Open the SafePal Wallet app",
          "description": "Put SafePal Wallet on your home screen for faster access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Create a new wallet or import an existing one."
        },
        "step3": {
          "title": "Tap WalletConnect in Settings",
          "description": "Choose New Connection, then scan the QR code and confirm the prompt to connect."
        }
      }
    },

    "desig": {
      "extension": {
        "step1": {
          "title": "Install the Desig extension",
          "description": "We recommend pinning Desig to your taskbar for easier access to your wallet."
        },
        "step2": {
          "title": "Create a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      }
    },

    "subwallet": {
      "extension": {
        "step1": {
          "title": "Install the SubWallet extension",
          "description": "We recommend pinning SubWallet to your taskbar for quicker access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your recovery phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      },
      "qr_code": {
        "step1": {
          "title": "Open the SubWallet app",
          "description": "We recommend putting SubWallet on your home screen for quicker access."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Tap the scan button",
          "description": "After you scan, a connection prompt will appear for you to connect your wallet."
        }
      }
    },

    "clv": {
      "extension": {
        "step1": {
          "title": "Install the CLV Wallet extension",
          "description": "We recommend pinning CLV Wallet to your taskbar for quicker access to your wallet."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Refresh your browser",
          "description": "Once you set up your wallet, click below to refresh the browser and load up the extension."
        }
      },
      "qr_code": {
        "step1": {
          "title": "Open the CLV Wallet app",
          "description": "We recommend putting CLV Wallet on your home screen for quicker access."
        },
        "step2": {
          "title": "Create or Import a Wallet",
          "description": "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone."
        },
        "step3": {
          "title": "Tap the scan button",
          "description": "After you scan, a connection prompt will appear for you to connect your wallet."
        }
      }
    },

    "okto": {
      "qr_code": {
        "step1": {
          "title": "Open the Okto app",
          "description": "Add Okto to your home screen for quick access"
        },
        "step2": {
          "title": "Create an MPC Wallet",
          "description": "Create an account and generate a wallet"
        },
        "step3": {
          "title": "Tap WalletConnect in Settings",
          "description": "Tap the Scan QR icon at the top right and confirm the prompt to connect."
        }
      }
    },

    "ledger": {
      "desktop": {
        "step1": {
          "title": "Open the Ledger Live app",
          "description": "We recommend putting Ledger Live on your home screen for quicker access."
        },
        "step2": {
          "title": "Set up your Ledger",
          "description": "Set up a new Ledger or connect to an existing one."
        },
        "step3": {
          "title": "Connect",
          "description": "A connection prompt will appear for you to connect your wallet."
        }
      },
      "qr_code": {
        "step1": {
          "title": "Open the Ledger Live app",
          "description": "We recommend putting Ledger Live on your home screen for quicker access."
        },
        "step2": {
          "title": "Set up your Ledger",
          "description": "You can either sync with the desktop app or connect your Ledger."
        },
        "step3": {
          "title": "Scan the code",
          "description": "Tap WalletConnect then Switch to Scanner. After you scan, a connection prompt will appear for you to connect your wallet."
        }
      }
    }
  }
}
`;
function J9(e, t) {
  return Object.defineProperty(e, "__recipe__", {
    value: t,
    writable: !1
  }), e;
}
var yT = J9;
function mT(e) {
  var {
    conditions: t
  } = e;
  if (!t)
    throw new Error("Styles have no conditions");
  function n(r) {
    if (typeof r == "string" || typeof r == "number" || typeof r == "boolean") {
      if (!t.defaultCondition)
        throw new Error("No default condition");
      return {
        [t.defaultCondition]: r
      };
    }
    if (Array.isArray(r)) {
      if (!("responsiveArray" in t))
        throw new Error("Responsive arrays are not supported");
      var i = {};
      for (var o in t.responsiveArray)
        r[o] != null && (i[t.responsiveArray[o]] = r[o]);
      return i;
    }
    return r;
  }
  return yT(n, {
    importPath: "@vanilla-extract/sprinkles/createUtils",
    importName: "createNormalizeValueFn",
    args: [{
      conditions: e.conditions
    }]
  });
}
function X9(e) {
  var {
    conditions: t
  } = e;
  if (!t)
    throw new Error("Styles have no conditions");
  var n = mT(e);
  function r(i, o) {
    if (typeof i == "string" || typeof i == "number" || typeof i == "boolean") {
      if (!t.defaultCondition)
        throw new Error("No default condition");
      return o(i, t.defaultCondition);
    }
    var s = Array.isArray(i) ? n(i) : i, a = {};
    for (var l in s)
      s[l] != null && (a[l] = o(s[l], l));
    return a;
  }
  return yT(r, {
    importPath: "@vanilla-extract/sprinkles/createUtils",
    importName: "createMapValueFn",
    args: [{
      conditions: e.conditions
    }]
  });
}
function Z9(e, t) {
  if (typeof e != "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function eU(e) {
  var t = Z9(e, "string");
  return typeof t == "symbol" ? t : String(t);
}
function tU(e, t, n) {
  return t = eU(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function vk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vk(Object(n), !0).forEach(function(r) {
      tU(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var nU = (e) => function() {
  for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
    n[r] = arguments[r];
  var i = Object.assign({}, ...n.map((l) => l.styles)), o = Object.keys(i), s = o.filter((l) => "mappings" in i[l]), a = (l) => {
    var c = [], u = {}, d = qm({}, l), f = !1;
    for (var h of s) {
      var p = l[h];
      if (p != null) {
        var m = i[h];
        f = !0;
        for (var g of m.mappings)
          u[g] = p, d[g] == null && delete d[g];
      }
    }
    var v = f ? qm(qm({}, u), d) : l, w = function() {
      var k = v[x], A = i[x];
      try {
        if (A.mappings)
          return "continue";
        if (typeof k == "string" || typeof k == "number") {
          if (ke.env.NODE_ENV !== "production" && !A.values[k].defaultClass)
            throw new Error();
          c.push(A.values[k].defaultClass);
        } else if (Array.isArray(k))
          for (var b = 0; b < k.length; b++) {
            var T = k[b];
            if (T != null) {
              var R = A.responsiveArray[b];
              if (ke.env.NODE_ENV !== "production" && !A.values[T].conditions[R])
                throw new Error();
              c.push(A.values[T].conditions[R]);
            }
          }
        else
          for (var B in k) {
            var O = k[B];
            if (O != null) {
              if (ke.env.NODE_ENV !== "production" && !A.values[O].conditions[B])
                throw new Error();
              c.push(A.values[O].conditions[B]);
            }
          }
      } catch ($) {
        if (ke.env.NODE_ENV !== "production") {
          class ie extends Error {
            constructor(ae) {
              super(ae), this.name = "SprinklesError";
            }
          }
          var L = (he) => typeof he == "string" ? '"'.concat(he, '"') : he, V = (he, ae, se) => {
            throw new ie('"'.concat(he, '" has no value ').concat(L(ae), ". Possible values are ").concat(Object.keys(se).map(L).join(", ")));
          };
          if (!A)
            throw new ie('"'.concat(x, '" is not a valid sprinkle'));
          if ((typeof k == "string" || typeof k == "number") && (k in A.values || V(x, k, A.values), !A.values[k].defaultClass))
            throw new ie('"'.concat(x, '" has no default condition. You must specify which conditions to target explicitly. Possible options are ').concat(Object.keys(A.values[k].conditions).map(L).join(", ")));
          if (typeof k == "object") {
            if (!("conditions" in A.values[Object.keys(A.values)[0]]))
              throw new ie('"'.concat(x, '" is not a conditional property'));
            if (Array.isArray(k)) {
              if (!("responsiveArray" in A))
                throw new ie('"'.concat(x, '" does not support responsive arrays'));
              var N = A.responsiveArray.length;
              if (N < k.length)
                throw new ie('"'.concat(x, '" only supports up to ').concat(N, " breakpoints. You passed ").concat(k.length));
              for (var M of k)
                A.values[M] || V(x, M, A.values);
            } else
              for (var U in k) {
                var F = k[U];
                if (F != null && (A.values[F] || V(x, F, A.values), !A.values[F].conditions[U]))
                  throw new ie('"'.concat(x, '" has no condition named ').concat(L(U), ". Possible values are ").concat(Object.keys(A.values[F].conditions).map(L).join(", ")));
              }
          }
        }
        throw $;
      }
    };
    for (var x in v)
      var C = w();
    return e(c.join(" "));
  };
  return Object.assign(a, {
    properties: new Set(o)
  });
}, rU = (e) => e, iU = function() {
  return nU(rU)(...arguments);
};
const gT = "2.21.8";
let _f = {
  getDocsUrl: ({ docsBaseUrl: e, docsPath: t = "", docsSlug: n }) => t ? `${e ?? "https://viem.sh"}${t}${n ? `#${n}` : ""}` : void 0,
  version: gT
}, be = class tb extends Error {
  constructor(t, n = {}) {
    var a;
    const r = (() => {
      var l;
      return n.cause instanceof tb ? n.cause.details : (l = n.cause) != null && l.message ? n.cause.message : n.details;
    })(), i = n.cause instanceof tb && n.cause.docsPath || n.docsPath, o = (a = _f.getDocsUrl) == null ? void 0 : a.call(_f, { ...n, docsPath: i }), s = [
      t || "An error occurred.",
      "",
      ...n.metaMessages ? [...n.metaMessages, ""] : [],
      ...o ? [`Docs: ${o}`] : [],
      ...r ? [`Details: ${r}`] : [],
      `Version: ${_f.version}`
    ].join(`
`);
    super(s, n.cause ? { cause: n.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseError"
    }), this.details = r, this.docsPath = i, this.metaMessages = n.metaMessages, this.name = n.name ?? this.name, this.shortMessage = t, this.version = gT;
  }
  walk(t) {
    return vT(this, t);
  }
};
function vT(e, t) {
  return t != null && t(e) ? e : e && typeof e == "object" && "cause" in e ? vT(e.cause, t) : t ? null : e;
}
class oU extends be {
  constructor({ max: t, min: n, signed: r, size: i, value: o }) {
    super(`Number "${o}" is not in safe ${i ? `${i * 8}-bit ${r ? "signed" : "unsigned"} ` : ""}integer range ${t ? `(${n} to ${t})` : `(above ${n})`}`, { name: "IntegerOutOfRangeError" });
  }
}
class sU extends be {
  constructor(t) {
    super(`Bytes value "${t}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`, {
      name: "InvalidBytesBooleanError"
    });
  }
}
class aU extends be {
  constructor({ givenSize: t, maxSize: n }) {
    super(`Size cannot exceed ${n} bytes. Given size: ${t} bytes.`, { name: "SizeOverflowError" });
  }
}
class bT extends be {
  constructor({ offset: t, position: n, size: r }) {
    super(`Slice ${n === "start" ? "starting" : "ending"} at offset "${t}" is out-of-bounds (size: ${r}).`, { name: "SliceOffsetOutOfBoundsError" });
  }
}
class wT extends be {
  constructor({ size: t, targetSize: n, type: r }) {
    super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (${t}) exceeds padding size (${n}).`, { name: "SizeExceedsPaddingSizeError" });
  }
}
class bk extends be {
  constructor({ size: t, targetSize: n, type: r }) {
    super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} is expected to be ${n} ${r} long, but is ${t} ${r} long.`, { name: "InvalidBytesLengthError" });
  }
}
function Oc(e, { dir: t, size: n = 32 } = {}) {
  return typeof e == "string" ? bs(e, { dir: t, size: n }) : lU(e, { dir: t, size: n });
}
function bs(e, { dir: t, size: n = 32 } = {}) {
  if (n === null)
    return e;
  const r = e.replace("0x", "");
  if (r.length > n * 2)
    throw new wT({
      size: Math.ceil(r.length / 2),
      targetSize: n,
      type: "hex"
    });
  return `0x${r[t === "right" ? "padEnd" : "padStart"](n * 2, "0")}`;
}
function lU(e, { dir: t, size: n = 32 } = {}) {
  if (n === null)
    return e;
  if (e.length > n)
    throw new wT({
      size: e.length,
      targetSize: n,
      type: "bytes"
    });
  const r = new Uint8Array(n);
  for (let i = 0; i < n; i++) {
    const o = t === "right";
    r[o ? i : n - i - 1] = e[o ? i : e.length - i - 1];
  }
  return r;
}
function ii(e, { strict: t = !0 } = {}) {
  return !e || typeof e != "string" ? !1 : t ? /^0x[0-9a-fA-F]*$/.test(e) : e.startsWith("0x");
}
function ln(e) {
  return ii(e, { strict: !1 }) ? Math.ceil((e.length - 2) / 2) : e.length;
}
function Ji(e, { dir: t = "left" } = {}) {
  let n = typeof e == "string" ? e.replace("0x", "") : e, r = 0;
  for (let i = 0; i < n.length - 1 && n[t === "left" ? i : n.length - i - 1].toString() === "0"; i++)
    r++;
  return n = t === "left" ? n.slice(r) : n.slice(0, n.length - r), typeof e == "string" ? (n.length === 1 && t === "right" && (n = `${n}0`), `0x${n.length % 2 === 1 ? `0${n}` : n}`) : n;
}
const cU = /* @__PURE__ */ new TextEncoder();
function Cs(e, t = {}) {
  return typeof e == "number" || typeof e == "bigint" ? dU(e, t) : typeof e == "boolean" ? uU(e, t) : ii(e) ? Ai(e, t) : ba(e, t);
}
function uU(e, t = {}) {
  const n = new Uint8Array(1);
  return n[0] = Number(e), typeof t.size == "number" ? (ro(n, { size: t.size }), Oc(n, { size: t.size })) : n;
}
const fo = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function wk(e) {
  if (e >= fo.zero && e <= fo.nine)
    return e - fo.zero;
  if (e >= fo.A && e <= fo.F)
    return e - (fo.A - 10);
  if (e >= fo.a && e <= fo.f)
    return e - (fo.a - 10);
}
function Ai(e, t = {}) {
  let n = e;
  t.size && (ro(n, { size: t.size }), n = Oc(n, { dir: "right", size: t.size }));
  let r = n.slice(2);
  r.length % 2 && (r = `0${r}`);
  const i = r.length / 2, o = new Uint8Array(i);
  for (let s = 0, a = 0; s < i; s++) {
    const l = wk(r.charCodeAt(a++)), c = wk(r.charCodeAt(a++));
    if (l === void 0 || c === void 0)
      throw new be(`Invalid byte sequence ("${r[a - 2]}${r[a - 1]}" in "${r}").`);
    o[s] = l * 16 + c;
  }
  return o;
}
function dU(e, t) {
  const n = Fe(e, t);
  return Ai(n);
}
function ba(e, t = {}) {
  const n = cU.encode(e);
  return typeof t.size == "number" ? (ro(n, { size: t.size }), Oc(n, { dir: "right", size: t.size })) : n;
}
function ro(e, { size: t }) {
  if (ln(e) > t)
    throw new aU({
      givenSize: ln(e),
      maxSize: t
    });
}
function Yn(e, t = {}) {
  const { signed: n } = t;
  t.size && ro(e, { size: t.size });
  const r = BigInt(e);
  if (!n)
    return r;
  const i = (e.length - 2) / 2, o = (1n << BigInt(i) * 8n - 1n) - 1n;
  return r <= o ? r : r - BigInt(`0x${"f".padStart(i * 2, "f")}`) - 1n;
}
function Xi(e, t = {}) {
  return Number(Yn(e, t));
}
const fU = /* @__PURE__ */ Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function $e(e, t = {}) {
  return typeof e == "number" || typeof e == "bigint" ? Fe(e, t) : typeof e == "string" ? Yl(e, t) : typeof e == "boolean" ? xT(e, t) : vn(e, t);
}
function xT(e, t = {}) {
  const n = `0x${Number(e)}`;
  return typeof t.size == "number" ? (ro(n, { size: t.size }), Oc(n, { size: t.size })) : n;
}
function vn(e, t = {}) {
  let n = "";
  for (let i = 0; i < e.length; i++)
    n += fU[e[i]];
  const r = `0x${n}`;
  return typeof t.size == "number" ? (ro(r, { size: t.size }), Oc(r, { dir: "right", size: t.size })) : r;
}
function Fe(e, t = {}) {
  const { signed: n, size: r } = t, i = BigInt(e);
  let o;
  r ? n ? o = (1n << BigInt(r) * 8n - 1n) - 1n : o = 2n ** (BigInt(r) * 8n) - 1n : typeof e == "number" && (o = BigInt(Number.MAX_SAFE_INTEGER));
  const s = typeof o == "bigint" && n ? -o - 1n : 0;
  if (o && i > o || i < s) {
    const l = typeof e == "bigint" ? "n" : "";
    throw new oU({
      max: o ? `${o}${l}` : void 0,
      min: `${s}${l}`,
      signed: n,
      size: r,
      value: `${e}${l}`
    });
  }
  const a = `0x${(n && i < 0 ? (1n << BigInt(r * 8)) + BigInt(i) : i).toString(16)}`;
  return r ? Oc(a, { size: r }) : a;
}
const hU = /* @__PURE__ */ new TextEncoder();
function Yl(e, t = {}) {
  const n = hU.encode(e);
  return vn(n, t);
}
function Io(e, { includeName: t = !1 } = {}) {
  if (e.type !== "function" && e.type !== "event" && e.type !== "error")
    throw new AU(e.type);
  return `${e.name}(${Lp(e.inputs, { includeName: t })})`;
}
function Lp(e, { includeName: t = !1 } = {}) {
  return e ? e.map((n) => pU(n, { includeName: t })).join(t ? ", " : ",") : "";
}
function pU(e, { includeName: t }) {
  return e.type.startsWith("tuple") ? `(${Lp(e.components, { includeName: t })})${e.type.slice(5)}` : e.type + (t && e.name ? ` ${e.name}` : "");
}
class yU extends be {
  constructor({ docsPath: t }) {
    super([
      "A constructor was not found on the ABI.",
      "Make sure you are using the correct ABI and that the constructor exists on it."
    ].join(`
`), {
      docsPath: t,
      name: "AbiConstructorNotFoundError"
    });
  }
}
class xk extends be {
  constructor({ docsPath: t }) {
    super([
      "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
      "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
    ].join(`
`), {
      docsPath: t,
      name: "AbiConstructorParamsNotFoundError"
    });
  }
}
class CT extends be {
  constructor({ data: t, params: n, size: r }) {
    super([`Data size of ${r} bytes is too small for given parameters.`].join(`
`), {
      metaMessages: [
        `Params: (${Lp(n, { includeName: !0 })})`,
        `Data:   ${t} (${r} bytes)`
      ],
      name: "AbiDecodingDataSizeTooSmallError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "params", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "size", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = t, this.params = n, this.size = r;
  }
}
class Up extends be {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.', {
      name: "AbiDecodingZeroDataError"
    });
  }
}
class mU extends be {
  constructor({ expectedLength: t, givenLength: n, type: r }) {
    super([
      `ABI encoding array length mismatch for type ${r}.`,
      `Expected length: ${t}`,
      `Given length: ${n}`
    ].join(`
`), { name: "AbiEncodingArrayLengthMismatchError" });
  }
}
class gU extends be {
  constructor({ expectedSize: t, value: n }) {
    super(`Size of bytes "${n}" (bytes${ln(n)}) does not match expected size (bytes${t}).`, { name: "AbiEncodingBytesSizeMismatchError" });
  }
}
class vU extends be {
  constructor({ expectedLength: t, givenLength: n }) {
    super([
      "ABI encoding params/values length mismatch.",
      `Expected length (params): ${t}`,
      `Given length (values): ${n}`
    ].join(`
`), { name: "AbiEncodingLengthMismatchError" });
  }
}
class kT extends be {
  constructor(t, { docsPath: n }) {
    super([
      `Encoded error signature "${t}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${t}.`
    ].join(`
`), {
      docsPath: n,
      name: "AbiErrorSignatureNotFoundError"
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.signature = t;
  }
}
class bU extends be {
  constructor({ docsPath: t }) {
    super("Cannot extract event signature from empty topics.", {
      docsPath: t,
      name: "AbiEventSignatureEmptyTopicsError"
    });
  }
}
class ET extends be {
  constructor(t, { docsPath: n }) {
    super([
      `Encoded event signature "${t}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the event exists on it.",
      `You can look up the signature here: https://openchain.xyz/signatures?query=${t}.`
    ].join(`
`), {
      docsPath: n,
      name: "AbiEventSignatureNotFoundError"
    });
  }
}
class Ck extends be {
  constructor(t, { docsPath: n } = {}) {
    super([
      `Event ${t ? `"${t}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the event exists on it."
    ].join(`
`), {
      docsPath: n,
      name: "AbiEventNotFoundError"
    });
  }
}
class Vh extends be {
  constructor(t, { docsPath: n } = {}) {
    super([
      `Function ${t ? `"${t}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join(`
`), {
      docsPath: n,
      name: "AbiFunctionNotFoundError"
    });
  }
}
class wU extends be {
  constructor(t, { docsPath: n }) {
    super([
      `Function "${t}" does not contain any \`outputs\` on ABI.`,
      "Cannot decode function result without knowing what the parameter types are.",
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join(`
`), {
      docsPath: n,
      name: "AbiFunctionOutputsNotFoundError"
    });
  }
}
class xU extends be {
  constructor(t, n) {
    super("Found ambiguous types in overloaded ABI items.", {
      metaMessages: [
        `\`${t.type}\` in \`${Io(t.abiItem)}\`, and`,
        `\`${n.type}\` in \`${Io(n.abiItem)}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ],
      name: "AbiItemAmbiguityError"
    });
  }
}
class CU extends be {
  constructor({ expectedSize: t, givenSize: n }) {
    super(`Expected bytes${t}, got bytes${n}.`, {
      name: "BytesSizeMismatchError"
    });
  }
}
class Fu extends be {
  constructor({ abiItem: t, data: n, params: r, size: i }) {
    super([
      `Data size of ${i} bytes is too small for non-indexed event parameters.`
    ].join(`
`), {
      metaMessages: [
        `Params: (${Lp(r, { includeName: !0 })})`,
        `Data:   ${n} (${i} bytes)`
      ],
      name: "DecodeLogDataMismatch"
    }), Object.defineProperty(this, "abiItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "params", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "size", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.abiItem = t, this.data = n, this.params = r, this.size = i;
  }
}
class zp extends be {
  constructor({ abiItem: t, param: n }) {
    super([
      `Expected a topic for indexed event parameter${n.name ? ` "${n.name}"` : ""} on event "${Io(t, { includeName: !0 })}".`
    ].join(`
`), { name: "DecodeLogTopicsMismatch" }), Object.defineProperty(this, "abiItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.abiItem = t;
  }
}
class kU extends be {
  constructor(t, { docsPath: n }) {
    super([
      `Type "${t}" is not a valid encoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: n, name: "InvalidAbiEncodingType" });
  }
}
class EU extends be {
  constructor(t, { docsPath: n }) {
    super([
      `Type "${t}" is not a valid decoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: n, name: "InvalidAbiDecodingType" });
  }
}
class SU extends be {
  constructor(t) {
    super([`Value "${t}" is not a valid array.`].join(`
`), {
      name: "InvalidArrayError"
    });
  }
}
class AU extends be {
  constructor(t) {
    super([
      `"${t}" is not a valid definition type.`,
      'Valid types: "function", "event", "error"'
    ].join(`
`), { name: "InvalidDefinitionTypeError" });
  }
}
function Ro(e) {
  return typeof e[0] == "string" ? Pi(e) : TU(e);
}
function TU(e) {
  let t = 0;
  for (const i of e)
    t += i.length;
  const n = new Uint8Array(t);
  let r = 0;
  for (const i of e)
    n.set(i, r), r += i.length;
  return n;
}
function Pi(e) {
  return `0x${e.reduce((t, n) => t + n.replace("0x", ""), "")}`;
}
class Zn extends be {
  constructor({ address: t }) {
    super(`Address "${t}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart."
      ],
      name: "InvalidAddressError"
    });
  }
}
class aw extends Map {
  constructor(t) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSize = t;
  }
  get(t) {
    const n = super.get(t);
    return super.has(t) && n !== void 0 && (this.delete(t), super.set(t, n)), n;
  }
  set(t, n) {
    if (super.set(t, n), this.maxSize && this.size > this.maxSize) {
      const r = this.keys().next().value;
      r && this.delete(r);
    }
    return this;
  }
}
function qh(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`positive integer expected, not ${e}`);
}
function _U(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
function Od(e, ...t) {
  if (!_U(e))
    throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`);
}
function IU(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  qh(e.outputLen), qh(e.blockLen);
}
function Ql(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function ST(e, t) {
  Od(e);
  const n = t.outputLen;
  if (e.length < n)
    throw new Error(`digestInto() expects output buffer of length at least ${n}`);
}
const If = /* @__PURE__ */ BigInt(2 ** 32 - 1), kk = /* @__PURE__ */ BigInt(32);
function RU(e, t = !1) {
  return t ? { h: Number(e & If), l: Number(e >> kk & If) } : { h: Number(e >> kk & If) | 0, l: Number(e & If) | 0 };
}
function PU(e, t = !1) {
  let n = new Uint32Array(e.length), r = new Uint32Array(e.length);
  for (let i = 0; i < e.length; i++) {
    const { h: o, l: s } = RU(e[i], t);
    [n[i], r[i]] = [o, s];
  }
  return [n, r];
}
const OU = (e, t, n) => e << n | t >>> 32 - n, BU = (e, t, n) => t << n | e >>> 32 - n, NU = (e, t, n) => t << n - 32 | e >>> 64 - n, DU = (e, t, n) => e << n - 32 | t >>> 64 - n, $m = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const jU = (e) => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)), Wm = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength), Fi = (e, t) => e << 32 - t | e >>> t, Ek = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, MU = (e) => e << 24 & 4278190080 | e << 8 & 16711680 | e >>> 8 & 65280 | e >>> 24 & 255;
function Sk(e) {
  for (let t = 0; t < e.length; t++)
    e[t] = MU(e[t]);
}
function FU(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function Vp(e) {
  return typeof e == "string" && (e = FU(e)), Od(e), e;
}
function LU(...e) {
  let t = 0;
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    Od(i), t += i.length;
  }
  const n = new Uint8Array(t);
  for (let r = 0, i = 0; r < e.length; r++) {
    const o = e[r];
    n.set(o, i), i += o.length;
  }
  return n;
}
class lw {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function AT(e) {
  const t = (r) => e().update(Vp(r)).digest(), n = e();
  return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = () => e(), t;
}
function UU(e = 32) {
  if ($m && typeof $m.getRandomValues == "function")
    return $m.getRandomValues(new Uint8Array(e));
  throw new Error("crypto.getRandomValues must be defined");
}
const TT = [], _T = [], IT = [], zU = /* @__PURE__ */ BigInt(0), iu = /* @__PURE__ */ BigInt(1), VU = /* @__PURE__ */ BigInt(2), qU = /* @__PURE__ */ BigInt(7), $U = /* @__PURE__ */ BigInt(256), WU = /* @__PURE__ */ BigInt(113);
for (let e = 0, t = iu, n = 1, r = 0; e < 24; e++) {
  [n, r] = [r, (2 * n + 3 * r) % 5], TT.push(2 * (5 * r + n)), _T.push((e + 1) * (e + 2) / 2 % 64);
  let i = zU;
  for (let o = 0; o < 7; o++)
    t = (t << iu ^ (t >> qU) * WU) % $U, t & VU && (i ^= iu << (iu << /* @__PURE__ */ BigInt(o)) - iu);
  IT.push(i);
}
const [GU, HU] = /* @__PURE__ */ PU(IT, !0), Ak = (e, t, n) => n > 32 ? NU(e, t, n) : OU(e, t, n), Tk = (e, t, n) => n > 32 ? DU(e, t, n) : BU(e, t, n);
function KU(e, t = 24) {
  const n = new Uint32Array(10);
  for (let r = 24 - t; r < 24; r++) {
    for (let s = 0; s < 10; s++)
      n[s] = e[s] ^ e[s + 10] ^ e[s + 20] ^ e[s + 30] ^ e[s + 40];
    for (let s = 0; s < 10; s += 2) {
      const a = (s + 8) % 10, l = (s + 2) % 10, c = n[l], u = n[l + 1], d = Ak(c, u, 1) ^ n[a], f = Tk(c, u, 1) ^ n[a + 1];
      for (let h = 0; h < 50; h += 10)
        e[s + h] ^= d, e[s + h + 1] ^= f;
    }
    let i = e[2], o = e[3];
    for (let s = 0; s < 24; s++) {
      const a = _T[s], l = Ak(i, o, a), c = Tk(i, o, a), u = TT[s];
      i = e[u], o = e[u + 1], e[u] = l, e[u + 1] = c;
    }
    for (let s = 0; s < 50; s += 10) {
      for (let a = 0; a < 10; a++)
        n[a] = e[s + a];
      for (let a = 0; a < 10; a++)
        e[s + a] ^= ~n[(a + 2) % 10] & n[(a + 4) % 10];
    }
    e[0] ^= GU[r], e[1] ^= HU[r];
  }
  n.fill(0);
}
class cw extends lw {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(t, n, r, i = !1, o = 24) {
    if (super(), this.blockLen = t, this.suffix = n, this.outputLen = r, this.enableXOF = i, this.rounds = o, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, qh(r), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = jU(this.state);
  }
  keccak() {
    Ek || Sk(this.state32), KU(this.state32, this.rounds), Ek || Sk(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(t) {
    Ql(this);
    const { blockLen: n, state: r } = this;
    t = Vp(t);
    const i = t.length;
    for (let o = 0; o < i; ) {
      const s = Math.min(n - this.pos, i - o);
      for (let a = 0; a < s; a++)
        r[this.pos++] ^= t[o++];
      this.pos === n && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: t, suffix: n, pos: r, blockLen: i } = this;
    t[r] ^= n, n & 128 && r === i - 1 && this.keccak(), t[i - 1] ^= 128, this.keccak();
  }
  writeInto(t) {
    Ql(this, !1), Od(t), this.finish();
    const n = this.state, { blockLen: r } = this;
    for (let i = 0, o = t.length; i < o; ) {
      this.posOut >= r && this.keccak();
      const s = Math.min(r - this.posOut, o - i);
      t.set(n.subarray(this.posOut, this.posOut + s), i), this.posOut += s, i += s;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return qh(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (ST(t, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: n, suffix: r, outputLen: i, rounds: o, enableXOF: s } = this;
    return t || (t = new cw(n, r, i, s, o)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = o, t.suffix = r, t.outputLen = i, t.enableXOF = s, t.destroyed = this.destroyed, t;
  }
}
const YU = (e, t, n) => AT(() => new cw(t, e, n)), QU = /* @__PURE__ */ YU(1, 136, 256 / 8);
function On(e, t) {
  const n = t || "hex", r = QU(ii(e, { strict: !1 }) ? Cs(e) : e);
  return n === "bytes" ? r : $e(r);
}
const Gm = /* @__PURE__ */ new aw(8192);
function qp(e, t) {
  if (Gm.has(`${e}.${t}`))
    return Gm.get(`${e}.${t}`);
  const n = t ? `${t}${e.toLowerCase()}` : e.substring(2).toLowerCase(), r = On(ba(n), "bytes"), i = (t ? n.substring(`${t}0x`.length) : n).split("");
  for (let s = 0; s < 40; s += 2)
    r[s >> 1] >> 4 >= 8 && i[s] && (i[s] = i[s].toUpperCase()), (r[s >> 1] & 15) >= 8 && i[s + 1] && (i[s + 1] = i[s + 1].toUpperCase());
  const o = `0x${i.join("")}`;
  return Gm.set(`${e}.${t}`, o), o;
}
function Qn(e, t) {
  if (!bn(e, { strict: !1 }))
    throw new Zn({ address: e });
  return qp(e, t);
}
const JU = /^0x[a-fA-F0-9]{40}$/, Hm = /* @__PURE__ */ new aw(8192);
function bn(e, t) {
  const { strict: n = !0 } = t ?? {}, r = `${e}.${n}`;
  if (Hm.has(r))
    return Hm.get(r);
  const i = JU.test(e) ? e.toLowerCase() === e ? !0 : n ? qp(e) === e : !0 : !1;
  return Hm.set(r, i), i;
}
function Lu(e, t, n, { strict: r } = {}) {
  return ii(e, { strict: !1 }) ? BT(e, t, n, {
    strict: r
  }) : OT(e, t, n, {
    strict: r
  });
}
function RT(e, t) {
  if (typeof t == "number" && t > 0 && t > ln(e) - 1)
    throw new bT({
      offset: t,
      position: "start",
      size: ln(e)
    });
}
function PT(e, t, n) {
  if (typeof t == "number" && typeof n == "number" && ln(e) !== n - t)
    throw new bT({
      offset: n,
      position: "end",
      size: ln(e)
    });
}
function OT(e, t, n, { strict: r } = {}) {
  RT(e, t);
  const i = e.slice(t, n);
  return r && PT(i, t, n), i;
}
function BT(e, t, n, { strict: r } = {}) {
  RT(e, t);
  const i = `0x${e.replace("0x", "").slice((t ?? 0) * 2, (n ?? e.length) * 2)}`;
  return r && PT(i, t, n), i;
}
function Bc(e, t) {
  if (e.length !== t.length)
    throw new vU({
      expectedLength: e.length,
      givenLength: t.length
    });
  const n = XU({
    params: e,
    values: t
  }), r = dw(n);
  return r.length === 0 ? "0x" : r;
}
function XU({ params: e, values: t }) {
  const n = [];
  for (let r = 0; r < e.length; r++)
    n.push(uw({ param: e[r], value: t[r] }));
  return n;
}
function uw({ param: e, value: t }) {
  const n = fw(e.type);
  if (n) {
    const [r, i] = n;
    return ez(t, { length: r, param: { ...e, type: i } });
  }
  if (e.type === "tuple")
    return oz(t, {
      param: e
    });
  if (e.type === "address")
    return ZU(t);
  if (e.type === "bool")
    return nz(t);
  if (e.type.startsWith("uint") || e.type.startsWith("int")) {
    const r = e.type.startsWith("int");
    return rz(t, { signed: r });
  }
  if (e.type.startsWith("bytes"))
    return tz(t, { param: e });
  if (e.type === "string")
    return iz(t);
  throw new kU(e.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  });
}
function dw(e) {
  let t = 0;
  for (let o = 0; o < e.length; o++) {
    const { dynamic: s, encoded: a } = e[o];
    s ? t += 32 : t += ln(a);
  }
  const n = [], r = [];
  let i = 0;
  for (let o = 0; o < e.length; o++) {
    const { dynamic: s, encoded: a } = e[o];
    s ? (n.push(Fe(t + i, { size: 32 })), r.push(a), i += ln(a)) : n.push(a);
  }
  return Ro([...n, ...r]);
}
function ZU(e) {
  if (!bn(e))
    throw new Zn({ address: e });
  return { dynamic: !1, encoded: bs(e.toLowerCase()) };
}
function ez(e, { length: t, param: n }) {
  const r = t === null;
  if (!Array.isArray(e))
    throw new SU(e);
  if (!r && e.length !== t)
    throw new mU({
      expectedLength: t,
      givenLength: e.length,
      type: `${n.type}[${t}]`
    });
  let i = !1;
  const o = [];
  for (let s = 0; s < e.length; s++) {
    const a = uw({ param: n, value: e[s] });
    a.dynamic && (i = !0), o.push(a);
  }
  if (r || i) {
    const s = dw(o);
    if (r) {
      const a = Fe(o.length, { size: 32 });
      return {
        dynamic: !0,
        encoded: o.length > 0 ? Ro([a, s]) : a
      };
    }
    if (i)
      return { dynamic: !0, encoded: s };
  }
  return {
    dynamic: !1,
    encoded: Ro(o.map(({ encoded: s }) => s))
  };
}
function tz(e, { param: t }) {
  const [, n] = t.type.split("bytes"), r = ln(e);
  if (!n) {
    let i = e;
    return r % 32 !== 0 && (i = bs(i, {
      dir: "right",
      size: Math.ceil((e.length - 2) / 2 / 32) * 32
    })), {
      dynamic: !0,
      encoded: Ro([bs(Fe(r, { size: 32 })), i])
    };
  }
  if (r !== Number.parseInt(n))
    throw new gU({
      expectedSize: Number.parseInt(n),
      value: e
    });
  return { dynamic: !1, encoded: bs(e, { dir: "right" }) };
}
function nz(e) {
  if (typeof e != "boolean")
    throw new be(`Invalid boolean value: "${e}" (type: ${typeof e}). Expected: \`true\` or \`false\`.`);
  return { dynamic: !1, encoded: bs(xT(e)) };
}
function rz(e, { signed: t }) {
  return {
    dynamic: !1,
    encoded: Fe(e, {
      size: 32,
      signed: t
    })
  };
}
function iz(e) {
  const t = Yl(e), n = Math.ceil(ln(t) / 32), r = [];
  for (let i = 0; i < n; i++)
    r.push(bs(Lu(t, i * 32, (i + 1) * 32), {
      dir: "right"
    }));
  return {
    dynamic: !0,
    encoded: Ro([
      bs(Fe(ln(t), { size: 32 })),
      ...r
    ])
  };
}
function oz(e, { param: t }) {
  let n = !1;
  const r = [];
  for (let i = 0; i < t.components.length; i++) {
    const o = t.components[i], s = Array.isArray(e) ? i : o.name, a = uw({
      param: o,
      value: e[s]
    });
    r.push(a), a.dynamic && (n = !0);
  }
  return {
    dynamic: n,
    encoded: n ? dw(r) : Ro(r.map(({ encoded: i }) => i))
  };
}
function fw(e) {
  const t = e.match(/^(.*)\[(\d+)?\]$/);
  return t ? (
    // Return `null` if the array is dynamic.
    [t[2] ? Number(t[2]) : null, t[1]]
  ) : void 0;
}
const Km = "/docs/contract/encodeDeployData";
function hw(e) {
  const { abi: t, args: n, bytecode: r } = e;
  if (!n || n.length === 0)
    return r;
  const i = t.find((s) => "type" in s && s.type === "constructor");
  if (!i)
    throw new yU({ docsPath: Km });
  if (!("inputs" in i))
    throw new xk({ docsPath: Km });
  if (!i.inputs || i.inputs.length === 0)
    throw new xk({ docsPath: Km });
  const o = Bc(i.inputs, n);
  return Pi([r, o]);
}
function ui(e) {
  return typeof e == "string" ? { address: e, type: "json-rpc" } : e;
}
class pw extends be {
  constructor({ docsPath: t } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."
    ].join(`
`), {
      docsPath: t,
      docsSlug: "account",
      name: "AccountNotFoundError"
    });
  }
}
class Ym extends be {
  constructor({ docsPath: t, metaMessages: n, type: r }) {
    super(`Account type "${r}" is not supported.`, {
      docsPath: t,
      metaMessages: n,
      name: "AccountTypeNotSupportedError"
    });
  }
}
function sz(e) {
  const t = On(`0x${e.substring(4)}`).substring(26);
  return qp(`0x${t}`);
}
async function az({ hash: e, signature: t }) {
  const n = ii(e) ? e : $e(e), { secp256k1: r } = await Promise.resolve().then(() => gW);
  return `0x${(() => {
    if (typeof t == "object" && "r" in t && "s" in t) {
      const { r: c, s: u, v: d, yParity: f } = t, h = Number(f ?? d), p = _k(h);
      return new r.Signature(Yn(c), Yn(u)).addRecoveryBit(p);
    }
    const s = ii(t) ? t : $e(t), a = Xi(`0x${s.slice(130)}`), l = _k(a);
    return r.Signature.fromCompact(s.substring(2, 130)).addRecoveryBit(l);
  })().recoverPublicKey(n.substring(2)).toHex(!1)}`;
}
function _k(e) {
  if (e === 0 || e === 1)
    return e;
  if (e === 27)
    return 0;
  if (e === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}
async function NT({ hash: e, signature: t }) {
  return sz(await az({ hash: e, signature: t }));
}
class Ik extends be {
  constructor({ offset: t }) {
    super(`Offset \`${t}\` cannot be negative.`, {
      name: "NegativeOffsetError"
    });
  }
}
class DT extends be {
  constructor({ length: t, position: n }) {
    super(`Position \`${n}\` is out of bounds (\`0 < position < ${t}\`).`, { name: "PositionOutOfBoundsError" });
  }
}
class lz extends be {
  constructor({ count: t, limit: n }) {
    super(`Recursive read limit of \`${n}\` exceeded (recursive read count: \`${t}\`).`, { name: "RecursiveReadLimitExceededError" });
  }
}
const cz = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new lz({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(e) {
    if (e < 0 || e > this.bytes.length - 1)
      throw new DT({
        length: this.bytes.length,
        position: e
      });
  },
  decrementPosition(e) {
    if (e < 0)
      throw new Ik({ offset: e });
    const t = this.position - e;
    this.assertPosition(t), this.position = t;
  },
  getReadCount(e) {
    return this.positionReadCount.get(e || this.position) || 0;
  },
  incrementPosition(e) {
    if (e < 0)
      throw new Ik({ offset: e });
    const t = this.position + e;
    this.assertPosition(t), this.position = t;
  },
  inspectByte(e) {
    const t = e ?? this.position;
    return this.assertPosition(t), this.bytes[t];
  },
  inspectBytes(e, t) {
    const n = t ?? this.position;
    return this.assertPosition(n + e - 1), this.bytes.subarray(n, n + e);
  },
  inspectUint8(e) {
    const t = e ?? this.position;
    return this.assertPosition(t), this.bytes[t];
  },
  inspectUint16(e) {
    const t = e ?? this.position;
    return this.assertPosition(t + 1), this.dataView.getUint16(t);
  },
  inspectUint24(e) {
    const t = e ?? this.position;
    return this.assertPosition(t + 2), (this.dataView.getUint16(t) << 8) + this.dataView.getUint8(t + 2);
  },
  inspectUint32(e) {
    const t = e ?? this.position;
    return this.assertPosition(t + 3), this.dataView.getUint32(t);
  },
  pushByte(e) {
    this.assertPosition(this.position), this.bytes[this.position] = e, this.position++;
  },
  pushBytes(e) {
    this.assertPosition(this.position + e.length - 1), this.bytes.set(e, this.position), this.position += e.length;
  },
  pushUint8(e) {
    this.assertPosition(this.position), this.bytes[this.position] = e, this.position++;
  },
  pushUint16(e) {
    this.assertPosition(this.position + 1), this.dataView.setUint16(this.position, e), this.position += 2;
  },
  pushUint24(e) {
    this.assertPosition(this.position + 2), this.dataView.setUint16(this.position, e >> 8), this.dataView.setUint8(this.position + 2, e & 255), this.position += 3;
  },
  pushUint32(e) {
    this.assertPosition(this.position + 3), this.dataView.setUint32(this.position, e), this.position += 4;
  },
  readByte() {
    this.assertReadLimit(), this._touch();
    const e = this.inspectByte();
    return this.position++, e;
  },
  readBytes(e, t) {
    this.assertReadLimit(), this._touch();
    const n = this.inspectBytes(e);
    return this.position += t ?? e, n;
  },
  readUint8() {
    this.assertReadLimit(), this._touch();
    const e = this.inspectUint8();
    return this.position += 1, e;
  },
  readUint16() {
    this.assertReadLimit(), this._touch();
    const e = this.inspectUint16();
    return this.position += 2, e;
  },
  readUint24() {
    this.assertReadLimit(), this._touch();
    const e = this.inspectUint24();
    return this.position += 3, e;
  },
  readUint32() {
    this.assertReadLimit(), this._touch();
    const e = this.inspectUint32();
    return this.position += 4, e;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(e) {
    const t = this.position;
    return this.assertPosition(e), this.position = e, () => this.position = t;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const e = this.getReadCount();
    this.positionReadCount.set(this.position, e + 1), e > 0 && this.recursiveReadCount++;
  }
};
function yw(e, { recursiveReadLimit: t = 8192 } = {}) {
  const n = Object.create(cz);
  return n.bytes = e, n.dataView = new DataView(e.buffer, e.byteOffset, e.byteLength), n.positionReadCount = /* @__PURE__ */ new Map(), n.recursiveReadLimit = t, n;
}
function Po(e, t = "hex") {
  const n = jT(e), r = yw(new Uint8Array(n.length));
  return n.encode(r), t === "hex" ? vn(r.bytes) : r.bytes;
}
function jT(e) {
  return Array.isArray(e) ? uz(e.map((t) => jT(t))) : dz(e);
}
function uz(e) {
  const t = e.reduce((i, o) => i + o.length, 0), n = MT(t);
  return {
    length: t <= 55 ? 1 + t : 1 + n + t,
    encode(i) {
      t <= 55 ? i.pushByte(192 + t) : (i.pushByte(247 + n), n === 1 ? i.pushUint8(t) : n === 2 ? i.pushUint16(t) : n === 3 ? i.pushUint24(t) : i.pushUint32(t));
      for (const { encode: o } of e)
        o(i);
    }
  };
}
function dz(e) {
  const t = typeof e == "string" ? Ai(e) : e, n = MT(t.length);
  return {
    length: t.length === 1 && t[0] < 128 ? 1 : t.length <= 55 ? 1 + t.length : 1 + n + t.length,
    encode(i) {
      t.length === 1 && t[0] < 128 ? i.pushBytes(t) : t.length <= 55 ? (i.pushByte(128 + t.length), i.pushBytes(t)) : (i.pushByte(183 + n), n === 1 ? i.pushUint8(t.length) : n === 2 ? i.pushUint16(t.length) : n === 3 ? i.pushUint24(t.length) : i.pushUint32(t.length), i.pushBytes(t));
    }
  };
}
function MT(e) {
  if (e < 2 ** 8)
    return 1;
  if (e < 2 ** 16)
    return 2;
  if (e < 2 ** 24)
    return 3;
  if (e < 2 ** 32)
    return 4;
  throw new be("Length is too large.");
}
function fz(e) {
  const { chainId: t, contractAddress: n, nonce: r, to: i } = e, o = On(Pi([
    "0x05",
    Po([
      Fe(t),
      n,
      r ? Fe(r) : "0x"
    ])
  ]));
  return i === "bytes" ? Ai(o) : o;
}
async function FT(e) {
  const { authorization: t, signature: n } = e;
  return NT({
    hash: fz(t),
    signature: n ?? t
  });
}
class nb extends be {
  constructor({ blockNumber: t, chain: n, contract: r }) {
    super(`Chain "${n.name}" does not support contract "${r.name}".`, {
      metaMessages: [
        "This could be due to any of the following:",
        ...t && r.blockCreated && r.blockCreated > t ? [
          `- The contract "${r.name}" was not deployed until block ${r.blockCreated} (current block ${t}).`
        ] : [
          `- The chain does not have the contract "${r.name}" configured.`
        ]
      ],
      name: "ChainDoesNotSupportContract"
    });
  }
}
class hz extends be {
  constructor({ chain: t, currentChainId: n }) {
    super(`The current chain of the wallet (id: ${n}) does not match the target chain for the transaction (id: ${t.id} – ${t.name}).`, {
      metaMessages: [
        `Current Chain ID:  ${n}`,
        `Expected Chain ID: ${t.id} – ${t.name}`
      ],
      name: "ChainMismatchError"
    });
  }
}
class pz extends be {
  constructor() {
    super([
      "No chain was provided to the request.",
      "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
    ].join(`
`), {
      name: "ChainNotFoundError"
    });
  }
}
class LT extends be {
  constructor() {
    super("No chain was provided to the Client.", {
      name: "ClientChainNotConfiguredError"
    });
  }
}
class Bd extends be {
  constructor({ chainId: t }) {
    super(typeof t == "number" ? `Chain ID "${t}" is invalid.` : "Chain ID is invalid.", { name: "InvalidChainIdError" });
  }
}
function yz({ chain: e, currentChainId: t }) {
  if (!e)
    throw new pz();
  if (t !== e.id)
    throw new hz({ chain: e, currentChainId: t });
}
const mz = {
  gwei: 9,
  wei: 18
}, gz = {
  ether: -9,
  wei: 9
};
function UT(e, t) {
  let n = e.toString();
  const r = n.startsWith("-");
  r && (n = n.slice(1)), n = n.padStart(t, "0");
  let [i, o] = [
    n.slice(0, n.length - t),
    n.slice(n.length - t)
  ];
  return o = o.replace(/(0+)$/, ""), `${r ? "-" : ""}${i || "0"}${o ? `.${o}` : ""}`;
}
function kr(e, t = "wei") {
  return UT(e, gz[t]);
}
class pl extends be {
  constructor({ cause: t, message: n } = {}) {
    var i;
    const r = (i = n == null ? void 0 : n.replace("execution reverted: ", "")) == null ? void 0 : i.replace("execution reverted", "");
    super(`Execution reverted ${r ? `with reason: ${r}` : "for an unknown reason"}.`, {
      cause: t,
      name: "ExecutionRevertedError"
    });
  }
}
Object.defineProperty(pl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 3
});
Object.defineProperty(pl, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /execution reverted/
});
class ks extends be {
  constructor({ cause: t, maxFeePerGas: n } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${n ? ` = ${kr(n)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause: t,
      name: "FeeCapTooHighError"
    });
  }
}
Object.defineProperty(ks, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class rb extends be {
  constructor({ cause: t, maxFeePerGas: n } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${n ? ` = ${kr(n)}` : ""} gwei) cannot be lower than the block base fee.`, {
      cause: t,
      name: "FeeCapTooLowError"
    });
  }
}
Object.defineProperty(rb, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
class ib extends be {
  constructor({ cause: t, nonce: n } = {}) {
    super(`Nonce provided for the transaction ${n ? `(${n}) ` : ""}is higher than the next one expected.`, { cause: t, name: "NonceTooHighError" });
  }
}
Object.defineProperty(ib, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too high/
});
class ob extends be {
  constructor({ cause: t, nonce: n } = {}) {
    super([
      `Nonce provided for the transaction ${n ? `(${n}) ` : ""}is lower than the current nonce of the account.`,
      "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
    ].join(`
`), { cause: t, name: "NonceTooLowError" });
  }
}
Object.defineProperty(ob, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too low|transaction already imported|already known/
});
class sb extends be {
  constructor({ cause: t, nonce: n } = {}) {
    super(`Nonce provided for the transaction ${n ? `(${n}) ` : ""}exceeds the maximum allowed nonce.`, { cause: t, name: "NonceMaxValueError" });
  }
}
Object.defineProperty(sb, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce has max value/
});
class ab extends be {
  constructor({ cause: t } = {}) {
    super([
      "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
    ].join(`
`), {
      cause: t,
      metaMessages: [
        "This error could arise when the account does not have enough funds to:",
        " - pay for the total gas fee,",
        " - pay for the value to send.",
        " ",
        "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
        " - `gas` is the amount of gas needed for transaction to execute,",
        " - `gas fee` is the gas fee,",
        " - `value` is the amount of ether to send to the recipient."
      ],
      name: "InsufficientFundsError"
    });
  }
}
Object.defineProperty(ab, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /insufficient funds|exceeds transaction sender account balance/
});
class lb extends be {
  constructor({ cause: t, gas: n } = {}) {
    super(`The amount of gas ${n ? `(${n}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
      cause: t,
      name: "IntrinsicGasTooHighError"
    });
  }
}
Object.defineProperty(lb, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too high|gas limit reached/
});
class cb extends be {
  constructor({ cause: t, gas: n } = {}) {
    super(`The amount of gas ${n ? `(${n}) ` : ""}provided for the transaction is too low.`, {
      cause: t,
      name: "IntrinsicGasTooLowError"
    });
  }
}
Object.defineProperty(cb, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too low/
});
class ub extends be {
  constructor({ cause: t }) {
    super("The transaction type is not supported for this chain.", {
      cause: t,
      name: "TransactionTypeNotSupportedError"
    });
  }
}
Object.defineProperty(ub, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /transaction type not valid/
});
class Jl extends be {
  constructor({ cause: t, maxPriorityFeePerGas: n, maxFeePerGas: r } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${n ? ` = ${kr(n)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${r ? ` = ${kr(r)} gwei` : ""}).`
    ].join(`
`), {
      cause: t,
      name: "TipAboveFeeCapError"
    });
  }
}
Object.defineProperty(Jl, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
class $p extends be {
  constructor({ cause: t }) {
    super(`An error occurred while executing: ${t == null ? void 0 : t.shortMessage}`, {
      cause: t,
      name: "UnknownNodeError"
    });
  }
}
function mw(e, t = "wei") {
  return UT(e, mz[t]);
}
function Nd(e) {
  const t = Object.entries(e).map(([r, i]) => i === void 0 || i === !1 ? null : [r, i]).filter(Boolean), n = t.reduce((r, [i]) => Math.max(r, i.length), 0);
  return t.map(([r, i]) => `  ${`${r}:`.padEnd(n + 1)}  ${i}`).join(`
`);
}
class vz extends be {
  constructor() {
    super([
      "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
      "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
    ].join(`
`), { name: "FeeConflictError" });
  }
}
class bz extends be {
  constructor({ v: t }) {
    super(`Invalid \`v\` value "${t}". Expected 27 or 28.`, {
      name: "InvalidLegacyVError"
    });
  }
}
class wz extends be {
  constructor({ transaction: t }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        Nd(t),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
        "- an EIP-7702 Transaction with `authorizationList`, or",
        "- a Legacy Transaction with `gasPrice`"
      ],
      name: "InvalidSerializableTransactionError"
    });
  }
}
class xz extends be {
  constructor({ storageKey: t }) {
    super(`Size for storage key "${t}" is invalid. Expected 32 bytes. Got ${Math.floor((t.length - 2) / 2)} bytes.`, { name: "InvalidStorageKeySizeError" });
  }
}
class Cz extends be {
  constructor(t, { account: n, docsPath: r, chain: i, data: o, gas: s, gasPrice: a, maxFeePerGas: l, maxPriorityFeePerGas: c, nonce: u, to: d, value: f }) {
    var p;
    const h = Nd({
      chain: i && `${i == null ? void 0 : i.name} (id: ${i == null ? void 0 : i.id})`,
      from: n == null ? void 0 : n.address,
      to: d,
      value: typeof f < "u" && `${mw(f)} ${((p = i == null ? void 0 : i.nativeCurrency) == null ? void 0 : p.symbol) || "ETH"}`,
      data: o,
      gas: s,
      gasPrice: typeof a < "u" && `${kr(a)} gwei`,
      maxFeePerGas: typeof l < "u" && `${kr(l)} gwei`,
      maxPriorityFeePerGas: typeof c < "u" && `${kr(c)} gwei`,
      nonce: u
    });
    super(t.shortMessage, {
      cause: t,
      docsPath: r,
      metaMessages: [
        ...t.metaMessages ? [...t.metaMessages, " "] : [],
        "Request Arguments:",
        h
      ].filter(Boolean),
      name: "TransactionExecutionError"
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cause = t;
  }
}
class zT extends be {
  constructor({ blockHash: t, blockNumber: n, blockTag: r, hash: i, index: o }) {
    let s = "Transaction";
    r && o !== void 0 && (s = `Transaction at block time "${r}" at index "${o}"`), t && o !== void 0 && (s = `Transaction at block hash "${t}" at index "${o}"`), n && o !== void 0 && (s = `Transaction at block number "${n}" at index "${o}"`), i && (s = `Transaction with hash "${i}"`), super(`${s} could not be found.`, {
      name: "TransactionNotFoundError"
    });
  }
}
class VT extends be {
  constructor({ hash: t }) {
    super(`Transaction receipt with hash "${t}" could not be found. The Transaction may not be processed on a block yet.`, {
      name: "TransactionReceiptNotFoundError"
    });
  }
}
class Rk extends be {
  constructor({ hash: t }) {
    super(`Timed out while waiting for transaction with hash "${t}" to be confirmed.`, { name: "WaitForTransactionReceiptTimeoutError" });
  }
}
const Jn = (e, t, n) => JSON.stringify(e, (r, i) => typeof i == "bigint" ? i.toString() : i, n), kz = (e) => e, gw = (e) => e;
class _u extends be {
  constructor({ body: t, cause: n, details: r, headers: i, status: o, url: s }) {
    super("HTTP request failed.", {
      cause: n,
      details: r,
      metaMessages: [
        o && `Status: ${o}`,
        `URL: ${gw(s)}`,
        t && `Request body: ${Jn(t)}`
      ].filter(Boolean),
      name: "HttpRequestError"
    }), Object.defineProperty(this, "body", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "status", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "url", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.body = t, this.headers = i, this.status = o, this.url = s;
  }
}
class qT extends be {
  constructor({ body: t, error: n, url: r }) {
    super("RPC Request failed.", {
      cause: n,
      details: n.message,
      metaMessages: [`URL: ${gw(r)}`, `Request body: ${Jn(t)}`],
      name: "RpcRequestError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.code = n.code;
  }
}
class Pk extends be {
  constructor({ body: t, url: n }) {
    super("The request took too long to respond.", {
      details: "The request timed out.",
      metaMessages: [`URL: ${gw(n)}`, `Request body: ${Jn(t)}`],
      name: "TimeoutError"
    });
  }
}
const Ez = -1;
class Er extends be {
  constructor(t, { code: n, docsPath: r, metaMessages: i, name: o, shortMessage: s }) {
    super(s, {
      cause: t,
      docsPath: r,
      metaMessages: i || (t == null ? void 0 : t.metaMessages),
      name: o || "RpcError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = o || t.name, this.code = t instanceof qT ? t.code : n ?? Ez;
  }
}
class Nc extends Er {
  constructor(t, n) {
    super(t, n), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = n.data;
  }
}
class Uu extends Er {
  constructor(t) {
    super(t, {
      code: Uu.code,
      name: "ParseRpcError",
      shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    });
  }
}
Object.defineProperty(Uu, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32700
});
class zu extends Er {
  constructor(t) {
    super(t, {
      code: zu.code,
      name: "InvalidRequestRpcError",
      shortMessage: "JSON is not a valid request object."
    });
  }
}
Object.defineProperty(zu, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32600
});
class Vu extends Er {
  constructor(t, { method: n } = {}) {
    super(t, {
      code: Vu.code,
      name: "MethodNotFoundRpcError",
      shortMessage: `The method${n ? ` "${n}"` : ""} does not exist / is not available.`
    });
  }
}
Object.defineProperty(Vu, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32601
});
class qu extends Er {
  constructor(t) {
    super(t, {
      code: qu.code,
      name: "InvalidParamsRpcError",
      shortMessage: [
        "Invalid parameters were provided to the RPC method.",
        "Double check you have provided the correct parameters."
      ].join(`
`)
    });
  }
}
Object.defineProperty(qu, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32602
});
class _a extends Er {
  constructor(t) {
    super(t, {
      code: _a.code,
      name: "InternalRpcError",
      shortMessage: "An internal error was received."
    });
  }
}
Object.defineProperty(_a, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32603
});
class Ia extends Er {
  constructor(t) {
    super(t, {
      code: Ia.code,
      name: "InvalidInputRpcError",
      shortMessage: [
        "Missing or invalid parameters.",
        "Double check you have provided the correct parameters."
      ].join(`
`)
    });
  }
}
Object.defineProperty(Ia, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32e3
});
class $u extends Er {
  constructor(t) {
    super(t, {
      code: $u.code,
      name: "ResourceNotFoundRpcError",
      shortMessage: "Requested resource not found."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ResourceNotFoundRpcError"
    });
  }
}
Object.defineProperty($u, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32001
});
class ws extends Er {
  constructor(t) {
    super(t, {
      code: ws.code,
      name: "ResourceUnavailableRpcError",
      shortMessage: "Requested resource not available."
    });
  }
}
Object.defineProperty(ws, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32002
});
class Wu extends Er {
  constructor(t) {
    super(t, {
      code: Wu.code,
      name: "TransactionRejectedRpcError",
      shortMessage: "Transaction creation failed."
    });
  }
}
Object.defineProperty(Wu, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32003
});
class Gu extends Er {
  constructor(t, { method: n } = {}) {
    super(t, {
      code: Gu.code,
      name: "MethodNotSupportedRpcError",
      shortMessage: `Method${n ? ` "${n}"` : ""} is not implemented.`
    });
  }
}
Object.defineProperty(Gu, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32004
});
class Xl extends Er {
  constructor(t) {
    super(t, {
      code: Xl.code,
      name: "LimitExceededRpcError",
      shortMessage: "Request exceeds defined limit."
    });
  }
}
Object.defineProperty(Xl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32005
});
class Hu extends Er {
  constructor(t) {
    super(t, {
      code: Hu.code,
      name: "JsonRpcVersionUnsupportedError",
      shortMessage: "Version of JSON-RPC protocol is not supported."
    });
  }
}
Object.defineProperty(Hu, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32006
});
class $t extends Nc {
  constructor(t) {
    super(t, {
      code: $t.code,
      name: "UserRejectedRequestError",
      shortMessage: "User rejected the request."
    });
  }
}
Object.defineProperty($t, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4001
});
class Ku extends Nc {
  constructor(t) {
    super(t, {
      code: Ku.code,
      name: "UnauthorizedProviderError",
      shortMessage: "The requested method and/or account has not been authorized by the user."
    });
  }
}
Object.defineProperty(Ku, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4100
});
class Yu extends Nc {
  constructor(t, { method: n } = {}) {
    super(t, {
      code: Yu.code,
      name: "UnsupportedProviderMethodError",
      shortMessage: `The Provider does not support the requested method${n ? ` " ${n}"` : ""}.`
    });
  }
}
Object.defineProperty(Yu, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4200
});
class Qu extends Nc {
  constructor(t) {
    super(t, {
      code: Qu.code,
      name: "ProviderDisconnectedError",
      shortMessage: "The Provider is disconnected from all chains."
    });
  }
}
Object.defineProperty(Qu, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4900
});
class Ju extends Nc {
  constructor(t) {
    super(t, {
      code: Ju.code,
      name: "ChainDisconnectedError",
      shortMessage: "The Provider is not connected to the requested chain."
    });
  }
}
Object.defineProperty(Ju, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4901
});
class oi extends Nc {
  constructor(t) {
    super(t, {
      code: oi.code,
      name: "SwitchChainError",
      shortMessage: "An error occurred when attempting to switch chain."
    });
  }
}
Object.defineProperty(oi, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4902
});
class Sz extends Er {
  constructor(t) {
    super(t, {
      name: "UnknownRpcError",
      shortMessage: "An unknown RPC error occurred."
    });
  }
}
function vw(e, t) {
  const n = (e.details || "").toLowerCase(), r = e instanceof be ? e.walk((i) => i.code === pl.code) : e;
  return r instanceof be ? new pl({
    cause: e,
    message: r.details
  }) : pl.nodeMessage.test(n) ? new pl({
    cause: e,
    message: e.details
  }) : ks.nodeMessage.test(n) ? new ks({
    cause: e,
    maxFeePerGas: t == null ? void 0 : t.maxFeePerGas
  }) : rb.nodeMessage.test(n) ? new rb({
    cause: e,
    maxFeePerGas: t == null ? void 0 : t.maxFeePerGas
  }) : ib.nodeMessage.test(n) ? new ib({ cause: e, nonce: t == null ? void 0 : t.nonce }) : ob.nodeMessage.test(n) ? new ob({ cause: e, nonce: t == null ? void 0 : t.nonce }) : sb.nodeMessage.test(n) ? new sb({ cause: e, nonce: t == null ? void 0 : t.nonce }) : ab.nodeMessage.test(n) ? new ab({ cause: e }) : lb.nodeMessage.test(n) ? new lb({ cause: e, gas: t == null ? void 0 : t.gas }) : cb.nodeMessage.test(n) ? new cb({ cause: e, gas: t == null ? void 0 : t.gas }) : ub.nodeMessage.test(n) ? new ub({ cause: e }) : Jl.nodeMessage.test(n) ? new Jl({
    cause: e,
    maxFeePerGas: t == null ? void 0 : t.maxFeePerGas,
    maxPriorityFeePerGas: t == null ? void 0 : t.maxPriorityFeePerGas
  }) : new $p({
    cause: e
  });
}
function Az(e, { docsPath: t, ...n }) {
  const r = (() => {
    const i = vw(e, n);
    return i instanceof $p ? e : i;
  })();
  return new Cz(r, {
    docsPath: t,
    ...n
  });
}
function Wp(e, { format: t }) {
  if (!t)
    return {};
  const n = {};
  function r(o) {
    const s = Object.keys(o);
    for (const a of s)
      a in e && (n[a] = e[a]), o[a] && typeof o[a] == "object" && !Array.isArray(o[a]) && r(o[a]);
  }
  const i = t(e || {});
  return r(i), n;
}
function Gp(e, t) {
  return ({ exclude: n, format: r }) => ({
    exclude: n,
    format: (i) => {
      const o = t(i);
      if (n)
        for (const s of n)
          delete o[s];
      return {
        ...o,
        ...r(i)
      };
    },
    type: e
  });
}
const Tz = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3",
  eip7702: "0x4"
};
function Dd(e) {
  const t = {};
  return typeof e.authorizationList < "u" && (t.authorizationList = Iz(e.authorizationList)), typeof e.accessList < "u" && (t.accessList = e.accessList), typeof e.blobVersionedHashes < "u" && (t.blobVersionedHashes = e.blobVersionedHashes), typeof e.blobs < "u" && (typeof e.blobs[0] != "string" ? t.blobs = e.blobs.map((n) => vn(n)) : t.blobs = e.blobs), typeof e.data < "u" && (t.data = e.data), typeof e.from < "u" && (t.from = e.from), typeof e.gas < "u" && (t.gas = Fe(e.gas)), typeof e.gasPrice < "u" && (t.gasPrice = Fe(e.gasPrice)), typeof e.maxFeePerBlobGas < "u" && (t.maxFeePerBlobGas = Fe(e.maxFeePerBlobGas)), typeof e.maxFeePerGas < "u" && (t.maxFeePerGas = Fe(e.maxFeePerGas)), typeof e.maxPriorityFeePerGas < "u" && (t.maxPriorityFeePerGas = Fe(e.maxPriorityFeePerGas)), typeof e.nonce < "u" && (t.nonce = Fe(e.nonce)), typeof e.to < "u" && (t.to = e.to), typeof e.type < "u" && (t.type = Tz[e.type]), typeof e.value < "u" && (t.value = Fe(e.value)), t;
}
const _z = /* @__PURE__ */ Gp("transactionRequest", Dd);
function Iz(e) {
  return e.map((t) => ({
    address: t.contractAddress,
    r: t.r,
    s: t.s,
    chainId: Fe(t.chainId),
    nonce: Fe(t.nonce),
    ...typeof t.yParity < "u" ? { yParity: Fe(t.yParity) } : {},
    ...typeof t.v < "u" && typeof t.yParity > "u" ? { v: Fe(t.v) } : {}
  }));
}
function at(e, t, n) {
  const r = e[t.name];
  if (typeof r == "function")
    return r;
  const i = e[n];
  return typeof i == "function" ? i : (o) => t(e, o);
}
const jd = 2n ** 256n - 1n;
function Md(e) {
  const { account: t, gasPrice: n, maxFeePerGas: r, maxPriorityFeePerGas: i, to: o } = e, s = t ? ui(t) : void 0;
  if (s && !bn(s.address))
    throw new Zn({ address: s.address });
  if (o && !bn(o))
    throw new Zn({ address: o });
  if (typeof n < "u" && (typeof r < "u" || typeof i < "u"))
    throw new vz();
  if (r && r > jd)
    throw new ks({ maxFeePerGas: r });
  if (i && r && i > r)
    throw new Jl({ maxFeePerGas: r, maxPriorityFeePerGas: i });
}
async function bw(e) {
  const t = await e.request({
    method: "eth_chainId"
  }, { dedupe: !0 });
  return Xi(t);
}
class Rz extends be {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1.", {
      name: "BaseFeeScalarError"
    });
  }
}
class ww extends be {
  constructor() {
    super("Chain does not support EIP-1559 fees.", {
      name: "Eip1559FeesNotSupportedError"
    });
  }
}
class Pz extends be {
  constructor({ maxPriorityFeePerGas: t }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${kr(t)} gwei).`, { name: "MaxFeePerGasTooLowError" });
  }
}
class $T extends be {
  constructor({ blockHash: t, blockNumber: n }) {
    let r = "Block";
    t && (r = `Block at hash "${t}"`), n && (r = `Block at number "${n}"`), super(`${r} could not be found.`, { name: "BlockNotFoundError" });
  }
}
const WT = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function Fd(e) {
  const t = {
    ...e,
    blockHash: e.blockHash ? e.blockHash : null,
    blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
    chainId: e.chainId ? Xi(e.chainId) : void 0,
    gas: e.gas ? BigInt(e.gas) : void 0,
    gasPrice: e.gasPrice ? BigInt(e.gasPrice) : void 0,
    maxFeePerBlobGas: e.maxFeePerBlobGas ? BigInt(e.maxFeePerBlobGas) : void 0,
    maxFeePerGas: e.maxFeePerGas ? BigInt(e.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: e.maxPriorityFeePerGas ? BigInt(e.maxPriorityFeePerGas) : void 0,
    nonce: e.nonce ? Xi(e.nonce) : void 0,
    to: e.to ? e.to : null,
    transactionIndex: e.transactionIndex ? Number(e.transactionIndex) : null,
    type: e.type ? WT[e.type] : void 0,
    typeHex: e.type ? e.type : void 0,
    value: e.value ? BigInt(e.value) : void 0,
    v: e.v ? BigInt(e.v) : void 0
  };
  return e.authorizationList && (t.authorizationList = Oz(e.authorizationList)), t.yParity = (() => {
    if (e.yParity)
      return Number(e.yParity);
    if (typeof t.v == "bigint") {
      if (t.v === 0n || t.v === 27n)
        return 0;
      if (t.v === 1n || t.v === 28n)
        return 1;
      if (t.v >= 35n)
        return t.v % 2n === 0n ? 1 : 0;
    }
  })(), t.type === "legacy" && (delete t.accessList, delete t.maxFeePerBlobGas, delete t.maxFeePerGas, delete t.maxPriorityFeePerGas, delete t.yParity), t.type === "eip2930" && (delete t.maxFeePerBlobGas, delete t.maxFeePerGas, delete t.maxPriorityFeePerGas), t.type === "eip1559" && delete t.maxFeePerBlobGas, t;
}
const GT = /* @__PURE__ */ Gp("transaction", Fd);
function Oz(e) {
  return e.map((t) => ({
    contractAddress: t.address,
    r: t.r,
    s: t.s,
    chainId: Number(t.chainId),
    nonce: Number(t.nonce),
    ...typeof t.yParity < "u" ? { yParity: Number(t.yParity) } : {},
    ...typeof t.v < "u" && typeof t.yParity > "u" ? { v: Number(t.v) } : {}
  }));
}
function xw(e) {
  var n;
  const t = (n = e.transactions) == null ? void 0 : n.map((r) => typeof r == "string" ? r : Fd(r));
  return {
    ...e,
    baseFeePerGas: e.baseFeePerGas ? BigInt(e.baseFeePerGas) : null,
    blobGasUsed: e.blobGasUsed ? BigInt(e.blobGasUsed) : void 0,
    difficulty: e.difficulty ? BigInt(e.difficulty) : void 0,
    excessBlobGas: e.excessBlobGas ? BigInt(e.excessBlobGas) : void 0,
    gasLimit: e.gasLimit ? BigInt(e.gasLimit) : void 0,
    gasUsed: e.gasUsed ? BigInt(e.gasUsed) : void 0,
    hash: e.hash ? e.hash : null,
    logsBloom: e.logsBloom ? e.logsBloom : null,
    nonce: e.nonce ? e.nonce : null,
    number: e.number ? BigInt(e.number) : null,
    size: e.size ? BigInt(e.size) : void 0,
    timestamp: e.timestamp ? BigInt(e.timestamp) : void 0,
    transactions: t,
    totalDifficulty: e.totalDifficulty ? BigInt(e.totalDifficulty) : null
  };
}
const HT = /* @__PURE__ */ Gp("block", xw);
async function Es(e, { blockHash: t, blockNumber: n, blockTag: r, includeTransactions: i } = {}) {
  var u, d, f;
  const o = r ?? "latest", s = i ?? !1, a = n !== void 0 ? Fe(n) : void 0;
  let l = null;
  if (t ? l = await e.request({
    method: "eth_getBlockByHash",
    params: [t, s]
  }, { dedupe: !0 }) : l = await e.request({
    method: "eth_getBlockByNumber",
    params: [a || o, s]
  }, { dedupe: !!a }), !l)
    throw new $T({ blockHash: t, blockNumber: n });
  return (((f = (d = (u = e.chain) == null ? void 0 : u.formatters) == null ? void 0 : d.block) == null ? void 0 : f.format) || xw)(l);
}
async function Cw(e) {
  const t = await e.request({
    method: "eth_gasPrice"
  });
  return BigInt(t);
}
async function Bz(e, t) {
  return KT(e, t);
}
async function KT(e, t) {
  var o, s;
  const { block: n, chain: r = e.chain, request: i } = t || {};
  try {
    const a = ((o = r == null ? void 0 : r.fees) == null ? void 0 : o.maxPriorityFeePerGas) ?? ((s = r == null ? void 0 : r.fees) == null ? void 0 : s.defaultPriorityFee);
    if (typeof a == "function") {
      const c = n || await at(e, Es, "getBlock")({}), u = await a({
        block: c,
        client: e,
        request: i
      });
      if (u === null)
        throw new Error();
      return u;
    }
    if (typeof a < "u")
      return a;
    const l = await e.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return Yn(l);
  } catch {
    const [a, l] = await Promise.all([
      n ? Promise.resolve(n) : at(e, Es, "getBlock")({}),
      at(e, Cw, "getGasPrice")({})
    ]);
    if (typeof a.baseFeePerGas != "bigint")
      throw new ww();
    const c = l - a.baseFeePerGas;
    return c < 0n ? 0n : c;
  }
}
async function Nz(e, t) {
  return db(e, t);
}
async function db(e, t) {
  var f, h;
  const { block: n, chain: r = e.chain, request: i, type: o = "eip1559" } = t || {}, s = await (async () => {
    var p, m;
    return typeof ((p = r == null ? void 0 : r.fees) == null ? void 0 : p.baseFeeMultiplier) == "function" ? r.fees.baseFeeMultiplier({
      block: n,
      client: e,
      request: i
    }) : ((m = r == null ? void 0 : r.fees) == null ? void 0 : m.baseFeeMultiplier) ?? 1.2;
  })();
  if (s < 1)
    throw new Rz();
  const l = 10 ** (((f = s.toString().split(".")[1]) == null ? void 0 : f.length) ?? 0), c = (p) => p * BigInt(Math.ceil(s * l)) / BigInt(l), u = n || await at(e, Es, "getBlock")({});
  if (typeof ((h = r == null ? void 0 : r.fees) == null ? void 0 : h.estimateFeesPerGas) == "function") {
    const p = await r.fees.estimateFeesPerGas({
      block: n,
      client: e,
      multiply: c,
      request: i,
      type: o
    });
    if (p !== null)
      return p;
  }
  if (o === "eip1559") {
    if (typeof u.baseFeePerGas != "bigint")
      throw new ww();
    const p = typeof (i == null ? void 0 : i.maxPriorityFeePerGas) == "bigint" ? i.maxPriorityFeePerGas : await KT(e, {
      block: u,
      chain: r,
      request: i
    }), m = c(u.baseFeePerGas);
    return {
      maxFeePerGas: (i == null ? void 0 : i.maxFeePerGas) ?? m + p,
      maxPriorityFeePerGas: p
    };
  }
  return {
    gasPrice: (i == null ? void 0 : i.gasPrice) ?? c(await at(e, Cw, "getGasPrice")({}))
  };
}
class Dz extends be {
  constructor(t, { account: n, docsPath: r, chain: i, data: o, gas: s, gasPrice: a, maxFeePerGas: l, maxPriorityFeePerGas: c, nonce: u, to: d, value: f }) {
    var p;
    const h = Nd({
      from: n == null ? void 0 : n.address,
      to: d,
      value: typeof f < "u" && `${mw(f)} ${((p = i == null ? void 0 : i.nativeCurrency) == null ? void 0 : p.symbol) || "ETH"}`,
      data: o,
      gas: s,
      gasPrice: typeof a < "u" && `${kr(a)} gwei`,
      maxFeePerGas: typeof l < "u" && `${kr(l)} gwei`,
      maxPriorityFeePerGas: typeof c < "u" && `${kr(c)} gwei`,
      nonce: u
    });
    super(t.shortMessage, {
      cause: t,
      docsPath: r,
      metaMessages: [
        ...t.metaMessages ? [...t.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        h
      ].filter(Boolean),
      name: "EstimateGasExecutionError"
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cause = t;
  }
}
function jz(e, { docsPath: t, ...n }) {
  const r = (() => {
    const i = vw(e, n);
    return i instanceof $p ? e : i;
  })();
  return new Dz(r, {
    docsPath: t,
    ...n
  });
}
class Mz extends be {
  constructor({ address: t }) {
    super(`State for account "${t}" is set multiple times.`, {
      name: "AccountStateConflictError"
    });
  }
}
class Fz extends be {
  constructor() {
    super("state and stateDiff are set on the same account.", {
      name: "StateAssignmentConflictError"
    });
  }
}
function Ok(e) {
  return e.reduce((t, { slot: n, value: r }) => `${t}        ${n}: ${r}
`, "");
}
function Lz(e) {
  return e.reduce((t, { address: n, ...r }) => {
    let i = `${t}    ${n}:
`;
    return r.nonce && (i += `      nonce: ${r.nonce}
`), r.balance && (i += `      balance: ${r.balance}
`), r.code && (i += `      code: ${r.code}
`), r.state && (i += `      state:
`, i += Ok(r.state)), r.stateDiff && (i += `      stateDiff:
`, i += Ok(r.stateDiff)), i;
  }, `  State Override:
`).slice(0, -1);
}
function Bk(e) {
  if (!(!e || e.length === 0))
    return e.reduce((t, { slot: n, value: r }) => {
      if (n.length !== 66)
        throw new bk({
          size: n.length,
          targetSize: 66,
          type: "hex"
        });
      if (r.length !== 66)
        throw new bk({
          size: r.length,
          targetSize: 66,
          type: "hex"
        });
      return t[n] = r, t;
    }, {});
}
function Uz(e) {
  const { balance: t, nonce: n, state: r, stateDiff: i, code: o } = e, s = {};
  if (o !== void 0 && (s.code = o), t !== void 0 && (s.balance = Fe(t)), n !== void 0 && (s.nonce = Fe(n)), r !== void 0 && (s.state = Bk(r)), i !== void 0) {
    if (s.state)
      throw new Fz();
    s.stateDiff = Bk(i);
  }
  return s;
}
function YT(e) {
  if (!e)
    return;
  const t = {};
  for (const { address: n, ...r } of e) {
    if (!bn(n, { strict: !1 }))
      throw new Zn({ address: n });
    if (t[n])
      throw new Mz({ address: n });
    t[n] = Uz(r);
  }
  return t;
}
async function QT(e, { address: t, blockNumber: n, blockTag: r = "latest" }) {
  const i = n ? Fe(n) : void 0, o = await e.request({
    method: "eth_getBalance",
    params: [t, i || r]
  });
  return BigInt(o);
}
async function Hp(e, t) {
  var i, o, s;
  const n = t.account ?? e.account, r = n ? ui(n) : void 0;
  try {
    let V = function(M) {
      const { block: U, request: F, rpcStateOverride: $ } = M;
      return e.request({
        method: "eth_estimateGas",
        params: $ ? [F, U ?? "latest", $] : U ? [F, U] : [F]
      });
    };
    const { accessList: a, authorizationList: l, blobs: c, blobVersionedHashes: u, blockNumber: d, blockTag: f, data: h, gas: p, gasPrice: m, maxFeePerBlobGas: g, maxFeePerGas: v, maxPriorityFeePerGas: w, nonce: x, value: C, stateOverride: S, ...k } = await Kp(e, {
      ...t,
      parameters: (
        // Some RPC Providers do not compute versioned hashes from blobs. We will need
        // to compute them.
        (r == null ? void 0 : r.type) === "local" ? void 0 : ["blobVersionedHashes"]
      )
    }), b = (d ? Fe(d) : void 0) || f, T = YT(S), R = await (async () => {
      if (k.to)
        return k.to;
      if (l && l.length > 0)
        return await FT({
          authorization: l[0]
        }).catch(() => {
          throw new be("`to` is required. Could not infer from `authorizationList`");
        });
    })();
    Md(t);
    const B = (s = (o = (i = e.chain) == null ? void 0 : i.formatters) == null ? void 0 : o.transactionRequest) == null ? void 0 : s.format, L = (B || Dd)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...Wp(k, { format: B }),
      from: r == null ? void 0 : r.address,
      accessList: a,
      authorizationList: l,
      blobs: c,
      blobVersionedHashes: u,
      data: h,
      gas: p,
      gasPrice: m,
      maxFeePerBlobGas: g,
      maxFeePerGas: v,
      maxPriorityFeePerGas: w,
      nonce: x,
      to: R,
      value: C
    });
    let N = BigInt(await V({ block: b, request: L, rpcStateOverride: T }));
    if (l) {
      const M = await QT(e, { address: L.from }), U = await Promise.all(l.map(async (F) => {
        const { contractAddress: $ } = F, ie = await V({
          block: b,
          request: {
            authorizationList: void 0,
            data: h,
            from: r == null ? void 0 : r.address,
            to: $,
            value: Fe(M)
          },
          rpcStateOverride: T
        }).catch(() => 100000n);
        return 2n * BigInt(ie);
      }));
      N += U.reduce((F, $) => F + $, 0n);
    }
    return N;
  } catch (a) {
    throw jz(a, {
      ...t,
      account: r,
      chain: e.chain
    });
  }
}
async function JT(e, { address: t, blockTag: n = "latest", blockNumber: r }) {
  const i = await e.request({
    method: "eth_getTransactionCount",
    params: [t, r ? Fe(r) : n]
  }, { dedupe: !!r });
  return Xi(i);
}
function kw(e) {
  const { kzg: t } = e, n = e.to ?? (typeof e.blobs[0] == "string" ? "hex" : "bytes"), r = typeof e.blobs[0] == "string" ? e.blobs.map((o) => Ai(o)) : e.blobs, i = [];
  for (const o of r)
    i.push(Uint8Array.from(t.blobToKzgCommitment(o)));
  return n === "bytes" ? i : i.map((o) => vn(o));
}
function Ew(e) {
  const { kzg: t } = e, n = e.to ?? (typeof e.blobs[0] == "string" ? "hex" : "bytes"), r = typeof e.blobs[0] == "string" ? e.blobs.map((s) => Ai(s)) : e.blobs, i = typeof e.commitments[0] == "string" ? e.commitments.map((s) => Ai(s)) : e.commitments, o = [];
  for (let s = 0; s < r.length; s++) {
    const a = r[s], l = i[s];
    o.push(Uint8Array.from(t.computeBlobKzgProof(a, l)));
  }
  return n === "bytes" ? o : o.map((s) => vn(s));
}
function zz(e, t, n, r) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, n, r);
  const i = BigInt(32), o = BigInt(4294967295), s = Number(n >> i & o), a = Number(n & o), l = r ? 4 : 0, c = r ? 0 : 4;
  e.setUint32(t + l, s, r), e.setUint32(t + c, a, r);
}
const Vz = (e, t, n) => e & t ^ ~e & n, qz = (e, t, n) => e & t ^ e & n ^ t & n;
class $z extends lw {
  constructor(t, n, r, i) {
    super(), this.blockLen = t, this.outputLen = n, this.padOffset = r, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = Wm(this.buffer);
  }
  update(t) {
    Ql(this);
    const { view: n, buffer: r, blockLen: i } = this;
    t = Vp(t);
    const o = t.length;
    for (let s = 0; s < o; ) {
      const a = Math.min(i - this.pos, o - s);
      if (a === i) {
        const l = Wm(t);
        for (; i <= o - s; s += i)
          this.process(l, s);
        continue;
      }
      r.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === i && (this.process(n, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    Ql(this), ST(t, this), this.finished = !0;
    const { buffer: n, view: r, blockLen: i, isLE: o } = this;
    let { pos: s } = this;
    n[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > i - s && (this.process(r, 0), s = 0);
    for (let d = s; d < i; d++)
      n[d] = 0;
    zz(r, i - 8, BigInt(this.length * 8), o), this.process(r, 0);
    const a = Wm(t), l = this.outputLen;
    if (l % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const c = l / 4, u = this.get();
    if (c > u.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let d = 0; d < c; d++)
      a.setUint32(4 * d, u[d], o);
  }
  digest() {
    const { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    const r = t.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: n, buffer: r, length: i, finished: o, destroyed: s, pos: a } = this;
    return t.length = i, t.pos = a, t.finished = o, t.destroyed = s, i % n && t.buffer.set(r), t;
  }
}
const Wz = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Qo = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), Jo = /* @__PURE__ */ new Uint32Array(64);
class Gz extends $z {
  constructor() {
    super(64, 32, 8, !1), this.A = Qo[0] | 0, this.B = Qo[1] | 0, this.C = Qo[2] | 0, this.D = Qo[3] | 0, this.E = Qo[4] | 0, this.F = Qo[5] | 0, this.G = Qo[6] | 0, this.H = Qo[7] | 0;
  }
  get() {
    const { A: t, B: n, C: r, D: i, E: o, F: s, G: a, H: l } = this;
    return [t, n, r, i, o, s, a, l];
  }
  // prettier-ignore
  set(t, n, r, i, o, s, a, l) {
    this.A = t | 0, this.B = n | 0, this.C = r | 0, this.D = i | 0, this.E = o | 0, this.F = s | 0, this.G = a | 0, this.H = l | 0;
  }
  process(t, n) {
    for (let d = 0; d < 16; d++, n += 4)
      Jo[d] = t.getUint32(n, !1);
    for (let d = 16; d < 64; d++) {
      const f = Jo[d - 15], h = Jo[d - 2], p = Fi(f, 7) ^ Fi(f, 18) ^ f >>> 3, m = Fi(h, 17) ^ Fi(h, 19) ^ h >>> 10;
      Jo[d] = m + Jo[d - 7] + p + Jo[d - 16] | 0;
    }
    let { A: r, B: i, C: o, D: s, E: a, F: l, G: c, H: u } = this;
    for (let d = 0; d < 64; d++) {
      const f = Fi(a, 6) ^ Fi(a, 11) ^ Fi(a, 25), h = u + f + Vz(a, l, c) + Wz[d] + Jo[d] | 0, m = (Fi(r, 2) ^ Fi(r, 13) ^ Fi(r, 22)) + qz(r, i, o) | 0;
      u = c, c = l, l = a, a = s + h | 0, s = o, o = i, i = r, r = h + m | 0;
    }
    r = r + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, l = l + this.F | 0, c = c + this.G | 0, u = u + this.H | 0, this.set(r, i, o, s, a, l, c, u);
  }
  roundClean() {
    Jo.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const XT = /* @__PURE__ */ AT(() => new Gz());
function Hz(e, t) {
  return XT(ii(e, { strict: !1 }) ? Cs(e) : e);
}
function Kz(e) {
  const { commitment: t, version: n = 1 } = e, r = e.to ?? (typeof t == "string" ? "hex" : "bytes"), i = Hz(t);
  return i.set([n], 0), r === "bytes" ? i : vn(i);
}
function ZT(e) {
  const { commitments: t, version: n } = e, r = e.to ?? (typeof t[0] == "string" ? "hex" : "bytes"), i = [];
  for (const o of t)
    i.push(Kz({
      commitment: o,
      to: r,
      version: n
    }));
  return i;
}
const Nk = 6, e_ = 32, Sw = 4096, t_ = e_ * Sw, Dk = t_ * Nk - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * Sw * Nk, n_ = 1;
class Yz extends be {
  constructor({ maxSize: t, size: n }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${t} bytes`, `Given: ${n} bytes`],
      name: "BlobSizeTooLargeError"
    });
  }
}
class r_ extends be {
  constructor() {
    super("Blob data must not be empty.", { name: "EmptyBlobError" });
  }
}
class Qz extends be {
  constructor({ hash: t, size: n }) {
    super(`Versioned hash "${t}" size is invalid.`, {
      metaMessages: ["Expected: 32", `Received: ${n}`],
      name: "InvalidVersionedHashSizeError"
    });
  }
}
class Jz extends be {
  constructor({ hash: t, version: n }) {
    super(`Versioned hash "${t}" version is invalid.`, {
      metaMessages: [
        `Expected: ${n_}`,
        `Received: ${n}`
      ],
      name: "InvalidVersionedHashVersionError"
    });
  }
}
function Xz(e) {
  const t = e.to ?? (typeof e.data == "string" ? "hex" : "bytes"), n = typeof e.data == "string" ? Ai(e.data) : e.data, r = ln(n);
  if (!r)
    throw new r_();
  if (r > Dk)
    throw new Yz({
      maxSize: Dk,
      size: r
    });
  const i = [];
  let o = !0, s = 0;
  for (; o; ) {
    const a = yw(new Uint8Array(t_));
    let l = 0;
    for (; l < Sw; ) {
      const c = n.slice(s, s + (e_ - 1));
      if (a.pushByte(0), a.pushBytes(c), c.length < 31) {
        a.pushByte(128), o = !1;
        break;
      }
      l++, s += 31;
    }
    i.push(a);
  }
  return t === "bytes" ? i.map((a) => a.bytes) : i.map((a) => vn(a.bytes));
}
function i_(e) {
  const { data: t, kzg: n, to: r } = e, i = e.blobs ?? Xz({ data: t, to: r }), o = e.commitments ?? kw({ blobs: i, kzg: n, to: r }), s = e.proofs ?? Ew({ blobs: i, commitments: o, kzg: n, to: r }), a = [];
  for (let l = 0; l < i.length; l++)
    a.push({
      blob: i[l],
      commitment: o[l],
      proof: s[l]
    });
  return a;
}
function o_(e) {
  if (e.type)
    return e.type;
  if (typeof e.authorizationList < "u")
    return "eip7702";
  if (typeof e.blobs < "u" || typeof e.blobVersionedHashes < "u" || typeof e.maxFeePerBlobGas < "u" || typeof e.sidecars < "u")
    return "eip4844";
  if (typeof e.maxFeePerGas < "u" || typeof e.maxPriorityFeePerGas < "u")
    return "eip1559";
  if (typeof e.gasPrice < "u")
    return typeof e.accessList < "u" ? "eip2930" : "legacy";
  throw new wz({ transaction: e });
}
const s_ = [
  "blobVersionedHashes",
  "chainId",
  "fees",
  "gas",
  "nonce",
  "type"
];
async function Kp(e, t) {
  const { account: n = e.account, blobs: r, chain: i, gas: o, kzg: s, nonce: a, nonceManager: l, parameters: c = s_, type: u } = t, d = n ? ui(n) : void 0, f = { ...t, ...d ? { from: d == null ? void 0 : d.address } : {} };
  let h;
  async function p() {
    return h || (h = await at(e, Es, "getBlock")({ blockTag: "latest" }), h);
  }
  let m;
  async function g() {
    return m || (i ? i.id : typeof t.chainId < "u" ? t.chainId : (m = await at(e, bw, "getChainId")({}), m));
  }
  if ((c.includes("blobVersionedHashes") || c.includes("sidecars")) && r && s) {
    const v = kw({ blobs: r, kzg: s });
    if (c.includes("blobVersionedHashes")) {
      const w = ZT({
        commitments: v,
        to: "hex"
      });
      f.blobVersionedHashes = w;
    }
    if (c.includes("sidecars")) {
      const w = Ew({ blobs: r, commitments: v, kzg: s }), x = i_({
        blobs: r,
        commitments: v,
        proofs: w,
        to: "hex"
      });
      f.sidecars = x;
    }
  }
  if (c.includes("chainId") && (f.chainId = await g()), c.includes("nonce") && typeof a > "u" && d)
    if (l) {
      const v = await g();
      f.nonce = await l.consume({
        address: d.address,
        chainId: v,
        client: e
      });
    } else
      f.nonce = await at(e, JT, "getTransactionCount")({
        address: d.address,
        blockTag: "pending"
      });
  if ((c.includes("fees") || c.includes("type")) && typeof u > "u")
    try {
      f.type = o_(f);
    } catch {
      const v = await p();
      f.type = typeof (v == null ? void 0 : v.baseFeePerGas) == "bigint" ? "eip1559" : "legacy";
    }
  if (c.includes("fees"))
    if (f.type !== "legacy" && f.type !== "eip2930") {
      if (typeof f.maxFeePerGas > "u" || typeof f.maxPriorityFeePerGas > "u") {
        const v = await p(), { maxFeePerGas: w, maxPriorityFeePerGas: x } = await db(e, {
          block: v,
          chain: i,
          request: f
        });
        if (typeof t.maxPriorityFeePerGas > "u" && t.maxFeePerGas && t.maxFeePerGas < x)
          throw new Pz({
            maxPriorityFeePerGas: x
          });
        f.maxPriorityFeePerGas = x, f.maxFeePerGas = w;
      }
    } else {
      if (typeof t.maxFeePerGas < "u" || typeof t.maxPriorityFeePerGas < "u")
        throw new ww();
      const v = await p(), { gasPrice: w } = await db(e, {
        block: v,
        chain: i,
        request: f,
        type: "legacy"
      });
      f.gasPrice = w;
    }
  return c.includes("gas") && typeof o > "u" && (f.gas = await at(e, Hp, "estimateGas")({
    ...f,
    account: d ? { address: d.address, type: "json-rpc" } : void 0
  })), Md(f), delete f.parameters, f;
}
async function a_(e, { serializedTransaction: t }) {
  return e.request({
    method: "eth_sendRawTransaction",
    params: [t]
  }, { retryCount: 0 });
}
async function Zz(e, t) {
  var v, w, x, C;
  const { account: n = e.account, chain: r = e.chain, accessList: i, authorizationList: o, blobs: s, data: a, gas: l, gasPrice: c, maxFeePerBlobGas: u, maxFeePerGas: d, maxPriorityFeePerGas: f, nonce: h, value: p, ...m } = t;
  if (!n)
    throw new pw({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  const g = ui(n);
  try {
    Md(t);
    const S = await (async () => {
      if (t.to)
        return t.to;
      if (o && o.length > 0)
        return await FT({
          authorization: o[0]
        }).catch(() => {
          throw new be("`to` is required. Could not infer from `authorizationList`.");
        });
    })();
    if (g.type === "json-rpc") {
      let k;
      r !== null && (k = await at(e, bw, "getChainId")({}), yz({
        currentChainId: k,
        chain: r
      }));
      const A = (x = (w = (v = e.chain) == null ? void 0 : v.formatters) == null ? void 0 : w.transactionRequest) == null ? void 0 : x.format, T = (A || Dd)({
        // Pick out extra data that might exist on the chain's transaction request type.
        ...Wp(m, { format: A }),
        accessList: i,
        authorizationList: o,
        blobs: s,
        chainId: k,
        data: a,
        from: g.address,
        gas: l,
        gasPrice: c,
        maxFeePerBlobGas: u,
        maxFeePerGas: d,
        maxPriorityFeePerGas: f,
        nonce: h,
        to: S,
        value: p
      });
      return await e.request({
        method: "eth_sendTransaction",
        params: [T]
      }, { retryCount: 0 });
    }
    if (g.type === "local") {
      const k = await at(e, Kp, "prepareTransactionRequest")({
        account: g,
        accessList: i,
        authorizationList: o,
        blobs: s,
        chain: r,
        data: a,
        gas: l,
        gasPrice: c,
        maxFeePerBlobGas: u,
        maxFeePerGas: d,
        maxPriorityFeePerGas: f,
        nonce: h,
        nonceManager: g.nonceManager,
        parameters: [...s_, "sidecars"],
        value: p,
        ...m,
        to: S
      }), A = (C = r == null ? void 0 : r.serializers) == null ? void 0 : C.transaction, b = await g.signTransaction(k, {
        serializer: A
      });
      return await at(e, a_, "sendRawTransaction")({
        serializedTransaction: b
      });
    }
    throw g.type === "smart" ? new Ym({
      metaMessages: [
        "Consider using the `sendUserOperation` Action instead."
      ],
      docsPath: "/docs/actions/bundler/sendUserOperation",
      type: "smart"
    }) : new Ym({
      docsPath: "/docs/actions/wallet/sendTransaction",
      type: g.type
    });
  } catch (S) {
    throw S instanceof Ym ? S : Az(S, {
      ...t,
      account: g,
      chain: t.chain || void 0
    });
  }
}
const fb = [
  {
    inputs: [
      {
        components: [
          {
            name: "target",
            type: "address"
          },
          {
            name: "allowFailure",
            type: "bool"
          },
          {
            name: "callData",
            type: "bytes"
          }
        ],
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "aggregate3",
    outputs: [
      {
        components: [
          {
            name: "success",
            type: "bool"
          },
          {
            name: "returnData",
            type: "bytes"
          }
        ],
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
], l_ = [
  {
    inputs: [],
    name: "ResolverNotFound",
    type: "error"
  },
  {
    inputs: [],
    name: "ResolverWildcardNotSupported",
    type: "error"
  },
  {
    inputs: [],
    name: "ResolverNotContract",
    type: "error"
  },
  {
    inputs: [
      {
        name: "returnData",
        type: "bytes"
      }
    ],
    name: "ResolverError",
    type: "error"
  },
  {
    inputs: [
      {
        components: [
          {
            name: "status",
            type: "uint16"
          },
          {
            name: "message",
            type: "string"
          }
        ],
        name: "errors",
        type: "tuple[]"
      }
    ],
    name: "HttpError",
    type: "error"
  }
], c_ = [
  ...l_,
  {
    name: "resolve",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes" },
      { name: "data", type: "bytes" }
    ],
    outputs: [
      { name: "", type: "bytes" },
      { name: "address", type: "address" }
    ]
  },
  {
    name: "resolve",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes" },
      { name: "data", type: "bytes" },
      { name: "gateways", type: "string[]" }
    ],
    outputs: [
      { name: "", type: "bytes" },
      { name: "address", type: "address" }
    ]
  }
], eV = [
  ...l_,
  {
    name: "reverse",
    type: "function",
    stateMutability: "view",
    inputs: [{ type: "bytes", name: "reverseName" }],
    outputs: [
      { type: "string", name: "resolvedName" },
      { type: "address", name: "resolvedAddress" },
      { type: "address", name: "reverseResolver" },
      { type: "address", name: "resolver" }
    ]
  },
  {
    name: "reverse",
    type: "function",
    stateMutability: "view",
    inputs: [
      { type: "bytes", name: "reverseName" },
      { type: "string[]", name: "gateways" }
    ],
    outputs: [
      { type: "string", name: "resolvedName" },
      { type: "address", name: "resolvedAddress" },
      { type: "address", name: "reverseResolver" },
      { type: "address", name: "resolver" }
    ]
  }
], jk = [
  {
    name: "text",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes32" },
      { name: "key", type: "string" }
    ],
    outputs: [{ name: "", type: "string" }]
  }
], Mk = [
  {
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [{ name: "name", type: "bytes32" }],
    outputs: [{ name: "", type: "address" }]
  },
  {
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes32" },
      { name: "coinType", type: "uint256" }
    ],
    outputs: [{ name: "", type: "bytes" }]
  }
], tV = [
  {
    inputs: [
      {
        name: "_signer",
        type: "address"
      },
      {
        name: "_hash",
        type: "bytes32"
      },
      {
        name: "_signature",
        type: "bytes"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  }
];
function nV(e, t = {}) {
  typeof t.size < "u" && ro(e, { size: t.size });
  const n = vn(e, t);
  return Yn(n, t);
}
function rV(e, t = {}) {
  let n = e;
  if (typeof t.size < "u" && (ro(n, { size: t.size }), n = Ji(n)), n.length > 1 || n[0] > 1)
    throw new sU(n);
  return !!n[0];
}
function Co(e, t = {}) {
  typeof t.size < "u" && ro(e, { size: t.size });
  const n = vn(e, t);
  return Xi(n, t);
}
function iV(e, t = {}) {
  let n = e;
  return typeof t.size < "u" && (ro(n, { size: t.size }), n = Ji(n, { dir: "right" })), new TextDecoder().decode(n);
}
function Yp(e, t) {
  const n = typeof t == "string" ? Ai(t) : t, r = yw(n);
  if (ln(n) === 0 && e.length > 0)
    throw new Up();
  if (ln(t) && ln(t) < 32)
    throw new CT({
      data: typeof t == "string" ? t : vn(t),
      params: e,
      size: ln(t)
    });
  let i = 0;
  const o = [];
  for (let s = 0; s < e.length; ++s) {
    const a = e[s];
    r.setPosition(i);
    const [l, c] = Tl(r, a, {
      staticPosition: 0
    });
    i += c, o.push(l);
  }
  return o;
}
function Tl(e, t, { staticPosition: n }) {
  const r = fw(t.type);
  if (r) {
    const [i, o] = r;
    return sV(e, { ...t, type: o }, { length: i, staticPosition: n });
  }
  if (t.type === "tuple")
    return uV(e, t, { staticPosition: n });
  if (t.type === "address")
    return oV(e);
  if (t.type === "bool")
    return aV(e);
  if (t.type.startsWith("bytes"))
    return lV(e, t, { staticPosition: n });
  if (t.type.startsWith("uint") || t.type.startsWith("int"))
    return cV(e, t);
  if (t.type === "string")
    return dV(e, { staticPosition: n });
  throw new EU(t.type, {
    docsPath: "/docs/contract/decodeAbiParameters"
  });
}
const Fk = 32, hb = 32;
function oV(e) {
  const t = e.readBytes(32);
  return [qp(vn(OT(t, -20))), 32];
}
function sV(e, t, { length: n, staticPosition: r }) {
  if (!n) {
    const s = Co(e.readBytes(hb)), a = r + s, l = a + Fk;
    e.setPosition(a);
    const c = Co(e.readBytes(Fk)), u = Xu(t);
    let d = 0;
    const f = [];
    for (let h = 0; h < c; ++h) {
      e.setPosition(l + (u ? h * 32 : d));
      const [p, m] = Tl(e, t, {
        staticPosition: l
      });
      d += m, f.push(p);
    }
    return e.setPosition(r + 32), [f, 32];
  }
  if (Xu(t)) {
    const s = Co(e.readBytes(hb)), a = r + s, l = [];
    for (let c = 0; c < n; ++c) {
      e.setPosition(a + c * 32);
      const [u] = Tl(e, t, {
        staticPosition: a
      });
      l.push(u);
    }
    return e.setPosition(r + 32), [l, 32];
  }
  let i = 0;
  const o = [];
  for (let s = 0; s < n; ++s) {
    const [a, l] = Tl(e, t, {
      staticPosition: r + i
    });
    i += l, o.push(a);
  }
  return [o, i];
}
function aV(e) {
  return [rV(e.readBytes(32), { size: 32 }), 32];
}
function lV(e, t, { staticPosition: n }) {
  const [r, i] = t.type.split("bytes");
  if (!i) {
    const s = Co(e.readBytes(32));
    e.setPosition(n + s);
    const a = Co(e.readBytes(32));
    if (a === 0)
      return e.setPosition(n + 32), ["0x", 32];
    const l = e.readBytes(a);
    return e.setPosition(n + 32), [vn(l), 32];
  }
  return [vn(e.readBytes(Number.parseInt(i), 32)), 32];
}
function cV(e, t) {
  const n = t.type.startsWith("int"), r = Number.parseInt(t.type.split("int")[1] || "256"), i = e.readBytes(32);
  return [
    r > 48 ? nV(i, { signed: n }) : Co(i, { signed: n }),
    32
  ];
}
function uV(e, t, { staticPosition: n }) {
  const r = t.components.length === 0 || t.components.some(({ name: s }) => !s), i = r ? [] : {};
  let o = 0;
  if (Xu(t)) {
    const s = Co(e.readBytes(hb)), a = n + s;
    for (let l = 0; l < t.components.length; ++l) {
      const c = t.components[l];
      e.setPosition(a + o);
      const [u, d] = Tl(e, c, {
        staticPosition: a
      });
      o += d, i[r ? l : c == null ? void 0 : c.name] = u;
    }
    return e.setPosition(n + 32), [i, 32];
  }
  for (let s = 0; s < t.components.length; ++s) {
    const a = t.components[s], [l, c] = Tl(e, a, {
      staticPosition: n
    });
    i[r ? s : a == null ? void 0 : a.name] = l, o += c;
  }
  return [i, o];
}
function dV(e, { staticPosition: t }) {
  const n = Co(e.readBytes(32)), r = t + n;
  e.setPosition(r);
  const i = Co(e.readBytes(32));
  if (i === 0)
    return e.setPosition(t + 32), ["", 32];
  const o = e.readBytes(i, 32), s = iV(Ji(o));
  return e.setPosition(t + 32), [s, 32];
}
function Xu(e) {
  var r;
  const { type: t } = e;
  if (t === "string" || t === "bytes" || t.endsWith("[]"))
    return !0;
  if (t === "tuple")
    return (r = e.components) == null ? void 0 : r.some(Xu);
  const n = fw(e.type);
  return !!(n && Xu({ ...e, type: n[1] }));
}
const fV = (e) => On(Cs(e));
function hV(e) {
  return fV(e);
}
const pV = "1.0.5";
let di = class pb extends Error {
  constructor(t, n = {}) {
    var s;
    const r = n.cause instanceof pb ? n.cause.details : (s = n.cause) != null && s.message ? n.cause.message : n.details, i = n.cause instanceof pb && n.cause.docsPath || n.docsPath, o = [
      t || "An error occurred.",
      "",
      ...n.metaMessages ? [...n.metaMessages, ""] : [],
      ...i ? [`Docs: https://abitype.dev${i}`] : [],
      ...r ? [`Details: ${r}`] : [],
      `Version: abitype@${pV}`
    ].join(`
`);
    super(o), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiTypeError"
    }), n.cause && (this.cause = n.cause), this.details = r, this.docsPath = i, this.metaMessages = n.metaMessages, this.shortMessage = t;
  }
};
function Ls(e, t) {
  const n = e.exec(t);
  return n == null ? void 0 : n.groups;
}
const u_ = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, d_ = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/, f_ = /^\(.+?\).*?$/, Lk = /^tuple(?<array>(\[(\d*)\])*)$/;
function yb(e) {
  let t = e.type;
  if (Lk.test(e.type) && "components" in e) {
    t = "(";
    const n = e.components.length;
    for (let i = 0; i < n; i++) {
      const o = e.components[i];
      t += yb(o), i < n - 1 && (t += ", ");
    }
    const r = Ls(Lk, e.type);
    return t += `)${(r == null ? void 0 : r.array) ?? ""}`, yb({
      ...e,
      type: t
    });
  }
  return "indexed" in e && e.indexed && (t = `${t} indexed`), e.name ? `${t} ${e.name}` : t;
}
function ou(e) {
  let t = "";
  const n = e.length;
  for (let r = 0; r < n; r++) {
    const i = e[r];
    t += yb(i), r !== n - 1 && (t += ", ");
  }
  return t;
}
function yV(e) {
  return e.type === "function" ? `function ${e.name}(${ou(e.inputs)})${e.stateMutability && e.stateMutability !== "nonpayable" ? ` ${e.stateMutability}` : ""}${e.outputs.length ? ` returns (${ou(e.outputs)})` : ""}` : e.type === "event" ? `event ${e.name}(${ou(e.inputs)})` : e.type === "error" ? `error ${e.name}(${ou(e.inputs)})` : e.type === "constructor" ? `constructor(${ou(e.inputs)})${e.stateMutability === "payable" ? " payable" : ""}` : e.type === "fallback" ? "fallback()" : "receive() external payable";
}
const h_ = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function mV(e) {
  return h_.test(e);
}
function gV(e) {
  return Ls(h_, e);
}
const p_ = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function vV(e) {
  return p_.test(e);
}
function bV(e) {
  return Ls(p_, e);
}
const y_ = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
function wV(e) {
  return y_.test(e);
}
function xV(e) {
  return Ls(y_, e);
}
const m_ = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
function g_(e) {
  return m_.test(e);
}
function CV(e) {
  return Ls(m_, e);
}
const v_ = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
function kV(e) {
  return v_.test(e);
}
function EV(e) {
  return Ls(v_, e);
}
const SV = /^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;
function AV(e) {
  return SV.test(e);
}
const TV = /^receive\(\) external payable$/;
function _V(e) {
  return TV.test(e);
}
const IV = /* @__PURE__ */ new Set(["indexed"]), mb = /* @__PURE__ */ new Set([
  "calldata",
  "memory",
  "storage"
]);
class RV extends di {
  constructor({ type: t }) {
    super("Unknown type.", {
      metaMessages: [
        `Type "${t}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownTypeError"
    });
  }
}
class PV extends di {
  constructor({ type: t }) {
    super("Unknown type.", {
      metaMessages: [`Type "${t}" is not a valid ABI type.`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownSolidityTypeError"
    });
  }
}
class OV extends di {
  constructor({ param: t }) {
    super("Invalid ABI parameter.", {
      details: t
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParameterError"
    });
  }
}
class BV extends di {
  constructor({ param: t, name: n }) {
    super("Invalid ABI parameter.", {
      details: t,
      metaMessages: [
        `"${n}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SolidityProtectedKeywordError"
    });
  }
}
class NV extends di {
  constructor({ param: t, type: n, modifier: r }) {
    super("Invalid ABI parameter.", {
      details: t,
      metaMessages: [
        `Modifier "${r}" not allowed${n ? ` in "${n}" type` : ""}.`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidModifierError"
    });
  }
}
class DV extends di {
  constructor({ param: t, type: n, modifier: r }) {
    super("Invalid ABI parameter.", {
      details: t,
      metaMessages: [
        `Modifier "${r}" not allowed${n ? ` in "${n}" type` : ""}.`,
        `Data location can only be specified for array, struct, or mapping types, but "${r}" was given.`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidFunctionModifierError"
    });
  }
}
class jV extends di {
  constructor({ abiParameter: t }) {
    super("Invalid ABI parameter.", {
      details: JSON.stringify(t, null, 2),
      metaMessages: ["ABI parameter type is invalid."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiTypeParameterError"
    });
  }
}
class gu extends di {
  constructor({ signature: t, type: n }) {
    super(`Invalid ${n} signature.`, {
      details: t
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidSignatureError"
    });
  }
}
class MV extends di {
  constructor({ signature: t }) {
    super("Unknown signature.", {
      details: t
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownSignatureError"
    });
  }
}
class FV extends di {
  constructor({ signature: t }) {
    super("Invalid struct signature.", {
      details: t,
      metaMessages: ["No properties exist."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidStructSignatureError"
    });
  }
}
class LV extends di {
  constructor({ type: t }) {
    super("Circular reference detected.", {
      metaMessages: [`Struct "${t}" is a circular reference.`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "CircularReferenceError"
    });
  }
}
class UV extends di {
  constructor({ current: t, depth: n }) {
    super("Unbalanced parentheses.", {
      metaMessages: [
        `"${t.trim()}" has too many ${n > 0 ? "opening" : "closing"} parentheses.`
      ],
      details: `Depth "${n}"`
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParenthesisError"
    });
  }
}
function zV(e, t) {
  return t ? `${t}:${e}` : e;
}
const Qm = /* @__PURE__ */ new Map([
  // Unnamed
  ["address", { type: "address" }],
  ["bool", { type: "bool" }],
  ["bytes", { type: "bytes" }],
  ["bytes32", { type: "bytes32" }],
  ["int", { type: "int256" }],
  ["int256", { type: "int256" }],
  ["string", { type: "string" }],
  ["uint", { type: "uint256" }],
  ["uint8", { type: "uint8" }],
  ["uint16", { type: "uint16" }],
  ["uint24", { type: "uint24" }],
  ["uint32", { type: "uint32" }],
  ["uint64", { type: "uint64" }],
  ["uint96", { type: "uint96" }],
  ["uint112", { type: "uint112" }],
  ["uint160", { type: "uint160" }],
  ["uint192", { type: "uint192" }],
  ["uint256", { type: "uint256" }],
  // Named
  ["address owner", { type: "address", name: "owner" }],
  ["address to", { type: "address", name: "to" }],
  ["bool approved", { type: "bool", name: "approved" }],
  ["bytes _data", { type: "bytes", name: "_data" }],
  ["bytes data", { type: "bytes", name: "data" }],
  ["bytes signature", { type: "bytes", name: "signature" }],
  ["bytes32 hash", { type: "bytes32", name: "hash" }],
  ["bytes32 r", { type: "bytes32", name: "r" }],
  ["bytes32 root", { type: "bytes32", name: "root" }],
  ["bytes32 s", { type: "bytes32", name: "s" }],
  ["string name", { type: "string", name: "name" }],
  ["string symbol", { type: "string", name: "symbol" }],
  ["string tokenURI", { type: "string", name: "tokenURI" }],
  ["uint tokenId", { type: "uint256", name: "tokenId" }],
  ["uint8 v", { type: "uint8", name: "v" }],
  ["uint256 balance", { type: "uint256", name: "balance" }],
  ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
  ["uint256 value", { type: "uint256", name: "value" }],
  // Indexed
  [
    "event:address indexed from",
    { type: "address", name: "from", indexed: !0 }
  ],
  ["event:address indexed to", { type: "address", name: "to", indexed: !0 }],
  [
    "event:uint indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: !0 }
  ],
  [
    "event:uint256 indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: !0 }
  ]
]);
function VV(e, t = {}) {
  if (wV(e)) {
    const n = xV(e);
    if (!n)
      throw new gu({ signature: e, type: "function" });
    const r = Ei(n.parameters), i = [], o = r.length;
    for (let a = 0; a < o; a++)
      i.push(Zs(r[a], {
        modifiers: mb,
        structs: t,
        type: "function"
      }));
    const s = [];
    if (n.returns) {
      const a = Ei(n.returns), l = a.length;
      for (let c = 0; c < l; c++)
        s.push(Zs(a[c], {
          modifiers: mb,
          structs: t,
          type: "function"
        }));
    }
    return {
      name: n.name,
      type: "function",
      stateMutability: n.stateMutability ?? "nonpayable",
      inputs: i,
      outputs: s
    };
  }
  if (vV(e)) {
    const n = bV(e);
    if (!n)
      throw new gu({ signature: e, type: "event" });
    const r = Ei(n.parameters), i = [], o = r.length;
    for (let s = 0; s < o; s++)
      i.push(Zs(r[s], {
        modifiers: IV,
        structs: t,
        type: "event"
      }));
    return { name: n.name, type: "event", inputs: i };
  }
  if (mV(e)) {
    const n = gV(e);
    if (!n)
      throw new gu({ signature: e, type: "error" });
    const r = Ei(n.parameters), i = [], o = r.length;
    for (let s = 0; s < o; s++)
      i.push(Zs(r[s], { structs: t, type: "error" }));
    return { name: n.name, type: "error", inputs: i };
  }
  if (kV(e)) {
    const n = EV(e);
    if (!n)
      throw new gu({ signature: e, type: "constructor" });
    const r = Ei(n.parameters), i = [], o = r.length;
    for (let s = 0; s < o; s++)
      i.push(Zs(r[s], { structs: t, type: "constructor" }));
    return {
      type: "constructor",
      stateMutability: n.stateMutability ?? "nonpayable",
      inputs: i
    };
  }
  if (AV(e))
    return { type: "fallback" };
  if (_V(e))
    return {
      type: "receive",
      stateMutability: "payable"
    };
  throw new MV({ signature: e });
}
const qV = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/, $V = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/, WV = /^u?int$/;
function Zs(e, t) {
  var d, f;
  const n = zV(e, t == null ? void 0 : t.type);
  if (Qm.has(n))
    return Qm.get(n);
  const r = f_.test(e), i = Ls(r ? $V : qV, e);
  if (!i)
    throw new OV({ param: e });
  if (i.name && HV(i.name))
    throw new BV({ param: e, name: i.name });
  const o = i.name ? { name: i.name } : {}, s = i.modifier === "indexed" ? { indexed: !0 } : {}, a = (t == null ? void 0 : t.structs) ?? {};
  let l, c = {};
  if (r) {
    l = "tuple";
    const h = Ei(i.type), p = [], m = h.length;
    for (let g = 0; g < m; g++)
      p.push(Zs(h[g], { structs: a }));
    c = { components: p };
  } else if (i.type in a)
    l = "tuple", c = { components: a[i.type] };
  else if (WV.test(i.type))
    l = `${i.type}256`;
  else if (l = i.type, (t == null ? void 0 : t.type) !== "struct" && !b_(l))
    throw new PV({ type: l });
  if (i.modifier) {
    if (!((f = (d = t == null ? void 0 : t.modifiers) == null ? void 0 : d.has) != null && f.call(d, i.modifier)))
      throw new NV({
        param: e,
        type: t == null ? void 0 : t.type,
        modifier: i.modifier
      });
    if (mb.has(i.modifier) && !KV(l, !!i.array))
      throw new DV({
        param: e,
        type: t == null ? void 0 : t.type,
        modifier: i.modifier
      });
  }
  const u = {
    type: `${l}${i.array ?? ""}`,
    ...o,
    ...s,
    ...c
  };
  return Qm.set(n, u), u;
}
function Ei(e, t = [], n = "", r = 0) {
  const i = e.trim().length;
  for (let o = 0; o < i; o++) {
    const s = e[o], a = e.slice(o + 1);
    switch (s) {
      case ",":
        return r === 0 ? Ei(a, [...t, n.trim()]) : Ei(a, t, `${n}${s}`, r);
      case "(":
        return Ei(a, t, `${n}${s}`, r + 1);
      case ")":
        return Ei(a, t, `${n}${s}`, r - 1);
      default:
        return Ei(a, t, `${n}${s}`, r);
    }
  }
  if (n === "")
    return t;
  if (r !== 0)
    throw new UV({ current: n, depth: r });
  return t.push(n.trim()), t;
}
function b_(e) {
  return e === "address" || e === "bool" || e === "function" || e === "string" || u_.test(e) || d_.test(e);
}
const GV = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
function HV(e) {
  return e === "address" || e === "bool" || e === "function" || e === "string" || e === "tuple" || u_.test(e) || d_.test(e) || GV.test(e);
}
function KV(e, t) {
  return t || e === "bytes" || e === "string" || e === "tuple";
}
function YV(e) {
  const t = {}, n = e.length;
  for (let s = 0; s < n; s++) {
    const a = e[s];
    if (!g_(a))
      continue;
    const l = CV(a);
    if (!l)
      throw new gu({ signature: a, type: "struct" });
    const c = l.properties.split(";"), u = [], d = c.length;
    for (let f = 0; f < d; f++) {
      const p = c[f].trim();
      if (!p)
        continue;
      const m = Zs(p, {
        type: "struct"
      });
      u.push(m);
    }
    if (!u.length)
      throw new FV({ signature: a });
    t[l.name] = u;
  }
  const r = {}, i = Object.entries(t), o = i.length;
  for (let s = 0; s < o; s++) {
    const [a, l] = i[s];
    r[a] = w_(l, t);
  }
  return r;
}
const QV = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
function w_(e, t, n = /* @__PURE__ */ new Set()) {
  const r = [], i = e.length;
  for (let o = 0; o < i; o++) {
    const s = e[o];
    if (f_.test(s.type))
      r.push(s);
    else {
      const l = Ls(QV, s.type);
      if (!(l != null && l.type))
        throw new jV({ abiParameter: s });
      const { array: c, type: u } = l;
      if (u in t) {
        if (n.has(u))
          throw new LV({ type: u });
        r.push({
          ...s,
          type: `tuple${c ?? ""}`,
          components: w_(t[u] ?? [], t, /* @__PURE__ */ new Set([...n, u]))
        });
      } else if (b_(u))
        r.push(s);
      else
        throw new RV({ type: u });
    }
  }
  return r;
}
function x_(e) {
  const t = YV(e), n = [], r = e.length;
  for (let i = 0; i < r; i++) {
    const o = e[i];
    g_(o) || n.push(VV(o, t));
  }
  return n;
}
function JV(e) {
  let t = !0, n = "", r = 0, i = "", o = !1;
  for (let s = 0; s < e.length; s++) {
    const a = e[s];
    if (["(", ")", ","].includes(a) && (t = !0), a === "(" && r++, a === ")" && r--, !!t) {
      if (r === 0) {
        if (a === " " && ["event", "function", ""].includes(i))
          i = "";
        else if (i += a, a === ")") {
          o = !0;
          break;
        }
        continue;
      }
      if (a === " ") {
        e[s - 1] !== "," && n !== "," && n !== ",(" && (n = "", t = !1);
        continue;
      }
      i += a, n += a;
    }
  }
  if (!o)
    throw new be("Unable to normalize signature.");
  return i;
}
const XV = (e) => {
  const t = typeof e == "string" ? e : yV(e);
  return JV(t);
};
function C_(e) {
  return hV(XV(e));
}
const Qp = C_, Aw = (e) => Lu(C_(e), 0, 4);
function Ld(e) {
  const { abi: t, args: n = [], name: r } = e, i = ii(r, { strict: !1 }), o = t.filter((a) => i ? a.type === "function" ? Aw(a) === r : a.type === "event" ? Qp(a) === r : !1 : "name" in a && a.name === r);
  if (o.length === 0)
    return;
  if (o.length === 1)
    return o[0];
  let s;
  for (const a of o) {
    if (!("inputs" in a))
      continue;
    if (!n || n.length === 0) {
      if (!a.inputs || a.inputs.length === 0)
        return a;
      continue;
    }
    if (!a.inputs || a.inputs.length === 0 || a.inputs.length !== n.length)
      continue;
    if (n.every((c, u) => {
      const d = "inputs" in a && a.inputs[u];
      return d ? gb(c, d) : !1;
    })) {
      if (s && "inputs" in s && s.inputs) {
        const c = k_(a.inputs, s.inputs, n);
        if (c)
          throw new xU({
            abiItem: a,
            type: c[0]
          }, {
            abiItem: s,
            type: c[1]
          });
      }
      s = a;
    }
  }
  return s || o[0];
}
function gb(e, t) {
  const n = typeof e, r = t.type;
  switch (r) {
    case "address":
      return bn(e, { strict: !1 });
    case "bool":
      return n === "boolean";
    case "function":
      return n === "string";
    case "string":
      return n === "string";
    default:
      return r === "tuple" && "components" in t ? Object.values(t.components).every((i, o) => gb(Object.values(e)[o], i)) : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(r) ? n === "number" || n === "bigint" : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(r) ? n === "string" || e instanceof Uint8Array : /[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(r) ? Array.isArray(e) && e.every((i) => gb(i, {
        ...t,
        // Pop off `[]` or `[M]` from end of type
        type: r.replace(/(\[[0-9]{0,}\])$/, "")
      })) : !1;
  }
}
function k_(e, t, n) {
  for (const r in e) {
    const i = e[r], o = t[r];
    if (i.type === "tuple" && o.type === "tuple" && "components" in i && "components" in o)
      return k_(i.components, o.components, n[r]);
    const s = [i.type, o.type];
    if (s.includes("address") && s.includes("bytes20") ? !0 : s.includes("address") && s.includes("string") ? bn(n[r], { strict: !1 }) : s.includes("address") && s.includes("bytes") ? bn(n[r], { strict: !1 }) : !1)
      return s;
  }
}
const Jm = "/docs/contract/decodeFunctionResult";
function Dc(e) {
  const { abi: t, args: n, functionName: r, data: i } = e;
  let o = t[0];
  if (r) {
    const a = Ld({ abi: t, args: n, name: r });
    if (!a)
      throw new Vh(r, { docsPath: Jm });
    o = a;
  }
  if (o.type !== "function")
    throw new Vh(void 0, { docsPath: Jm });
  if (!o.outputs)
    throw new wU(o.name, { docsPath: Jm });
  const s = Yp(o.outputs, i);
  if (s && s.length > 1)
    return s;
  if (s && s.length === 1)
    return s[0];
}
const Uk = "/docs/contract/encodeFunctionData";
function ZV(e) {
  const { abi: t, args: n, functionName: r } = e;
  let i = t[0];
  if (r) {
    const o = Ld({
      abi: t,
      args: n,
      name: r
    });
    if (!o)
      throw new Vh(r, { docsPath: Uk });
    i = o;
  }
  if (i.type !== "function")
    throw new Vh(void 0, { docsPath: Uk });
  return {
    abi: [i],
    functionName: Aw(Io(i))
  };
}
function za(e) {
  const { args: t } = e, { abi: n, functionName: r } = (() => {
    var a;
    return e.abi.length === 1 && ((a = e.functionName) != null && a.startsWith("0x")) ? e : ZV(e);
  })(), i = n[0], o = r, s = "inputs" in i && i.inputs ? Bc(i.inputs, t ?? []) : void 0;
  return Pi([o, s ?? "0x"]);
}
function jc({ blockNumber: e, chain: t, contract: n }) {
  var i;
  const r = (i = t == null ? void 0 : t.contracts) == null ? void 0 : i[n];
  if (!r)
    throw new nb({
      chain: t,
      contract: { name: n }
    });
  if (e && r.blockCreated && r.blockCreated > e)
    throw new nb({
      blockNumber: e,
      chain: t,
      contract: {
        name: n,
        blockCreated: r.blockCreated
      }
    });
  return r.address;
}
const E_ = {
  1: "An `assert` condition failed.",
  17: "Arithmetic operation resulted in underflow or overflow.",
  18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
  33: "Attempted to convert to an invalid type.",
  34: "Attempted to access a storage byte array that is incorrectly encoded.",
  49: "Performed `.pop()` on an empty array",
  50: "Array index is out of bounds.",
  65: "Allocated too much memory or created an array which is too large.",
  81: "Attempted to call a zero-initialized variable of internal function type."
}, eq = {
  inputs: [
    {
      name: "message",
      type: "string"
    }
  ],
  name: "Error",
  type: "error"
}, tq = {
  inputs: [
    {
      name: "reason",
      type: "uint256"
    }
  ],
  name: "Panic",
  type: "error"
};
function nq(e) {
  const { abi: t, data: n } = e, r = Lu(n, 0, 4);
  if (r === "0x")
    throw new Up();
  const o = [...t || [], eq, tq].find((s) => s.type === "error" && r === Aw(Io(s)));
  if (!o)
    throw new kT(r, {
      docsPath: "/docs/contract/decodeErrorResult"
    });
  return {
    abiItem: o,
    args: "inputs" in o && o.inputs && o.inputs.length > 0 ? Yp(o.inputs, Lu(n, 4)) : void 0,
    errorName: o.name
  };
}
function S_({ abiItem: e, args: t, includeFunctionName: n = !0, includeName: r = !1 }) {
  if ("name" in e && "inputs" in e && e.inputs)
    return `${n ? e.name : ""}(${e.inputs.map((i, o) => `${r && i.name ? `${i.name}: ` : ""}${typeof t[o] == "object" ? Jn(t[o]) : t[o]}`).join(", ")})`;
}
class A_ extends be {
  constructor(t, { account: n, docsPath: r, chain: i, data: o, gas: s, gasPrice: a, maxFeePerGas: l, maxPriorityFeePerGas: c, nonce: u, to: d, value: f, stateOverride: h }) {
    var g;
    const p = n ? ui(n) : void 0;
    let m = Nd({
      from: p == null ? void 0 : p.address,
      to: d,
      value: typeof f < "u" && `${mw(f)} ${((g = i == null ? void 0 : i.nativeCurrency) == null ? void 0 : g.symbol) || "ETH"}`,
      data: o,
      gas: s,
      gasPrice: typeof a < "u" && `${kr(a)} gwei`,
      maxFeePerGas: typeof l < "u" && `${kr(l)} gwei`,
      maxPriorityFeePerGas: typeof c < "u" && `${kr(c)} gwei`,
      nonce: u
    });
    h && (m += `
${Lz(h)}`), super(t.shortMessage, {
      cause: t,
      docsPath: r,
      metaMessages: [
        ...t.metaMessages ? [...t.metaMessages, " "] : [],
        "Raw Call Arguments:",
        m
      ].filter(Boolean),
      name: "CallExecutionError"
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cause = t;
  }
}
class rq extends be {
  constructor(t, { abi: n, args: r, contractAddress: i, docsPath: o, functionName: s, sender: a }) {
    const l = Ld({ abi: n, args: r, name: s }), c = l ? S_({
      abiItem: l,
      args: r,
      includeFunctionName: !1,
      includeName: !1
    }) : void 0, u = l ? Io(l, { includeName: !0 }) : void 0, d = Nd({
      address: i && kz(i),
      function: u,
      args: c && c !== "()" && `${[...Array((s == null ? void 0 : s.length) ?? 0).keys()].map(() => " ").join("")}${c}`,
      sender: a
    });
    super(t.shortMessage || `An unknown error occurred while executing the contract function "${s}".`, {
      cause: t,
      docsPath: o,
      metaMessages: [
        ...t.metaMessages ? [...t.metaMessages, " "] : [],
        d && "Contract Call:",
        d
      ].filter(Boolean),
      name: "ContractFunctionExecutionError"
    }), Object.defineProperty(this, "abi", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "args", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "contractAddress", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "formattedArgs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "functionName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "sender", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.abi = n, this.args = r, this.cause = t, this.contractAddress = i, this.functionName = s, this.sender = a;
  }
}
class vb extends be {
  constructor({ abi: t, data: n, functionName: r, message: i }) {
    let o, s, a, l;
    if (n && n !== "0x")
      try {
        s = nq({ abi: t, data: n });
        const { abiItem: u, errorName: d, args: f } = s;
        if (d === "Error")
          l = f[0];
        else if (d === "Panic") {
          const [h] = f;
          l = E_[h];
        } else {
          const h = u ? Io(u, { includeName: !0 }) : void 0, p = u && f ? S_({
            abiItem: u,
            args: f,
            includeFunctionName: !1,
            includeName: !1
          }) : void 0;
          a = [
            h ? `Error: ${h}` : "",
            p && p !== "()" ? `       ${[...Array((d == null ? void 0 : d.length) ?? 0).keys()].map(() => " ").join("")}${p}` : ""
          ];
        }
      } catch (u) {
        o = u;
      }
    else i && (l = i);
    let c;
    o instanceof kT && (c = o.signature, a = [
      `Unable to decode signature "${c}" as it was not found on the provided ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${c}.`
    ]), super(l && l !== "execution reverted" || c ? [
      `The contract function "${r}" reverted with the following ${c ? "signature" : "reason"}:`,
      l || c
    ].join(`
`) : `The contract function "${r}" reverted.`, {
      cause: o,
      metaMessages: a,
      name: "ContractFunctionRevertedError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "reason", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = s, this.reason = l, this.signature = c;
  }
}
class iq extends be {
  constructor({ functionName: t }) {
    super(`The contract function "${t}" returned no data ("0x").`, {
      metaMessages: [
        "This could be due to any of the following:",
        `  - The contract does not have the function "${t}",`,
        "  - The parameters passed to the contract function may be invalid, or",
        "  - The address is not a contract."
      ],
      name: "ContractFunctionZeroDataError"
    });
  }
}
class oq extends be {
  constructor({ factory: t }) {
    super(`Deployment for counterfactual contract call failed${t ? ` for factory "${t}".` : ""}`, {
      metaMessages: [
        "Please ensure:",
        "- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).",
        "- The `factoryData` is a valid encoded function call for contract deployment function on the factory."
      ],
      name: "CounterfactualDeploymentFailedError"
    });
  }
}
class Tw extends be {
  constructor({ data: t, message: n }) {
    super(n || "", { name: "RawContractError" }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 3
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = t;
  }
}
function _w(e, t) {
  var r, i, o, s, a, l;
  if (!(e instanceof be))
    return !1;
  const n = e.walk((c) => c instanceof vb);
  return n instanceof vb ? !!(((r = n.data) == null ? void 0 : r.errorName) === "ResolverNotFound" || ((i = n.data) == null ? void 0 : i.errorName) === "ResolverWildcardNotSupported" || ((o = n.data) == null ? void 0 : o.errorName) === "ResolverNotContract" || ((s = n.data) == null ? void 0 : s.errorName) === "ResolverError" || ((a = n.data) == null ? void 0 : a.errorName) === "HttpError" || (l = n.reason) != null && l.includes("Wildcard on non-extended resolvers is not supported") || t === "reverse" && n.reason === E_[50]) : !1;
}
function T_(e) {
  if (e.length !== 66 || e.indexOf("[") !== 0 || e.indexOf("]") !== 65)
    return null;
  const t = `0x${e.slice(1, 65)}`;
  return ii(t) ? t : null;
}
function mh(e) {
  let t = new Uint8Array(32).fill(0);
  if (!e)
    return vn(t);
  const n = e.split(".");
  for (let r = n.length - 1; r >= 0; r -= 1) {
    const i = T_(n[r]), o = i ? Cs(i) : On(ba(n[r]), "bytes");
    t = On(Ro([t, o]), "bytes");
  }
  return vn(t);
}
function sq(e) {
  return `[${e.slice(2)}]`;
}
function aq(e) {
  const t = new Uint8Array(32).fill(0);
  return e ? T_(e) || On(ba(e)) : vn(t);
}
function Jp(e) {
  const t = e.replace(/^\.|\.$/gm, "");
  if (t.length === 0)
    return new Uint8Array(1);
  const n = new Uint8Array(ba(t).byteLength + 2);
  let r = 0;
  const i = t.split(".");
  for (let o = 0; o < i.length; o++) {
    let s = ba(i[o]);
    s.byteLength > 255 && (s = ba(sq(aq(i[o])))), n[r] = s.length, n.set(s, r + 1), r += s.length + 1;
  }
  return n.byteLength !== r + 1 ? n.slice(0, r + 1) : n;
}
const lq = 3;
function Zu(e, { abi: t, address: n, args: r, docsPath: i, functionName: o, sender: s }) {
  const { code: a, data: l, message: c, shortMessage: u } = e instanceof Tw ? e : e instanceof be ? e.walk((f) => "data" in f) || e.walk() : {}, d = e instanceof Up ? new iq({ functionName: o }) : [lq, _a.code].includes(a) && (l || c || u) ? new vb({
    abi: t,
    data: typeof l == "object" ? l.data : l,
    functionName: o,
    message: u ?? c
  }) : e;
  return new rq(d, {
    abi: t,
    args: r,
    contractAddress: n,
    docsPath: i,
    functionName: o,
    sender: s
  });
}
const cq = "0x82ad56cb", uq = "0x608060405234801561001057600080fd5b5060405161018e38038061018e83398101604081905261002f91610124565b6000808351602085016000f59050803b61004857600080fd5b6000808351602085016000855af16040513d6000823e81610067573d81fd5b3d81f35b634e487b7160e01b600052604160045260246000fd5b600082601f83011261009257600080fd5b81516001600160401b038111156100ab576100ab61006b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156100d9576100d961006b565b6040528181528382016020018510156100f157600080fd5b60005b82811015610110576020818601810151838301820152016100f4565b506000918101602001919091529392505050565b6000806040838503121561013757600080fd5b82516001600160401b0381111561014d57600080fd5b61015985828601610081565b602085015190935090506001600160401b0381111561017757600080fd5b61018385828601610081565b915050925092905056fe", dq = "0x608060405234801561001057600080fd5b506040516102c03803806102c083398101604081905261002f916101e6565b836001600160a01b03163b6000036100e457600080836001600160a01b03168360405161005c9190610270565b6000604051808303816000865af19150503d8060008114610099576040519150601f19603f3d011682016040523d82523d6000602084013e61009e565b606091505b50915091508115806100b857506001600160a01b0386163b155b156100e1578060405163101bb98d60e01b81526004016100d8919061028c565b60405180910390fd5b50505b6000808451602086016000885af16040513d6000823e81610103573d81fd5b3d81f35b80516001600160a01b038116811461011e57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561015457818101518382015260200161013c565b50506000910152565b600082601f83011261016e57600080fd5b81516001600160401b0381111561018757610187610123565b604051601f8201601f19908116603f011681016001600160401b03811182821017156101b5576101b5610123565b6040528181528382016020018510156101cd57600080fd5b6101de826020830160208701610139565b949350505050565b600080600080608085870312156101fc57600080fd5b61020585610107565b60208601519094506001600160401b0381111561022157600080fd5b61022d8782880161015d565b93505061023c60408601610107565b60608601519092506001600160401b0381111561025857600080fd5b6102648782880161015d565b91505092959194509250565b60008251610282818460208701610139565b9190910192915050565b60208152600082518060208401526102ab816040850160208701610139565b601f01601f1916919091016040019291505056fe", fq = "0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";
function __(e, { docsPath: t, ...n }) {
  const r = (() => {
    const i = vw(e, n);
    return i instanceof $p ? e : i;
  })();
  return new A_(r, {
    docsPath: t,
    ...n
  });
}
const Xm = /* @__PURE__ */ new Map();
function I_({ fn: e, id: t, shouldSplitBatch: n, wait: r = 0, sort: i }) {
  const o = async () => {
    const u = l();
    s();
    const d = u.map(({ args: f }) => f);
    d.length !== 0 && e(d).then((f) => {
      var h;
      i && Array.isArray(f) && f.sort(i);
      for (let p = 0; p < u.length; p++) {
        const { pendingPromise: m } = u[p];
        (h = m.resolve) == null || h.call(m, [f[p], f]);
      }
    }).catch((f) => {
      var h;
      for (let p = 0; p < u.length; p++) {
        const { pendingPromise: m } = u[p];
        (h = m.reject) == null || h.call(m, f);
      }
    });
  }, s = () => Xm.delete(t), a = () => l().map(({ args: u }) => u), l = () => Xm.get(t) || [], c = (u) => Xm.set(t, [...l(), u]);
  return {
    flush: s,
    async schedule(u) {
      const d = {}, f = new Promise((m, g) => {
        d.resolve = m, d.reject = g;
      });
      return (n == null ? void 0 : n([...a(), u])) && o(), l().length > 0 ? (c({ args: u, pendingPromise: d }), f) : (c({ args: u, pendingPromise: d }), setTimeout(o, r), f);
    }
  };
}
async function Xp(e, t) {
  var B, O, L, V;
  const { account: n = e.account, batch: r = !!((B = e.batch) != null && B.multicall), blockNumber: i, blockTag: o = "latest", accessList: s, blobs: a, code: l, data: c, factory: u, factoryData: d, gas: f, gasPrice: h, maxFeePerBlobGas: p, maxFeePerGas: m, maxPriorityFeePerGas: g, nonce: v, to: w, value: x, stateOverride: C, ...S } = t, k = n ? ui(n) : void 0;
  if (l && (u || d))
    throw new be("Cannot provide both `code` & `factory`/`factoryData` as parameters.");
  if (l && w)
    throw new be("Cannot provide both `code` & `to` as parameters.");
  const A = l && c, b = u && d && w && c, T = A || b, R = A ? yq({
    code: l,
    data: c
  }) : b ? mq({
    data: c,
    factory: u,
    factoryData: d,
    to: w
  }) : c;
  try {
    Md(t);
    const M = (i ? Fe(i) : void 0) || o, U = YT(C), F = (V = (L = (O = e.chain) == null ? void 0 : O.formatters) == null ? void 0 : L.transactionRequest) == null ? void 0 : V.format, ie = (F || Dd)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...Wp(S, { format: F }),
      from: k == null ? void 0 : k.address,
      accessList: s,
      blobs: a,
      data: R,
      gas: f,
      gasPrice: h,
      maxFeePerBlobGas: p,
      maxFeePerGas: m,
      maxPriorityFeePerGas: g,
      nonce: v,
      to: T ? void 0 : w,
      value: x
    });
    if (r && hq({ request: ie }) && !U)
      try {
        return await pq(e, {
          ...ie,
          blockNumber: i,
          blockTag: o
        });
      } catch (ae) {
        if (!(ae instanceof LT) && !(ae instanceof nb))
          throw ae;
      }
    const he = await e.request({
      method: "eth_call",
      params: U ? [
        ie,
        M,
        U
      ] : [ie, M]
    });
    return he === "0x" ? { data: void 0 } : { data: he };
  } catch (N) {
    const M = gq(N), { offchainLookup: U, offchainLookupSignature: F } = await import("./ccip-B1FDrn8S.js");
    if (e.ccipRead !== !1 && (M == null ? void 0 : M.slice(0, 10)) === F && w)
      return { data: await U(e, { data: M, to: w }) };
    throw T && (M == null ? void 0 : M.slice(0, 10)) === "0x101bb98d" ? new oq({ factory: u }) : __(N, {
      ...t,
      account: k,
      chain: e.chain
    });
  }
}
function hq({ request: e }) {
  const { data: t, to: n, ...r } = e;
  return !(!t || t.startsWith(cq) || !n || Object.values(r).filter((i) => typeof i < "u").length > 0);
}
async function pq(e, t) {
  var m;
  const { batchSize: n = 1024, wait: r = 0 } = typeof ((m = e.batch) == null ? void 0 : m.multicall) == "object" ? e.batch.multicall : {}, { blockNumber: i, blockTag: o = "latest", data: s, multicallAddress: a, to: l } = t;
  let c = a;
  if (!c) {
    if (!e.chain)
      throw new LT();
    c = jc({
      blockNumber: i,
      chain: e.chain,
      contract: "multicall3"
    });
  }
  const d = (i ? Fe(i) : void 0) || o, { schedule: f } = I_({
    id: `${e.uid}.${d}`,
    wait: r,
    shouldSplitBatch(g) {
      return g.reduce((w, { data: x }) => w + (x.length - 2), 0) > n * 2;
    },
    fn: async (g) => {
      const v = g.map((C) => ({
        allowFailure: !0,
        callData: C.data,
        target: C.to
      })), w = za({
        abi: fb,
        args: [v],
        functionName: "aggregate3"
      }), x = await e.request({
        method: "eth_call",
        params: [
          {
            data: w,
            to: c
          },
          d
        ]
      });
      return Dc({
        abi: fb,
        args: [v],
        functionName: "aggregate3",
        data: x || "0x"
      });
    }
  }), [{ returnData: h, success: p }] = await f({ data: s, to: l });
  if (!p)
    throw new Tw({ data: h });
  return h === "0x" ? { data: void 0 } : { data: h };
}
function yq(e) {
  const { code: t, data: n } = e;
  return hw({
    abi: x_(["constructor(bytes, bytes)"]),
    bytecode: uq,
    args: [t, n]
  });
}
function mq(e) {
  const { data: t, factory: n, factoryData: r, to: i } = e;
  return hw({
    abi: x_(["constructor(address, bytes, address, bytes)"]),
    bytecode: dq,
    args: [i, t, n, r]
  });
}
function gq(e) {
  var n;
  if (!(e instanceof be))
    return;
  const t = e.walk();
  return typeof (t == null ? void 0 : t.data) == "object" ? (n = t.data) == null ? void 0 : n.data : t.data;
}
async function Oo(e, t) {
  const { abi: n, address: r, args: i, functionName: o, ...s } = t, a = za({
    abi: n,
    args: i,
    functionName: o
  });
  try {
    const { data: l } = await at(e, Xp, "call")({
      ...s,
      data: a,
      to: r
    });
    return Dc({
      abi: n,
      args: i,
      functionName: o,
      data: l || "0x"
    });
  } catch (l) {
    throw Zu(l, {
      abi: n,
      address: r,
      args: i,
      docsPath: "/docs/contract/readContract",
      functionName: o
    });
  }
}
async function vq(e, { blockNumber: t, blockTag: n, coinType: r, name: i, gatewayUrls: o, strict: s, universalResolverAddress: a }) {
  let l = a;
  if (!l) {
    if (!e.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    l = jc({
      blockNumber: t,
      chain: e.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const c = za({
      abi: Mk,
      functionName: "addr",
      ...r != null ? { args: [mh(i), BigInt(r)] } : { args: [mh(i)] }
    }), u = {
      address: l,
      abi: c_,
      functionName: "resolve",
      args: [$e(Jp(i)), c],
      blockNumber: t,
      blockTag: n
    }, d = at(e, Oo, "readContract"), f = o ? await d({
      ...u,
      args: [...u.args, o]
    }) : await d(u);
    if (f[0] === "0x")
      return null;
    const h = Dc({
      abi: Mk,
      args: r != null ? [mh(i), BigInt(r)] : void 0,
      functionName: "addr",
      data: f[0]
    });
    return h === "0x" || Ji(h) === "0x00" ? null : h;
  } catch (c) {
    if (s)
      throw c;
    if (_w(c, "resolve"))
      return null;
    throw c;
  }
}
class bq extends be {
  constructor({ data: t }) {
    super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
      metaMessages: [
        "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
        "",
        `Provided data: ${JSON.stringify(t)}`
      ],
      name: "EnsAvatarInvalidMetadataError"
    });
  }
}
class su extends be {
  constructor({ reason: t }) {
    super(`ENS NFT avatar URI is invalid. ${t}`, {
      name: "EnsAvatarInvalidNftUriError"
    });
  }
}
class Iw extends be {
  constructor({ uri: t }) {
    super(`Unable to resolve ENS avatar URI "${t}". The URI may be malformed, invalid, or does not respond with a valid image.`, { name: "EnsAvatarUriResolutionError" });
  }
}
class wq extends be {
  constructor({ namespace: t }) {
    super(`ENS NFT avatar namespace "${t}" is not supported. Must be "erc721" or "erc1155".`, { name: "EnsAvatarUnsupportedNamespaceError" });
  }
}
const xq = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/, Cq = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/, kq = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/, Eq = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function Sq(e) {
  try {
    const t = await fetch(e, { method: "HEAD" });
    if (t.status === 200) {
      const n = t.headers.get("content-type");
      return n == null ? void 0 : n.startsWith("image/");
    }
    return !1;
  } catch (t) {
    return typeof t == "object" && typeof t.response < "u" || !globalThis.hasOwnProperty("Image") ? !1 : new Promise((n) => {
      const r = new Image();
      r.onload = () => {
        n(!0);
      }, r.onerror = () => {
        n(!1);
      }, r.src = e;
    });
  }
}
function zk(e, t) {
  return e ? e.endsWith("/") ? e.slice(0, -1) : e : t;
}
function R_({ uri: e, gatewayUrls: t }) {
  const n = kq.test(e);
  if (n)
    return { uri: e, isOnChain: !0, isEncoded: n };
  const r = zk(t == null ? void 0 : t.ipfs, "https://ipfs.io"), i = zk(t == null ? void 0 : t.arweave, "https://arweave.net"), o = e.match(xq), { protocol: s, subpath: a, target: l, subtarget: c = "" } = (o == null ? void 0 : o.groups) || {}, u = s === "ipns:/" || a === "ipns/", d = s === "ipfs:/" || a === "ipfs/" || Cq.test(e);
  if (e.startsWith("http") && !u && !d) {
    let h = e;
    return t != null && t.arweave && (h = e.replace(/https:\/\/arweave.net/g, t == null ? void 0 : t.arweave)), { uri: h, isOnChain: !1, isEncoded: !1 };
  }
  if ((u || d) && l)
    return {
      uri: `${r}/${u ? "ipns" : "ipfs"}/${l}${c}`,
      isOnChain: !1,
      isEncoded: !1
    };
  if (s === "ar:/" && l)
    return {
      uri: `${i}/${l}${c || ""}`,
      isOnChain: !1,
      isEncoded: !1
    };
  let f = e.replace(Eq, "");
  if (f.startsWith("<svg") && (f = `data:image/svg+xml;base64,${btoa(f)}`), f.startsWith("data:") || f.startsWith("{"))
    return {
      uri: f,
      isOnChain: !0,
      isEncoded: !1
    };
  throw new Iw({ uri: e });
}
function P_(e) {
  if (typeof e != "object" || !("image" in e) && !("image_url" in e) && !("image_data" in e))
    throw new bq({ data: e });
  return e.image || e.image_url || e.image_data;
}
async function Aq({ gatewayUrls: e, uri: t }) {
  try {
    const n = await fetch(t).then((i) => i.json());
    return await Rw({
      gatewayUrls: e,
      uri: P_(n)
    });
  } catch {
    throw new Iw({ uri: t });
  }
}
async function Rw({ gatewayUrls: e, uri: t }) {
  const { uri: n, isOnChain: r } = R_({ uri: t, gatewayUrls: e });
  if (r || await Sq(n))
    return n;
  throw new Iw({ uri: t });
}
function Tq(e) {
  let t = e;
  t.startsWith("did:nft:") && (t = t.replace("did:nft:", "").replace(/_/g, "/"));
  const [n, r, i] = t.split("/"), [o, s] = n.split(":"), [a, l] = r.split(":");
  if (!o || o.toLowerCase() !== "eip155")
    throw new su({ reason: "Only EIP-155 supported" });
  if (!s)
    throw new su({ reason: "Chain ID not found" });
  if (!l)
    throw new su({
      reason: "Contract address not found"
    });
  if (!i)
    throw new su({ reason: "Token ID not found" });
  if (!a)
    throw new su({ reason: "ERC namespace not found" });
  return {
    chainID: Number.parseInt(s),
    namespace: a.toLowerCase(),
    contractAddress: l,
    tokenID: i
  };
}
async function _q(e, { nft: t }) {
  if (t.namespace === "erc721")
    return Oo(e, {
      address: t.contractAddress,
      abi: [
        {
          name: "tokenURI",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "tokenId", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "tokenURI",
      args: [BigInt(t.tokenID)]
    });
  if (t.namespace === "erc1155")
    return Oo(e, {
      address: t.contractAddress,
      abi: [
        {
          name: "uri",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "_id", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "uri",
      args: [BigInt(t.tokenID)]
    });
  throw new wq({ namespace: t.namespace });
}
async function Iq(e, { gatewayUrls: t, record: n }) {
  return /eip155:/i.test(n) ? Rq(e, { gatewayUrls: t, record: n }) : Rw({ uri: n, gatewayUrls: t });
}
async function Rq(e, { gatewayUrls: t, record: n }) {
  const r = Tq(n), i = await _q(e, { nft: r }), { uri: o, isOnChain: s, isEncoded: a } = R_({ uri: i, gatewayUrls: t });
  if (s && (o.includes("data:application/json;base64,") || o.startsWith("{"))) {
    const c = a ? (
      // if it is encoded, decode it
      atob(o.replace("data:application/json;base64,", ""))
    ) : (
      // if it isn't encoded assume it is a JSON string, but it could be anything (it will error if it is)
      o
    ), u = JSON.parse(c);
    return Rw({ uri: P_(u), gatewayUrls: t });
  }
  let l = r.tokenID;
  return r.namespace === "erc1155" && (l = l.replace("0x", "").padStart(64, "0")), Aq({
    gatewayUrls: t,
    uri: o.replace(/(?:0x)?{id}/, l)
  });
}
async function O_(e, { blockNumber: t, blockTag: n, name: r, key: i, gatewayUrls: o, strict: s, universalResolverAddress: a }) {
  let l = a;
  if (!l) {
    if (!e.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    l = jc({
      blockNumber: t,
      chain: e.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const c = {
      address: l,
      abi: c_,
      functionName: "resolve",
      args: [
        $e(Jp(r)),
        za({
          abi: jk,
          functionName: "text",
          args: [mh(r), i]
        })
      ],
      blockNumber: t,
      blockTag: n
    }, u = at(e, Oo, "readContract"), d = o ? await u({
      ...c,
      args: [...c.args, o]
    }) : await u(c);
    if (d[0] === "0x")
      return null;
    const f = Dc({
      abi: jk,
      functionName: "text",
      data: d[0]
    });
    return f === "" ? null : f;
  } catch (c) {
    if (s)
      throw c;
    if (_w(c, "resolve"))
      return null;
    throw c;
  }
}
async function B_(e, { blockNumber: t, blockTag: n, assetGatewayUrls: r, name: i, gatewayUrls: o, strict: s, universalResolverAddress: a }) {
  const l = await at(e, O_, "getEnsText")({
    blockNumber: t,
    blockTag: n,
    key: "avatar",
    name: i,
    universalResolverAddress: a,
    gatewayUrls: o,
    strict: s
  });
  if (!l)
    return null;
  try {
    return await Iq(e, {
      record: l,
      gatewayUrls: r
    });
  } catch {
    return null;
  }
}
async function N_(e, { address: t, blockNumber: n, blockTag: r, gatewayUrls: i, strict: o, universalResolverAddress: s }) {
  let a = s;
  if (!a) {
    if (!e.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    a = jc({
      blockNumber: n,
      chain: e.chain,
      contract: "ensUniversalResolver"
    });
  }
  const l = `${t.toLowerCase().substring(2)}.addr.reverse`;
  try {
    const c = {
      address: a,
      abi: eV,
      functionName: "reverse",
      args: [$e(Jp(l))],
      blockNumber: n,
      blockTag: r
    }, u = at(e, Oo, "readContract"), [d, f] = i ? await u({
      ...c,
      args: [...c.args, i]
    }) : await u(c);
    return t.toLowerCase() !== f.toLowerCase() ? null : d;
  } catch (c) {
    if (o)
      throw c;
    if (_w(c, "reverse"))
      return null;
    throw c;
  }
}
async function Pq(e, { blockNumber: t, blockTag: n, name: r, universalResolverAddress: i }) {
  let o = i;
  if (!o) {
    if (!e.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    o = jc({
      blockNumber: t,
      chain: e.chain,
      contract: "ensUniversalResolver"
    });
  }
  const [s] = await at(e, Oo, "readContract")({
    address: o,
    abi: [
      {
        inputs: [{ type: "bytes" }],
        name: "findResolver",
        outputs: [{ type: "address" }, { type: "bytes32" }],
        stateMutability: "view",
        type: "function"
      }
    ],
    functionName: "findResolver",
    args: [$e(Jp(r))],
    blockNumber: t,
    blockTag: n
  });
  return s;
}
function Zp(e, { method: t }) {
  var r, i;
  const n = {};
  return e.transport.type === "fallback" && ((i = (r = e.transport).onResponse) == null || i.call(r, ({ method: o, response: s, status: a, transport: l }) => {
    a === "success" && t === o && (n[s] = l.request);
  })), (o) => n[o] || e.request;
}
async function Oq(e) {
  const t = Zp(e, {
    method: "eth_newBlockFilter"
  }), n = await e.request({
    method: "eth_newBlockFilter"
  });
  return { id: n, request: t(n), type: "block" };
}
class Bq extends be {
  constructor(t) {
    super(`Filter type "${t}" is not supported.`, {
      name: "FilterTypeNotSupportedError"
    });
  }
}
const Vk = "/docs/contract/encodeEventTopics";
function Ud(e) {
  var l;
  const { abi: t, eventName: n, args: r } = e;
  let i = t[0];
  if (n) {
    const c = Ld({ abi: t, name: n });
    if (!c)
      throw new Ck(n, { docsPath: Vk });
    i = c;
  }
  if (i.type !== "event")
    throw new Ck(void 0, { docsPath: Vk });
  const o = Io(i), s = Qp(o);
  let a = [];
  if (r && "inputs" in i) {
    const c = (l = i.inputs) == null ? void 0 : l.filter((d) => "indexed" in d && d.indexed), u = Array.isArray(r) ? r : Object.values(r).length > 0 ? (c == null ? void 0 : c.map((d) => r[d.name])) ?? [] : [];
    u.length > 0 && (a = (c == null ? void 0 : c.map((d, f) => Array.isArray(u[f]) ? u[f].map((h, p) => qk({ param: d, value: u[f][p] })) : u[f] ? qk({ param: d, value: u[f] }) : null)) ?? []);
  }
  return [s, ...a];
}
function qk({ param: e, value: t }) {
  if (e.type === "string" || e.type === "bytes")
    return On(Cs(t));
  if (e.type === "tuple" || e.type.match(/^(.*)\[(\d+)?\]$/))
    throw new Bq(e.type);
  return Bc([e], [t]);
}
async function D_(e, t) {
  const { address: n, abi: r, args: i, eventName: o, fromBlock: s, strict: a, toBlock: l } = t, c = Zp(e, {
    method: "eth_newFilter"
  }), u = o ? Ud({
    abi: r,
    args: i,
    eventName: o
  }) : void 0, d = await e.request({
    method: "eth_newFilter",
    params: [
      {
        address: n,
        fromBlock: typeof s == "bigint" ? Fe(s) : s,
        toBlock: typeof l == "bigint" ? Fe(l) : l,
        topics: u
      }
    ]
  });
  return {
    abi: r,
    args: i,
    eventName: o,
    id: d,
    request: c(d),
    strict: !!a,
    type: "event"
  };
}
async function j_(e, { address: t, args: n, event: r, events: i, fromBlock: o, strict: s, toBlock: a } = {}) {
  const l = i ?? (r ? [r] : void 0), c = Zp(e, {
    method: "eth_newFilter"
  });
  let u = [];
  l && (u = [l.flatMap((h) => Ud({
    abi: [h],
    eventName: h.name,
    args: n
  }))], r && (u = u[0]));
  const d = await e.request({
    method: "eth_newFilter",
    params: [
      {
        address: t,
        fromBlock: typeof o == "bigint" ? Fe(o) : o,
        toBlock: typeof a == "bigint" ? Fe(a) : a,
        ...u.length ? { topics: u } : {}
      }
    ]
  });
  return {
    abi: l,
    args: n,
    eventName: r ? r.name : void 0,
    fromBlock: o,
    id: d,
    request: c(d),
    strict: !!s,
    toBlock: a,
    type: "event"
  };
}
async function M_(e) {
  const t = Zp(e, {
    method: "eth_newPendingTransactionFilter"
  }), n = await e.request({
    method: "eth_newPendingTransactionFilter"
  });
  return { id: n, request: t(n), type: "transaction" };
}
async function Nq(e, t) {
  const { abi: n, address: r, args: i, functionName: o, ...s } = t, a = za({
    abi: n,
    args: i,
    functionName: o
  });
  try {
    return await at(e, Hp, "estimateGas")({
      data: a,
      to: r,
      ...s
    });
  } catch (l) {
    const c = s.account ? ui(s.account) : void 0;
    throw Zu(l, {
      abi: n,
      address: r,
      args: i,
      docsPath: "/docs/contract/estimateContractGas",
      functionName: o,
      sender: c == null ? void 0 : c.address
    });
  }
}
async function Dq(e) {
  const t = await e.request({
    method: "eth_blobBaseFee"
  });
  return BigInt(t);
}
const jq = /* @__PURE__ */ new Map(), Mq = /* @__PURE__ */ new Map();
function Fq(e) {
  const t = (i, o) => ({
    clear: () => o.delete(i),
    get: () => o.get(i),
    set: (s) => o.set(i, s)
  }), n = t(e, jq), r = t(e, Mq);
  return {
    clear: () => {
      n.clear(), r.clear();
    },
    promise: n,
    response: r
  };
}
async function Lq(e, { cacheKey: t, cacheTime: n = Number.POSITIVE_INFINITY }) {
  const r = Fq(t), i = r.response.get();
  if (i && n > 0 && (/* @__PURE__ */ new Date()).getTime() - i.created.getTime() < n)
    return i.data;
  let o = r.promise.get();
  o || (o = e(), r.promise.set(o));
  try {
    const s = await o;
    return r.response.set({ created: /* @__PURE__ */ new Date(), data: s }), s;
  } finally {
    r.promise.clear();
  }
}
const Uq = (e) => `blockNumber.${e}`;
async function zd(e, { cacheTime: t = e.cacheTime } = {}) {
  const n = await Lq(() => e.request({
    method: "eth_blockNumber"
  }), { cacheKey: Uq(e.uid), cacheTime: t });
  return BigInt(n);
}
async function zq(e, { blockHash: t, blockNumber: n, blockTag: r = "latest" } = {}) {
  const i = n !== void 0 ? Fe(n) : void 0;
  let o;
  return t ? o = await e.request({
    method: "eth_getBlockTransactionCountByHash",
    params: [t]
  }, { dedupe: !0 }) : o = await e.request({
    method: "eth_getBlockTransactionCountByNumber",
    params: [i || r]
  }, { dedupe: !!i }), Xi(o);
}
async function $k(e, { address: t, blockNumber: n, blockTag: r = "latest" }) {
  const i = n !== void 0 ? Fe(n) : void 0, o = await e.request({
    method: "eth_getCode",
    params: [t, i || r]
  }, { dedupe: !!i });
  if (o !== "0x")
    return o;
}
function Pw(e, t) {
  if (!bn(e, { strict: !1 }))
    throw new Zn({ address: e });
  if (!bn(t, { strict: !1 }))
    throw new Zn({ address: t });
  return e.toLowerCase() === t.toLowerCase();
}
const Wk = "/docs/contract/decodeEventLog";
function Ow(e) {
  const { abi: t, data: n, strict: r, topics: i } = e, o = r ?? !0, [s, ...a] = i;
  if (!s)
    throw new bU({ docsPath: Wk });
  const l = t.length === 1 ? t[0] : t.find((m) => m.type === "event" && s === Qp(Io(m)));
  if (!(l && "name" in l) || l.type !== "event")
    throw new ET(s, { docsPath: Wk });
  const { name: c, inputs: u } = l, d = u == null ? void 0 : u.some((m) => !("name" in m && m.name));
  let f = d ? [] : {};
  const h = u.filter((m) => "indexed" in m && m.indexed);
  for (let m = 0; m < h.length; m++) {
    const g = h[m], v = a[m];
    if (!v)
      throw new zp({
        abiItem: l,
        param: g
      });
    f[d ? m : g.name || m] = Vq({ param: g, value: v });
  }
  const p = u.filter((m) => !("indexed" in m && m.indexed));
  if (p.length > 0) {
    if (n && n !== "0x")
      try {
        const m = Yp(p, n);
        if (m)
          if (d)
            f = [...f, ...m];
          else
            for (let g = 0; g < p.length; g++)
              f[p[g].name] = m[g];
      } catch (m) {
        if (o)
          throw m instanceof CT || m instanceof DT ? new Fu({
            abiItem: l,
            data: n,
            params: p,
            size: ln(n)
          }) : m;
      }
    else if (o)
      throw new Fu({
        abiItem: l,
        data: "0x",
        params: p,
        size: 0
      });
  }
  return {
    eventName: c,
    args: Object.values(f).length > 0 ? f : void 0
  };
}
function Vq({ param: e, value: t }) {
  return e.type === "string" || e.type === "bytes" || e.type === "tuple" || e.type.match(/^(.*)\[(\d+)?\]$/) ? t : (Yp([e], t) || [])[0];
}
function Bw(e) {
  const { abi: t, args: n, logs: r, strict: i = !0 } = e, o = (() => {
    if (e.eventName)
      return Array.isArray(e.eventName) ? e.eventName : [e.eventName];
  })();
  return r.map((s) => {
    var a;
    try {
      const l = t.find((u) => u.type === "event" && s.topics[0] === Qp(u));
      if (!l)
        return null;
      const c = Ow({
        ...s,
        abi: [l],
        strict: i
      });
      return o && !o.includes(c.eventName) || !qq({
        args: c.args,
        inputs: l.inputs,
        matchArgs: n
      }) ? null : { ...c, ...s };
    } catch (l) {
      let c, u;
      if (l instanceof ET)
        return null;
      if (l instanceof Fu || l instanceof zp) {
        if (i)
          return null;
        c = l.abiItem.name, u = (a = l.abiItem.inputs) == null ? void 0 : a.some((d) => !("name" in d && d.name));
      }
      return { ...s, args: u ? [] : {}, eventName: c };
    }
  }).filter(Boolean);
}
function qq(e) {
  const { args: t, inputs: n, matchArgs: r } = e;
  if (!r)
    return !0;
  if (!t)
    return !1;
  function i(o, s, a) {
    try {
      return o.type === "address" ? Pw(s, a) : o.type === "string" || o.type === "bytes" ? On(Cs(s)) === a : s === a;
    } catch {
      return !1;
    }
  }
  return Array.isArray(t) && Array.isArray(r) ? r.every((o, s) => {
    if (o === null)
      return !0;
    const a = n[s];
    return a ? (Array.isArray(o) ? o : [o]).some((c) => i(a, c, t[s])) : !1;
  }) : typeof t == "object" && !Array.isArray(t) && typeof r == "object" && !Array.isArray(r) ? Object.entries(r).every(([o, s]) => {
    if (s === null)
      return !0;
    const a = n.find((c) => c.name === o);
    return a ? (Array.isArray(s) ? s : [s]).some((c) => i(a, c, t[o])) : !1;
  }) : !1;
}
function Ss(e, { args: t, eventName: n } = {}) {
  return {
    ...e,
    blockHash: e.blockHash ? e.blockHash : null,
    blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
    logIndex: e.logIndex ? Number(e.logIndex) : null,
    transactionHash: e.transactionHash ? e.transactionHash : null,
    transactionIndex: e.transactionIndex ? Number(e.transactionIndex) : null,
    ...n ? { args: t, eventName: n } : {}
  };
}
async function Nw(e, { address: t, blockHash: n, fromBlock: r, toBlock: i, event: o, events: s, args: a, strict: l } = {}) {
  const c = l ?? !1, u = s ?? (o ? [o] : void 0);
  let d = [];
  u && (d = [u.flatMap((m) => Ud({
    abi: [m],
    eventName: m.name,
    args: s ? void 0 : a
  }))], o && (d = d[0]));
  let f;
  n ? f = await e.request({
    method: "eth_getLogs",
    params: [{ address: t, topics: d, blockHash: n }]
  }) : f = await e.request({
    method: "eth_getLogs",
    params: [
      {
        address: t,
        topics: d,
        fromBlock: typeof r == "bigint" ? Fe(r) : r,
        toBlock: typeof i == "bigint" ? Fe(i) : i
      }
    ]
  });
  const h = f.map((p) => Ss(p));
  return u ? Bw({
    abi: u,
    args: a,
    logs: h,
    strict: c
  }) : h;
}
async function F_(e, t) {
  const { abi: n, address: r, args: i, blockHash: o, eventName: s, fromBlock: a, toBlock: l, strict: c } = t, u = s ? Ld({ abi: n, name: s }) : void 0, d = u ? void 0 : n.filter((f) => f.type === "event");
  return at(e, Nw, "getLogs")({
    address: r,
    args: i,
    blockHash: o,
    event: u,
    events: d,
    fromBlock: a,
    toBlock: l,
    strict: c
  });
}
class $q extends be {
  constructor({ address: t }) {
    super(`No EIP-712 domain found on contract "${t}".`, {
      metaMessages: [
        "Ensure that:",
        `- The contract is deployed at the address "${t}".`,
        "- `eip712Domain()` function exists on the contract.",
        "- `eip712Domain()` function matches signature to ERC-5267 specification."
      ],
      name: "Eip712DomainNotFoundError"
    });
  }
}
async function Wq(e, t) {
  const { address: n, factory: r, factoryData: i } = t;
  try {
    const [o, s, a, l, c, u, d] = await at(e, Oo, "readContract")({
      abi: Gq,
      address: n,
      functionName: "eip712Domain",
      factory: r,
      factoryData: i
    });
    return {
      domain: {
        name: s,
        version: a,
        chainId: Number(l),
        verifyingContract: c,
        salt: u
      },
      extensions: d,
      fields: o
    };
  } catch (o) {
    const s = o;
    throw s.name === "ContractFunctionExecutionError" && s.cause.name === "ContractFunctionZeroDataError" ? new $q({ address: n }) : s;
  }
}
const Gq = [
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      { name: "fields", type: "bytes1" },
      { name: "name", type: "string" },
      { name: "version", type: "string" },
      { name: "chainId", type: "uint256" },
      { name: "verifyingContract", type: "address" },
      { name: "salt", type: "bytes32" },
      { name: "extensions", type: "uint256[]" }
    ],
    stateMutability: "view",
    type: "function"
  }
];
function Hq(e) {
  var t;
  return {
    baseFeePerGas: e.baseFeePerGas.map((n) => BigInt(n)),
    gasUsedRatio: e.gasUsedRatio,
    oldestBlock: BigInt(e.oldestBlock),
    reward: (t = e.reward) == null ? void 0 : t.map((n) => n.map((r) => BigInt(r)))
  };
}
async function Kq(e, { blockCount: t, blockNumber: n, blockTag: r = "latest", rewardPercentiles: i }) {
  const o = n ? Fe(n) : void 0, s = await e.request({
    method: "eth_feeHistory",
    params: [
      Fe(t),
      o || r,
      i
    ]
  }, { dedupe: !!o });
  return Hq(s);
}
async function ey(e, { filter: t }) {
  const n = "strict" in t && t.strict, r = await t.request({
    method: "eth_getFilterChanges",
    params: [t.id]
  });
  if (typeof r[0] == "string")
    return r;
  const i = r.map((o) => Ss(o));
  return !("abi" in t) || !t.abi ? i : Bw({
    abi: t.abi,
    logs: i,
    strict: n
  });
}
async function Yq(e, { filter: t }) {
  const n = t.strict ?? !1, i = (await t.request({
    method: "eth_getFilterLogs",
    params: [t.id]
  })).map((o) => Ss(o));
  return t.abi ? Bw({
    abi: t.abi,
    logs: i,
    strict: n
  }) : i;
}
async function Qq(e, { address: t, blockNumber: n, blockTag: r = "latest", slot: i }) {
  const o = n !== void 0 ? Fe(n) : void 0;
  return await e.request({
    method: "eth_getStorageAt",
    params: [t, i, o || r]
  });
}
async function Dw(e, { blockHash: t, blockNumber: n, blockTag: r, hash: i, index: o }) {
  var u, d, f;
  const s = r || "latest", a = n !== void 0 ? Fe(n) : void 0;
  let l = null;
  if (i ? l = await e.request({
    method: "eth_getTransactionByHash",
    params: [i]
  }, { dedupe: !0 }) : t ? l = await e.request({
    method: "eth_getTransactionByBlockHashAndIndex",
    params: [t, Fe(o)]
  }, { dedupe: !0 }) : (a || s) && (l = await e.request({
    method: "eth_getTransactionByBlockNumberAndIndex",
    params: [a || s, Fe(o)]
  }, { dedupe: !!a })), !l)
    throw new zT({
      blockHash: t,
      blockNumber: n,
      blockTag: s,
      hash: i,
      index: o
    });
  return (((f = (d = (u = e.chain) == null ? void 0 : u.formatters) == null ? void 0 : d.transaction) == null ? void 0 : f.format) || Fd)(l);
}
async function Jq(e, { hash: t, transactionReceipt: n }) {
  const [r, i] = await Promise.all([
    at(e, zd, "getBlockNumber")({}),
    t ? at(e, Dw, "getTransaction")({ hash: t }) : void 0
  ]), o = (n == null ? void 0 : n.blockNumber) || (i == null ? void 0 : i.blockNumber);
  return o ? r - o + 1n : 0n;
}
const Xq = {
  "0x0": "reverted",
  "0x1": "success"
};
function L_(e) {
  const t = {
    ...e,
    blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
    contractAddress: e.contractAddress ? e.contractAddress : null,
    cumulativeGasUsed: e.cumulativeGasUsed ? BigInt(e.cumulativeGasUsed) : null,
    effectiveGasPrice: e.effectiveGasPrice ? BigInt(e.effectiveGasPrice) : null,
    gasUsed: e.gasUsed ? BigInt(e.gasUsed) : null,
    logs: e.logs ? e.logs.map((n) => Ss(n)) : null,
    to: e.to ? e.to : null,
    transactionIndex: e.transactionIndex ? Xi(e.transactionIndex) : null,
    status: e.status ? Xq[e.status] : null,
    type: e.type ? WT[e.type] || e.type : null
  };
  return e.blobGasPrice && (t.blobGasPrice = BigInt(e.blobGasPrice)), e.blobGasUsed && (t.blobGasUsed = BigInt(e.blobGasUsed)), t;
}
const Zq = /* @__PURE__ */ Gp("transactionReceipt", L_);
async function bb(e, { hash: t }) {
  var i, o, s;
  const n = await e.request({
    method: "eth_getTransactionReceipt",
    params: [t]
  }, { dedupe: !0 });
  if (!n)
    throw new VT({ hash: t });
  return (((s = (o = (i = e.chain) == null ? void 0 : i.formatters) == null ? void 0 : o.transactionReceipt) == null ? void 0 : s.format) || L_)(n);
}
async function e$(e, t) {
  var g;
  const { allowFailure: n = !0, batchSize: r, blockNumber: i, blockTag: o, multicallAddress: s, stateOverride: a } = t, l = t.contracts, c = r ?? (typeof ((g = e.batch) == null ? void 0 : g.multicall) == "object" && e.batch.multicall.batchSize || 1024);
  let u = s;
  if (!u) {
    if (!e.chain)
      throw new Error("client chain not configured. multicallAddress is required.");
    u = jc({
      blockNumber: i,
      chain: e.chain,
      contract: "multicall3"
    });
  }
  const d = [[]];
  let f = 0, h = 0;
  for (let v = 0; v < l.length; v++) {
    const { abi: w, address: x, args: C, functionName: S } = l[v];
    try {
      const k = za({ abi: w, args: C, functionName: S });
      h += (k.length - 2) / 2, // Check if batching is enabled.
      c > 0 && // Check if the current size of the batch exceeds the size limit.
      h > c && // Check if the current chunk is not already empty.
      d[f].length > 0 && (f++, h = (k.length - 2) / 2, d[f] = []), d[f] = [
        ...d[f],
        {
          allowFailure: !0,
          callData: k,
          target: x
        }
      ];
    } catch (k) {
      const A = Zu(k, {
        abi: w,
        address: x,
        args: C,
        docsPath: "/docs/contract/multicall",
        functionName: S
      });
      if (!n)
        throw A;
      d[f] = [
        ...d[f],
        {
          allowFailure: !0,
          callData: "0x",
          target: x
        }
      ];
    }
  }
  const p = await Promise.allSettled(d.map((v) => at(e, Oo, "readContract")({
    abi: fb,
    address: u,
    args: [v],
    blockNumber: i,
    blockTag: o,
    functionName: "aggregate3",
    stateOverride: a
  }))), m = [];
  for (let v = 0; v < p.length; v++) {
    const w = p[v];
    if (w.status === "rejected") {
      if (!n)
        throw w.reason;
      for (let C = 0; C < d[v].length; C++)
        m.push({
          status: "failure",
          error: w.reason,
          result: void 0
        });
      continue;
    }
    const x = w.value;
    for (let C = 0; C < x.length; C++) {
      const { returnData: S, success: k } = x[C], { callData: A } = d[v][C], { abi: b, address: T, functionName: R, args: B } = l[m.length];
      try {
        if (A === "0x")
          throw new Up();
        if (!k)
          throw new Tw({ data: S });
        const O = Dc({
          abi: b,
          args: B,
          data: S,
          functionName: R
        });
        m.push(n ? { result: O, status: "success" } : O);
      } catch (O) {
        const L = Zu(O, {
          abi: b,
          address: T,
          args: B,
          docsPath: "/docs/contract/multicall",
          functionName: R
        });
        if (!n)
          throw L;
        m.push({ error: L, result: void 0, status: "failure" });
      }
    }
  }
  if (m.length !== l.length)
    throw new be("multicall results mismatch");
  return m;
}
const Zm = /* @__PURE__ */ new Map(), Gk = /* @__PURE__ */ new Map();
let t$ = 0;
function As(e, t, n) {
  const r = ++t$, i = () => Zm.get(e) || [], o = () => {
    const u = i();
    Zm.set(e, u.filter((d) => d.id !== r));
  }, s = () => {
    const u = Gk.get(e);
    i().length === 1 && u && u(), o();
  }, a = i();
  if (Zm.set(e, [
    ...a,
    { id: r, fns: t }
  ]), a && a.length > 0)
    return s;
  const l = {};
  for (const u in t)
    l[u] = (...d) => {
      var h, p;
      const f = i();
      if (f.length !== 0)
        for (const m of f)
          (p = (h = m.fns)[u]) == null || p.call(h, ...d);
    };
  const c = n(l);
  return typeof c == "function" && Gk.set(e, c), s;
}
async function wb(e) {
  return new Promise((t) => setTimeout(t, e));
}
function Vd(e, { emitOnBegin: t, initialWaitTime: n, interval: r }) {
  let i = !0;
  const o = () => i = !1;
  return (async () => {
    let a;
    t && (a = await e({ unpoll: o }));
    const l = await (n == null ? void 0 : n(a)) ?? r;
    await wb(l);
    const c = async () => {
      i && (await e({ unpoll: o }), await wb(r), c());
    };
    c();
  })(), o;
}
function n$(e, { blockTag: t = "latest", emitMissed: n = !1, emitOnBegin: r = !1, onBlock: i, onError: o, includeTransactions: s, poll: a, pollingInterval: l = e.pollingInterval }) {
  const c = typeof a < "u" ? a : !(e.transport.type === "webSocket" || e.transport.type === "fallback" && e.transport.transports[0].config.type === "webSocket"), u = s ?? !1;
  let d;
  return c ? (() => {
    const p = Jn([
      "watchBlocks",
      e.uid,
      t,
      n,
      r,
      u,
      l
    ]);
    return As(p, { onBlock: i, onError: o }, (m) => Vd(async () => {
      var g;
      try {
        const v = await at(e, Es, "getBlock")({
          blockTag: t,
          includeTransactions: u
        });
        if (v.number && (d != null && d.number)) {
          if (v.number === d.number)
            return;
          if (v.number - d.number > 1 && n)
            for (let w = (d == null ? void 0 : d.number) + 1n; w < v.number; w++) {
              const x = await at(e, Es, "getBlock")({
                blockNumber: w,
                includeTransactions: u
              });
              m.onBlock(x, d), d = x;
            }
        }
        // If no previous block exists, emit.
        (!(d != null && d.number) || // If the block tag is "pending" with no block number, emit.
        t === "pending" && !(v != null && v.number) || // If the next block number is greater than the previous block number, emit.
        // We don't want to emit blocks in the past.
        v.number && v.number > d.number) && (m.onBlock(v, d), d = v);
      } catch (v) {
        (g = m.onError) == null || g.call(m, v);
      }
    }, {
      emitOnBegin: r,
      interval: l
    }));
  })() : (() => {
    let p = !0, m = () => p = !1;
    return (async () => {
      try {
        const g = (() => {
          if (e.transport.type === "fallback") {
            const w = e.transport.transports.find((x) => x.config.type === "webSocket");
            return w ? w.value : e.transport;
          }
          return e.transport;
        })(), { unsubscribe: v } = await g.subscribe({
          params: ["newHeads"],
          onData(w) {
            var S, k, A;
            if (!p)
              return;
            const C = (((A = (k = (S = e.chain) == null ? void 0 : S.formatters) == null ? void 0 : k.block) == null ? void 0 : A.format) || xw)(w.result);
            i(C, d), d = C;
          },
          onError(w) {
            o == null || o(w);
          }
        });
        m = v, p || m();
      } catch (g) {
        o == null || o(g);
      }
    })(), () => m();
  })();
}
function U_(e, { emitOnBegin: t = !1, emitMissed: n = !1, onBlockNumber: r, onError: i, poll: o, pollingInterval: s = e.pollingInterval }) {
  const a = typeof o < "u" ? o : !(e.transport.type === "webSocket" || e.transport.type === "fallback" && e.transport.transports[0].config.type === "webSocket");
  let l;
  return a ? (() => {
    const d = Jn([
      "watchBlockNumber",
      e.uid,
      t,
      n,
      s
    ]);
    return As(d, { onBlockNumber: r, onError: i }, (f) => Vd(async () => {
      var h;
      try {
        const p = await at(e, zd, "getBlockNumber")({ cacheTime: 0 });
        if (l) {
          if (p === l)
            return;
          if (p - l > 1 && n)
            for (let m = l + 1n; m < p; m++)
              f.onBlockNumber(m, l), l = m;
        }
        (!l || p > l) && (f.onBlockNumber(p, l), l = p);
      } catch (p) {
        (h = f.onError) == null || h.call(f, p);
      }
    }, {
      emitOnBegin: t,
      interval: s
    }));
  })() : (() => {
    const d = Jn([
      "watchBlockNumber",
      e.uid,
      t,
      n
    ]);
    return As(d, { onBlockNumber: r, onError: i }, (f) => {
      let h = !0, p = () => h = !1;
      return (async () => {
        try {
          const m = (() => {
            if (e.transport.type === "fallback") {
              const v = e.transport.transports.find((w) => w.config.type === "webSocket");
              return v ? v.value : e.transport;
            }
            return e.transport;
          })(), { unsubscribe: g } = await m.subscribe({
            params: ["newHeads"],
            onData(v) {
              var x;
              if (!h)
                return;
              const w = Yn((x = v.result) == null ? void 0 : x.number);
              f.onBlockNumber(w, l), l = w;
            },
            onError(v) {
              var w;
              (w = f.onError) == null || w.call(f, v);
            }
          });
          p = g, h || p();
        } catch (m) {
          i == null || i(m);
        }
      })(), () => p();
    });
  })();
}
async function ty(e, { filter: t }) {
  return t.request({
    method: "eth_uninstallFilter",
    params: [t.id]
  });
}
function r$(e, { address: t, args: n, batch: r = !0, event: i, events: o, fromBlock: s, onError: a, onLogs: l, poll: c, pollingInterval: u = e.pollingInterval, strict: d }) {
  const f = typeof c < "u" ? c : typeof s == "bigint" ? !0 : !(e.transport.type === "webSocket" || e.transport.type === "fallback" && e.transport.transports[0].config.type === "webSocket"), h = d ?? !1;
  return f ? (() => {
    const g = Jn([
      "watchEvent",
      t,
      n,
      r,
      e.uid,
      i,
      u,
      s
    ]);
    return As(g, { onLogs: l, onError: a }, (v) => {
      let w;
      s !== void 0 && (w = s - 1n);
      let x, C = !1;
      const S = Vd(async () => {
        var k;
        if (!C) {
          try {
            x = await at(e, j_, "createEventFilter")({
              address: t,
              args: n,
              event: i,
              events: o,
              strict: h,
              fromBlock: s
            });
          } catch {
          }
          C = !0;
          return;
        }
        try {
          let A;
          if (x)
            A = await at(e, ey, "getFilterChanges")({ filter: x });
          else {
            const b = await at(e, zd, "getBlockNumber")({});
            w && w !== b ? A = await at(e, Nw, "getLogs")({
              address: t,
              args: n,
              event: i,
              events: o,
              fromBlock: w + 1n,
              toBlock: b
            }) : A = [], w = b;
          }
          if (A.length === 0)
            return;
          if (r)
            v.onLogs(A);
          else
            for (const b of A)
              v.onLogs([b]);
        } catch (A) {
          x && A instanceof Ia && (C = !1), (k = v.onError) == null || k.call(v, A);
        }
      }, {
        emitOnBegin: !0,
        interval: u
      });
      return async () => {
        x && await at(e, ty, "uninstallFilter")({ filter: x }), S();
      };
    });
  })() : (() => {
    let g = !0, v = () => g = !1;
    return (async () => {
      try {
        const w = (() => {
          if (e.transport.type === "fallback") {
            const k = e.transport.transports.find((A) => A.config.type === "webSocket");
            return k ? k.value : e.transport;
          }
          return e.transport;
        })(), x = o ?? (i ? [i] : void 0);
        let C = [];
        x && (C = [x.flatMap((A) => Ud({
          abi: [A],
          eventName: A.name,
          args: n
        }))], i && (C = C[0]));
        const { unsubscribe: S } = await w.subscribe({
          params: ["logs", { address: t, topics: C }],
          onData(k) {
            var b;
            if (!g)
              return;
            const A = k.result;
            try {
              const { eventName: T, args: R } = Ow({
                abi: x ?? [],
                data: A.data,
                topics: A.topics,
                strict: h
              }), B = Ss(A, { args: R, eventName: T });
              l([B]);
            } catch (T) {
              let R, B;
              if (T instanceof Fu || T instanceof zp) {
                if (d)
                  return;
                R = T.abiItem.name, B = (b = T.abiItem.inputs) == null ? void 0 : b.some((L) => !("name" in L && L.name));
              }
              const O = Ss(A, {
                args: B ? [] : {},
                eventName: R
              });
              l([O]);
            }
          },
          onError(k) {
            a == null || a(k);
          }
        });
        v = S, g || v();
      } catch (w) {
        a == null || a(w);
      }
    })(), () => v();
  })();
}
function i$(e, { batch: t = !0, onError: n, onTransactions: r, poll: i, pollingInterval: o = e.pollingInterval }) {
  return (typeof i < "u" ? i : e.transport.type !== "webSocket") ? (() => {
    const c = Jn([
      "watchPendingTransactions",
      e.uid,
      t,
      o
    ]);
    return As(c, { onTransactions: r, onError: n }, (u) => {
      let d;
      const f = Vd(async () => {
        var h;
        try {
          if (!d)
            try {
              d = await at(e, M_, "createPendingTransactionFilter")({});
              return;
            } catch (m) {
              throw f(), m;
            }
          const p = await at(e, ey, "getFilterChanges")({ filter: d });
          if (p.length === 0)
            return;
          if (t)
            u.onTransactions(p);
          else
            for (const m of p)
              u.onTransactions([m]);
        } catch (p) {
          (h = u.onError) == null || h.call(u, p);
        }
      }, {
        emitOnBegin: !0,
        interval: o
      });
      return async () => {
        d && await at(e, ty, "uninstallFilter")({ filter: d }), f();
      };
    });
  })() : (() => {
    let c = !0, u = () => c = !1;
    return (async () => {
      try {
        const { unsubscribe: d } = await e.transport.subscribe({
          params: ["newPendingTransactions"],
          onData(f) {
            if (!c)
              return;
            const h = f.result;
            r([h]);
          },
          onError(f) {
            n == null || n(f);
          }
        });
        u = d, c || u();
      } catch (d) {
        n == null || n(d);
      }
    })(), () => u();
  })();
}
const Rf = /* @__PURE__ */ new aw(8192);
function o$(e, { enabled: t = !0, id: n }) {
  if (!t || !n)
    return e();
  if (Rf.get(n))
    return Rf.get(n);
  const r = e().finally(() => Rf.delete(n));
  return Rf.set(n, r), r;
}
function $h(e, { delay: t = 100, retryCount: n = 2, shouldRetry: r = () => !0 } = {}) {
  return new Promise((i, o) => {
    const s = async ({ count: a = 0 } = {}) => {
      const l = async ({ error: c }) => {
        const u = typeof t == "function" ? t({ count: a, error: c }) : t;
        u && await wb(u), s({ count: a + 1 });
      };
      try {
        const c = await e();
        i(c);
      } catch (c) {
        if (a < n && await r({ count: a, error: c }))
          return l({ error: c });
        o(c);
      }
    };
    s();
  });
}
function s$(e, t = {}) {
  return async (n, r = {}) => {
    const { dedupe: i = !1, retryDelay: o = 150, retryCount: s = 3, uid: a } = {
      ...t,
      ...r
    }, l = i ? On(Yl(`${a}.${Jn(n)}`)) : void 0;
    return o$(() => $h(async () => {
      try {
        return await e(n);
      } catch (c) {
        const u = c;
        switch (u.code) {
          case Uu.code:
            throw new Uu(u);
          case zu.code:
            throw new zu(u);
          case Vu.code:
            throw new Vu(u, { method: n.method });
          case qu.code:
            throw new qu(u);
          case _a.code:
            throw new _a(u);
          case Ia.code:
            throw new Ia(u);
          case $u.code:
            throw new $u(u);
          case ws.code:
            throw new ws(u);
          case Wu.code:
            throw new Wu(u);
          case Gu.code:
            throw new Gu(u, {
              method: n.method
            });
          case Xl.code:
            throw new Xl(u);
          case Hu.code:
            throw new Hu(u);
          case $t.code:
            throw new $t(u);
          case Ku.code:
            throw new Ku(u);
          case Yu.code:
            throw new Yu(u);
          case Qu.code:
            throw new Qu(u);
          case Ju.code:
            throw new Ju(u);
          case oi.code:
            throw new oi(u);
          case 5e3:
            throw new $t(u);
          default:
            throw c instanceof be ? c : new Sz(u);
        }
      }
    }, {
      delay: ({ count: c, error: u }) => {
        var d;
        if (u && u instanceof _u) {
          const f = (d = u == null ? void 0 : u.headers) == null ? void 0 : d.get("Retry-After");
          if (f != null && f.match(/\d/))
            return Number.parseInt(f) * 1e3;
        }
        return ~~(1 << c) * o;
      },
      retryCount: s,
      shouldRetry: ({ error: c }) => a$(c)
    }), { enabled: i, id: l });
  };
}
function a$(e) {
  return "code" in e && typeof e.code == "number" ? e.code === -1 || e.code === Xl.code || e.code === _a.code : e instanceof _u && e.status ? e.status === 403 || e.status === 408 || e.status === 413 || e.status === 429 || e.status === 500 || e.status === 502 || e.status === 503 || e.status === 504 : !0;
}
function jr(e) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...e
  };
}
const l$ = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, c$ = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
function z_(e, { errorInstance: t = new Error("timed out"), timeout: n, signal: r }) {
  return new Promise((i, o) => {
    (async () => {
      let s;
      try {
        const a = new AbortController();
        n > 0 && (s = setTimeout(() => {
          r ? a.abort() : o(t);
        }, n)), i(await e({ signal: (a == null ? void 0 : a.signal) || null }));
      } catch (a) {
        (a == null ? void 0 : a.name) === "AbortError" && o(t), o(a);
      } finally {
        clearTimeout(s);
      }
    })();
  });
}
function u$() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
const Hk = /* @__PURE__ */ u$();
function d$(e, t = {}) {
  return {
    async request(n) {
      var d;
      const { body: r, onRequest: i = t.onRequest, onResponse: o = t.onResponse, timeout: s = t.timeout ?? 1e4 } = n, a = {
        ...t.fetchOptions ?? {},
        ...n.fetchOptions ?? {}
      }, { headers: l, method: c, signal: u } = a;
      try {
        const f = await z_(async ({ signal: p }) => {
          const m = {
            ...a,
            body: Array.isArray(r) ? Jn(r.map((w) => ({
              jsonrpc: "2.0",
              id: w.id ?? Hk.take(),
              ...w
            }))) : Jn({
              jsonrpc: "2.0",
              id: r.id ?? Hk.take(),
              ...r
            }),
            headers: {
              "Content-Type": "application/json",
              ...l
            },
            method: c || "POST",
            signal: u || (s > 0 ? p : null)
          }, g = new Request(e, m);
          return i && await i(g), await fetch(e, m);
        }, {
          errorInstance: new Pk({ body: r, url: e }),
          timeout: s,
          signal: !0
        });
        o && await o(f);
        let h;
        if ((d = f.headers.get("Content-Type")) != null && d.startsWith("application/json") ? h = await f.json() : (h = await f.text(), h = JSON.parse(h || "{}")), !f.ok)
          throw new _u({
            body: r,
            details: Jn(h.error) || f.statusText,
            headers: f.headers,
            status: f.status,
            url: e
          });
        return h;
      } catch (f) {
        throw f instanceof _u || f instanceof Pk ? f : new _u({
          body: r,
          cause: f,
          url: e
        });
      }
    }
  };
}
function f$(e) {
  const { domain: t = {}, message: n, primaryType: r } = e, i = {
    EIP712Domain: g$({ domain: t }),
    ...e.types
  };
  m$({
    domain: t,
    message: n,
    primaryType: r,
    types: i
  });
  const o = ["0x1901"];
  return t && o.push(h$({
    domain: t,
    types: i
  })), r !== "EIP712Domain" && o.push(V_({
    data: n,
    primaryType: r,
    types: i
  })), On(Ro(o));
}
function h$({ domain: e, types: t }) {
  return V_({
    data: e,
    primaryType: "EIP712Domain",
    types: t
  });
}
function V_({ data: e, primaryType: t, types: n }) {
  const r = q_({
    data: e,
    primaryType: t,
    types: n
  });
  return On(r);
}
function q_({ data: e, primaryType: t, types: n }) {
  const r = [{ type: "bytes32" }], i = [p$({ primaryType: t, types: n })];
  for (const o of n[t]) {
    const [s, a] = W_({
      types: n,
      name: o.name,
      type: o.type,
      value: e[o.name]
    });
    r.push(s), i.push(a);
  }
  return Bc(r, i);
}
function p$({ primaryType: e, types: t }) {
  const n = $e(y$({ primaryType: e, types: t }));
  return On(n);
}
function y$({ primaryType: e, types: t }) {
  let n = "";
  const r = $_({ primaryType: e, types: t });
  r.delete(e);
  const i = [e, ...Array.from(r).sort()];
  for (const o of i)
    n += `${o}(${t[o].map(({ name: s, type: a }) => `${a} ${s}`).join(",")})`;
  return n;
}
function $_({ primaryType: e, types: t }, n = /* @__PURE__ */ new Set()) {
  const r = e.match(/^\w*/u), i = r == null ? void 0 : r[0];
  if (n.has(i) || t[i] === void 0)
    return n;
  n.add(i);
  for (const o of t[i])
    $_({ primaryType: o.type, types: t }, n);
  return n;
}
function W_({ types: e, name: t, type: n, value: r }) {
  if (e[n] !== void 0)
    return [
      { type: "bytes32" },
      On(q_({ data: r, primaryType: n, types: e }))
    ];
  if (n === "bytes")
    return r = `0x${(r.length % 2 ? "0" : "") + r.slice(2)}`, [{ type: "bytes32" }, On(r)];
  if (n === "string")
    return [{ type: "bytes32" }, On($e(r))];
  if (n.lastIndexOf("]") === n.length - 1) {
    const i = n.slice(0, n.lastIndexOf("[")), o = r.map((s) => W_({
      name: t,
      type: i,
      types: e,
      value: s
    }));
    return [
      { type: "bytes32" },
      On(Bc(o.map(([s]) => s), o.map(([, s]) => s)))
    ];
  }
  return [{ type: n }, r];
}
function m$(e) {
  const { domain: t, message: n, primaryType: r, types: i } = e, o = (s, a) => {
    for (const l of s) {
      const { name: c, type: u } = l, d = a[c], f = u.match(c$);
      if (f && (typeof d == "number" || typeof d == "bigint")) {
        const [m, g, v] = f;
        Fe(d, {
          signed: g === "int",
          size: Number.parseInt(v) / 8
        });
      }
      if (u === "address" && typeof d == "string" && !bn(d))
        throw new Zn({ address: d });
      const h = u.match(l$);
      if (h) {
        const [m, g] = h;
        if (g && ln(d) !== Number.parseInt(g))
          throw new CU({
            expectedSize: Number.parseInt(g),
            givenSize: ln(d)
          });
      }
      const p = i[u];
      p && o(p, d);
    }
  };
  i.EIP712Domain && t && o(i.EIP712Domain, t), r !== "EIP712Domain" && o(i[r], n);
}
function g$({ domain: e }) {
  return [
    typeof (e == null ? void 0 : e.name) == "string" && { name: "name", type: "string" },
    (e == null ? void 0 : e.version) && { name: "version", type: "string" },
    typeof (e == null ? void 0 : e.chainId) == "number" && {
      name: "chainId",
      type: "uint256"
    },
    (e == null ? void 0 : e.verifyingContract) && {
      name: "verifyingContract",
      type: "address"
    },
    (e == null ? void 0 : e.salt) && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}
const v$ = `Ethereum Signed Message:
`;
function b$(e) {
  const t = typeof e == "string" ? Yl(e) : typeof e.raw == "string" ? e.raw : vn(e.raw), n = Yl(`${v$}${ln(t)}`);
  return Ro([n, t]);
}
function G_(e, t) {
  return On(b$(e), t);
}
const H_ = "0x6492649264926492649264926492649264926492649264926492649264926492";
function w$(e) {
  return BT(e, -32) === H_;
}
function x$(e) {
  const { address: t, data: n, signature: r, to: i = "hex" } = e, o = Pi([
    Bc([{ type: "address" }, { type: "bytes" }, { type: "bytes" }], [t, n, r]),
    H_
  ]);
  return i === "hex" ? o : Ai(o);
}
function C$(e) {
  const { authorizationList: t } = e;
  if (t)
    for (const n of t) {
      const { contractAddress: r, chainId: i } = n;
      if (!bn(r))
        throw new Zn({ address: r });
      if (i <= 0)
        throw new Bd({ chainId: i });
    }
  jw(e);
}
function k$(e) {
  const { blobVersionedHashes: t } = e;
  if (t) {
    if (t.length === 0)
      throw new r_();
    for (const n of t) {
      const r = ln(n), i = Xi(Lu(n, 0, 1));
      if (r !== 32)
        throw new Qz({ hash: n, size: r });
      if (i !== n_)
        throw new Jz({
          hash: n,
          version: i
        });
    }
  }
  jw(e);
}
function jw(e) {
  const { chainId: t, maxPriorityFeePerGas: n, maxFeePerGas: r, to: i } = e;
  if (t <= 0)
    throw new Bd({ chainId: t });
  if (i && !bn(i))
    throw new Zn({ address: i });
  if (r && r > jd)
    throw new ks({ maxFeePerGas: r });
  if (n && r && n > r)
    throw new Jl({ maxFeePerGas: r, maxPriorityFeePerGas: n });
}
function E$(e) {
  const { chainId: t, maxPriorityFeePerGas: n, gasPrice: r, maxFeePerGas: i, to: o } = e;
  if (t <= 0)
    throw new Bd({ chainId: t });
  if (o && !bn(o))
    throw new Zn({ address: o });
  if (n || i)
    throw new be("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
  if (r && r > jd)
    throw new ks({ maxFeePerGas: r });
}
function S$(e) {
  const { chainId: t, maxPriorityFeePerGas: n, gasPrice: r, maxFeePerGas: i, to: o } = e;
  if (o && !bn(o))
    throw new Zn({ address: o });
  if (typeof t < "u" && t <= 0)
    throw new Bd({ chainId: t });
  if (n || i)
    throw new be("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
  if (r && r > jd)
    throw new ks({ maxFeePerGas: r });
}
function A$(e) {
  if (!e || e.length === 0)
    return [];
  const t = [];
  for (const n of e) {
    const { contractAddress: r, chainId: i, nonce: o, ...s } = n;
    t.push([
      $e(i),
      r,
      o ? $e(o) : "0x",
      ...Mc({}, s)
    ]);
  }
  return t;
}
function qd(e) {
  if (!e || e.length === 0)
    return [];
  const t = [];
  for (let n = 0; n < e.length; n++) {
    const { address: r, storageKeys: i } = e[n];
    for (let o = 0; o < i.length; o++)
      if (i[o].length - 2 !== 64)
        throw new xz({ storageKey: i[o] });
    if (!bn(r, { strict: !1 }))
      throw new Zn({ address: r });
    t.push([r, i]);
  }
  return t;
}
function T$(e, t) {
  const n = o_(e);
  return n === "eip1559" ? R$(e, t) : n === "eip2930" ? P$(e, t) : n === "eip4844" ? I$(e, t) : n === "eip7702" ? _$(e, t) : O$(e, t);
}
function _$(e, t) {
  const { authorizationList: n, chainId: r, gas: i, nonce: o, to: s, value: a, maxFeePerGas: l, maxPriorityFeePerGas: c, accessList: u, data: d } = e;
  C$(e);
  const f = qd(u), h = A$(n);
  return Pi([
    "0x04",
    Po([
      $e(r),
      o ? $e(o) : "0x",
      c ? $e(c) : "0x",
      l ? $e(l) : "0x",
      i ? $e(i) : "0x",
      s ?? "0x",
      a ? $e(a) : "0x",
      d ?? "0x",
      f,
      h,
      ...Mc(e, t)
    ])
  ]);
}
function I$(e, t) {
  const { chainId: n, gas: r, nonce: i, to: o, value: s, maxFeePerBlobGas: a, maxFeePerGas: l, maxPriorityFeePerGas: c, accessList: u, data: d } = e;
  k$(e);
  let f = e.blobVersionedHashes, h = e.sidecars;
  if (e.blobs && (typeof f > "u" || typeof h > "u")) {
    const x = typeof e.blobs[0] == "string" ? e.blobs : e.blobs.map((k) => vn(k)), C = e.kzg, S = kw({
      blobs: x,
      kzg: C
    });
    if (typeof f > "u" && (f = ZT({
      commitments: S
    })), typeof h > "u") {
      const k = Ew({ blobs: x, commitments: S, kzg: C });
      h = i_({ blobs: x, commitments: S, proofs: k });
    }
  }
  const p = qd(u), m = [
    $e(n),
    i ? $e(i) : "0x",
    c ? $e(c) : "0x",
    l ? $e(l) : "0x",
    r ? $e(r) : "0x",
    o ?? "0x",
    s ? $e(s) : "0x",
    d ?? "0x",
    p,
    a ? $e(a) : "0x",
    f ?? [],
    ...Mc(e, t)
  ], g = [], v = [], w = [];
  if (h)
    for (let x = 0; x < h.length; x++) {
      const { blob: C, commitment: S, proof: k } = h[x];
      g.push(C), v.push(S), w.push(k);
    }
  return Pi([
    "0x03",
    // If sidecars are enabled, envelope turns into a "wrapper":
    Po(h ? [m, g, v, w] : m)
  ]);
}
function R$(e, t) {
  const { chainId: n, gas: r, nonce: i, to: o, value: s, maxFeePerGas: a, maxPriorityFeePerGas: l, accessList: c, data: u } = e;
  jw(e);
  const d = qd(c), f = [
    $e(n),
    i ? $e(i) : "0x",
    l ? $e(l) : "0x",
    a ? $e(a) : "0x",
    r ? $e(r) : "0x",
    o ?? "0x",
    s ? $e(s) : "0x",
    u ?? "0x",
    d,
    ...Mc(e, t)
  ];
  return Pi([
    "0x02",
    Po(f)
  ]);
}
function P$(e, t) {
  const { chainId: n, gas: r, data: i, nonce: o, to: s, value: a, accessList: l, gasPrice: c } = e;
  E$(e);
  const u = qd(l), d = [
    $e(n),
    o ? $e(o) : "0x",
    c ? $e(c) : "0x",
    r ? $e(r) : "0x",
    s ?? "0x",
    a ? $e(a) : "0x",
    i ?? "0x",
    u,
    ...Mc(e, t)
  ];
  return Pi([
    "0x01",
    Po(d)
  ]);
}
function O$(e, t) {
  const { chainId: n = 0, gas: r, data: i, nonce: o, to: s, value: a, gasPrice: l } = e;
  S$(e);
  let c = [
    o ? $e(o) : "0x",
    l ? $e(l) : "0x",
    r ? $e(r) : "0x",
    s ?? "0x",
    a ? $e(a) : "0x",
    i ?? "0x"
  ];
  if (t) {
    const u = (() => {
      if (t.v >= 35n)
        return (t.v - 35n) / 2n > 0 ? t.v : 27n + (t.v === 35n ? 0n : 1n);
      if (n > 0)
        return BigInt(n * 2) + BigInt(35n + t.v - 27n);
      const h = 27n + (t.v === 27n ? 0n : 1n);
      if (t.v !== h)
        throw new bz({ v: t.v });
      return h;
    })(), d = Ji(t.r), f = Ji(t.s);
    c = [
      ...c,
      $e(u),
      d === "0x00" ? "0x" : d,
      f === "0x00" ? "0x" : f
    ];
  } else n > 0 && (c = [
    ...c,
    $e(n),
    "0x",
    "0x"
  ]);
  return Po(c);
}
function Mc(e, t) {
  const n = t ?? e, { v: r, yParity: i } = n;
  if (typeof n.r > "u")
    return [];
  if (typeof n.s > "u")
    return [];
  if (typeof r > "u" && typeof i > "u")
    return [];
  const o = Ji(n.r), s = Ji(n.s);
  return [typeof i == "number" ? i ? $e(1) : "0x" : r === 0n ? "0x" : r === 1n ? $e(1) : r === 27n ? "0x" : $e(1), o === "0x00" ? "0x" : o, s === "0x00" ? "0x" : s];
}
function B$(e) {
  return e.map((t) => ({
    ...t,
    value: BigInt(t.value)
  }));
}
function N$(e) {
  return {
    ...e,
    balance: e.balance ? BigInt(e.balance) : void 0,
    nonce: e.nonce ? Xi(e.nonce) : void 0,
    storageProof: e.storageProof ? B$(e.storageProof) : void 0
  };
}
async function D$(e, { address: t, blockNumber: n, blockTag: r, storageKeys: i }) {
  const o = r ?? "latest", s = n !== void 0 ? Fe(n) : void 0, a = await e.request({
    method: "eth_getProof",
    params: [t, i, s || o]
  });
  return N$(a);
}
async function j$(e, {
  confirmations: t = 1,
  hash: n,
  onReplaced: r,
  pollingInterval: i = e.pollingInterval,
  retryCount: o = 6,
  retryDelay: s = ({ count: l }) => ~~(1 << l) * 200,
  // exponential backoff
  timeout: a
}) {
  const l = Jn(["waitForTransactionReceipt", e.uid, n]);
  let c = 0, u, d, f, h = !1;
  return new Promise((p, m) => {
    a && setTimeout(() => m(new Rk({ hash: n })), a);
    const g = As(l, { onReplaced: r, resolve: p, reject: m }, (v) => {
      const w = at(e, U_, "watchBlockNumber")({
        emitMissed: !0,
        emitOnBegin: !0,
        poll: !0,
        pollingInterval: i,
        async onBlockNumber(x) {
          const C = (k) => {
            w(), k(), g();
          };
          let S = x;
          if (!h) {
            c > o && C(() => v.reject(new Rk({ hash: n })));
            try {
              if (f) {
                if (t > 1 && (!f.blockNumber || S - f.blockNumber + 1n < t))
                  return;
                C(() => v.resolve(f));
                return;
              }
              if (u || (h = !0, await $h(async () => {
                u = await at(e, Dw, "getTransaction")({ hash: n }), u.blockNumber && (S = u.blockNumber);
              }, {
                delay: s,
                retryCount: o
              }), h = !1), f = await at(e, bb, "getTransactionReceipt")({ hash: n }), t > 1 && (!f.blockNumber || S - f.blockNumber + 1n < t))
                return;
              C(() => v.resolve(f));
            } catch (k) {
              if (k instanceof zT || k instanceof VT) {
                if (!u) {
                  h = !1;
                  return;
                }
                try {
                  d = u, h = !0;
                  const A = await $h(() => at(e, Es, "getBlock")({
                    blockNumber: S,
                    includeTransactions: !0
                  }), {
                    delay: s,
                    retryCount: o,
                    shouldRetry: ({ error: R }) => R instanceof $T
                  });
                  h = !1;
                  const b = A.transactions.find(({ from: R, nonce: B }) => R === d.from && B === d.nonce);
                  if (!b || (f = await at(e, bb, "getTransactionReceipt")({
                    hash: b.hash
                  }), t > 1 && (!f.blockNumber || S - f.blockNumber + 1n < t)))
                    return;
                  let T = "replaced";
                  b.to === d.to && b.value === d.value ? T = "repriced" : b.from === b.to && b.value === 0n && (T = "cancelled"), C(() => {
                    var R;
                    (R = v.onReplaced) == null || R.call(v, {
                      reason: T,
                      replacedTransaction: d,
                      transaction: b,
                      transactionReceipt: f
                    }), v.resolve(f);
                  });
                } catch (A) {
                  C(() => v.reject(A));
                }
              } else
                C(() => v.reject(k));
            } finally {
              c++;
            }
          }
        }
      });
    });
  });
}
async function M$(e, { account: t = e.account, message: n }) {
  if (!t)
    throw new pw({
      docsPath: "/docs/actions/wallet/signMessage"
    });
  const r = ui(t);
  if (r.signMessage)
    return r.signMessage({ message: n });
  const i = typeof n == "string" ? Yl(n) : n.raw instanceof Uint8Array ? $e(n.raw) : n.raw;
  return e.request({
    method: "personal_sign",
    params: [i, r.address]
  }, { retryCount: 0 });
}
async function F$(e, t) {
  const { abi: n, address: r, args: i, dataSuffix: o, functionName: s, ...a } = t, l = a.account ? ui(a.account) : e.account, c = za({ abi: n, args: i, functionName: s });
  try {
    const { data: u } = await at(e, Xp, "call")({
      batch: !1,
      data: `${c}${o ? o.replace("0x", "") : ""}`,
      to: r,
      ...a,
      account: l
    }), d = Dc({
      abi: n,
      args: i,
      functionName: s,
      data: u || "0x"
    }), f = n.filter((h) => "name" in h && h.name === t.functionName);
    return {
      result: d,
      request: {
        abi: f,
        address: r,
        args: i,
        dataSuffix: o,
        functionName: s,
        ...a,
        account: l
      }
    };
  } catch (u) {
    throw Zu(u, {
      abi: n,
      address: r,
      args: i,
      docsPath: "/docs/contract/simulateContract",
      functionName: s,
      sender: l == null ? void 0 : l.address
    });
  }
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const K_ = BigInt(0), ny = BigInt(1), L$ = BigInt(2);
function Ra(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
function $d(e) {
  if (!Ra(e))
    throw new Error("Uint8Array expected");
}
const U$ = /* @__PURE__ */ Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Zl(e) {
  $d(e);
  let t = "";
  for (let n = 0; n < e.length; n++)
    t += U$[e[n]];
  return t;
}
function Y_(e) {
  const t = e.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function Mw(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return BigInt(e === "" ? "0" : `0x${e}`);
}
const ho = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function Kk(e) {
  if (e >= ho._0 && e <= ho._9)
    return e - ho._0;
  if (e >= ho._A && e <= ho._F)
    return e - (ho._A - 10);
  if (e >= ho._a && e <= ho._f)
    return e - (ho._a - 10);
}
function ec(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  const t = e.length, n = t / 2;
  if (t % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + t);
  const r = new Uint8Array(n);
  for (let i = 0, o = 0; i < n; i++, o += 2) {
    const s = Kk(e.charCodeAt(o)), a = Kk(e.charCodeAt(o + 1));
    if (s === void 0 || a === void 0) {
      const l = e[o] + e[o + 1];
      throw new Error('hex string expected, got non-hex character "' + l + '" at index ' + o);
    }
    r[i] = s * 16 + a;
  }
  return r;
}
function wa(e) {
  return Mw(Zl(e));
}
function Fw(e) {
  return $d(e), Mw(Zl(Uint8Array.from(e).reverse()));
}
function tc(e, t) {
  return ec(e.toString(16).padStart(t * 2, "0"));
}
function Lw(e, t) {
  return tc(e, t).reverse();
}
function z$(e) {
  return ec(Y_(e));
}
function bi(e, t, n) {
  let r;
  if (typeof t == "string")
    try {
      r = ec(t);
    } catch (o) {
      throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${o}`);
    }
  else if (Ra(t))
    r = Uint8Array.from(t);
  else
    throw new Error(`${e} must be hex string or Uint8Array`);
  const i = r.length;
  if (typeof n == "number" && i !== n)
    throw new Error(`${e} expected ${n} bytes, got ${i}`);
  return r;
}
function ed(...e) {
  let t = 0;
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    $d(i), t += i.length;
  }
  const n = new Uint8Array(t);
  for (let r = 0, i = 0; r < e.length; r++) {
    const o = e[r];
    n.set(o, i), i += o.length;
  }
  return n;
}
function Q_(e, t) {
  if (e.length !== t.length)
    return !1;
  let n = 0;
  for (let r = 0; r < e.length; r++)
    n |= e[r] ^ t[r];
  return n === 0;
}
function V$(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function q$(e) {
  let t;
  for (t = 0; e > K_; e >>= ny, t += 1)
    ;
  return t;
}
function $$(e, t) {
  return e >> BigInt(t) & ny;
}
function W$(e, t, n) {
  return e | (n ? ny : K_) << BigInt(t);
}
const Uw = (e) => (L$ << BigInt(e - 1)) - ny, eg = (e) => new Uint8Array(e), Yk = (e) => Uint8Array.from(e);
function J_(e, t, n) {
  if (typeof e != "number" || e < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof n != "function")
    throw new Error("hmacFn must be a function");
  let r = eg(e), i = eg(e), o = 0;
  const s = () => {
    r.fill(1), i.fill(0), o = 0;
  }, a = (...d) => n(i, r, ...d), l = (d = eg()) => {
    i = a(Yk([0]), d), r = a(), d.length !== 0 && (i = a(Yk([1]), d), r = a());
  }, c = () => {
    if (o++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let d = 0;
    const f = [];
    for (; d < t; ) {
      r = a();
      const h = r.slice();
      f.push(h), d += r.length;
    }
    return ed(...f);
  };
  return (d, f) => {
    s(), l(d);
    let h;
    for (; !(h = f(c())); )
      l();
    return s(), h;
  };
}
const G$ = {
  bigint: (e) => typeof e == "bigint",
  function: (e) => typeof e == "function",
  boolean: (e) => typeof e == "boolean",
  string: (e) => typeof e == "string",
  stringOrUint8Array: (e) => typeof e == "string" || Ra(e),
  isSafeInteger: (e) => Number.isSafeInteger(e),
  array: (e) => Array.isArray(e),
  field: (e, t) => t.Fp.isValid(e),
  hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen)
};
function Wd(e, t, n = {}) {
  const r = (i, o, s) => {
    const a = G$[o];
    if (typeof a != "function")
      throw new Error(`Invalid validator "${o}", expected function`);
    const l = e[i];
    if (!(s && l === void 0) && !a(l, e))
      throw new Error(`Invalid param ${String(i)}=${l} (${typeof l}), expected ${o}`);
  };
  for (const [i, o] of Object.entries(t))
    r(i, o, !1);
  for (const [i, o] of Object.entries(n))
    r(i, o, !0);
  return e;
}
const H$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  abytes: $d,
  bitGet: $$,
  bitLen: q$,
  bitMask: Uw,
  bitSet: W$,
  bytesToHex: Zl,
  bytesToNumberBE: wa,
  bytesToNumberLE: Fw,
  concatBytes: ed,
  createHmacDrbg: J_,
  ensureBytes: bi,
  equalBytes: Q_,
  hexToBytes: ec,
  hexToNumber: Mw,
  isBytes: Ra,
  numberToBytesBE: tc,
  numberToBytesLE: Lw,
  numberToHexUnpadded: Y_,
  numberToVarBytesBE: z$,
  utf8ToBytes: V$,
  validateObject: Wd
}, Symbol.toStringTag, { value: "Module" }));
function K$(e, t) {
  const n = ii(e) ? Cs(e) : e, r = ii(t) ? Cs(t) : t;
  return Q_(n, r);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Bn = BigInt(0), hn = BigInt(1), ea = BigInt(2), Y$ = BigInt(3), xb = BigInt(4), Qk = BigInt(5), Jk = BigInt(8);
BigInt(9);
BigInt(16);
function br(e, t) {
  const n = e % t;
  return n >= Bn ? n : t + n;
}
function Q$(e, t, n) {
  if (n <= Bn || t < Bn)
    throw new Error("Expected power/modulo > 0");
  if (n === hn)
    return Bn;
  let r = hn;
  for (; t > Bn; )
    t & hn && (r = r * e % n), e = e * e % n, t >>= hn;
  return r;
}
function zr(e, t, n) {
  let r = e;
  for (; t-- > Bn; )
    r *= r, r %= n;
  return r;
}
function Cb(e, t) {
  if (e === Bn || t <= Bn)
    throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
  let n = br(e, t), r = t, i = Bn, o = hn;
  for (; n !== Bn; ) {
    const a = r / n, l = r % n, c = i - o * a;
    r = n, n = l, i = o, o = c;
  }
  if (r !== hn)
    throw new Error("invert: does not exist");
  return br(i, t);
}
function J$(e) {
  const t = (e - hn) / ea;
  let n, r, i;
  for (n = e - hn, r = 0; n % ea === Bn; n /= ea, r++)
    ;
  for (i = ea; i < e && Q$(i, t, e) !== e - hn; i++)
    ;
  if (r === 1) {
    const s = (e + hn) / xb;
    return function(l, c) {
      const u = l.pow(c, s);
      if (!l.eql(l.sqr(u), c))
        throw new Error("Cannot find square root");
      return u;
    };
  }
  const o = (n + hn) / ea;
  return function(a, l) {
    if (a.pow(l, t) === a.neg(a.ONE))
      throw new Error("Cannot find square root");
    let c = r, u = a.pow(a.mul(a.ONE, i), n), d = a.pow(l, o), f = a.pow(l, n);
    for (; !a.eql(f, a.ONE); ) {
      if (a.eql(f, a.ZERO))
        return a.ZERO;
      let h = 1;
      for (let m = a.sqr(f); h < c && !a.eql(m, a.ONE); h++)
        m = a.sqr(m);
      const p = a.pow(u, hn << BigInt(c - h - 1));
      u = a.sqr(p), d = a.mul(d, p), f = a.mul(f, u), c = h;
    }
    return d;
  };
}
function X$(e) {
  if (e % xb === Y$) {
    const t = (e + hn) / xb;
    return function(r, i) {
      const o = r.pow(i, t);
      if (!r.eql(r.sqr(o), i))
        throw new Error("Cannot find square root");
      return o;
    };
  }
  if (e % Jk === Qk) {
    const t = (e - Qk) / Jk;
    return function(r, i) {
      const o = r.mul(i, ea), s = r.pow(o, t), a = r.mul(i, s), l = r.mul(r.mul(a, ea), s), c = r.mul(a, r.sub(l, r.ONE));
      if (!r.eql(r.sqr(c), i))
        throw new Error("Cannot find square root");
      return c;
    };
  }
  return J$(e);
}
const Z$ = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function eW(e) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, n = Z$.reduce((r, i) => (r[i] = "function", r), t);
  return Wd(e, n);
}
function tW(e, t, n) {
  if (n < Bn)
    throw new Error("Expected power > 0");
  if (n === Bn)
    return e.ONE;
  if (n === hn)
    return t;
  let r = e.ONE, i = t;
  for (; n > Bn; )
    n & hn && (r = e.mul(r, i)), i = e.sqr(i), n >>= hn;
  return r;
}
function nW(e, t) {
  const n = new Array(t.length), r = t.reduce((o, s, a) => e.is0(s) ? o : (n[a] = o, e.mul(o, s)), e.ONE), i = e.inv(r);
  return t.reduceRight((o, s, a) => e.is0(s) ? o : (n[a] = e.mul(o, n[a]), e.mul(o, s)), i), n;
}
function X_(e, t) {
  const n = t !== void 0 ? t : e.toString(2).length, r = Math.ceil(n / 8);
  return { nBitLength: n, nByteLength: r };
}
function rW(e, t, n = !1, r = {}) {
  if (e <= Bn)
    throw new Error(`Expected Field ORDER > 0, got ${e}`);
  const { nBitLength: i, nByteLength: o } = X_(e, t);
  if (o > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const s = X$(e), a = Object.freeze({
    ORDER: e,
    BITS: i,
    BYTES: o,
    MASK: Uw(i),
    ZERO: Bn,
    ONE: hn,
    create: (l) => br(l, e),
    isValid: (l) => {
      if (typeof l != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof l}`);
      return Bn <= l && l < e;
    },
    is0: (l) => l === Bn,
    isOdd: (l) => (l & hn) === hn,
    neg: (l) => br(-l, e),
    eql: (l, c) => l === c,
    sqr: (l) => br(l * l, e),
    add: (l, c) => br(l + c, e),
    sub: (l, c) => br(l - c, e),
    mul: (l, c) => br(l * c, e),
    pow: (l, c) => tW(a, l, c),
    div: (l, c) => br(l * Cb(c, e), e),
    // Same as above, but doesn't normalize
    sqrN: (l) => l * l,
    addN: (l, c) => l + c,
    subN: (l, c) => l - c,
    mulN: (l, c) => l * c,
    inv: (l) => Cb(l, e),
    sqrt: r.sqrt || ((l) => s(a, l)),
    invertBatch: (l) => nW(a, l),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (l, c, u) => u ? c : l,
    toBytes: (l) => n ? Lw(l, o) : tc(l, o),
    fromBytes: (l) => {
      if (l.length !== o)
        throw new Error(`Fp.fromBytes: expected ${o}, got ${l.length}`);
      return n ? Fw(l) : wa(l);
    }
  });
  return Object.freeze(a);
}
function Z_(e) {
  if (typeof e != "bigint")
    throw new Error("field order must be bigint");
  const t = e.toString(2).length;
  return Math.ceil(t / 8);
}
function eI(e) {
  const t = Z_(e);
  return t + Math.ceil(t / 2);
}
function iW(e, t, n = !1) {
  const r = e.length, i = Z_(t), o = eI(t);
  if (r < 16 || r < o || r > 1024)
    throw new Error(`expected ${o}-1024 bytes of input, got ${r}`);
  const s = n ? wa(e) : Fw(e), a = br(s, t - hn) + hn;
  return n ? Lw(a, i) : tc(a, i);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const oW = BigInt(0), tg = BigInt(1);
function sW(e, t) {
  const n = (i, o) => {
    const s = o.negate();
    return i ? s : o;
  }, r = (i) => {
    const o = Math.ceil(t / i) + 1, s = 2 ** (i - 1);
    return { windows: o, windowSize: s };
  };
  return {
    constTimeNegate: n,
    // non-const time multiplication ladder
    unsafeLadder(i, o) {
      let s = e.ZERO, a = i;
      for (; o > oW; )
        o & tg && (s = s.add(a)), a = a.double(), o >>= tg;
      return s;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(i, o) {
      const { windows: s, windowSize: a } = r(o), l = [];
      let c = i, u = c;
      for (let d = 0; d < s; d++) {
        u = c, l.push(u);
        for (let f = 1; f < a; f++)
          u = u.add(c), l.push(u);
        c = u.double();
      }
      return l;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(i, o, s) {
      const { windows: a, windowSize: l } = r(i);
      let c = e.ZERO, u = e.BASE;
      const d = BigInt(2 ** i - 1), f = 2 ** i, h = BigInt(i);
      for (let p = 0; p < a; p++) {
        const m = p * l;
        let g = Number(s & d);
        s >>= h, g > l && (g -= f, s += tg);
        const v = m, w = m + Math.abs(g) - 1, x = p % 2 !== 0, C = g < 0;
        g === 0 ? u = u.add(n(x, o[v])) : c = c.add(n(C, o[w]));
      }
      return { p: c, f: u };
    },
    wNAFCached(i, o, s, a) {
      const l = i._WINDOW_SIZE || 1;
      let c = o.get(i);
      return c || (c = this.precomputeWindow(i, l), l !== 1 && o.set(i, a(c))), this.wNAF(l, c, s);
    }
  };
}
function tI(e) {
  return eW(e.Fp), Wd(e, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...X_(e.n, e.nBitLength),
    ...e,
    p: e.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function aW(e) {
  const t = tI(e);
  Wd(t, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: n, Fp: r, a: i } = t;
  if (n) {
    if (!r.eql(i, r.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof n != "object" || typeof n.beta != "bigint" || typeof n.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...t });
}
const { bytesToNumberBE: lW, hexToBytes: cW } = H$, sa = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(t = "") {
      super(t);
    }
  },
  _parseInt(e) {
    const { Err: t } = sa;
    if (e.length < 2 || e[0] !== 2)
      throw new t("Invalid signature integer tag");
    const n = e[1], r = e.subarray(2, n + 2);
    if (!n || r.length !== n)
      throw new t("Invalid signature integer: wrong length");
    if (r[0] & 128)
      throw new t("Invalid signature integer: negative");
    if (r[0] === 0 && !(r[1] & 128))
      throw new t("Invalid signature integer: unnecessary leading zero");
    return { d: lW(r), l: e.subarray(n + 2) };
  },
  toSig(e) {
    const { Err: t } = sa, n = typeof e == "string" ? cW(e) : e;
    $d(n);
    let r = n.length;
    if (r < 2 || n[0] != 48)
      throw new t("Invalid signature tag");
    if (n[1] !== r - 2)
      throw new t("Invalid signature: incorrect length");
    const { d: i, l: o } = sa._parseInt(n.subarray(2)), { d: s, l: a } = sa._parseInt(o);
    if (a.length)
      throw new t("Invalid signature: left bytes after parsing");
    return { r: i, s };
  },
  hexFromSig(e) {
    const t = (c) => Number.parseInt(c[0], 16) & 8 ? "00" + c : c, n = (c) => {
      const u = c.toString(16);
      return u.length & 1 ? `0${u}` : u;
    }, r = t(n(e.s)), i = t(n(e.r)), o = r.length / 2, s = i.length / 2, a = n(o), l = n(s);
    return `30${n(s + o + 4)}02${l}${i}02${a}${r}`;
  }
}, go = BigInt(0), Qr = BigInt(1);
BigInt(2);
const Xk = BigInt(3);
BigInt(4);
function uW(e) {
  const t = aW(e), { Fp: n } = t, r = t.toBytes || ((p, m, g) => {
    const v = m.toAffine();
    return ed(Uint8Array.from([4]), n.toBytes(v.x), n.toBytes(v.y));
  }), i = t.fromBytes || ((p) => {
    const m = p.subarray(1), g = n.fromBytes(m.subarray(0, n.BYTES)), v = n.fromBytes(m.subarray(n.BYTES, 2 * n.BYTES));
    return { x: g, y: v };
  });
  function o(p) {
    const { a: m, b: g } = t, v = n.sqr(p), w = n.mul(v, p);
    return n.add(n.add(w, n.mul(p, m)), g);
  }
  if (!n.eql(n.sqr(t.Gy), o(t.Gx)))
    throw new Error("bad generator point: equation left != right");
  function s(p) {
    return typeof p == "bigint" && go < p && p < t.n;
  }
  function a(p) {
    if (!s(p))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function l(p) {
    const { allowedPrivateKeyLengths: m, nByteLength: g, wrapPrivateKey: v, n: w } = t;
    if (m && typeof p != "bigint") {
      if (Ra(p) && (p = Zl(p)), typeof p != "string" || !m.includes(p.length))
        throw new Error("Invalid key");
      p = p.padStart(g * 2, "0");
    }
    let x;
    try {
      x = typeof p == "bigint" ? p : wa(bi("private key", p, g));
    } catch {
      throw new Error(`private key must be ${g} bytes, hex or bigint, not ${typeof p}`);
    }
    return v && (x = br(x, w)), a(x), x;
  }
  const c = /* @__PURE__ */ new Map();
  function u(p) {
    if (!(p instanceof d))
      throw new Error("ProjectivePoint expected");
  }
  class d {
    constructor(m, g, v) {
      if (this.px = m, this.py = g, this.pz = v, m == null || !n.isValid(m))
        throw new Error("x required");
      if (g == null || !n.isValid(g))
        throw new Error("y required");
      if (v == null || !n.isValid(v))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(m) {
      const { x: g, y: v } = m || {};
      if (!m || !n.isValid(g) || !n.isValid(v))
        throw new Error("invalid affine point");
      if (m instanceof d)
        throw new Error("projective point not allowed");
      const w = (x) => n.eql(x, n.ZERO);
      return w(g) && w(v) ? d.ZERO : new d(g, v, n.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(m) {
      const g = n.invertBatch(m.map((v) => v.pz));
      return m.map((v, w) => v.toAffine(g[w])).map(d.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(m) {
      const g = d.fromAffine(i(bi("pointHex", m)));
      return g.assertValidity(), g;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(m) {
      return d.BASE.multiply(l(m));
    }
    // "Private method", don't use it directly
    _setWindowSize(m) {
      this._WINDOW_SIZE = m, c.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (t.allowInfinityPoint && !n.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: m, y: g } = this.toAffine();
      if (!n.isValid(m) || !n.isValid(g))
        throw new Error("bad point: x or y not FE");
      const v = n.sqr(g), w = o(m);
      if (!n.eql(v, w))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: m } = this.toAffine();
      if (n.isOdd)
        return !n.isOdd(m);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(m) {
      u(m);
      const { px: g, py: v, pz: w } = this, { px: x, py: C, pz: S } = m, k = n.eql(n.mul(g, S), n.mul(x, w)), A = n.eql(n.mul(v, S), n.mul(C, w));
      return k && A;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new d(this.px, n.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: m, b: g } = t, v = n.mul(g, Xk), { px: w, py: x, pz: C } = this;
      let S = n.ZERO, k = n.ZERO, A = n.ZERO, b = n.mul(w, w), T = n.mul(x, x), R = n.mul(C, C), B = n.mul(w, x);
      return B = n.add(B, B), A = n.mul(w, C), A = n.add(A, A), S = n.mul(m, A), k = n.mul(v, R), k = n.add(S, k), S = n.sub(T, k), k = n.add(T, k), k = n.mul(S, k), S = n.mul(B, S), A = n.mul(v, A), R = n.mul(m, R), B = n.sub(b, R), B = n.mul(m, B), B = n.add(B, A), A = n.add(b, b), b = n.add(A, b), b = n.add(b, R), b = n.mul(b, B), k = n.add(k, b), R = n.mul(x, C), R = n.add(R, R), b = n.mul(R, B), S = n.sub(S, b), A = n.mul(R, T), A = n.add(A, A), A = n.add(A, A), new d(S, k, A);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(m) {
      u(m);
      const { px: g, py: v, pz: w } = this, { px: x, py: C, pz: S } = m;
      let k = n.ZERO, A = n.ZERO, b = n.ZERO;
      const T = t.a, R = n.mul(t.b, Xk);
      let B = n.mul(g, x), O = n.mul(v, C), L = n.mul(w, S), V = n.add(g, v), N = n.add(x, C);
      V = n.mul(V, N), N = n.add(B, O), V = n.sub(V, N), N = n.add(g, w);
      let M = n.add(x, S);
      return N = n.mul(N, M), M = n.add(B, L), N = n.sub(N, M), M = n.add(v, w), k = n.add(C, S), M = n.mul(M, k), k = n.add(O, L), M = n.sub(M, k), b = n.mul(T, N), k = n.mul(R, L), b = n.add(k, b), k = n.sub(O, b), b = n.add(O, b), A = n.mul(k, b), O = n.add(B, B), O = n.add(O, B), L = n.mul(T, L), N = n.mul(R, N), O = n.add(O, L), L = n.sub(B, L), L = n.mul(T, L), N = n.add(N, L), B = n.mul(O, N), A = n.add(A, B), B = n.mul(M, N), k = n.mul(V, k), k = n.sub(k, B), B = n.mul(V, O), b = n.mul(M, b), b = n.add(b, B), new d(k, A, b);
    }
    subtract(m) {
      return this.add(m.negate());
    }
    is0() {
      return this.equals(d.ZERO);
    }
    wNAF(m) {
      return h.wNAFCached(this, c, m, (g) => {
        const v = n.invertBatch(g.map((w) => w.pz));
        return g.map((w, x) => w.toAffine(v[x])).map(d.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(m) {
      const g = d.ZERO;
      if (m === go)
        return g;
      if (a(m), m === Qr)
        return this;
      const { endo: v } = t;
      if (!v)
        return h.unsafeLadder(this, m);
      let { k1neg: w, k1: x, k2neg: C, k2: S } = v.splitScalar(m), k = g, A = g, b = this;
      for (; x > go || S > go; )
        x & Qr && (k = k.add(b)), S & Qr && (A = A.add(b)), b = b.double(), x >>= Qr, S >>= Qr;
      return w && (k = k.negate()), C && (A = A.negate()), A = new d(n.mul(A.px, v.beta), A.py, A.pz), k.add(A);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(m) {
      a(m);
      let g = m, v, w;
      const { endo: x } = t;
      if (x) {
        const { k1neg: C, k1: S, k2neg: k, k2: A } = x.splitScalar(g);
        let { p: b, f: T } = this.wNAF(S), { p: R, f: B } = this.wNAF(A);
        b = h.constTimeNegate(C, b), R = h.constTimeNegate(k, R), R = new d(n.mul(R.px, x.beta), R.py, R.pz), v = b.add(R), w = T.add(B);
      } else {
        const { p: C, f: S } = this.wNAF(g);
        v = C, w = S;
      }
      return d.normalizeZ([v, w])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(m, g, v) {
      const w = d.BASE, x = (S, k) => k === go || k === Qr || !S.equals(w) ? S.multiplyUnsafe(k) : S.multiply(k), C = x(this, g).add(x(m, v));
      return C.is0() ? void 0 : C;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(m) {
      const { px: g, py: v, pz: w } = this, x = this.is0();
      m == null && (m = x ? n.ONE : n.inv(w));
      const C = n.mul(g, m), S = n.mul(v, m), k = n.mul(w, m);
      if (x)
        return { x: n.ZERO, y: n.ZERO };
      if (!n.eql(k, n.ONE))
        throw new Error("invZ was invalid");
      return { x: C, y: S };
    }
    isTorsionFree() {
      const { h: m, isTorsionFree: g } = t;
      if (m === Qr)
        return !0;
      if (g)
        return g(d, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: m, clearCofactor: g } = t;
      return m === Qr ? this : g ? g(d, this) : this.multiplyUnsafe(t.h);
    }
    toRawBytes(m = !0) {
      return this.assertValidity(), r(d, this, m);
    }
    toHex(m = !0) {
      return Zl(this.toRawBytes(m));
    }
  }
  d.BASE = new d(t.Gx, t.Gy, n.ONE), d.ZERO = new d(n.ZERO, n.ONE, n.ZERO);
  const f = t.nBitLength, h = sW(d, t.endo ? Math.ceil(f / 2) : f);
  return {
    CURVE: t,
    ProjectivePoint: d,
    normPrivateKeyToScalar: l,
    weierstrassEquation: o,
    isWithinCurveOrder: s
  };
}
function dW(e) {
  const t = tI(e);
  return Wd(t, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...t });
}
function fW(e) {
  const t = dW(e), { Fp: n, n: r } = t, i = n.BYTES + 1, o = 2 * n.BYTES + 1;
  function s(N) {
    return go < N && N < n.ORDER;
  }
  function a(N) {
    return br(N, r);
  }
  function l(N) {
    return Cb(N, r);
  }
  const { ProjectivePoint: c, normPrivateKeyToScalar: u, weierstrassEquation: d, isWithinCurveOrder: f } = uW({
    ...t,
    toBytes(N, M, U) {
      const F = M.toAffine(), $ = n.toBytes(F.x), ie = ed;
      return U ? ie(Uint8Array.from([M.hasEvenY() ? 2 : 3]), $) : ie(Uint8Array.from([4]), $, n.toBytes(F.y));
    },
    fromBytes(N) {
      const M = N.length, U = N[0], F = N.subarray(1);
      if (M === i && (U === 2 || U === 3)) {
        const $ = wa(F);
        if (!s($))
          throw new Error("Point is not on curve");
        const ie = d($);
        let he;
        try {
          he = n.sqrt(ie);
        } catch (oe) {
          const ye = oe instanceof Error ? ": " + oe.message : "";
          throw new Error("Point is not on curve" + ye);
        }
        const ae = (he & Qr) === Qr;
        return (U & 1) === 1 !== ae && (he = n.neg(he)), { x: $, y: he };
      } else if (M === o && U === 4) {
        const $ = n.fromBytes(F.subarray(0, n.BYTES)), ie = n.fromBytes(F.subarray(n.BYTES, 2 * n.BYTES));
        return { x: $, y: ie };
      } else
        throw new Error(`Point of length ${M} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`);
    }
  }), h = (N) => Zl(tc(N, t.nByteLength));
  function p(N) {
    const M = r >> Qr;
    return N > M;
  }
  function m(N) {
    return p(N) ? a(-N) : N;
  }
  const g = (N, M, U) => wa(N.slice(M, U));
  class v {
    constructor(M, U, F) {
      this.r = M, this.s = U, this.recovery = F, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(M) {
      const U = t.nByteLength;
      return M = bi("compactSignature", M, U * 2), new v(g(M, 0, U), g(M, U, 2 * U));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(M) {
      const { r: U, s: F } = sa.toSig(bi("DER", M));
      return new v(U, F);
    }
    assertValidity() {
      if (!f(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!f(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(M) {
      return new v(this.r, this.s, M);
    }
    recoverPublicKey(M) {
      const { r: U, s: F, recovery: $ } = this, ie = A(bi("msgHash", M));
      if ($ == null || ![0, 1, 2, 3].includes($))
        throw new Error("recovery id invalid");
      const he = $ === 2 || $ === 3 ? U + t.n : U;
      if (he >= n.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const ae = $ & 1 ? "03" : "02", se = c.fromHex(ae + h(he)), oe = l(he), ye = a(-ie * oe), ve = a(F * oe), Be = c.BASE.multiplyAndAddUnsafe(se, ye, ve);
      if (!Be)
        throw new Error("point at infinify");
      return Be.assertValidity(), Be;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return p(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new v(this.r, a(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return ec(this.toDERHex());
    }
    toDERHex() {
      return sa.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return ec(this.toCompactHex());
    }
    toCompactHex() {
      return h(this.r) + h(this.s);
    }
  }
  const w = {
    isValidPrivateKey(N) {
      try {
        return u(N), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: u,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const N = eI(t.n);
      return iW(t.randomBytes(N), t.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(N = 8, M = c.BASE) {
      return M._setWindowSize(N), M.multiply(BigInt(3)), M;
    }
  };
  function x(N, M = !0) {
    return c.fromPrivateKey(N).toRawBytes(M);
  }
  function C(N) {
    const M = Ra(N), U = typeof N == "string", F = (M || U) && N.length;
    return M ? F === i || F === o : U ? F === 2 * i || F === 2 * o : N instanceof c;
  }
  function S(N, M, U = !0) {
    if (C(N))
      throw new Error("first arg must be private key");
    if (!C(M))
      throw new Error("second arg must be public key");
    return c.fromHex(M).multiply(u(N)).toRawBytes(U);
  }
  const k = t.bits2int || function(N) {
    const M = wa(N), U = N.length * 8 - t.nBitLength;
    return U > 0 ? M >> BigInt(U) : M;
  }, A = t.bits2int_modN || function(N) {
    return a(k(N));
  }, b = Uw(t.nBitLength);
  function T(N) {
    if (typeof N != "bigint")
      throw new Error("bigint expected");
    if (!(go <= N && N < b))
      throw new Error(`bigint expected < 2^${t.nBitLength}`);
    return tc(N, t.nByteLength);
  }
  function R(N, M, U = B) {
    if (["recovered", "canonical"].some((lt) => lt in U))
      throw new Error("sign() legacy options not supported");
    const { hash: F, randomBytes: $ } = t;
    let { lowS: ie, prehash: he, extraEntropy: ae } = U;
    ie == null && (ie = !0), N = bi("msgHash", N), he && (N = bi("prehashed msgHash", F(N)));
    const se = A(N), oe = u(M), ye = [T(oe), T(se)];
    if (ae != null && ae !== !1) {
      const lt = ae === !0 ? $(n.BYTES) : ae;
      ye.push(bi("extraEntropy", lt));
    }
    const ve = ed(...ye), Be = se;
    function it(lt) {
      const yt = k(lt);
      if (!f(yt))
        return;
      const gt = l(yt), vt = c.BASE.multiply(yt).toAffine(), ot = a(vt.x);
      if (ot === go)
        return;
      const Le = a(gt * a(Be + ot * oe));
      if (Le === go)
        return;
      let tt = (vt.x === ot ? 0 : 2) | Number(vt.y & Qr), jt = Le;
      return ie && p(Le) && (jt = m(Le), tt ^= 1), new v(ot, jt, tt);
    }
    return { seed: ve, k2sig: it };
  }
  const B = { lowS: t.lowS, prehash: !1 }, O = { lowS: t.lowS, prehash: !1 };
  function L(N, M, U = B) {
    const { seed: F, k2sig: $ } = R(N, M, U), ie = t;
    return J_(ie.hash.outputLen, ie.nByteLength, ie.hmac)(F, $);
  }
  c.BASE._setWindowSize(8);
  function V(N, M, U, F = O) {
    var vt;
    const $ = N;
    if (M = bi("msgHash", M), U = bi("publicKey", U), "strict" in F)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: ie, prehash: he } = F;
    let ae, se;
    try {
      if (typeof $ == "string" || Ra($))
        try {
          ae = v.fromDER($);
        } catch (ot) {
          if (!(ot instanceof sa.Err))
            throw ot;
          ae = v.fromCompact($);
        }
      else if (typeof $ == "object" && typeof $.r == "bigint" && typeof $.s == "bigint") {
        const { r: ot, s: Le } = $;
        ae = new v(ot, Le);
      } else
        throw new Error("PARSE");
      se = c.fromHex(U);
    } catch (ot) {
      if (ot.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (ie && ae.hasHighS())
      return !1;
    he && (M = t.hash(M));
    const { r: oe, s: ye } = ae, ve = A(M), Be = l(ye), it = a(ve * Be), lt = a(oe * Be), yt = (vt = c.BASE.multiplyAndAddUnsafe(se, it, lt)) == null ? void 0 : vt.toAffine();
    return yt ? a(yt.x) === oe : !1;
  }
  return {
    CURVE: t,
    getPublicKey: x,
    getSharedSecret: S,
    sign: L,
    verify: V,
    ProjectivePoint: c,
    Signature: v,
    utils: w
  };
}
class nI extends lw {
  constructor(t, n) {
    super(), this.finished = !1, this.destroyed = !1, IU(t);
    const r = Vp(n);
    if (this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const i = this.blockLen, o = new Uint8Array(i);
    o.set(r.length > i ? t.create().update(r).digest() : r);
    for (let s = 0; s < o.length; s++)
      o[s] ^= 54;
    this.iHash.update(o), this.oHash = t.create();
    for (let s = 0; s < o.length; s++)
      o[s] ^= 106;
    this.oHash.update(o), o.fill(0);
  }
  update(t) {
    return Ql(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    Ql(this), Od(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n, iHash: r, finished: i, destroyed: o, blockLen: s, outputLen: a } = this;
    return t = t, t.finished = i, t.destroyed = o, t.blockLen = s, t.outputLen = a, t.oHash = n._cloneInto(t.oHash), t.iHash = r._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const rI = (e, t, n) => new nI(e, t).update(n).digest();
rI.create = (e, t) => new nI(e, t);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function hW(e) {
  return {
    hash: e,
    hmac: (t, ...n) => rI(e, t, LU(...n)),
    randomBytes: UU
  };
}
function pW(e, t) {
  const n = (r) => fW({ ...e, ...hW(r) });
  return Object.freeze({ ...n(t), create: n });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const iI = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), Zk = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), yW = BigInt(1), kb = BigInt(2), eE = (e, t) => (e + t / kb) / t;
function mW(e) {
  const t = iI, n = BigInt(3), r = BigInt(6), i = BigInt(11), o = BigInt(22), s = BigInt(23), a = BigInt(44), l = BigInt(88), c = e * e * e % t, u = c * c * e % t, d = zr(u, n, t) * u % t, f = zr(d, n, t) * u % t, h = zr(f, kb, t) * c % t, p = zr(h, i, t) * h % t, m = zr(p, o, t) * p % t, g = zr(m, a, t) * m % t, v = zr(g, l, t) * g % t, w = zr(v, a, t) * m % t, x = zr(w, n, t) * u % t, C = zr(x, s, t) * p % t, S = zr(C, r, t) * c % t, k = zr(S, kb, t);
  if (!Eb.eql(Eb.sqr(k), e))
    throw new Error("Cannot find square root");
  return k;
}
const Eb = rW(iI, void 0, void 0, { sqrt: mW }), zw = pW({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp: Eb,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: Zk,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: !0,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (e) => {
      const t = Zk, n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), r = -yW * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), o = n, s = BigInt("0x100000000000000000000000000000000"), a = eE(o * e, t), l = eE(-r * e, t);
      let c = br(e - a * n - l * i, t), u = br(-a * r - l * o, t);
      const d = c > s, f = u > s;
      if (d && (c = t - c), f && (u = t - u), c > s || u > s)
        throw new Error("splitScalar: Endomorphism failed, k=" + e);
      return { k1neg: d, k1: c, k2neg: f, k2: u };
    }
  }
}, XT);
BigInt(0);
zw.ProjectivePoint;
const gW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  secp256k1: zw
}, Symbol.toStringTag, { value: "Module" }));
function vW({ r: e, s: t, to: n = "hex", v: r, yParity: i }) {
  const o = (() => {
    if (i === 0 || i === 1)
      return i;
    if (r && (r === 27n || r === 28n || r >= 35n))
      return r % 2n === 0n ? 1 : 0;
    throw new Error("Invalid `v` or `yParity` value");
  })(), s = `0x${new zw.Signature(Yn(e), Yn(t)).toCompactHex()}${o === 0 ? "1b" : "1c"}`;
  return n === "hex" ? s : Ai(s);
}
async function Vw(e, t) {
  const { address: n, factory: r, factoryData: i, hash: o, signature: s, ...a } = t, l = ii(s) ? s : typeof s == "object" && "r" in s && "s" in s ? vW(s) : vn(s), c = await (async () => !r && !i || w$(l) ? l : x$({
    address: r,
    data: i,
    signature: l
  }))();
  try {
    const { data: u } = await at(e, Xp, "call")({
      data: hw({
        abi: tV,
        args: [n, o, c],
        bytecode: fq
      }),
      ...a
    });
    return K$(u ?? "0x0", "0x1");
  } catch (u) {
    try {
      if (Pw(Qn(n), await NT({ hash: o, signature: s })))
        return !0;
    } catch {
    }
    if (u instanceof A_)
      return !1;
    throw u;
  }
}
async function bW(e, { address: t, message: n, factory: r, factoryData: i, signature: o, ...s }) {
  const a = G_(n);
  return Vw(e, {
    address: t,
    factory: r,
    factoryData: i,
    hash: a,
    signature: o,
    ...s
  });
}
async function wW(e, t) {
  const { address: n, factory: r, factoryData: i, signature: o, message: s, primaryType: a, types: l, domain: c, ...u } = t, d = f$({ message: s, primaryType: a, types: l, domain: c });
  return Vw(e, {
    address: n,
    factory: r,
    factoryData: i,
    hash: d,
    signature: o,
    ...u
  });
}
function xW(e, t) {
  const { abi: n, address: r, args: i, batch: o = !0, eventName: s, fromBlock: a, onError: l, onLogs: c, poll: u, pollingInterval: d = e.pollingInterval, strict: f } = t;
  return (typeof u < "u" ? u : typeof a == "bigint" ? !0 : !(e.transport.type === "webSocket" || e.transport.type === "fallback" && e.transport.transports[0].config.type === "webSocket")) ? (() => {
    const g = f ?? !1, v = Jn([
      "watchContractEvent",
      r,
      i,
      o,
      e.uid,
      s,
      d,
      g,
      a
    ]);
    return As(v, { onLogs: c, onError: l }, (w) => {
      let x;
      a !== void 0 && (x = a - 1n);
      let C, S = !1;
      const k = Vd(async () => {
        var A;
        if (!S) {
          try {
            C = await at(e, D_, "createContractEventFilter")({
              abi: n,
              address: r,
              args: i,
              eventName: s,
              strict: g,
              fromBlock: a
            });
          } catch {
          }
          S = !0;
          return;
        }
        try {
          let b;
          if (C)
            b = await at(e, ey, "getFilterChanges")({ filter: C });
          else {
            const T = await at(e, zd, "getBlockNumber")({});
            x && x < T ? b = await at(e, F_, "getContractEvents")({
              abi: n,
              address: r,
              args: i,
              eventName: s,
              fromBlock: x + 1n,
              toBlock: T,
              strict: g
            }) : b = [], x = T;
          }
          if (b.length === 0)
            return;
          if (o)
            w.onLogs(b);
          else
            for (const T of b)
              w.onLogs([T]);
        } catch (b) {
          C && b instanceof Ia && (S = !1), (A = w.onError) == null || A.call(w, b);
        }
      }, {
        emitOnBegin: !0,
        interval: d
      });
      return async () => {
        C && await at(e, ty, "uninstallFilter")({ filter: C }), k();
      };
    });
  })() : (() => {
    const g = f ?? !1, v = Jn([
      "watchContractEvent",
      r,
      i,
      o,
      e.uid,
      s,
      d,
      g
    ]);
    let w = !0, x = () => w = !1;
    return As(v, { onLogs: c, onError: l }, (C) => ((async () => {
      try {
        const S = (() => {
          if (e.transport.type === "fallback") {
            const b = e.transport.transports.find((T) => T.config.type === "webSocket");
            return b ? b.value : e.transport;
          }
          return e.transport;
        })(), k = s ? Ud({
          abi: n,
          eventName: s,
          args: i
        }) : [], { unsubscribe: A } = await S.subscribe({
          params: ["logs", { address: r, topics: k }],
          onData(b) {
            var R;
            if (!w)
              return;
            const T = b.result;
            try {
              const { eventName: B, args: O } = Ow({
                abi: n,
                data: T.data,
                topics: T.topics,
                strict: f
              }), L = Ss(T, {
                args: O,
                eventName: B
              });
              C.onLogs([L]);
            } catch (B) {
              let O, L;
              if (B instanceof Fu || B instanceof zp) {
                if (f)
                  return;
                O = B.abiItem.name, L = (R = B.abiItem.inputs) == null ? void 0 : R.some((N) => !("name" in N && N.name));
              }
              const V = Ss(T, {
                args: L ? [] : {},
                eventName: O
              });
              C.onLogs([V]);
            }
          },
          onError(b) {
            var T;
            (T = C.onError) == null || T.call(C, b);
          }
        });
        x = A, w || x();
      } catch (S) {
        l == null || l(S);
      }
    })(), () => x()));
  })();
}
function td(e, t, n) {
  const r = e[t.name];
  if (typeof r == "function")
    return r;
  const i = e[n];
  return typeof i == "function" ? i : (o) => t(e, o);
}
const gh = "2.14.1", CW = () => `@wagmi/core@${gh}`;
var oI = function(e, t, n, r) {
  if (n === "a" && !r) throw new TypeError("Private accessor was defined without a getter");
  if (typeof t == "function" ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? r : n === "a" ? r.call(e) : r ? r.value : t.get(e);
}, Wh, sI;
let Lo = class Sb extends Error {
  get docsBaseUrl() {
    return "https://wagmi.sh/core";
  }
  get version() {
    return CW();
  }
  constructor(t, n = {}) {
    var o;
    super(), Wh.add(this), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "WagmiCoreError"
    });
    const r = n.cause instanceof Sb ? n.cause.details : (o = n.cause) != null && o.message ? n.cause.message : n.details, i = n.cause instanceof Sb && n.cause.docsPath || n.docsPath;
    this.message = [
      t || "An error occurred.",
      "",
      ...n.metaMessages ? [...n.metaMessages, ""] : [],
      ...i ? [
        `Docs: ${this.docsBaseUrl}${i}.html${n.docsSlug ? `#${n.docsSlug}` : ""}`
      ] : [],
      ...r ? [`Details: ${r}`] : [],
      `Version: ${this.version}`
    ].join(`
`), n.cause && (this.cause = n.cause), this.details = r, this.docsPath = i, this.metaMessages = n.metaMessages, this.shortMessage = t;
  }
  walk(t) {
    return oI(this, Wh, "m", sI).call(this, this, t);
  }
};
Wh = /* @__PURE__ */ new WeakSet(), sI = function e(t, n) {
  return n != null && n(t) ? t : t.cause ? oI(this, Wh, "m", e).call(this, t.cause, n) : t;
};
class Pa extends Lo {
  constructor() {
    super("Chain not configured."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ChainNotConfiguredError"
    });
  }
}
class kW extends Lo {
  constructor() {
    super("Connector already connected."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ConnectorAlreadyConnectedError"
    });
  }
}
class EW extends Lo {
  constructor() {
    super("Connector not connected."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ConnectorNotConnectedError"
    });
  }
}
class SW extends Lo {
  constructor({ address: t, connector: n }) {
    super(`Account "${t}" not found for connector "${n.name}".`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ConnectorAccountNotFoundError"
    });
  }
}
class AW extends Lo {
  constructor({ connectionChainId: t, connectorChainId: n }) {
    super(`The current chain of the connector (id: ${n}) does not match the connection's chain (id: ${t}).`, {
      metaMessages: [
        `Current Chain ID:  ${n}`,
        `Expected Chain ID: ${t}`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ConnectorChainMismatchError"
    });
  }
}
class TW extends Lo {
  constructor({ connector: t }) {
    super(`Connector "${t.name}" unavailable while reconnecting.`, {
      details: [
        "During the reconnection step, the only connector methods guaranteed to be available are: `id`, `name`, `type`, `uuid`.",
        "All other methods are not guaranteed to be available until reconnection completes and connectors are fully restored.",
        "This error commonly occurs for connectors that asynchronously inject after reconnection has already started."
      ].join(" ")
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ConnectorUnavailableReconnectingError"
    });
  }
}
async function aI(e, t) {
  var r;
  let n;
  if (typeof t.connector == "function" ? n = e._internal.connectors.setup(t.connector) : n = t.connector, n.uid === e.state.current)
    throw new kW();
  try {
    e.setState((s) => ({ ...s, status: "connecting" })), n.emitter.emit("message", { type: "connecting" });
    const i = await n.connect({ chainId: t.chainId }), o = i.accounts;
    return n.emitter.off("connect", e._internal.events.connect), n.emitter.on("change", e._internal.events.change), n.emitter.on("disconnect", e._internal.events.disconnect), await ((r = e.storage) == null ? void 0 : r.setItem("recentConnectorId", n.id)), e.setState((s) => ({
      ...s,
      connections: new Map(s.connections).set(n.uid, {
        accounts: o,
        chainId: i.chainId,
        connector: n
      }),
      current: n.uid,
      status: "connected"
    })), { accounts: o, chainId: i.chainId };
  } catch (i) {
    throw e.setState((o) => ({
      ...o,
      // Keep existing connector connected in case of error
      status: o.current ? "connected" : "disconnected"
    })), i;
  }
}
const Ab = 256;
let Pf = Ab, Of;
function lI(e = 11) {
  if (!Of || Pf + e > Ab * 2) {
    Of = "", Pf = 0;
    for (let t = 0; t < Ab; t++)
      Of += (256 + Math.random() * 256 | 0).toString(16).substring(1);
  }
  return Of.substring(Pf, Pf++ + e);
}
function ry(e) {
  const { batch: t, cacheTime: n = e.pollingInterval ?? 4e3, ccipRead: r, key: i = "base", name: o = "Base Client", pollingInterval: s = 4e3, type: a = "base" } = e, l = e.chain, c = e.account ? ui(e.account) : void 0, { config: u, request: d, value: f } = e.transport({
    chain: l,
    pollingInterval: s
  }), h = { ...u, ...f }, p = {
    account: c,
    batch: t,
    cacheTime: n,
    ccipRead: r,
    chain: l,
    key: i,
    name: o,
    pollingInterval: s,
    request: d,
    transport: h,
    type: a,
    uid: lI()
  };
  function m(g) {
    return (v) => {
      const w = v(g);
      for (const C in p)
        delete w[C];
      const x = { ...g, ...w };
      return Object.assign(x, { extend: m(x) });
    };
  }
  return Object.assign(p, { extend: m(p) });
}
function cI({ key: e, name: t, request: n, retryCount: r = 3, retryDelay: i = 150, timeout: o, type: s }, a) {
  const l = lI();
  return {
    config: {
      key: e,
      name: t,
      request: n,
      retryCount: r,
      retryDelay: i,
      timeout: o,
      type: s
    },
    request: s$(n, { retryCount: r, retryDelay: i, uid: l }),
    value: a
  };
}
function _W(e, t = {}) {
  const { key: n = "custom", name: r = "Custom Provider", retryDelay: i } = t;
  return ({ retryCount: o }) => cI({
    key: n,
    name: r,
    request: e.request.bind(e),
    retryCount: t.retryCount ?? o,
    retryDelay: i,
    type: "custom"
  });
}
class IW extends be {
  constructor() {
    super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
      docsPath: "/docs/clients/intro",
      name: "UrlRequiredError"
    });
  }
}
function uI(e, t = {}) {
  const { batch: n, fetchOptions: r, key: i = "http", name: o = "HTTP JSON-RPC", onFetchRequest: s, onFetchResponse: a, retryDelay: l } = t;
  return ({ chain: c, retryCount: u, timeout: d }) => {
    const { batchSize: f = 1e3, wait: h = 0 } = typeof n == "object" ? n : {}, p = t.retryCount ?? u, m = d ?? t.timeout ?? 1e4, g = e || (c == null ? void 0 : c.rpcUrls.default.http[0]);
    if (!g)
      throw new IW();
    const v = d$(g, {
      fetchOptions: r,
      onRequest: s,
      onResponse: a,
      timeout: m
    });
    return cI({
      key: i,
      name: o,
      async request({ method: w, params: x }) {
        const C = { method: w, params: x }, { schedule: S } = I_({
          id: g,
          wait: h,
          shouldSplitBatch(T) {
            return T.length > f;
          },
          fn: (T) => v.request({
            body: T
          }),
          sort: (T, R) => T.id - R.id
        }), k = async (T) => n ? S(T) : [
          await v.request({
            body: T
          })
        ], [{ error: A, result: b }] = await k(C);
        if (A)
          throw new qT({
            body: C,
            error: A,
            url: g
          });
        return b;
      },
      retryCount: p,
      retryDelay: l,
      timeout: m,
      type: "http"
    }, {
      fetchOptions: r,
      url: g
    });
  };
}
function RW(e) {
  var d, f, h;
  const { scheme: t, statement: n, ...r } = ((d = e.match(PW)) == null ? void 0 : d.groups) ?? {}, { chainId: i, expirationTime: o, issuedAt: s, notBefore: a, requestId: l, ...c } = ((f = e.match(OW)) == null ? void 0 : f.groups) ?? {}, u = (h = e.split("Resources:")[1]) == null ? void 0 : h.split(`
- `).slice(1);
  return {
    ...r,
    ...c,
    ...i ? { chainId: Number(i) } : {},
    ...o ? { expirationTime: new Date(o) } : {},
    ...s ? { issuedAt: new Date(s) } : {},
    ...a ? { notBefore: new Date(a) } : {},
    ...l ? { requestId: l } : {},
    ...u ? { resources: u } : {},
    ...t ? { scheme: t } : {},
    ...n ? { statement: n } : {}
  };
}
const PW = /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\/\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\n)(?<address>0x[a-fA-F0-9]{40})\n\n(?:(?<statement>.*)\n\n)?/, OW = /(?:URI: (?<uri>.+))\n(?:Version: (?<version>.+))\n(?:Chain ID: (?<chainId>\d+))\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\n(?:Issued At: (?<issuedAt>.+))(?:\nExpiration Time: (?<expirationTime>.+))?(?:\nNot Before: (?<notBefore>.+))?(?:\nRequest ID: (?<requestId>.+))?/;
function BW(e) {
  const { address: t, domain: n, message: r, nonce: i, scheme: o, time: s = /* @__PURE__ */ new Date() } = e;
  if (n && r.domain !== n || i && r.nonce !== i || o && r.scheme !== o || r.expirationTime && s >= r.expirationTime || r.notBefore && s < r.notBefore)
    return !1;
  try {
    if (!r.address || t && !Pw(r.address, t))
      return !1;
  } catch {
    return !1;
  }
  return !0;
}
async function NW(e, t) {
  const { address: n, domain: r, message: i, nonce: o, scheme: s, signature: a, time: l = /* @__PURE__ */ new Date(), ...c } = t, u = RW(i);
  if (!u.address || !BW({
    address: n,
    domain: r,
    message: u,
    nonce: o,
    scheme: s,
    time: l
  }))
    return !1;
  const f = G_(i);
  return Vw(e, {
    address: u.address,
    hash: f,
    signature: a,
    ...c
  });
}
function DW(e) {
  return {
    call: (t) => Xp(e, t),
    createBlockFilter: () => Oq(e),
    createContractEventFilter: (t) => D_(e, t),
    createEventFilter: (t) => j_(e, t),
    createPendingTransactionFilter: () => M_(e),
    estimateContractGas: (t) => Nq(e, t),
    estimateGas: (t) => Hp(e, t),
    getBalance: (t) => QT(e, t),
    getBlobBaseFee: () => Dq(e),
    getBlock: (t) => Es(e, t),
    getBlockNumber: (t) => zd(e, t),
    getBlockTransactionCount: (t) => zq(e, t),
    getBytecode: (t) => $k(e, t),
    getChainId: () => bw(e),
    getCode: (t) => $k(e, t),
    getContractEvents: (t) => F_(e, t),
    getEip712Domain: (t) => Wq(e, t),
    getEnsAddress: (t) => vq(e, t),
    getEnsAvatar: (t) => B_(e, t),
    getEnsName: (t) => N_(e, t),
    getEnsResolver: (t) => Pq(e, t),
    getEnsText: (t) => O_(e, t),
    getFeeHistory: (t) => Kq(e, t),
    estimateFeesPerGas: (t) => Nz(e, t),
    getFilterChanges: (t) => ey(e, t),
    getFilterLogs: (t) => Yq(e, t),
    getGasPrice: () => Cw(e),
    getLogs: (t) => Nw(e, t),
    getProof: (t) => D$(e, t),
    estimateMaxPriorityFeePerGas: (t) => Bz(e, t),
    getStorageAt: (t) => Qq(e, t),
    getTransaction: (t) => Dw(e, t),
    getTransactionConfirmations: (t) => Jq(e, t),
    getTransactionCount: (t) => JT(e, t),
    getTransactionReceipt: (t) => bb(e, t),
    multicall: (t) => e$(e, t),
    prepareTransactionRequest: (t) => Kp(e, t),
    readContract: (t) => Oo(e, t),
    sendRawTransaction: (t) => a_(e, t),
    simulateContract: (t) => F$(e, t),
    verifyMessage: (t) => bW(e, t),
    verifySiweMessage: (t) => NW(e, t),
    verifyTypedData: (t) => wW(e, t),
    uninstallFilter: (t) => ty(e, t),
    waitForTransactionReceipt: (t) => j$(e, t),
    watchBlocks: (t) => n$(e, t),
    watchBlockNumber: (t) => U_(e, t),
    watchContractEvent: (t) => xW(e, t),
    watchEvent: (t) => r$(e, t),
    watchPendingTransactions: (t) => i$(e, t)
  };
}
async function dI(e, t = {}) {
  let n;
  if (t.connector) {
    const { connector: c } = t;
    if (e.state.status === "reconnecting" && !c.getAccounts && !c.getChainId)
      throw new TW({ connector: c });
    const [u, d] = await Promise.all([
      c.getAccounts(),
      c.getChainId()
    ]);
    n = {
      accounts: u,
      chainId: d,
      connector: c
    };
  } else
    n = e.state.connections.get(e.state.current);
  if (!n)
    throw new EW();
  const r = t.chainId ?? n.chainId, i = await n.connector.getChainId();
  if (i !== n.chainId)
    throw new AW({
      connectionChainId: n.chainId,
      connectorChainId: i
    });
  const o = n.connector;
  if (o.getClient)
    return o.getClient({ chainId: r });
  const s = ui(t.account ?? n.accounts[0]);
  if (s.address = Qn(s.address), t.account && !n.accounts.some((c) => c.toLowerCase() === s.address.toLowerCase()))
    throw new SW({
      address: s.address,
      connector: o
    });
  const a = e.chains.find((c) => c.id === r), l = await n.connector.getProvider({ chainId: r });
  return ry({
    account: s,
    chain: a,
    name: "Connector Client",
    transport: (c) => _W(l)({ ...c, retryCount: 0 })
  });
}
async function jW(e, t = {}) {
  var i, o;
  let n;
  if (t.connector)
    n = t.connector;
  else {
    const { connections: s, current: a } = e.state, l = s.get(a);
    n = l == null ? void 0 : l.connector;
  }
  const r = e.state.connections;
  n && (await n.disconnect(), n.emitter.off("change", e._internal.events.change), n.emitter.off("disconnect", e._internal.events.disconnect), n.emitter.on("connect", e._internal.events.connect), r.delete(n.uid)), e.setState((s) => {
    if (r.size === 0)
      return {
        ...s,
        connections: /* @__PURE__ */ new Map(),
        current: null,
        status: "disconnected"
      };
    const a = r.values().next().value;
    return {
      ...s,
      connections: new Map(r),
      current: a.connector.uid
    };
  });
  {
    const s = e.state.current;
    if (!s)
      return;
    const a = (i = e.state.connections.get(s)) == null ? void 0 : i.connector;
    if (!a)
      return;
    await ((o = e.storage) == null ? void 0 : o.setItem("recentConnectorId", a.id));
  }
}
function qw(e) {
  const t = e.state.current, n = e.state.connections.get(t), r = n == null ? void 0 : n.accounts, i = r == null ? void 0 : r[0], o = e.chains.find((a) => a.id === (n == null ? void 0 : n.chainId)), s = e.state.status;
  switch (s) {
    case "connected":
      return {
        address: i,
        addresses: r,
        chain: o,
        chainId: n == null ? void 0 : n.chainId,
        connector: n == null ? void 0 : n.connector,
        isConnected: !0,
        isConnecting: !1,
        isDisconnected: !1,
        isReconnecting: !1,
        status: s
      };
    case "reconnecting":
      return {
        address: i,
        addresses: r,
        chain: o,
        chainId: n == null ? void 0 : n.chainId,
        connector: n == null ? void 0 : n.connector,
        isConnected: !!i,
        isConnecting: !1,
        isDisconnected: !1,
        isReconnecting: !0,
        status: s
      };
    case "connecting":
      return {
        address: i,
        addresses: r,
        chain: o,
        chainId: n == null ? void 0 : n.chainId,
        connector: n == null ? void 0 : n.connector,
        isConnected: !1,
        isConnecting: !0,
        isDisconnected: !1,
        isReconnecting: !1,
        status: s
      };
    case "disconnected":
      return {
        address: void 0,
        addresses: void 0,
        chain: void 0,
        chainId: void 0,
        connector: void 0,
        isConnected: !1,
        isConnecting: !1,
        isDisconnected: !0,
        isReconnecting: !1,
        status: s
      };
  }
}
function tE(e) {
  return e.state.chainId;
}
function Ts(e, t) {
  if (e === t)
    return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    if (e.constructor !== t.constructor)
      return !1;
    let n, r;
    if (Array.isArray(e) && Array.isArray(t)) {
      if (n = e.length, n !== t.length)
        return !1;
      for (r = n; r-- !== 0; )
        if (!Ts(e[r], t[r]))
          return !1;
      return !0;
    }
    if (e.valueOf !== Object.prototype.valueOf)
      return e.valueOf() === t.valueOf();
    if (e.toString !== Object.prototype.toString)
      return e.toString() === t.toString();
    const i = Object.keys(e);
    if (n = i.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(t, i[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const o = i[r];
      if (o && !Ts(e[o], t[o]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
let ng = [];
function nE(e) {
  const t = e.chains;
  return Ts(ng, t) ? ng : (ng = t, t);
}
function MW(e, t = {}) {
  let n;
  try {
    n = e.getClient(t);
  } catch {
  }
  return n;
}
let Bf = [];
function Tb(e) {
  const t = [...e.state.connections.values()];
  return e.state.status === "reconnecting" || Ts(Bf, t) ? Bf : (Bf = t, t);
}
let rg = [];
function rE(e) {
  const t = e.connectors;
  return Ts(rg, t) ? rg : (rg = t, t);
}
function FW(e, t) {
  const { chainId: n, ...r } = t, i = e.getClient({ chainId: n });
  return td(i, B_, "getEnsAvatar")(r);
}
function LW(e, t) {
  const { chainId: n, ...r } = t, i = e.getClient({ chainId: n });
  return td(i, N_, "getEnsName")(r);
}
function _b(e, t = {}) {
  const n = MW(e, t);
  return n == null ? void 0 : n.extend(DW);
}
let ig = !1;
async function UW(e, t = {}) {
  var c, u;
  if (ig)
    return [];
  ig = !0, e.setState((d) => ({
    ...d,
    status: d.current ? "reconnecting" : "connecting"
  }));
  const n = [];
  if ((c = t.connectors) != null && c.length)
    for (const d of t.connectors) {
      let f;
      typeof d == "function" ? f = e._internal.connectors.setup(d) : f = d, n.push(f);
    }
  else
    n.push(...e.connectors);
  let r;
  try {
    r = await ((u = e.storage) == null ? void 0 : u.getItem("recentConnectorId"));
  } catch {
  }
  const i = {};
  for (const [, d] of e.state.connections)
    i[d.connector.id] = 1;
  r && (i[r] = 0);
  const o = Object.keys(i).length > 0 ? (
    // .toSorted()
    [...n].sort((d, f) => (i[d.id] ?? 10) - (i[f.id] ?? 10))
  ) : n;
  let s = !1;
  const a = [], l = [];
  for (const d of o) {
    const f = await d.getProvider().catch(() => {
    });
    if (!f || l.some((m) => m === f) || !await d.isAuthorized())
      continue;
    const p = await d.connect({ isReconnecting: !0 }).catch(() => null);
    p && (d.emitter.off("connect", e._internal.events.connect), d.emitter.on("change", e._internal.events.change), d.emitter.on("disconnect", e._internal.events.disconnect), e.setState((m) => {
      const g = new Map(s ? m.connections : /* @__PURE__ */ new Map()).set(d.uid, { accounts: p.accounts, chainId: p.chainId, connector: d });
      return {
        ...m,
        current: s ? m.current : d.uid,
        connections: g
      };
    }), a.push({
      accounts: p.accounts,
      chainId: p.chainId,
      connector: d
    }), l.push(f), s = !0);
  }
  return (e.state.status === "reconnecting" || e.state.status === "connecting") && (s ? e.setState((d) => ({ ...d, status: "connected" })) : e.setState((d) => ({
    ...d,
    connections: /* @__PURE__ */ new Map(),
    current: null,
    status: "disconnected"
  }))), ig = !1, a;
}
async function zW(e, t) {
  const { account: n, chainId: r, connector: i, gas: o, ...s } = t;
  let a;
  typeof n == "object" && (n == null ? void 0 : n.type) === "local" ? a = e.getClient({ chainId: r }) : a = await dI(e, {
    account: n ?? void 0,
    chainId: r,
    connector: i
  });
  const { connector: l } = qw(e), c = await (async () => {
    var f;
    if (!(!("data" in t) || !t.data) && !((f = i ?? l) != null && f.supportsSimulation) && o !== null)
      return o === void 0 ? td(a, Hp, "estimateGas")({
        ...s,
        account: n,
        chain: r ? { id: r } : null
      }) : o;
  })();
  return await td(a, Zz, "sendTransaction")({
    ...s,
    ...n ? { account: n } : {},
    gas: c,
    chain: r ? { id: r } : null
  });
}
async function VW(e, t) {
  const { account: n, connector: r, ...i } = t;
  let o;
  return typeof n == "object" && n.type === "local" ? o = e.getClient() : o = await dI(e, { account: n, connector: r }), td(o, M$, "signMessage")({
    ...i,
    ...n ? { account: n } : {}
  });
}
class is extends Lo {
  constructor() {
    super("Provider not found."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ProviderNotFoundError"
    });
  }
}
class qW extends Lo {
  constructor({ connector: t }) {
    super(`"${t.name}" does not support programmatic chain switching.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SwitchChainNotSupportedError"
    });
  }
}
async function fI(e, t) {
  var s;
  const { addEthereumChainParameter: n, chainId: r } = t, i = e.state.connections.get(((s = t.connector) == null ? void 0 : s.uid) ?? e.state.current);
  if (i) {
    const a = i.connector;
    if (!a.switchChain)
      throw new qW({ connector: a });
    return await a.switchChain({
      addEthereumChainParameter: n,
      chainId: r
    });
  }
  const o = e.chains.find((a) => a.id === r);
  if (!o)
    throw new Pa();
  return e.setState((a) => ({ ...a, chainId: r })), o;
}
function hI(e, t) {
  const { onChange: n } = t;
  return e.subscribe(() => qw(e), n, {
    equalityFn(r, i) {
      const { connector: o, ...s } = r, { connector: a, ...l } = i;
      return Ts(s, l) && // check connector separately
      (o == null ? void 0 : o.id) === (a == null ? void 0 : a.id) && (o == null ? void 0 : o.uid) === (a == null ? void 0 : a.uid);
    }
  });
}
function $W(e, t) {
  const { onChange: n } = t;
  return e.subscribe((r) => r.chainId, n);
}
function WW(e, t) {
  const { onChange: n } = t;
  return e.subscribe(() => Tb(e), n, {
    equalityFn: Ts
  });
}
function GW(e, t) {
  const { onChange: n } = t;
  return e._internal.connectors.subscribe((r, i) => {
    n(Object.values(r), i);
  });
}
function HW(e, t) {
  const { onChange: n } = t;
  return e.subscribe(() => _b(e), n, {
    equalityFn(r, i) {
      return (r == null ? void 0 : r.uid) === (i == null ? void 0 : i.uid);
    }
  });
}
function vbe(e) {
  return e;
}
const KW = /(rabby|trustwallet)/;
iy.type = "injected";
function iy(e = {}) {
  const { shimDisconnect: t = !0, unstable_shimAsyncInject: n } = e;
  function r() {
    const l = e.target;
    if (typeof l == "function") {
      const c = l();
      if (c)
        return c;
    }
    return typeof l == "object" ? l : typeof l == "string" ? {
      ...YW[l] ?? {
        id: l,
        name: `${l[0].toUpperCase()}${l.slice(1)}`,
        provider: `is${l[0].toUpperCase()}${l.slice(1)}`
      }
    } : {
      id: "injected",
      name: "Injected",
      provider(c) {
        return c == null ? void 0 : c.ethereum;
      }
    };
  }
  let i, o, s, a;
  return (l) => ({
    get icon() {
      return r().icon;
    },
    get id() {
      return r().id;
    },
    get name() {
      return r().name;
    },
    get supportsSimulation() {
      return KW.test(this.id.toLowerCase());
    },
    type: iy.type,
    async setup() {
      const c = await this.getProvider();
      c != null && c.on && e.target && (s || (s = this.onConnect.bind(this), c.on("connect", s)), i || (i = this.onAccountsChanged.bind(this), c.on("accountsChanged", i)));
    },
    async connect({ chainId: c, isReconnecting: u } = {}) {
      var h, p, m, g, v, w;
      const d = await this.getProvider();
      if (!d)
        throw new is();
      let f = [];
      if (u)
        f = await this.getAccounts().catch(() => []);
      else if (t)
        try {
          f = (g = (m = (p = (h = (await d.request({
            method: "wallet_requestPermissions",
            params: [{ eth_accounts: {} }]
          }))[0]) == null ? void 0 : h.caveats) == null ? void 0 : p[0]) == null ? void 0 : m.value) == null ? void 0 : g.map((C) => Qn(C)), f.length > 0 && (f = await this.getAccounts());
        } catch (x) {
          const C = x;
          if (C.code === $t.code)
            throw new $t(C);
          if (C.code === ws.code)
            throw C;
        }
      try {
        !(f != null && f.length) && !u && (f = (await d.request({
          method: "eth_requestAccounts"
        })).map((S) => Qn(S))), s && (d.removeListener("connect", s), s = void 0), i || (i = this.onAccountsChanged.bind(this), d.on("accountsChanged", i)), o || (o = this.onChainChanged.bind(this), d.on("chainChanged", o)), a || (a = this.onDisconnect.bind(this), d.on("disconnect", a));
        let x = await this.getChainId();
        if (c && x !== c) {
          const C = await this.switchChain({ chainId: c }).catch((S) => {
            if (S.code === $t.code)
              throw S;
            return { id: x };
          });
          x = (C == null ? void 0 : C.id) ?? x;
        }
        return t && await ((v = l.storage) == null ? void 0 : v.removeItem(`${this.id}.disconnected`)), e.target || await ((w = l.storage) == null ? void 0 : w.setItem("injected.connected", !0)), { accounts: f, chainId: x };
      } catch (x) {
        const C = x;
        throw C.code === $t.code ? new $t(C) : C.code === ws.code ? new ws(C) : C;
      }
    },
    async disconnect() {
      var u, d;
      const c = await this.getProvider();
      if (!c)
        throw new is();
      o && (c.removeListener("chainChanged", o), o = void 0), a && (c.removeListener("disconnect", a), a = void 0), s || (s = this.onConnect.bind(this), c.on("connect", s));
      try {
        await z_(() => (
          // TODO: Remove explicit type for viem@3
          c.request({
            // `'wallet_revokePermissions'` added in `viem@2.10.3`
            method: "wallet_revokePermissions",
            params: [{ eth_accounts: {} }]
          })
        ), { timeout: 100 });
      } catch {
      }
      t && await ((u = l.storage) == null ? void 0 : u.setItem(`${this.id}.disconnected`, !0)), e.target || await ((d = l.storage) == null ? void 0 : d.removeItem("injected.connected"));
    },
    async getAccounts() {
      const c = await this.getProvider();
      if (!c)
        throw new is();
      return (await c.request({ method: "eth_accounts" })).map((d) => Qn(d));
    },
    async getChainId() {
      const c = await this.getProvider();
      if (!c)
        throw new is();
      const u = await c.request({ method: "eth_chainId" });
      return Number(u);
    },
    async getProvider() {
      if (typeof window > "u")
        return;
      let c;
      const u = r();
      return typeof u.provider == "function" ? c = u.provider(window) : typeof u.provider == "string" ? c = vh(window, u.provider) : c = u.provider, c && !c.removeListener && ("off" in c && typeof c.off == "function" ? c.removeListener = c.off : c.removeListener = () => {
      }), c;
    },
    async isAuthorized() {
      var c, u;
      try {
        if (t && // If shim exists in storage, connector is disconnected
        await ((c = l.storage) == null ? void 0 : c.getItem(`${this.id}.disconnected`)) || !e.target && !await ((u = l.storage) == null ? void 0 : u.getItem("injected.connected")))
          return !1;
        if (!await this.getProvider()) {
          if (n !== void 0 && n !== !1) {
            const p = async () => (typeof window < "u" && window.removeEventListener("ethereum#initialized", p), !!await this.getProvider()), m = typeof n == "number" ? n : 1e3;
            if (await Promise.race([
              ...typeof window < "u" ? [
                new Promise((v) => window.addEventListener("ethereum#initialized", () => v(p()), { once: !0 }))
              ] : [],
              new Promise((v) => setTimeout(() => v(p()), m))
            ]))
              return !0;
          }
          throw new is();
        }
        return !!(await $h(() => this.getAccounts())).length;
      } catch {
        return !1;
      }
    },
    async switchChain({ addEthereumChainParameter: c, chainId: u }) {
      var h, p, m, g;
      const d = await this.getProvider();
      if (!d)
        throw new is();
      const f = l.chains.find((v) => v.id === u);
      if (!f)
        throw new oi(new Pa());
      try {
        return await Promise.all([
          d.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: Fe(u) }]
          }).then(async () => {
            await this.getChainId() === u && l.emitter.emit("change", { chainId: u });
          }),
          new Promise((v) => {
            const w = (x) => {
              "chainId" in x && x.chainId === u && (l.emitter.off("change", w), v());
            };
            l.emitter.on("change", w);
          })
        ]), f;
      } catch (v) {
        const w = v;
        if (w.code === 4902 || // Unwrapping for MetaMask Mobile
        // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719
        ((p = (h = w == null ? void 0 : w.data) == null ? void 0 : h.originalError) == null ? void 0 : p.code) === 4902)
          try {
            const { default: x, ...C } = f.blockExplorers ?? {};
            let S;
            c != null && c.blockExplorerUrls ? S = c.blockExplorerUrls : x && (S = [
              x.url,
              ...Object.values(C).map((T) => T.url)
            ]);
            let k;
            (m = c == null ? void 0 : c.rpcUrls) != null && m.length ? k = c.rpcUrls : k = [((g = f.rpcUrls.default) == null ? void 0 : g.http[0]) ?? ""];
            const A = {
              blockExplorerUrls: S,
              chainId: Fe(u),
              chainName: (c == null ? void 0 : c.chainName) ?? f.name,
              iconUrls: c == null ? void 0 : c.iconUrls,
              nativeCurrency: (c == null ? void 0 : c.nativeCurrency) ?? f.nativeCurrency,
              rpcUrls: k
            };
            if (await d.request({
              method: "wallet_addEthereumChain",
              params: [A]
            }), await this.getChainId() !== u)
              throw new $t(new Error("User rejected switch after adding network."));
            return f;
          } catch (x) {
            throw new $t(x);
          }
        throw w.code === $t.code ? new $t(w) : new oi(w);
      }
    },
    async onAccountsChanged(c) {
      var u;
      if (c.length === 0)
        this.onDisconnect();
      else if (l.emitter.listenerCount("connect")) {
        const d = (await this.getChainId()).toString();
        this.onConnect({ chainId: d }), t && await ((u = l.storage) == null ? void 0 : u.removeItem(`${this.id}.disconnected`));
      } else
        l.emitter.emit("change", {
          accounts: c.map((d) => Qn(d))
        });
    },
    onChainChanged(c) {
      const u = Number(c);
      l.emitter.emit("change", { chainId: u });
    },
    async onConnect(c) {
      const u = await this.getAccounts();
      if (u.length === 0)
        return;
      const d = Number(c.chainId);
      l.emitter.emit("connect", { accounts: u, chainId: d });
      const f = await this.getProvider();
      f && (s && (f.removeListener("connect", s), s = void 0), i || (i = this.onAccountsChanged.bind(this), f.on("accountsChanged", i)), o || (o = this.onChainChanged.bind(this), f.on("chainChanged", o)), a || (a = this.onDisconnect.bind(this), f.on("disconnect", a)));
    },
    async onDisconnect(c) {
      const u = await this.getProvider();
      c && c.code === 1013 && u && (await this.getAccounts()).length || (l.emitter.emit("disconnect"), u && (o && (u.removeListener("chainChanged", o), o = void 0), a && (u.removeListener("disconnect", a), a = void 0), s || (s = this.onConnect.bind(this), u.on("connect", s))));
    }
  });
}
const YW = {
  coinbaseWallet: {
    id: "coinbaseWallet",
    name: "Coinbase Wallet",
    provider(e) {
      return e != null && e.coinbaseWalletExtension ? e.coinbaseWalletExtension : vh(e, "isCoinbaseWallet");
    }
  },
  metaMask: {
    id: "metaMask",
    name: "MetaMask",
    provider(e) {
      return vh(e, (t) => {
        if (!t.isMetaMask || t.isBraveWallet && !t._events && !t._state)
          return !1;
        const n = [
          "isApexWallet",
          "isAvalanche",
          "isBitKeep",
          "isBlockWallet",
          "isKuCoinWallet",
          "isMathWallet",
          "isOkxWallet",
          "isOKExWallet",
          "isOneInchIOSWallet",
          "isOneInchAndroidWallet",
          "isOpera",
          "isPortal",
          "isRabby",
          "isTokenPocket",
          "isTokenary",
          "isUniswapWallet",
          "isZerion"
        ];
        for (const r of n)
          if (t[r])
            return !1;
        return !0;
      });
    }
  },
  phantom: {
    id: "phantom",
    name: "Phantom",
    provider(e) {
      var t, n;
      return (t = e == null ? void 0 : e.phantom) != null && t.ethereum ? (n = e.phantom) == null ? void 0 : n.ethereum : vh(e, "isPhantom");
    }
  }
};
function vh(e, t) {
  function n(i) {
    return typeof t == "function" ? t(i) : typeof t == "string" ? i[t] : !0;
  }
  const r = e.ethereum;
  if (r != null && r.providers)
    return r.providers.find((i) => n(i));
  if (r && n(r))
    return r;
}
function QW(e) {
  if (typeof window > "u")
    return;
  const t = (n) => e(n.detail);
  return window.addEventListener("eip6963:announceProvider", t), window.dispatchEvent(new CustomEvent("eip6963:requestProvider")), () => window.removeEventListener("eip6963:announceProvider", t);
}
function JW() {
  const e = /* @__PURE__ */ new Set();
  let t = [];
  const n = () => QW((i) => {
    t.some(({ info: o }) => o.uuid === i.info.uuid) || (t = [...t, i], e.forEach((o) => o(t, { added: [i] })));
  });
  let r = n();
  return {
    _listeners() {
      return e;
    },
    clear() {
      e.forEach((i) => i([], { removed: [...t] })), t = [];
    },
    destroy() {
      this.clear(), e.clear(), r == null || r();
    },
    findProvider({ rdns: i }) {
      return t.find((o) => o.info.rdns === i);
    },
    getProviders() {
      return t;
    },
    reset() {
      this.clear(), r == null || r(), r = n();
    },
    subscribe(i, { emitImmediately: o } = {}) {
      return e.add(i), o && i(t, { added: t }), () => e.delete(i);
    }
  };
}
const XW = (e) => (t, n, r) => {
  const i = r.subscribe;
  return r.subscribe = (s, a, l) => {
    let c = s;
    if (a) {
      const u = (l == null ? void 0 : l.equalityFn) || Object.is;
      let d = s(r.getState());
      c = (f) => {
        const h = s(f);
        if (!u(d, h)) {
          const p = d;
          a(d = h, p);
        }
      }, l != null && l.fireImmediately && a(d, d);
    }
    return i(c);
  }, e(t, n, r);
}, ZW = XW;
function eG(e, t) {
  let n;
  try {
    n = e();
  } catch {
    return;
  }
  return {
    getItem: (i) => {
      var o;
      const s = (l) => l === null ? null : JSON.parse(l, void 0), a = (o = n.getItem(i)) != null ? o : null;
      return a instanceof Promise ? a.then(s) : s(a);
    },
    setItem: (i, o) => n.setItem(
      i,
      JSON.stringify(o, void 0)
    ),
    removeItem: (i) => n.removeItem(i)
  };
}
const Ib = (e) => (t) => {
  try {
    const n = e(t);
    return n instanceof Promise ? n : {
      then(r) {
        return Ib(r)(n);
      },
      catch(r) {
        return this;
      }
    };
  } catch (n) {
    return {
      then(r) {
        return this;
      },
      catch(r) {
        return Ib(r)(n);
      }
    };
  }
}, tG = (e, t) => (n, r, i) => {
  let o = {
    storage: eG(() => localStorage),
    partialize: (m) => m,
    version: 0,
    merge: (m, g) => ({
      ...g,
      ...m
    }),
    ...t
  }, s = !1;
  const a = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set();
  let c = o.storage;
  if (!c)
    return e(
      (...m) => {
        n(...m);
      },
      r,
      i
    );
  const u = () => {
    const m = o.partialize({ ...r() });
    return c.setItem(o.name, {
      state: m,
      version: o.version
    });
  }, d = i.setState;
  i.setState = (m, g) => {
    d(m, g), u();
  };
  const f = e(
    (...m) => {
      n(...m), u();
    },
    r,
    i
  );
  i.getInitialState = () => f;
  let h;
  const p = () => {
    var m, g;
    if (!c) return;
    s = !1, a.forEach((w) => {
      var x;
      return w((x = r()) != null ? x : f);
    });
    const v = ((g = o.onRehydrateStorage) == null ? void 0 : g.call(o, (m = r()) != null ? m : f)) || void 0;
    return Ib(c.getItem.bind(c))(o.name).then((w) => {
      if (w)
        if (typeof w.version == "number" && w.version !== o.version) {
          if (o.migrate)
            return [
              !0,
              o.migrate(
                w.state,
                w.version
              )
            ];
        } else
          return [!1, w.state];
      return [!1, void 0];
    }).then((w) => {
      var x;
      const [C, S] = w;
      if (h = o.merge(
        S,
        (x = r()) != null ? x : f
      ), n(h, !0), C)
        return u();
    }).then(() => {
      v == null || v(h, void 0), h = r(), s = !0, l.forEach((w) => w(h));
    }).catch((w) => {
      v == null || v(void 0, w);
    });
  };
  return i.persist = {
    setOptions: (m) => {
      o = {
        ...o,
        ...m
      }, m.storage && (c = m.storage);
    },
    clearStorage: () => {
      c == null || c.removeItem(o.name);
    },
    getOptions: () => o,
    rehydrate: () => p(),
    hasHydrated: () => s,
    onHydrate: (m) => (a.add(m), () => {
      a.delete(m);
    }),
    onFinishHydration: (m) => (l.add(m), () => {
      l.delete(m);
    })
  }, o.skipHydration || p(), h || f;
}, nG = tG, iE = (e) => {
  let t;
  const n = /* @__PURE__ */ new Set(), r = (c, u) => {
    const d = typeof c == "function" ? c(t) : c;
    if (!Object.is(d, t)) {
      const f = t;
      t = u ?? (typeof d != "object" || d === null) ? d : Object.assign({}, t, d), n.forEach((h) => h(t, f));
    }
  }, i = () => t, a = { setState: r, getState: i, getInitialState: () => l, subscribe: (c) => (n.add(c), () => n.delete(c)) }, l = t = e(r, i, a);
  return a;
}, og = (e) => e ? iE(e) : iE;
var pI = { exports: {} };
(function(e) {
  var t = Object.prototype.hasOwnProperty, n = "~";
  function r() {
  }
  Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (n = !1));
  function i(l, c, u) {
    this.fn = l, this.context = c, this.once = u || !1;
  }
  function o(l, c, u, d, f) {
    if (typeof u != "function")
      throw new TypeError("The listener must be a function");
    var h = new i(u, d || l, f), p = n ? n + c : c;
    return l._events[p] ? l._events[p].fn ? l._events[p] = [l._events[p], h] : l._events[p].push(h) : (l._events[p] = h, l._eventsCount++), l;
  }
  function s(l, c) {
    --l._eventsCount === 0 ? l._events = new r() : delete l._events[c];
  }
  function a() {
    this._events = new r(), this._eventsCount = 0;
  }
  a.prototype.eventNames = function() {
    var c = [], u, d;
    if (this._eventsCount === 0) return c;
    for (d in u = this._events)
      t.call(u, d) && c.push(n ? d.slice(1) : d);
    return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(u)) : c;
  }, a.prototype.listeners = function(c) {
    var u = n ? n + c : c, d = this._events[u];
    if (!d) return [];
    if (d.fn) return [d.fn];
    for (var f = 0, h = d.length, p = new Array(h); f < h; f++)
      p[f] = d[f].fn;
    return p;
  }, a.prototype.listenerCount = function(c) {
    var u = n ? n + c : c, d = this._events[u];
    return d ? d.fn ? 1 : d.length : 0;
  }, a.prototype.emit = function(c, u, d, f, h, p) {
    var m = n ? n + c : c;
    if (!this._events[m]) return !1;
    var g = this._events[m], v = arguments.length, w, x;
    if (g.fn) {
      switch (g.once && this.removeListener(c, g.fn, void 0, !0), v) {
        case 1:
          return g.fn.call(g.context), !0;
        case 2:
          return g.fn.call(g.context, u), !0;
        case 3:
          return g.fn.call(g.context, u, d), !0;
        case 4:
          return g.fn.call(g.context, u, d, f), !0;
        case 5:
          return g.fn.call(g.context, u, d, f, h), !0;
        case 6:
          return g.fn.call(g.context, u, d, f, h, p), !0;
      }
      for (x = 1, w = new Array(v - 1); x < v; x++)
        w[x - 1] = arguments[x];
      g.fn.apply(g.context, w);
    } else {
      var C = g.length, S;
      for (x = 0; x < C; x++)
        switch (g[x].once && this.removeListener(c, g[x].fn, void 0, !0), v) {
          case 1:
            g[x].fn.call(g[x].context);
            break;
          case 2:
            g[x].fn.call(g[x].context, u);
            break;
          case 3:
            g[x].fn.call(g[x].context, u, d);
            break;
          case 4:
            g[x].fn.call(g[x].context, u, d, f);
            break;
          default:
            if (!w) for (S = 1, w = new Array(v - 1); S < v; S++)
              w[S - 1] = arguments[S];
            g[x].fn.apply(g[x].context, w);
        }
    }
    return !0;
  }, a.prototype.on = function(c, u, d) {
    return o(this, c, u, d, !1);
  }, a.prototype.once = function(c, u, d) {
    return o(this, c, u, d, !0);
  }, a.prototype.removeListener = function(c, u, d, f) {
    var h = n ? n + c : c;
    if (!this._events[h]) return this;
    if (!u)
      return s(this, h), this;
    var p = this._events[h];
    if (p.fn)
      p.fn === u && (!f || p.once) && (!d || p.context === d) && s(this, h);
    else {
      for (var m = 0, g = [], v = p.length; m < v; m++)
        (p[m].fn !== u || f && !p[m].once || d && p[m].context !== d) && g.push(p[m]);
      g.length ? this._events[h] = g.length === 1 ? g[0] : g : s(this, h);
    }
    return this;
  }, a.prototype.removeAllListeners = function(c) {
    var u;
    return c ? (u = n ? n + c : c, this._events[u] && s(this, u)) : (this._events = new r(), this._eventsCount = 0), this;
  }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = n, a.EventEmitter = a, e.exports = a;
})(pI);
var rG = pI.exports;
const iG = /* @__PURE__ */ F0(rG);
class oG {
  constructor(t) {
    Object.defineProperty(this, "uid", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "_emitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new iG()
    });
  }
  on(t, n) {
    this._emitter.on(t, n);
  }
  once(t, n) {
    this._emitter.once(t, n);
  }
  off(t, n) {
    this._emitter.off(t, n);
  }
  emit(t, ...n) {
    const r = n[0];
    this._emitter.emit(t, { uid: this.uid, ...r });
  }
  listenerCount(t) {
    return this._emitter.listenerCount(t);
  }
}
function sG(e) {
  return new oG(e);
}
function aG(e, t) {
  return JSON.parse(e, (n, r) => {
    let i = r;
    return (i == null ? void 0 : i.__type) === "bigint" && (i = BigInt(i.value)), (i == null ? void 0 : i.__type) === "Map" && (i = new Map(i.value)), (t == null ? void 0 : t(n, i)) ?? i;
  });
}
function oE(e, t) {
  return e.slice(0, t).join(".") || ".";
}
function sE(e, t) {
  const { length: n } = e;
  for (let r = 0; r < n; ++r)
    if (e[r] === t)
      return r + 1;
  return 0;
}
function lG(e, t) {
  const n = typeof e == "function", r = typeof t == "function", i = [], o = [];
  return function(a, l) {
    if (typeof l == "object")
      if (i.length) {
        const c = sE(i, this);
        c === 0 ? i[i.length] = this : (i.splice(c), o.splice(c)), o[o.length] = a;
        const u = sE(i, l);
        if (u !== 0)
          return r ? t.call(this, a, l, oE(o, u)) : `[ref=${oE(o, u)}]`;
      } else
        i[0] = l, o[0] = a;
    return n ? e.call(this, a, l) : l;
  };
}
function cG(e, t, n, r) {
  return JSON.stringify(e, lG((i, o) => {
    let s = o;
    return typeof s == "bigint" && (s = { __type: "bigint", value: o.toString() }), s instanceof Map && (s = { __type: "Map", value: Array.from(o.entries()) }), (t == null ? void 0 : t(i, s)) ?? s;
  }, r), n ?? void 0);
}
function uG(e) {
  const { deserialize: t = aG, key: n = "wagmi", serialize: r = cG, storage: i = yI } = e;
  function o(s) {
    return s instanceof Promise ? s.then((a) => a).catch(() => null) : s;
  }
  return {
    ...i,
    key: n,
    async getItem(s, a) {
      const l = i.getItem(`${n}.${s}`), c = await o(l);
      return c ? t(c) ?? null : a ?? null;
    },
    async setItem(s, a) {
      const l = `${n}.${s}`;
      a === null ? await o(i.removeItem(l)) : await o(i.setItem(l, r(a)));
    },
    async removeItem(s) {
      await o(i.removeItem(`${n}.${s}`));
    }
  };
}
const yI = {
  getItem: () => null,
  setItem: () => {
  },
  removeItem: () => {
  }
}, Rb = 256;
let Nf = Rb, Df;
function dG(e = 11) {
  if (!Df || Nf + e > Rb * 2) {
    Df = "", Nf = 0;
    for (let t = 0; t < Rb; t++)
      Df += (256 + Math.random() * 256 | 0).toString(16).substring(1);
  }
  return Df.substring(Nf, Nf++ + e);
}
function mI(e) {
  const { multiInjectedProviderDiscovery: t = !0, storage: n = uG({
    storage: typeof window < "u" && window.localStorage ? window.localStorage : yI
  }), syncConnectedChain: r = !0, ssr: i = !1, ...o } = e, s = typeof window < "u" && t ? JW() : void 0, a = og(() => o.chains), l = og(() => {
    const S = [], k = /* @__PURE__ */ new Set();
    for (const A of o.connectors ?? []) {
      const b = c(A);
      S.push(b), !i && b.rdns && k.add(b.rdns);
    }
    if (!i && s) {
      const A = s.getProviders();
      for (const b of A)
        k.has(b.info.rdns) || S.push(c(u(b)));
    }
    return S;
  });
  function c(S) {
    var b;
    const k = sG(dG()), A = {
      ...S({
        emitter: k,
        chains: a.getState(),
        storage: n,
        transports: o.transports
      }),
      emitter: k,
      uid: k.uid
    };
    return k.on("connect", x), (b = A.setup) == null || b.call(A), A;
  }
  function u(S) {
    const { info: k } = S, A = S.provider;
    return iy({ target: { ...k, id: k.rdns, provider: A } });
  }
  const d = /* @__PURE__ */ new Map();
  function f(S = {}) {
    const k = S.chainId ?? g.getState().chainId, A = a.getState().find((T) => T.id === k);
    if (S.chainId && !A)
      throw new Pa();
    {
      const T = d.get(g.getState().chainId);
      if (T && !A)
        return T;
      if (!A)
        throw new Pa();
    }
    {
      const T = d.get(k);
      if (T)
        return T;
    }
    let b;
    if (o.client)
      b = o.client({ chain: A });
    else {
      const T = A.id, R = a.getState().map((L) => L.id), B = {}, O = Object.entries(o);
      for (const [L, V] of O)
        if (!(L === "chains" || L === "client" || L === "connectors" || L === "transports"))
          if (typeof V == "object")
            if (T in V)
              B[L] = V[T];
            else {
              if (R.some((M) => M in V))
                continue;
              B[L] = V;
            }
          else
            B[L] = V;
      b = ry({
        ...B,
        chain: A,
        batch: B.batch ?? { multicall: !0 },
        transport: (L) => o.transports[T]({ ...L, connectors: l })
      });
    }
    return d.set(k, b), b;
  }
  function h() {
    return {
      chainId: a.getState()[0].id,
      connections: /* @__PURE__ */ new Map(),
      current: null,
      status: "disconnected"
    };
  }
  let p;
  const m = "0.0.0-canary-";
  gh.startsWith(m) ? p = Number.parseInt(gh.replace(m, "")) : p = Number.parseInt(gh.split(".")[0] ?? "0");
  const g = og(ZW(
    // only use persist middleware if storage exists
    n ? nG(h, {
      migrate(S, k) {
        if (k === p)
          return S;
        const A = h(), b = v(S, A.chainId);
        return { ...A, chainId: b };
      },
      name: "store",
      partialize(S) {
        return {
          connections: {
            __type: "Map",
            value: Array.from(S.connections.entries()).map(([k, A]) => {
              const { id: b, name: T, type: R, uid: B } = A.connector;
              return [k, { ...A, connector: { id: b, name: T, type: R, uid: B } }];
            })
          },
          chainId: S.chainId,
          current: S.current
        };
      },
      merge(S, k) {
        typeof S == "object" && S && "status" in S && delete S.status;
        const A = v(S, k.chainId);
        return {
          ...k,
          ...S,
          chainId: A
        };
      },
      skipHydration: i,
      storage: n,
      version: p
    }) : h
  ));
  g.setState(h());
  function v(S, k) {
    return S && typeof S == "object" && "chainId" in S && typeof S.chainId == "number" && a.getState().some((A) => A.id === S.chainId) ? S.chainId : k;
  }
  r && g.subscribe(({ connections: S, current: k }) => {
    var A;
    return k ? (A = S.get(k)) == null ? void 0 : A.chainId : void 0;
  }, (S) => {
    if (a.getState().some((A) => A.id === S))
      return g.setState((A) => ({
        ...A,
        chainId: S ?? A.chainId
      }));
  }), s == null || s.subscribe((S) => {
    const k = /* @__PURE__ */ new Set(), A = /* @__PURE__ */ new Set();
    for (const T of l.getState())
      k.add(T.id), T.rdns && A.add(T.rdns);
    const b = [];
    for (const T of S) {
      if (A.has(T.info.rdns))
        continue;
      const R = c(u(T));
      k.has(R.id) || b.push(R);
    }
    n && !g.persist.hasHydrated() || l.setState((T) => [...T, ...b], !0);
  });
  function w(S) {
    g.setState((k) => {
      const A = k.connections.get(S.uid);
      return A ? {
        ...k,
        connections: new Map(k.connections).set(S.uid, {
          accounts: S.accounts ?? A.accounts,
          chainId: S.chainId ?? A.chainId,
          connector: A.connector
        })
      } : k;
    });
  }
  function x(S) {
    g.getState().status === "connecting" || g.getState().status === "reconnecting" || g.setState((k) => {
      const A = l.getState().find((b) => b.uid === S.uid);
      return A ? (A.emitter.listenerCount("connect") && A.emitter.off("connect", w), A.emitter.listenerCount("change") || A.emitter.on("change", w), A.emitter.listenerCount("disconnect") || A.emitter.on("disconnect", C), {
        ...k,
        connections: new Map(k.connections).set(S.uid, {
          accounts: S.accounts,
          chainId: S.chainId,
          connector: A
        }),
        current: S.uid,
        status: "connected"
      }) : k;
    });
  }
  function C(S) {
    g.setState((k) => {
      const A = k.connections.get(S.uid);
      if (A) {
        const T = A.connector;
        T.emitter.listenerCount("change") && A.connector.emitter.off("change", w), T.emitter.listenerCount("disconnect") && A.connector.emitter.off("disconnect", C), T.emitter.listenerCount("connect") || A.connector.emitter.on("connect", x);
      }
      if (k.connections.delete(S.uid), k.connections.size === 0)
        return {
          ...k,
          connections: /* @__PURE__ */ new Map(),
          current: null,
          status: "disconnected"
        };
      const b = k.connections.values().next().value;
      return {
        ...k,
        connections: new Map(k.connections),
        current: b.connector.uid
      };
    });
  }
  return {
    get chains() {
      return a.getState();
    },
    get connectors() {
      return l.getState();
    },
    storage: n,
    getClient: f,
    get state() {
      return g.getState();
    },
    setState(S) {
      let k;
      typeof S == "function" ? k = S(g.getState()) : k = S;
      const A = h();
      typeof k != "object" && (k = A), Object.keys(A).some((T) => !(T in k)) && (k = A), g.setState(k, !0);
    },
    subscribe(S, k, A) {
      return g.subscribe(S, k, A ? {
        ...A,
        fireImmediately: A.emitImmediately
        // Workaround cast since Zustand does not support `'exactOptionalPropertyTypes'`
      } : void 0);
    },
    _internal: {
      mipd: s,
      store: g,
      ssr: !!i,
      syncConnectedChain: r,
      transports: o.transports,
      chains: {
        setState(S) {
          const k = typeof S == "function" ? S(a.getState()) : S;
          if (k.length !== 0)
            return a.setState(k, !0);
        },
        subscribe(S) {
          return a.subscribe(S);
        }
      },
      connectors: {
        providerDetailToConnector: u,
        setup: c,
        setState(S) {
          return l.setState(typeof S == "function" ? S(l.getState()) : S, !0);
        },
        subscribe(S) {
          return l.subscribe(S);
        }
      },
      events: { change: w, connect: x, disconnect: C }
    }
  };
}
function fG(e) {
  var o, s, a;
  const { chain: t } = e, n = t.rpcUrls.default.http[0];
  if (!e.transports)
    return [n];
  const r = (s = (o = e.transports) == null ? void 0 : o[t.id]) == null ? void 0 : s.call(o, { chain: t });
  return (((a = r == null ? void 0 : r.value) == null ? void 0 : a.transports) || [r]).map(({ value: l }) => (l == null ? void 0 : l.url) || n);
}
function hG(e) {
  if (typeof e == "string")
    return Number.parseInt(e, e.trim().substring(0, 2) === "0x" ? 16 : 10);
  if (typeof e == "bigint")
    return Number(e);
  if (typeof e == "number")
    return e;
  throw new Error(`Cannot normalize chainId "${e}" of type "${typeof e}"`);
}
const gI = Ge(void 0), pG = "2.12.25", yG = () => `wagmi@${pG}`;
class mG extends Lo {
  constructor() {
    super(...arguments), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "WagmiError"
    });
  }
  get docsBaseUrl() {
    return "https://wagmi.sh/react";
  }
  get version() {
    return yG();
  }
}
class gG extends mG {
  constructor() {
    super("`useConfig` must be used within `WagmiProvider`.", {
      docsPath: "/api/WagmiProvider"
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "WagmiProviderNotFoundError"
    });
  }
}
function Dn(e = {}) {
  const t = e.config ?? we(gI);
  if (!t)
    throw new gG();
  return t;
}
function vG(e, t) {
  const { onChange: n } = t;
  return e._internal.chains.subscribe((r, i) => {
    n(r, i);
  });
}
var Pb = { exports: {} }, sg = {}, jf = { exports: {} }, ag = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aE;
function bG() {
  if (aE) return ag;
  aE = 1;
  var e = I;
  function t(d, f) {
    return d === f && (d !== 0 || 1 / d === 1 / f) || d !== d && f !== f;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, i = e.useEffect, o = e.useLayoutEffect, s = e.useDebugValue;
  function a(d, f) {
    var h = f(), p = r({ inst: { value: h, getSnapshot: f } }), m = p[0].inst, g = p[1];
    return o(function() {
      m.value = h, m.getSnapshot = f, l(m) && g({ inst: m });
    }, [d, h, f]), i(function() {
      return l(m) && g({ inst: m }), d(function() {
        l(m) && g({ inst: m });
      });
    }, [d]), s(h), h;
  }
  function l(d) {
    var f = d.getSnapshot;
    d = d.value;
    try {
      var h = f();
      return !n(d, h);
    } catch {
      return !0;
    }
  }
  function c(d, f) {
    return f();
  }
  var u = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? c : a;
  return ag.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : u, ag;
}
var lg = {}, lE;
function wG() {
  return lE || (lE = 1, ke.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = I, t = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function n(x) {
      {
        for (var C = arguments.length, S = new Array(C > 1 ? C - 1 : 0), k = 1; k < C; k++)
          S[k - 1] = arguments[k];
        r("error", x, S);
      }
    }
    function r(x, C, S) {
      {
        var k = t.ReactDebugCurrentFrame, A = k.getStackAddendum();
        A !== "" && (C += "%s", S = S.concat([A]));
        var b = S.map(function(T) {
          return String(T);
        });
        b.unshift("Warning: " + C), Function.prototype.apply.call(console[x], console, b);
      }
    }
    function i(x, C) {
      return x === C && (x !== 0 || 1 / x === 1 / C) || x !== x && C !== C;
    }
    var o = typeof Object.is == "function" ? Object.is : i, s = e.useState, a = e.useEffect, l = e.useLayoutEffect, c = e.useDebugValue, u = !1, d = !1;
    function f(x, C, S) {
      u || e.startTransition !== void 0 && (u = !0, n("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var k = C();
      if (!d) {
        var A = C();
        o(k, A) || (n("The result of getSnapshot should be cached to avoid an infinite loop"), d = !0);
      }
      var b = s({
        inst: {
          value: k,
          getSnapshot: C
        }
      }), T = b[0].inst, R = b[1];
      return l(function() {
        T.value = k, T.getSnapshot = C, h(T) && R({
          inst: T
        });
      }, [x, k, C]), a(function() {
        h(T) && R({
          inst: T
        });
        var B = function() {
          h(T) && R({
            inst: T
          });
        };
        return x(B);
      }, [x]), c(k), k;
    }
    function h(x) {
      var C = x.getSnapshot, S = x.value;
      try {
        var k = C();
        return !o(S, k);
      } catch {
        return !0;
      }
    }
    function p(x, C, S) {
      return C();
    }
    var m = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", g = !m, v = g ? p : f, w = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : v;
    lg.useSyncExternalStore = w, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), lg;
}
var cE;
function vI() {
  return cE || (cE = 1, ke.env.NODE_ENV === "production" ? jf.exports = bG() : jf.exports = wG()), jf.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var uE;
function xG() {
  if (uE) return sg;
  uE = 1;
  var e = I, t = vI();
  function n(c, u) {
    return c === u && (c !== 0 || 1 / c === 1 / u) || c !== c && u !== u;
  }
  var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, o = e.useRef, s = e.useEffect, a = e.useMemo, l = e.useDebugValue;
  return sg.useSyncExternalStoreWithSelector = function(c, u, d, f, h) {
    var p = o(null);
    if (p.current === null) {
      var m = { hasValue: !1, value: null };
      p.current = m;
    } else m = p.current;
    p = a(function() {
      function v(k) {
        if (!w) {
          if (w = !0, x = k, k = f(k), h !== void 0 && m.hasValue) {
            var A = m.value;
            if (h(A, k)) return C = A;
          }
          return C = k;
        }
        if (A = C, r(x, k)) return A;
        var b = f(k);
        return h !== void 0 && h(A, b) ? A : (x = k, C = b);
      }
      var w = !1, x, C, S = d === void 0 ? null : d;
      return [function() {
        return v(u());
      }, S === null ? void 0 : function() {
        return v(S());
      }];
    }, [u, d, f, h]);
    var g = i(c, p[0], p[1]);
    return s(function() {
      m.hasValue = !0, m.value = g;
    }, [g]), l(g), g;
  }, sg;
}
var cg = {}, dE;
function CG() {
  return dE || (dE = 1, ke.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = I, t = vI();
    function n(u, d) {
      return u === d && (u !== 0 || 1 / u === 1 / d) || u !== u && d !== d;
    }
    var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, o = e.useRef, s = e.useEffect, a = e.useMemo, l = e.useDebugValue;
    function c(u, d, f, h, p) {
      var m = o(null), g;
      m.current === null ? (g = {
        hasValue: !1,
        value: null
      }, m.current = g) : g = m.current;
      var v = a(function() {
        var S = !1, k, A, b = function(O) {
          if (!S) {
            S = !0, k = O;
            var L = h(O);
            if (p !== void 0 && g.hasValue) {
              var V = g.value;
              if (p(V, L))
                return A = V, V;
            }
            return A = L, L;
          }
          var N = k, M = A;
          if (r(N, O))
            return M;
          var U = h(O);
          return p !== void 0 && p(M, U) ? M : (k = O, A = U, U);
        }, T = f === void 0 ? null : f, R = function() {
          return b(d());
        }, B = T === null ? void 0 : function() {
          return b(T());
        };
        return [R, B];
      }, [d, f, h, p]), w = v[0], x = v[1], C = i(u, w, x);
      return s(function() {
        g.hasValue = !0, g.value = C;
      }, [C]), l(C), C;
    }
    cg.useSyncExternalStoreWithSelector = c, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), cg;
}
ke.env.NODE_ENV === "production" ? Pb.exports = xG() : Pb.exports = CG();
var bI = Pb.exports;
const ug = (e) => typeof e == "object" && !Array.isArray(e);
function kG(e, t, n = t, r = Ts) {
  const i = It([]), o = bI.useSyncExternalStoreWithSelector(e, t, n, (s) => s, (s, a) => {
    if (ug(s) && ug(a) && i.current.length) {
      for (const l of i.current)
        if (!r(s[l], a[l]))
          return !1;
      return !0;
    }
    return r(s, a);
  });
  return J(() => {
    if (ug(o)) {
      const s = { ...o };
      let a = {};
      for (const [l, c] of Object.entries(s))
        a = {
          ...a,
          [l]: {
            configurable: !1,
            enumerable: !0,
            get: () => (i.current.includes(l) || i.current.push(l), c)
          }
        };
      return Object.defineProperties(s, a), s;
    }
    return o;
  }, [o]);
}
function ur(e = {}) {
  const t = Dn(e);
  return kG((n) => hI(t, { onChange: n }), () => qw(t));
}
function wI(e = {}) {
  const { onConnect: t, onDisconnect: n } = e, r = Dn(e);
  Te(() => hI(r, {
    onChange(i, o) {
      if ((o.status === "reconnecting" || o.status === "connecting" && o.address === void 0) && i.status === "connected") {
        const { address: s, addresses: a, chain: l, chainId: c, connector: u } = i, d = o.status === "reconnecting" || // if `previousAccount.status` is `undefined`, the connector connected immediately.
        o.status === void 0;
        t == null || t({
          address: s,
          addresses: a,
          chain: l,
          chainId: c,
          connector: u,
          isReconnected: d
        });
      } else o.status === "connected" && i.status === "disconnected" && (n == null || n());
    }
  }), [r, t, n]);
}
function EG(e) {
  return JSON.stringify(e, (t, n) => SG(n) ? Object.keys(n).sort().reduce((r, i) => (r[i] = n[i], r), {}) : typeof n == "bigint" ? n.toString() : n);
}
function SG(e) {
  if (!fE(e))
    return !1;
  const t = e.constructor;
  if (typeof t > "u")
    return !0;
  const n = t.prototype;
  return !(!fE(n) || !n.hasOwnProperty("isPrototypeOf"));
}
function fE(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function xI(e) {
  const {
    // import('@tanstack/query-core').QueryOptions
    _defaulted: t,
    behavior: n,
    gcTime: r,
    initialData: i,
    initialDataUpdatedAt: o,
    maxPages: s,
    meta: a,
    networkMode: l,
    queryFn: c,
    queryHash: u,
    queryKey: d,
    queryKeyHashFn: f,
    retry: h,
    retryDelay: p,
    structuralSharing: m,
    // import('@tanstack/query-core').InfiniteQueryObserverOptions
    getPreviousPageParam: g,
    getNextPageParam: v,
    initialPageParam: w,
    // import('@tanstack/react-query').UseQueryOptions
    _optimisticResults: x,
    enabled: C,
    notifyOnChangeProps: S,
    placeholderData: k,
    refetchInterval: A,
    refetchIntervalInBackground: b,
    refetchOnMount: T,
    refetchOnReconnect: R,
    refetchOnWindowFocus: B,
    retryOnMount: O,
    select: L,
    staleTime: V,
    suspense: N,
    throwOnError: M,
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // wagmi
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    config: U,
    connector: F,
    query: $,
    ...ie
  } = e;
  return ie;
}
function AG(e) {
  return {
    mutationFn(t) {
      return aI(e, t);
    },
    mutationKey: ["connect"]
  };
}
function TG(e) {
  return {
    mutationFn(t) {
      return jW(e, t);
    },
    mutationKey: ["disconnect"]
  };
}
function _G(e, t = {}) {
  return {
    async queryFn({ queryKey: n }) {
      const { name: r, scopeKey: i, ...o } = n[1];
      if (!r)
        throw new Error("name is required");
      return FW(e, { ...o, name: r });
    },
    queryKey: IG(t)
  };
}
function IG(e = {}) {
  return ["ensAvatar", xI(e)];
}
function RG(e, t = {}) {
  return {
    async queryFn({ queryKey: n }) {
      const { address: r, scopeKey: i, ...o } = n[1];
      if (!r)
        throw new Error("address is required");
      return LW(e, { ...o, address: r });
    },
    queryKey: PG(t)
  };
}
function PG(e = {}) {
  return ["ensName", xI(e)];
}
function OG(e) {
  return {
    mutationFn(t) {
      return zW(e, t);
    },
    mutationKey: ["sendTransaction"]
  };
}
function BG(e) {
  return {
    mutationFn(t) {
      return VW(e, t);
    },
    mutationKey: ["signMessage"]
  };
}
function NG(e) {
  return {
    mutationFn(t) {
      return fI(e, t);
    },
    mutationKey: ["switchChain"]
  };
}
function CI(e) {
  const t = Ut({
    ...e,
    queryKeyHashFn: EG
    // for bigint support
  });
  return t.queryKey = e.queryKey, t;
}
function kI(e = {}) {
  const t = Dn(e);
  return Dr((n) => $W(t, { onChange: n }), () => tE(t), () => tE(t));
}
function DG(e = {}) {
  const t = Dn(e);
  return Dr((n) => vG(t, { onChange: n }), () => nE(t), () => nE(t));
}
function EI(e = {}) {
  const t = Dn(e);
  return Dr((n) => GW(t, { onChange: n }), () => rE(t), () => rE(t));
}
function SI(e = {}) {
  const { mutation: t } = e, n = Dn(e), r = AG(n), { mutate: i, mutateAsync: o, ...s } = li({
    ...t,
    ...r
  });
  return Te(() => n.subscribe(({ status: a }) => a, (a, l) => {
    l === "connected" && a === "disconnected" && s.reset();
  }), [n, s.reset]), {
    ...s,
    connect: i,
    connectAsync: o,
    connectors: EI({ config: n })
  };
}
function jG(e = {}) {
  const t = Dn(e);
  return Dr((n) => WW(t, { onChange: n }), () => Tb(t), () => Tb(t));
}
function oy(e = {}) {
  const { mutation: t } = e, n = Dn(e), r = TG(n), { mutate: i, mutateAsync: o, ...s } = li({
    ...t,
    ...r
  });
  return {
    ...s,
    connectors: jG({ config: n }).map((a) => a.connector),
    disconnect: i,
    disconnectAsync: o
  };
}
function MG(e = {}) {
  const { name: t, query: n = {} } = e, r = Dn(e), i = kI({ config: r }), o = _G(r, {
    ...e,
    chainId: e.chainId ?? i
  }), s = !!(t && (n.enabled ?? !0));
  return CI({ ...n, ...o, enabled: s });
}
function FG(e = {}) {
  const { address: t, query: n = {} } = e, r = Dn(e), i = kI({ config: r }), o = RG(r, {
    ...e,
    chainId: e.chainId ?? i
  }), s = !!(t && (n.enabled ?? !0));
  return CI({ ...n, ...o, enabled: s });
}
function LG(e = {}) {
  const t = Dn(e);
  return bI.useSyncExternalStoreWithSelector((n) => HW(t, { onChange: n }), () => _b(t, e), () => _b(t, e), (n) => n, (n, r) => (n == null ? void 0 : n.uid) === (r == null ? void 0 : r.uid));
}
function UG(e = {}) {
  const { mutation: t } = e, n = Dn(e), r = OG(n), { mutate: i, mutateAsync: o, ...s } = li({
    ...t,
    ...r
  });
  return {
    ...s,
    sendTransaction: i,
    sendTransactionAsync: o
  };
}
function AI(e = {}) {
  const { mutation: t } = e, n = Dn(e), r = BG(n), { mutate: i, mutateAsync: o, ...s } = li({
    ...t,
    ...r
  });
  return {
    ...s,
    signMessage: i,
    signMessageAsync: o
  };
}
function zG(e = {}) {
  const { mutation: t } = e, n = Dn(e), r = NG(n), { mutate: i, mutateAsync: o, ...s } = li({
    ...t,
    ...r
  });
  return {
    ...s,
    chains: DG({ config: n }),
    switchChain: i,
    switchChainAsync: o
  };
}
function TI(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var i = e.length;
    for (t = 0; t < i; t++) e[t] && (n = TI(e[t])) && (r && (r += " "), r += n);
  } else for (n in e) e[n] && (r && (r += " "), r += n);
  return r;
}
function _I() {
  for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++) (e = arguments[n]) && (t = TI(e)) && (r && (r += " "), r += t);
  return r;
}
var VG = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
const hE = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]), pE = 4;
function qG(e) {
  let t = 0;
  function n() {
    return e[t++] << 8 | e[t++];
  }
  let r = n(), i = 1, o = [0, 1];
  for (let S = 1; S < r; S++)
    o.push(i += n());
  let s = n(), a = t;
  t += s;
  let l = 0, c = 0;
  function u() {
    return l == 0 && (c = c << 8 | e[t++], l = 8), c >> --l & 1;
  }
  const d = 31, f = 2 ** d, h = f >>> 1, p = h >> 1, m = f - 1;
  let g = 0;
  for (let S = 0; S < d; S++) g = g << 1 | u();
  let v = [], w = 0, x = f;
  for (; ; ) {
    let S = Math.floor(((g - w + 1) * i - 1) / x), k = 0, A = r;
    for (; A - k > 1; ) {
      let R = k + A >>> 1;
      S < o[R] ? A = R : k = R;
    }
    if (k == 0) break;
    v.push(k);
    let b = w + Math.floor(x * o[k] / i), T = w + Math.floor(x * o[k + 1] / i) - 1;
    for (; !((b ^ T) & h); )
      g = g << 1 & m | u(), b = b << 1 & m, T = T << 1 & m | 1;
    for (; b & ~T & p; )
      g = g & h | g << 1 & m >>> 1 | u(), b = b << 1 ^ h, T = (T ^ h) << 1 | h | 1;
    w = b, x = 1 + T - b;
  }
  let C = r - 4;
  return v.map((S) => {
    switch (S - C) {
      case 3:
        return C + 65792 + (e[a++] << 16 | e[a++] << 8 | e[a++]);
      case 2:
        return C + 256 + (e[a++] << 8 | e[a++]);
      case 1:
        return C + e[a++];
      default:
        return S - 1;
    }
  });
}
function $G(e) {
  let t = 0;
  return () => e[t++];
}
function II(e) {
  return $G(qG(WG(e)));
}
function WG(e) {
  let t = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((i, o) => t[i.charCodeAt(0)] = o);
  let n = e.length, r = new Uint8Array(6 * n >> 3);
  for (let i = 0, o = 0, s = 0, a = 0; i < n; i++)
    a = a << 6 | t[e.charCodeAt(i)], s += 6, s >= 8 && (r[o++] = a >> (s -= 8));
  return r;
}
function GG(e) {
  return e & 1 ? ~e >> 1 : e >> 1;
}
function HG(e, t) {
  let n = Array(e);
  for (let r = 0, i = 0; r < e; r++) n[r] = i += GG(t());
  return n;
}
function nd(e, t = 0) {
  let n = [];
  for (; ; ) {
    let r = e(), i = e();
    if (!i) break;
    t += r;
    for (let o = 0; o < i; o++)
      n.push(t + o);
    t += i + 1;
  }
  return n;
}
function RI(e) {
  return rd(() => {
    let t = nd(e);
    if (t.length) return t;
  });
}
function PI(e) {
  let t = [];
  for (; ; ) {
    let n = e();
    if (n == 0) break;
    t.push(KG(n, e));
  }
  for (; ; ) {
    let n = e() - 1;
    if (n < 0) break;
    t.push(YG(n, e));
  }
  return t.flat();
}
function rd(e) {
  let t = [];
  for (; ; ) {
    let n = e(t.length);
    if (!n) break;
    t.push(n);
  }
  return t;
}
function OI(e, t, n) {
  let r = Array(e).fill().map(() => []);
  for (let i = 0; i < t; i++)
    HG(e, n).forEach((o, s) => r[s].push(o));
  return r;
}
function KG(e, t) {
  let n = 1 + t(), r = t(), i = rd(t);
  return OI(i.length, 1 + e, t).flatMap((s, a) => {
    let [l, ...c] = s;
    return Array(i[a]).fill().map((u, d) => {
      let f = d * r;
      return [l + d * n, c.map((h) => h + f)];
    });
  });
}
function YG(e, t) {
  let n = 1 + t();
  return OI(n, 1 + e, t).map((i) => [i[0], i.slice(1)]);
}
function QG(e) {
  let t = [], n = nd(e);
  return i(r([]), []), t;
  function r(o) {
    let s = e(), a = rd(() => {
      let l = nd(e).map((c) => n[c]);
      if (l.length) return r(l);
    });
    return { S: s, B: a, Q: o };
  }
  function i({ S: o, B: s }, a, l) {
    if (!(o & 4 && l === a[a.length - 1])) {
      o & 2 && (l = a[a.length - 1]), o & 1 && t.push(a);
      for (let c of s)
        for (let u of c.Q)
          i(c, [...a, u], l);
    }
  }
}
function JG(e) {
  return e.toString(16).toUpperCase().padStart(2, "0");
}
function BI(e) {
  return `{${JG(e)}}`;
}
function XG(e) {
  let t = [];
  for (let n = 0, r = e.length; n < r; ) {
    let i = e.codePointAt(n);
    n += i < 65536 ? 1 : 2, t.push(i);
  }
  return t;
}
function nc(e) {
  let n = e.length;
  if (n < 4096) return String.fromCodePoint(...e);
  let r = [];
  for (let i = 0; i < n; )
    r.push(String.fromCodePoint(...e.slice(i, i += 4096)));
  return r.join("");
}
function ZG(e, t) {
  let n = e.length, r = n - t.length;
  for (let i = 0; r == 0 && i < n; i++) r = e[i] - t[i];
  return r;
}
var eH = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
const id = 44032, Gh = 4352, Hh = 4449, Kh = 4519, NI = 19, DI = 21, rc = 28, Yh = DI * rc, tH = NI * Yh, nH = id + tH, rH = Gh + NI, iH = Hh + DI, oH = Kh + rc;
function vu(e) {
  return e >> 24 & 255;
}
function jI(e) {
  return e & 16777215;
}
let Ob, yE, Bb, bh;
function sH() {
  let e = II(eH);
  Ob = new Map(RI(e).flatMap((t, n) => t.map((r) => [r, n + 1 << 24]))), yE = new Set(nd(e)), Bb = /* @__PURE__ */ new Map(), bh = /* @__PURE__ */ new Map();
  for (let [t, n] of PI(e)) {
    if (!yE.has(t) && n.length == 2) {
      let [r, i] = n, o = bh.get(r);
      o || (o = /* @__PURE__ */ new Map(), bh.set(r, o)), o.set(i, t);
    }
    Bb.set(t, n.reverse());
  }
}
function MI(e) {
  return e >= id && e < nH;
}
function aH(e, t) {
  if (e >= Gh && e < rH && t >= Hh && t < iH)
    return id + (e - Gh) * Yh + (t - Hh) * rc;
  if (MI(e) && t > Kh && t < oH && (e - id) % rc == 0)
    return e + (t - Kh);
  {
    let n = bh.get(e);
    return n && (n = n.get(t), n) ? n : -1;
  }
}
function FI(e) {
  Ob || sH();
  let t = [], n = [], r = !1;
  function i(o) {
    let s = Ob.get(o);
    s && (r = !0, o |= s), t.push(o);
  }
  for (let o of e)
    for (; ; ) {
      if (o < 128)
        t.push(o);
      else if (MI(o)) {
        let s = o - id, a = s / Yh | 0, l = s % Yh / rc | 0, c = s % rc;
        i(Gh + a), i(Hh + l), c > 0 && i(Kh + c);
      } else {
        let s = Bb.get(o);
        s ? n.push(...s) : i(o);
      }
      if (!n.length) break;
      o = n.pop();
    }
  if (r && t.length > 1) {
    let o = vu(t[0]);
    for (let s = 1; s < t.length; s++) {
      let a = vu(t[s]);
      if (a == 0 || o <= a) {
        o = a;
        continue;
      }
      let l = s - 1;
      for (; ; ) {
        let c = t[l + 1];
        if (t[l + 1] = t[l], t[l] = c, !l || (o = vu(t[--l]), o <= a)) break;
      }
      o = vu(t[s]);
    }
  }
  return t;
}
function lH(e) {
  let t = [], n = [], r = -1, i = 0;
  for (let o of e) {
    let s = vu(o), a = jI(o);
    if (r == -1)
      s == 0 ? r = a : t.push(a);
    else if (i > 0 && i >= s)
      s == 0 ? (t.push(r, ...n), n.length = 0, r = a) : n.push(a), i = s;
    else {
      let l = aH(r, a);
      l >= 0 ? r = l : i == 0 && s == 0 ? (t.push(r), r = a) : (n.push(a), i = s);
    }
  }
  return r >= 0 && t.push(r, ...n), t;
}
function LI(e) {
  return FI(e).map(jI);
}
function cH(e) {
  return lH(FI(e));
}
const mE = 45, UI = ".", zI = 65039, VI = 1, yl = (e) => Array.from(e);
function od(e, t) {
  return e.P.has(t) || e.Q.has(t);
}
class uH extends Array {
  get is_emoji() {
    return !0;
  }
  // free tagging system
}
let Nb, qI, aa, Db, $I, _l, dg, cl, WI, gE, jb;
function $w() {
  if (Nb) return;
  let e = II(VG);
  const t = () => nd(e), n = () => new Set(t());
  Nb = new Map(PI(e)), qI = n(), aa = t(), Db = new Set(t().map((u) => aa[u])), aa = new Set(aa), $I = n(), n();
  let r = RI(e), i = e();
  const o = () => new Set(t().flatMap((u) => r[u]).concat(t()));
  _l = rd((u) => {
    let d = rd(e).map((f) => f + 96);
    if (d.length) {
      let f = u >= i;
      d[0] -= 32, d = nc(d), f && (d = `Restricted[${d}]`);
      let h = o(), p = o(), m = !e();
      return { N: d, P: h, Q: p, M: m, R: f };
    }
  }), dg = n(), cl = /* @__PURE__ */ new Map();
  let s = t().concat(yl(dg)).sort((u, d) => u - d);
  s.forEach((u, d) => {
    let f = e(), h = s[d] = f ? s[d - f] : { V: [], M: /* @__PURE__ */ new Map() };
    h.V.push(u), dg.has(u) || cl.set(u, h);
  });
  for (let { V: u, M: d } of new Set(cl.values())) {
    let f = [];
    for (let p of u) {
      let m = _l.filter((v) => od(v, p)), g = f.find(({ G: v }) => m.some((w) => v.has(w)));
      g || (g = { G: /* @__PURE__ */ new Set(), V: [] }, f.push(g)), g.V.push(p), m.forEach((v) => g.G.add(v));
    }
    let h = f.flatMap((p) => yl(p.G));
    for (let { G: p, V: m } of f) {
      let g = new Set(h.filter((v) => !p.has(v)));
      for (let v of m)
        d.set(v, g);
    }
  }
  let a = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set();
  const c = (u) => a.has(u) ? l.add(u) : a.add(u);
  for (let u of _l) {
    for (let d of u.P) c(d);
    for (let d of u.Q) c(d);
  }
  for (let u of a)
    !cl.has(u) && !l.has(u) && cl.set(u, VI);
  WI = new Set(yl(a).concat(yl(LI(a)))), gE = QG(e).map((u) => uH.from(u)).sort(ZG), jb = /* @__PURE__ */ new Map();
  for (let u of gE) {
    let d = [jb];
    for (let f of u) {
      let h = d.map((p) => {
        let m = p.get(f);
        return m || (m = /* @__PURE__ */ new Map(), p.set(f, m)), m;
      });
      f === zI ? d.push(...h) : d = h;
    }
    for (let f of d)
      f.V = u;
  }
}
function Ww(e) {
  return (GI(e) ? "" : `${Gw(sy([e]))} `) + BI(e);
}
function Gw(e) {
  return `"${e}"‎`;
}
function dH(e) {
  if (e.length >= 4 && e[2] == mE && e[3] == mE)
    throw new Error(`invalid label extension: "${nc(e.slice(0, 4))}"`);
}
function fH(e) {
  for (let n = e.lastIndexOf(95); n > 0; )
    if (e[--n] !== 95)
      throw new Error("underscore allowed only at start");
}
function hH(e) {
  let t = e[0], n = hE.get(t);
  if (n) throw Iu(`leading ${n}`);
  let r = e.length, i = -1;
  for (let o = 1; o < r; o++) {
    t = e[o];
    let s = hE.get(t);
    if (s) {
      if (i == o) throw Iu(`${n} + ${s}`);
      i = o + 1, n = s;
    }
  }
  if (i == r) throw Iu(`trailing ${n}`);
}
function sy(e, t = BI) {
  let n = [];
  pH(e[0]) && n.push("◌");
  let r = 0, i = e.length;
  for (let o = 0; o < i; o++) {
    let s = e[o];
    GI(s) && (n.push(nc(e.slice(r, o))), n.push(t(s)), r = o + 1);
  }
  return n.push(nc(e.slice(r, i))), n.join("");
}
function pH(e) {
  return $w(), aa.has(e);
}
function GI(e) {
  return $w(), $I.has(e);
}
function yH(e) {
  return bH(mH(e, cH, CH));
}
function mH(e, t, n) {
  if (!e) return [];
  $w();
  let r = 0;
  return e.split(UI).map((i) => {
    let o = XG(i), s = {
      input: o,
      offset: r
      // codepoint, not substring!
    };
    r += o.length + 1;
    try {
      let a = s.tokens = xH(o, t, n), l = a.length, c;
      if (!l)
        throw new Error("empty label");
      let u = s.output = a.flat();
      if (fH(u), !(s.emoji = l > 1 || a[0].is_emoji) && u.every((f) => f < 128))
        dH(u), c = "ASCII";
      else {
        let f = a.flatMap((h) => h.is_emoji ? [] : h);
        if (!f.length)
          c = "Emoji";
        else {
          if (aa.has(u[0])) throw Iu("leading combining mark");
          for (let m = 1; m < l; m++) {
            let g = a[m];
            if (!g.is_emoji && aa.has(g[0]))
              throw Iu(`emoji + combining mark: "${nc(a[m - 1])} + ${sy([g[0]])}"`);
          }
          hH(u);
          let h = yl(new Set(f)), [p] = vH(h);
          wH(p, f), gH(p, h), c = p.N;
        }
      }
      s.type = c;
    } catch (a) {
      s.error = a;
    }
    return s;
  });
}
function gH(e, t) {
  let n, r = [];
  for (let i of t) {
    let o = cl.get(i);
    if (o === VI) return;
    if (o) {
      let s = o.M.get(i);
      if (n = n ? n.filter((a) => s.has(a)) : yl(s), !n.length) return;
    } else
      r.push(i);
  }
  if (n) {
    for (let i of n)
      if (r.every((o) => od(i, o)))
        throw new Error(`whole-script confusable: ${e.N}/${i.N}`);
  }
}
function vH(e) {
  let t = _l;
  for (let n of e) {
    let r = t.filter((i) => od(i, n));
    if (!r.length)
      throw _l.some((i) => od(i, n)) ? KI(t[0], n) : HI(n);
    if (t = r, r.length == 1) break;
  }
  return t;
}
function bH(e) {
  return e.map(({ input: t, error: n, output: r }) => {
    if (n) {
      let i = n.message;
      throw new Error(e.length == 1 ? i : `Invalid label ${Gw(sy(t))}: ${i}`);
    }
    return nc(r);
  }).join(UI);
}
function HI(e) {
  return new Error(`disallowed character: ${Ww(e)}`);
}
function KI(e, t) {
  let n = Ww(t), r = _l.find((i) => i.P.has(t));
  return r && (n = `${r.N} ${n}`), new Error(`illegal mixture: ${e.N} + ${n}`);
}
function Iu(e) {
  return new Error(`illegal placement: ${e}`);
}
function wH(e, t) {
  for (let n of t)
    if (!od(e, n))
      throw KI(e, n);
  if (e.M) {
    let n = LI(t);
    for (let r = 1, i = n.length; r < i; r++)
      if (Db.has(n[r])) {
        let o = r + 1;
        for (let s; o < i && Db.has(s = n[o]); o++)
          for (let a = r; a < o; a++)
            if (n[a] == s)
              throw new Error(`duplicate non-spacing marks: ${Ww(s)}`);
        if (o - r > pE)
          throw new Error(`excessive non-spacing marks: ${Gw(sy(n.slice(r - 1, o)))} (${o - r}/${pE})`);
        r = o;
      }
  }
}
function xH(e, t, n) {
  let r = [], i = [];
  for (e = e.slice().reverse(); e.length; ) {
    let o = kH(e);
    if (o)
      i.length && (r.push(t(i)), i = []), r.push(n(o));
    else {
      let s = e.pop();
      if (WI.has(s))
        i.push(s);
      else {
        let a = Nb.get(s);
        if (a)
          i.push(...a);
        else if (!qI.has(s))
          throw HI(s);
      }
    }
  }
  return i.length && r.push(t(i)), r;
}
function CH(e) {
  return e.filter((t) => t != zI);
}
function kH(e, t) {
  let n = jb, r, i = e.length;
  for (; i && (n = n.get(e[--i]), !!n); ) {
    let { V: o } = n;
    o && (r = o, e.length = i);
  }
  return r;
}
function EH(e) {
  return yH(e);
}
const SH = {
  gasPriceOracle: { address: "0x420000000000000000000000000000000000000F" },
  l1Block: { address: "0x4200000000000000000000000000000000000015" },
  l2CrossDomainMessenger: {
    address: "0x4200000000000000000000000000000000000007"
  },
  l2Erc721Bridge: { address: "0x4200000000000000000000000000000000000014" },
  l2StandardBridge: { address: "0x4200000000000000000000000000000000000010" },
  l2ToL1MessagePasser: {
    address: "0x4200000000000000000000000000000000000016"
  }
}, AH = {
  block: /* @__PURE__ */ HT({
    format(e) {
      var n;
      return {
        transactions: (n = e.transactions) == null ? void 0 : n.map((r) => {
          if (typeof r == "string")
            return r;
          const i = Fd(r);
          return i.typeHex === "0x7e" && (i.isSystemTx = r.isSystemTx, i.mint = r.mint ? Yn(r.mint) : void 0, i.sourceHash = r.sourceHash, i.type = "deposit"), i;
        }),
        stateRoot: e.stateRoot
      };
    }
  }),
  transaction: /* @__PURE__ */ GT({
    format(e) {
      const t = {};
      return e.type === "0x7e" && (t.isSystemTx = e.isSystemTx, t.mint = e.mint ? Yn(e.mint) : void 0, t.sourceHash = e.sourceHash, t.type = "deposit"), t;
    }
  }),
  transactionReceipt: /* @__PURE__ */ Zq({
    format(e) {
      return {
        l1GasPrice: e.l1GasPrice ? Yn(e.l1GasPrice) : null,
        l1GasUsed: e.l1GasUsed ? Yn(e.l1GasUsed) : null,
        l1Fee: e.l1Fee ? Yn(e.l1Fee) : null,
        l1FeeScalar: e.l1FeeScalar ? Number(e.l1FeeScalar) : null
      };
    }
  })
};
function YI(e, t) {
  return IH(e) ? _H(e) : T$(e, t);
}
const TH = {
  transaction: YI
};
function _H(e) {
  RH(e);
  const { sourceHash: t, data: n, from: r, gas: i, isSystemTx: o, mint: s, to: a, value: l } = e, c = [
    t,
    r,
    a ?? "0x",
    s ? $e(s) : "0x",
    l ? $e(l) : "0x",
    i ? $e(i) : "0x",
    o ? "0x1" : "0x",
    n ?? "0x"
  ];
  return Pi([
    "0x7e",
    Po(c)
  ]);
}
function IH(e) {
  return e.type === "deposit" || typeof e.sourceHash < "u";
}
function RH(e) {
  const { from: t, to: n } = e;
  if (t && !bn(t))
    throw new Zn({ address: t });
  if (n && !bn(n))
    throw new Zn({ address: n });
}
const Qh = {
  contracts: SH,
  formatters: AH,
  serializers: TH
}, PH = /* @__PURE__ */ jr({
  id: 42161,
  name: "Arbitrum One",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://arb1.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://arbiscan.io",
      apiUrl: "https://api.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7654707
    }
  }
}), OH = /* @__PURE__ */ jr({
  id: 43114,
  name: "Avalanche",
  nativeCurrency: {
    decimals: 18,
    name: "Avalanche",
    symbol: "AVAX"
  },
  rpcUrls: {
    default: { http: ["https://api.avax.network/ext/bc/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "SnowTrace",
      url: "https://snowtrace.io",
      apiUrl: "https://api.snowtrace.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11907934
    }
  }
}), Mf = 1, BH = /* @__PURE__ */ jr({
  ...Qh,
  id: 8453,
  name: "Base",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.base.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://basescan.org",
      apiUrl: "https://api.basescan.org/api"
    }
  },
  contracts: {
    ...Qh.contracts,
    l2OutputOracle: {
      [Mf]: {
        address: "0x56315b90c40730925ec5485cf004d835058518A0"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 5022
    },
    portal: {
      [Mf]: {
        address: "0x49048044D57e1C92A77f79988d21Fa8fAF74E97e",
        blockCreated: 17482143
      }
    },
    l1StandardBridge: {
      [Mf]: {
        address: "0x3154Cf16ccdb4C6d922629664174b904d80F2C35",
        blockCreated: 17482143
      }
    }
  },
  sourceId: Mf
}), NH = /* @__PURE__ */ jr({
  id: 56,
  name: "BNB Smart Chain",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "BNB"
  },
  rpcUrls: {
    default: { http: ["https://rpc.ankr.com/bsc"] }
  },
  blockExplorers: {
    default: {
      name: "BscScan",
      url: "https://bscscan.com",
      apiUrl: "https://api.bscscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15921452
    }
  }
}), DH = {
  /*
     * Estimates the fees per gas for a transaction.
  
     * If the transaction is to be paid in a token (feeCurrency is present) then the fees
     * are estimated in the value of the token. Otherwise falls back to the default
     * estimation by returning null.
     *
     * @param params fee estimation function parameters
     */
  estimateFeesPerGas: async (e) => {
    var r;
    if (!((r = e.request) != null && r.feeCurrency))
      return null;
    const [t, n] = await Promise.all([
      jH(e.client, e.request.feeCurrency),
      MH(e.client, e.request.feeCurrency)
    ]);
    return {
      maxFeePerGas: t,
      maxPriorityFeePerGas: n
    };
  }
};
async function jH(e, t) {
  const n = await e.request({
    method: "eth_gasPrice",
    params: [t]
  });
  return BigInt(n);
}
async function MH(e, t) {
  const n = await e.request({
    method: "eth_maxPriorityFeePerGas",
    params: [t]
  });
  return BigInt(n);
}
function QI(e) {
  return e === 0 || e === 0n || e === void 0 || e === null || e === "0" || e === "" || typeof e == "string" && (Ji(e).toLowerCase() === "0x" || Ji(e).toLowerCase() === "0x00");
}
function bu(e) {
  return !QI(e);
}
function FH(e) {
  return typeof e.maxFeePerGas < "u" && typeof e.maxPriorityFeePerGas < "u";
}
function JI(e) {
  return e.type === "cip64" ? !0 : FH(e) && bu(e.feeCurrency);
}
const LH = {
  block: /* @__PURE__ */ HT({
    format(e) {
      var n;
      return {
        transactions: (n = e.transactions) == null ? void 0 : n.map((r) => typeof r == "string" ? r : {
          ...Fd(r),
          ...r.gatewayFee ? {
            gatewayFee: Yn(r.gatewayFee),
            gatewayFeeRecipient: r.gatewayFeeRecipient
          } : {},
          feeCurrency: r.feeCurrency
        }),
        ...e.randomness ? { randomness: e.randomness } : {}
      };
    }
  }),
  transaction: /* @__PURE__ */ GT({
    format(e) {
      if (e.type === "0x7e")
        return {
          isSystemTx: e.isSystemTx,
          mint: e.mint ? Yn(e.mint) : void 0,
          sourceHash: e.sourceHash,
          type: "deposit"
        };
      const t = { feeCurrency: e.feeCurrency };
      return e.type === "0x7b" ? t.type = "cip64" : (e.type === "0x7c" && (t.type = "cip42"), t.gatewayFee = e.gatewayFee ? Yn(e.gatewayFee) : null, t.gatewayFeeRecipient = e.gatewayFeeRecipient), t;
    }
  }),
  transactionRequest: /* @__PURE__ */ _z({
    format(e) {
      const t = {};
      return e.feeCurrency && (t.feeCurrency = e.feeCurrency), JI(e) && (t.type = "0x7b"), t;
    }
  })
};
function UH(e, t) {
  return JI(e) ? VH(e, t) : YI(e, t);
}
const zH = {
  transaction: UH
};
function VH(e, t) {
  $H(e);
  const { chainId: n, gas: r, nonce: i, to: o, value: s, maxFeePerGas: a, maxPriorityFeePerGas: l, accessList: c, feeCurrency: u, data: d } = e, f = [
    $e(n),
    i ? $e(i) : "0x",
    l ? $e(l) : "0x",
    a ? $e(a) : "0x",
    r ? $e(r) : "0x",
    o ?? "0x",
    s ? $e(s) : "0x",
    d ?? "0x",
    qd(c),
    u,
    ...Mc(e, t)
  ];
  return Pi([
    "0x7b",
    Po(f)
  ]);
}
const qH = jd;
function $H(e) {
  const { chainId: t, maxPriorityFeePerGas: n, gasPrice: r, maxFeePerGas: i, to: o, feeCurrency: s } = e;
  if (t <= 0)
    throw new Bd({ chainId: t });
  if (o && !bn(o))
    throw new Zn({ address: o });
  if (r)
    throw new be("`gasPrice` is not a valid CIP-64 Transaction attribute.");
  if (bu(i) && i > qH)
    throw new ks({ maxFeePerGas: i });
  if (bu(n) && bu(i) && n > i)
    throw new Jl({ maxFeePerGas: i, maxPriorityFeePerGas: n });
  if (bu(s) && !bn(s))
    throw new be("`feeCurrency` MUST be a token address for CIP-64 transactions.");
  if (QI(s))
    throw new be("`feeCurrency` must be provided for CIP-64 transactions.");
}
const WH = {
  formatters: LH,
  serializers: zH,
  fees: DH
}, GH = /* @__PURE__ */ jr({
  ...WH,
  id: 42220,
  name: "Celo",
  nativeCurrency: {
    decimals: 18,
    name: "CELO",
    symbol: "CELO"
  },
  rpcUrls: {
    default: { http: ["https://forno.celo.org"] }
  },
  blockExplorers: {
    default: {
      name: "Celo Explorer",
      url: "https://celoscan.io",
      apiUrl: "https://api.celoscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 13112599
    }
  },
  testnet: !1
}), HH = /* @__PURE__ */ jr({
  id: 1116,
  name: "Core Dao",
  nativeCurrency: {
    decimals: 18,
    name: "Core",
    symbol: "CORE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.coredao.org"] }
  },
  blockExplorers: {
    default: {
      name: "CoreDao",
      url: "https://scan.coredao.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 11907934
    }
  },
  testnet: !1
}), KH = /* @__PURE__ */ jr({
  id: 5,
  name: "Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.ankr.com/eth_goerli"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli.etherscan.io",
      apiUrl: "https://api-goerli.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xfc4AC75C46C914aF5892d6d3eFFcebD7917293F1",
      blockCreated: 10339206
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6507670
    }
  },
  testnet: !0
}), YH = /* @__PURE__ */ jr({
  id: 16666e5,
  name: "Harmony One",
  nativeCurrency: {
    name: "Harmony",
    symbol: "ONE",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.ankr.com/harmony"] }
  },
  blockExplorers: {
    default: {
      name: "Harmony Explorer",
      url: "https://explorer.harmony.one"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 24185753
    }
  }
}), QH = /* @__PURE__ */ jr({
  id: 17e3,
  name: "Holesky",
  nativeCurrency: { name: "Holesky Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://ethereum-holesky-rpc.publicnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://holesky.etherscan.io",
      apiUrl: "https://api-holesky.etherscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 77
    },
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      blockCreated: 801613
    },
    ensUniversalResolver: {
      address: "0xa6AC935D4971E3CD133b950aE053bECD16fE7f3b",
      blockCreated: 973484
    }
  },
  testnet: !0
});
async function JH(e, t) {
  var i, o, s;
  const { account: n = e.account } = t;
  if (!n)
    throw new pw();
  const r = ui(n);
  try {
    const { accessList: a, blockNumber: l, blockTag: c, data: u, gas: d, gasPrice: f, maxFeePerGas: h, maxPriorityFeePerGas: p, nonce: m, to: g, value: v, ...w } = (r == null ? void 0 : r.type) === "local" ? await Kp(e, t) : t, C = (l ? Fe(l) : void 0) || c;
    Md(t);
    const S = (s = (o = (i = e.chain) == null ? void 0 : i.formatters) == null ? void 0 : o.transactionRequest) == null ? void 0 : s.format, A = (S || Dd)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...Wp(w, { format: S }),
      from: r == null ? void 0 : r.address,
      accessList: a,
      data: u,
      gas: d,
      gasPrice: f,
      maxFeePerGas: h,
      maxPriorityFeePerGas: p,
      nonce: m,
      to: g,
      value: v
    }), { baseFeePerGas: b, gasLimit: T, priorityFeePerGas: R } = await e.request({
      method: "linea_estimateGas",
      params: C ? [A, C] : [A]
    });
    return {
      baseFeePerGas: BigInt(b),
      gasLimit: BigInt(T),
      priorityFeePerGas: BigInt(R)
    };
  } catch (a) {
    throw __(a, {
      ...t,
      account: r,
      chain: e.chain
    });
  }
}
const XH = {
  fees: {
    estimateFeesPerGas: vE,
    async maxPriorityFeePerGas({ block: e, client: t, request: n }) {
      const r = await vE({
        block: e,
        client: t,
        multiply: (i) => i,
        request: n,
        type: "eip1559"
      });
      return r != null && r.maxPriorityFeePerGas ? r.maxPriorityFeePerGas : null;
    }
  }
};
async function vE({ client: e, multiply: t, request: n, type: r }) {
  try {
    const i = await JH(e, {
      ...n,
      account: n == null ? void 0 : n.account
    }), { priorityFeePerGas: o } = i, a = t(BigInt(i.baseFeePerGas)) + o;
    return r === "legacy" ? { gasPrice: a } : {
      maxFeePerGas: a,
      maxPriorityFeePerGas: o
    };
  } catch {
    return null;
  }
}
const ZH = /* @__PURE__ */ jr({
  ...XH,
  id: 59144,
  name: "Linea Mainnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.linea.build"],
      webSocket: ["wss://rpc.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://lineascan.build",
      apiUrl: "https://api.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 42
    }
  },
  testnet: !1
}), Fc = /* @__PURE__ */ jr({
  id: 1,
  name: "Ethereum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://cloudflare-eth.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://etherscan.io",
      apiUrl: "https://api.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xce01f8eee7E479C928F8919abD53E553a36CeF67",
      blockCreated: 19258213
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
}), au = 1, eK = /* @__PURE__ */ jr({
  ...Qh,
  id: 10,
  name: "OP Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Optimism Explorer",
      url: "https://optimistic.etherscan.io",
      apiUrl: "https://api-optimistic.etherscan.io/api"
    }
  },
  contracts: {
    ...Qh.contracts,
    disputeGameFactory: {
      [au]: {
        address: "0xe5965Ab5962eDc7477C8520243A95517CD252fA9"
      }
    },
    l2OutputOracle: {
      [au]: {
        address: "0xdfe97868233d1aa22e815a266982f2cf17685a27"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4286263
    },
    portal: {
      [au]: {
        address: "0xbEb5Fc579115071764c7423A4f12eDde41f106Ed"
      }
    },
    l1StandardBridge: {
      [au]: {
        address: "0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1"
      }
    }
  },
  sourceId: au
}), tK = /* @__PURE__ */ jr({
  id: 137,
  name: "Polygon",
  nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://polygon-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://polygonscan.com",
      apiUrl: "https://api.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  }
});
var wh = "right-scroll-bar-position", xh = "width-before-scroll-bar", nK = "with-scroll-bars-hidden", rK = "--removed-body-scroll-bar-size";
function iK(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function oK(e, t) {
  var n = Oe(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var i = n.value;
          i !== r && (n.value = r, n.callback(r, i));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
function sK(e, t) {
  return oK(null, function(n) {
    return e.forEach(function(r) {
      return iK(r, n);
    });
  });
}
function aK(e) {
  return e;
}
function lK(e, t) {
  t === void 0 && (t = aK);
  var n = [], r = !1, i = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(o) {
      var s = t(o, r);
      return n.push(s), function() {
        n = n.filter(function(a) {
          return a !== s;
        });
      };
    },
    assignSyncMedium: function(o) {
      for (r = !0; n.length; ) {
        var s = n;
        n = [], s.forEach(o);
      }
      n = {
        push: function(a) {
          return o(a);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(o) {
      r = !0;
      var s = [];
      if (n.length) {
        var a = n;
        n = [], a.forEach(o), s = n;
      }
      var l = function() {
        var u = s;
        s = [], u.forEach(o);
      }, c = function() {
        return Promise.resolve().then(l);
      };
      c(), n = {
        push: function(u) {
          s.push(u), c();
        },
        filter: function(u) {
          return s = s.filter(u), n;
        }
      };
    }
  };
  return i;
}
function cK(e) {
  e === void 0 && (e = {});
  var t = lK(null);
  return t.options = Jr({ async: !0, ssr: !1 }, e), t;
}
var XI = function(e) {
  var t = e.sideCar, n = Dp(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return P.createElement(r, Jr({}, n));
};
XI.isSideCarExport = !0;
function uK(e, t) {
  return e.useMedium(t), XI;
}
var ZI = cK(), fg = function() {
}, ay = P.forwardRef(function(e, t) {
  var n = P.useRef(null), r = P.useState({
    onScrollCapture: fg,
    onWheelCapture: fg,
    onTouchMoveCapture: fg
  }), i = r[0], o = r[1], s = e.forwardProps, a = e.children, l = e.className, c = e.removeScrollBar, u = e.enabled, d = e.shards, f = e.sideCar, h = e.noIsolation, p = e.inert, m = e.allowPinchZoom, g = e.as, v = g === void 0 ? "div" : g, w = e.gapMode, x = Dp(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), C = f, S = sK([n, t]), k = Jr(Jr({}, x), i);
  return P.createElement(
    P.Fragment,
    null,
    u && P.createElement(C, { sideCar: ZI, removeScrollBar: c, shards: d, noIsolation: h, inert: p, setCallbacks: o, allowPinchZoom: !!m, lockRef: n, gapMode: w }),
    s ? P.cloneElement(P.Children.only(a), Jr(Jr({}, k), { ref: S })) : P.createElement(v, Jr({}, k, { className: l, ref: S }), a)
  );
});
ay.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
ay.classNames = {
  fullWidth: xh,
  zeroRight: wh
};
var dK = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function fK() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = dK();
  return t && e.setAttribute("nonce", t), e;
}
function hK(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function pK(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var yK = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = fK()) && (hK(t, n), pK(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, mK = function() {
  var e = yK();
  return function(t, n) {
    P.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, e5 = function() {
  var e = mK(), t = function(n) {
    var r = n.styles, i = n.dynamic;
    return e(r, i), null;
  };
  return t;
}, gK = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, hg = function(e) {
  return parseInt(e || "", 10) || 0;
}, vK = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], i = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [hg(n), hg(r), hg(i)];
}, bK = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return gK;
  var t = vK(e), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, r - n + t[2] - t[0])
  };
}, wK = e5(), Jh = "data-scroll-locked", xK = function(e, t, n, r) {
  var i = e.left, o = e.top, s = e.right, a = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(nK, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(a, "px ").concat(r, `;
  }
  body[`).concat(Jh, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(i, `px;
    padding-top: `).concat(o, `px;
    padding-right: `).concat(s, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(a, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(a, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(wh, ` {
    right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(xh, ` {
    margin-right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(wh, " .").concat(wh, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(xh, " .").concat(xh, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(Jh, `] {
    `).concat(rK, ": ").concat(a, `px;
  }
`);
}, CK = function(e) {
  var t = e.noRelative, n = e.noImportant, r = e.gapMode, i = r === void 0 ? "margin" : r, o = P.useMemo(function() {
    return bK(i);
  }, [i]);
  return P.useEffect(function() {
    return document.body.setAttribute(Jh, ""), function() {
      document.body.removeAttribute(Jh);
    };
  }, []), P.createElement(wK, { styles: xK(o, !t, i, n ? "" : "!important") });
}, Mb = !1;
if (typeof window < "u")
  try {
    var Ff = Object.defineProperty({}, "passive", {
      get: function() {
        return Mb = !0, !0;
      }
    });
    window.addEventListener("test", Ff, Ff), window.removeEventListener("test", Ff, Ff);
  } catch {
    Mb = !1;
  }
var el = Mb ? { passive: !1 } : !1, kK = function(e) {
  return e.tagName === "TEXTAREA";
}, t5 = function(e, t) {
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !kK(e) && n[t] === "visible")
  );
}, EK = function(e) {
  return t5(e, "overflowY");
}, SK = function(e) {
  return t5(e, "overflowX");
}, bE = function(e, t) {
  var n = t.ownerDocument, r = t;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var i = n5(e, r);
    if (i) {
      var o = r5(e, r), s = o[1], a = o[2];
      if (s > a)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, AK = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
  return [
    t,
    n,
    r
  ];
}, TK = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
  return [
    t,
    n,
    r
  ];
}, n5 = function(e, t) {
  return e === "v" ? EK(t) : SK(t);
}, r5 = function(e, t) {
  return e === "v" ? AK(t) : TK(t);
}, _K = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, IK = function(e, t, n, r, i) {
  var o = _K(e, window.getComputedStyle(t).direction), s = o * r, a = n.target, l = t.contains(a), c = !1, u = s > 0, d = 0, f = 0;
  do {
    var h = r5(e, a), p = h[0], m = h[1], g = h[2], v = m - g - o * p;
    (p || v) && n5(e, a) && (d += v, f += p), a instanceof ShadowRoot ? a = a.host : a = a.parentNode;
  } while (
    // portaled content
    !l && a !== document.body || // self content
    l && (t.contains(a) || t === a)
  );
  return (u && (Math.abs(d) < 1 || !i) || !u && (Math.abs(f) < 1 || !i)) && (c = !0), c;
}, Lf = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, wE = function(e) {
  return [e.deltaX, e.deltaY];
}, xE = function(e) {
  return e && "current" in e ? e.current : e;
}, RK = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, PK = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, OK = 0, tl = [];
function BK(e) {
  var t = P.useRef([]), n = P.useRef([0, 0]), r = P.useRef(), i = P.useState(OK++)[0], o = P.useState(e5)[0], s = P.useRef(e);
  P.useEffect(function() {
    s.current = e;
  }, [e]), P.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(i));
      var m = Hl([e.lockRef.current], (e.shards || []).map(xE), !0).filter(Boolean);
      return m.forEach(function(g) {
        return g.classList.add("allow-interactivity-".concat(i));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(i)), m.forEach(function(g) {
          return g.classList.remove("allow-interactivity-".concat(i));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var a = P.useCallback(function(m, g) {
    if ("touches" in m && m.touches.length === 2)
      return !s.current.allowPinchZoom;
    var v = Lf(m), w = n.current, x = "deltaX" in m ? m.deltaX : w[0] - v[0], C = "deltaY" in m ? m.deltaY : w[1] - v[1], S, k = m.target, A = Math.abs(x) > Math.abs(C) ? "h" : "v";
    if ("touches" in m && A === "h" && k.type === "range")
      return !1;
    var b = bE(A, k);
    if (!b)
      return !0;
    if (b ? S = A : (S = A === "v" ? "h" : "v", b = bE(A, k)), !b)
      return !1;
    if (!r.current && "changedTouches" in m && (x || C) && (r.current = S), !S)
      return !0;
    var T = r.current || S;
    return IK(T, g, m, T === "h" ? x : C, !0);
  }, []), l = P.useCallback(function(m) {
    var g = m;
    if (!(!tl.length || tl[tl.length - 1] !== o)) {
      var v = "deltaY" in g ? wE(g) : Lf(g), w = t.current.filter(function(S) {
        return S.name === g.type && (S.target === g.target || g.target === S.shadowParent) && RK(S.delta, v);
      })[0];
      if (w && w.should) {
        g.cancelable && g.preventDefault();
        return;
      }
      if (!w) {
        var x = (s.current.shards || []).map(xE).filter(Boolean).filter(function(S) {
          return S.contains(g.target);
        }), C = x.length > 0 ? a(g, x[0]) : !s.current.noIsolation;
        C && g.cancelable && g.preventDefault();
      }
    }
  }, []), c = P.useCallback(function(m, g, v, w) {
    var x = { name: m, delta: g, target: v, should: w, shadowParent: NK(v) };
    t.current.push(x), setTimeout(function() {
      t.current = t.current.filter(function(C) {
        return C !== x;
      });
    }, 1);
  }, []), u = P.useCallback(function(m) {
    n.current = Lf(m), r.current = void 0;
  }, []), d = P.useCallback(function(m) {
    c(m.type, wE(m), m.target, a(m, e.lockRef.current));
  }, []), f = P.useCallback(function(m) {
    c(m.type, Lf(m), m.target, a(m, e.lockRef.current));
  }, []);
  P.useEffect(function() {
    return tl.push(o), e.setCallbacks({
      onScrollCapture: d,
      onWheelCapture: d,
      onTouchMoveCapture: f
    }), document.addEventListener("wheel", l, el), document.addEventListener("touchmove", l, el), document.addEventListener("touchstart", u, el), function() {
      tl = tl.filter(function(m) {
        return m !== o;
      }), document.removeEventListener("wheel", l, el), document.removeEventListener("touchmove", l, el), document.removeEventListener("touchstart", u, el);
    };
  }, []);
  var h = e.removeScrollBar, p = e.inert;
  return P.createElement(
    P.Fragment,
    null,
    p ? P.createElement(o, { styles: PK(i) }) : null,
    h ? P.createElement(CK, { gapMode: e.gapMode }) : null
  );
}
function NK(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const DK = uK(ZI, BK);
var ly = P.forwardRef(function(e, t) {
  return P.createElement(ay, Jr({}, e, { ref: t, sideCar: DK }));
});
ly.classNames = ay.classNames;
function CE(e) {
  var t = e.match(/^var\((.*)\)$/);
  return t ? t[1] : e;
}
function jK(e, t) {
  var n = e;
  for (var r of t) {
    if (!(r in n))
      throw new Error("Path ".concat(t.join(" -> "), " does not exist in object"));
    n = n[r];
  }
  return n;
}
function i5(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], r = e.constructor();
  for (var i in e) {
    var o = e[i], s = [...n, i];
    typeof o == "string" || typeof o == "number" || o == null ? r[i] = t(o, s) : typeof o == "object" && !Array.isArray(o) && (r[i] = i5(o, t, s));
  }
  return r;
}
function kE(e, t) {
  var n = {};
  if (typeof t == "object") {
    var r = e;
    i5(t, (a, l) => {
      if (a != null) {
        var c = jK(r, l);
        n[CE(c)] = String(a);
      }
    });
  } else {
    var i = e;
    for (var o in i) {
      var s = i[o];
      s != null && (n[CE(o)] = s);
    }
  }
  return Object.defineProperty(n, "toString", {
    value: function() {
      return Object.keys(this).map((l) => "".concat(l, ":").concat(this[l])).join(";");
    },
    writable: !1
  }), n;
}
var Fb = { exports: {} };
(function(e, t) {
  (function(n, r) {
    var i = "1.0.37", o = "", s = "?", a = "function", l = "undefined", c = "object", u = "string", d = "major", f = "model", h = "name", p = "type", m = "vendor", g = "version", v = "architecture", w = "console", x = "mobile", C = "tablet", S = "smarttv", k = "wearable", A = "embedded", b = 500, T = "Amazon", R = "Apple", B = "ASUS", O = "BlackBerry", L = "Browser", V = "Chrome", N = "Edge", M = "Firefox", U = "Google", F = "Huawei", $ = "LG", ie = "Microsoft", he = "Motorola", ae = "Opera", se = "Samsung", oe = "Sharp", ye = "Sony", ve = "Xiaomi", Be = "Zebra", it = "Facebook", lt = "Chromium OS", yt = "Mac OS", gt = function(Ve, nt) {
      var je = {};
      for (var st in Ve)
        nt[st] && nt[st].length % 2 === 0 ? je[st] = nt[st].concat(Ve[st]) : je[st] = Ve[st];
      return je;
    }, vt = function(Ve) {
      for (var nt = {}, je = 0; je < Ve.length; je++)
        nt[Ve[je].toUpperCase()] = Ve[je];
      return nt;
    }, ot = function(Ve, nt) {
      return typeof Ve === u ? Le(nt).indexOf(Le(Ve)) !== -1 : !1;
    }, Le = function(Ve) {
      return Ve.toLowerCase();
    }, tt = function(Ve) {
      return typeof Ve === u ? Ve.replace(/[^\d\.]/g, o).split(".")[0] : r;
    }, jt = function(Ve, nt) {
      if (typeof Ve === u)
        return Ve = Ve.replace(/^\s\s*/, o), typeof nt === l ? Ve : Ve.substring(0, b);
    }, rn = function(Ve, nt) {
      for (var je = 0, st, tn, D, E, _, q; je < nt.length && !_; ) {
        var Z = nt[je], re = nt[je + 1];
        for (st = tn = 0; st < Z.length && !_ && Z[st]; )
          if (_ = Z[st++].exec(Ve), _)
            for (D = 0; D < re.length; D++)
              q = _[++tn], E = re[D], typeof E === c && E.length > 0 ? E.length === 2 ? typeof E[1] == a ? this[E[0]] = E[1].call(this, q) : this[E[0]] = E[1] : E.length === 3 ? typeof E[1] === a && !(E[1].exec && E[1].test) ? this[E[0]] = q ? E[1].call(this, q, E[2]) : r : this[E[0]] = q ? q.replace(E[1], E[2]) : r : E.length === 4 && (this[E[0]] = q ? E[3].call(this, q.replace(E[1], E[2])) : r) : this[E] = q || r;
        je += 2;
      }
    }, en = function(Ve, nt) {
      for (var je in nt)
        if (typeof nt[je] === c && nt[je].length > 0) {
          for (var st = 0; st < nt[je].length; st++)
            if (ot(nt[je][st], Ve))
              return je === s ? r : je;
        } else if (ot(nt[je], Ve))
          return je === s ? r : je;
      return Ve;
    }, Gt = {
      "1.0": "/8",
      "1.2": "/1",
      "1.3": "/3",
      "2.0": "/412",
      "2.0.2": "/416",
      "2.0.3": "/417",
      "2.0.4": "/419",
      "?": "/"
    }, jn = {
      ME: "4.90",
      "NT 3.11": "NT3.51",
      "NT 4.0": "NT4.0",
      2e3: "NT 5.0",
      XP: ["NT 5.1", "NT 5.2"],
      Vista: "NT 6.0",
      7: "NT 6.1",
      8: "NT 6.2",
      "8.1": "NT 6.3",
      10: ["NT 6.4", "NT 10.0"],
      RT: "ARM"
    }, tr = {
      browser: [
        [
          /\b(?:crmo|crios)\/([\w\.]+)/i
          // Chrome for Android/iOS
        ],
        [g, [h, "Chrome"]],
        [
          /edg(?:e|ios|a)?\/([\w\.]+)/i
          // Microsoft Edge
        ],
        [g, [h, "Edge"]],
        [
          // Presto based
          /(opera mini)\/([-\w\.]+)/i,
          // Opera Mini
          /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
          // Opera Mobi/Tablet
          /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i
          // Opera
        ],
        [h, g],
        [
          /opios[\/ ]+([\w\.]+)/i
          // Opera mini on iphone >= 8.0
        ],
        [g, [h, ae + " Mini"]],
        [
          /\bopr\/([\w\.]+)/i
          // Opera Webkit
        ],
        [g, [h, ae]],
        [
          // Mixed
          /\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i
          // Baidu
        ],
        [g, [h, "Baidu"]],
        [
          /(kindle)\/([\w\.]+)/i,
          // Kindle
          /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i,
          // Lunascape/Maxthon/Netfront/Jasmine/Blazer
          // Trident based
          /(avant|iemobile|slim)\s?(?:browser)?[\/ ]?([\w\.]*)/i,
          // Avant/IEMobile/SlimBrowser
          /(?:ms|\()(ie) ([\w\.]+)/i,
          // Internet Explorer
          // Webkit/KHTML based                                               // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
          /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i,
          // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ, aka ShouQ
          /(heytap|ovi)browser\/([\d\.]+)/i,
          // Heytap/Ovi
          /(weibo)__([\d\.]+)/i
          // Weibo
        ],
        [h, g],
        [
          /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i
          // UCBrowser
        ],
        [g, [h, "UC" + L]],
        [
          /microm.+\bqbcore\/([\w\.]+)/i,
          // WeChat Desktop for Windows Built-in Browser
          /\bqbcore\/([\w\.]+).+microm/i,
          /micromessenger\/([\w\.]+)/i
          // WeChat
        ],
        [g, [h, "WeChat"]],
        [
          /konqueror\/([\w\.]+)/i
          // Konqueror
        ],
        [g, [h, "Konqueror"]],
        [
          /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i
          // IE11
        ],
        [g, [h, "IE"]],
        [
          /ya(?:search)?browser\/([\w\.]+)/i
          // Yandex
        ],
        [g, [h, "Yandex"]],
        [
          /slbrowser\/([\w\.]+)/i
          // Smart Lenovo Browser
        ],
        [g, [h, "Smart Lenovo " + L]],
        [
          /(avast|avg)\/([\w\.]+)/i
          // Avast/AVG Secure Browser
        ],
        [[h, /(.+)/, "$1 Secure " + L], g],
        [
          /\bfocus\/([\w\.]+)/i
          // Firefox Focus
        ],
        [g, [h, M + " Focus"]],
        [
          /\bopt\/([\w\.]+)/i
          // Opera Touch
        ],
        [g, [h, ae + " Touch"]],
        [
          /coc_coc\w+\/([\w\.]+)/i
          // Coc Coc Browser
        ],
        [g, [h, "Coc Coc"]],
        [
          /dolfin\/([\w\.]+)/i
          // Dolphin
        ],
        [g, [h, "Dolphin"]],
        [
          /coast\/([\w\.]+)/i
          // Opera Coast
        ],
        [g, [h, ae + " Coast"]],
        [
          /miuibrowser\/([\w\.]+)/i
          // MIUI Browser
        ],
        [g, [h, "MIUI " + L]],
        [
          /fxios\/([-\w\.]+)/i
          // Firefox for iOS
        ],
        [g, [h, M]],
        [
          /\bqihu|(qi?ho?o?|360)browser/i
          // 360
        ],
        [[h, "360 " + L]],
        [
          /(oculus|sailfish|huawei|vivo)browser\/([\w\.]+)/i
        ],
        [[h, /(.+)/, "$1 " + L], g],
        [
          // Oculus/Sailfish/HuaweiBrowser/VivoBrowser
          /samsungbrowser\/([\w\.]+)/i
          // Samsung Internet
        ],
        [g, [h, se + " Internet"]],
        [
          /(comodo_dragon)\/([\w\.]+)/i
          // Comodo Dragon
        ],
        [[h, /_/g, " "], g],
        [
          /metasr[\/ ]?([\d\.]+)/i
          // Sogou Explorer
        ],
        [g, [h, "Sogou Explorer"]],
        [
          /(sogou)mo\w+\/([\d\.]+)/i
          // Sogou Mobile
        ],
        [[h, "Sogou Mobile"], g],
        [
          /(electron)\/([\w\.]+) safari/i,
          // Electron-based App
          /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
          // Tesla
          /m?(qqbrowser|2345Explorer)[\/ ]?([\w\.]+)/i
          // QQBrowser/2345 Browser
        ],
        [h, g],
        [
          /(lbbrowser)/i,
          // LieBao Browser
          /\[(linkedin)app\]/i
          // LinkedIn App for iOS & Android
        ],
        [h],
        [
          // WebView
          /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i
          // Facebook App for iOS & Android
        ],
        [[h, it], g],
        [
          /(Klarna)\/([\w\.]+)/i,
          // Klarna Shopping Browser for iOS & Android
          /(kakao(?:talk|story))[\/ ]([\w\.]+)/i,
          // Kakao App
          /(naver)\(.*?(\d+\.[\w\.]+).*\)/i,
          // Naver InApp
          /safari (line)\/([\w\.]+)/i,
          // Line App for iOS
          /\b(line)\/([\w\.]+)\/iab/i,
          // Line App for Android
          /(alipay)client\/([\w\.]+)/i,
          // Alipay
          /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i
          // Chromium/Instagram/Snapchat
        ],
        [h, g],
        [
          /\bgsa\/([\w\.]+) .*safari\//i
          // Google Search Appliance on iOS
        ],
        [g, [h, "GSA"]],
        [
          /musical_ly(?:.+app_?version\/|_)([\w\.]+)/i
          // TikTok
        ],
        [g, [h, "TikTok"]],
        [
          /headlesschrome(?:\/([\w\.]+)| )/i
          // Chrome Headless
        ],
        [g, [h, V + " Headless"]],
        [
          / wv\).+(chrome)\/([\w\.]+)/i
          // Chrome WebView
        ],
        [[h, V + " WebView"], g],
        [
          /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i
          // Android Browser
        ],
        [g, [h, "Android " + L]],
        [
          /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i
          // Chrome/OmniWeb/Arora/Tizen/Nokia
        ],
        [h, g],
        [
          /version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i
          // Mobile Safari
        ],
        [g, [h, "Mobile Safari"]],
        [
          /version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i
          // Safari & Safari Mobile
        ],
        [g, h],
        [
          /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i
          // Safari < 3.0
        ],
        [h, [g, en, Gt]],
        [
          /(webkit|khtml)\/([\w\.]+)/i
        ],
        [h, g],
        [
          // Gecko based
          /(navigator|netscape\d?)\/([-\w\.]+)/i
          // Netscape
        ],
        [[h, "Netscape"], g],
        [
          /mobile vr; rv:([\w\.]+)\).+firefox/i
          // Firefox Reality
        ],
        [g, [h, M + " Reality"]],
        [
          /ekiohf.+(flow)\/([\w\.]+)/i,
          // Flow
          /(swiftfox)/i,
          // Swiftfox
          /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i,
          // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror/Klar
          /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
          // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
          /(firefox)\/([\w\.]+)/i,
          // Other Firefox-based
          /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
          // Mozilla
          // Other
          /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
          // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir/Obigo/Mosaic/Go/ICE/UP.Browser
          /(links) \(([\w\.]+)/i,
          // Links
          /panasonic;(viera)/i
          // Panasonic Viera
        ],
        [h, g],
        [
          /(cobalt)\/([\w\.]+)/i
          // Cobalt
        ],
        [h, [g, /master.|lts./, ""]]
      ],
      cpu: [
        [
          /(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i
          // AMD64 (x64)
        ],
        [[v, "amd64"]],
        [
          /(ia32(?=;))/i
          // IA32 (quicktime)
        ],
        [[v, Le]],
        [
          /((?:i[346]|x)86)[;\)]/i
          // IA32 (x86)
        ],
        [[v, "ia32"]],
        [
          /\b(aarch64|arm(v?8e?l?|_?64))\b/i
          // ARM64
        ],
        [[v, "arm64"]],
        [
          /\b(arm(?:v[67])?ht?n?[fl]p?)\b/i
          // ARMHF
        ],
        [[v, "armhf"]],
        [
          // PocketPC mistakenly identified as PowerPC
          /windows (ce|mobile); ppc;/i
        ],
        [[v, "arm"]],
        [
          /((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i
          // PowerPC
        ],
        [[v, /ower/, o, Le]],
        [
          /(sun4\w)[;\)]/i
          // SPARC
        ],
        [[v, "sparc"]],
        [
          /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i
          // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
        ],
        [[v, Le]]
      ],
      device: [
        [
          //////////////////////////
          // MOBILES & TABLETS
          /////////////////////////
          // Samsung
          /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i
        ],
        [f, [m, se], [p, C]],
        [
          /\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,
          /samsung[- ]([-\w]+)/i,
          /sec-(sgh\w+)/i
        ],
        [f, [m, se], [p, x]],
        [
          // Apple
          /(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i
          // iPod/iPhone
        ],
        [f, [m, R], [p, x]],
        [
          /\((ipad);[-\w\),; ]+apple/i,
          // iPad
          /applecoremedia\/[\w\.]+ \((ipad)/i,
          /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
        ],
        [f, [m, R], [p, C]],
        [
          /(macintosh);/i
        ],
        [f, [m, R]],
        [
          // Sharp
          /\b(sh-?[altvz]?\d\d[a-ekm]?)/i
        ],
        [f, [m, oe], [p, x]],
        [
          // Huawei
          /\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i
        ],
        [f, [m, F], [p, C]],
        [
          /(?:huawei|honor)([-\w ]+)[;\)]/i,
          /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i
        ],
        [f, [m, F], [p, x]],
        [
          // Xiaomi
          /\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i,
          // Xiaomi POCO
          /\b; (\w+) build\/hm\1/i,
          // Xiaomi Hongmi 'numeric' models
          /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
          // Xiaomi Hongmi
          /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
          // Xiaomi Redmi
          /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i,
          // Xiaomi Redmi 'numeric' models
          /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i
          // Xiaomi Mi
        ],
        [[f, /_/g, " "], [m, ve], [p, x]],
        [
          /oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i,
          // Redmi Pad
          /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i
          // Mi Pad tablets
        ],
        [[f, /_/g, " "], [m, ve], [p, C]],
        [
          // OPPO
          /; (\w+) bui.+ oppo/i,
          /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
        ],
        [f, [m, "OPPO"], [p, x]],
        [
          // Vivo
          /vivo (\w+)(?: bui|\))/i,
          /\b(v[12]\d{3}\w?[at])(?: bui|;)/i
        ],
        [f, [m, "Vivo"], [p, x]],
        [
          // Realme
          /\b(rmx[1-3]\d{3})(?: bui|;|\))/i
        ],
        [f, [m, "Realme"], [p, x]],
        [
          // Motorola
          /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
          /\bmot(?:orola)?[- ](\w*)/i,
          /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i
        ],
        [f, [m, he], [p, x]],
        [
          /\b(mz60\d|xoom[2 ]{0,2}) build\//i
        ],
        [f, [m, he], [p, C]],
        [
          // LG
          /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i
        ],
        [f, [m, $], [p, C]],
        [
          /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
          /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,
          /\blg-?([\d\w]+) bui/i
        ],
        [f, [m, $], [p, x]],
        [
          // Lenovo
          /(ideatab[-\w ]+)/i,
          /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i
        ],
        [f, [m, "Lenovo"], [p, C]],
        [
          // Nokia
          /(?:maemo|nokia).*(n900|lumia \d+)/i,
          /nokia[-_ ]?([-\w\.]*)/i
        ],
        [[f, /_/g, " "], [m, "Nokia"], [p, x]],
        [
          // Google
          /(pixel c)\b/i
          // Google Pixel C
        ],
        [f, [m, U], [p, C]],
        [
          /droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i
          // Google Pixel
        ],
        [f, [m, U], [p, x]],
        [
          // Sony
          /droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
        ],
        [f, [m, ye], [p, x]],
        [
          /sony tablet [ps]/i,
          /\b(?:sony)?sgp\w+(?: bui|\))/i
        ],
        [[f, "Xperia Tablet"], [m, ye], [p, C]],
        [
          // OnePlus
          / (kb2005|in20[12]5|be20[12][59])\b/i,
          /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
        ],
        [f, [m, "OnePlus"], [p, x]],
        [
          // Amazon
          /(alexa)webm/i,
          /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i,
          // Kindle Fire without Silk / Echo Show
          /(kf[a-z]+)( bui|\)).+silk\//i
          // Kindle Fire HD
        ],
        [f, [m, T], [p, C]],
        [
          /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i
          // Fire Phone
        ],
        [[f, /(.+)/g, "Fire Phone $1"], [m, T], [p, x]],
        [
          // BlackBerry
          /(playbook);[-\w\),; ]+(rim)/i
          // BlackBerry PlayBook
        ],
        [f, m, [p, C]],
        [
          /\b((?:bb[a-f]|st[hv])100-\d)/i,
          /\(bb10; (\w+)/i
          // BlackBerry 10
        ],
        [f, [m, O], [p, x]],
        [
          // Asus
          /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i
        ],
        [f, [m, B], [p, C]],
        [
          / (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i
        ],
        [f, [m, B], [p, x]],
        [
          // HTC
          /(nexus 9)/i
          // HTC Nexus 9
        ],
        [f, [m, "HTC"], [p, C]],
        [
          /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
          // HTC
          // ZTE
          /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
          /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i
          // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
        ],
        [m, [f, /_/g, " "], [p, x]],
        [
          // Acer
          /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i
        ],
        [f, [m, "Acer"], [p, C]],
        [
          // Meizu
          /droid.+; (m[1-5] note) bui/i,
          /\bmz-([-\w]{2,})/i
        ],
        [f, [m, "Meizu"], [p, x]],
        [
          // Ulefone
          /; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i
        ],
        [f, [m, "Ulefone"], [p, x]],
        [
          // MIXED
          /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno)[-_ ]?([-\w]*)/i,
          // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron
          /(hp) ([\w ]+\w)/i,
          // HP iPAQ
          /(asus)-?(\w+)/i,
          // Asus
          /(microsoft); (lumia[\w ]+)/i,
          // Microsoft Lumia
          /(lenovo)[-_ ]?([-\w]+)/i,
          // Lenovo
          /(jolla)/i,
          // Jolla
          /(oppo) ?([\w ]+) bui/i
          // OPPO
        ],
        [m, f, [p, x]],
        [
          /(kobo)\s(ereader|touch)/i,
          // Kobo
          /(archos) (gamepad2?)/i,
          // Archos
          /(hp).+(touchpad(?!.+tablet)|tablet)/i,
          // HP TouchPad
          /(kindle)\/([\w\.]+)/i,
          // Kindle
          /(nook)[\w ]+build\/(\w+)/i,
          // Nook
          /(dell) (strea[kpr\d ]*[\dko])/i,
          // Dell Streak
          /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
          // Le Pan Tablets
          /(trinity)[- ]*(t\d{3}) bui/i,
          // Trinity Tablets
          /(gigaset)[- ]+(q\w{1,9}) bui/i,
          // Gigaset Tablets
          /(vodafone) ([\w ]+)(?:\)| bui)/i
          // Vodafone
        ],
        [m, f, [p, C]],
        [
          /(surface duo)/i
          // Surface Duo
        ],
        [f, [m, ie], [p, C]],
        [
          /droid [\d\.]+; (fp\du?)(?: b|\))/i
          // Fairphone
        ],
        [f, [m, "Fairphone"], [p, x]],
        [
          /(u304aa)/i
          // AT&T
        ],
        [f, [m, "AT&T"], [p, x]],
        [
          /\bsie-(\w*)/i
          // Siemens
        ],
        [f, [m, "Siemens"], [p, x]],
        [
          /\b(rct\w+) b/i
          // RCA Tablets
        ],
        [f, [m, "RCA"], [p, C]],
        [
          /\b(venue[\d ]{2,7}) b/i
          // Dell Venue Tablets
        ],
        [f, [m, "Dell"], [p, C]],
        [
          /\b(q(?:mv|ta)\w+) b/i
          // Verizon Tablet
        ],
        [f, [m, "Verizon"], [p, C]],
        [
          /\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i
          // Barnes & Noble Tablet
        ],
        [f, [m, "Barnes & Noble"], [p, C]],
        [
          /\b(tm\d{3}\w+) b/i
        ],
        [f, [m, "NuVision"], [p, C]],
        [
          /\b(k88) b/i
          // ZTE K Series Tablet
        ],
        [f, [m, "ZTE"], [p, C]],
        [
          /\b(nx\d{3}j) b/i
          // ZTE Nubia
        ],
        [f, [m, "ZTE"], [p, x]],
        [
          /\b(gen\d{3}) b.+49h/i
          // Swiss GEN Mobile
        ],
        [f, [m, "Swiss"], [p, x]],
        [
          /\b(zur\d{3}) b/i
          // Swiss ZUR Tablet
        ],
        [f, [m, "Swiss"], [p, C]],
        [
          /\b((zeki)?tb.*\b) b/i
          // Zeki Tablets
        ],
        [f, [m, "Zeki"], [p, C]],
        [
          /\b([yr]\d{2}) b/i,
          /\b(dragon[- ]+touch |dt)(\w{5}) b/i
          // Dragon Touch Tablet
        ],
        [[m, "Dragon Touch"], f, [p, C]],
        [
          /\b(ns-?\w{0,9}) b/i
          // Insignia Tablets
        ],
        [f, [m, "Insignia"], [p, C]],
        [
          /\b((nxa|next)-?\w{0,9}) b/i
          // NextBook Tablets
        ],
        [f, [m, "NextBook"], [p, C]],
        [
          /\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i
          // Voice Xtreme Phones
        ],
        [[m, "Voice"], f, [p, x]],
        [
          /\b(lvtel\-)?(v1[12]) b/i
          // LvTel Phones
        ],
        [[m, "LvTel"], f, [p, x]],
        [
          /\b(ph-1) /i
          // Essential PH-1
        ],
        [f, [m, "Essential"], [p, x]],
        [
          /\b(v(100md|700na|7011|917g).*\b) b/i
          // Envizen Tablets
        ],
        [f, [m, "Envizen"], [p, C]],
        [
          /\b(trio[-\w\. ]+) b/i
          // MachSpeed Tablets
        ],
        [f, [m, "MachSpeed"], [p, C]],
        [
          /\btu_(1491) b/i
          // Rotor Tablets
        ],
        [f, [m, "Rotor"], [p, C]],
        [
          /(shield[\w ]+) b/i
          // Nvidia Shield Tablets
        ],
        [f, [m, "Nvidia"], [p, C]],
        [
          /(sprint) (\w+)/i
          // Sprint Phones
        ],
        [m, f, [p, x]],
        [
          /(kin\.[onetw]{3})/i
          // Microsoft Kin
        ],
        [[f, /\./g, " "], [m, ie], [p, x]],
        [
          /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i
          // Zebra
        ],
        [f, [m, Be], [p, C]],
        [
          /droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i
        ],
        [f, [m, Be], [p, x]],
        [
          ///////////////////
          // SMARTTVS
          ///////////////////
          /smart-tv.+(samsung)/i
          // Samsung
        ],
        [m, [p, S]],
        [
          /hbbtv.+maple;(\d+)/i
        ],
        [[f, /^/, "SmartTV"], [m, se], [p, S]],
        [
          /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i
          // LG SmartTV
        ],
        [[m, $], [p, S]],
        [
          /(apple) ?tv/i
          // Apple TV
        ],
        [m, [f, R + " TV"], [p, S]],
        [
          /crkey/i
          // Google Chromecast
        ],
        [[f, V + "cast"], [m, U], [p, S]],
        [
          /droid.+aft(\w+)( bui|\))/i
          // Fire TV
        ],
        [f, [m, T], [p, S]],
        [
          /\(dtv[\);].+(aquos)/i,
          /(aquos-tv[\w ]+)\)/i
          // Sharp
        ],
        [f, [m, oe], [p, S]],
        [
          /(bravia[\w ]+)( bui|\))/i
          // Sony
        ],
        [f, [m, ye], [p, S]],
        [
          /(mitv-\w{5}) bui/i
          // Xiaomi
        ],
        [f, [m, ve], [p, S]],
        [
          /Hbbtv.*(technisat) (.*);/i
          // TechniSAT
        ],
        [m, f, [p, S]],
        [
          /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
          // Roku
          /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i
          // HbbTV devices
        ],
        [[m, jt], [f, jt], [p, S]],
        [
          /\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i
          // SmartTV from Unidentified Vendors
        ],
        [[p, S]],
        [
          ///////////////////
          // CONSOLES
          ///////////////////
          /(ouya)/i,
          // Ouya
          /(nintendo) ([wids3utch]+)/i
          // Nintendo
        ],
        [m, f, [p, w]],
        [
          /droid.+; (shield) bui/i
          // Nvidia
        ],
        [f, [m, "Nvidia"], [p, w]],
        [
          /(playstation [345portablevi]+)/i
          // Playstation
        ],
        [f, [m, ye], [p, w]],
        [
          /\b(xbox(?: one)?(?!; xbox))[\); ]/i
          // Microsoft Xbox
        ],
        [f, [m, ie], [p, w]],
        [
          ///////////////////
          // WEARABLES
          ///////////////////
          /((pebble))app/i
          // Pebble
        ],
        [m, f, [p, k]],
        [
          /(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i
          // Apple Watch
        ],
        [f, [m, R], [p, k]],
        [
          /droid.+; (glass) \d/i
          // Google Glass
        ],
        [f, [m, U], [p, k]],
        [
          /droid.+; (wt63?0{2,3})\)/i
        ],
        [f, [m, Be], [p, k]],
        [
          /(quest( 2| pro)?)/i
          // Oculus Quest
        ],
        [f, [m, it], [p, k]],
        [
          ///////////////////
          // EMBEDDED
          ///////////////////
          /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i
          // Tesla
        ],
        [m, [p, A]],
        [
          /(aeobc)\b/i
          // Echo Dot
        ],
        [f, [m, T], [p, A]],
        [
          ////////////////////
          // MIXED (GENERIC)
          ///////////////////
          /droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i
          // Android Phones from Unidentified Vendors
        ],
        [f, [p, x]],
        [
          /droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i
          // Android Tablets from Unidentified Vendors
        ],
        [f, [p, C]],
        [
          /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i
          // Unidentifiable Tablet
        ],
        [[p, C]],
        [
          /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i
          // Unidentifiable Mobile
        ],
        [[p, x]],
        [
          /(android[-\w\. ]{0,9});.+buil/i
          // Generic Android Device
        ],
        [f, [m, "Generic"]]
      ],
      engine: [
        [
          /windows.+ edge\/([\w\.]+)/i
          // EdgeHTML
        ],
        [g, [h, N + "HTML"]],
        [
          /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i
          // Blink
        ],
        [g, [h, "Blink"]],
        [
          /(presto)\/([\w\.]+)/i,
          // Presto
          /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i,
          // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna
          /ekioh(flow)\/([\w\.]+)/i,
          // Flow
          /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
          // KHTML/Tasman/Links
          /(icab)[\/ ]([23]\.[\d\.]+)/i,
          // iCab
          /\b(libweb)/i
        ],
        [h, g],
        [
          /rv\:([\w\.]{1,9})\b.+(gecko)/i
          // Gecko
        ],
        [g, h]
      ],
      os: [
        [
          // Windows
          /microsoft (windows) (vista|xp)/i
          // Windows (iTunes)
        ],
        [h, g],
        [
          /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i
          // Windows Phone
        ],
        [h, [g, en, jn]],
        [
          /windows nt 6\.2; (arm)/i,
          // Windows RT
          /windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i,
          /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i
        ],
        [[g, en, jn], [h, "Windows"]],
        [
          // iOS/macOS
          /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,
          // iOS
          /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i,
          /cfnetwork\/.+darwin/i
        ],
        [[g, /_/g, "."], [h, "iOS"]],
        [
          /(mac os x) ?([\w\. ]*)/i,
          /(macintosh|mac_powerpc\b)(?!.+haiku)/i
          // Mac OS
        ],
        [[h, yt], [g, /_/g, "."]],
        [
          // Mobile OSes
          /droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i
          // Android-x86/HarmonyOS
        ],
        [g, h],
        [
          // Android/WebOS/QNX/Bada/RIM/Maemo/MeeGo/Sailfish OS
          /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i,
          /(blackberry)\w*\/([\w\.]*)/i,
          // Blackberry
          /(tizen|kaios)[\/ ]([\w\.]+)/i,
          // Tizen/KaiOS
          /\((series40);/i
          // Series 40
        ],
        [h, g],
        [
          /\(bb(10);/i
          // BlackBerry 10
        ],
        [g, [h, O]],
        [
          /(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i
          // Symbian
        ],
        [g, [h, "Symbian"]],
        [
          /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i
          // Firefox OS
        ],
        [g, [h, M + " OS"]],
        [
          /web0s;.+rt(tv)/i,
          /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i
          // WebOS
        ],
        [g, [h, "webOS"]],
        [
          /watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i
          // watchOS
        ],
        [g, [h, "watchOS"]],
        [
          // Google Chromecast
          /crkey\/([\d\.]+)/i
          // Google Chromecast
        ],
        [g, [h, V + "cast"]],
        [
          /(cros) [\w]+(?:\)| ([\w\.]+)\b)/i
          // Chromium OS
        ],
        [[h, lt], g],
        [
          // Smart TVs
          /panasonic;(viera)/i,
          // Panasonic Viera
          /(netrange)mmh/i,
          // Netrange
          /(nettv)\/(\d+\.[\w\.]+)/i,
          // NetTV
          // Console
          /(nintendo|playstation) ([wids345portablevuch]+)/i,
          // Nintendo/Playstation
          /(xbox); +xbox ([^\);]+)/i,
          // Microsoft Xbox (360, One, X, S, Series X, Series S)
          // Other
          /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
          // Joli/Palm
          /(mint)[\/\(\) ]?(\w*)/i,
          // Mint
          /(mageia|vectorlinux)[; ]/i,
          // Mageia/VectorLinux
          /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
          // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire
          /(hurd|linux) ?([\w\.]*)/i,
          // Hurd/Linux
          /(gnu) ?([\w\.]*)/i,
          // GNU
          /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
          // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly
          /(haiku) (\w+)/i
          // Haiku
        ],
        [h, g],
        [
          /(sunos) ?([\w\.\d]*)/i
          // Solaris
        ],
        [[h, "Solaris"], g],
        [
          /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
          // Solaris
          /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
          // AIX
          /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i,
          // BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX/SerenityOS
          /(unix) ?([\w\.]*)/i
          // UNIX
        ],
        [h, g]
      ]
    }, Ot = function(Ve, nt) {
      if (typeof Ve === c && (nt = Ve, Ve = r), !(this instanceof Ot))
        return new Ot(Ve, nt).getResult();
      var je = typeof n !== l && n.navigator ? n.navigator : r, st = Ve || (je && je.userAgent ? je.userAgent : o), tn = je && je.userAgentData ? je.userAgentData : r, D = nt ? gt(tr, nt) : tr, E = je && je.userAgent == st;
      return this.getBrowser = function() {
        var _ = {};
        return _[h] = r, _[g] = r, rn.call(_, st, D.browser), _[d] = tt(_[g]), E && je && je.brave && typeof je.brave.isBrave == a && (_[h] = "Brave"), _;
      }, this.getCPU = function() {
        var _ = {};
        return _[v] = r, rn.call(_, st, D.cpu), _;
      }, this.getDevice = function() {
        var _ = {};
        return _[m] = r, _[f] = r, _[p] = r, rn.call(_, st, D.device), E && !_[p] && tn && tn.mobile && (_[p] = x), E && _[f] == "Macintosh" && je && typeof je.standalone !== l && je.maxTouchPoints && je.maxTouchPoints > 2 && (_[f] = "iPad", _[p] = C), _;
      }, this.getEngine = function() {
        var _ = {};
        return _[h] = r, _[g] = r, rn.call(_, st, D.engine), _;
      }, this.getOS = function() {
        var _ = {};
        return _[h] = r, _[g] = r, rn.call(_, st, D.os), E && !_[h] && tn && tn.platform != "Unknown" && (_[h] = tn.platform.replace(/chrome os/i, lt).replace(/macos/i, yt)), _;
      }, this.getResult = function() {
        return {
          ua: this.getUA(),
          browser: this.getBrowser(),
          engine: this.getEngine(),
          os: this.getOS(),
          device: this.getDevice(),
          cpu: this.getCPU()
        };
      }, this.getUA = function() {
        return st;
      }, this.setUA = function(_) {
        return st = typeof _ === u && _.length > b ? jt(_, b) : _, this;
      }, this.setUA(st), this;
    };
    Ot.VERSION = i, Ot.BROWSER = vt([h, g, d]), Ot.CPU = vt([v]), Ot.DEVICE = vt([f, m, p, w, x, S, C, k, A]), Ot.ENGINE = Ot.OS = vt([h, g]), e.exports && (t = e.exports = Ot), t.UAParser = Ot;
    var qt = typeof n !== l && (n.jQuery || n.Zepto);
    if (qt && !qt.ua) {
      var Cn = new Ot();
      qt.ua = Cn.getResult(), qt.ua.get = function() {
        return Cn.getUA();
      }, qt.ua.set = function(Ve) {
        Cn.setUA(Ve);
        var nt = Cn.getResult();
        for (var je in nt)
          qt.ua[je] = nt[je];
      };
    }
  })(typeof window == "object" ? window : pu);
})(Fb, Fb.exports);
var MK = Fb.exports, Gd = {}, FK = function() {
  return typeof Promise == "function" && Promise.prototype && Promise.prototype.then;
}, o5 = {}, Mr = {};
let Hw;
const LK = [
  0,
  // Not used
  26,
  44,
  70,
  100,
  134,
  172,
  196,
  242,
  292,
  346,
  404,
  466,
  532,
  581,
  655,
  733,
  815,
  901,
  991,
  1085,
  1156,
  1258,
  1364,
  1474,
  1588,
  1706,
  1828,
  1921,
  2051,
  2185,
  2323,
  2465,
  2611,
  2761,
  2876,
  3034,
  3196,
  3362,
  3532,
  3706
];
Mr.getSymbolSize = function(t) {
  if (!t) throw new Error('"version" cannot be null or undefined');
  if (t < 1 || t > 40) throw new Error('"version" should be in range from 1 to 40');
  return t * 4 + 17;
};
Mr.getSymbolTotalCodewords = function(t) {
  return LK[t];
};
Mr.getBCHDigit = function(e) {
  let t = 0;
  for (; e !== 0; )
    t++, e >>>= 1;
  return t;
};
Mr.setToSJISFunction = function(t) {
  if (typeof t != "function")
    throw new Error('"toSJISFunc" is not a valid function.');
  Hw = t;
};
Mr.isKanjiModeEnabled = function() {
  return typeof Hw < "u";
};
Mr.toSJIS = function(t) {
  return Hw(t);
};
var cy = {};
(function(e) {
  e.L = { bit: 1 }, e.M = { bit: 0 }, e.Q = { bit: 3 }, e.H = { bit: 2 };
  function t(n) {
    if (typeof n != "string")
      throw new Error("Param is not a string");
    switch (n.toLowerCase()) {
      case "l":
      case "low":
        return e.L;
      case "m":
      case "medium":
        return e.M;
      case "q":
      case "quartile":
        return e.Q;
      case "h":
      case "high":
        return e.H;
      default:
        throw new Error("Unknown EC Level: " + n);
    }
  }
  e.isValid = function(r) {
    return r && typeof r.bit < "u" && r.bit >= 0 && r.bit < 4;
  }, e.from = function(r, i) {
    if (e.isValid(r))
      return r;
    try {
      return t(r);
    } catch {
      return i;
    }
  };
})(cy);
function s5() {
  this.buffer = [], this.length = 0;
}
s5.prototype = {
  get: function(e) {
    const t = Math.floor(e / 8);
    return (this.buffer[t] >>> 7 - e % 8 & 1) === 1;
  },
  put: function(e, t) {
    for (let n = 0; n < t; n++)
      this.putBit((e >>> t - n - 1 & 1) === 1);
  },
  getLengthInBits: function() {
    return this.length;
  },
  putBit: function(e) {
    const t = Math.floor(this.length / 8);
    this.buffer.length <= t && this.buffer.push(0), e && (this.buffer[t] |= 128 >>> this.length % 8), this.length++;
  }
};
var UK = s5;
function Hd(e) {
  if (!e || e < 1)
    throw new Error("BitMatrix size must be defined and greater than 0");
  this.size = e, this.data = new Uint8Array(e * e), this.reservedBit = new Uint8Array(e * e);
}
Hd.prototype.set = function(e, t, n, r) {
  const i = e * this.size + t;
  this.data[i] = n, r && (this.reservedBit[i] = !0);
};
Hd.prototype.get = function(e, t) {
  return this.data[e * this.size + t];
};
Hd.prototype.xor = function(e, t, n) {
  this.data[e * this.size + t] ^= n;
};
Hd.prototype.isReserved = function(e, t) {
  return this.reservedBit[e * this.size + t];
};
var zK = Hd, a5 = {};
(function(e) {
  const t = Mr.getSymbolSize;
  e.getRowColCoords = function(r) {
    if (r === 1) return [];
    const i = Math.floor(r / 7) + 2, o = t(r), s = o === 145 ? 26 : Math.ceil((o - 13) / (2 * i - 2)) * 2, a = [o - 7];
    for (let l = 1; l < i - 1; l++)
      a[l] = a[l - 1] - s;
    return a.push(6), a.reverse();
  }, e.getPositions = function(r) {
    const i = [], o = e.getRowColCoords(r), s = o.length;
    for (let a = 0; a < s; a++)
      for (let l = 0; l < s; l++)
        a === 0 && l === 0 || // top-left
        a === 0 && l === s - 1 || // bottom-left
        a === s - 1 && l === 0 || i.push([o[a], o[l]]);
    return i;
  };
})(a5);
var l5 = {};
const VK = Mr.getSymbolSize, EE = 7;
l5.getPositions = function(t) {
  const n = VK(t);
  return [
    // top-left
    [0, 0],
    // top-right
    [n - EE, 0],
    // bottom-left
    [0, n - EE]
  ];
};
var c5 = {};
(function(e) {
  e.Patterns = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7
  };
  const t = {
    N1: 3,
    N2: 3,
    N3: 40,
    N4: 10
  };
  e.isValid = function(i) {
    return i != null && i !== "" && !isNaN(i) && i >= 0 && i <= 7;
  }, e.from = function(i) {
    return e.isValid(i) ? parseInt(i, 10) : void 0;
  }, e.getPenaltyN1 = function(i) {
    const o = i.size;
    let s = 0, a = 0, l = 0, c = null, u = null;
    for (let d = 0; d < o; d++) {
      a = l = 0, c = u = null;
      for (let f = 0; f < o; f++) {
        let h = i.get(d, f);
        h === c ? a++ : (a >= 5 && (s += t.N1 + (a - 5)), c = h, a = 1), h = i.get(f, d), h === u ? l++ : (l >= 5 && (s += t.N1 + (l - 5)), u = h, l = 1);
      }
      a >= 5 && (s += t.N1 + (a - 5)), l >= 5 && (s += t.N1 + (l - 5));
    }
    return s;
  }, e.getPenaltyN2 = function(i) {
    const o = i.size;
    let s = 0;
    for (let a = 0; a < o - 1; a++)
      for (let l = 0; l < o - 1; l++) {
        const c = i.get(a, l) + i.get(a, l + 1) + i.get(a + 1, l) + i.get(a + 1, l + 1);
        (c === 4 || c === 0) && s++;
      }
    return s * t.N2;
  }, e.getPenaltyN3 = function(i) {
    const o = i.size;
    let s = 0, a = 0, l = 0;
    for (let c = 0; c < o; c++) {
      a = l = 0;
      for (let u = 0; u < o; u++)
        a = a << 1 & 2047 | i.get(c, u), u >= 10 && (a === 1488 || a === 93) && s++, l = l << 1 & 2047 | i.get(u, c), u >= 10 && (l === 1488 || l === 93) && s++;
    }
    return s * t.N3;
  }, e.getPenaltyN4 = function(i) {
    let o = 0;
    const s = i.data.length;
    for (let l = 0; l < s; l++) o += i.data[l];
    return Math.abs(Math.ceil(o * 100 / s / 5) - 10) * t.N4;
  };
  function n(r, i, o) {
    switch (r) {
      case e.Patterns.PATTERN000:
        return (i + o) % 2 === 0;
      case e.Patterns.PATTERN001:
        return i % 2 === 0;
      case e.Patterns.PATTERN010:
        return o % 3 === 0;
      case e.Patterns.PATTERN011:
        return (i + o) % 3 === 0;
      case e.Patterns.PATTERN100:
        return (Math.floor(i / 2) + Math.floor(o / 3)) % 2 === 0;
      case e.Patterns.PATTERN101:
        return i * o % 2 + i * o % 3 === 0;
      case e.Patterns.PATTERN110:
        return (i * o % 2 + i * o % 3) % 2 === 0;
      case e.Patterns.PATTERN111:
        return (i * o % 3 + (i + o) % 2) % 2 === 0;
      default:
        throw new Error("bad maskPattern:" + r);
    }
  }
  e.applyMask = function(i, o) {
    const s = o.size;
    for (let a = 0; a < s; a++)
      for (let l = 0; l < s; l++)
        o.isReserved(l, a) || o.xor(l, a, n(i, l, a));
  }, e.getBestMask = function(i, o) {
    const s = Object.keys(e.Patterns).length;
    let a = 0, l = 1 / 0;
    for (let c = 0; c < s; c++) {
      o(c), e.applyMask(c, i);
      const u = e.getPenaltyN1(i) + e.getPenaltyN2(i) + e.getPenaltyN3(i) + e.getPenaltyN4(i);
      e.applyMask(c, i), u < l && (l = u, a = c);
    }
    return a;
  };
})(c5);
var uy = {};
const ps = cy, Uf = [
  // L  M  Q  H
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  2,
  1,
  2,
  2,
  4,
  1,
  2,
  4,
  4,
  2,
  4,
  4,
  4,
  2,
  4,
  6,
  5,
  2,
  4,
  6,
  6,
  2,
  5,
  8,
  8,
  4,
  5,
  8,
  8,
  4,
  5,
  8,
  11,
  4,
  8,
  10,
  11,
  4,
  9,
  12,
  16,
  4,
  9,
  16,
  16,
  6,
  10,
  12,
  18,
  6,
  10,
  17,
  16,
  6,
  11,
  16,
  19,
  6,
  13,
  18,
  21,
  7,
  14,
  21,
  25,
  8,
  16,
  20,
  25,
  8,
  17,
  23,
  25,
  9,
  17,
  23,
  34,
  9,
  18,
  25,
  30,
  10,
  20,
  27,
  32,
  12,
  21,
  29,
  35,
  12,
  23,
  34,
  37,
  12,
  25,
  34,
  40,
  13,
  26,
  35,
  42,
  14,
  28,
  38,
  45,
  15,
  29,
  40,
  48,
  16,
  31,
  43,
  51,
  17,
  33,
  45,
  54,
  18,
  35,
  48,
  57,
  19,
  37,
  51,
  60,
  19,
  38,
  53,
  63,
  20,
  40,
  56,
  66,
  21,
  43,
  59,
  70,
  22,
  45,
  62,
  74,
  24,
  47,
  65,
  77,
  25,
  49,
  68,
  81
], zf = [
  // L  M  Q  H
  7,
  10,
  13,
  17,
  10,
  16,
  22,
  28,
  15,
  26,
  36,
  44,
  20,
  36,
  52,
  64,
  26,
  48,
  72,
  88,
  36,
  64,
  96,
  112,
  40,
  72,
  108,
  130,
  48,
  88,
  132,
  156,
  60,
  110,
  160,
  192,
  72,
  130,
  192,
  224,
  80,
  150,
  224,
  264,
  96,
  176,
  260,
  308,
  104,
  198,
  288,
  352,
  120,
  216,
  320,
  384,
  132,
  240,
  360,
  432,
  144,
  280,
  408,
  480,
  168,
  308,
  448,
  532,
  180,
  338,
  504,
  588,
  196,
  364,
  546,
  650,
  224,
  416,
  600,
  700,
  224,
  442,
  644,
  750,
  252,
  476,
  690,
  816,
  270,
  504,
  750,
  900,
  300,
  560,
  810,
  960,
  312,
  588,
  870,
  1050,
  336,
  644,
  952,
  1110,
  360,
  700,
  1020,
  1200,
  390,
  728,
  1050,
  1260,
  420,
  784,
  1140,
  1350,
  450,
  812,
  1200,
  1440,
  480,
  868,
  1290,
  1530,
  510,
  924,
  1350,
  1620,
  540,
  980,
  1440,
  1710,
  570,
  1036,
  1530,
  1800,
  570,
  1064,
  1590,
  1890,
  600,
  1120,
  1680,
  1980,
  630,
  1204,
  1770,
  2100,
  660,
  1260,
  1860,
  2220,
  720,
  1316,
  1950,
  2310,
  750,
  1372,
  2040,
  2430
];
uy.getBlocksCount = function(t, n) {
  switch (n) {
    case ps.L:
      return Uf[(t - 1) * 4 + 0];
    case ps.M:
      return Uf[(t - 1) * 4 + 1];
    case ps.Q:
      return Uf[(t - 1) * 4 + 2];
    case ps.H:
      return Uf[(t - 1) * 4 + 3];
    default:
      return;
  }
};
uy.getTotalCodewordsCount = function(t, n) {
  switch (n) {
    case ps.L:
      return zf[(t - 1) * 4 + 0];
    case ps.M:
      return zf[(t - 1) * 4 + 1];
    case ps.Q:
      return zf[(t - 1) * 4 + 2];
    case ps.H:
      return zf[(t - 1) * 4 + 3];
    default:
      return;
  }
};
var u5 = {}, dy = {};
const Ru = new Uint8Array(512), Xh = new Uint8Array(256);
(function() {
  let t = 1;
  for (let n = 0; n < 255; n++)
    Ru[n] = t, Xh[t] = n, t <<= 1, t & 256 && (t ^= 285);
  for (let n = 255; n < 512; n++)
    Ru[n] = Ru[n - 255];
})();
dy.log = function(t) {
  if (t < 1) throw new Error("log(" + t + ")");
  return Xh[t];
};
dy.exp = function(t) {
  return Ru[t];
};
dy.mul = function(t, n) {
  return t === 0 || n === 0 ? 0 : Ru[Xh[t] + Xh[n]];
};
(function(e) {
  const t = dy;
  e.mul = function(r, i) {
    const o = new Uint8Array(r.length + i.length - 1);
    for (let s = 0; s < r.length; s++)
      for (let a = 0; a < i.length; a++)
        o[s + a] ^= t.mul(r[s], i[a]);
    return o;
  }, e.mod = function(r, i) {
    let o = new Uint8Array(r);
    for (; o.length - i.length >= 0; ) {
      const s = o[0];
      for (let l = 0; l < i.length; l++)
        o[l] ^= t.mul(i[l], s);
      let a = 0;
      for (; a < o.length && o[a] === 0; ) a++;
      o = o.slice(a);
    }
    return o;
  }, e.generateECPolynomial = function(r) {
    let i = new Uint8Array([1]);
    for (let o = 0; o < r; o++)
      i = e.mul(i, new Uint8Array([1, t.exp(o)]));
    return i;
  };
})(u5);
const d5 = u5;
function Kw(e) {
  this.genPoly = void 0, this.degree = e, this.degree && this.initialize(this.degree);
}
Kw.prototype.initialize = function(t) {
  this.degree = t, this.genPoly = d5.generateECPolynomial(this.degree);
};
Kw.prototype.encode = function(t) {
  if (!this.genPoly)
    throw new Error("Encoder not initialized");
  const n = new Uint8Array(t.length + this.degree);
  n.set(t);
  const r = d5.mod(n, this.genPoly), i = this.degree - r.length;
  if (i > 0) {
    const o = new Uint8Array(this.degree);
    return o.set(r, i), o;
  }
  return r;
};
var qK = Kw, f5 = {}, Us = {}, Yw = {};
Yw.isValid = function(t) {
  return !isNaN(t) && t >= 1 && t <= 40;
};
var io = {};
const h5 = "[0-9]+", $K = "[A-Z $%*+\\-./:]+";
let sd = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
sd = sd.replace(/u/g, "\\u");
const WK = "(?:(?![A-Z0-9 $%*+\\-./:]|" + sd + `)(?:.|[\r
]))+`;
io.KANJI = new RegExp(sd, "g");
io.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
io.BYTE = new RegExp(WK, "g");
io.NUMERIC = new RegExp(h5, "g");
io.ALPHANUMERIC = new RegExp($K, "g");
const GK = new RegExp("^" + sd + "$"), HK = new RegExp("^" + h5 + "$"), KK = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
io.testKanji = function(t) {
  return GK.test(t);
};
io.testNumeric = function(t) {
  return HK.test(t);
};
io.testAlphanumeric = function(t) {
  return KK.test(t);
};
(function(e) {
  const t = Yw, n = io;
  e.NUMERIC = {
    id: "Numeric",
    bit: 1,
    ccBits: [10, 12, 14]
  }, e.ALPHANUMERIC = {
    id: "Alphanumeric",
    bit: 2,
    ccBits: [9, 11, 13]
  }, e.BYTE = {
    id: "Byte",
    bit: 4,
    ccBits: [8, 16, 16]
  }, e.KANJI = {
    id: "Kanji",
    bit: 8,
    ccBits: [8, 10, 12]
  }, e.MIXED = {
    bit: -1
  }, e.getCharCountIndicator = function(o, s) {
    if (!o.ccBits) throw new Error("Invalid mode: " + o);
    if (!t.isValid(s))
      throw new Error("Invalid version: " + s);
    return s >= 1 && s < 10 ? o.ccBits[0] : s < 27 ? o.ccBits[1] : o.ccBits[2];
  }, e.getBestModeForData = function(o) {
    return n.testNumeric(o) ? e.NUMERIC : n.testAlphanumeric(o) ? e.ALPHANUMERIC : n.testKanji(o) ? e.KANJI : e.BYTE;
  }, e.toString = function(o) {
    if (o && o.id) return o.id;
    throw new Error("Invalid mode");
  }, e.isValid = function(o) {
    return o && o.bit && o.ccBits;
  };
  function r(i) {
    if (typeof i != "string")
      throw new Error("Param is not a string");
    switch (i.toLowerCase()) {
      case "numeric":
        return e.NUMERIC;
      case "alphanumeric":
        return e.ALPHANUMERIC;
      case "kanji":
        return e.KANJI;
      case "byte":
        return e.BYTE;
      default:
        throw new Error("Unknown mode: " + i);
    }
  }
  e.from = function(o, s) {
    if (e.isValid(o))
      return o;
    try {
      return r(o);
    } catch {
      return s;
    }
  };
})(Us);
(function(e) {
  const t = Mr, n = uy, r = cy, i = Us, o = Yw, s = 7973, a = t.getBCHDigit(s);
  function l(f, h, p) {
    for (let m = 1; m <= 40; m++)
      if (h <= e.getCapacity(m, p, f))
        return m;
  }
  function c(f, h) {
    return i.getCharCountIndicator(f, h) + 4;
  }
  function u(f, h) {
    let p = 0;
    return f.forEach(function(m) {
      const g = c(m.mode, h);
      p += g + m.getBitsLength();
    }), p;
  }
  function d(f, h) {
    for (let p = 1; p <= 40; p++)
      if (u(f, p) <= e.getCapacity(p, h, i.MIXED))
        return p;
  }
  e.from = function(h, p) {
    return o.isValid(h) ? parseInt(h, 10) : p;
  }, e.getCapacity = function(h, p, m) {
    if (!o.isValid(h))
      throw new Error("Invalid QR Code version");
    typeof m > "u" && (m = i.BYTE);
    const g = t.getSymbolTotalCodewords(h), v = n.getTotalCodewordsCount(h, p), w = (g - v) * 8;
    if (m === i.MIXED) return w;
    const x = w - c(m, h);
    switch (m) {
      case i.NUMERIC:
        return Math.floor(x / 10 * 3);
      case i.ALPHANUMERIC:
        return Math.floor(x / 11 * 2);
      case i.KANJI:
        return Math.floor(x / 13);
      case i.BYTE:
      default:
        return Math.floor(x / 8);
    }
  }, e.getBestVersionForData = function(h, p) {
    let m;
    const g = r.from(p, r.M);
    if (Array.isArray(h)) {
      if (h.length > 1)
        return d(h, g);
      if (h.length === 0)
        return 1;
      m = h[0];
    } else
      m = h;
    return l(m.mode, m.getLength(), g);
  }, e.getEncodedBits = function(h) {
    if (!o.isValid(h) || h < 7)
      throw new Error("Invalid QR Code version");
    let p = h << 12;
    for (; t.getBCHDigit(p) - a >= 0; )
      p ^= s << t.getBCHDigit(p) - a;
    return h << 12 | p;
  };
})(f5);
var p5 = {};
const Lb = Mr, y5 = 1335, YK = 21522, SE = Lb.getBCHDigit(y5);
p5.getEncodedBits = function(t, n) {
  const r = t.bit << 3 | n;
  let i = r << 10;
  for (; Lb.getBCHDigit(i) - SE >= 0; )
    i ^= y5 << Lb.getBCHDigit(i) - SE;
  return (r << 10 | i) ^ YK;
};
var m5 = {};
const QK = Us;
function ic(e) {
  this.mode = QK.NUMERIC, this.data = e.toString();
}
ic.getBitsLength = function(t) {
  return 10 * Math.floor(t / 3) + (t % 3 ? t % 3 * 3 + 1 : 0);
};
ic.prototype.getLength = function() {
  return this.data.length;
};
ic.prototype.getBitsLength = function() {
  return ic.getBitsLength(this.data.length);
};
ic.prototype.write = function(t) {
  let n, r, i;
  for (n = 0; n + 3 <= this.data.length; n += 3)
    r = this.data.substr(n, 3), i = parseInt(r, 10), t.put(i, 10);
  const o = this.data.length - n;
  o > 0 && (r = this.data.substr(n), i = parseInt(r, 10), t.put(i, o * 3 + 1));
};
var JK = ic;
const XK = Us, pg = [
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  " ",
  "$",
  "%",
  "*",
  "+",
  "-",
  ".",
  "/",
  ":"
];
function oc(e) {
  this.mode = XK.ALPHANUMERIC, this.data = e;
}
oc.getBitsLength = function(t) {
  return 11 * Math.floor(t / 2) + 6 * (t % 2);
};
oc.prototype.getLength = function() {
  return this.data.length;
};
oc.prototype.getBitsLength = function() {
  return oc.getBitsLength(this.data.length);
};
oc.prototype.write = function(t) {
  let n;
  for (n = 0; n + 2 <= this.data.length; n += 2) {
    let r = pg.indexOf(this.data[n]) * 45;
    r += pg.indexOf(this.data[n + 1]), t.put(r, 11);
  }
  this.data.length % 2 && t.put(pg.indexOf(this.data[n]), 6);
};
var ZK = oc, eY = function(t) {
  for (var n = [], r = t.length, i = 0; i < r; i++) {
    var o = t.charCodeAt(i);
    if (o >= 55296 && o <= 56319 && r > i + 1) {
      var s = t.charCodeAt(i + 1);
      s >= 56320 && s <= 57343 && (o = (o - 55296) * 1024 + s - 56320 + 65536, i += 1);
    }
    if (o < 128) {
      n.push(o);
      continue;
    }
    if (o < 2048) {
      n.push(o >> 6 | 192), n.push(o & 63 | 128);
      continue;
    }
    if (o < 55296 || o >= 57344 && o < 65536) {
      n.push(o >> 12 | 224), n.push(o >> 6 & 63 | 128), n.push(o & 63 | 128);
      continue;
    }
    if (o >= 65536 && o <= 1114111) {
      n.push(o >> 18 | 240), n.push(o >> 12 & 63 | 128), n.push(o >> 6 & 63 | 128), n.push(o & 63 | 128);
      continue;
    }
    n.push(239, 191, 189);
  }
  return new Uint8Array(n).buffer;
};
const tY = eY, nY = Us;
function sc(e) {
  this.mode = nY.BYTE, typeof e == "string" && (e = tY(e)), this.data = new Uint8Array(e);
}
sc.getBitsLength = function(t) {
  return t * 8;
};
sc.prototype.getLength = function() {
  return this.data.length;
};
sc.prototype.getBitsLength = function() {
  return sc.getBitsLength(this.data.length);
};
sc.prototype.write = function(e) {
  for (let t = 0, n = this.data.length; t < n; t++)
    e.put(this.data[t], 8);
};
var rY = sc;
const iY = Us, oY = Mr;
function ac(e) {
  this.mode = iY.KANJI, this.data = e;
}
ac.getBitsLength = function(t) {
  return t * 13;
};
ac.prototype.getLength = function() {
  return this.data.length;
};
ac.prototype.getBitsLength = function() {
  return ac.getBitsLength(this.data.length);
};
ac.prototype.write = function(e) {
  let t;
  for (t = 0; t < this.data.length; t++) {
    let n = oY.toSJIS(this.data[t]);
    if (n >= 33088 && n <= 40956)
      n -= 33088;
    else if (n >= 57408 && n <= 60351)
      n -= 49472;
    else
      throw new Error(
        "Invalid SJIS character: " + this.data[t] + `
Make sure your charset is UTF-8`
      );
    n = (n >>> 8 & 255) * 192 + (n & 255), e.put(n, 13);
  }
};
var sY = ac, g5 = { exports: {} };
(function(e) {
  var t = {
    single_source_shortest_paths: function(n, r, i) {
      var o = {}, s = {};
      s[r] = 0;
      var a = t.PriorityQueue.make();
      a.push(r, 0);
      for (var l, c, u, d, f, h, p, m, g; !a.empty(); ) {
        l = a.pop(), c = l.value, d = l.cost, f = n[c] || {};
        for (u in f)
          f.hasOwnProperty(u) && (h = f[u], p = d + h, m = s[u], g = typeof s[u] > "u", (g || m > p) && (s[u] = p, a.push(u, p), o[u] = c));
      }
      if (typeof i < "u" && typeof s[i] > "u") {
        var v = ["Could not find a path from ", r, " to ", i, "."].join("");
        throw new Error(v);
      }
      return o;
    },
    extract_shortest_path_from_predecessor_list: function(n, r) {
      for (var i = [], o = r; o; )
        i.push(o), n[o], o = n[o];
      return i.reverse(), i;
    },
    find_path: function(n, r, i) {
      var o = t.single_source_shortest_paths(n, r, i);
      return t.extract_shortest_path_from_predecessor_list(
        o,
        i
      );
    },
    /**
     * A very naive priority queue implementation.
     */
    PriorityQueue: {
      make: function(n) {
        var r = t.PriorityQueue, i = {}, o;
        n = n || {};
        for (o in r)
          r.hasOwnProperty(o) && (i[o] = r[o]);
        return i.queue = [], i.sorter = n.sorter || r.default_sorter, i;
      },
      default_sorter: function(n, r) {
        return n.cost - r.cost;
      },
      /**
       * Add a new item to the queue and ensure the highest priority element
       * is at the front of the queue.
       */
      push: function(n, r) {
        var i = { value: n, cost: r };
        this.queue.push(i), this.queue.sort(this.sorter);
      },
      /**
       * Return the highest priority element in the queue.
       */
      pop: function() {
        return this.queue.shift();
      },
      empty: function() {
        return this.queue.length === 0;
      }
    }
  };
  e.exports = t;
})(g5);
var aY = g5.exports;
(function(e) {
  const t = Us, n = JK, r = ZK, i = rY, o = sY, s = io, a = Mr, l = aY;
  function c(v) {
    return unescape(encodeURIComponent(v)).length;
  }
  function u(v, w, x) {
    const C = [];
    let S;
    for (; (S = v.exec(x)) !== null; )
      C.push({
        data: S[0],
        index: S.index,
        mode: w,
        length: S[0].length
      });
    return C;
  }
  function d(v) {
    const w = u(s.NUMERIC, t.NUMERIC, v), x = u(s.ALPHANUMERIC, t.ALPHANUMERIC, v);
    let C, S;
    return a.isKanjiModeEnabled() ? (C = u(s.BYTE, t.BYTE, v), S = u(s.KANJI, t.KANJI, v)) : (C = u(s.BYTE_KANJI, t.BYTE, v), S = []), w.concat(x, C, S).sort(function(A, b) {
      return A.index - b.index;
    }).map(function(A) {
      return {
        data: A.data,
        mode: A.mode,
        length: A.length
      };
    });
  }
  function f(v, w) {
    switch (w) {
      case t.NUMERIC:
        return n.getBitsLength(v);
      case t.ALPHANUMERIC:
        return r.getBitsLength(v);
      case t.KANJI:
        return o.getBitsLength(v);
      case t.BYTE:
        return i.getBitsLength(v);
    }
  }
  function h(v) {
    return v.reduce(function(w, x) {
      const C = w.length - 1 >= 0 ? w[w.length - 1] : null;
      return C && C.mode === x.mode ? (w[w.length - 1].data += x.data, w) : (w.push(x), w);
    }, []);
  }
  function p(v) {
    const w = [];
    for (let x = 0; x < v.length; x++) {
      const C = v[x];
      switch (C.mode) {
        case t.NUMERIC:
          w.push([
            C,
            { data: C.data, mode: t.ALPHANUMERIC, length: C.length },
            { data: C.data, mode: t.BYTE, length: C.length }
          ]);
          break;
        case t.ALPHANUMERIC:
          w.push([
            C,
            { data: C.data, mode: t.BYTE, length: C.length }
          ]);
          break;
        case t.KANJI:
          w.push([
            C,
            { data: C.data, mode: t.BYTE, length: c(C.data) }
          ]);
          break;
        case t.BYTE:
          w.push([
            { data: C.data, mode: t.BYTE, length: c(C.data) }
          ]);
      }
    }
    return w;
  }
  function m(v, w) {
    const x = {}, C = { start: {} };
    let S = ["start"];
    for (let k = 0; k < v.length; k++) {
      const A = v[k], b = [];
      for (let T = 0; T < A.length; T++) {
        const R = A[T], B = "" + k + T;
        b.push(B), x[B] = { node: R, lastCount: 0 }, C[B] = {};
        for (let O = 0; O < S.length; O++) {
          const L = S[O];
          x[L] && x[L].node.mode === R.mode ? (C[L][B] = f(x[L].lastCount + R.length, R.mode) - f(x[L].lastCount, R.mode), x[L].lastCount += R.length) : (x[L] && (x[L].lastCount = R.length), C[L][B] = f(R.length, R.mode) + 4 + t.getCharCountIndicator(R.mode, w));
        }
      }
      S = b;
    }
    for (let k = 0; k < S.length; k++)
      C[S[k]].end = 0;
    return { map: C, table: x };
  }
  function g(v, w) {
    let x;
    const C = t.getBestModeForData(v);
    if (x = t.from(w, C), x !== t.BYTE && x.bit < C.bit)
      throw new Error('"' + v + '" cannot be encoded with mode ' + t.toString(x) + `.
 Suggested mode is: ` + t.toString(C));
    switch (x === t.KANJI && !a.isKanjiModeEnabled() && (x = t.BYTE), x) {
      case t.NUMERIC:
        return new n(v);
      case t.ALPHANUMERIC:
        return new r(v);
      case t.KANJI:
        return new o(v);
      case t.BYTE:
        return new i(v);
    }
  }
  e.fromArray = function(w) {
    return w.reduce(function(x, C) {
      return typeof C == "string" ? x.push(g(C, null)) : C.data && x.push(g(C.data, C.mode)), x;
    }, []);
  }, e.fromString = function(w, x) {
    const C = d(w, a.isKanjiModeEnabled()), S = p(C), k = m(S, x), A = l.find_path(k.map, "start", "end"), b = [];
    for (let T = 1; T < A.length - 1; T++)
      b.push(k.table[A[T]].node);
    return e.fromArray(h(b));
  }, e.rawSplit = function(w) {
    return e.fromArray(
      d(w, a.isKanjiModeEnabled())
    );
  };
})(m5);
const fy = Mr, yg = cy, lY = UK, cY = zK, uY = a5, dY = l5, Ub = c5, zb = uy, fY = qK, Zh = f5, hY = p5, pY = Us, mg = m5;
function yY(e, t) {
  const n = e.size, r = dY.getPositions(t);
  for (let i = 0; i < r.length; i++) {
    const o = r[i][0], s = r[i][1];
    for (let a = -1; a <= 7; a++)
      if (!(o + a <= -1 || n <= o + a))
        for (let l = -1; l <= 7; l++)
          s + l <= -1 || n <= s + l || (a >= 0 && a <= 6 && (l === 0 || l === 6) || l >= 0 && l <= 6 && (a === 0 || a === 6) || a >= 2 && a <= 4 && l >= 2 && l <= 4 ? e.set(o + a, s + l, !0, !0) : e.set(o + a, s + l, !1, !0));
  }
}
function mY(e) {
  const t = e.size;
  for (let n = 8; n < t - 8; n++) {
    const r = n % 2 === 0;
    e.set(n, 6, r, !0), e.set(6, n, r, !0);
  }
}
function gY(e, t) {
  const n = uY.getPositions(t);
  for (let r = 0; r < n.length; r++) {
    const i = n[r][0], o = n[r][1];
    for (let s = -2; s <= 2; s++)
      for (let a = -2; a <= 2; a++)
        s === -2 || s === 2 || a === -2 || a === 2 || s === 0 && a === 0 ? e.set(i + s, o + a, !0, !0) : e.set(i + s, o + a, !1, !0);
  }
}
function vY(e, t) {
  const n = e.size, r = Zh.getEncodedBits(t);
  let i, o, s;
  for (let a = 0; a < 18; a++)
    i = Math.floor(a / 3), o = a % 3 + n - 8 - 3, s = (r >> a & 1) === 1, e.set(i, o, s, !0), e.set(o, i, s, !0);
}
function gg(e, t, n) {
  const r = e.size, i = hY.getEncodedBits(t, n);
  let o, s;
  for (o = 0; o < 15; o++)
    s = (i >> o & 1) === 1, o < 6 ? e.set(o, 8, s, !0) : o < 8 ? e.set(o + 1, 8, s, !0) : e.set(r - 15 + o, 8, s, !0), o < 8 ? e.set(8, r - o - 1, s, !0) : o < 9 ? e.set(8, 15 - o - 1 + 1, s, !0) : e.set(8, 15 - o - 1, s, !0);
  e.set(r - 8, 8, 1, !0);
}
function bY(e, t) {
  const n = e.size;
  let r = -1, i = n - 1, o = 7, s = 0;
  for (let a = n - 1; a > 0; a -= 2)
    for (a === 6 && a--; ; ) {
      for (let l = 0; l < 2; l++)
        if (!e.isReserved(i, a - l)) {
          let c = !1;
          s < t.length && (c = (t[s] >>> o & 1) === 1), e.set(i, a - l, c), o--, o === -1 && (s++, o = 7);
        }
      if (i += r, i < 0 || n <= i) {
        i -= r, r = -r;
        break;
      }
    }
}
function wY(e, t, n) {
  const r = new lY();
  n.forEach(function(l) {
    r.put(l.mode.bit, 4), r.put(l.getLength(), pY.getCharCountIndicator(l.mode, e)), l.write(r);
  });
  const i = fy.getSymbolTotalCodewords(e), o = zb.getTotalCodewordsCount(e, t), s = (i - o) * 8;
  for (r.getLengthInBits() + 4 <= s && r.put(0, 4); r.getLengthInBits() % 8 !== 0; )
    r.putBit(0);
  const a = (s - r.getLengthInBits()) / 8;
  for (let l = 0; l < a; l++)
    r.put(l % 2 ? 17 : 236, 8);
  return xY(r, e, t);
}
function xY(e, t, n) {
  const r = fy.getSymbolTotalCodewords(t), i = zb.getTotalCodewordsCount(t, n), o = r - i, s = zb.getBlocksCount(t, n), a = r % s, l = s - a, c = Math.floor(r / s), u = Math.floor(o / s), d = u + 1, f = c - u, h = new fY(f);
  let p = 0;
  const m = new Array(s), g = new Array(s);
  let v = 0;
  const w = new Uint8Array(e.buffer);
  for (let A = 0; A < s; A++) {
    const b = A < l ? u : d;
    m[A] = w.slice(p, p + b), g[A] = h.encode(m[A]), p += b, v = Math.max(v, b);
  }
  const x = new Uint8Array(r);
  let C = 0, S, k;
  for (S = 0; S < v; S++)
    for (k = 0; k < s; k++)
      S < m[k].length && (x[C++] = m[k][S]);
  for (S = 0; S < f; S++)
    for (k = 0; k < s; k++)
      x[C++] = g[k][S];
  return x;
}
function CY(e, t, n, r) {
  let i;
  if (Array.isArray(e))
    i = mg.fromArray(e);
  else if (typeof e == "string") {
    let c = t;
    if (!c) {
      const u = mg.rawSplit(e);
      c = Zh.getBestVersionForData(u, n);
    }
    i = mg.fromString(e, c || 40);
  } else
    throw new Error("Invalid data");
  const o = Zh.getBestVersionForData(i, n);
  if (!o)
    throw new Error("The amount of data is too big to be stored in a QR Code");
  if (!t)
    t = o;
  else if (t < o)
    throw new Error(
      `
The chosen QR Code version cannot contain this amount of data.
Minimum version required to store current data is: ` + o + `.
`
    );
  const s = wY(t, n, i), a = fy.getSymbolSize(t), l = new cY(a);
  return yY(l, t), mY(l), gY(l, t), gg(l, n, 0), t >= 7 && vY(l, t), bY(l, s), isNaN(r) && (r = Ub.getBestMask(
    l,
    gg.bind(null, l, n)
  )), Ub.applyMask(r, l), gg(l, n, r), {
    modules: l,
    version: t,
    errorCorrectionLevel: n,
    maskPattern: r,
    segments: i
  };
}
o5.create = function(t, n) {
  if (typeof t > "u" || t === "")
    throw new Error("No input text");
  let r = yg.M, i, o;
  return typeof n < "u" && (r = yg.from(n.errorCorrectionLevel, yg.M), i = Zh.from(n.version), o = Ub.from(n.maskPattern), n.toSJISFunc && fy.setToSJISFunction(n.toSJISFunc)), CY(t, i, r, o);
};
var v5 = {}, Qw = {};
(function(e) {
  function t(n) {
    if (typeof n == "number" && (n = n.toString()), typeof n != "string")
      throw new Error("Color should be defined as hex string");
    let r = n.slice().replace("#", "").split("");
    if (r.length < 3 || r.length === 5 || r.length > 8)
      throw new Error("Invalid hex color: " + n);
    (r.length === 3 || r.length === 4) && (r = Array.prototype.concat.apply([], r.map(function(o) {
      return [o, o];
    }))), r.length === 6 && r.push("F", "F");
    const i = parseInt(r.join(""), 16);
    return {
      r: i >> 24 & 255,
      g: i >> 16 & 255,
      b: i >> 8 & 255,
      a: i & 255,
      hex: "#" + r.slice(0, 6).join("")
    };
  }
  e.getOptions = function(r) {
    r || (r = {}), r.color || (r.color = {});
    const i = typeof r.margin > "u" || r.margin === null || r.margin < 0 ? 4 : r.margin, o = r.width && r.width >= 21 ? r.width : void 0, s = r.scale || 4;
    return {
      width: o,
      scale: o ? 4 : s,
      margin: i,
      color: {
        dark: t(r.color.dark || "#000000ff"),
        light: t(r.color.light || "#ffffffff")
      },
      type: r.type,
      rendererOpts: r.rendererOpts || {}
    };
  }, e.getScale = function(r, i) {
    return i.width && i.width >= r + i.margin * 2 ? i.width / (r + i.margin * 2) : i.scale;
  }, e.getImageWidth = function(r, i) {
    const o = e.getScale(r, i);
    return Math.floor((r + i.margin * 2) * o);
  }, e.qrToImageData = function(r, i, o) {
    const s = i.modules.size, a = i.modules.data, l = e.getScale(s, o), c = Math.floor((s + o.margin * 2) * l), u = o.margin * l, d = [o.color.light, o.color.dark];
    for (let f = 0; f < c; f++)
      for (let h = 0; h < c; h++) {
        let p = (f * c + h) * 4, m = o.color.light;
        if (f >= u && h >= u && f < c - u && h < c - u) {
          const g = Math.floor((f - u) / l), v = Math.floor((h - u) / l);
          m = d[a[g * s + v] ? 1 : 0];
        }
        r[p++] = m.r, r[p++] = m.g, r[p++] = m.b, r[p] = m.a;
      }
  };
})(Qw);
(function(e) {
  const t = Qw;
  function n(i, o, s) {
    i.clearRect(0, 0, o.width, o.height), o.style || (o.style = {}), o.height = s, o.width = s, o.style.height = s + "px", o.style.width = s + "px";
  }
  function r() {
    try {
      return document.createElement("canvas");
    } catch {
      throw new Error("You need to specify a canvas element");
    }
  }
  e.render = function(o, s, a) {
    let l = a, c = s;
    typeof l > "u" && (!s || !s.getContext) && (l = s, s = void 0), s || (c = r()), l = t.getOptions(l);
    const u = t.getImageWidth(o.modules.size, l), d = c.getContext("2d"), f = d.createImageData(u, u);
    return t.qrToImageData(f.data, o, l), n(d, c, u), d.putImageData(f, 0, 0), c;
  }, e.renderToDataURL = function(o, s, a) {
    let l = a;
    typeof l > "u" && (!s || !s.getContext) && (l = s, s = void 0), l || (l = {});
    const c = e.render(o, s, l), u = l.type || "image/png", d = l.rendererOpts || {};
    return c.toDataURL(u, d.quality);
  };
})(v5);
var b5 = {};
const kY = Qw;
function AE(e, t) {
  const n = e.a / 255, r = t + '="' + e.hex + '"';
  return n < 1 ? r + " " + t + '-opacity="' + n.toFixed(2).slice(1) + '"' : r;
}
function vg(e, t, n) {
  let r = e + t;
  return typeof n < "u" && (r += " " + n), r;
}
function EY(e, t, n) {
  let r = "", i = 0, o = !1, s = 0;
  for (let a = 0; a < e.length; a++) {
    const l = Math.floor(a % t), c = Math.floor(a / t);
    !l && !o && (o = !0), e[a] ? (s++, a > 0 && l > 0 && e[a - 1] || (r += o ? vg("M", l + n, 0.5 + c + n) : vg("m", i, 0), i = 0, o = !1), l + 1 < t && e[a + 1] || (r += vg("h", s), s = 0)) : i++;
  }
  return r;
}
b5.render = function(t, n, r) {
  const i = kY.getOptions(n), o = t.modules.size, s = t.modules.data, a = o + i.margin * 2, l = i.color.light.a ? "<path " + AE(i.color.light, "fill") + ' d="M0 0h' + a + "v" + a + 'H0z"/>' : "", c = "<path " + AE(i.color.dark, "stroke") + ' d="' + EY(s, o, i.margin) + '"/>', u = 'viewBox="0 0 ' + a + " " + a + '"', f = '<svg xmlns="http://www.w3.org/2000/svg" ' + (i.width ? 'width="' + i.width + '" height="' + i.width + '" ' : "") + u + ' shape-rendering="crispEdges">' + l + c + `</svg>
`;
  return typeof r == "function" && r(null, f), f;
};
const SY = FK, Vb = o5, w5 = v5, AY = b5;
function Jw(e, t, n, r, i) {
  const o = [].slice.call(arguments, 1), s = o.length, a = typeof o[s - 1] == "function";
  if (!a && !SY())
    throw new Error("Callback required as last argument");
  if (a) {
    if (s < 2)
      throw new Error("Too few arguments provided");
    s === 2 ? (i = n, n = t, t = r = void 0) : s === 3 && (t.getContext && typeof i > "u" ? (i = r, r = void 0) : (i = r, r = n, n = t, t = void 0));
  } else {
    if (s < 1)
      throw new Error("Too few arguments provided");
    return s === 1 ? (n = t, t = r = void 0) : s === 2 && !t.getContext && (r = n, n = t, t = void 0), new Promise(function(l, c) {
      try {
        const u = Vb.create(n, r);
        l(e(u, t, r));
      } catch (u) {
        c(u);
      }
    });
  }
  try {
    const l = Vb.create(n, r);
    i(null, e(l, t, r));
  } catch (l) {
    i(l);
  }
}
Gd.create = Vb.create;
Gd.toCanvas = Jw.bind(null, w5.render);
Gd.toDataURL = Jw.bind(null, w5.renderToDataURL);
Gd.toString = Jw.bind(null, function(e, t, n) {
  return AY.render(e, n);
});
hy.type = "coinbaseWallet";
function hy(e = {}) {
  return e.version === "3" || e.headlessMode ? _Y(e) : TY(e);
}
function TY(e) {
  let t, n, r, i, o;
  return (s) => ({
    id: "coinbaseWalletSDK",
    name: "Coinbase Wallet",
    rdns: "com.coinbase.wallet",
    supportsSimulation: !0,
    type: hy.type,
    async connect({ chainId: a } = {}) {
      try {
        const l = await this.getProvider(), c = (await l.request({
          method: "eth_requestAccounts"
        })).map((d) => Qn(d));
        r || (r = this.onAccountsChanged.bind(this), l.on("accountsChanged", r)), i || (i = this.onChainChanged.bind(this), l.on("chainChanged", i)), o || (o = this.onDisconnect.bind(this), l.on("disconnect", o));
        let u = await this.getChainId();
        if (a && u !== a) {
          const d = await this.switchChain({ chainId: a }).catch((f) => {
            if (f.code === $t.code)
              throw f;
            return { id: u };
          });
          u = (d == null ? void 0 : d.id) ?? u;
        }
        return { accounts: c, chainId: u };
      } catch (l) {
        throw /(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(l.message) ? new $t(l) : l;
      }
    },
    async disconnect() {
      var l;
      const a = await this.getProvider();
      r && (a.removeListener("accountsChanged", r), r = void 0), i && (a.removeListener("chainChanged", i), i = void 0), o && (a.removeListener("disconnect", o), o = void 0), a.disconnect(), (l = a.close) == null || l.call(a);
    },
    async getAccounts() {
      return (await (await this.getProvider()).request({
        method: "eth_accounts"
      })).map((l) => Qn(l));
    },
    async getChainId() {
      const l = await (await this.getProvider()).request({
        method: "eth_chainId"
      });
      return Number(l);
    },
    async getProvider() {
      if (!n) {
        const a = await (async () => {
          const { default: l } = await import("./index-CBSaS9uK.js").then((c) => c.i);
          return typeof l != "function" && typeof l.default == "function" ? l.default : l;
        })();
        t = new a({
          ...e,
          appChainIds: s.chains.map((l) => l.id)
        }), n = t.makeWeb3Provider({
          ...e,
          options: e.preference ?? "all"
        });
      }
      return n;
    },
    async isAuthorized() {
      try {
        return !!(await this.getAccounts()).length;
      } catch {
        return !1;
      }
    },
    async switchChain({ addEthereumChainParameter: a, chainId: l }) {
      var d, f, h, p;
      const c = s.chains.find((m) => m.id === l);
      if (!c)
        throw new oi(new Pa());
      const u = await this.getProvider();
      try {
        return await u.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: Fe(c.id) }]
        }), c;
      } catch (m) {
        if (m.code === 4902)
          try {
            let g;
            a != null && a.blockExplorerUrls ? g = a.blockExplorerUrls : g = (d = c.blockExplorers) != null && d.default.url ? [(f = c.blockExplorers) == null ? void 0 : f.default.url] : [];
            let v;
            (h = a == null ? void 0 : a.rpcUrls) != null && h.length ? v = a.rpcUrls : v = [((p = c.rpcUrls.default) == null ? void 0 : p.http[0]) ?? ""];
            const w = {
              blockExplorerUrls: g,
              chainId: Fe(l),
              chainName: (a == null ? void 0 : a.chainName) ?? c.name,
              iconUrls: a == null ? void 0 : a.iconUrls,
              nativeCurrency: (a == null ? void 0 : a.nativeCurrency) ?? c.nativeCurrency,
              rpcUrls: v
            };
            return await u.request({
              method: "wallet_addEthereumChain",
              params: [w]
            }), c;
          } catch (g) {
            throw new $t(g);
          }
        throw new oi(m);
      }
    },
    onAccountsChanged(a) {
      a.length === 0 ? this.onDisconnect() : s.emitter.emit("change", {
        accounts: a.map((l) => Qn(l))
      });
    },
    onChainChanged(a) {
      const l = Number(a);
      s.emitter.emit("change", { chainId: l });
    },
    async onDisconnect(a) {
      s.emitter.emit("disconnect");
      const l = await this.getProvider();
      r && (l.removeListener("accountsChanged", r), r = void 0), i && (l.removeListener("chainChanged", i), i = void 0), o && (l.removeListener("disconnect", o), o = void 0);
    }
  });
}
function _Y(e) {
  let n, r, i, o, s;
  return (a) => ({
    id: "coinbaseWalletSDK",
    name: "Coinbase Wallet",
    supportsSimulation: !0,
    type: hy.type,
    async connect({ chainId: l } = {}) {
      try {
        const c = await this.getProvider(), u = (await c.request({
          method: "eth_requestAccounts"
        })).map((f) => Qn(f));
        i || (i = this.onAccountsChanged.bind(this), c.on("accountsChanged", i)), o || (o = this.onChainChanged.bind(this), c.on("chainChanged", o)), s || (s = this.onDisconnect.bind(this), c.on("disconnect", s));
        let d = await this.getChainId();
        if (l && d !== l) {
          const f = await this.switchChain({ chainId: l }).catch((h) => {
            if (h.code === $t.code)
              throw h;
            return { id: d };
          });
          d = (f == null ? void 0 : f.id) ?? d;
        }
        return { accounts: u, chainId: d };
      } catch (c) {
        throw /(user closed modal|accounts received is empty|user denied account)/i.test(c.message) ? new $t(c) : c;
      }
    },
    async disconnect() {
      const l = await this.getProvider();
      i && (l.removeListener("accountsChanged", i), i = void 0), o && (l.removeListener("chainChanged", o), o = void 0), s && (l.removeListener("disconnect", s), s = void 0), l.disconnect(), l.close();
    },
    async getAccounts() {
      return (await (await this.getProvider()).request({
        method: "eth_accounts"
      })).map((c) => Qn(c));
    },
    async getChainId() {
      const c = await (await this.getProvider()).request({
        method: "eth_chainId"
      });
      return Number(c);
    },
    async getProvider() {
      var l;
      if (!r) {
        const c = await (async () => {
          const { default: p } = await import("./index-DFp2HoyL.js").then((m) => m.i);
          return typeof p != "function" && typeof p.default == "function" ? p.default : p;
        })();
        n = new c({ ...e, reloadOnDisconnect: !1 });
        const u = (l = n.walletExtension) == null ? void 0 : l.getChainId(), d = a.chains.find((p) => e.chainId ? p.id === e.chainId : p.id === u) || a.chains[0], f = e.chainId || (d == null ? void 0 : d.id), h = e.jsonRpcUrl || (d == null ? void 0 : d.rpcUrls.default.http[0]);
        r = n.makeWeb3Provider(h, f);
      }
      return r;
    },
    async isAuthorized() {
      try {
        return !!(await this.getAccounts()).length;
      } catch {
        return !1;
      }
    },
    async switchChain({ addEthereumChainParameter: l, chainId: c }) {
      var f, h, p, m;
      const u = a.chains.find((g) => g.id === c);
      if (!u)
        throw new oi(new Pa());
      const d = await this.getProvider();
      try {
        return await d.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: Fe(u.id) }]
        }), u;
      } catch (g) {
        if (g.code === 4902)
          try {
            let v;
            l != null && l.blockExplorerUrls ? v = l.blockExplorerUrls : v = (f = u.blockExplorers) != null && f.default.url ? [(h = u.blockExplorers) == null ? void 0 : h.default.url] : [];
            let w;
            (p = l == null ? void 0 : l.rpcUrls) != null && p.length ? w = l.rpcUrls : w = [((m = u.rpcUrls.default) == null ? void 0 : m.http[0]) ?? ""];
            const x = {
              blockExplorerUrls: v,
              chainId: Fe(c),
              chainName: (l == null ? void 0 : l.chainName) ?? u.name,
              iconUrls: l == null ? void 0 : l.iconUrls,
              nativeCurrency: (l == null ? void 0 : l.nativeCurrency) ?? u.nativeCurrency,
              rpcUrls: w
            };
            return await d.request({
              method: "wallet_addEthereumChain",
              params: [x]
            }), u;
          } catch (v) {
            throw new $t(v);
          }
        throw new oi(g);
      }
    },
    onAccountsChanged(l) {
      l.length === 0 ? this.onDisconnect() : a.emitter.emit("change", {
        accounts: l.map((c) => Qn(c))
      });
    },
    onChainChanged(l) {
      const c = Number(l);
      a.emitter.emit("change", { chainId: c });
    },
    async onDisconnect(l) {
      a.emitter.emit("disconnect");
      const c = await this.getProvider();
      i && (c.removeListener("accountsChanged", i), i = void 0), o && (c.removeListener("chainChanged", o), o = void 0), s && (c.removeListener("disconnect", s), s = void 0);
    }
  });
}
Xw.type = "walletConnect";
function Xw(e) {
  const t = e.isNewChainsStale ?? !0;
  let n, r;
  const i = "eip155";
  let o, s, a, l, c, u;
  return (d) => ({
    id: "walletConnect",
    name: "WalletConnect",
    type: Xw.type,
    async setup() {
      const f = await this.getProvider().catch(() => null);
      f && (a || (a = this.onConnect.bind(this), f.on("connect", a)), c || (c = this.onSessionDelete.bind(this), f.on("session_delete", c)));
    },
    async connect({ chainId: f, ...h } = {}) {
      var p, m;
      try {
        const g = await this.getProvider();
        if (!g)
          throw new is();
        l || (l = this.onDisplayUri, g.on("display_uri", l));
        let v = f;
        if (!v) {
          const S = await ((p = d.storage) == null ? void 0 : p.getItem("state")) ?? {};
          d.chains.some((A) => A.id === S.chainId) ? v = S.chainId : v = (m = d.chains[0]) == null ? void 0 : m.id;
        }
        if (!v)
          throw new Error("No chains found on connector.");
        const w = await this.isChainsStale();
        if (g.session && w && await g.disconnect(), !g.session || w) {
          const S = d.chains.filter((k) => k.id !== v).map((k) => k.id);
          await g.connect({
            optionalChains: [v, ...S],
            ..."pairingTopic" in h ? { pairingTopic: h.pairingTopic } : {}
          }), this.setRequestedChainsIds(d.chains.map((k) => k.id));
        }
        const x = (await g.enable()).map((S) => Qn(S)), C = await this.getChainId();
        return l && (g.removeListener("display_uri", l), l = void 0), a && (g.removeListener("connect", a), a = void 0), o || (o = this.onAccountsChanged.bind(this), g.on("accountsChanged", o)), s || (s = this.onChainChanged.bind(this), g.on("chainChanged", s)), u || (u = this.onDisconnect.bind(this), g.on("disconnect", u)), c || (c = this.onSessionDelete.bind(this), g.on("session_delete", c)), { accounts: x, chainId: C };
      } catch (g) {
        throw /(user rejected|connection request reset)/i.test(g == null ? void 0 : g.message) ? new $t(g) : g;
      }
    },
    async disconnect() {
      const f = await this.getProvider();
      try {
        await (f == null ? void 0 : f.disconnect());
      } catch (h) {
        if (!/No matching key/i.test(h.message))
          throw h;
      } finally {
        s && (f == null || f.removeListener("chainChanged", s), s = void 0), u && (f == null || f.removeListener("disconnect", u), u = void 0), a || (a = this.onConnect.bind(this), f == null || f.on("connect", a)), o && (f == null || f.removeListener("accountsChanged", o), o = void 0), c && (f == null || f.removeListener("session_delete", c), c = void 0), this.setRequestedChainsIds([]);
      }
    },
    async getAccounts() {
      return (await this.getProvider()).accounts.map((h) => Qn(h));
    },
    async getProvider({ chainId: f } = {}) {
      var p;
      async function h() {
        const m = d.chains.map((v) => v.id);
        if (!m.length)
          return;
        const { EthereumProvider: g } = await import("./index.es-rsEdUaBx.js");
        return await g.init({
          ...e,
          disableProviderPing: !0,
          optionalChains: m,
          projectId: e.projectId,
          rpcMap: Object.fromEntries(d.chains.map((v) => {
            const [w] = fG({
              chain: v,
              transports: d.transports
            });
            return [v.id, w];
          })),
          showQrModal: e.showQrModal ?? !0
        });
      }
      return n || (r || (r = h()), n = await r, n == null || n.events.setMaxListeners(Number.POSITIVE_INFINITY)), f && await ((p = this.switchChain) == null ? void 0 : p.call(this, { chainId: f })), n;
    },
    async getChainId() {
      return (await this.getProvider()).chainId;
    },
    async isAuthorized() {
      try {
        const [f, h] = await Promise.all([
          this.getAccounts(),
          this.getProvider()
        ]);
        return f.length ? await this.isChainsStale() && h.session ? (await h.disconnect().catch(() => {
        }), !1) : !0 : !1;
      } catch {
        return !1;
      }
    },
    async switchChain({ addEthereumChainParameter: f, chainId: h }) {
      var g, v, w;
      const p = await this.getProvider();
      if (!p)
        throw new is();
      const m = d.chains.find((x) => x.id === h);
      if (!m)
        throw new oi(new Pa());
      try {
        await Promise.all([
          new Promise((C) => {
            const S = ({ chainId: k }) => {
              k === h && (d.emitter.off("change", S), C());
            };
            d.emitter.on("change", S);
          }),
          p.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: Fe(h) }]
          })
        ]);
        const x = await this.getRequestedChainsIds();
        return this.setRequestedChainsIds([...x, h]), m;
      } catch (x) {
        const C = x;
        if (/(user rejected)/i.test(C.message))
          throw new $t(C);
        try {
          let S;
          f != null && f.blockExplorerUrls ? S = f.blockExplorerUrls : S = (g = m.blockExplorers) != null && g.default.url ? [(v = m.blockExplorers) == null ? void 0 : v.default.url] : [];
          let k;
          (w = f == null ? void 0 : f.rpcUrls) != null && w.length ? k = f.rpcUrls : k = [...m.rpcUrls.default.http];
          const A = {
            blockExplorerUrls: S,
            chainId: Fe(h),
            chainName: (f == null ? void 0 : f.chainName) ?? m.name,
            iconUrls: f == null ? void 0 : f.iconUrls,
            nativeCurrency: (f == null ? void 0 : f.nativeCurrency) ?? m.nativeCurrency,
            rpcUrls: k
          };
          await p.request({
            method: "wallet_addEthereumChain",
            params: [A]
          });
          const b = await this.getRequestedChainsIds();
          return this.setRequestedChainsIds([...b, h]), m;
        } catch (S) {
          throw new $t(S);
        }
      }
    },
    onAccountsChanged(f) {
      f.length === 0 ? this.onDisconnect() : d.emitter.emit("change", {
        accounts: f.map((h) => Qn(h))
      });
    },
    onChainChanged(f) {
      const h = Number(f);
      d.emitter.emit("change", { chainId: h });
    },
    async onConnect(f) {
      const h = Number(f.chainId), p = await this.getAccounts();
      d.emitter.emit("connect", { accounts: p, chainId: h });
    },
    async onDisconnect(f) {
      this.setRequestedChainsIds([]), d.emitter.emit("disconnect");
      const h = await this.getProvider();
      o && (h.removeListener("accountsChanged", o), o = void 0), s && (h.removeListener("chainChanged", s), s = void 0), u && (h.removeListener("disconnect", u), u = void 0), c && (h.removeListener("session_delete", c), c = void 0), a || (a = this.onConnect.bind(this), h.on("connect", a));
    },
    onDisplayUri(f) {
      d.emitter.emit("message", { type: "display_uri", data: f });
    },
    onSessionDelete() {
      this.onDisconnect();
    },
    getNamespaceChainsIds() {
      var h, p, m;
      return n ? ((m = (p = (h = n.session) == null ? void 0 : h.namespaces[i]) == null ? void 0 : p.accounts) == null ? void 0 : m.map((g) => Number.parseInt(g.split(":")[1] || ""))) ?? [] : [];
    },
    async getRequestedChainsIds() {
      var f;
      return await ((f = d.storage) == null ? void 0 : f.getItem(this.requestedChainsStorageKey)) ?? [];
    },
    /**
     * Checks if the target chains match the chains that were
     * initially requested by the connector for the WalletConnect session.
     * If there is a mismatch, this means that the chains on the connector
     * are considered stale, and need to be revalidated at a later point (via
     * connection).
     *
     * There may be a scenario where a dapp adds a chain to the
     * connector later on, however, this chain will not have been approved or rejected
     * by the wallet. In this case, the chain is considered stale.
     */
    async isChainsStale() {
      if (!t)
        return !1;
      const f = d.chains.map((m) => m.id), h = this.getNamespaceChainsIds();
      if (h.length && !h.some((m) => f.includes(m)))
        return !1;
      const p = await this.getRequestedChainsIds();
      return !f.every((m) => p.includes(m));
    },
    async setRequestedChainsIds(f) {
      var h;
      await ((h = d.storage) == null ? void 0 : h.setItem(this.requestedChainsStorageKey, f));
    },
    get requestedChainsStorageKey() {
      return `${this.id}.requestedChains`;
    }
  });
}
var IY = 768, nl = X9({ conditions: { defaultCondition: "smallScreen", conditionNames: ["smallScreen", "largeScreen"], responsiveArray: void 0 } }), RY = mT({ conditions: { defaultCondition: "smallScreen", conditionNames: ["smallScreen", "largeScreen"], responsiveArray: void 0 } }), qb = iU({ conditions: { defaultCondition: "base", conditionNames: ["base", "hover", "active"], responsiveArray: void 0 }, styles: { background: { values: { accentColor: { conditions: { base: "in5bvi9i", hover: "in5bvi9j", active: "in5bvi9k" }, defaultClass: "in5bvi9i" }, accentColorForeground: { conditions: { base: "in5bvi9l", hover: "in5bvi9m", active: "in5bvi9n" }, defaultClass: "in5bvi9l" }, actionButtonBorder: { conditions: { base: "in5bvi9o", hover: "in5bvi9p", active: "in5bvi9q" }, defaultClass: "in5bvi9o" }, actionButtonBorderMobile: { conditions: { base: "in5bvi9r", hover: "in5bvi9s", active: "in5bvi9t" }, defaultClass: "in5bvi9r" }, actionButtonSecondaryBackground: { conditions: { base: "in5bvi9u", hover: "in5bvi9v", active: "in5bvi9w" }, defaultClass: "in5bvi9u" }, closeButton: { conditions: { base: "in5bvi9x", hover: "in5bvi9y", active: "in5bvi9z" }, defaultClass: "in5bvi9x" }, closeButtonBackground: { conditions: { base: "in5bvia0", hover: "in5bvia1", active: "in5bvia2" }, defaultClass: "in5bvia0" }, connectButtonBackground: { conditions: { base: "in5bvia3", hover: "in5bvia4", active: "in5bvia5" }, defaultClass: "in5bvia3" }, connectButtonBackgroundError: { conditions: { base: "in5bvia6", hover: "in5bvia7", active: "in5bvia8" }, defaultClass: "in5bvia6" }, connectButtonInnerBackground: { conditions: { base: "in5bvia9", hover: "in5bviaa", active: "in5bviab" }, defaultClass: "in5bvia9" }, connectButtonText: { conditions: { base: "in5bviac", hover: "in5bviad", active: "in5bviae" }, defaultClass: "in5bviac" }, connectButtonTextError: { conditions: { base: "in5bviaf", hover: "in5bviag", active: "in5bviah" }, defaultClass: "in5bviaf" }, connectionIndicator: { conditions: { base: "in5bviai", hover: "in5bviaj", active: "in5bviak" }, defaultClass: "in5bviai" }, downloadBottomCardBackground: { conditions: { base: "in5bvial", hover: "in5bviam", active: "in5bvian" }, defaultClass: "in5bvial" }, downloadTopCardBackground: { conditions: { base: "in5bviao", hover: "in5bviap", active: "in5bviaq" }, defaultClass: "in5bviao" }, error: { conditions: { base: "in5bviar", hover: "in5bvias", active: "in5bviat" }, defaultClass: "in5bviar" }, generalBorder: { conditions: { base: "in5bviau", hover: "in5bviav", active: "in5bviaw" }, defaultClass: "in5bviau" }, generalBorderDim: { conditions: { base: "in5bviax", hover: "in5bviay", active: "in5bviaz" }, defaultClass: "in5bviax" }, menuItemBackground: { conditions: { base: "in5bvib0", hover: "in5bvib1", active: "in5bvib2" }, defaultClass: "in5bvib0" }, modalBackdrop: { conditions: { base: "in5bvib3", hover: "in5bvib4", active: "in5bvib5" }, defaultClass: "in5bvib3" }, modalBackground: { conditions: { base: "in5bvib6", hover: "in5bvib7", active: "in5bvib8" }, defaultClass: "in5bvib6" }, modalBorder: { conditions: { base: "in5bvib9", hover: "in5bviba", active: "in5bvibb" }, defaultClass: "in5bvib9" }, modalText: { conditions: { base: "in5bvibc", hover: "in5bvibd", active: "in5bvibe" }, defaultClass: "in5bvibc" }, modalTextDim: { conditions: { base: "in5bvibf", hover: "in5bvibg", active: "in5bvibh" }, defaultClass: "in5bvibf" }, modalTextSecondary: { conditions: { base: "in5bvibi", hover: "in5bvibj", active: "in5bvibk" }, defaultClass: "in5bvibi" }, profileAction: { conditions: { base: "in5bvibl", hover: "in5bvibm", active: "in5bvibn" }, defaultClass: "in5bvibl" }, profileActionHover: { conditions: { base: "in5bvibo", hover: "in5bvibp", active: "in5bvibq" }, defaultClass: "in5bvibo" }, profileForeground: { conditions: { base: "in5bvibr", hover: "in5bvibs", active: "in5bvibt" }, defaultClass: "in5bvibr" }, selectedOptionBorder: { conditions: { base: "in5bvibu", hover: "in5bvibv", active: "in5bvibw" }, defaultClass: "in5bvibu" }, standby: { conditions: { base: "in5bvibx", hover: "in5bviby", active: "in5bvibz" }, defaultClass: "in5bvibx" } } }, borderColor: { values: { accentColor: { conditions: { base: "in5bvic0", hover: "in5bvic1", active: "in5bvic2" }, defaultClass: "in5bvic0" }, accentColorForeground: { conditions: { base: "in5bvic3", hover: "in5bvic4", active: "in5bvic5" }, defaultClass: "in5bvic3" }, actionButtonBorder: { conditions: { base: "in5bvic6", hover: "in5bvic7", active: "in5bvic8" }, defaultClass: "in5bvic6" }, actionButtonBorderMobile: { conditions: { base: "in5bvic9", hover: "in5bvica", active: "in5bvicb" }, defaultClass: "in5bvic9" }, actionButtonSecondaryBackground: { conditions: { base: "in5bvicc", hover: "in5bvicd", active: "in5bvice" }, defaultClass: "in5bvicc" }, closeButton: { conditions: { base: "in5bvicf", hover: "in5bvicg", active: "in5bvich" }, defaultClass: "in5bvicf" }, closeButtonBackground: { conditions: { base: "in5bvici", hover: "in5bvicj", active: "in5bvick" }, defaultClass: "in5bvici" }, connectButtonBackground: { conditions: { base: "in5bvicl", hover: "in5bvicm", active: "in5bvicn" }, defaultClass: "in5bvicl" }, connectButtonBackgroundError: { conditions: { base: "in5bvico", hover: "in5bvicp", active: "in5bvicq" }, defaultClass: "in5bvico" }, connectButtonInnerBackground: { conditions: { base: "in5bvicr", hover: "in5bvics", active: "in5bvict" }, defaultClass: "in5bvicr" }, connectButtonText: { conditions: { base: "in5bvicu", hover: "in5bvicv", active: "in5bvicw" }, defaultClass: "in5bvicu" }, connectButtonTextError: { conditions: { base: "in5bvicx", hover: "in5bvicy", active: "in5bvicz" }, defaultClass: "in5bvicx" }, connectionIndicator: { conditions: { base: "in5bvid0", hover: "in5bvid1", active: "in5bvid2" }, defaultClass: "in5bvid0" }, downloadBottomCardBackground: { conditions: { base: "in5bvid3", hover: "in5bvid4", active: "in5bvid5" }, defaultClass: "in5bvid3" }, downloadTopCardBackground: { conditions: { base: "in5bvid6", hover: "in5bvid7", active: "in5bvid8" }, defaultClass: "in5bvid6" }, error: { conditions: { base: "in5bvid9", hover: "in5bvida", active: "in5bvidb" }, defaultClass: "in5bvid9" }, generalBorder: { conditions: { base: "in5bvidc", hover: "in5bvidd", active: "in5bvide" }, defaultClass: "in5bvidc" }, generalBorderDim: { conditions: { base: "in5bvidf", hover: "in5bvidg", active: "in5bvidh" }, defaultClass: "in5bvidf" }, menuItemBackground: { conditions: { base: "in5bvidi", hover: "in5bvidj", active: "in5bvidk" }, defaultClass: "in5bvidi" }, modalBackdrop: { conditions: { base: "in5bvidl", hover: "in5bvidm", active: "in5bvidn" }, defaultClass: "in5bvidl" }, modalBackground: { conditions: { base: "in5bvido", hover: "in5bvidp", active: "in5bvidq" }, defaultClass: "in5bvido" }, modalBorder: { conditions: { base: "in5bvidr", hover: "in5bvids", active: "in5bvidt" }, defaultClass: "in5bvidr" }, modalText: { conditions: { base: "in5bvidu", hover: "in5bvidv", active: "in5bvidw" }, defaultClass: "in5bvidu" }, modalTextDim: { conditions: { base: "in5bvidx", hover: "in5bvidy", active: "in5bvidz" }, defaultClass: "in5bvidx" }, modalTextSecondary: { conditions: { base: "in5bvie0", hover: "in5bvie1", active: "in5bvie2" }, defaultClass: "in5bvie0" }, profileAction: { conditions: { base: "in5bvie3", hover: "in5bvie4", active: "in5bvie5" }, defaultClass: "in5bvie3" }, profileActionHover: { conditions: { base: "in5bvie6", hover: "in5bvie7", active: "in5bvie8" }, defaultClass: "in5bvie6" }, profileForeground: { conditions: { base: "in5bvie9", hover: "in5bviea", active: "in5bvieb" }, defaultClass: "in5bvie9" }, selectedOptionBorder: { conditions: { base: "in5bviec", hover: "in5bvied", active: "in5bviee" }, defaultClass: "in5bviec" }, standby: { conditions: { base: "in5bvief", hover: "in5bvieg", active: "in5bvieh" }, defaultClass: "in5bvief" } } }, boxShadow: { values: { connectButton: { conditions: { base: "in5bviei", hover: "in5bviej", active: "in5bviek" }, defaultClass: "in5bviei" }, dialog: { conditions: { base: "in5bviel", hover: "in5bviem", active: "in5bvien" }, defaultClass: "in5bviel" }, profileDetailsAction: { conditions: { base: "in5bvieo", hover: "in5bviep", active: "in5bvieq" }, defaultClass: "in5bvieo" }, selectedOption: { conditions: { base: "in5bvier", hover: "in5bvies", active: "in5bviet" }, defaultClass: "in5bvier" }, selectedWallet: { conditions: { base: "in5bvieu", hover: "in5bviev", active: "in5bview" }, defaultClass: "in5bvieu" }, walletLogo: { conditions: { base: "in5bviex", hover: "in5bviey", active: "in5bviez" }, defaultClass: "in5bviex" } } }, color: { values: { accentColor: { conditions: { base: "in5bvif0", hover: "in5bvif1", active: "in5bvif2" }, defaultClass: "in5bvif0" }, accentColorForeground: { conditions: { base: "in5bvif3", hover: "in5bvif4", active: "in5bvif5" }, defaultClass: "in5bvif3" }, actionButtonBorder: { conditions: { base: "in5bvif6", hover: "in5bvif7", active: "in5bvif8" }, defaultClass: "in5bvif6" }, actionButtonBorderMobile: { conditions: { base: "in5bvif9", hover: "in5bvifa", active: "in5bvifb" }, defaultClass: "in5bvif9" }, actionButtonSecondaryBackground: { conditions: { base: "in5bvifc", hover: "in5bvifd", active: "in5bvife" }, defaultClass: "in5bvifc" }, closeButton: { conditions: { base: "in5bviff", hover: "in5bvifg", active: "in5bvifh" }, defaultClass: "in5bviff" }, closeButtonBackground: { conditions: { base: "in5bvifi", hover: "in5bvifj", active: "in5bvifk" }, defaultClass: "in5bvifi" }, connectButtonBackground: { conditions: { base: "in5bvifl", hover: "in5bvifm", active: "in5bvifn" }, defaultClass: "in5bvifl" }, connectButtonBackgroundError: { conditions: { base: "in5bvifo", hover: "in5bvifp", active: "in5bvifq" }, defaultClass: "in5bvifo" }, connectButtonInnerBackground: { conditions: { base: "in5bvifr", hover: "in5bvifs", active: "in5bvift" }, defaultClass: "in5bvifr" }, connectButtonText: { conditions: { base: "in5bvifu", hover: "in5bvifv", active: "in5bvifw" }, defaultClass: "in5bvifu" }, connectButtonTextError: { conditions: { base: "in5bvifx", hover: "in5bvify", active: "in5bvifz" }, defaultClass: "in5bvifx" }, connectionIndicator: { conditions: { base: "in5bvig0", hover: "in5bvig1", active: "in5bvig2" }, defaultClass: "in5bvig0" }, downloadBottomCardBackground: { conditions: { base: "in5bvig3", hover: "in5bvig4", active: "in5bvig5" }, defaultClass: "in5bvig3" }, downloadTopCardBackground: { conditions: { base: "in5bvig6", hover: "in5bvig7", active: "in5bvig8" }, defaultClass: "in5bvig6" }, error: { conditions: { base: "in5bvig9", hover: "in5bviga", active: "in5bvigb" }, defaultClass: "in5bvig9" }, generalBorder: { conditions: { base: "in5bvigc", hover: "in5bvigd", active: "in5bvige" }, defaultClass: "in5bvigc" }, generalBorderDim: { conditions: { base: "in5bvigf", hover: "in5bvigg", active: "in5bvigh" }, defaultClass: "in5bvigf" }, menuItemBackground: { conditions: { base: "in5bvigi", hover: "in5bvigj", active: "in5bvigk" }, defaultClass: "in5bvigi" }, modalBackdrop: { conditions: { base: "in5bvigl", hover: "in5bvigm", active: "in5bvign" }, defaultClass: "in5bvigl" }, modalBackground: { conditions: { base: "in5bvigo", hover: "in5bvigp", active: "in5bvigq" }, defaultClass: "in5bvigo" }, modalBorder: { conditions: { base: "in5bvigr", hover: "in5bvigs", active: "in5bvigt" }, defaultClass: "in5bvigr" }, modalText: { conditions: { base: "in5bvigu", hover: "in5bvigv", active: "in5bvigw" }, defaultClass: "in5bvigu" }, modalTextDim: { conditions: { base: "in5bvigx", hover: "in5bvigy", active: "in5bvigz" }, defaultClass: "in5bvigx" }, modalTextSecondary: { conditions: { base: "in5bvih0", hover: "in5bvih1", active: "in5bvih2" }, defaultClass: "in5bvih0" }, profileAction: { conditions: { base: "in5bvih3", hover: "in5bvih4", active: "in5bvih5" }, defaultClass: "in5bvih3" }, profileActionHover: { conditions: { base: "in5bvih6", hover: "in5bvih7", active: "in5bvih8" }, defaultClass: "in5bvih6" }, profileForeground: { conditions: { base: "in5bvih9", hover: "in5bviha", active: "in5bvihb" }, defaultClass: "in5bvih9" }, selectedOptionBorder: { conditions: { base: "in5bvihc", hover: "in5bvihd", active: "in5bvihe" }, defaultClass: "in5bvihc" }, standby: { conditions: { base: "in5bvihf", hover: "in5bvihg", active: "in5bvihh" }, defaultClass: "in5bvihf" } } } } }, { conditions: { defaultCondition: "smallScreen", conditionNames: ["smallScreen", "largeScreen"], responsiveArray: void 0 }, styles: { alignItems: { values: { "flex-start": { conditions: { smallScreen: "in5bvi0", largeScreen: "in5bvi1" }, defaultClass: "in5bvi0" }, "flex-end": { conditions: { smallScreen: "in5bvi2", largeScreen: "in5bvi3" }, defaultClass: "in5bvi2" }, center: { conditions: { smallScreen: "in5bvi4", largeScreen: "in5bvi5" }, defaultClass: "in5bvi4" } } }, display: { values: { none: { conditions: { smallScreen: "in5bvi6", largeScreen: "in5bvi7" }, defaultClass: "in5bvi6" }, block: { conditions: { smallScreen: "in5bvi8", largeScreen: "in5bvi9" }, defaultClass: "in5bvi8" }, flex: { conditions: { smallScreen: "in5bvia", largeScreen: "in5bvib" }, defaultClass: "in5bvia" }, inline: { conditions: { smallScreen: "in5bvic", largeScreen: "in5bvid" }, defaultClass: "in5bvic" } } } } }, { conditions: void 0, styles: { margin: { mappings: ["marginTop", "marginBottom", "marginLeft", "marginRight"] }, marginX: { mappings: ["marginLeft", "marginRight"] }, marginY: { mappings: ["marginTop", "marginBottom"] }, padding: { mappings: ["paddingTop", "paddingBottom", "paddingLeft", "paddingRight"] }, paddingX: { mappings: ["paddingLeft", "paddingRight"] }, paddingY: { mappings: ["paddingTop", "paddingBottom"] }, alignSelf: { values: { "flex-start": { defaultClass: "in5bvie" }, "flex-end": { defaultClass: "in5bvif" }, center: { defaultClass: "in5bvig" } } }, backgroundSize: { values: { cover: { defaultClass: "in5bvih" } } }, borderRadius: { values: { 1: { defaultClass: "in5bvii" }, 6: { defaultClass: "in5bvij" }, 10: { defaultClass: "in5bvik" }, 13: { defaultClass: "in5bvil" }, actionButton: { defaultClass: "in5bvim" }, connectButton: { defaultClass: "in5bvin" }, menuButton: { defaultClass: "in5bvio" }, modal: { defaultClass: "in5bvip" }, modalMobile: { defaultClass: "in5bviq" }, "25%": { defaultClass: "in5bvir" }, full: { defaultClass: "in5bvis" } } }, borderStyle: { values: { solid: { defaultClass: "in5bvit" } } }, borderWidth: { values: { 0: { defaultClass: "in5bviu" }, 1: { defaultClass: "in5bviv" }, 2: { defaultClass: "in5bviw" }, 4: { defaultClass: "in5bvix" } } }, cursor: { values: { pointer: { defaultClass: "in5bviy" }, none: { defaultClass: "in5bviz" } } }, pointerEvents: { values: { none: { defaultClass: "in5bvi10" }, all: { defaultClass: "in5bvi11" } } }, minHeight: { values: { 8: { defaultClass: "in5bvi12" }, 44: { defaultClass: "in5bvi13" } } }, flexDirection: { values: { row: { defaultClass: "in5bvi14" }, column: { defaultClass: "in5bvi15" } } }, fontFamily: { values: { body: { defaultClass: "in5bvi16" } } }, fontSize: { values: { 12: { defaultClass: "in5bvi17" }, 13: { defaultClass: "in5bvi18" }, 14: { defaultClass: "in5bvi19" }, 16: { defaultClass: "in5bvi1a" }, 18: { defaultClass: "in5bvi1b" }, 20: { defaultClass: "in5bvi1c" }, 23: { defaultClass: "in5bvi1d" } } }, fontWeight: { values: { regular: { defaultClass: "in5bvi1e" }, medium: { defaultClass: "in5bvi1f" }, semibold: { defaultClass: "in5bvi1g" }, bold: { defaultClass: "in5bvi1h" }, heavy: { defaultClass: "in5bvi1i" } } }, gap: { values: { 0: { defaultClass: "in5bvi1j" }, 1: { defaultClass: "in5bvi1k" }, 2: { defaultClass: "in5bvi1l" }, 3: { defaultClass: "in5bvi1m" }, 4: { defaultClass: "in5bvi1n" }, 5: { defaultClass: "in5bvi1o" }, 6: { defaultClass: "in5bvi1p" }, 8: { defaultClass: "in5bvi1q" }, 10: { defaultClass: "in5bvi1r" }, 12: { defaultClass: "in5bvi1s" }, 14: { defaultClass: "in5bvi1t" }, 16: { defaultClass: "in5bvi1u" }, 18: { defaultClass: "in5bvi1v" }, 20: { defaultClass: "in5bvi1w" }, 24: { defaultClass: "in5bvi1x" }, 28: { defaultClass: "in5bvi1y" }, 32: { defaultClass: "in5bvi1z" }, 36: { defaultClass: "in5bvi20" }, 44: { defaultClass: "in5bvi21" }, 64: { defaultClass: "in5bvi22" }, "-1": { defaultClass: "in5bvi23" } } }, height: { values: { 1: { defaultClass: "in5bvi24" }, 2: { defaultClass: "in5bvi25" }, 4: { defaultClass: "in5bvi26" }, 8: { defaultClass: "in5bvi27" }, 12: { defaultClass: "in5bvi28" }, 20: { defaultClass: "in5bvi29" }, 24: { defaultClass: "in5bvi2a" }, 28: { defaultClass: "in5bvi2b" }, 30: { defaultClass: "in5bvi2c" }, 32: { defaultClass: "in5bvi2d" }, 34: { defaultClass: "in5bvi2e" }, 36: { defaultClass: "in5bvi2f" }, 40: { defaultClass: "in5bvi2g" }, 44: { defaultClass: "in5bvi2h" }, 48: { defaultClass: "in5bvi2i" }, 54: { defaultClass: "in5bvi2j" }, 60: { defaultClass: "in5bvi2k" }, 200: { defaultClass: "in5bvi2l" }, full: { defaultClass: "in5bvi2m" }, max: { defaultClass: "in5bvi2n" } } }, justifyContent: { values: { "flex-start": { defaultClass: "in5bvi2o" }, "flex-end": { defaultClass: "in5bvi2p" }, center: { defaultClass: "in5bvi2q" }, "space-between": { defaultClass: "in5bvi2r" }, "space-around": { defaultClass: "in5bvi2s" } } }, textAlign: { values: { left: { defaultClass: "in5bvi2t" }, center: { defaultClass: "in5bvi2u" }, inherit: { defaultClass: "in5bvi2v" } } }, marginBottom: { values: { 0: { defaultClass: "in5bvi2w" }, 1: { defaultClass: "in5bvi2x" }, 2: { defaultClass: "in5bvi2y" }, 3: { defaultClass: "in5bvi2z" }, 4: { defaultClass: "in5bvi30" }, 5: { defaultClass: "in5bvi31" }, 6: { defaultClass: "in5bvi32" }, 8: { defaultClass: "in5bvi33" }, 10: { defaultClass: "in5bvi34" }, 12: { defaultClass: "in5bvi35" }, 14: { defaultClass: "in5bvi36" }, 16: { defaultClass: "in5bvi37" }, 18: { defaultClass: "in5bvi38" }, 20: { defaultClass: "in5bvi39" }, 24: { defaultClass: "in5bvi3a" }, 28: { defaultClass: "in5bvi3b" }, 32: { defaultClass: "in5bvi3c" }, 36: { defaultClass: "in5bvi3d" }, 44: { defaultClass: "in5bvi3e" }, 64: { defaultClass: "in5bvi3f" }, "-1": { defaultClass: "in5bvi3g" } } }, marginLeft: { values: { 0: { defaultClass: "in5bvi3h" }, 1: { defaultClass: "in5bvi3i" }, 2: { defaultClass: "in5bvi3j" }, 3: { defaultClass: "in5bvi3k" }, 4: { defaultClass: "in5bvi3l" }, 5: { defaultClass: "in5bvi3m" }, 6: { defaultClass: "in5bvi3n" }, 8: { defaultClass: "in5bvi3o" }, 10: { defaultClass: "in5bvi3p" }, 12: { defaultClass: "in5bvi3q" }, 14: { defaultClass: "in5bvi3r" }, 16: { defaultClass: "in5bvi3s" }, 18: { defaultClass: "in5bvi3t" }, 20: { defaultClass: "in5bvi3u" }, 24: { defaultClass: "in5bvi3v" }, 28: { defaultClass: "in5bvi3w" }, 32: { defaultClass: "in5bvi3x" }, 36: { defaultClass: "in5bvi3y" }, 44: { defaultClass: "in5bvi3z" }, 64: { defaultClass: "in5bvi40" }, "-1": { defaultClass: "in5bvi41" } } }, marginRight: { values: { 0: { defaultClass: "in5bvi42" }, 1: { defaultClass: "in5bvi43" }, 2: { defaultClass: "in5bvi44" }, 3: { defaultClass: "in5bvi45" }, 4: { defaultClass: "in5bvi46" }, 5: { defaultClass: "in5bvi47" }, 6: { defaultClass: "in5bvi48" }, 8: { defaultClass: "in5bvi49" }, 10: { defaultClass: "in5bvi4a" }, 12: { defaultClass: "in5bvi4b" }, 14: { defaultClass: "in5bvi4c" }, 16: { defaultClass: "in5bvi4d" }, 18: { defaultClass: "in5bvi4e" }, 20: { defaultClass: "in5bvi4f" }, 24: { defaultClass: "in5bvi4g" }, 28: { defaultClass: "in5bvi4h" }, 32: { defaultClass: "in5bvi4i" }, 36: { defaultClass: "in5bvi4j" }, 44: { defaultClass: "in5bvi4k" }, 64: { defaultClass: "in5bvi4l" }, "-1": { defaultClass: "in5bvi4m" } } }, marginTop: { values: { 0: { defaultClass: "in5bvi4n" }, 1: { defaultClass: "in5bvi4o" }, 2: { defaultClass: "in5bvi4p" }, 3: { defaultClass: "in5bvi4q" }, 4: { defaultClass: "in5bvi4r" }, 5: { defaultClass: "in5bvi4s" }, 6: { defaultClass: "in5bvi4t" }, 8: { defaultClass: "in5bvi4u" }, 10: { defaultClass: "in5bvi4v" }, 12: { defaultClass: "in5bvi4w" }, 14: { defaultClass: "in5bvi4x" }, 16: { defaultClass: "in5bvi4y" }, 18: { defaultClass: "in5bvi4z" }, 20: { defaultClass: "in5bvi50" }, 24: { defaultClass: "in5bvi51" }, 28: { defaultClass: "in5bvi52" }, 32: { defaultClass: "in5bvi53" }, 36: { defaultClass: "in5bvi54" }, 44: { defaultClass: "in5bvi55" }, 64: { defaultClass: "in5bvi56" }, "-1": { defaultClass: "in5bvi57" } } }, maxWidth: { values: { 1: { defaultClass: "in5bvi58" }, 2: { defaultClass: "in5bvi59" }, 4: { defaultClass: "in5bvi5a" }, 8: { defaultClass: "in5bvi5b" }, 12: { defaultClass: "in5bvi5c" }, 20: { defaultClass: "in5bvi5d" }, 24: { defaultClass: "in5bvi5e" }, 28: { defaultClass: "in5bvi5f" }, 30: { defaultClass: "in5bvi5g" }, 32: { defaultClass: "in5bvi5h" }, 34: { defaultClass: "in5bvi5i" }, 36: { defaultClass: "in5bvi5j" }, 40: { defaultClass: "in5bvi5k" }, 44: { defaultClass: "in5bvi5l" }, 48: { defaultClass: "in5bvi5m" }, 54: { defaultClass: "in5bvi5n" }, 60: { defaultClass: "in5bvi5o" }, 200: { defaultClass: "in5bvi5p" }, full: { defaultClass: "in5bvi5q" }, max: { defaultClass: "in5bvi5r" } } }, minWidth: { values: { 1: { defaultClass: "in5bvi5s" }, 2: { defaultClass: "in5bvi5t" }, 4: { defaultClass: "in5bvi5u" }, 8: { defaultClass: "in5bvi5v" }, 12: { defaultClass: "in5bvi5w" }, 20: { defaultClass: "in5bvi5x" }, 24: { defaultClass: "in5bvi5y" }, 28: { defaultClass: "in5bvi5z" }, 30: { defaultClass: "in5bvi60" }, 32: { defaultClass: "in5bvi61" }, 34: { defaultClass: "in5bvi62" }, 36: { defaultClass: "in5bvi63" }, 40: { defaultClass: "in5bvi64" }, 44: { defaultClass: "in5bvi65" }, 48: { defaultClass: "in5bvi66" }, 54: { defaultClass: "in5bvi67" }, 60: { defaultClass: "in5bvi68" }, 200: { defaultClass: "in5bvi69" }, full: { defaultClass: "in5bvi6a" }, max: { defaultClass: "in5bvi6b" } } }, overflow: { values: { hidden: { defaultClass: "in5bvi6c" } } }, paddingBottom: { values: { 0: { defaultClass: "in5bvi6d" }, 1: { defaultClass: "in5bvi6e" }, 2: { defaultClass: "in5bvi6f" }, 3: { defaultClass: "in5bvi6g" }, 4: { defaultClass: "in5bvi6h" }, 5: { defaultClass: "in5bvi6i" }, 6: { defaultClass: "in5bvi6j" }, 8: { defaultClass: "in5bvi6k" }, 10: { defaultClass: "in5bvi6l" }, 12: { defaultClass: "in5bvi6m" }, 14: { defaultClass: "in5bvi6n" }, 16: { defaultClass: "in5bvi6o" }, 18: { defaultClass: "in5bvi6p" }, 20: { defaultClass: "in5bvi6q" }, 24: { defaultClass: "in5bvi6r" }, 28: { defaultClass: "in5bvi6s" }, 32: { defaultClass: "in5bvi6t" }, 36: { defaultClass: "in5bvi6u" }, 44: { defaultClass: "in5bvi6v" }, 64: { defaultClass: "in5bvi6w" }, "-1": { defaultClass: "in5bvi6x" } } }, paddingLeft: { values: { 0: { defaultClass: "in5bvi6y" }, 1: { defaultClass: "in5bvi6z" }, 2: { defaultClass: "in5bvi70" }, 3: { defaultClass: "in5bvi71" }, 4: { defaultClass: "in5bvi72" }, 5: { defaultClass: "in5bvi73" }, 6: { defaultClass: "in5bvi74" }, 8: { defaultClass: "in5bvi75" }, 10: { defaultClass: "in5bvi76" }, 12: { defaultClass: "in5bvi77" }, 14: { defaultClass: "in5bvi78" }, 16: { defaultClass: "in5bvi79" }, 18: { defaultClass: "in5bvi7a" }, 20: { defaultClass: "in5bvi7b" }, 24: { defaultClass: "in5bvi7c" }, 28: { defaultClass: "in5bvi7d" }, 32: { defaultClass: "in5bvi7e" }, 36: { defaultClass: "in5bvi7f" }, 44: { defaultClass: "in5bvi7g" }, 64: { defaultClass: "in5bvi7h" }, "-1": { defaultClass: "in5bvi7i" } } }, paddingRight: { values: { 0: { defaultClass: "in5bvi7j" }, 1: { defaultClass: "in5bvi7k" }, 2: { defaultClass: "in5bvi7l" }, 3: { defaultClass: "in5bvi7m" }, 4: { defaultClass: "in5bvi7n" }, 5: { defaultClass: "in5bvi7o" }, 6: { defaultClass: "in5bvi7p" }, 8: { defaultClass: "in5bvi7q" }, 10: { defaultClass: "in5bvi7r" }, 12: { defaultClass: "in5bvi7s" }, 14: { defaultClass: "in5bvi7t" }, 16: { defaultClass: "in5bvi7u" }, 18: { defaultClass: "in5bvi7v" }, 20: { defaultClass: "in5bvi7w" }, 24: { defaultClass: "in5bvi7x" }, 28: { defaultClass: "in5bvi7y" }, 32: { defaultClass: "in5bvi7z" }, 36: { defaultClass: "in5bvi80" }, 44: { defaultClass: "in5bvi81" }, 64: { defaultClass: "in5bvi82" }, "-1": { defaultClass: "in5bvi83" } } }, paddingTop: { values: { 0: { defaultClass: "in5bvi84" }, 1: { defaultClass: "in5bvi85" }, 2: { defaultClass: "in5bvi86" }, 3: { defaultClass: "in5bvi87" }, 4: { defaultClass: "in5bvi88" }, 5: { defaultClass: "in5bvi89" }, 6: { defaultClass: "in5bvi8a" }, 8: { defaultClass: "in5bvi8b" }, 10: { defaultClass: "in5bvi8c" }, 12: { defaultClass: "in5bvi8d" }, 14: { defaultClass: "in5bvi8e" }, 16: { defaultClass: "in5bvi8f" }, 18: { defaultClass: "in5bvi8g" }, 20: { defaultClass: "in5bvi8h" }, 24: { defaultClass: "in5bvi8i" }, 28: { defaultClass: "in5bvi8j" }, 32: { defaultClass: "in5bvi8k" }, 36: { defaultClass: "in5bvi8l" }, 44: { defaultClass: "in5bvi8m" }, 64: { defaultClass: "in5bvi8n" }, "-1": { defaultClass: "in5bvi8o" } } }, position: { values: { absolute: { defaultClass: "in5bvi8p" }, fixed: { defaultClass: "in5bvi8q" }, relative: { defaultClass: "in5bvi8r" } } }, WebkitUserSelect: { values: { none: { defaultClass: "in5bvi8s" } } }, right: { values: { 0: { defaultClass: "in5bvi8t" } } }, transition: { values: { default: { defaultClass: "in5bvi8u" }, transform: { defaultClass: "in5bvi8v" } } }, userSelect: { values: { none: { defaultClass: "in5bvi8w" } } }, width: { values: { 1: { defaultClass: "in5bvi8x" }, 2: { defaultClass: "in5bvi8y" }, 4: { defaultClass: "in5bvi8z" }, 8: { defaultClass: "in5bvi90" }, 12: { defaultClass: "in5bvi91" }, 20: { defaultClass: "in5bvi92" }, 24: { defaultClass: "in5bvi93" }, 28: { defaultClass: "in5bvi94" }, 30: { defaultClass: "in5bvi95" }, 32: { defaultClass: "in5bvi96" }, 34: { defaultClass: "in5bvi97" }, 36: { defaultClass: "in5bvi98" }, 40: { defaultClass: "in5bvi99" }, 44: { defaultClass: "in5bvi9a" }, 48: { defaultClass: "in5bvi9b" }, 54: { defaultClass: "in5bvi9c" }, 60: { defaultClass: "in5bvi9d" }, 200: { defaultClass: "in5bvi9e" }, full: { defaultClass: "in5bvi9f" }, max: { defaultClass: "in5bvi9g" } } }, backdropFilter: { values: { modalOverlay: { defaultClass: "in5bvi9h" } } } } }), TE = { colors: { accentColor: "var(--rk-colors-accentColor)", accentColorForeground: "var(--rk-colors-accentColorForeground)", actionButtonBorder: "var(--rk-colors-actionButtonBorder)", actionButtonBorderMobile: "var(--rk-colors-actionButtonBorderMobile)", actionButtonSecondaryBackground: "var(--rk-colors-actionButtonSecondaryBackground)", closeButton: "var(--rk-colors-closeButton)", closeButtonBackground: "var(--rk-colors-closeButtonBackground)", connectButtonBackground: "var(--rk-colors-connectButtonBackground)", connectButtonBackgroundError: "var(--rk-colors-connectButtonBackgroundError)", connectButtonInnerBackground: "var(--rk-colors-connectButtonInnerBackground)", connectButtonText: "var(--rk-colors-connectButtonText)", connectButtonTextError: "var(--rk-colors-connectButtonTextError)", connectionIndicator: "var(--rk-colors-connectionIndicator)", downloadBottomCardBackground: "var(--rk-colors-downloadBottomCardBackground)", downloadTopCardBackground: "var(--rk-colors-downloadTopCardBackground)", error: "var(--rk-colors-error)", generalBorder: "var(--rk-colors-generalBorder)", generalBorderDim: "var(--rk-colors-generalBorderDim)", menuItemBackground: "var(--rk-colors-menuItemBackground)", modalBackdrop: "var(--rk-colors-modalBackdrop)", modalBackground: "var(--rk-colors-modalBackground)", modalBorder: "var(--rk-colors-modalBorder)", modalText: "var(--rk-colors-modalText)", modalTextDim: "var(--rk-colors-modalTextDim)", modalTextSecondary: "var(--rk-colors-modalTextSecondary)", profileAction: "var(--rk-colors-profileAction)", profileActionHover: "var(--rk-colors-profileActionHover)", profileForeground: "var(--rk-colors-profileForeground)", selectedOptionBorder: "var(--rk-colors-selectedOptionBorder)", standby: "var(--rk-colors-standby)" }, fonts: { body: "var(--rk-fonts-body)" }, radii: { actionButton: "var(--rk-radii-actionButton)", connectButton: "var(--rk-radii-connectButton)", menuButton: "var(--rk-radii-menuButton)", modal: "var(--rk-radii-modal)", modalMobile: "var(--rk-radii-modalMobile)" }, shadows: { connectButton: "var(--rk-shadows-connectButton)", dialog: "var(--rk-shadows-dialog)", profileDetailsAction: "var(--rk-shadows-profileDetailsAction)", selectedOption: "var(--rk-shadows-selectedOption)", selectedWallet: "var(--rk-shadows-selectedWallet)", walletLogo: "var(--rk-shadows-walletLogo)" }, blurs: { modalOverlay: "var(--rk-blurs-modalOverlay)" } }, PY = { shrink: "_1y8a2mu6", shrinkSm: "_1y8a2mu7" }, OY = "_1y8a2mu3 in5bvi8r", BY = { grow: "_1y8a2mu4", growLg: "_1y8a2mu5" };
function mn({ active: e, hover: t }) {
  return [OY, t && BY[t], PY[e]];
}
var x5 = Ge(
  null
);
function NY() {
  const { adapter: e } = we(x5) ?? {};
  if (!e)
    throw new Error("No authentication adapter found");
  return e;
}
function py() {
  const e = we(x5);
  return (e == null ? void 0 : e.status) ?? null;
}
function Zw() {
  const e = py(), { isConnected: t } = ur();
  return t ? e && (e === "loading" || e === "unauthenticated") ? e : "connected" : "disconnected";
}
function DY() {
  return typeof navigator < "u" && /android/i.test(navigator.userAgent);
}
function jY() {
  return typeof navigator < "u" && /iPhone|iPod/.test(navigator.userAgent);
}
function MY() {
  return typeof navigator < "u" && (/iPad/.test(navigator.userAgent) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
}
function yy() {
  return jY() || MY();
}
function zn() {
  return DY() || yy();
}
var FY = "ssroob0", LY = { a: "ssrooba", blockquote: "ssroob2", button: "ssroob9", input: "ssroob8 ssroob5 ssroob4", mark: "ssroob6", ol: "ssroob1", q: "ssroob2", select: "ssroob7 ssroob5 ssroob4", table: "ssroob3", textarea: "ssroob5 ssroob4", ul: "ssroob1" }, UY = ({ reset: e, ...t }) => {
  if (!e)
    return qb(t);
  const n = LY[e], r = qb(t);
  return _I(FY, n, r);
}, K = P.forwardRef(
  ({ as: e = "div", className: t, testId: n, ...r }, i) => {
    const o = {}, s = {};
    for (const l in r)
      qb.properties.has(l) ? o[l] = r[l] : s[l] = r[l];
    const a = UY({
      reset: typeof e == "string" ? e : "div",
      ...o
    });
    return P.createElement(e, {
      className: _I(a, t),
      ...s,
      "data-testid": n ? `rk-${n.replace(/^rk-/, "")}` : void 0,
      ref: i
    });
  }
);
K.displayName = "Box";
var C5 = /* @__PURE__ */ new Map(), bg = /* @__PURE__ */ new Map();
async function k5(e) {
  const t = bg.get(e);
  if (t)
    return t;
  const n = async () => e().then(async (i) => (C5.set(e, i), i)), r = n().catch((i) => n().catch((o) => {
    bg.delete(e);
  }));
  return bg.set(e, r), r;
}
async function Zi(...e) {
  return await Promise.all(
    e.map((t) => typeof t == "function" ? k5(t) : t)
  );
}
function zY() {
  const [, e] = _c((t) => t + 1, 0);
  return e;
}
function e1(e) {
  const t = typeof e == "function" ? C5.get(e) : void 0, n = zY();
  return Te(() => {
    typeof e == "function" && !t && k5(e).then(n);
  }, [e, t, n]), typeof e == "function" ? t : e;
}
function An({
  alt: e,
  background: t,
  borderColor: n,
  borderRadius: r,
  useAsImage: i,
  boxShadow: o,
  height: s,
  src: a,
  width: l,
  testId: c
}) {
  const u = yy(), d = e1(a), f = d && /^http/.test(d), [h, p] = _c(
    () => !0,
    !1
  );
  return /* @__PURE__ */ I.createElement(
    K,
    {
      "aria-label": e,
      borderRadius: r,
      boxShadow: o,
      height: typeof s == "string" ? s : void 0,
      overflow: "hidden",
      position: "relative",
      role: "img",
      style: {
        background: t,
        height: typeof s == "number" ? s : void 0,
        width: typeof l == "number" ? l : void 0
      },
      width: typeof l == "string" ? l : void 0,
      testId: c
    },
    /* @__PURE__ */ I.createElement(
      K,
      {
        ...f ? (
          // biome-ignore format: design system keys
          {
            "aria-hidden": !0,
            as: "img",
            onLoad: p,
            src: d
          }
        ) : { "aria-hidden": !0, as: "img", src: d },
        height: "full",
        position: "absolute",
        ...u ? { WebkitUserSelect: "none" } : {},
        style: {
          WebkitTouchCallout: "none",
          transition: "opacity .15s linear",
          userSelect: "none",
          ...!i && f ? {
            opacity: h ? 1 : 0
          } : {}
        },
        width: "full"
      }
    ),
    n ? /* @__PURE__ */ I.createElement(
      K,
      {
        ...typeof n == "object" && "custom" in n ? { style: { borderColor: n.custom } } : { borderColor: n },
        borderRadius: r,
        borderStyle: "solid",
        borderWidth: "1",
        height: "full",
        position: "relative",
        width: "full"
      }
    ) : null
  );
}
var VY = "ovowzo2", qY = "ovowzo3", $Y = (e) => J(
  () => `${e}_${Math.round(Math.random() * 1e9)}`,
  [e]
), ad = ({
  height: e = 21,
  width: t = 21
}) => {
  const n = $Y("spinner");
  return /* @__PURE__ */ I.createElement(
    "svg",
    {
      className: VY,
      fill: "none",
      height: e,
      viewBox: "0 0 21 21",
      width: t,
      xmlns: "http://www.w3.org/2000/svg"
    },
    /* @__PURE__ */ I.createElement("title", null, "Loading"),
    /* @__PURE__ */ I.createElement("clipPath", { id: n }, /* @__PURE__ */ I.createElement("path", { d: "M10.5 3C6.35786 3 3 6.35786 3 10.5C3 14.6421 6.35786 18 10.5 18C11.3284 18 12 18.6716 12 19.5C12 20.3284 11.3284 21 10.5 21C4.70101 21 0 16.299 0 10.5C0 4.70101 4.70101 0 10.5 0C16.299 0 21 4.70101 21 10.5C21 11.3284 20.3284 12 19.5 12C18.6716 12 18 11.3284 18 10.5C18 6.35786 14.6421 3 10.5 3Z" })),
    /* @__PURE__ */ I.createElement(
      "foreignObject",
      {
        clipPath: `url(#${n})`,
        height: "21",
        width: "21",
        x: "0",
        y: "0"
      },
      /* @__PURE__ */ I.createElement("div", { className: qY })
    )
  );
}, kt = [
  "#FC5C54",
  "#FFD95A",
  "#E95D72",
  "#6A87C8",
  "#5FD0F3",
  "#75C06B",
  "#FFDD86",
  "#5FC6D4",
  "#FF949A",
  "#FF8024",
  "#9BA1A4",
  "#EC66FF",
  "#FF8CBC",
  "#FF9A23",
  "#C5DADB",
  "#A8CE63",
  "#71ABFF",
  "#FFE279",
  "#B6B1B6",
  "#FF6780",
  "#A575FF",
  "#4D82FF",
  "#FFB35A"
], _E = [
  { color: kt[0], emoji: "🌶" },
  { color: kt[1], emoji: "🤑" },
  { color: kt[2], emoji: "🐙" },
  { color: kt[3], emoji: "🫐" },
  { color: kt[4], emoji: "🐳" },
  { color: kt[0], emoji: "🤶" },
  { color: kt[5], emoji: "🌲" },
  { color: kt[6], emoji: "🌞" },
  { color: kt[7], emoji: "🐒" },
  { color: kt[8], emoji: "🐵" },
  { color: kt[9], emoji: "🦊" },
  { color: kt[10], emoji: "🐼" },
  { color: kt[11], emoji: "🦄" },
  { color: kt[12], emoji: "🐷" },
  { color: kt[13], emoji: "🐧" },
  { color: kt[8], emoji: "🦩" },
  { color: kt[14], emoji: "👽" },
  { color: kt[0], emoji: "🎈" },
  { color: kt[8], emoji: "🍉" },
  { color: kt[1], emoji: "🎉" },
  { color: kt[15], emoji: "🐲" },
  { color: kt[16], emoji: "🌎" },
  { color: kt[17], emoji: "🍊" },
  { color: kt[18], emoji: "🐭" },
  { color: kt[19], emoji: "🍣" },
  { color: kt[1], emoji: "🐥" },
  { color: kt[20], emoji: "👾" },
  { color: kt[15], emoji: "🥦" },
  { color: kt[0], emoji: "👹" },
  { color: kt[17], emoji: "🙀" },
  { color: kt[4], emoji: "⛱" },
  { color: kt[21], emoji: "⛵️" },
  { color: kt[17], emoji: "🥳" },
  { color: kt[8], emoji: "🤯" },
  { color: kt[22], emoji: "🤠" }
];
function WY(e) {
  let t = 0;
  if (e.length === 0)
    return t;
  for (let n = 0; n < e.length; n++) {
    const r = e.charCodeAt(n);
    t = (t << 5) - t + r, t |= 0;
  }
  return t;
}
function GY(e) {
  const n = Math.abs(
    WY((typeof e == "string" ? e : "").toLowerCase()) % _E.length
  );
  return _E[n ?? 0];
}
var HY = ({ address: e, ensImage: t, size: n }) => {
  const [r, i] = Oe(!1);
  Te(() => {
    if (t) {
      const a = new Image();
      a.src = t, a.onload = () => i(!0);
    }
  }, [t]);
  const { color: o, emoji: s } = J(
    () => GY(e),
    [e]
  );
  return t ? r ? /* @__PURE__ */ I.createElement(
    K,
    {
      backgroundSize: "cover",
      borderRadius: "full",
      position: "absolute",
      style: {
        backgroundImage: `url(${t})`,
        backgroundPosition: "center",
        height: n,
        width: n
      }
    }
  ) : /* @__PURE__ */ I.createElement(
    K,
    {
      alignItems: "center",
      backgroundSize: "cover",
      borderRadius: "full",
      color: "modalText",
      display: "flex",
      justifyContent: "center",
      position: "absolute",
      style: {
        height: n,
        width: n
      }
    },
    /* @__PURE__ */ I.createElement(ad, null)
  ) : /* @__PURE__ */ I.createElement(
    K,
    {
      alignItems: "center",
      display: "flex",
      justifyContent: "center",
      overflow: "hidden",
      style: {
        ...!t && { backgroundColor: o },
        height: n,
        width: n
      }
    },
    s
  );
}, E5 = HY, t1 = Ge(E5);
function S5({ address: e, imageUrl: t, loading: n, size: r }) {
  const i = we(t1);
  return /* @__PURE__ */ I.createElement(
    K,
    {
      "aria-hidden": !0,
      borderRadius: "full",
      overflow: "hidden",
      position: "relative",
      style: {
        height: `${r}px`,
        width: `${r}px`
      },
      userSelect: "none"
    },
    /* @__PURE__ */ I.createElement(
      K,
      {
        alignItems: "center",
        borderRadius: "full",
        display: "flex",
        justifyContent: "center",
        overflow: "hidden",
        position: "absolute",
        style: {
          fontSize: `${Math.round(r * 0.55)}px`,
          height: `${r}px`,
          transform: n ? "scale(0.72)" : void 0,
          transition: ".25s ease",
          transitionDelay: n ? void 0 : ".1s",
          width: `${r}px`,
          willChange: "transform"
        },
        userSelect: "none"
      },
      /* @__PURE__ */ I.createElement(i, { address: e, ensImage: t, size: r })
    ),
    n && /* @__PURE__ */ I.createElement(
      K,
      {
        color: "accentColor",
        display: "flex",
        height: "full",
        position: "absolute",
        width: "full"
      },
      /* @__PURE__ */ I.createElement(ad, { height: "100%", width: "100%" })
    )
  );
}
var IE = () => /* @__PURE__ */ I.createElement("svg", { fill: "none", height: "7", width: "14", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ I.createElement("title", null, "Dropdown"), /* @__PURE__ */ I.createElement(
  "path",
  {
    d: "M12.75 1.54001L8.51647 5.0038C7.77974 5.60658 6.72026 5.60658 5.98352 5.0038L1.75 1.54001",
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: "2.5",
    xmlns: "http://www.w3.org/2000/svg"
  }
)), RE = {
  defaultLocale: "en",
  locale: "en"
}, KY = class {
  constructor(e) {
    this.listeners = /* @__PURE__ */ new Set(), this.defaultLocale = RE.defaultLocale, this.enableFallback = !1, this.locale = RE.locale, this.cachedLocales = [], this.translations = {};
    for (const [t, n] of Object.entries(e))
      this.cachedLocales = [...this.cachedLocales, t], this.translations = {
        ...this.translations,
        ...this.flattenTranslation(n, t)
      };
  }
  missingMessage(e) {
    return `[missing: "${this.locale}.${e}" translation]`;
  }
  flattenTranslation(e, t) {
    const n = {}, r = (i, o) => {
      for (const s of Object.keys(i)) {
        const a = `${o}.${s}`, l = i[s];
        typeof l == "object" && l !== null ? r(l, a) : n[a] = l;
      }
    };
    return r(e, t), n;
  }
  translateWithReplacements(e, t = {}) {
    let n = e;
    for (const r in t) {
      const i = t[r];
      n = n.replace(
        `%{${r}}`,
        i
      );
    }
    return n;
  }
  t(e, t, n) {
    const r = `${this.locale}.${e}`, i = this.translations[r];
    if (!i) {
      if (this.enableFallback) {
        const o = `${this.defaultLocale}.${e}`, s = this.translations[o];
        if (s)
          return this.translateWithReplacements(
            s,
            t
          );
      }
      return n != null && n.rawKeyIfTranslationMissing ? e : this.missingMessage(e);
    }
    return this.translateWithReplacements(i, t);
  }
  isLocaleCached(e) {
    return this.cachedLocales.includes(e);
  }
  updateLocale(e) {
    this.locale = e, this.notifyListeners();
  }
  setTranslations(e, t) {
    this.isLocaleCached(e) || (this.cachedLocales = [...this.cachedLocales, e], this.translations = {
      ...this.translations,
      ...this.flattenTranslation(t, e)
    }), this.locale = e, this.notifyListeners();
  }
  notifyListeners() {
    for (const e of this.listeners)
      e();
  }
  onChange(e) {
    return this.listeners.add(e), () => {
      this.listeners.delete(e);
    };
  }
}, Xr = new KY({
  en: JSON.parse(gk),
  "en-US": JSON.parse(gk)
});
Xr.defaultLocale = "en-US";
Xr.locale = "en-US";
Xr.enableFallback = !0;
var YY = async (e) => {
  switch (e) {
    case "ar":
    case "ar-AR":
      return (await import("./ar_AR-OBNLAES4-Dja2hlQc.js")).default;
    case "en":
    case "en-US":
      return (await import("./en_US-FEVFXARA-C6xYcZt7.js")).default;
    case "es":
    case "es-419":
      return (await import("./es_419-O2GTQZ7N-BjjQGG9j.js")).default;
    case "fr":
    case "fr-FR":
      return (await import("./fr_FR-L4QMIDHZ-ye7ItZjL.js")).default;
    case "hi":
    case "hi-IN":
      return (await import("./hi_IN-JNRRBHWZ-Dhp0QYVL.js")).default;
    case "id":
    case "id-ID":
      return (await import("./id_ID-ZGYTXMOP-CGGTM7TB.js")).default;
    case "ja":
    case "ja-JP":
      return (await import("./ja_JP-HOTHN4EA-CwnShEAB.js")).default;
    case "ko":
    case "ko-KR":
      return (await import("./ko_KR-GIW3THCV-D5W1LBo5.js")).default;
    case "pt":
    case "pt-BR":
      return (await import("./pt_BR-F7QMXAJN-Bh_7XM57.js")).default;
    case "ru":
    case "ru-RU":
      return (await import("./ru_RU-X7PLXGFL-DF7GBMSY.js")).default;
    case "th":
    case "th-TH":
      return (await import("./th_TH-SRCDFUPR-D4ImU4E4.js")).default;
    case "tr":
    case "tr-TR":
      return (await import("./tr_TR-YZS5CIK5-BaF9zn3R.js")).default;
    case "ua":
    case "uk-UA":
      return (await import("./uk_UA-Y3657REC-BU3GgRdW.js")).default;
    case "zh":
    case "zh-CN":
      return (await import("./zh_CN-UU5O3W4T-UuqmLTkR.js")).default;
    default:
      return (await import("./en_US-FEVFXARA-C6xYcZt7.js")).default;
  }
};
async function PE(e) {
  if (Xr.isLocaleCached(e)) {
    Xr.updateLocale(e);
    return;
  }
  const n = await YY(e);
  Xr.setTranslations(e, JSON.parse(n));
}
var QY = () => {
  var e;
  if (typeof window < "u" && typeof navigator < "u") {
    if ((e = navigator.languages) != null && e.length)
      return navigator.languages[0];
    if (navigator.language)
      return navigator.language;
  }
}, xn = Ge({ i18n: Xr }), JY = ({ children: e, locale: t }) => {
  const [n, r] = Oe(0), i = J(
    () => QY(),
    []
  );
  Te(() => Xr.onChange(() => {
    r((a) => a + 1);
  }), []), Te(() => {
    t && t !== Xr.locale ? PE(t) : !t && i && i !== Xr.locale && PE(i);
  }, [t, i]);
  const o = J(() => ({ t: (a, l) => Xr.t(a, l), i18n: Xr }), [n]);
  return /* @__PURE__ */ I.createElement(xn.Provider, { value: o }, e);
};
function A5(e) {
  return e != null;
}
var wg = {
  iconBackground: "#96bedc",
  iconUrl: async () => (await import("./arbitrum-IA4OWRTN-D6k03H61.js")).default
}, OE = {
  iconBackground: "#e84141",
  iconUrl: async () => (await import("./avalanche-MXEFEDSW-DSD2cRd4.js")).default
}, xg = {
  iconBackground: "#0052ff",
  iconUrl: async () => (await import("./base-Z4LFBE5D-C6ql6hur.js")).default
}, BE = {
  iconBackground: "#000000",
  iconUrl: async () => (await import("./blast-TN2WIMWF-DWKoNBoF.js")).default
}, NE = {
  iconBackground: "#ebac0e",
  iconUrl: async () => (await import("./bsc-RVE67I5L-DYHB_GPW.js")).default
}, DE = {
  iconBackground: "#002D74",
  iconUrl: async () => (await import("./cronos-ROYR77VZ-B7giDie4.js")).default
}, Xo = {
  iconBackground: "#484c50",
  iconUrl: async () => (await import("./ethereum-RFBAMUVK-DLaR1RlB.js")).default
}, XY = {
  iconBackground: "#f9f7ec",
  iconUrl: async () => (await import("./hardhat-NEEC6JX7-C2Xrwbgs.js")).default
}, jE = {
  iconBackground: "transparent",
  iconUrl: async () => (await import("./klaytn-OYHSPTO4-ChZSwUTY.js")).default
}, Vf = {
  iconBackground: "#ff5a57",
  iconUrl: async () => (await import("./optimism-VD7XDD2W-CcQZ21H4.js")).default
}, Cg = {
  iconBackground: "#ffffff",
  iconUrl: async () => (await import("./manta-5V6W5D7G-C8oxgIlB.js")).default
}, ME = {
  iconBackground: "#000000",
  iconUrl: async () => (await import("./mantle-KBL3OIYT-DuWwR7sX.js")).default
}, FE = {
  iconBackground: "#9f71ec",
  iconUrl: async () => (await import("./polygon-WWEUOMKW-DzNyQyyA.js")).default
}, LE = {
  iconBackground: "#f9f7ec",
  iconUrl: async () => (await import("./xdc-X7V4QFNF-CvhCDsG_.js")).default
}, UE = {
  iconBackground: "#000000",
  iconUrl: async () => (await import("./zetachain-BMJKVYBN-eLqEdfvx.js")).default
}, zE = {
  iconBackground: "#f9f7ec",
  iconUrl: async () => (await import("./zkSync-JL26RB7U-5r-kV3WG.js")).default
}, kg = {
  iconBackground: "#000000",
  iconUrl: async () => (await import("./zora-YZH32HP3-CfC4kCq7.js")).default
}, ZY = {
  iconBackground: "#1273EA",
  iconUrl: async () => (await import("./ronin-PNHX5V6H-BIFvgSfW.js")).default
}, eQ = {
  arbitrum: { chainId: 42161, name: "Arbitrum", ...wg },
  arbitrumGoerli: { chainId: 421613, ...wg },
  arbitrumSepolia: { chainId: 421614, ...wg },
  avalanche: { chainId: 43114, ...OE },
  avalancheFuji: { chainId: 43113, ...OE },
  base: { chainId: 8453, name: "Base", ...xg },
  baseGoerli: { chainId: 84531, ...xg },
  baseSepolia: { chainId: 84532, ...xg },
  blast: { chainId: 81457, name: "Blast", ...BE },
  blastSepolia: { chainId: 168587773, ...BE },
  bsc: { chainId: 56, name: "BSC", ...NE },
  bscTestnet: { chainId: 97, ...NE },
  cronos: { chainId: 25, ...DE },
  cronosTestnet: { chainId: 338, ...DE },
  goerli: { chainId: 5, ...Xo },
  hardhat: { chainId: 31337, ...XY },
  holesky: { chainId: 17e3, ...Xo },
  kovan: { chainId: 42, ...Xo },
  klaytn: { chainId: 8217, name: "Klaytn", ...jE },
  klaytnBaobab: { chainId: 1001, name: "Klaytn Baobab", ...jE },
  localhost: { chainId: 1337, ...Xo },
  mainnet: { chainId: 1, name: "Ethereum", ...Xo },
  manta: { chainId: 169, name: "Manta", ...Cg },
  mantaSepolia: { chainId: 3441006, ...Cg },
  mantaTestnet: { chainId: 3441005, ...Cg },
  mantle: { chainId: 5e3, ...ME },
  mantleTestnet: { chainId: 5001, ...ME },
  optimism: { chainId: 10, name: "Optimism", ...Vf },
  optimismGoerli: { chainId: 420, ...Vf },
  optimismKovan: { chainId: 69, ...Vf },
  optimismSepolia: { chainId: 11155420, ...Vf },
  polygon: { chainId: 137, name: "Polygon", ...FE },
  polygonMumbai: { chainId: 80001, ...FE },
  rinkeby: { chainId: 4, ...Xo },
  ropsten: { chainId: 3, ...Xo },
  ronin: { chainId: 2020, ...ZY },
  sepolia: { chainId: 11155111, ...Xo },
  xdc: { chainId: 50, name: "XinFin", ...LE },
  xdcTestnet: { chainId: 51, ...LE },
  zetachain: { chainId: 7e3, name: "ZetaChain", ...UE },
  zetachainAthensTestnet: {
    chainId: 7001,
    name: "Zeta Athens",
    ...UE
  },
  zkSync: { chainId: 324, name: "zkSync", ...zE },
  zkSyncTestnet: { chainId: 280, ...zE },
  zora: { chainId: 7777777, name: "Zora", ...kg },
  zoraSepolia: { chainId: 999999999, ...kg },
  zoraTestnet: { chainId: 999, ...kg }
}, tQ = Object.fromEntries(
  Object.values(eQ).filter(A5).map(({ chainId: e, ...t }) => [e, t])
), VE = (e) => e.map((t) => {
  const n = tQ[t.id] ?? {};
  return {
    ...t,
    name: n.name ?? t.name,
    // favor colloquial names
    iconUrl: t.iconUrl ?? n.iconUrl,
    iconBackground: t.iconBackground ?? n.iconBackground
  };
}), Kd = Ge({
  disabledChains: [],
  chains: []
});
function nQ({
  chainIdsToUse: e,
  disabledChains: t,
  onDisabledChainClick: n,
  children: r,
  initialChain: i
}) {
  const { chains: o } = Dn(), s = J(
    () => VE(
      e ? o.filter(
        (a) => e.has(a.id)
      ) : o
    ),
    [e, o]
  );
  return /* @__PURE__ */ I.createElement(
    Kd.Provider,
    {
      value: J(
        () => ({
          chains: s,
          disabledChains: VE(
            t ?? []
          ),
          onDisabledChainClick: n,
          initialChainId: typeof i == "number" ? i : i == null ? void 0 : i.id
        }),
        [
          o,
          i,
          t,
          n,
          s
        ]
      )
    },
    r
  );
}
var Va = () => we(Kd).chains, rQ = () => we(Kd).disabledChains, iQ = () => we(Kd).onDisabledChainClick, oQ = () => we(Kd).initialChainId, sQ = () => {
  const e = Va();
  return J(() => {
    const t = {};
    for (const n of e)
      t[n.id] = n;
    return t;
  }, [e]);
}, T5 = Ge({
  showBalance: void 0,
  setShowBalance: () => {
  }
});
function aQ({ children: e }) {
  const [t, n] = Oe();
  return /* @__PURE__ */ I.createElement(T5.Provider, { value: { showBalance: t, setShowBalance: n } }, e);
}
var lQ = () => we(T5);
function cQ() {
  const [e, t] = Oe(!1);
  return Te(() => (t(!0), () => {
    t(!1);
  }), []), Ie(() => e, [e]);
}
function _5() {
  const e = Va(), t = Fc.id;
  return e.some(
    (r) => r.id === t
  );
}
function uQ(e) {
  const t = _5(), n = (i) => {
    try {
      return EH(i);
    } catch {
    }
  }, { data: r } = MG({
    chainId: Fc.id,
    name: e ? n(e) : void 0,
    query: {
      enabled: t
    }
  });
  return r;
}
function dQ(e) {
  const t = _5(), { data: n } = FG({
    chainId: Fc.id,
    address: e,
    query: {
      enabled: t
    }
  });
  return n;
}
function I5({ address: e }) {
  const t = dQ(e), n = uQ(t);
  return { ensName: t, ensAvatar: n };
}
function n1() {
  const { chain: e } = ur();
  return (e == null ? void 0 : e.id) ?? null;
}
var R5 = "rk-transactions";
function fQ(e) {
  try {
    const t = e ? JSON.parse(e) : {};
    return typeof t == "object" ? t : {};
  } catch {
    return {};
  }
}
function qE() {
  return fQ(
    typeof localStorage < "u" ? localStorage.getItem(R5) : null
  );
}
var hQ = /^0x([A-Fa-f0-9]{64})$/;
function pQ(e) {
  const t = [];
  return hQ.test(e.hash) || t.push("Invalid transaction hash"), typeof e.description != "string" && t.push("Transaction must have a description"), typeof e.confirmations < "u" && (!Number.isInteger(e.confirmations) || e.confirmations < 1) && t.push("Transaction confirmations must be a positiver integer"), t;
}
function yQ({
  provider: e
}) {
  let t = qE(), n = e;
  const r = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Map();
  function s(w) {
    n = w;
  }
  function a(w, x) {
    var C;
    return ((C = t[w]) == null ? void 0 : C[x]) ?? [];
  }
  function l(w, x, C) {
    const S = pQ(C);
    if (S.length > 0)
      throw new Error(["Unable to add transaction", ...S].join(`
`));
    f(w, x, (k) => [
      { ...C, status: "pending" },
      ...k.filter(({ hash: A }) => A !== C.hash)
    ]);
  }
  function c(w, x) {
    f(w, x, () => []);
  }
  function u(w, x, C, S) {
    f(w, x, (k) => k.map(
      (A) => A.hash === C ? { ...A, status: S } : A
    ));
  }
  async function d(w, x) {
    await Promise.all(
      a(w, x).filter((C) => C.status === "pending").map(async (C) => {
        const { confirmations: S, hash: k } = C, A = o.get(k);
        if (A)
          return await A;
        const b = n.waitForTransactionReceipt({
          confirmations: S,
          hash: k,
          timeout: 3e5
          // 5 minutes
        }).then(({ status: T }) => {
          o.delete(k), T !== void 0 && (u(
            w,
            x,
            k,
            // @ts-ignore - types changed with viem@1.1.0
            T === 0 || T === "reverted" ? "failed" : "confirmed"
          ), m(T));
        }).catch(() => {
          u(w, x, k, "failed");
        });
        return o.set(k, b), await b;
      })
    );
  }
  function f(w, x, C) {
    t = qE(), t[w] = t[w] ?? {};
    let S = 0;
    const k = 10, A = C(t[w][x] ?? []).filter(({ status: b }) => b === "pending" ? !0 : S++ <= k);
    t[w][x] = A.length > 0 ? A : void 0, h(), p(), d(w, x);
  }
  function h() {
    localStorage.setItem(R5, JSON.stringify(t));
  }
  function p() {
    for (const w of r)
      w();
  }
  function m(w) {
    for (const x of i)
      x(w);
  }
  function g(w) {
    return r.add(w), () => {
      r.delete(w);
    };
  }
  function v(w) {
    return i.add(w), () => {
      i.delete(w);
    };
  }
  return {
    addTransaction: l,
    clearTransactions: c,
    getTransactions: a,
    onTransactionStatus: v,
    onChange: g,
    setProvider: s,
    waitForPendingTransactions: d
  };
}
var $E, P5 = Ge(null);
function mQ({
  children: e
}) {
  const t = LG(), { address: n } = ur(), r = n1(), [i] = Oe(
    () => $E ?? ($E = yQ({ provider: t }))
  );
  return Te(() => {
    i.setProvider(t);
  }, [i, t]), Te(() => {
    n && r && i.waitForPendingTransactions(n, r);
  }, [i, n, r]), /* @__PURE__ */ I.createElement(P5.Provider, { value: i }, e);
}
function O5() {
  const e = we(P5);
  if (!e)
    throw new Error("Transaction hooks must be used within RainbowKitProvider");
  return e;
}
function B5() {
  const e = O5(), { address: t } = ur(), n = n1(), [r, i] = Oe(
    () => e && t && n ? e.getTransactions(t, n) : []
  );
  return Te(() => {
    if (e && t && n)
      return i(e.getTransactions(t, n)), e.onChange(() => {
        i(e.getTransactions(t, n));
      });
  }, [e, t, n]), r;
}
var WE = (e) => typeof e == "function" ? e() : e;
function gQ(e, { extends: t } = {}) {
  const n = {
    // We use an object spread here to ensure it's a plain object since vanilla-extract's
    // var objects have a custom 'toString' method that returns a CSS string, but we don't
    // want to leak this to our consumers since they're unaware we're using vanilla-extract.
    // Instead, we want them to handle this explicitly via our 'cssStringFromTheme' function.
    ...kE(TE, WE(e))
  };
  if (!t)
    return n;
  const r = kE(
    TE,
    WE(t)
  );
  return Object.fromEntries(
    Object.entries(n).filter(
      ([o, s]) => s !== r[o]
    )
  );
}
function GE(e, t = {}) {
  return Object.entries(gQ(e, t)).map(([n, r]) => `${n}:${r.replace(/[:;{}</>]/g, "")};`).join("");
}
var N5 = {
  appName: void 0,
  disclaimer: void 0,
  learnMoreUrl: "https://learn.rainbow.me/understanding-web3?utm_source=rainbowkit&utm_campaign=learnmore"
}, Yd = Ge(N5), D5 = Ge(!1);
function vQ(e, t) {
  let n;
  return () => {
    n && clearTimeout(n), n = setTimeout(() => {
      n = null, e();
    }, t);
  };
}
var j5 = () => {
  const [e, t] = Oe({
    height: void 0,
    width: void 0
  });
  return Te(() => {
    let n = !1;
    const r = vQ(() => {
      n || t({
        height: window.innerHeight,
        width: window.innerWidth
      });
    }, 500);
    return window.addEventListener("resize", r), r(), () => {
      n = !0, window.removeEventListener("resize", r);
    };
  }, []), e;
}, Qd = Ge({
  connector: null,
  setConnector: () => {
  }
});
function bQ({ children: e }) {
  const [t, n] = Oe(null);
  return /* @__PURE__ */ I.createElement(
    Qd.Provider,
    {
      value: J(
        () => ({
          connector: t,
          setConnector: n
        }),
        [t]
      )
    },
    e
  );
}
var Jd = {
  COMPACT: "compact",
  WIDE: "wide"
}, my = Ge(
  Jd.WIDE
);
function wQ({
  children: e,
  modalSize: t
}) {
  const { width: n } = j5(), r = n && n < IY, { connector: i } = we(Qd);
  return /* @__PURE__ */ I.createElement(
    my.Provider,
    {
      value: r || i ? Jd.COMPACT : t
    },
    e
  );
}
var r1 = Ge(!1), xQ = "rk-version";
function CQ({ version: e }) {
  localStorage.setItem(xQ, e);
}
function kQ() {
  const e = Ie(() => {
    CQ({ version: "2.1.7" });
  }, []);
  Te(() => {
    e();
  }, [e]);
}
function EQ(e, t) {
  const n = {};
  for (const r of e) {
    const i = t(r);
    i && (n[i] = r);
  }
  return n;
}
function i1() {
  return typeof navigator < "u" && typeof navigator.userAgent < "u" && /Version\/([0-9._]+).*Safari/.test(navigator.userAgent);
}
function SQ() {
  return typeof document < "u" && getComputedStyle(document.body).getPropertyValue("--arc-palette-focus") !== "";
}
function o1() {
  var t, n;
  if (typeof navigator > "u")
    return "Browser";
  const e = (t = navigator.userAgent) == null ? void 0 : t.toLowerCase();
  return (n = navigator.brave) != null && n.isBrave ? "Brave" : (e == null ? void 0 : e.indexOf("edg/")) > -1 ? "Edge" : (e == null ? void 0 : e.indexOf("op")) > -1 ? "Opera" : SQ() ? "Arc" : (e == null ? void 0 : e.indexOf("chrome")) > -1 ? "Chrome" : (e == null ? void 0 : e.indexOf("firefox")) > -1 ? "Firefox" : i1() ? "Safari" : "Browser";
}
var AQ = MK.UAParser(), { os: s1 } = AQ;
function TQ() {
  return s1.name === "Windows";
}
function _Q() {
  return s1.name === "Mac OS";
}
function IQ() {
  return ["Ubuntu", "Mint", "Fedora", "Debian", "Arch", "Linux"].includes(
    s1.name
  );
}
function a1() {
  return TQ() ? "Windows" : _Q() ? "macOS" : IQ() ? "Linux" : "Desktop";
}
var RQ = (e) => {
  var n, r, i, o, s, a, l, c, u, d, f;
  const t = o1();
  return {
    Arc: (n = e == null ? void 0 : e.downloadUrls) == null ? void 0 : n.chrome,
    Brave: (r = e == null ? void 0 : e.downloadUrls) == null ? void 0 : r.chrome,
    Chrome: (i = e == null ? void 0 : e.downloadUrls) == null ? void 0 : i.chrome,
    Edge: ((o = e == null ? void 0 : e.downloadUrls) == null ? void 0 : o.edge) || ((s = e == null ? void 0 : e.downloadUrls) == null ? void 0 : s.chrome),
    Firefox: (a = e == null ? void 0 : e.downloadUrls) == null ? void 0 : a.firefox,
    Opera: ((l = e == null ? void 0 : e.downloadUrls) == null ? void 0 : l.opera) || ((c = e == null ? void 0 : e.downloadUrls) == null ? void 0 : c.chrome),
    Safari: (u = e == null ? void 0 : e.downloadUrls) == null ? void 0 : u.safari,
    Browser: (d = e == null ? void 0 : e.downloadUrls) == null ? void 0 : d.browserExtension
  }[t] ?? ((f = e == null ? void 0 : e.downloadUrls) == null ? void 0 : f.browserExtension);
}, PQ = (e) => {
  var n, r, i;
  return (yy() ? (n = e == null ? void 0 : e.downloadUrls) == null ? void 0 : n.ios : (r = e == null ? void 0 : e.downloadUrls) == null ? void 0 : r.android) ?? ((i = e == null ? void 0 : e.downloadUrls) == null ? void 0 : i.mobile);
}, OQ = (e) => {
  var n, r, i, o, s;
  const t = a1();
  return {
    Windows: (n = e == null ? void 0 : e.downloadUrls) == null ? void 0 : n.windows,
    macOS: (r = e == null ? void 0 : e.downloadUrls) == null ? void 0 : r.macos,
    Linux: (i = e == null ? void 0 : e.downloadUrls) == null ? void 0 : i.linux,
    Desktop: (o = e == null ? void 0 : e.downloadUrls) == null ? void 0 : o.desktop
  }[t] ?? ((s = e == null ? void 0 : e.downloadUrls) == null ? void 0 : s.desktop);
}, M5 = (e, t) => e.some((n) => n.id === t), BQ = (e) => !!e.isRainbowKitConnector, HE = (e) => {
  var t;
  return !!(!e.isRainbowKitConnector && ((t = e.icon) != null && t.startsWith("data:image")) && e.uid && e.name);
}, NQ = (e, t) => e.id === "walletConnect" && t ? { ...e, walletConnectModalConnector: t } : e, DQ = ({
  wallets: e,
  recentWallets: t
}) => [
  ...t,
  ...e.filter((n) => !M5(t, n.id))
], F5 = "rk-recent";
function jQ(e) {
  try {
    const t = e ? JSON.parse(e) : [];
    return Array.isArray(t) ? t : [];
  } catch {
    return [];
  }
}
function L5() {
  return typeof localStorage < "u" ? jQ(localStorage.getItem(F5)) : [];
}
function MQ(e) {
  return [...new Set(e)];
}
function FQ(e) {
  const t = MQ([e, ...L5()]);
  localStorage.setItem(F5, JSON.stringify(t));
}
function gy(e = !1) {
  var C, S, k;
  const t = Va(), n = oQ(), { connectAsync: r, connectors: i } = SI(), o = i, { setIsWalletConnectModalOpen: s } = dR(), a = o.map((A) => ({
    ...A,
    // rkDetails is optional it does not exist in eip6963 connectors.
    // We only inject `rkDetails` in `connectorsForWallets` when we
    // want to have additional information in the connector.
    ...A.rkDetails || {}
  }));
  async function l(A) {
    var R, B;
    const b = await A.getChainId(), T = await r({
      chainId: (
        // The goal here is to ensure users are always on a supported chain when connecting.
        // If an `initialChain` prop was provided to RainbowKitProvider, use that.
        n ?? // Otherwise, if the wallet is already on a supported chain, use that to avoid a chain switch prompt.
        ((R = t.find(({ id: O }) => O === b)) == null ? void 0 : R.id) ?? // Finally, fall back to the first chain provided to RainbowKitProvider.
        ((B = t[0]) == null ? void 0 : B.id)
      ),
      connector: A
    });
    return T && FQ(A.id), T;
  }
  async function c(A) {
    try {
      s(!0), await l(A), s(!1);
    } catch (b) {
      const T = (
        // @ts-expect-error - Web3Modal v1 error name
        b.name === "UserRejectedRequestError" || // @ts-expect-error - Web3Modal v2 error message on desktop
        b.message === "Connection request reset. Please try again."
      );
      if (s(!1), !T)
        throw b;
    }
  }
  const u = async (A, b) => {
    const T = await A.getProvider();
    return A.id === "coinbase" ? T.qrUrl : new Promise(
      (R) => (
        // Wagmi v2 doesn't have a return type for provider yet
        // @ts-expect-error
        T.once("display_uri", (B) => {
          R(b(B));
        })
      )
    );
  }, d = a.find(
    (A) => A.id === "walletConnect" && A.isWalletConnectModalConnector
  ), f = a.filter(HE).map((A) => ({
    ...A,
    groupIndex: 0
  })), h = a.filter(BQ).filter((A) => !A.isWalletConnectModalConnector).filter((A) => e ? !f.some(
    (T) => T.id === A.rdns
  ) : !0).map(
    (A) => NQ(
      A,
      d
    )
  ), p = [...f, ...h], m = EQ(
    p,
    (A) => A.id
  ), v = L5().map((A) => m[A]).filter(Boolean).slice(0, 3), w = [], x = DQ({
    wallets: p,
    recentWallets: v
  });
  for (const A of x) {
    if (!A)
      continue;
    const b = HE(A), T = M5(v, A.id);
    if (b) {
      w.push({
        ...A,
        iconUrl: A.icon,
        ready: !0,
        connect: () => l(A),
        groupName: "Installed",
        recent: T
      });
      continue;
    }
    w.push({
      ...A,
      ready: A.installed ?? !0,
      connect: () => l(A),
      desktopDownloadUrl: OQ(A),
      extensionDownloadUrl: RQ(A),
      groupName: A.groupName,
      mobileDownloadUrl: PQ(A),
      getQrCodeUri: (C = A.qrCode) != null && C.getUri ? () => u(A, A.qrCode.getUri) : void 0,
      getDesktopUri: (S = A.desktop) != null && S.getUri ? () => u(A, A.desktop.getUri) : void 0,
      getMobileUri: (k = A.mobile) != null && k.getUri ? () => {
        var R;
        return u(A, (R = A.mobile) == null ? void 0 : R.getUri);
      } : void 0,
      recent: T,
      showWalletConnectModal: A.walletConnectModalConnector ? () => c(A.walletConnectModalConnector) : void 0
    });
  }
  return w;
}
var U5 = async () => (await import("./assets-NU2OP443-C4m6cbxQ.js")).default, LQ = () => Zi(U5), UQ = () => /* @__PURE__ */ I.createElement(
  An,
  {
    background: "#d0d5de",
    borderRadius: "10",
    height: "48",
    src: U5,
    width: "48"
  }
), z5 = async () => (await import("./login-CWDTIDNK-DDKE2czq.js")).default, zQ = () => Zi(z5), VQ = () => /* @__PURE__ */ I.createElement(
  An,
  {
    background: "#d0d5de",
    borderRadius: "10",
    height: "48",
    src: z5,
    width: "48"
  }
), De = I.forwardRef(
  ({
    as: e = "div",
    children: t,
    className: n,
    color: r,
    display: i,
    font: o = "body",
    id: s,
    size: a = "16",
    style: l,
    tabIndex: c,
    textAlign: u = "inherit",
    weight: d = "regular",
    testId: f
  }, h) => /* @__PURE__ */ I.createElement(
    K,
    {
      as: e,
      className: n,
      color: r,
      display: i,
      fontFamily: o,
      fontSize: a,
      fontWeight: d,
      id: s,
      ref: h,
      style: l,
      tabIndex: c,
      textAlign: u,
      testId: f
    },
    t
  )
);
De.displayName = "Text";
var qQ = {
  large: {
    fontSize: "16",
    paddingX: "24",
    paddingY: "10"
  },
  medium: {
    fontSize: "14",
    height: "28",
    paddingX: "12",
    paddingY: "4"
  },
  small: {
    fontSize: "14",
    paddingX: "10",
    paddingY: "5"
  }
};
function cr({
  disabled: e = !1,
  href: t,
  label: n,
  onClick: r,
  rel: i = "noreferrer noopener",
  size: o = "medium",
  target: s = "_blank",
  testId: a,
  type: l = "primary"
}) {
  const c = l === "primary", u = o !== "large", d = zn(), f = e ? "actionButtonSecondaryBackground" : c ? "accentColor" : u ? "actionButtonSecondaryBackground" : null, { fontSize: h, height: p, paddingX: m, paddingY: g } = qQ[o], v = !d || !u;
  return /* @__PURE__ */ I.createElement(
    K,
    {
      ...t ? e ? {} : { as: "a", href: t, rel: i, target: s } : { as: "button", type: "button" },
      onClick: e ? void 0 : r,
      ...v ? {
        borderColor: d && !u && !c ? "actionButtonBorderMobile" : "actionButtonBorder",
        borderStyle: "solid",
        borderWidth: "1"
      } : {},
      borderRadius: "actionButton",
      className: !e && mn({ active: "shrinkSm", hover: "grow" }),
      display: "block",
      paddingX: m,
      paddingY: g,
      style: { willChange: "transform" },
      testId: a,
      textAlign: "center",
      transition: "transform",
      ...f ? { background: f } : {},
      ...p ? { height: p } : {}
    },
    /* @__PURE__ */ I.createElement(
      De,
      {
        color: e ? "modalTextSecondary" : c ? "accentColorForeground" : "accentColor",
        size: h,
        weight: "bold"
      },
      n
    )
  );
}
var $Q = () => zn() ? /* @__PURE__ */ I.createElement(
  "svg",
  {
    "aria-hidden": !0,
    fill: "none",
    height: "11.5",
    viewBox: "0 0 11.5 11.5",
    width: "11.5",
    xmlns: "http://www.w3.org/2000/svg"
  },
  /* @__PURE__ */ I.createElement("title", null, "Close"),
  /* @__PURE__ */ I.createElement(
    "path",
    {
      d: "M2.13388 0.366117C1.64573 -0.122039 0.854272 -0.122039 0.366117 0.366117C-0.122039 0.854272 -0.122039 1.64573 0.366117 2.13388L3.98223 5.75L0.366117 9.36612C-0.122039 9.85427 -0.122039 10.6457 0.366117 11.1339C0.854272 11.622 1.64573 11.622 2.13388 11.1339L5.75 7.51777L9.36612 11.1339C9.85427 11.622 10.6457 11.622 11.1339 11.1339C11.622 10.6457 11.622 9.85427 11.1339 9.36612L7.51777 5.75L11.1339 2.13388C11.622 1.64573 11.622 0.854272 11.1339 0.366117C10.6457 -0.122039 9.85427 -0.122039 9.36612 0.366117L5.75 3.98223L2.13388 0.366117Z",
      fill: "currentColor"
    }
  )
) : /* @__PURE__ */ I.createElement(
  "svg",
  {
    "aria-hidden": !0,
    fill: "none",
    height: "10",
    viewBox: "0 0 10 10",
    width: "10",
    xmlns: "http://www.w3.org/2000/svg"
  },
  /* @__PURE__ */ I.createElement("title", null, "Close"),
  /* @__PURE__ */ I.createElement(
    "path",
    {
      d: "M1.70711 0.292893C1.31658 -0.0976311 0.683417 -0.0976311 0.292893 0.292893C-0.0976311 0.683417 -0.0976311 1.31658 0.292893 1.70711L3.58579 5L0.292893 8.29289C-0.0976311 8.68342 -0.0976311 9.31658 0.292893 9.70711C0.683417 10.0976 1.31658 10.0976 1.70711 9.70711L5 6.41421L8.29289 9.70711C8.68342 10.0976 9.31658 10.0976 9.70711 9.70711C10.0976 9.31658 10.0976 8.68342 9.70711 8.29289L6.41421 5L9.70711 1.70711C10.0976 1.31658 10.0976 0.683417 9.70711 0.292893C9.31658 -0.0976311 8.68342 -0.0976311 8.29289 0.292893L5 3.58579L1.70711 0.292893Z",
      fill: "currentColor"
    }
  )
), Oa = ({
  "aria-label": e = "Close",
  onClose: t
}) => {
  const n = zn();
  return /* @__PURE__ */ I.createElement(
    K,
    {
      alignItems: "center",
      "aria-label": e,
      as: "button",
      background: "closeButtonBackground",
      borderColor: "actionButtonBorder",
      borderRadius: "full",
      borderStyle: "solid",
      borderWidth: n ? "0" : "1",
      className: mn({ active: "shrinkSm", hover: "growLg" }),
      color: "closeButton",
      display: "flex",
      height: n ? "30" : "28",
      justifyContent: "center",
      onClick: t,
      style: { willChange: "transform" },
      transition: "default",
      type: "button",
      width: n ? "30" : "28"
    },
    /* @__PURE__ */ I.createElement($Q, null)
  );
}, V5 = async () => (await import("./sign-A7IJEUT5-C2I7GEuo.js")).default;
function WQ({
  onClose: e,
  onCloseModal: t
}) {
  const { i18n: n } = we(xn), [{ status: r, ...i }, o] = I.useState({ status: "idle" }), s = NY(), a = Ie(async () => {
    try {
      const p = await s.getNonce();
      o((m) => ({ ...m, nonce: p }));
    } catch {
      o((p) => ({
        ...p,
        errorMessage: n.t("sign_in.message.preparing_error"),
        status: "idle"
      }));
    }
  }, [s, n.t]), l = It(!1);
  I.useEffect(() => {
    l.current || (l.current = !0, a());
  }, [a]);
  const c = zn(), { address: u, chain: d } = ur(), { signMessageAsync: f } = AI(), h = async () => {
    try {
      const p = d == null ? void 0 : d.id, { nonce: m } = i;
      if (!u || !p || !m)
        return;
      o((w) => ({
        ...w,
        errorMessage: void 0,
        status: "signing"
      }));
      const g = s.createMessage({ address: u, chainId: p, nonce: m });
      let v;
      try {
        v = await f({
          message: s.getMessageBody({ message: g })
        });
      } catch (w) {
        return w instanceof $t ? o((x) => ({
          ...x,
          status: "idle"
        })) : o((x) => ({
          ...x,
          errorMessage: n.t("sign_in.signature.signing_error"),
          status: "idle"
        }));
      }
      o((w) => ({ ...w, status: "verifying" }));
      try {
        if (await s.verify({ message: g, signature: v })) {
          t();
          return;
        }
        throw new Error();
      } catch {
        return o((w) => ({
          ...w,
          errorMessage: n.t("sign_in.signature.verifying_error"),
          status: "idle"
        }));
      }
    } catch {
      o({
        errorMessage: n.t("sign_in.signature.oops_error"),
        status: "idle"
      });
    }
  };
  return /* @__PURE__ */ I.createElement(K, { position: "relative" }, /* @__PURE__ */ I.createElement(
    K,
    {
      display: "flex",
      paddingRight: "16",
      paddingTop: "16",
      position: "absolute",
      right: "0"
    },
    /* @__PURE__ */ I.createElement(Oa, { onClose: e })
  ), /* @__PURE__ */ I.createElement(
    K,
    {
      alignItems: "center",
      display: "flex",
      flexDirection: "column",
      gap: c ? "32" : "24",
      padding: "24",
      paddingX: "18",
      style: { paddingTop: c ? "60px" : "36px" }
    },
    /* @__PURE__ */ I.createElement(
      K,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        gap: c ? "6" : "4",
        style: { maxWidth: c ? 320 : 280 }
      },
      /* @__PURE__ */ I.createElement(
        K,
        {
          alignItems: "center",
          display: "flex",
          flexDirection: "column",
          gap: c ? "32" : "16"
        },
        /* @__PURE__ */ I.createElement(An, { height: 40, src: V5, width: 40 }),
        /* @__PURE__ */ I.createElement(
          De,
          {
            color: "modalText",
            size: c ? "20" : "18",
            textAlign: "center",
            weight: "heavy"
          },
          n.t("sign_in.label")
        )
      ),
      /* @__PURE__ */ I.createElement(
        K,
        {
          alignItems: "center",
          display: "flex",
          flexDirection: "column",
          gap: c ? "16" : "12"
        },
        /* @__PURE__ */ I.createElement(
          De,
          {
            color: "modalTextSecondary",
            size: c ? "16" : "14",
            textAlign: "center"
          },
          n.t("sign_in.description")
        ),
        r === "idle" && i.errorMessage ? /* @__PURE__ */ I.createElement(
          De,
          {
            color: "error",
            size: c ? "16" : "14",
            textAlign: "center",
            weight: "bold"
          },
          i.errorMessage
        ) : null
      )
    ),
    /* @__PURE__ */ I.createElement(
      K,
      {
        alignItems: c ? void 0 : "center",
        display: "flex",
        flexDirection: "column",
        gap: "8",
        width: "full"
      },
      /* @__PURE__ */ I.createElement(
        cr,
        {
          disabled: !i.nonce || r === "signing" || r === "verifying",
          label: i.nonce ? r === "signing" ? n.t("sign_in.signature.waiting") : r === "verifying" ? n.t("sign_in.signature.verifying") : n.t("sign_in.message.send") : n.t("sign_in.message.preparing"),
          onClick: h,
          size: c ? "large" : "medium",
          testId: "auth-message-button"
        }
      ),
      c ? /* @__PURE__ */ I.createElement(
        cr,
        {
          label: "Cancel",
          onClick: e,
          size: "large",
          type: "secondary"
        }
      ) : /* @__PURE__ */ I.createElement(
        K,
        {
          as: "button",
          borderRadius: "full",
          className: mn({ active: "shrink", hover: "grow" }),
          display: "block",
          onClick: e,
          paddingX: "10",
          paddingY: "5",
          rel: "noreferrer",
          style: { willChange: "transform" },
          target: "_blank",
          transition: "default"
        },
        /* @__PURE__ */ I.createElement(
          De,
          {
            color: "closeButton",
            size: c ? "16" : "14",
            weight: "bold"
          },
          n.t("sign_in.message.cancel")
        )
      )
    )
  ));
}
function GQ() {
  const e = Va(), t = gy(), n = py() === "unauthenticated", r = Ie(() => {
    Zi(
      ...t.map((i) => i.iconUrl),
      ...e.map((i) => i.iconUrl).filter(A5)
    ), zn() || (LQ(), zQ()), n && Zi(V5);
  }, [t, e, n]);
  Te(() => {
    r();
  }, [r]);
}
var q5 = "WALLETCONNECT_DEEPLINK_CHOICE";
function HQ({
  mobileUri: e,
  name: t
}) {
  localStorage.setItem(
    q5,
    JSON.stringify({
      href: e.split("?")[0],
      name: t
    })
  );
}
function KQ() {
  localStorage.removeItem(q5);
}
var $5 = Ge(void 0), $b = "data-rk", W5 = (e) => ({ [$b]: e || "" }), YQ = (e) => {
  if (e && !/^[a-zA-Z0-9_]+$/.test(e))
    throw new Error(`Invalid ID: ${e}`);
  return e ? `[${$b}="${e}"]` : `[${$b}]`;
}, QQ = () => {
  const e = we($5);
  return W5(e);
}, JQ = sw();
function XQ({
  appInfo: e,
  avatar: t,
  disabledChains: n,
  onDisabledChainClick: r,
  children: i,
  coolMode: o = !1,
  id: s,
  initialChain: a,
  locale: l,
  modalSize: c = Jd.WIDE,
  showRecentTransactions: u = !1,
  theme: d = JQ,
  dialogRoot: f,
  hideDisconnect: h,
  chainIdsToUse: p
}) {
  if (GQ(), kQ(), wI({ onDisconnect: KQ }), typeof d == "function")
    throw new Error(
      'A theme function was provided to the "theme" prop instead of a theme object. You must execute this function to get the resulting theme object.'
    );
  const m = YQ(s), g = {
    ...N5,
    ...e
  }, v = t ?? E5;
  return /* @__PURE__ */ I.createElement(
    nQ,
    {
      chainIdsToUse: p,
      disabledChains: n,
      initialChain: a,
      onDisabledChainClick: r
    },
    /* @__PURE__ */ I.createElement(bQ, null, /* @__PURE__ */ I.createElement(JY, { locale: l }, /* @__PURE__ */ I.createElement(D5.Provider, { value: o }, /* @__PURE__ */ I.createElement(wQ, { modalSize: c }, /* @__PURE__ */ I.createElement(
      r1.Provider,
      {
        value: u
      },
      /* @__PURE__ */ I.createElement(mQ, null, /* @__PURE__ */ I.createElement(t1.Provider, { value: v }, /* @__PURE__ */ I.createElement(Yd.Provider, { value: g }, /* @__PURE__ */ I.createElement($5.Provider, { value: s }, /* @__PURE__ */ I.createElement(aQ, null, /* @__PURE__ */ I.createElement(
        yX,
        {
          dialogRoot: f,
          hideDisconnect: h
        },
        d ? /* @__PURE__ */ I.createElement("div", { ...W5(s) }, /* @__PURE__ */ I.createElement(
          "style",
          {
            dangerouslySetInnerHTML: {
              // Selectors are sanitized to only contain alphanumeric
              // and underscore characters. Theme values generated by
              // cssStringFromTheme are sanitized, removing
              // characters that terminate values / HTML tags.
              __html: [
                `${m}{${GE(
                  "lightMode" in d ? d.lightMode : d
                )}}`,
                "darkMode" in d ? `@media(prefers-color-scheme:dark){${m}{${GE(
                  d.darkMode,
                  { extends: d.lightMode }
                )}}}` : null
              ].join("")
            }
          }
        ), i) : i
      ))))))
    )))))
  );
}
var ZQ = "kzuco17 in5bvia in5bvi15 in5bvi8r", eJ = "kzuco15 in5bvi9h in5bvib3", tJ = "kzuco13 in5bvia in5bvi2q in5bvi8q", KE = (e, t) => {
  const n = e.querySelectorAll(
    "button:not(:disabled), a[href]"
  );
  n.length !== 0 && n[t === "end" ? n.length - 1 : 0].focus();
};
function nJ(e) {
  const t = It(null);
  return Te(() => {
    const n = document.activeElement;
    return () => {
      var r;
      (r = n.focus) == null || r.call(n);
    };
  }, []), Te(() => {
    if (t.current) {
      const n = t.current.querySelector("[data-auto-focus]");
      n ? n.focus() : t.current.focus();
    }
  }, []), /* @__PURE__ */ I.createElement(I.Fragment, null, /* @__PURE__ */ I.createElement(
    "div",
    {
      onFocus: Ie(
        () => t.current && KE(t.current, "end"),
        []
      ),
      tabIndex: 0
    }
  ), /* @__PURE__ */ I.createElement(
    "div",
    {
      ref: t,
      style: { outline: "none" },
      tabIndex: -1,
      ...e
    }
  ), /* @__PURE__ */ I.createElement(
    "div",
    {
      onFocus: Ie(
        () => t.current && KE(t.current, "start"),
        []
      ),
      tabIndex: 0
    }
  ));
}
var rJ = (e) => e.stopPropagation();
function ep({
  children: e,
  onClose: t,
  open: n,
  titleId: r,
  dialogRoot: i
}) {
  Te(() => {
    const u = (d) => n && d.key === "Escape" && t();
    return document.addEventListener("keydown", u), () => document.removeEventListener("keydown", u);
  }, [n, t]);
  const [o, s] = Oe(!0);
  Te(() => {
    s(
      getComputedStyle(window.document.body).overflow !== "hidden"
    );
  }, []);
  const a = Ie(() => t(), [t]), l = QQ(), c = zn();
  return /* @__PURE__ */ I.createElement(I.Fragment, null, n ? uA(
    /* @__PURE__ */ I.createElement(ly, { enabled: o }, /* @__PURE__ */ I.createElement(K, { ...l }, /* @__PURE__ */ I.createElement(
      K,
      {
        ...l,
        alignItems: c ? "flex-end" : "center",
        "aria-labelledby": r,
        "aria-modal": !0,
        className: tJ,
        onClick: a,
        position: "fixed",
        role: "dialog"
      },
      /* @__PURE__ */ I.createElement(K, { className: eJ }),
      /* @__PURE__ */ I.createElement(
        nJ,
        {
          className: ZQ,
          onClick: rJ,
          role: "document"
        },
        e
      )
    ))),
    i ?? document.body
  ) : null);
}
var iJ = "_1t0jwgf7", oJ = "_1t0jwgf1 in5bvib6 in5bvidr in5bvip in5bvit in5bviv in5bviel in5bvia in5bvi15 in5bvi6c in5bvi8r", sJ = "_1t0jwgf4 _1t0jwgf1 in5bvib6 in5bvidr in5bvip in5bvit in5bviv in5bviel in5bvia in5bvi15 in5bvi6c in5bvi8r", aJ = "_1t0jwgf6 in5bviq", lJ = "_1t0jwgf3 _1t0jwgf1 in5bvib6 in5bvidr in5bvip in5bvit in5bviv in5bviel in5bvia in5bvi15 in5bvi6c in5bvi8r", cJ = "_1t0jwgf2 _1t0jwgf1 in5bvib6 in5bvidr in5bvip in5bvit in5bviv in5bviel in5bvia in5bvi15 in5bvi6c in5bvi8r";
function tp({
  bottomSheetOnMobile: e = !1,
  children: t,
  marginTop: n,
  padding: r = "16",
  paddingBottom: i,
  wide: o = !1
}) {
  const s = zn(), l = we(my) === Jd.COMPACT;
  return /* @__PURE__ */ I.createElement(K, { marginTop: n }, /* @__PURE__ */ I.createElement(
    K,
    {
      className: [
        o ? s ? cJ : l ? sJ : lJ : oJ,
        s ? aJ : null,
        s && e ? iJ : null
      ].join(" ")
    },
    /* @__PURE__ */ I.createElement(K, { padding: r, paddingBottom: i ?? r }, t)
  ));
}
function G5(e) {
  return e.length < 8 ? e : `${e.substring(0, 4)}…${e.substring(
    e.length - 4
  )}`;
}
function H5(e) {
  if (!e)
    return "";
  const t = e.split("."), n = t.pop();
  return t.join(".").length > 24 ? `${t.join(".").substring(0, 24)}...` : `${t.join(".")}.${n}`;
}
var uJ = () => /* @__PURE__ */ I.createElement(
  "svg",
  {
    fill: "none",
    height: "13",
    viewBox: "0 0 13 13",
    width: "13",
    xmlns: "http://www.w3.org/2000/svg"
  },
  /* @__PURE__ */ I.createElement("title", null, "Copied"),
  /* @__PURE__ */ I.createElement(
    "path",
    {
      d: "M4.94568 12.2646C5.41052 12.2646 5.77283 12.0869 6.01892 11.7109L12.39 1.96973C12.5677 1.69629 12.6429 1.44336 12.6429 1.2041C12.6429 0.561523 12.1644 0.0966797 11.5082 0.0966797C11.057 0.0966797 10.7767 0.260742 10.5033 0.691406L4.9115 9.50977L2.07458 5.98926C1.82166 5.68848 1.54822 5.55176 1.16541 5.55176C0.502319 5.55176 0.0238037 6.02344 0.0238037 6.66602C0.0238037 6.95312 0.112671 7.20605 0.358765 7.48633L3.88611 11.7588C4.18005 12.1074 4.50818 12.2646 4.94568 12.2646Z",
      fill: "currentColor"
    }
  )
), dJ = () => /* @__PURE__ */ I.createElement(
  "svg",
  {
    fill: "none",
    height: "16",
    viewBox: "0 0 17 16",
    width: "17",
    xmlns: "http://www.w3.org/2000/svg"
  },
  /* @__PURE__ */ I.createElement("title", null, "Copy"),
  /* @__PURE__ */ I.createElement(
    "path",
    {
      d: "M3.04236 12.3027H4.18396V13.3008C4.18396 14.8525 5.03845 15.7002 6.59705 15.7002H13.6244C15.183 15.7002 16.0375 14.8525 16.0375 13.3008V6.24609C16.0375 4.69434 15.183 3.84668 13.6244 3.84668H12.4828V2.8418C12.4828 1.29688 11.6283 0.442383 10.0697 0.442383H3.04236C1.48376 0.442383 0.629272 1.29004 0.629272 2.8418V9.90332C0.629272 11.4551 1.48376 12.3027 3.04236 12.3027ZM3.23376 10.5391C2.68689 10.5391 2.39294 10.2656 2.39294 9.68457V3.06055C2.39294 2.47949 2.68689 2.21289 3.23376 2.21289H9.8783C10.4252 2.21289 10.7191 2.47949 10.7191 3.06055V3.84668H6.59705C5.03845 3.84668 4.18396 4.69434 4.18396 6.24609V10.5391H3.23376ZM6.78845 13.9365C6.24158 13.9365 5.94763 13.6699 5.94763 13.0889V6.45801C5.94763 5.87695 6.24158 5.61035 6.78845 5.61035H13.433C13.9799 5.61035 14.2738 5.87695 14.2738 6.45801V13.0889C14.2738 13.6699 13.9799 13.9365 13.433 13.9365H6.78845Z",
      fill: "currentColor"
    }
  )
), fJ = () => /* @__PURE__ */ I.createElement(
  "svg",
  {
    fill: "none",
    height: "16",
    viewBox: "0 0 18 16",
    width: "18",
    xmlns: "http://www.w3.org/2000/svg"
  },
  /* @__PURE__ */ I.createElement("title", null, "Disconnect"),
  /* @__PURE__ */ I.createElement(
    "path",
    {
      d: "M2.67834 15.5908H9.99963C11.5514 15.5908 12.399 14.7432 12.399 13.1777V10.2656H10.6354V12.9863C10.6354 13.5332 10.3688 13.8271 9.78772 13.8271H2.89026C2.3092 13.8271 2.0426 13.5332 2.0426 12.9863V3.15625C2.0426 2.60254 2.3092 2.30859 2.89026 2.30859H9.78772C10.3688 2.30859 10.6354 2.60254 10.6354 3.15625V5.89746H12.399V2.95801C12.399 1.39941 11.5514 0.544922 9.99963 0.544922H2.67834C1.12659 0.544922 0.278931 1.39941 0.278931 2.95801V13.1777C0.278931 14.7432 1.12659 15.5908 2.67834 15.5908ZM7.43616 8.85059H14.0875L15.0924 8.78906L14.566 9.14453L13.6842 9.96484C13.5406 10.1016 13.4586 10.2861 13.4586 10.4844C13.4586 10.8398 13.7321 11.168 14.1217 11.168C14.3199 11.168 14.4635 11.0928 14.6002 10.9561L16.7809 8.68652C16.986 8.48145 17.0543 8.27637 17.0543 8.06445C17.0543 7.85254 16.986 7.64746 16.7809 7.43555L14.6002 5.17285C14.4635 5.03613 14.3199 4.9541 14.1217 4.9541C13.7321 4.9541 13.4586 5.27539 13.4586 5.6377C13.4586 5.83594 13.5406 6.02734 13.6842 6.15723L14.566 6.98438L15.0924 7.33984L14.0875 7.27148H7.43616C7.01917 7.27148 6.65686 7.62012 6.65686 8.06445C6.65686 8.50195 7.01917 8.85059 7.43616 8.85059Z",
      fill: "currentColor"
    }
  )
), hJ = "_1mfzuhu0", vy = I.forwardRef(
  ({
    children: e,
    currentlySelected: t = !1,
    onClick: n,
    testId: r,
    ...i
  }, o) => {
    const s = zn();
    return /* @__PURE__ */ I.createElement(
      K,
      {
        as: "button",
        borderRadius: "menuButton",
        disabled: t,
        display: "flex",
        onClick: n,
        ref: o,
        testId: r,
        type: "button"
      },
      /* @__PURE__ */ I.createElement(
        K,
        {
          borderRadius: "menuButton",
          className: [
            s ? hJ : void 0,
            !t && mn({ active: "shrink" })
          ],
          padding: s ? "8" : "6",
          transition: "default",
          width: "full",
          ...t ? {
            background: "accentColor",
            borderColor: "selectedOptionBorder",
            borderStyle: "solid",
            borderWidth: "1",
            boxShadow: "selectedOption",
            color: "accentColorForeground"
          } : {
            background: { hover: "menuItemBackground" },
            color: "modalText",
            transition: "default"
          },
          ...i
        },
        e
      )
    );
  }
);
vy.displayName = "MenuButton";
function pJ() {
  const e = O5(), { address: t } = ur(), n = n1();
  return Ie(() => {
    if (!t || !n)
      throw new Error("No address or chain ID found");
    e.clearTransactions(t, n);
  }, [e, t, n]);
}
var K5 = (e) => {
  var t, n;
  return (n = (t = e == null ? void 0 : e.blockExplorers) == null ? void 0 : t.default) == null ? void 0 : n.url;
}, Y5 = () => /* @__PURE__ */ I.createElement(
  "svg",
  {
    fill: "none",
    height: "19",
    viewBox: "0 0 20 19",
    width: "20",
    xmlns: "http://www.w3.org/2000/svg"
  },
  /* @__PURE__ */ I.createElement("title", null, "Link"),
  /* @__PURE__ */ I.createElement(
    "path",
    {
      d: "M10 18.9443C15.0977 18.9443 19.2812 14.752 19.2812 9.6543C19.2812 4.56543 15.0889 0.373047 10 0.373047C4.90234 0.373047 0.71875 4.56543 0.71875 9.6543C0.71875 14.752 4.91113 18.9443 10 18.9443ZM10 16.6328C6.1416 16.6328 3.03906 13.5215 3.03906 9.6543C3.03906 5.7959 6.13281 2.68457 10 2.68457C13.8584 2.68457 16.9697 5.7959 16.9697 9.6543C16.9785 13.5215 13.8672 16.6328 10 16.6328ZM12.7158 12.1416C13.2432 12.1416 13.5684 11.7549 13.5684 11.1836V7.19336C13.5684 6.44629 13.1377 6.05957 12.417 6.05957H8.40918C7.8291 6.05957 7.45117 6.38477 7.45117 6.91211C7.45117 7.43945 7.8291 7.77344 8.40918 7.77344H9.69238L10.7207 7.63281L9.53418 8.67871L6.73047 11.4912C6.53711 11.6758 6.41406 11.9395 6.41406 12.2031C6.41406 12.7832 6.85352 13.1699 7.39844 13.1699C7.68848 13.1699 7.92578 13.0732 8.1543 12.8623L10.9316 10.0762L11.9775 8.89844L11.8545 9.98828V11.1836C11.8545 11.7725 12.1885 12.1416 12.7158 12.1416Z",
      fill: "currentColor"
    }
  )
), yJ = () => /* @__PURE__ */ I.createElement(
  "svg",
  {
    fill: "none",
    height: "19",
    viewBox: "0 0 20 19",
    width: "20",
    xmlns: "http://www.w3.org/2000/svg"
  },
  /* @__PURE__ */ I.createElement("title", null, "Cancel"),
  /* @__PURE__ */ I.createElement(
    "path",
    {
      d: "M10 18.9443C15.0977 18.9443 19.2812 14.752 19.2812 9.6543C19.2812 4.56543 15.0889 0.373047 10 0.373047C4.90234 0.373047 0.71875 4.56543 0.71875 9.6543C0.71875 14.752 4.91113 18.9443 10 18.9443ZM10 16.6328C6.1416 16.6328 3.03906 13.5215 3.03906 9.6543C3.03906 5.7959 6.13281 2.68457 10 2.68457C13.8584 2.68457 16.9697 5.7959 16.9697 9.6543C16.9785 13.5215 13.8672 16.6328 10 16.6328ZM7.29297 13.3018C7.58301 13.3018 7.81152 13.2139 7.99609 13.0205L10 11.0166L12.0127 13.0205C12.1973 13.2051 12.4258 13.3018 12.707 13.3018C13.2432 13.3018 13.6562 12.8887 13.6562 12.3525C13.6562 12.0977 13.5508 11.8691 13.3662 11.6934L11.3535 9.67188L13.375 7.6416C13.5596 7.44824 13.6562 7.22852 13.6562 6.98242C13.6562 6.44629 13.2432 6.0332 12.7158 6.0332C12.4346 6.0332 12.2148 6.12109 12.0215 6.31445L10 8.32715L7.9873 6.32324C7.80273 6.12988 7.58301 6.04199 7.29297 6.04199C6.76562 6.04199 6.35254 6.45508 6.35254 6.99121C6.35254 7.2373 6.44922 7.46582 6.63379 7.6416L8.65527 9.67188L6.63379 11.6934C6.44922 11.8691 6.35254 12.1064 6.35254 12.3525C6.35254 12.8887 6.76562 13.3018 7.29297 13.3018Z",
      fill: "currentColor"
    }
  )
), mJ = () => /* @__PURE__ */ I.createElement(
  "svg",
  {
    fill: "none",
    height: "20",
    viewBox: "0 0 20 20",
    width: "20",
    xmlns: "http://www.w3.org/2000/svg"
  },
  /* @__PURE__ */ I.createElement("title", null, "Success"),
  /* @__PURE__ */ I.createElement(
    "path",
    {
      d: "M10 19.4443C15.0977 19.4443 19.2812 15.252 19.2812 10.1543C19.2812 5.06543 15.0889 0.873047 10 0.873047C4.90234 0.873047 0.71875 5.06543 0.71875 10.1543C0.71875 15.252 4.91113 19.4443 10 19.4443ZM10 17.1328C6.1416 17.1328 3.03906 14.0215 3.03906 10.1543C3.03906 6.2959 6.13281 3.18457 10 3.18457C13.8584 3.18457 16.9697 6.2959 16.9697 10.1543C16.9785 14.0215 13.8672 17.1328 10 17.1328ZM9.07715 14.3379C9.4375 14.3379 9.7627 14.1533 9.97363 13.8369L13.7441 8.00977C13.8848 7.79883 13.9814 7.5791 13.9814 7.36816C13.9814 6.84961 13.5244 6.48926 13.0322 6.48926C12.707 6.48926 12.4258 6.66504 12.2148 7.0166L9.05957 12.0967L7.5918 10.2949C7.37207 10.0225 7.13477 9.9082 6.84473 9.9082C6.33496 9.9082 5.92188 10.3125 5.92188 10.8223C5.92188 11.0684 6.00098 11.2793 6.18555 11.5078L8.1543 13.8545C8.40918 14.1709 8.70801 14.3379 9.07715 14.3379Z",
      fill: "currentColor"
    }
  )
), gJ = (e) => {
  switch (e) {
    case "pending":
      return ad;
    case "confirmed":
      return mJ;
    case "failed":
      return yJ;
    default:
      return ad;
  }
};
function vJ({ tx: e }) {
  const t = zn(), n = gJ(e.status), r = e.status === "failed" ? "error" : "accentColor", { chain: i } = ur(), o = e.status === "confirmed" ? "Confirmed" : e.status === "failed" ? "Failed" : "Pending", s = K5(i);
  return /* @__PURE__ */ I.createElement(I.Fragment, null, /* @__PURE__ */ I.createElement(
    K,
    {
      ...s ? {
        as: "a",
        background: { hover: "profileForeground" },
        borderRadius: "menuButton",
        className: mn({ active: "shrink" }),
        href: `${s}/tx/${e.hash}`,
        rel: "noreferrer noopener",
        target: "_blank",
        transition: "default"
      } : {},
      color: "modalText",
      display: "flex",
      flexDirection: "row",
      justifyContent: "space-between",
      padding: "8",
      width: "full"
    },
    /* @__PURE__ */ I.createElement(
      K,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "row",
        gap: t ? "16" : "14"
      },
      /* @__PURE__ */ I.createElement(K, { color: r }, /* @__PURE__ */ I.createElement(n, null)),
      /* @__PURE__ */ I.createElement(K, { display: "flex", flexDirection: "column", gap: t ? "3" : "1" }, /* @__PURE__ */ I.createElement(K, null, /* @__PURE__ */ I.createElement(
        De,
        {
          color: "modalText",
          font: "body",
          size: t ? "16" : "14",
          weight: "bold"
        },
        e == null ? void 0 : e.description
      )), /* @__PURE__ */ I.createElement(K, null, /* @__PURE__ */ I.createElement(
        De,
        {
          color: e.status === "pending" ? "modalTextSecondary" : r,
          font: "body",
          size: "14",
          weight: t ? "medium" : "regular"
        },
        o
      )))
    ),
    s && /* @__PURE__ */ I.createElement(K, { alignItems: "center", color: "modalTextDim", display: "flex" }, /* @__PURE__ */ I.createElement(Y5, null))
  ));
}
var bJ = 3;
function wJ({ address: e }) {
  const t = B5(), n = pJ(), { chain: r } = ur(), i = K5(r), o = t.slice(0, bJ), s = o.length > 0, a = zn(), { appName: l } = we(Yd), { i18n: c } = we(xn);
  return /* @__PURE__ */ I.createElement(I.Fragment, null, /* @__PURE__ */ I.createElement(
    K,
    {
      display: "flex",
      flexDirection: "column",
      gap: "10",
      paddingBottom: "2",
      paddingTop: "16",
      paddingX: a ? "8" : "18"
    },
    s && /* @__PURE__ */ I.createElement(
      K,
      {
        paddingBottom: a ? "4" : "0",
        paddingTop: "8",
        paddingX: a ? "12" : "6"
      },
      /* @__PURE__ */ I.createElement(K, { display: "flex", justifyContent: "space-between" }, /* @__PURE__ */ I.createElement(
        De,
        {
          color: "modalTextSecondary",
          size: a ? "16" : "14",
          weight: "semibold"
        },
        c.t("profile.transactions.recent.title")
      ), /* @__PURE__ */ I.createElement(
        K,
        {
          style: {
            marginBottom: -6,
            marginLeft: -10,
            marginRight: -10,
            marginTop: -6
          }
        },
        /* @__PURE__ */ I.createElement(
          K,
          {
            as: "button",
            background: {
              hover: "profileForeground"
            },
            borderRadius: "actionButton",
            className: mn({ active: "shrink" }),
            onClick: n,
            paddingX: a ? "8" : "12",
            paddingY: a ? "4" : "5",
            transition: "default",
            type: "button"
          },
          /* @__PURE__ */ I.createElement(
            De,
            {
              color: "modalTextSecondary",
              size: a ? "16" : "14",
              weight: "semibold"
            },
            c.t("profile.transactions.clear.label")
          )
        )
      ))
    ),
    /* @__PURE__ */ I.createElement(K, { display: "flex", flexDirection: "column", gap: "4" }, s ? o.map((u) => /* @__PURE__ */ I.createElement(vJ, { key: u.hash, tx: u })) : /* @__PURE__ */ I.createElement(I.Fragment, null, /* @__PURE__ */ I.createElement(K, { padding: a ? "12" : "8" }, /* @__PURE__ */ I.createElement(
      De,
      {
        color: "modalTextDim",
        size: a ? "16" : "14",
        weight: a ? "medium" : "bold"
      },
      l ? c.t("profile.transactions.description", {
        appName: l
      }) : c.t("profile.transactions.description_fallback")
    )), a && /* @__PURE__ */ I.createElement(
      K,
      {
        background: "generalBorderDim",
        height: "1",
        marginX: "12",
        marginY: "8"
      }
    )))
  ), i && /* @__PURE__ */ I.createElement(K, { paddingBottom: "18", paddingX: a ? "8" : "18" }, /* @__PURE__ */ I.createElement(
    K,
    {
      alignItems: "center",
      as: "a",
      background: { hover: "profileForeground" },
      borderRadius: "menuButton",
      className: mn({ active: "shrink" }),
      color: "modalTextDim",
      display: "flex",
      flexDirection: "row",
      href: `${i}/address/${e}`,
      justifyContent: "space-between",
      paddingX: "8",
      paddingY: "12",
      rel: "noreferrer noopener",
      style: { willChange: "transform" },
      target: "_blank",
      transition: "default",
      width: "full",
      ...a ? { paddingLeft: "12" } : {}
    },
    /* @__PURE__ */ I.createElement(
      De,
      {
        color: "modalText",
        font: "body",
        size: a ? "16" : "14",
        weight: a ? "semibold" : "bold"
      },
      c.t("profile.explorer.label")
    ),
    /* @__PURE__ */ I.createElement(Y5, null)
  )));
}
function YE({
  action: e,
  icon: t,
  label: n,
  testId: r,
  url: i
}) {
  const o = zn();
  return /* @__PURE__ */ I.createElement(
    K,
    {
      ...i ? { as: "a", href: i, rel: "noreferrer noopener", target: "_blank" } : { as: "button", type: "button" },
      background: {
        base: "profileAction",
        ...o ? {} : { hover: "profileActionHover" }
      },
      borderRadius: "menuButton",
      boxShadow: "profileDetailsAction",
      className: mn({
        active: "shrinkSm",
        hover: o ? void 0 : "grow"
      }),
      display: "flex",
      onClick: e,
      padding: o ? "6" : "8",
      style: { willChange: "transform" },
      testId: r,
      transition: "default",
      width: "full"
    },
    /* @__PURE__ */ I.createElement(
      K,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        gap: "1",
        justifyContent: "center",
        paddingTop: "2",
        width: "full"
      },
      /* @__PURE__ */ I.createElement(K, { color: "modalText", height: "max" }, t),
      /* @__PURE__ */ I.createElement(K, null, /* @__PURE__ */ I.createElement(De, { color: "modalText", size: o ? "12" : "13", weight: "semibold" }, n))
    )
  );
}
function xJ({
  accountExtraInfo: e,
  address: t,
  ensAvatar: n,
  ensName: r,
  onClose: i,
  onDisconnect: o,
  hideDisconnect: s
}) {
  const a = we(r1), [l, c] = Oe(!1), u = Ie(() => {
    t && (navigator.clipboard.writeText(t), c(!0));
  }, [t]);
  if (Te(() => {
    if (l) {
      const m = setTimeout(() => {
        c(!1);
      }, 1500);
      return () => clearTimeout(m);
    }
  }, [l]), !t)
    return null;
  const d = r ? H5(r) : G5(t), f = "rk_profile_title", h = zn(), { i18n: p } = we(xn);
  return /* @__PURE__ */ I.createElement(I.Fragment, null, /* @__PURE__ */ I.createElement(K, { display: "flex", flexDirection: "column" }, /* @__PURE__ */ I.createElement(K, { background: "profileForeground", padding: "16" }, /* @__PURE__ */ I.createElement(
    K,
    {
      alignItems: "center",
      display: "flex",
      flexDirection: "column",
      gap: h ? "16" : "12",
      justifyContent: "center",
      margin: "8",
      style: { textAlign: "center" }
    },
    /* @__PURE__ */ I.createElement(
      K,
      {
        style: {
          position: "absolute",
          right: 16,
          top: 16,
          willChange: "transform"
        }
      },
      /* @__PURE__ */ I.createElement(Oa, { onClose: i })
    ),
    " ",
    /* @__PURE__ */ I.createElement(K, { marginTop: h ? "24" : "0" }, /* @__PURE__ */ I.createElement(
      S5,
      {
        address: t,
        imageUrl: n,
        size: h ? 82 : 74
      }
    )),
    /* @__PURE__ */ I.createElement(
      K,
      {
        display: "flex",
        flexDirection: "column",
        gap: h ? "4" : "0",
        textAlign: "center"
      },
      /* @__PURE__ */ I.createElement(K, { textAlign: "center" }, /* @__PURE__ */ I.createElement(
        De,
        {
          as: "h1",
          color: "modalText",
          id: f,
          size: h ? "20" : "18",
          weight: "heavy"
        },
        d
      ))
    ),
    e == null ? void 0 : e.otherAddresses.map((m) => /* @__PURE__ */ I.createElement(
      vy,
      {
        currentlySelected: !1,
        key: m,
        onClick: () => {
          e.onOtherAddressClick(m), i();
        }
      },
      /* @__PURE__ */ I.createElement(
        K,
        {
          display: "flex",
          flexDirection: "column",
          gap: h ? "4" : "0",
          textAlign: "center"
        },
        /* @__PURE__ */ I.createElement(K, { textAlign: "center" }, /* @__PURE__ */ I.createElement(
          De,
          {
            as: "h1",
            color: "modalText",
            id: f,
            size: h ? "20" : "18",
            weight: "heavy"
          },
          m
        ))
      )
    ))
  ), /* @__PURE__ */ I.createElement(
    K,
    {
      display: "flex",
      flexDirection: "row",
      gap: "8",
      margin: "2",
      marginTop: "16"
    },
    /* @__PURE__ */ I.createElement(
      YE,
      {
        action: u,
        icon: l ? /* @__PURE__ */ I.createElement(uJ, null) : /* @__PURE__ */ I.createElement(dJ, null),
        label: l ? p.t("profile.copy_address.copied") : p.t("profile.copy_address.label")
      }
    ),
    !s && /* @__PURE__ */ I.createElement(
      YE,
      {
        action: o,
        icon: /* @__PURE__ */ I.createElement(fJ, null),
        label: p.t("profile.disconnect.label"),
        testId: "disconnect-button"
      }
    )
  )), a && /* @__PURE__ */ I.createElement(I.Fragment, null, /* @__PURE__ */ I.createElement(K, { background: "generalBorder", height: "1", marginTop: "-1" }), /* @__PURE__ */ I.createElement(K, null, /* @__PURE__ */ I.createElement(wJ, { address: t })))));
}
var Q5 = Ge(void 0), CJ = () => we(Q5);
function kJ({
  onClose: e,
  open: t,
  dialogRoot: n,
  hideDisconnect: r
}) {
  const { address: i } = ur(), { ensAvatar: o, ensName: s } = I5({
    address: i
  }), { disconnect: a } = oy(), l = CJ();
  return i ? /* @__PURE__ */ I.createElement(I.Fragment, null, i && /* @__PURE__ */ I.createElement(
    ep,
    {
      dialogRoot: n,
      onClose: e,
      open: t,
      titleId: "rk_account_modal_title"
    },
    /* @__PURE__ */ I.createElement(tp, { bottomSheetOnMobile: !0, padding: "0" }, /* @__PURE__ */ I.createElement(
      xJ,
      {
        accountExtraInfo: l,
        address: i,
        ensAvatar: o,
        ensName: s,
        onClose: e,
        onDisconnect: a,
        hideDisconnect: r
      }
    ))
  )) : null;
}
var EJ = ({ size: e }) => /* @__PURE__ */ I.createElement(
  "svg",
  {
    fill: "none",
    height: e,
    viewBox: "0 0 28 28",
    width: e,
    xmlns: "http://www.w3.org/2000/svg"
  },
  /* @__PURE__ */ I.createElement("title", null, "Disconnect"),
  /* @__PURE__ */ I.createElement(
    "path",
    {
      d: "M6.742 22.195h8.367c1.774 0 2.743-.968 2.743-2.758V16.11h-2.016v3.11c0 .625-.305.96-.969.96H6.984c-.664 0-.968-.335-.968-.96V7.984c0-.632.304-.968.968-.968h7.883c.664 0 .969.336.969.968v3.133h2.016v-3.36c0-1.78-.97-2.757-2.743-2.757H6.742C4.97 5 4 5.977 4 7.758v11.68c0 1.789.969 2.757 2.742 2.757Zm5.438-7.703h7.601l1.149-.07-.602.406-1.008.938a.816.816 0 0 0-.258.593c0 .407.313.782.758.782.227 0 .39-.086.547-.243l2.492-2.593c.235-.235.313-.47.313-.711 0-.242-.078-.477-.313-.719l-2.492-2.586c-.156-.156-.32-.25-.547-.25-.445 0-.758.367-.758.781 0 .227.094.446.258.594l1.008.945.602.407-1.149-.079H12.18a.904.904 0 0 0 0 1.805Z",
      fill: "currentColor"
    }
  )
), SJ = ({
  chainId: e,
  currentChainId: t,
  switchChain: n,
  chainIconSize: r,
  isLoading: i,
  src: o,
  name: s,
  iconBackground: a,
  idx: l,
  enabled: c,
  onDiabledChainClick: u,
  switchError: d,
  chain: f
}) => {
  const h = zn(), { i18n: p } = we(xn), m = Va(), g = t === e;
  return /* @__PURE__ */ I.createElement(Tc, null, /* @__PURE__ */ I.createElement(
    vy,
    {
      currentlySelected: g,
      onClick: g ? void 0 : c ? () => n({ chainId: e }) : () => u(),
      testId: `chain-option-${e}`
    },
    /* @__PURE__ */ I.createElement(
      K,
      {
        fontFamily: "body",
        fontSize: "16",
        fontWeight: "bold",
        style: { opacity: c ? 1 : 0.4 }
      },
      /* @__PURE__ */ I.createElement(
        K,
        {
          alignItems: "center",
          display: "flex",
          flexDirection: "row",
          justifyContent: "space-between"
        },
        /* @__PURE__ */ I.createElement(
          K,
          {
            alignItems: "center",
            display: "flex",
            flexDirection: "row",
            gap: "4",
            height: r
          },
          o && /* @__PURE__ */ I.createElement(K, { height: "full", marginRight: "8" }, /* @__PURE__ */ I.createElement(
            An,
            {
              alt: s,
              background: a,
              borderRadius: "full",
              height: r,
              src: o,
              width: r,
              testId: `chain-option-${e}-icon`
            }
          )),
          /* @__PURE__ */ I.createElement("div", null, s ?? s)
        ),
        g ? /* @__PURE__ */ I.createElement(
          K,
          {
            alignItems: "center",
            display: "flex",
            flexDirection: "row",
            marginRight: "6"
          },
          /* @__PURE__ */ I.createElement(De, { color: "accentColorForeground", size: "14", weight: "medium" }, p.t("chains.connected")),
          /* @__PURE__ */ I.createElement(
            K,
            {
              background: "connectionIndicator",
              borderColor: "selectedOptionBorder",
              borderRadius: "full",
              borderStyle: "solid",
              borderWidth: "1",
              height: "8",
              marginLeft: "8",
              width: "8"
            }
          )
        ) : i ? /* @__PURE__ */ I.createElement(
          K,
          {
            alignItems: "center",
            display: "flex",
            flexDirection: "row",
            marginRight: "6"
          },
          /* @__PURE__ */ I.createElement(De, { color: "modalText", size: "14", weight: "medium" }, d ? p.t("chains.confirm_error") : p.t("chains.confirm")),
          /* @__PURE__ */ I.createElement(
            K,
            {
              background: d ? "error" : "standby",
              borderRadius: "full",
              height: "8",
              marginLeft: "8",
              width: "8"
            }
          )
        ) : !f.enabled && f.info ? /* @__PURE__ */ I.createElement(
          K,
          {
            alignItems: "center",
            display: "flex",
            flexDirection: "row",
            marginRight: "6"
          },
          /* @__PURE__ */ I.createElement(De, { color: "modalText", size: "14", weight: "medium" }, f.info)
        ) : null
      )
    )
  ), h && l < m.length - 1 && /* @__PURE__ */ I.createElement(K, { background: "generalBorderDim", height: "1", marginX: "8" }));
}, AJ = SJ, TJ = "dwg2bm0", _J = "dwg2bm1";
function IJ({ onClose: e, open: t, dialogRoot: n }) {
  const { chainId: r } = ur(), { chains: i } = Dn(), [o, s] = Oe(null), { switchChain: a, reset: l, isError: c } = zG({
    mutation: {
      onMutate: ({ chainId: A }) => {
        s(A);
      },
      onSuccess: () => {
        o && s(null), u();
      }
      // onError: () => {
      //   if (pendingChainId) setPendingChainId(null);
      // },
      // onSettled: () => {
      //   _onClose();
      // },
    }
  }), u = () => {
    l(), e();
  }, d = J(() => new Map(i.map((A) => [A.id, A])), [i]), { i18n: f } = we(xn), { disconnect: h } = oy(), p = "rk_chain_modal_title", m = zn(), g = r && d.has(r), v = m ? "36" : "28", w = Va(), x = rQ(), C = iQ(), S = J(
    () => new Map(x.map((A) => [A.id, A])),
    [x]
  ), k = J(
    () => [
      ...w.reduce(
        (A, b) => {
          const T = d.get(b.id);
          return !T || S.has(T.id) || A.push({ ...b, ...T, enabled: !0 }), A;
        },
        []
      ),
      ...x.map((A) => ({
        ...A,
        enabled: !1
      }))
    ],
    [w, x, d]
  );
  return r ? /* @__PURE__ */ I.createElement(
    ep,
    {
      onClose: e,
      open: t,
      titleId: p,
      dialogRoot: n
    },
    /* @__PURE__ */ I.createElement(tp, { bottomSheetOnMobile: !0, paddingBottom: "0" }, /* @__PURE__ */ I.createElement(K, { display: "flex", flexDirection: "column", gap: "14" }, /* @__PURE__ */ I.createElement(
      K,
      {
        display: "flex",
        flexDirection: "row",
        justifyContent: "space-between"
      },
      m && /* @__PURE__ */ I.createElement(K, { width: "30" }),
      /* @__PURE__ */ I.createElement(K, { paddingBottom: "0", paddingLeft: "8", paddingTop: "4" }, /* @__PURE__ */ I.createElement(
        De,
        {
          as: "h1",
          color: "modalText",
          id: p,
          size: m ? "20" : "18",
          weight: "heavy"
        },
        f.t("chains.title")
      )),
      /* @__PURE__ */ I.createElement(Oa, { onClose: e })
    ), !g && /* @__PURE__ */ I.createElement(K, { marginX: "8", textAlign: m ? "center" : "left" }, /* @__PURE__ */ I.createElement(De, { color: "modalTextSecondary", size: "14", weight: "medium" }, f.t("chains.wrong_network"))), /* @__PURE__ */ I.createElement(
      K,
      {
        className: m ? _J : TJ,
        display: "flex",
        flexDirection: "column",
        gap: "4",
        padding: "2",
        paddingBottom: "16"
      },
      k.map((A, b) => {
        const { iconBackground: T, iconUrl: R, id: B, name: O, enabled: L } = A;
        return /* @__PURE__ */ I.createElement(
          AJ,
          {
            key: B,
            chainId: B,
            currentChainId: r,
            switchChain: a,
            chainIconSize: v,
            isLoading: o === B,
            src: R,
            name: O,
            iconBackground: T,
            idx: b,
            enabled: L,
            onDiabledChainClick: () => C == null ? void 0 : C(A),
            switchError: c,
            chain: A
          }
        );
      }),
      !g && /* @__PURE__ */ I.createElement(I.Fragment, null, /* @__PURE__ */ I.createElement(K, { background: "generalBorderDim", height: "1", marginX: "8" }), /* @__PURE__ */ I.createElement(
        vy,
        {
          onClick: () => h(),
          testId: "chain-option-disconnect"
        },
        /* @__PURE__ */ I.createElement(
          K,
          {
            color: "error",
            fontFamily: "body",
            fontSize: "16",
            fontWeight: "bold"
          },
          /* @__PURE__ */ I.createElement(
            K,
            {
              alignItems: "center",
              display: "flex",
              flexDirection: "row",
              justifyContent: "space-between"
            },
            /* @__PURE__ */ I.createElement(
              K,
              {
                alignItems: "center",
                display: "flex",
                flexDirection: "row",
                gap: "4",
                height: v
              },
              /* @__PURE__ */ I.createElement(
                K,
                {
                  alignItems: "center",
                  color: "error",
                  height: v,
                  justifyContent: "center",
                  marginRight: "8"
                },
                /* @__PURE__ */ I.createElement(EJ, { size: Number(v) })
              ),
              /* @__PURE__ */ I.createElement("div", null, f.t("chains.disconnect"))
            )
          )
        )
      ))
    )))
  ) : null;
}
function RJ(e, t) {
  const n = {};
  for (const r of e) {
    const i = t(r);
    i && (n[i] || (n[i] = []), n[i].push(r));
  }
  return n;
}
var l1 = ({
  children: e,
  href: t
}) => /* @__PURE__ */ I.createElement(
  K,
  {
    as: "a",
    color: "accentColor",
    href: t,
    rel: "noreferrer",
    target: "_blank"
  },
  e
), c1 = ({ children: e }) => /* @__PURE__ */ I.createElement(De, { color: "modalTextSecondary", size: "12", weight: "medium" }, e);
function QE({
  compactModeEnabled: e = !1,
  getWallet: t
}) {
  const { disclaimer: n, learnMoreUrl: r } = we(Yd), { i18n: i } = we(xn);
  return /* @__PURE__ */ I.createElement(I.Fragment, null, /* @__PURE__ */ I.createElement(
    K,
    {
      alignItems: "center",
      color: "accentColor",
      display: "flex",
      flexDirection: "column",
      height: "full",
      justifyContent: "space-around"
    },
    /* @__PURE__ */ I.createElement(K, { marginBottom: "10" }, !e && /* @__PURE__ */ I.createElement(De, { color: "modalText", size: "18", weight: "heavy" }, i.t("intro.title"))),
    /* @__PURE__ */ I.createElement(
      K,
      {
        display: "flex",
        flexDirection: "column",
        gap: "32",
        justifyContent: "center",
        marginY: "20",
        style: { maxWidth: 312 }
      },
      /* @__PURE__ */ I.createElement(K, { alignItems: "center", display: "flex", flexDirection: "row", gap: "16" }, /* @__PURE__ */ I.createElement(K, { borderRadius: "6", height: "48", minWidth: "48", width: "48" }, /* @__PURE__ */ I.createElement(UQ, null)), /* @__PURE__ */ I.createElement(K, { display: "flex", flexDirection: "column", gap: "4" }, /* @__PURE__ */ I.createElement(De, { color: "modalText", size: "14", weight: "bold" }, i.t("intro.digital_asset.title")), /* @__PURE__ */ I.createElement(De, { color: "modalTextSecondary", size: "14", weight: "medium" }, i.t("intro.digital_asset.description")))),
      /* @__PURE__ */ I.createElement(K, { alignItems: "center", display: "flex", flexDirection: "row", gap: "16" }, /* @__PURE__ */ I.createElement(K, { borderRadius: "6", height: "48", minWidth: "48", width: "48" }, /* @__PURE__ */ I.createElement(VQ, null)), /* @__PURE__ */ I.createElement(K, { display: "flex", flexDirection: "column", gap: "4" }, /* @__PURE__ */ I.createElement(De, { color: "modalText", size: "14", weight: "bold" }, i.t("intro.login.title")), /* @__PURE__ */ I.createElement(De, { color: "modalTextSecondary", size: "14", weight: "medium" }, i.t("intro.login.description"))))
    ),
    /* @__PURE__ */ I.createElement(
      K,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        gap: "12",
        justifyContent: "center",
        margin: "10"
      },
      /* @__PURE__ */ I.createElement(cr, { label: i.t("intro.get.label"), onClick: t }),
      /* @__PURE__ */ I.createElement(
        K,
        {
          as: "a",
          className: mn({ active: "shrink", hover: "grow" }),
          display: "block",
          href: r,
          paddingX: "12",
          paddingY: "4",
          rel: "noreferrer",
          style: { willChange: "transform" },
          target: "_blank",
          transition: "default"
        },
        /* @__PURE__ */ I.createElement(De, { color: "accentColor", size: "14", weight: "bold" }, i.t("intro.learn_more.label"))
      )
    ),
    n && !e && /* @__PURE__ */ I.createElement(K, { marginBottom: "8", marginTop: "12", textAlign: "center" }, /* @__PURE__ */ I.createElement(n, { Link: l1, Text: c1 }))
  ));
}
var J5 = () => /* @__PURE__ */ I.createElement(
  "svg",
  {
    fill: "none",
    height: "17",
    viewBox: "0 0 11 17",
    width: "11",
    xmlns: "http://www.w3.org/2000/svg"
  },
  /* @__PURE__ */ I.createElement("title", null, "Back"),
  /* @__PURE__ */ I.createElement(
    "path",
    {
      d: "M0.99707 8.6543C0.99707 9.08496 1.15527 9.44531 1.51562 9.79688L8.16016 16.3096C8.43262 16.5732 8.74902 16.7051 9.13574 16.7051C9.90918 16.7051 10.5508 16.0811 10.5508 15.3076C10.5508 14.9121 10.3838 14.5605 10.0938 14.2705L4.30176 8.64551L10.0938 3.0293C10.3838 2.74805 10.5508 2.3877 10.5508 2.00098C10.5508 1.23633 9.90918 0.603516 9.13574 0.603516C8.74902 0.603516 8.43262 0.735352 8.16016 0.999023L1.51562 7.51172C1.15527 7.85449 1.00586 8.21484 0.99707 8.6543Z",
      fill: "currentColor"
    }
  )
), PJ = () => /* @__PURE__ */ I.createElement(
  "svg",
  {
    fill: "none",
    height: "12",
    viewBox: "0 0 8 12",
    width: "8",
    xmlns: "http://www.w3.org/2000/svg"
  },
  /* @__PURE__ */ I.createElement("title", null, "Info"),
  /* @__PURE__ */ I.createElement(
    "path",
    {
      d: "M3.64258 7.99609C4.19336 7.99609 4.5625 7.73828 4.68555 7.24609C4.69141 7.21094 4.70312 7.16406 4.70898 7.13477C4.80859 6.60742 5.05469 6.35547 6.04492 5.76367C7.14648 5.10156 7.67969 4.3457 7.67969 3.24414C7.67969 1.39844 6.17383 0.255859 3.95898 0.255859C2.32422 0.255859 1.05859 0.894531 0.548828 1.86719C0.396484 2.14844 0.320312 2.44727 0.320312 2.74023C0.314453 3.37305 0.742188 3.79492 1.42188 3.79492C1.91406 3.79492 2.33594 3.54883 2.53516 3.11523C2.78711 2.47656 3.23242 2.21289 3.83594 2.21289C4.55664 2.21289 5.10742 2.65234 5.10742 3.29102C5.10742 3.9707 4.7793 4.29883 3.81836 4.87891C3.02148 5.36523 2.50586 5.92773 2.50586 6.76562V6.90039C2.50586 7.55664 2.96289 7.99609 3.64258 7.99609ZM3.67188 11.4473C4.42773 11.4473 5.04297 10.8672 5.04297 10.1406C5.04297 9.41406 4.42773 8.83984 3.67188 8.83984C2.91602 8.83984 2.30664 9.41406 2.30664 10.1406C2.30664 10.8672 2.91602 11.4473 3.67188 11.4473Z",
      fill: "currentColor"
    }
  )
), OJ = ({
  "aria-label": e = "Info",
  onClick: t
}) => {
  const n = zn();
  return /* @__PURE__ */ I.createElement(
    K,
    {
      alignItems: "center",
      "aria-label": e,
      as: "button",
      background: "closeButtonBackground",
      borderColor: "actionButtonBorder",
      borderRadius: "full",
      borderStyle: "solid",
      borderWidth: n ? "0" : "1",
      className: mn({ active: "shrinkSm", hover: "growLg" }),
      color: "closeButton",
      display: "flex",
      height: n ? "30" : "28",
      justifyContent: "center",
      onClick: t,
      style: { willChange: "transform" },
      transition: "default",
      type: "button",
      width: n ? "30" : "28"
    },
    /* @__PURE__ */ I.createElement(PJ, null)
  );
}, X5 = (e) => {
  const t = It(null), n = we(D5), r = e1(e);
  return Te(() => {
    if (n && t.current && r)
      return NJ(t.current, r);
  }, [n, r]), t;
}, BJ = () => {
  const e = "_rk_coolMode", t = document.getElementById(e);
  if (t)
    return t;
  const n = document.createElement("div");
  return n.setAttribute("id", e), n.setAttribute(
    "style",
    [
      "overflow:hidden",
      "position:fixed",
      "height:100%",
      "top:0",
      "left:0",
      "right:0",
      "bottom:0",
      "pointer-events:none",
      "z-index:2147483647"
    ].join(";")
  ), document.body.appendChild(n), n;
}, JE = 0;
function NJ(e, t) {
  JE++;
  const n = [15, 20, 25, 35, 45], r = 35;
  let i = [], o = !1, s = 0, a = 0;
  const l = BJ();
  function c() {
    const C = n[Math.floor(Math.random() * n.length)], S = Math.random() * 10, k = Math.random() * 25, A = Math.random() * 360, b = Math.random() * 35 * (Math.random() <= 0.5 ? -1 : 1), T = a - C / 2, R = s - C / 2, B = Math.random() <= 0.5 ? -1 : 1, O = document.createElement("div");
    O.innerHTML = `<img src="${t}" width="${C}" height="${C}" style="border-radius: 25%">`, O.setAttribute(
      "style",
      [
        "position:absolute",
        "will-change:transform",
        `top:${T}px`,
        `left:${R}px`,
        `transform:rotate(${A}deg)`
      ].join(";")
    ), l.appendChild(O), i.push({
      direction: B,
      element: O,
      left: R,
      size: C,
      speedHorz: S,
      speedUp: k,
      spinSpeed: b,
      spinVal: A,
      top: T
    });
  }
  function u() {
    for (const C of i)
      C.left = C.left - C.speedHorz * C.direction, C.top = C.top - C.speedUp, C.speedUp = Math.min(C.size, C.speedUp - 1), C.spinVal = C.spinVal + C.spinSpeed, C.top >= Math.max(window.innerHeight, document.body.clientHeight) + C.size && (i = i.filter((S) => S !== C), C.element.remove()), C.element.setAttribute(
        "style",
        [
          "position:absolute",
          "will-change:transform",
          `top:${C.top}px`,
          `left:${C.left}px`,
          `transform:rotate(${C.spinVal}deg)`
        ].join(";")
      );
  }
  let d;
  function f() {
    o && i.length < r && c(), u(), d = requestAnimationFrame(f);
  }
  f();
  const h = "ontouchstart" in window || // @ts-expect-error
  navigator.msMaxTouchPoints, p = h ? "touchstart" : "mousedown", m = h ? "touchend" : "mouseup", g = h ? "touchmove" : "mousemove", v = (C) => {
    var S, k;
    "touches" in C ? (s = (S = C.touches) == null ? void 0 : S[0].clientX, a = (k = C.touches) == null ? void 0 : k[0].clientY) : (s = C.clientX, a = C.clientY);
  }, w = (C) => {
    v(C), o = !0;
  }, x = () => {
    o = !1;
  };
  return e.addEventListener(g, v, { passive: !1 }), e.addEventListener(p, w), e.addEventListener(m, x), e.addEventListener("mouseleave", x), () => {
    e.removeEventListener(g, v), e.removeEventListener(p, w), e.removeEventListener(m, x), e.removeEventListener("mouseleave", x);
    const C = setInterval(() => {
      d && i.length === 0 && (cancelAnimationFrame(d), clearInterval(C), --JE === 0 && l.remove());
    }, 500);
  };
}
var DJ = "ywp5x60", Z5 = ({
  as: e = "button",
  currentlySelected: t = !1,
  iconBackground: n,
  iconUrl: r,
  name: i,
  onClick: o,
  ready: s,
  recent: a,
  testId: l,
  isRainbowKitConnector: c,
  ...u
}) => {
  const d = X5(r), [f, h] = Oe(!1), { i18n: p } = we(xn);
  return /* @__PURE__ */ I.createElement(
    K,
    {
      display: "flex",
      flexDirection: "column",
      onMouseEnter: () => h(!0),
      onMouseLeave: () => h(!1),
      ref: d
    },
    /* @__PURE__ */ I.createElement(
      K,
      {
        as: e,
        borderRadius: "menuButton",
        borderStyle: "solid",
        borderWidth: "1",
        className: t ? void 0 : [
          DJ,
          mn({
            active: "shrink"
          })
        ],
        disabled: t,
        onClick: o,
        padding: "5",
        style: { willChange: "transform" },
        testId: l,
        transition: "default",
        width: "full",
        ...t ? {
          background: "accentColor",
          borderColor: "selectedOptionBorder",
          boxShadow: "selectedWallet"
        } : {
          background: { hover: "menuItemBackground" }
        },
        ...u
      },
      /* @__PURE__ */ I.createElement(
        K,
        {
          color: t ? "accentColorForeground" : "modalText",
          disabled: !s,
          fontFamily: "body",
          fontSize: "16",
          fontWeight: "bold",
          transition: "default"
        },
        /* @__PURE__ */ I.createElement(K, { alignItems: "center", display: "flex", flexDirection: "row", gap: "12" }, /* @__PURE__ */ I.createElement(
          An,
          {
            background: n,
            ...!f && c ? { borderColor: "actionButtonBorder" } : {},
            useAsImage: !c,
            borderRadius: "6",
            height: "28",
            src: r,
            width: "28"
          }
        ), /* @__PURE__ */ I.createElement(K, null, /* @__PURE__ */ I.createElement(
          K,
          {
            style: { marginTop: a ? -2 : void 0 },
            maxWidth: "200"
          },
          i
        ), a && /* @__PURE__ */ I.createElement(
          De,
          {
            color: t ? "accentColorForeground" : "accentColor",
            size: "12",
            style: { lineHeight: 1, marginTop: -1 },
            weight: "medium"
          },
          p.t("connect.recent")
        )))
      )
    )
  );
};
Z5.displayName = "ModalSelection";
var jJ = "rk-latest-id";
function MJ(e) {
  localStorage.setItem(jJ, e);
}
var Eg = (e, t = 1) => {
  let n = e.replace("#", "");
  n.length === 3 && (n = `${n[0]}${n[0]}${n[1]}${n[1]}${n[2]}${n[2]}`);
  const r = parseInt(n.substring(0, 2), 16), i = parseInt(n.substring(2, 4), 16), o = parseInt(n.substring(4, 6), 16);
  return t > 1 && t <= 100 && (t = t / 100), `rgba(${r},${i},${o},${t})`;
}, FJ = (e) => e ? [
  Eg(e, 0.2),
  Eg(e, 0.14),
  Eg(e, 0.1)
] : null, LJ = (e) => /^#([0-9a-f]{3}){1,2}$/i.test(e), eR = async () => (await import("./connect-MR6XDLIE-DIW_XJtj.js")).default, UJ = () => Zi(eR), zJ = () => /* @__PURE__ */ I.createElement(
  An,
  {
    background: "#515a70",
    borderColor: "generalBorder",
    borderRadius: "10",
    height: "48",
    src: eR,
    width: "48"
  }
), tR = async () => (await import("./create-X4WFHLCW-B45Mqv6V.js")).default, nR = () => Zi(tR), VJ = () => /* @__PURE__ */ I.createElement(
  An,
  {
    background: "#e3a5e8",
    borderColor: "generalBorder",
    borderRadius: "10",
    height: "48",
    src: tR,
    width: "48"
  }
), rR = async () => (await import("./refresh-HJGJRASX-Bg4Kfapo.js")).default, qJ = () => Zi(rR), $J = () => /* @__PURE__ */ I.createElement(
  An,
  {
    background: "#515a70",
    borderColor: "generalBorder",
    borderRadius: "10",
    height: "48",
    src: rR,
    width: "48"
  }
), iR = async () => (await import("./scan-DEOT2M37-DLhw4TP0.js")).default, oR = () => Zi(iR), WJ = () => /* @__PURE__ */ I.createElement(
  An,
  {
    background: "#515a70",
    borderColor: "generalBorder",
    borderRadius: "10",
    height: "48",
    src: iR,
    width: "48"
  }
), GJ = "_1ud5su60", HJ = "_1ud5su62 in5bvi7a in5bvi7v", KJ = "_1ud5su63", YJ = "_1ud5su64", QJ = (e, t) => {
  const n = Array.prototype.slice.call(
    Gd.create(e, { errorCorrectionLevel: t }).modules.data,
    0
  ), r = Math.sqrt(n.length);
  return n.reduce(
    (i, o, s) => (s % r === 0 ? i.push([o]) : i[i.length - 1].push(o)) && i,
    []
  );
};
function sR({
  ecl: e = "M",
  logoBackground: t,
  logoMargin: n = 10,
  logoSize: r = 50,
  logoUrl: i,
  size: o = 200,
  uri: s
}) {
  const a = "20", l = o - parseInt(a, 10) * 2, c = J(() => {
    const f = [], h = QJ(s, e), p = l / h.length;
    [
      { x: 0, y: 0 },
      { x: 1, y: 0 },
      { x: 0, y: 1 }
    ].forEach(({ x, y: C }) => {
      const S = (h.length - 7) * p * x, k = (h.length - 7) * p * C;
      for (let A = 0; A < 3; A++)
        f.push(
          /* @__PURE__ */ I.createElement(
            "rect",
            {
              fill: A % 2 !== 0 ? "white" : "black",
              height: p * (7 - A * 2),
              key: `${A}-${x}-${C}`,
              rx: (A - 2) * -5 + (A === 0 ? 2 : 0),
              ry: (A - 2) * -5 + (A === 0 ? 2 : 0),
              width: p * (7 - A * 2),
              x: S + p * A,
              y: k + p * A
            }
          )
        );
    });
    const g = Math.floor((r + 25) / p), v = h.length / 2 - g / 2, w = h.length / 2 + g / 2 - 1;
    return h.forEach((x, C) => {
      x.forEach((S, k) => {
        h[C][k] && (C < 7 && k < 7 || C > h.length - 8 && k < 7 || C < 7 && k > h.length - 8 || C > v && C < w && k > v && k < w || f.push(
          /* @__PURE__ */ I.createElement(
            "circle",
            {
              cx: C * p + p / 2,
              cy: k * p + p / 2,
              fill: "black",
              key: `circle-${C}-${k}`,
              r: p / 3
            }
          )
        ));
      });
    }), f;
  }, [e, r, l, s]), u = l / 2 - r / 2, d = r + n * 2;
  return /* @__PURE__ */ I.createElement(
    K,
    {
      borderColor: "generalBorder",
      borderRadius: "menuButton",
      borderStyle: "solid",
      borderWidth: "1",
      className: GJ,
      padding: a,
      width: "max"
    },
    /* @__PURE__ */ I.createElement(
      K,
      {
        style: {
          height: l,
          userSelect: "none",
          width: l
        },
        userSelect: "none"
      },
      /* @__PURE__ */ I.createElement(
        K,
        {
          display: "flex",
          justifyContent: "center",
          position: "relative",
          style: {
            height: 0,
            top: u,
            width: l
          },
          width: "full"
        },
        /* @__PURE__ */ I.createElement(
          An,
          {
            background: t,
            borderColor: { custom: "rgba(0, 0, 0, 0.06)" },
            borderRadius: "13",
            height: r,
            src: i,
            width: r
          }
        )
      ),
      /* @__PURE__ */ I.createElement("svg", { height: l, style: { all: "revert" }, width: l }, /* @__PURE__ */ I.createElement("title", null, "QR Code"), /* @__PURE__ */ I.createElement("defs", null, /* @__PURE__ */ I.createElement("clipPath", { id: "clip-wrapper" }, /* @__PURE__ */ I.createElement("rect", { height: d, width: d })), /* @__PURE__ */ I.createElement("clipPath", { id: "clip-logo" }, /* @__PURE__ */ I.createElement("rect", { height: r, width: r }))), /* @__PURE__ */ I.createElement("rect", { fill: "transparent", height: l, width: l }), c)
    )
  );
}
var aR = async () => {
  switch (o1()) {
    case "Arc":
      return (await import("./Arc-R3PUWRPJ-oIWmQTz-.js")).default;
    case "Brave":
      return (await import("./Brave-24BM36UM-BmquA_Ct.js")).default;
    case "Chrome":
      return (await import("./Chrome-TLI42HDP-BEkoj40w.js")).default;
    case "Edge":
      return (await import("./Edge-AZ34LAFM-Bg_GDy2_.js")).default;
    case "Firefox":
      return (await import("./Firefox-ZDK7RHKK-WeOEew4Z.js")).default;
    case "Opera":
      return (await import("./Opera-BKMCKUXC-DBIlX5eO.js")).default;
    case "Safari":
      return (await import("./Safari-PXQIVS6N-Dl4GHP_g.js")).default;
    default:
      return (await import("./Browser-4R4QKTV2-DJI3cfs0.js")).default;
  }
}, JJ = () => Zi(aR), lR = async () => {
  switch (a1()) {
    case "Windows":
      return (await import("./Windows-GTAT3OTE-S5UysqbI.js")).default;
    case "macOS":
      return (await import("./Macos-5QL4JBJE-QR-PBdQO.js")).default;
    case "Linux":
      return (await import("./Linux-VYP66PDO-DdRMzaAc.js")).default;
    default:
      return (await import("./Linux-VYP66PDO-DdRMzaAc.js")).default;
  }
}, XJ = () => Zi(lR);
function ZJ({
  getWalletDownload: e,
  compactModeEnabled: t
}) {
  const r = gy().filter(
    (o) => o.isRainbowKitConnector
  ).splice(0, 5), { i18n: i } = we(xn);
  return /* @__PURE__ */ I.createElement(
    K,
    {
      alignItems: "center",
      display: "flex",
      flexDirection: "column",
      height: "full",
      marginTop: "18",
      width: "full"
    },
    /* @__PURE__ */ I.createElement(
      K,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        gap: "28",
        height: "full",
        width: "full"
      },
      r == null ? void 0 : r.filter(
        (o) => {
          var s;
          return o.extensionDownloadUrl || o.desktopDownloadUrl || o.qrCode && ((s = o.downloadUrls) == null ? void 0 : s.qrCode);
        }
      ).map((o) => {
        const { downloadUrls: s, iconBackground: a, iconUrl: l, id: c, name: u, qrCode: d } = o, f = (s == null ? void 0 : s.qrCode) && d, h = !!o.extensionDownloadUrl, p = (s == null ? void 0 : s.qrCode) && h, m = (s == null ? void 0 : s.qrCode) && !!o.desktopDownloadUrl;
        return /* @__PURE__ */ I.createElement(
          K,
          {
            alignItems: "center",
            display: "flex",
            gap: "16",
            justifyContent: "space-between",
            key: o.id,
            width: "full"
          },
          /* @__PURE__ */ I.createElement(
            K,
            {
              alignItems: "center",
              display: "flex",
              flexDirection: "row",
              gap: "16"
            },
            /* @__PURE__ */ I.createElement(
              An,
              {
                background: a,
                borderColor: "actionButtonBorder",
                borderRadius: "10",
                height: "48",
                src: l,
                width: "48"
              }
            ),
            /* @__PURE__ */ I.createElement(K, { display: "flex", flexDirection: "column", gap: "2" }, /* @__PURE__ */ I.createElement(De, { color: "modalText", size: "14", weight: "bold" }, u), /* @__PURE__ */ I.createElement(De, { color: "modalTextSecondary", size: "14", weight: "medium" }, p ? i.t("get.mobile_and_extension.description") : m ? i.t("get.mobile_and_desktop.description") : f ? i.t("get.mobile.description") : h ? i.t("get.extension.description") : null))
          ),
          /* @__PURE__ */ I.createElement(K, { display: "flex", flexDirection: "column", gap: "4" }, /* @__PURE__ */ I.createElement(
            cr,
            {
              label: i.t("get.action.label"),
              onClick: () => e(c),
              type: "secondary"
            }
          ))
        );
      })
    ),
    /* @__PURE__ */ I.createElement(
      K,
      {
        alignItems: "center",
        borderRadius: "10",
        display: "flex",
        flexDirection: "column",
        gap: "8",
        justifyContent: "space-between",
        marginBottom: "4",
        paddingY: "8",
        style: { maxWidth: 275, textAlign: "center" }
      },
      /* @__PURE__ */ I.createElement(De, { color: "modalText", size: "14", weight: "bold" }, i.t("get.looking_for.title")),
      /* @__PURE__ */ I.createElement(De, { color: "modalTextSecondary", size: "14", weight: "medium" }, t ? i.t("get.looking_for.desktop.compact_description") : i.t("get.looking_for.desktop.wide_description"))
    )
  );
}
var Sg = "44";
function eX({
  changeWalletStep: e,
  compactModeEnabled: t,
  connectionError: n,
  onClose: r,
  qrCodeUri: i,
  reconnect: o,
  wallet: s
}) {
  const {
    downloadUrls: a,
    iconBackground: l,
    iconUrl: c,
    name: u,
    qrCode: d,
    ready: f,
    showWalletConnectModal: h,
    getDesktopUri: p
  } = s, m = !!p, g = i1(), { i18n: v } = we(xn), w = !!s.extensionDownloadUrl, x = (a == null ? void 0 : a.qrCode) && w, C = (a == null ? void 0 : a.qrCode) && !!s.desktopDownloadUrl, S = d && i, k = async () => {
    const R = await (p == null ? void 0 : p());
    window.open(R, g ? "_blank" : "_self");
  }, A = h ? {
    description: t ? v.t("connect.walletconnect.description.compact") : v.t("connect.walletconnect.description.full"),
    label: v.t("connect.walletconnect.open.label"),
    onClick: () => {
      r(), h();
    }
  } : S ? {
    description: v.t("connect.secondary_action.get.description", {
      wallet: u
    }),
    label: v.t("connect.secondary_action.get.label"),
    onClick: () => e(
      x || C ? "DOWNLOAD_OPTIONS" : "DOWNLOAD"
      /* Download */
    )
  } : null, { width: b } = j5(), T = b && b < 768;
  return Te(() => {
    JJ(), XJ();
  }, []), /* @__PURE__ */ I.createElement(K, { display: "flex", flexDirection: "column", height: "full", width: "full" }, S ? /* @__PURE__ */ I.createElement(
    K,
    {
      alignItems: "center",
      display: "flex",
      height: "full",
      justifyContent: "center"
    },
    /* @__PURE__ */ I.createElement(
      sR,
      {
        logoBackground: l,
        logoSize: t ? 60 : 72,
        logoUrl: c,
        size: t ? 318 : T ? Math.max(280, Math.min(b - 308, 382)) : 382,
        uri: i
      }
    )
  ) : /* @__PURE__ */ I.createElement(
    K,
    {
      alignItems: "center",
      display: "flex",
      justifyContent: "center",
      style: { flexGrow: 1 }
    },
    /* @__PURE__ */ I.createElement(
      K,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        gap: "8"
      },
      /* @__PURE__ */ I.createElement(K, { borderRadius: "10", height: Sg, overflow: "hidden" }, /* @__PURE__ */ I.createElement(
        An,
        {
          useAsImage: !s.isRainbowKitConnector,
          height: Sg,
          src: c,
          width: Sg
        }
      )),
      /* @__PURE__ */ I.createElement(
        K,
        {
          alignItems: "center",
          display: "flex",
          flexDirection: "column",
          gap: "4",
          paddingX: "32",
          style: { textAlign: "center" }
        },
        /* @__PURE__ */ I.createElement(De, { color: "modalText", size: "18", weight: "bold" }, f ? v.t("connect.status.opening", {
          wallet: u
        }) : w ? v.t("connect.status.not_installed", {
          wallet: u
        }) : v.t("connect.status.not_available", {
          wallet: u
        })),
        !f && w ? /* @__PURE__ */ I.createElement(K, { paddingTop: "20" }, /* @__PURE__ */ I.createElement(
          cr,
          {
            href: s.extensionDownloadUrl,
            label: v.t("connect.secondary_action.install.label"),
            type: "secondary"
          }
        )) : null,
        f && !S && /* @__PURE__ */ I.createElement(I.Fragment, null, /* @__PURE__ */ I.createElement(
          K,
          {
            alignItems: "center",
            display: "flex",
            flexDirection: "column",
            justifyContent: "center"
          },
          /* @__PURE__ */ I.createElement(
            De,
            {
              color: "modalTextSecondary",
              size: "14",
              textAlign: "center",
              weight: "medium"
            },
            v.t("connect.status.confirm")
          )
        ), /* @__PURE__ */ I.createElement(
          K,
          {
            alignItems: "center",
            color: "modalText",
            display: "flex",
            flexDirection: "row",
            height: "32",
            marginTop: "8"
          },
          n ? /* @__PURE__ */ I.createElement(
            cr,
            {
              label: v.t("connect.secondary_action.retry.label"),
              onClick: async () => {
                m && k(), o(s);
              }
            }
          ) : /* @__PURE__ */ I.createElement(K, { color: "modalTextSecondary" }, /* @__PURE__ */ I.createElement(ad, null))
        ))
      )
    )
  ), /* @__PURE__ */ I.createElement(
    K,
    {
      alignItems: "center",
      borderRadius: "10",
      display: "flex",
      flexDirection: "row",
      gap: "8",
      height: "28",
      justifyContent: "space-between",
      marginTop: "12"
    },
    f && A && /* @__PURE__ */ I.createElement(I.Fragment, null, /* @__PURE__ */ I.createElement(De, { color: "modalTextSecondary", size: "14", weight: "medium" }, A.description), /* @__PURE__ */ I.createElement(
      cr,
      {
        label: A.label,
        onClick: A.onClick,
        type: "secondary"
      }
    ))
  ));
}
var Ag = ({
  actionLabel: e,
  description: t,
  iconAccent: n,
  iconBackground: r,
  iconUrl: i,
  isCompact: o,
  onAction: s,
  title: a,
  url: l,
  variant: c
}) => {
  const u = c === "browser", d = !u && n && FJ(n);
  return /* @__PURE__ */ I.createElement(
    K,
    {
      alignItems: "center",
      borderRadius: "13",
      display: "flex",
      justifyContent: "center",
      overflow: "hidden",
      paddingX: o ? "18" : "44",
      position: "relative",
      style: { flex: 1, isolation: "isolate" },
      width: "full"
    },
    /* @__PURE__ */ I.createElement(
      K,
      {
        borderColor: "actionButtonBorder",
        borderRadius: "13",
        borderStyle: "solid",
        borderWidth: "1",
        style: {
          bottom: "0",
          left: "0",
          position: "absolute",
          right: "0",
          top: "0",
          zIndex: 1
        }
      }
    ),
    u && /* @__PURE__ */ I.createElement(
      K,
      {
        background: "downloadTopCardBackground",
        height: "full",
        position: "absolute",
        style: {
          zIndex: 0
        },
        width: "full"
      },
      /* @__PURE__ */ I.createElement(
        K,
        {
          display: "flex",
          flexDirection: "row",
          justifyContent: "space-between",
          style: {
            bottom: "0",
            filter: "blur(20px)",
            left: "0",
            position: "absolute",
            right: "0",
            top: "0",
            transform: "translate3d(0, 0, 0)"
          }
        },
        /* @__PURE__ */ I.createElement(
          K,
          {
            style: {
              filter: "blur(100px)",
              marginLeft: -27,
              marginTop: -20,
              opacity: 0.6,
              transform: "translate3d(0, 0, 0)"
            }
          },
          /* @__PURE__ */ I.createElement(
            An,
            {
              borderRadius: "full",
              height: "200",
              src: i,
              width: "200"
            }
          )
        ),
        /* @__PURE__ */ I.createElement(
          K,
          {
            style: {
              filter: "blur(100px)",
              marginRight: 0,
              marginTop: 105,
              opacity: 0.6,
              overflow: "auto",
              transform: "translate3d(0, 0, 0)"
            }
          },
          /* @__PURE__ */ I.createElement(
            An,
            {
              borderRadius: "full",
              height: "200",
              src: i,
              width: "200"
            }
          )
        )
      )
    ),
    !u && d && /* @__PURE__ */ I.createElement(
      K,
      {
        background: "downloadBottomCardBackground",
        style: {
          bottom: "0",
          left: "0",
          position: "absolute",
          right: "0",
          top: "0"
        }
      },
      /* @__PURE__ */ I.createElement(
        K,
        {
          position: "absolute",
          style: {
            background: `radial-gradient(50% 50% at 50% 50%, ${d[0]} 0%, ${d[1]} 25%, rgba(0,0,0,0) 100%)`,
            height: 564,
            left: -215,
            top: -197,
            transform: "translate3d(0, 0, 0)",
            width: 564
          }
        }
      ),
      /* @__PURE__ */ I.createElement(
        K,
        {
          position: "absolute",
          style: {
            background: `radial-gradient(50% 50% at 50% 50%, ${d[2]} 0%, rgba(0, 0, 0, 0) 100%)`,
            height: 564,
            left: -1,
            top: -76,
            transform: "translate3d(0, 0, 0)",
            width: 564
          }
        }
      )
    ),
    /* @__PURE__ */ I.createElement(
      K,
      {
        alignItems: "flex-start",
        display: "flex",
        flexDirection: "row",
        gap: "24",
        height: "max",
        justifyContent: "center",
        style: { zIndex: 1 }
      },
      /* @__PURE__ */ I.createElement(K, null, /* @__PURE__ */ I.createElement(
        An,
        {
          height: "60",
          src: i,
          width: "60",
          ...r ? {
            background: r,
            borderColor: "generalBorder",
            borderRadius: "10"
          } : null
        }
      )),
      /* @__PURE__ */ I.createElement(
        K,
        {
          display: "flex",
          flexDirection: "column",
          gap: "4",
          style: { flex: 1 },
          width: "full"
        },
        /* @__PURE__ */ I.createElement(De, { color: "modalText", size: "14", weight: "bold" }, a),
        /* @__PURE__ */ I.createElement(De, { color: "modalTextSecondary", size: "14", weight: "medium" }, t),
        /* @__PURE__ */ I.createElement(K, { marginTop: "14", width: "max" }, /* @__PURE__ */ I.createElement(
          cr,
          {
            href: l,
            label: e,
            onClick: s,
            size: "medium"
          }
        ))
      )
    )
  );
};
function tX({
  changeWalletStep: e,
  wallet: t
}) {
  const n = o1(), r = a1(), o = we(my) === "compact", {
    desktop: s,
    desktopDownloadUrl: a,
    extension: l,
    extensionDownloadUrl: c,
    mobileDownloadUrl: u
  } = t, { i18n: d } = we(xn);
  return Te(() => {
    nR(), oR(), qJ(), UJ();
  }, []), /* @__PURE__ */ I.createElement(
    K,
    {
      alignItems: "center",
      display: "flex",
      flexDirection: "column",
      gap: "24",
      height: "full",
      marginBottom: "8",
      marginTop: "4",
      width: "full"
    },
    /* @__PURE__ */ I.createElement(
      K,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        gap: "8",
        height: "full",
        justifyContent: "center",
        width: "full"
      },
      c && /* @__PURE__ */ I.createElement(
        Ag,
        {
          actionLabel: d.t("get_options.extension.download.label", {
            browser: n
          }),
          description: d.t("get_options.extension.description"),
          iconUrl: aR,
          isCompact: o,
          onAction: () => e(
            l != null && l.instructions ? "INSTRUCTIONS_EXTENSION" : "CONNECT"
            /* Connect */
          ),
          title: d.t("get_options.extension.title", {
            wallet: t.name,
            browser: n
          }),
          url: c,
          variant: "browser"
        }
      ),
      a && /* @__PURE__ */ I.createElement(
        Ag,
        {
          actionLabel: d.t("get_options.desktop.download.label", {
            platform: r
          }),
          description: d.t("get_options.desktop.description"),
          iconUrl: lR,
          isCompact: o,
          onAction: () => e(
            s != null && s.instructions ? "INSTRUCTIONS_DESKTOP" : "CONNECT"
            /* Connect */
          ),
          title: d.t("get_options.desktop.title", {
            wallet: t.name,
            platform: r
          }),
          url: a,
          variant: "desktop"
        }
      ),
      u && /* @__PURE__ */ I.createElement(
        Ag,
        {
          actionLabel: d.t("get_options.mobile.download.label", {
            wallet: t.name
          }),
          description: d.t("get_options.mobile.description"),
          iconAccent: t.iconAccent,
          iconBackground: t.iconBackground,
          iconUrl: t.iconUrl,
          isCompact: o,
          onAction: () => {
            e(
              "DOWNLOAD"
              /* Download */
            );
          },
          title: d.t("get_options.mobile.title", { wallet: t.name }),
          variant: "app"
        }
      )
    )
  );
}
function nX({
  changeWalletStep: e,
  wallet: t
}) {
  const { downloadUrls: n, qrCode: r } = t, { i18n: i } = we(xn);
  return Te(() => {
    nR(), oR();
  }, []), /* @__PURE__ */ I.createElement(
    K,
    {
      alignItems: "center",
      display: "flex",
      flexDirection: "column",
      gap: "24",
      height: "full",
      width: "full"
    },
    /* @__PURE__ */ I.createElement(K, { style: { maxWidth: 220, textAlign: "center" } }, /* @__PURE__ */ I.createElement(De, { color: "modalTextSecondary", size: "14", weight: "semibold" }, i.t("get_mobile.description"))),
    /* @__PURE__ */ I.createElement(K, { height: "full" }, n != null && n.qrCode ? /* @__PURE__ */ I.createElement(sR, { logoSize: 0, size: 268, uri: n.qrCode }) : null),
    /* @__PURE__ */ I.createElement(
      K,
      {
        alignItems: "center",
        borderRadius: "10",
        display: "flex",
        flexDirection: "row",
        gap: "8",
        height: "34",
        justifyContent: "space-between",
        marginBottom: "12",
        paddingY: "8"
      },
      /* @__PURE__ */ I.createElement(
        cr,
        {
          label: i.t("get_mobile.continue.label"),
          onClick: () => e(
            r != null && r.instructions ? "INSTRUCTIONS_MOBILE" : "CONNECT"
            /* Connect */
          )
        }
      )
    )
  );
}
var ko = {
  connect: () => /* @__PURE__ */ I.createElement(zJ, null),
  create: () => /* @__PURE__ */ I.createElement(VJ, null),
  install: (e) => /* @__PURE__ */ I.createElement(
    An,
    {
      background: e.iconBackground,
      borderColor: "generalBorder",
      borderRadius: "10",
      height: "48",
      src: e.iconUrl,
      width: "48"
    }
  ),
  refresh: () => /* @__PURE__ */ I.createElement($J, null),
  scan: () => /* @__PURE__ */ I.createElement(WJ, null)
};
function rX({
  connectWallet: e,
  wallet: t
}) {
  var r, i, o, s;
  const { i18n: n } = we(xn);
  return /* @__PURE__ */ I.createElement(
    K,
    {
      alignItems: "center",
      display: "flex",
      flexDirection: "column",
      height: "full",
      width: "full"
    },
    /* @__PURE__ */ I.createElement(
      K,
      {
        display: "flex",
        flexDirection: "column",
        gap: "28",
        height: "full",
        justifyContent: "center",
        paddingY: "32",
        style: { maxWidth: 320 }
      },
      (i = (r = t == null ? void 0 : t.qrCode) == null ? void 0 : r.instructions) == null ? void 0 : i.steps.map((a, l) => {
        var c;
        return /* @__PURE__ */ I.createElement(
          K,
          {
            alignItems: "center",
            display: "flex",
            flexDirection: "row",
            gap: "16",
            key: l
          },
          /* @__PURE__ */ I.createElement(
            K,
            {
              borderRadius: "10",
              height: "48",
              minWidth: "48",
              overflow: "hidden",
              position: "relative",
              width: "48"
            },
            (c = ko[a.step]) == null ? void 0 : c.call(ko, t)
          ),
          /* @__PURE__ */ I.createElement(K, { display: "flex", flexDirection: "column", gap: "4" }, /* @__PURE__ */ I.createElement(De, { color: "modalText", size: "14", weight: "bold" }, n.t(a.title, void 0, {
            rawKeyIfTranslationMissing: !0
          })), /* @__PURE__ */ I.createElement(De, { color: "modalTextSecondary", size: "14", weight: "medium" }, n.t(a.description, void 0, {
            rawKeyIfTranslationMissing: !0
          })))
        );
      })
    ),
    /* @__PURE__ */ I.createElement(
      K,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        gap: "12",
        justifyContent: "center",
        marginBottom: "16"
      },
      /* @__PURE__ */ I.createElement(
        cr,
        {
          label: n.t("get_instructions.mobile.connect.label"),
          onClick: () => e(t)
        }
      ),
      /* @__PURE__ */ I.createElement(
        K,
        {
          as: "a",
          className: mn({ active: "shrink", hover: "grow" }),
          display: "block",
          href: (s = (o = t == null ? void 0 : t.qrCode) == null ? void 0 : o.instructions) == null ? void 0 : s.learnMoreUrl,
          paddingX: "12",
          paddingY: "4",
          rel: "noreferrer",
          style: { willChange: "transform" },
          target: "_blank",
          transition: "default"
        },
        /* @__PURE__ */ I.createElement(De, { color: "accentColor", size: "14", weight: "bold" }, n.t("get_instructions.mobile.learn_more.label"))
      )
    )
  );
}
function iX({
  wallet: e
}) {
  var n, r, i, o;
  const { i18n: t } = we(xn);
  return /* @__PURE__ */ I.createElement(
    K,
    {
      alignItems: "center",
      display: "flex",
      flexDirection: "column",
      height: "full",
      width: "full"
    },
    /* @__PURE__ */ I.createElement(
      K,
      {
        display: "flex",
        flexDirection: "column",
        gap: "28",
        height: "full",
        justifyContent: "center",
        paddingY: "32",
        style: { maxWidth: 320 }
      },
      (r = (n = e == null ? void 0 : e.extension) == null ? void 0 : n.instructions) == null ? void 0 : r.steps.map((s, a) => {
        var l;
        return /* @__PURE__ */ I.createElement(
          K,
          {
            alignItems: "center",
            display: "flex",
            flexDirection: "row",
            gap: "16",
            key: a
          },
          /* @__PURE__ */ I.createElement(
            K,
            {
              borderRadius: "10",
              height: "48",
              minWidth: "48",
              overflow: "hidden",
              position: "relative",
              width: "48"
            },
            (l = ko[s.step]) == null ? void 0 : l.call(ko, e)
          ),
          /* @__PURE__ */ I.createElement(K, { display: "flex", flexDirection: "column", gap: "4" }, /* @__PURE__ */ I.createElement(De, { color: "modalText", size: "14", weight: "bold" }, t.t(s.title, void 0, {
            rawKeyIfTranslationMissing: !0
          })), /* @__PURE__ */ I.createElement(De, { color: "modalTextSecondary", size: "14", weight: "medium" }, t.t(s.description, void 0, {
            rawKeyIfTranslationMissing: !0
          })))
        );
      })
    ),
    /* @__PURE__ */ I.createElement(
      K,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        gap: "12",
        justifyContent: "center",
        marginBottom: "16"
      },
      /* @__PURE__ */ I.createElement(
        cr,
        {
          label: t.t("get_instructions.extension.refresh.label"),
          onClick: window.location.reload.bind(window.location)
        }
      ),
      /* @__PURE__ */ I.createElement(
        K,
        {
          as: "a",
          className: mn({ active: "shrink", hover: "grow" }),
          display: "block",
          href: (o = (i = e == null ? void 0 : e.extension) == null ? void 0 : i.instructions) == null ? void 0 : o.learnMoreUrl,
          paddingX: "12",
          paddingY: "4",
          rel: "noreferrer",
          style: { willChange: "transform" },
          target: "_blank",
          transition: "default"
        },
        /* @__PURE__ */ I.createElement(De, { color: "accentColor", size: "14", weight: "bold" }, t.t("get_instructions.extension.learn_more.label"))
      )
    )
  );
}
function oX({
  connectWallet: e,
  wallet: t
}) {
  var r, i, o, s;
  const { i18n: n } = we(xn);
  return /* @__PURE__ */ I.createElement(
    K,
    {
      alignItems: "center",
      display: "flex",
      flexDirection: "column",
      height: "full",
      width: "full"
    },
    /* @__PURE__ */ I.createElement(
      K,
      {
        display: "flex",
        flexDirection: "column",
        gap: "28",
        height: "full",
        justifyContent: "center",
        paddingY: "32",
        style: { maxWidth: 320 }
      },
      (i = (r = t == null ? void 0 : t.desktop) == null ? void 0 : r.instructions) == null ? void 0 : i.steps.map((a, l) => {
        var c;
        return /* @__PURE__ */ I.createElement(
          K,
          {
            alignItems: "center",
            display: "flex",
            flexDirection: "row",
            gap: "16",
            key: l
          },
          /* @__PURE__ */ I.createElement(
            K,
            {
              borderRadius: "10",
              height: "48",
              minWidth: "48",
              overflow: "hidden",
              position: "relative",
              width: "48"
            },
            (c = ko[a.step]) == null ? void 0 : c.call(ko, t)
          ),
          /* @__PURE__ */ I.createElement(K, { display: "flex", flexDirection: "column", gap: "4" }, /* @__PURE__ */ I.createElement(De, { color: "modalText", size: "14", weight: "bold" }, n.t(a.title, void 0, {
            rawKeyIfTranslationMissing: !0
          })), /* @__PURE__ */ I.createElement(De, { color: "modalTextSecondary", size: "14", weight: "medium" }, n.t(a.description, void 0, {
            rawKeyIfTranslationMissing: !0
          })))
        );
      })
    ),
    /* @__PURE__ */ I.createElement(
      K,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        gap: "12",
        justifyContent: "center",
        marginBottom: "16"
      },
      /* @__PURE__ */ I.createElement(
        cr,
        {
          label: n.t("get_instructions.desktop.connect.label"),
          onClick: () => e(t)
        }
      ),
      /* @__PURE__ */ I.createElement(
        K,
        {
          as: "a",
          className: mn({ active: "shrink", hover: "grow" }),
          display: "block",
          href: (s = (o = t == null ? void 0 : t.desktop) == null ? void 0 : o.instructions) == null ? void 0 : s.learnMoreUrl,
          paddingX: "12",
          paddingY: "4",
          rel: "noreferrer",
          style: { willChange: "transform" },
          target: "_blank",
          transition: "default"
        },
        /* @__PURE__ */ I.createElement(De, { color: "accentColor", size: "14", weight: "bold" }, n.t("get_instructions.desktop.learn_more.label"))
      )
    )
  );
}
function sX({ onClose: e }) {
  const t = "rk_connect_title", [n, r] = Oe(), [i, o] = Oe(), [s, a] = Oe(), l = !!(i != null && i.qrCode) && s, [c, u] = Oe(!1), f = we(my) === Jd.COMPACT, { disclaimer: h } = we(Yd), { i18n: p } = we(xn), m = i1(), g = It(!1), { connector: v } = we(Qd), x = gy(!v).filter((se) => se.ready || !!se.extensionDownloadUrl).sort((se, oe) => se.groupIndex - oe.groupIndex), C = RJ(x, (se) => se.groupName), S = [
    "Recommended",
    "Other",
    "Popular",
    "More",
    "Others",
    "Installed"
  ];
  Te(() => {
    v && !g.current && (O(
      "CONNECT"
      /* Connect */
    ), T(v), g.current = !0);
  }, [v]);
  const k = (se) => {
    var oe, ye;
    u(!1), se.ready && ((ye = (oe = se == null ? void 0 : se.connect) == null ? void 0 : oe.call(se)) == null || ye.catch(() => {
      u(!0);
    }));
  }, A = async (se) => {
    const oe = x.find((ye) => se.id === ye.id);
    oe != null && oe.getDesktopUri && setTimeout(async () => {
      var ve;
      const ye = await ((ve = oe == null ? void 0 : oe.getDesktopUri) == null ? void 0 : ve.call(oe));
      ye && window.open(ye, m ? "_blank" : "_self");
    }, 0);
  }, b = async (se) => {
    var ve;
    const oe = x.find((Be) => se.id === Be.id), ye = await ((ve = oe == null ? void 0 : oe.getQrCodeUri) == null ? void 0 : ve.call(oe));
    a(ye), setTimeout(
      () => {
        o(oe), O(
          "CONNECT"
          /* Connect */
        );
      },
      ye ? 0 : 50
    );
  }, T = async (se) => {
    MJ(se.id), se.ready && (b(se), A(se)), k(se), r(se.id), se.ready || (o(se), O(
      se != null && se.extensionDownloadUrl ? "DOWNLOAD_OPTIONS" : "CONNECT"
      /* Connect */
    ));
  }, R = (se) => {
    var it;
    r(se);
    const oe = x.find((lt) => se === lt.id), ye = (it = oe == null ? void 0 : oe.downloadUrls) == null ? void 0 : it.qrCode, ve = !!(oe != null && oe.desktopDownloadUrl), Be = !!(oe != null && oe.extensionDownloadUrl);
    o(oe), O(
      ye && (Be || ve) ? "DOWNLOAD_OPTIONS" : ye ? "DOWNLOAD" : ve ? "INSTRUCTIONS_DESKTOP" : "INSTRUCTIONS_EXTENSION"
      /* DownloadOptions */
    );
  }, B = () => {
    r(void 0), o(void 0), a(void 0);
  }, O = (se, oe = !1) => {
    oe && se === "GET" && L === "GET" ? B() : !oe && se === "GET" ? V(
      "GET"
      /* Get */
    ) : !oe && se === "CONNECT" && V(
      "CONNECT"
      /* Connect */
    ), M(se);
  }, [L, V] = Oe(
    "NONE"
    /* None */
  ), [N, M] = Oe(
    "NONE"
    /* None */
  );
  let U = null, F = null, $ = null, ie;
  Te(() => {
    u(!1);
  }, [N, i]);
  const ae = !!(!!(i != null && i.extensionDownloadUrl) && (i != null && i.mobileDownloadUrl));
  switch (N) {
    case "NONE":
      U = /* @__PURE__ */ I.createElement(QE, { getWallet: () => O(
        "GET"
        /* Get */
      ) });
      break;
    case "LEARN_COMPACT":
      U = /* @__PURE__ */ I.createElement(
        QE,
        {
          compactModeEnabled: f,
          getWallet: () => O(
            "GET"
            /* Get */
          )
        }
      ), F = p.t("intro.title"), $ = "NONE";
      break;
    case "GET":
      U = /* @__PURE__ */ I.createElement(
        ZJ,
        {
          getWalletDownload: R,
          compactModeEnabled: f
        }
      ), F = p.t("get.title"), $ = f ? "LEARN_COMPACT" : "NONE";
      break;
    case "CONNECT":
      U = i && /* @__PURE__ */ I.createElement(
        eX,
        {
          changeWalletStep: O,
          compactModeEnabled: f,
          connectionError: c,
          onClose: e,
          qrCodeUri: s,
          reconnect: k,
          wallet: i
        }
      ), F = l && (i.name === "WalletConnect" ? p.t("connect_scan.fallback_title") : p.t("connect_scan.title", {
        wallet: i.name
      })), $ = f ? v ? null : "NONE" : null, ie = f ? v ? () => {
      } : B : () => {
      };
      break;
    case "DOWNLOAD_OPTIONS":
      U = i && /* @__PURE__ */ I.createElement(
        tX,
        {
          changeWalletStep: O,
          wallet: i
        }
      ), F = i && p.t("get_options.short_title", { wallet: i.name }), $ = v ? "CONNECT" : f ? "NONE" : null;
      break;
    case "DOWNLOAD":
      U = i && /* @__PURE__ */ I.createElement(
        nX,
        {
          changeWalletStep: O,
          wallet: i
        }
      ), F = i && p.t("get_mobile.title", { wallet: i.name }), $ = ae ? "DOWNLOAD_OPTIONS" : L;
      break;
    case "INSTRUCTIONS_MOBILE":
      U = i && /* @__PURE__ */ I.createElement(
        rX,
        {
          connectWallet: T,
          wallet: i
        }
      ), F = i && p.t("get_options.title", {
        wallet: f && i.shortName || i.name
      }), $ = "DOWNLOAD";
      break;
    case "INSTRUCTIONS_EXTENSION":
      U = i && /* @__PURE__ */ I.createElement(iX, { wallet: i }), F = i && p.t("get_options.title", {
        wallet: f && i.shortName || i.name
      }), $ = "DOWNLOAD_OPTIONS";
      break;
    case "INSTRUCTIONS_DESKTOP":
      U = i && /* @__PURE__ */ I.createElement(
        oX,
        {
          connectWallet: T,
          wallet: i
        }
      ), F = i && p.t("get_options.title", {
        wallet: f && i.shortName || i.name
      }), $ = "DOWNLOAD_OPTIONS";
      break;
  }
  return /* @__PURE__ */ I.createElement(
    K,
    {
      display: "flex",
      flexDirection: "row",
      style: { maxHeight: f ? 468 : 504 }
    },
    (f ? N === "NONE" : !0) && /* @__PURE__ */ I.createElement(
      K,
      {
        className: f ? YJ : KJ,
        display: "flex",
        flexDirection: "column",
        marginTop: "16"
      },
      /* @__PURE__ */ I.createElement(K, { display: "flex", justifyContent: "space-between" }, f && h && /* @__PURE__ */ I.createElement(K, { marginLeft: "16", width: "28" }, /* @__PURE__ */ I.createElement(
        OJ,
        {
          onClick: () => O(
            "LEARN_COMPACT"
            /* LearnCompact */
          )
        }
      )), f && !h && /* @__PURE__ */ I.createElement(K, { marginLeft: "16", width: "28" }), /* @__PURE__ */ I.createElement(
        K,
        {
          marginLeft: f ? "0" : "6",
          paddingBottom: "8",
          paddingTop: "2",
          paddingX: "18"
        },
        /* @__PURE__ */ I.createElement(
          De,
          {
            as: "h1",
            color: "modalText",
            id: t,
            size: "18",
            weight: "heavy",
            testId: "connect-header-label"
          },
          p.t("connect.title")
        )
      ), f && /* @__PURE__ */ I.createElement(K, { marginRight: "16" }, /* @__PURE__ */ I.createElement(Oa, { onClose: e }))),
      /* @__PURE__ */ I.createElement(K, { className: HJ, paddingBottom: "18" }, Object.entries(C).map(
        ([se, oe], ye) => oe.length > 0 && /* @__PURE__ */ I.createElement(Tc, { key: ye }, se ? /* @__PURE__ */ I.createElement(K, { marginBottom: "8", marginTop: "16", marginX: "6" }, /* @__PURE__ */ I.createElement(
          De,
          {
            color: se === "Installed" ? "accentColor" : "modalTextSecondary",
            size: "14",
            weight: "bold"
          },
          S.includes(se) ? p.t(
            `connector_group.${se.toLowerCase()}`
          ) : se
        )) : null, /* @__PURE__ */ I.createElement(K, { display: "flex", flexDirection: "column", gap: "4" }, oe.map((ve) => /* @__PURE__ */ I.createElement(
          Z5,
          {
            currentlySelected: ve.id === n,
            iconBackground: ve.iconBackground,
            iconUrl: ve.iconUrl,
            key: ve.id,
            name: ve.name,
            onClick: () => T(ve),
            ready: ve.ready,
            recent: ve.recent,
            testId: `wallet-option-${ve.id}`,
            isRainbowKitConnector: ve.isRainbowKitConnector
          }
        ))))
      )),
      f && /* @__PURE__ */ I.createElement(I.Fragment, null, /* @__PURE__ */ I.createElement(K, { background: "generalBorder", height: "1", marginTop: "-1" }), h ? /* @__PURE__ */ I.createElement(K, { paddingX: "24", paddingY: "16", textAlign: "center" }, /* @__PURE__ */ I.createElement(h, { Link: l1, Text: c1 })) : /* @__PURE__ */ I.createElement(
        K,
        {
          alignItems: "center",
          display: "flex",
          justifyContent: "space-between",
          paddingX: "24",
          paddingY: "16"
        },
        /* @__PURE__ */ I.createElement(K, { paddingY: "4" }, /* @__PURE__ */ I.createElement(De, { color: "modalTextSecondary", size: "14", weight: "medium" }, p.t("connect.new_to_ethereum.description"))),
        /* @__PURE__ */ I.createElement(
          K,
          {
            alignItems: "center",
            display: "flex",
            flexDirection: "row",
            gap: "4",
            justifyContent: "center"
          },
          /* @__PURE__ */ I.createElement(
            K,
            {
              className: mn({
                active: "shrink",
                hover: "grow"
              }),
              cursor: "pointer",
              onClick: () => O(
                "LEARN_COMPACT"
                /* LearnCompact */
              ),
              paddingY: "4",
              style: { willChange: "transform" },
              transition: "default"
            },
            /* @__PURE__ */ I.createElement(De, { color: "accentColor", size: "14", weight: "bold" }, p.t("connect.new_to_ethereum.learn_more.label"))
          )
        )
      ))
    ),
    (f ? N !== "NONE" : !0) && /* @__PURE__ */ I.createElement(I.Fragment, null, !f && /* @__PURE__ */ I.createElement(K, { background: "generalBorder", minWidth: "1", width: "1" }), /* @__PURE__ */ I.createElement(
      K,
      {
        display: "flex",
        flexDirection: "column",
        margin: "16",
        style: { flexGrow: 1 }
      },
      /* @__PURE__ */ I.createElement(
        K,
        {
          alignItems: "center",
          display: "flex",
          justifyContent: "space-between",
          marginBottom: "12"
        },
        /* @__PURE__ */ I.createElement(K, { width: "28" }, $ && /* @__PURE__ */ I.createElement(
          K,
          {
            as: "button",
            className: mn({
              active: "shrinkSm",
              hover: "growLg"
            }),
            color: "accentColor",
            onClick: () => {
              $ && O($, !0), ie == null || ie();
            },
            paddingX: "8",
            paddingY: "4",
            style: {
              boxSizing: "content-box",
              height: 17,
              willChange: "transform"
            },
            transition: "default",
            type: "button"
          },
          /* @__PURE__ */ I.createElement(J5, null)
        )),
        /* @__PURE__ */ I.createElement(
          K,
          {
            display: "flex",
            justifyContent: "center",
            style: { flexGrow: 1 }
          },
          F && /* @__PURE__ */ I.createElement(
            De,
            {
              color: "modalText",
              size: "18",
              textAlign: "center",
              weight: "heavy"
            },
            F
          )
        ),
        /* @__PURE__ */ I.createElement(Oa, { onClose: e })
      ),
      /* @__PURE__ */ I.createElement(
        K,
        {
          display: "flex",
          flexDirection: "column",
          style: { minHeight: f ? 396 : 432 }
        },
        /* @__PURE__ */ I.createElement(
          K,
          {
            alignItems: "center",
            display: "flex",
            flexDirection: "column",
            gap: "6",
            height: "full",
            justifyContent: "center",
            marginX: "8"
          },
          U
        )
      )
    ))
  );
}
var aX = "_1fcvq812", lX = "_1fcvq810", cX = "_1fcvq813", uX = ({ wallet: e }) => /* @__PURE__ */ I.createElement("svg", { className: cX, viewBox: "0 0 86 86", width: "86", height: "86" }, /* @__PURE__ */ I.createElement("title", null, "Loading"), /* @__PURE__ */ I.createElement(
  "rect",
  {
    x: "3",
    y: "3",
    width: 80,
    height: 80,
    rx: 20,
    ry: 20,
    strokeDasharray: `${160 / 3} ${2 * 160 / 3}`,
    strokeDashoffset: 160,
    className: aX,
    style: {
      // Prop style passing works only in `@vanilla-extract/recipes`.
      // Instead downloading packages we can do this
      // manually without passing props
      stroke: (e == null ? void 0 : e.iconAccent) || "#0D3887"
    }
  }
));
function cR({
  onClose: e,
  wallet: t,
  connecting: n
}) {
  const {
    connect: r,
    iconBackground: i,
    iconUrl: o,
    id: s,
    name: a,
    getMobileUri: l,
    ready: c,
    shortName: u,
    showWalletConnectModal: d
  } = t, f = X5(o), h = It(!1), { i18n: p } = we(xn), m = Ie(async () => {
    if (s !== "walletConnect" && (async () => {
      const v = await (l == null ? void 0 : l());
      if (v)
        if (v && HQ({ mobileUri: v, name: a }), v.startsWith("http")) {
          const w = document.createElement("a");
          w.href = v, w.target = "_blank", w.rel = "noreferrer noopener", w.click();
        } else
          window.location.href = v;
    })(), d) {
      d(), e == null || e();
      return;
    }
    r == null || r();
  }, [r, l, d, e, a, s]);
  return Te(() => {
    n && !h.current && (m(), h.current = !0);
  }, [n, m]), /* @__PURE__ */ I.createElement(
    K,
    {
      as: "button",
      color: c ? "modalText" : "modalTextSecondary",
      disabled: !c,
      fontFamily: "body",
      key: s,
      onClick: m,
      ref: f,
      style: { overflow: "visible", textAlign: "center" },
      testId: `wallet-option-${s}`,
      type: "button",
      width: "full"
    },
    /* @__PURE__ */ I.createElement(
      K,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        justifyContent: "center"
      },
      /* @__PURE__ */ I.createElement(
        K,
        {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          paddingBottom: "8",
          paddingTop: "10",
          position: "relative"
        },
        n ? /* @__PURE__ */ I.createElement(uX, { wallet: t }) : null,
        /* @__PURE__ */ I.createElement(
          An,
          {
            background: i,
            borderRadius: "13",
            boxShadow: "walletLogo",
            height: "60",
            src: o,
            width: "60"
          }
        )
      ),
      n ? null : /* @__PURE__ */ I.createElement(K, { display: "flex", flexDirection: "column", textAlign: "center" }, /* @__PURE__ */ I.createElement(
        De,
        {
          as: "h2",
          color: t.ready ? "modalText" : "modalTextSecondary",
          size: "13",
          weight: "medium"
        },
        /* @__PURE__ */ I.createElement(K, { as: "span", position: "relative" }, u ?? a, !t.ready && " (unsupported)")
      ), t.recent && /* @__PURE__ */ I.createElement(De, { color: "accentColor", size: "12", weight: "medium" }, p.t("connect.recent")))
    )
  );
}
function dX({ onClose: e }) {
  var h;
  const t = "rk_connect_title", n = gy().filter(
    (p) => p.isRainbowKitConnector
  ), { disclaimer: r, learnMoreUrl: i } = we(Yd);
  let o = null, s = null, a = !1, l = null;
  const [c, u] = Oe(
    "CONNECT"
    /* Connect */
  ), { i18n: d } = we(xn), f = yy();
  switch (c) {
    case "CONNECT": {
      o = d.t("connect.title"), a = !0, s = /* @__PURE__ */ I.createElement(K, null, /* @__PURE__ */ I.createElement(
        K,
        {
          background: "profileForeground",
          className: lX,
          display: "flex",
          paddingBottom: "20",
          paddingTop: "6"
        },
        /* @__PURE__ */ I.createElement(K, { display: "flex", style: { margin: "0 auto" } }, n.filter((p) => p.ready).map((p) => /* @__PURE__ */ I.createElement(K, { key: p.id, paddingX: "20" }, /* @__PURE__ */ I.createElement(K, { width: "60" }, /* @__PURE__ */ I.createElement(cR, { onClose: e, wallet: p })))))
      ), /* @__PURE__ */ I.createElement(
        K,
        {
          background: "generalBorder",
          height: "1",
          marginBottom: "32",
          marginTop: "-1"
        }
      ), /* @__PURE__ */ I.createElement(
        K,
        {
          alignItems: "center",
          display: "flex",
          flexDirection: "column",
          gap: "32",
          paddingX: "32",
          style: { textAlign: "center" }
        },
        /* @__PURE__ */ I.createElement(
          K,
          {
            display: "flex",
            flexDirection: "column",
            gap: "8",
            textAlign: "center"
          },
          /* @__PURE__ */ I.createElement(De, { color: "modalText", size: "16", weight: "bold" }, d.t("intro.title")),
          /* @__PURE__ */ I.createElement(De, { color: "modalTextSecondary", size: "16" }, d.t("intro.description"))
        )
      ), /* @__PURE__ */ I.createElement(K, { paddingTop: "32", paddingX: "20" }, /* @__PURE__ */ I.createElement(K, { display: "flex", gap: "14", justifyContent: "center" }, /* @__PURE__ */ I.createElement(
        cr,
        {
          label: d.t("intro.get.label"),
          onClick: () => u(
            "GET"
            /* Get */
          ),
          size: "large",
          type: "secondary"
        }
      ), /* @__PURE__ */ I.createElement(
        cr,
        {
          href: i,
          label: d.t("intro.learn_more.label"),
          size: "large",
          type: "secondary"
        }
      ))), r && /* @__PURE__ */ I.createElement(K, { marginTop: "28", marginX: "32", textAlign: "center" }, /* @__PURE__ */ I.createElement(r, { Link: l1, Text: c1 })));
      break;
    }
    case "GET": {
      o = d.t("get.title"), l = "CONNECT";
      const p = (h = n == null ? void 0 : n.filter(
        (m) => {
          var g, v, w;
          return ((g = m.downloadUrls) == null ? void 0 : g.ios) || ((v = m.downloadUrls) == null ? void 0 : v.android) || ((w = m.downloadUrls) == null ? void 0 : w.mobile);
        }
      )) == null ? void 0 : h.splice(0, 3);
      s = /* @__PURE__ */ I.createElement(K, null, /* @__PURE__ */ I.createElement(
        K,
        {
          alignItems: "center",
          display: "flex",
          flexDirection: "column",
          height: "full",
          marginBottom: "36",
          marginTop: "5",
          paddingTop: "12",
          width: "full"
        },
        p.map((m, g) => {
          const { downloadUrls: v, iconBackground: w, iconUrl: x, name: C } = m;
          return !(v != null && v.ios) && !(v != null && v.android) && !(v != null && v.mobile) ? null : /* @__PURE__ */ I.createElement(
            K,
            {
              display: "flex",
              gap: "16",
              key: m.id,
              paddingX: "20",
              width: "full"
            },
            /* @__PURE__ */ I.createElement(K, { style: { minHeight: 48, minWidth: 48 } }, /* @__PURE__ */ I.createElement(
              An,
              {
                background: w,
                borderColor: "generalBorder",
                borderRadius: "10",
                height: "48",
                src: x,
                width: "48"
              }
            )),
            /* @__PURE__ */ I.createElement(K, { display: "flex", flexDirection: "column", width: "full" }, /* @__PURE__ */ I.createElement(K, { alignItems: "center", display: "flex", height: "48" }, /* @__PURE__ */ I.createElement(K, { width: "full" }, /* @__PURE__ */ I.createElement(De, { color: "modalText", size: "18", weight: "bold" }, C)), /* @__PURE__ */ I.createElement(
              cr,
              {
                href: (f ? v == null ? void 0 : v.ios : v == null ? void 0 : v.android) || (v == null ? void 0 : v.mobile),
                label: d.t("get.action.label"),
                size: "small",
                type: "secondary"
              }
            )), g < p.length - 1 && /* @__PURE__ */ I.createElement(
              K,
              {
                background: "generalBorderDim",
                height: "1",
                marginY: "10",
                width: "full"
              }
            ))
          );
        })
      ), /* @__PURE__ */ I.createElement(K, { style: { marginBottom: "42px" } }), /* @__PURE__ */ I.createElement(
        K,
        {
          alignItems: "center",
          display: "flex",
          flexDirection: "column",
          gap: "36",
          paddingX: "36",
          style: { textAlign: "center" }
        },
        /* @__PURE__ */ I.createElement(
          K,
          {
            display: "flex",
            flexDirection: "column",
            gap: "12",
            textAlign: "center"
          },
          /* @__PURE__ */ I.createElement(De, { color: "modalText", size: "16", weight: "bold" }, d.t("get.looking_for.title")),
          /* @__PURE__ */ I.createElement(De, { color: "modalTextSecondary", size: "16" }, d.t("get.looking_for.mobile.description"))
        )
      ));
      break;
    }
  }
  return /* @__PURE__ */ I.createElement(K, { display: "flex", flexDirection: "column", paddingBottom: "36" }, /* @__PURE__ */ I.createElement(
    K,
    {
      background: a ? "profileForeground" : "modalBackground",
      display: "flex",
      flexDirection: "column",
      paddingBottom: "4",
      paddingTop: "14"
    },
    /* @__PURE__ */ I.createElement(
      K,
      {
        display: "flex",
        justifyContent: "center",
        paddingBottom: "6",
        paddingX: "20",
        position: "relative"
      },
      l && /* @__PURE__ */ I.createElement(
        K,
        {
          display: "flex",
          position: "absolute",
          style: {
            left: 0,
            marginBottom: -20,
            marginTop: -20
          }
        },
        /* @__PURE__ */ I.createElement(
          K,
          {
            alignItems: "center",
            as: "button",
            className: mn({
              active: "shrinkSm",
              hover: "growLg"
            }),
            color: "accentColor",
            display: "flex",
            marginLeft: "4",
            marginTop: "20",
            onClick: () => u(l),
            padding: "16",
            style: { height: 17, willChange: "transform" },
            transition: "default",
            type: "button"
          },
          /* @__PURE__ */ I.createElement(J5, null)
        )
      ),
      /* @__PURE__ */ I.createElement(K, { marginTop: "4", textAlign: "center", width: "full" }, /* @__PURE__ */ I.createElement(
        De,
        {
          as: "h1",
          color: "modalText",
          id: t,
          size: "20",
          weight: "bold"
        },
        o
      )),
      /* @__PURE__ */ I.createElement(
        K,
        {
          alignItems: "center",
          display: "flex",
          height: "32",
          paddingRight: "14",
          position: "absolute",
          right: "0"
        },
        /* @__PURE__ */ I.createElement(
          K,
          {
            style: { marginBottom: -20, marginTop: -20 }
          },
          /* @__PURE__ */ I.createElement(Oa, { onClose: e })
        )
      )
    )
  ), /* @__PURE__ */ I.createElement(K, { display: "flex", flexDirection: "column" }, s));
}
var fX = ({ onClose: e }) => {
  const { connector: t } = we(Qd), { i18n: n } = we(xn), r = (t == null ? void 0 : t.name) || "";
  return /* @__PURE__ */ I.createElement(K, null, /* @__PURE__ */ I.createElement(
    K,
    {
      display: "flex",
      paddingBottom: "32",
      justifyContent: "center",
      alignItems: "center",
      background: "profileForeground",
      flexDirection: "column"
    },
    /* @__PURE__ */ I.createElement(
      K,
      {
        width: "full",
        display: "flex",
        justifyContent: "flex-end",
        marginTop: "18",
        marginRight: "24"
      },
      /* @__PURE__ */ I.createElement(Oa, { onClose: e })
    ),
    /* @__PURE__ */ I.createElement(K, { width: "60" }, /* @__PURE__ */ I.createElement(cR, { onClose: e, wallet: t, connecting: !0 })),
    /* @__PURE__ */ I.createElement(K, { marginTop: "20" }, /* @__PURE__ */ I.createElement(
      De,
      {
        textAlign: "center",
        color: "modalText",
        size: "18",
        weight: "semibold"
      },
      n.t("connect.status.connect_mobile", {
        wallet: r
      })
    )),
    /* @__PURE__ */ I.createElement(K, { maxWidth: "full", marginTop: "8" }, /* @__PURE__ */ I.createElement(De, { textAlign: "center", color: "modalText", size: "16", weight: "medium" }, n.t("connect.status.confirm_mobile", {
      wallet: r
    })))
  ));
};
function hX({ onClose: e }) {
  const { connector: t } = we(Qd);
  return zn() ? t ? /* @__PURE__ */ I.createElement(fX, { onClose: e }) : /* @__PURE__ */ I.createElement(dX, { onClose: e }) : /* @__PURE__ */ I.createElement(sX, { onClose: e });
}
function pX({ onClose: e, open: t, dialogRoot: n }) {
  const r = "rk_connect_title", i = Zw(), { disconnect: o } = oy(), { isConnecting: s } = ur(), a = I.useCallback(() => {
    e(), o();
  }, [e, o]), l = I.useCallback(() => {
    s && o(), e();
  }, [e, o, s]);
  return i === "disconnected" ? /* @__PURE__ */ I.createElement(
    ep,
    {
      dialogRoot: n,
      onClose: l,
      open: t,
      titleId: r
    },
    /* @__PURE__ */ I.createElement(tp, { bottomSheetOnMobile: !0, padding: "0", wide: !0 }, /* @__PURE__ */ I.createElement(hX, { onClose: l }))
  ) : i === "unauthenticated" ? /* @__PURE__ */ I.createElement(
    ep,
    {
      dialogRoot: n,
      onClose: a,
      open: t,
      titleId: r
    },
    /* @__PURE__ */ I.createElement(tp, { bottomSheetOnMobile: !0, padding: "0" }, /* @__PURE__ */ I.createElement(WQ, { onClose: a, onCloseModal: e }))
  ) : null;
}
function Tg() {
  const [e, t] = Oe(!1);
  return {
    closeModal: Ie(() => t(!1), []),
    isModalOpen: e,
    openModal: Ie(() => t(!0), [])
  };
}
var Lc = Ge({
  accountModalOpen: !1,
  chainModalOpen: !1,
  connectModalOpen: !1,
  closeAccountModal: () => {
  },
  closeChainModal: () => {
  },
  closeConnectModal: () => {
  },
  isWalletConnectModalOpen: !1,
  setIsWalletConnectModalOpen: () => {
  }
});
function yX({
  children: e,
  dialogRoot: t,
  hideDisconnect: n
}) {
  const {
    closeModal: r,
    isModalOpen: i,
    openModal: o
  } = Tg(), {
    closeModal: s,
    isModalOpen: a,
    openModal: l
  } = Tg(), {
    closeModal: c,
    isModalOpen: u,
    openModal: d
  } = Tg(), [f, h] = Oe(!1), p = Zw(), { chainId: m } = ur(), { chains: g } = Dn(), v = g.some((C) => C.id === m);
  function w({
    keepConnectModalOpen: C = !1
  } = {}) {
    C || r(), s(), c();
  }
  const x = py() === "unauthenticated";
  return wI({
    onConnect: () => w({ keepConnectModalOpen: x }),
    onDisconnect: () => w()
  }), Te(() => {
    x && w();
  }, [x]), /* @__PURE__ */ I.createElement(
    Lc.Provider,
    {
      value: J(
        () => ({
          accountModalOpen: a,
          chainModalOpen: u,
          connectModalOpen: i,
          closeConnectModal: r,
          closeAccountModal: s,
          closeChainModal: c,
          isWalletConnectModalOpen: f,
          openAccountModal: v && p === "connected" ? l : void 0,
          openChainModal: p === "connected" ? d : void 0,
          openConnectModal: p === "disconnected" || p === "unauthenticated" ? o : void 0,
          setIsWalletConnectModalOpen: h
        }),
        [
          p,
          a,
          u,
          i,
          l,
          d,
          o,
          r,
          s,
          c,
          v,
          f
        ]
      )
    },
    e,
    /* @__PURE__ */ I.createElement(
      pX,
      {
        dialogRoot: t,
        onClose: r,
        open: i
      }
    ),
    /* @__PURE__ */ I.createElement(
      kJ,
      {
        dialogRoot: t,
        onClose: s,
        open: a,
        hideDisconnect: n
      }
    ),
    /* @__PURE__ */ I.createElement(
      IJ,
      {
        dialogRoot: t,
        onClose: c,
        open: u
      }
    )
  );
}
function mX() {
  const { accountModalOpen: e, chainModalOpen: t, connectModalOpen: n } = we(Lc);
  return {
    accountModalOpen: e,
    chainModalOpen: t,
    connectModalOpen: n
  };
}
function gX() {
  const { accountModalOpen: e, openAccountModal: t, closeAccountModal: n } = we(Lc);
  return { accountModalOpen: e, openAccountModal: t, closeAccountModal: n };
}
function uR() {
  const { chainModalOpen: e, openChainModal: t, closeChainModal: n } = we(Lc);
  return { chainModalOpen: e, openChainModal: t, closeChainModal: n };
}
function dR() {
  const { isWalletConnectModalOpen: e, setIsWalletConnectModalOpen: t } = we(Lc);
  return { isWalletConnectModalOpen: e, setIsWalletConnectModalOpen: t };
}
function by() {
  const { connectModalOpen: e, openConnectModal: t, closeConnectModal: n } = we(Lc), { isWalletConnectModalOpen: r } = dR();
  return {
    connectModalOpen: e || r,
    openConnectModal: t,
    closeConnectModal: n
  };
}
var _g = () => {
};
function u1({
  children: e
}) {
  const t = cQ(), { address: n } = ur(), { chainId: r } = ur(), { chains: i } = Dn(), o = i.some(
    (A) => A.id === r
  ), s = sQ(), a = py() ?? void 0, l = r ? s[r] : void 0, c = (l == null ? void 0 : l.name) ?? void 0, u = (l == null ? void 0 : l.iconUrl) ?? void 0, d = (l == null ? void 0 : l.iconBackground) ?? void 0, f = e1(u), h = we(r1), p = B5().some(({ status: A }) => A === "pending") && h, { ensAvatar: m, ensName: g } = I5({
    address: n
  }), { openConnectModal: v } = by(), { openChainModal: w } = uR(), { openAccountModal: x } = gX(), { accountModalOpen: C, chainModalOpen: S, connectModalOpen: k } = mX();
  return /* @__PURE__ */ I.createElement(I.Fragment, null, e({
    account: n ? {
      address: n,
      displayName: g ? H5(g) : G5(n),
      ensAvatar: m ?? void 0,
      ensName: g ?? void 0,
      hasPendingTransactions: p
    } : void 0,
    accountModalOpen: C,
    authenticationStatus: a,
    chain: r ? {
      hasIcon: !!u,
      iconBackground: d,
      iconUrl: f,
      id: r,
      name: c,
      unsupported: !o
    } : void 0,
    chainModalOpen: S,
    connectModalOpen: k,
    mounted: t(),
    openAccountModal: x ?? _g,
    openChainModal: w ?? _g,
    openConnectModal: v ?? _g
  }));
}
u1.displayName = "ConnectButton.Custom";
var wu = {
  accountStatus: "full",
  chainStatus: { largeScreen: "full", smallScreen: "icon" },
  label: "Connect Wallet",
  showBalance: { largeScreen: !0, smallScreen: !1 }
};
function Xd({
  accountStatus: e = wu.accountStatus,
  chainStatus: t = wu.chainStatus,
  label: n = wu.label,
  showBalance: r = wu.showBalance
}) {
  const i = Va(), o = Zw(), { setShowBalance: s } = lQ(), [a, l] = Oe(!1), { i18n: c } = we(xn);
  return Te(() => {
    s(r), a || l(!0);
  }, [r, s]), a ? /* @__PURE__ */ I.createElement(u1, null, ({
    account: u,
    chain: d,
    mounted: f,
    openAccountModal: h,
    openChainModal: p,
    openConnectModal: m
  }) => {
    const g = f && o !== "loading", v = (d == null ? void 0 : d.unsupported) ?? !1;
    return /* @__PURE__ */ I.createElement(
      K,
      {
        display: "flex",
        gap: "12",
        ...!g && {
          "aria-hidden": !0,
          style: {
            opacity: 0,
            pointerEvents: "none",
            userSelect: "none"
          }
        }
      },
      g && u && o === "connected" ? /* @__PURE__ */ I.createElement(I.Fragment, null, d && (i.length > 1 || v) && /* @__PURE__ */ I.createElement(
        K,
        {
          alignItems: "center",
          "aria-label": "Chain Selector",
          as: "button",
          background: v ? "connectButtonBackgroundError" : "connectButtonBackground",
          borderRadius: "connectButton",
          boxShadow: "connectButton",
          className: mn({
            active: "shrink",
            hover: "grow"
          }),
          color: v ? "connectButtonTextError" : "connectButtonText",
          display: nl(
            t,
            (w) => w === "none" ? "none" : "flex"
          ),
          fontFamily: "body",
          fontWeight: "bold",
          gap: "6",
          key: (
            // Force re-mount to prevent CSS transition
            v ? "unsupported" : "supported"
          ),
          onClick: p,
          paddingX: "10",
          paddingY: "8",
          testId: v ? "wrong-network-button" : "chain-button",
          transition: "default",
          type: "button"
        },
        v ? /* @__PURE__ */ I.createElement(
          K,
          {
            alignItems: "center",
            display: "flex",
            height: "24",
            paddingX: "4"
          },
          c.t("connect_wallet.wrong_network.label")
        ) : /* @__PURE__ */ I.createElement(K, { alignItems: "center", display: "flex", gap: "6" }, d.hasIcon ? /* @__PURE__ */ I.createElement(
          K,
          {
            display: nl(
              t,
              (w) => w === "full" || w === "icon" ? "block" : "none"
            ),
            height: "24",
            width: "24"
          },
          /* @__PURE__ */ I.createElement(
            An,
            {
              alt: d.name ?? "Chain icon",
              background: d.iconBackground,
              borderRadius: "full",
              height: "24",
              src: d.iconUrl,
              width: "24"
            }
          )
        ) : null, /* @__PURE__ */ I.createElement(
          K,
          {
            display: nl(t, (w) => w === "icon" && !d.iconUrl || w === "full" || w === "name" ? "block" : "none")
          },
          d.name ?? d.id
        )),
        /* @__PURE__ */ I.createElement(IE, null)
      ), !v && /* @__PURE__ */ I.createElement(
        K,
        {
          alignItems: "center",
          as: "button",
          background: "connectButtonBackground",
          borderRadius: "connectButton",
          boxShadow: "connectButton",
          className: mn({
            active: "shrink",
            hover: "grow"
          }),
          color: "connectButtonText",
          display: "flex",
          fontFamily: "body",
          fontWeight: "bold",
          onClick: h,
          testId: "account-button",
          transition: "default",
          type: "button"
        },
        u.displayBalance && /* @__PURE__ */ I.createElement(
          K,
          {
            display: nl(
              r,
              (w) => w ? "block" : "none"
            ),
            padding: "8",
            paddingLeft: "12"
          },
          u.displayBalance
        ),
        /* @__PURE__ */ I.createElement(
          K,
          {
            background: RY(r)[zn() ? "smallScreen" : "largeScreen"] ? "connectButtonInnerBackground" : "connectButtonBackground",
            borderColor: "connectButtonBackground",
            borderRadius: "connectButton",
            borderStyle: "solid",
            borderWidth: "2",
            color: "connectButtonText",
            fontFamily: "body",
            fontWeight: "bold",
            paddingX: "8",
            paddingY: "6",
            transition: "default"
          },
          /* @__PURE__ */ I.createElement(
            K,
            {
              alignItems: "center",
              display: "flex",
              gap: "6",
              height: "24"
            },
            /* @__PURE__ */ I.createElement(
              K,
              {
                display: nl(
                  e,
                  (w) => w === "full" || w === "avatar" ? "block" : "none"
                )
              },
              /* @__PURE__ */ I.createElement(
                S5,
                {
                  address: u.address,
                  imageUrl: u.ensAvatar,
                  loading: u.hasPendingTransactions,
                  size: 24
                }
              )
            ),
            /* @__PURE__ */ I.createElement(K, { alignItems: "center", display: "flex", gap: "6" }, /* @__PURE__ */ I.createElement(
              K,
              {
                display: nl(
                  e,
                  (w) => w === "full" || w === "address" ? "block" : "none"
                )
              },
              u.displayName
            ), /* @__PURE__ */ I.createElement(IE, null))
          )
        )
      )) : /* @__PURE__ */ I.createElement(
        K,
        {
          as: "button",
          background: "accentColor",
          borderRadius: "connectButton",
          boxShadow: "connectButton",
          className: mn({
            active: "shrink",
            hover: "grow"
          }),
          color: "accentColorForeground",
          fontFamily: "body",
          fontWeight: "bold",
          height: "40",
          key: "connect",
          onClick: m,
          paddingX: "14",
          testId: "connect-button",
          transition: "default",
          type: "button"
        },
        f && n === "Connect Wallet" ? c.t("connect_wallet.label") : n
      )
    );
  }) : /* @__PURE__ */ I.createElement(I.Fragment, null);
}
Xd.__defaultProps = wu;
Xd.Custom = u1;
var vX = ({
  appName: e,
  appDescription: t,
  appUrl: n,
  appIcon: r
}) => ({
  name: e,
  description: t ?? e,
  url: n ?? (typeof window < "u" ? window.location.href : ""),
  icons: [...r ? [r] : []]
});
function bX(e) {
  return Object.fromEntries(
    //@ts-ignore
    Object.entries(e).filter(([t, n]) => n !== void 0)
  );
}
function wX(e, t) {
  const n = [];
  for (const r of e)
    n.some((i) => i[t] === r[t]) || n.push(r);
  return n;
}
var xX = (e, {
  projectId: t,
  walletConnectParameters: n,
  appName: r,
  appDescription: i,
  appUrl: o,
  appIcon: s
}) => {
  if (!e.length)
    throw new Error("No wallet list was provided");
  for (const { wallets: h, groupName: p } of e)
    if (!h.length)
      throw new Error(`No wallets provided for group: ${p}`);
  let a = -1;
  const l = [], c = [], u = [], d = vX({
    appName: r,
    appDescription: i,
    appUrl: o,
    appIcon: s
  });
  e.forEach(({ groupName: h, wallets: p }, m) => {
    p.forEach((g) => {
      a++;
      const v = g({
        projectId: t,
        appName: r,
        appIcon: s,
        // `option` is being used only for `walletConnectWallet` wallet
        options: {
          metadata: d,
          ...n
        },
        // Every other wallet that supports walletConnect flow and is not
        // `walletConnectWallet` wallet will have `walletConnectParameters` property
        walletConnectParameters: {
          metadata: d,
          ...n
        }
      });
      if (v != null && v.iconAccent && !LJ(v == null ? void 0 : v.iconAccent))
        throw new Error(
          `Property \`iconAccent\` is not a hex value for wallet: ${v.name}`
        );
      const w = {
        ...v,
        groupIndex: m + 1,
        groupName: h,
        index: a
      };
      typeof v.hidden == "function" ? u.push(w) : c.push(w);
    });
  });
  const f = wX(
    [...c, ...u],
    "id"
  );
  for (const {
    createConnector: h,
    groupIndex: p,
    groupName: m,
    hidden: g,
    ...v
  } of f) {
    if (typeof g == "function" && g())
      continue;
    const w = (S) => ({
      rkDetails: bX({
        ...v,
        groupIndex: p,
        groupName: m,
        isRainbowKitConnector: !0,
        // These additional params will be used in rainbowkit react tree to
        // merge `walletConnectWallet` and `walletConnect` connector from wagmi with
        // showQrModal: true. This way we can let the user choose if they want to
        // connect via QR code or open the official walletConnect modal instead
        ...S || {}
      })
    });
    v.id === "walletConnect" && l.push(
      h(
        w({
          isWalletConnectModalConnector: !0,
          showQrModal: !0
        })
      )
    );
    const C = h(w());
    l.push(C);
  }
  return l;
};
const Bo = Tn.map(
  () => js
).orDefault(Te), CX = () => Tn.map((e) => {
  const t = e.matchMedia("(prefers-color-scheme: dark)"), n = e.matchMedia("(prefers-color-scheme: light)");
  return t.matches ? "dark" : n.matches ? "light" : "no-preference";
}).orDefault("no-preference"), kX = () => {
  const [e, t] = Oe(() => ({ force: !1, theme: CX() }));
  return Bo(() => {
    if (e.force) return;
    const n = Tn.extractNullable();
    if (!n) return;
    const r = n.matchMedia("(prefers-color-scheme: dark)"), i = n.matchMedia("(prefers-color-scheme: light)");
    if (typeof i.addEventListener != "function") return;
    const o = ({ matches: a }) => {
      a && t({ theme: "dark", force: !1 });
    }, s = ({ matches: a }) => {
      a && t({ theme: "light", force: !1 });
    };
    return r.addEventListener("change", o), i.addEventListener("change", s), () => {
      r.removeEventListener("change", o), i.removeEventListener("change", s);
    };
  }, [e]), e.theme;
}, wy = {
  lightMode: sw(),
  darkMode: hT()
}, EX = {
  white: "#fff",
  black: "#000",
  transparent: "transparent",
  primary: "#fff",
  accent: "#000",
  disabled: "#E0E0E0",
  text: "#373737",
  textMuted: "#999999",
  textDanger: "#FF1515",
  background: "#fff",
  backgroundMuted: "#F6F7F9",
  tokenSelectBackground: "#F6F7F9",
  tokenSelectHoverBackground: "#EEF0F2",
  tokenSelect: "#373737",
  tabBorder: "#000000",
  skeletonLoaderBase: "#F6F7F9",
  skeletonLoaderHighlight: "#fff",
  warningBoxBackground: "#F6F7F9",
  stakeSectionBackground: "#F6F7F9",
  dropdownBackground: "#F6F7F9",
  selectValidatorMultiSelectedBackground: "#2DC969",
  selectValidatorMultiDefaultBackground: "#fff",
  positionsSectionBackgroundColor: "#FFFFFF",
  positionsSectionBorderColor: "#373737",
  positionsSectionDividerColor: "#F6F7F9",
  positionsClaimRewardsBackground: "#45D65C",
  positionsActionRequiredBackground: "#FA6878",
  positionsPendingBackground: "#FFAA07",
  modalOverlayBackground: "rgba(0, 0, 0, 0.5)",
  modalBodyBackground: "#FFFFFF",
  tooltipBackground: "#000000",
  primaryButtonColor: "#FFFFFF",
  primaryButtonBackground: "#000000",
  primaryButtonOutline: "#000000",
  primaryButtonHoverColor: "#FFFFFF",
  primaryButtonHoverBackground: "#1A1A1A",
  primaryButtonHoverOutline: "#1A1A1A",
  primaryButtonActiveColor: "#FFFFFF",
  primaryButtonActiveBackground: "#000000",
  primaryButtonActiveOutline: "#000000",
  secondaryButtonColor: "#373737",
  secondaryButtonBackground: "#FFFFFF",
  secondaryButtonOutline: "#000000",
  secondaryButtonHoverColor: "#373737",
  secondaryButtonHoverBackground: "#F6F7F9",
  secondaryButtonHoverOutline: "#000000",
  secondaryButtonActiveColor: "#373737",
  secondaryButtonActiveBackground: "#F6F7F9",
  secondaryButtonActiveOutline: "#000000",
  smallButtonColor: "#373737",
  smallButtonBackground: "#FFFFFF",
  smallButtonOutline: "#000000",
  smallButtonHoverColor: "#373737",
  smallButtonHoverBackground: "#F6F7F9",
  smallButtonHoverOutline: "#000000",
  smallButtonActiveColor: "#373737",
  smallButtonActiveBackground: "#F6F7F9",
  smallButtonActiveOutline: "#000000",
  smallLightButtonColor: "#373737",
  smallLightButtonBackground: "#F6F7F9",
  smallLightButtonOutline: "#F6F7F9",
  smallLightButtonHoverColor: "#373737",
  smallLightButtonHoverBackground: "#eaedf1",
  smallLightButtonHoverOutline: "#eaedf1",
  smallLightButtonActiveColor: "#373737",
  smallLightButtonActiveBackground: "#eaedf1",
  smallLightButtonActiveOutline: "#eaedf1",
  disabledButtonColor: "#FFFFFF",
  disabledButtonBackground: "#E0E0E0",
  disabledButtonOutline: "#E0E0E0",
  disabledButtonHoverColor: "#FFFFFF",
  disabledButtonHoverBackground: "#E6E6E6",
  disabledButtonHoverOutline: "#E0E0E0",
  disabledButtonActiveColor: "#FFFFFF",
  disabledButtonActiveBackground: "#E0E0E0",
  disabledButtonActiveOutline: "#E0E0E0",
  connectKit: {
    ...wy.lightMode.colors,
    modalBackground: "#FFFFFF",
    profileForeground: "#FFFFFF",
    profileAction: "#F6F7F9",
    profileActionHover: "#E0E0E0",
    modalBackdrop: "rgba(0, 0, 0, 0.5)"
  }
}, SX = {
  white: "#fff",
  black: "#000",
  transparent: "transparent",
  primary: "#2B2B2B",
  accent: "#3B6CEC",
  disabled: "#E0E0E0",
  text: "#FFFFFF",
  textMuted: "#999999",
  textDanger: "#FF1515",
  background: "#2B2B2B",
  backgroundMuted: "#363636",
  tokenSelectBackground: "#363636",
  tokenSelectHoverBackground: "#444444",
  tokenSelect: "#FFFFFF",
  tabBorder: "#FFFFFF",
  skeletonLoaderBase: "#363636",
  skeletonLoaderHighlight: "#2B2B2B",
  warningBoxBackground: "#363636",
  stakeSectionBackground: "#363636",
  dropdownBackground: "#363636",
  selectValidatorMultiSelectedBackground: "#2DC969",
  selectValidatorMultiDefaultBackground: "#2B2B2B",
  positionsSectionBackgroundColor: "#2B2B2B",
  positionsSectionBorderColor: "#2B2B2B",
  positionsSectionDividerColor: "#363636",
  positionsClaimRewardsBackground: "#45D65C",
  positionsActionRequiredBackground: "#FA6878",
  positionsPendingBackground: "#FFAA07",
  modalOverlayBackground: "rgba(0, 0, 0, 0.5)",
  modalBodyBackground: "#2B2B2B",
  tooltipBackground: "#000000",
  primaryButtonColor: "#000000",
  primaryButtonBackground: "#FFFFFF",
  primaryButtonOutline: "#FFFFFF",
  primaryButtonHoverColor: "#373737",
  primaryButtonHoverBackground: "#E6E6E6",
  primaryButtonHoverOutline: "#E6E6E6",
  primaryButtonActiveColor: "#000000",
  primaryButtonActiveBackground: "#FFFFFF",
  primaryButtonActiveOutline: "#000000",
  secondaryButtonColor: "#FFFFFF",
  secondaryButtonBackground: "#2B2B2B",
  secondaryButtonOutline: "#FFFFFF",
  secondaryButtonHoverColor: "#FFFFFF",
  secondaryButtonHoverBackground: "#212121",
  secondaryButtonHoverOutline: "#FFFFFF",
  secondaryButtonActiveColor: "#FFFFFF",
  secondaryButtonActiveBackground: "#212121",
  secondaryButtonActiveOutline: "#FFFFFF",
  smallButtonColor: "#FFFFFF",
  smallButtonBackground: "#2B2B2B",
  smallButtonOutline: "#2B2B2B",
  smallButtonHoverColor: "#FFFFFF",
  smallButtonHoverBackground: "#212121",
  smallButtonHoverOutline: "#212121",
  smallButtonActiveColor: "#FFFFFF",
  smallButtonActiveBackground: "#212121",
  smallButtonActiveOutline: "#212121",
  smallLightButtonColor: "#FFFFFF",
  smallLightButtonBackground: "#363636",
  smallLightButtonOutline: "#363636",
  smallLightButtonHoverColor: "#FFFFFF",
  smallLightButtonHoverBackground: "#434343",
  smallLightButtonHoverOutline: "#434343",
  smallLightButtonActiveColor: "#FFFFFF",
  smallLightButtonActiveBackground: "#434343",
  smallLightButtonActiveOutline: "#434343",
  disabledButtonColor: "#000000",
  disabledButtonBackground: "#E0E0E0",
  disabledButtonOutline: "#FFFFFF",
  disabledButtonHoverColor: "#000000",
  disabledButtonHoverBackground: "#E6E6E6",
  disabledButtonHoverOutline: "#F6F7F9",
  disabledButtonActiveColor: "#000000",
  disabledButtonActiveBackground: "#E0E0E0",
  disabledButtonActiveOutline: "#FFFFFF",
  connectKit: {
    ...wy.darkMode.colors,
    modalBackground: "#2B2B2B",
    profileForeground: "#2B2B2B",
    profileAction: "#363636",
    profileActionHover: "#444444",
    modalBackdrop: "rgba(0, 0, 0, 0.5)"
  }
}, AX = {
  body: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif'
};
var zt = { color: { white: "var(--sk-color-white)", black: "var(--sk-color-black)", transparent: "var(--sk-color-transparent)", primary: "var(--sk-color-primary)", accent: "var(--sk-color-accent)", disabled: "var(--sk-color-disabled)", text: "var(--sk-color-text)", textMuted: "var(--sk-color-text-muted)", textDanger: "var(--sk-color-text-danger)", background: "var(--sk-color-background)", backgroundMuted: "var(--sk-color-background-muted)", tokenSelectBackground: "var(--sk-color-token-select-background)", tokenSelectHoverBackground: "var(--sk-color-token-select-hover-background)", tokenSelect: "var(--sk-color-token-select)", skeletonLoaderBase: "var(--sk-color-skeleton-loader-base)", skeletonLoaderHighlight: "var(--sk-color-skeleton-loader-highlight)", tabBorder: "var(--sk-color-tab-border)", stakeSectionBackground: "var(--sk-color-stake-section-background)", dropdownBackground: "var(--sk-color-dropdown-background)", selectValidatorMultiSelectedBackground: "var(--sk-color-select-validator-multi-selected-background)", selectValidatorMultiDefaultBackground: "var(--sk-color-select-validator-multi-default-background)", warningBoxBackground: "var(--sk-color-warning-box-background)", positionsSectionBackgroundColor: "var(--sk-color-positions-section-background-color)", positionsSectionBorderColor: "var(--sk-color-positions-section-border-color)", positionsSectionDividerColor: "var(--sk-color-positions-section-divider-color)", positionsClaimRewardsBackground: "var(--sk-color-positions-claim-rewards-background)", positionsActionRequiredBackground: "var(--sk-color-positions-action-required-background)", positionsPendingBackground: "var(--sk-color-positions-pending-background)", modalOverlayBackground: "var(--sk-color-modal-overlay-background)", modalBodyBackground: "var(--sk-color-modal-body-background)", tooltipBackground: "var(--sk-color-tooltip-background)", primaryButtonColor: "var(--sk-color-primary-button-color)", primaryButtonBackground: "var(--sk-color-primary-button-background)", primaryButtonOutline: "var(--sk-color-primary-button-outline)", primaryButtonHoverColor: "var(--sk-color-primary-button-hover-color)", primaryButtonHoverBackground: "var(--sk-color-primary-button-hover-background)", primaryButtonHoverOutline: "var(--sk-color-primary-button-hover-outline)", primaryButtonActiveColor: "var(--sk-color-primary-button-active-color)", primaryButtonActiveBackground: "var(--sk-color-primary-button-active-background)", primaryButtonActiveOutline: "var(--sk-color-primary-button-active-outline)", secondaryButtonColor: "var(--sk-color-secondary-button-color)", secondaryButtonBackground: "var(--sk-color-secondary-button-background)", secondaryButtonOutline: "var(--sk-color-secondary-button-outline)", secondaryButtonHoverColor: "var(--sk-color-secondary-button-hover-color)", secondaryButtonHoverBackground: "var(--sk-color-secondary-button-hover-background)", secondaryButtonHoverOutline: "var(--sk-color-secondary-button-hover-outline)", secondaryButtonActiveColor: "var(--sk-color-secondary-button-active-color)", secondaryButtonActiveBackground: "var(--sk-color-secondary-button-active-background)", secondaryButtonActiveOutline: "var(--sk-color-secondary-button-active-outline)", smallButtonColor: "var(--sk-color-small-button-color)", smallButtonBackground: "var(--sk-color-small-button-background)", smallButtonOutline: "var(--sk-color-small-button-outline)", smallButtonHoverColor: "var(--sk-color-small-button-hover-color)", smallButtonHoverBackground: "var(--sk-color-small-button-hover-background)", smallButtonHoverOutline: "var(--sk-color-small-button-hover-outline)", smallButtonActiveColor: "var(--sk-color-small-button-active-color)", smallButtonActiveBackground: "var(--sk-color-small-button-active-background)", smallButtonActiveOutline: "var(--sk-color-small-button-active-outline)", smallLightButtonColor: "var(--sk-color-small-light-button-color)", smallLightButtonBackground: "var(--sk-color-small-light-button-background)", smallLightButtonOutline: "var(--sk-color-small-light-button-outline)", smallLightButtonHoverColor: "var(--sk-color-small-light-button-hover-color)", smallLightButtonHoverBackground: "var(--sk-color-small-light-button-hover-background)", smallLightButtonHoverOutline: "var(--sk-color-small-light-button-hover-outline)", smallLightButtonActiveColor: "var(--sk-color-small-light-button-active-color)", smallLightButtonActiveBackground: "var(--sk-color-small-light-button-active-background)", smallLightButtonActiveOutline: "var(--sk-color-small-light-button-active-outline)", disabledButtonColor: "var(--sk-color-disabled-button-color)", disabledButtonBackground: "var(--sk-color-disabled-button-background)", disabledButtonOutline: "var(--sk-color-disabled-button-outline)", disabledButtonHoverColor: "var(--sk-color-disabled-button-hover-color)", disabledButtonHoverBackground: "var(--sk-color-disabled-button-hover-background)", disabledButtonHoverOutline: "var(--sk-color-disabled-button-hover-outline)", disabledButtonActiveColor: "var(--sk-color-disabled-button-active-color)", disabledButtonActiveBackground: "var(--sk-color-disabled-button-active-background)", disabledButtonActiveOutline: "var(--sk-color-disabled-button-active-outline)", connectKit: { accentColor: "var(--sk-color-connect-kit-accent-color)", accentColorForeground: "var(--sk-color-connect-kit-accent-color-foreground)", actionButtonBorder: "var(--sk-color-connect-kit-action-button-border)", actionButtonBorderMobile: "var(--sk-color-connect-kit-action-button-border-mobile)", actionButtonSecondaryBackground: "var(--sk-color-connect-kit-action-button-secondary-background)", closeButton: "var(--sk-color-connect-kit-close-button)", closeButtonBackground: "var(--sk-color-connect-kit-close-button-background)", connectButtonBackground: "var(--sk-color-connect-kit-connect-button-background)", connectButtonBackgroundError: "var(--sk-color-connect-kit-connect-button-background-error)", connectButtonInnerBackground: "var(--sk-color-connect-kit-connect-button-inner-background)", connectButtonText: "var(--sk-color-connect-kit-connect-button-text)", connectButtonTextError: "var(--sk-color-connect-kit-connect-button-text-error)", connectionIndicator: "var(--sk-color-connect-kit-connection-indicator)", downloadBottomCardBackground: "var(--sk-color-connect-kit-download-bottom-card-background)", downloadTopCardBackground: "var(--sk-color-connect-kit-download-top-card-background)", error: "var(--sk-color-connect-kit-error)", generalBorder: "var(--sk-color-connect-kit-general-border)", generalBorderDim: "var(--sk-color-connect-kit-general-border-dim)", menuItemBackground: "var(--sk-color-connect-kit-menu-item-background)", modalBackdrop: "var(--sk-color-connect-kit-modal-backdrop)", modalBackground: "var(--sk-color-connect-kit-modal-background)", modalBorder: "var(--sk-color-connect-kit-modal-border)", modalText: "var(--sk-color-connect-kit-modal-text)", modalTextDim: "var(--sk-color-connect-kit-modal-text-dim)", modalTextSecondary: "var(--sk-color-connect-kit-modal-text-secondary)", profileAction: "var(--sk-color-connect-kit-profile-action)", profileActionHover: "var(--sk-color-connect-kit-profile-action-hover)", profileForeground: "var(--sk-color-connect-kit-profile-foreground)", selectedOptionBorder: "var(--sk-color-connect-kit-selected-option-border)", standby: "var(--sk-color-connect-kit-standby)" } }, fontSize: { xs: "var(--sk-font-size-xs)", sm: "var(--sk-font-size-sm)", md: "var(--sk-font-size-md)", lg: "var(--sk-font-size-lg)", lgx: "var(--sk-font-size-lgx)", xl: "var(--sk-font-size-xl)", "2xl": "var(--sk-font-size-2xl)", "3xl": "var(--sk-font-size-3xl)", "4xl": "var(--sk-font-size-4xl)", "5xl": "var(--sk-font-size-5xl)", "6xl": "var(--sk-font-size-6xl)" }, letterSpacing: { tighter: "var(--sk-letter-spacing-tighter)", tight: "var(--sk-letter-spacing-tight)", normal: "var(--sk-letter-spacing-normal)", wide: "var(--sk-letter-spacing-wide)", wider: "var(--sk-letter-spacing-wider)", widest: "var(--sk-letter-spacing-widest)" }, lineHeight: { none: "var(--sk-line-height-none)", shorter: "var(--sk-line-height-shorter)", short: "var(--sk-line-height-short)", base: "var(--sk-line-height-base)", tall: "var(--sk-line-height-tall)", taller: "var(--sk-line-height-taller)", xs: "var(--sk-line-height-xs)", sm: "var(--sk-line-height-sm)", md: "var(--sk-line-height-md)", lg: "var(--sk-line-height-lg)", xl: "var(--sk-line-height-xl)", "2xl": "var(--sk-line-height-2xl)", "3xl": "var(--sk-line-height-3xl)", "4xl": "var(--sk-line-height-4xl)", "5xl": "var(--sk-line-height-5xl)", "6xl": "var(--sk-line-height-6xl)" }, fontWeight: { normal: "var(--sk-font-weight-normal)", medium: "var(--sk-font-weight-medium)", semibold: "var(--sk-font-weight-semibold)", bold: "var(--sk-font-weight-bold)", extrabold: "var(--sk-font-weight-extrabold)", modalHeading: "var(--sk-font-weight-modal-heading)", tokenSelect: "var(--sk-font-weight-token-select)", primaryButton: "var(--sk-font-weight-primary-button)", secondaryButton: "var(--sk-font-weight-secondary-button)" }, borderRadius: { baseContract: { none: "var(--sk-border-radius-base-contract-none)", sm: "var(--sk-border-radius-base-contract-sm)", base: "var(--sk-border-radius-base-contract-base)", md: "var(--sk-border-radius-base-contract-md)", lg: "var(--sk-border-radius-base-contract-lg)", xl: "var(--sk-border-radius-base-contract-xl)", "2xl": "var(--sk-border-radius-base-contract-2xl)", "3xl": "var(--sk-border-radius-base-contract-3xl)", full: "var(--sk-border-radius-base-contract-full)", half: "var(--sk-border-radius-base-contract-half)", widgetBorderRadius: "var(--sk-border-radius-base-contract-widget-border-radius)", primaryButton: "var(--sk-border-radius-base-contract-primary-button)", secondaryButton: "var(--sk-border-radius-base-contract-secondary-button)", smallButton: "var(--sk-border-radius-base-contract-small-button)" }, connectKit: { actionButton: "var(--sk-border-radius-connect-kit-action-button)", connectButton: "var(--sk-border-radius-connect-kit-connect-button)", menuButton: "var(--sk-border-radius-connect-kit-menu-button)", modal: "var(--sk-border-radius-connect-kit-modal)", modalMobile: "var(--sk-border-radius-connect-kit-modal-mobile)" } }, space: { 0: "var(--sk-space-0)", 1: "var(--sk-space-1)", 2: "var(--sk-space-2)", 3: "var(--sk-space-3)", 4: "var(--sk-space-4)", 5: "var(--sk-space-5)", 6: "var(--sk-space-6)", 7: "var(--sk-space-7)", 8: "var(--sk-space-8)", 9: "var(--sk-space-9)", 10: "var(--sk-space-10)", 12: "var(--sk-space-12)", 14: "var(--sk-space-14)", 16: "var(--sk-space-16)", 20: "var(--sk-space-20)", 24: "var(--sk-space-24)", 28: "var(--sk-space-28)", 32: "var(--sk-space-32)", 36: "var(--sk-space-36)", 40: "var(--sk-space-40)", 44: "var(--sk-space-44)", 48: "var(--sk-space-48)", full: "var(--sk-space-full)", unset: "var(--sk-space-unset)", auto: "var(--sk-space-auto)", px: "var(--sk-space-px)", buttonMinHeight: "var(--sk-space-button-min-height)" }, heading: { h1: { mobile: { fontSize: "var(--sk-heading-h1-mobile-font-size)" }, tablet: { fontSize: "var(--sk-heading-h1-tablet-font-size)" } }, h2: { mobile: { fontSize: "var(--sk-heading-h2-mobile-font-size)" }, tablet: { fontSize: "var(--sk-heading-h2-tablet-font-size)" } }, h3: { mobile: { fontSize: "var(--sk-heading-h3-mobile-font-size)" }, tablet: { fontSize: "var(--sk-heading-h3-tablet-font-size)" } }, h4: { mobile: { fontSize: "var(--sk-heading-h4-mobile-font-size)" }, tablet: { fontSize: "var(--sk-heading-h4-tablet-font-size)" } } }, text: { large: { mobile: { fontSize: "var(--sk-text-large-mobile-font-size)" }, tablet: { fontSize: "var(--sk-text-large-tablet-font-size)" } }, medium: { mobile: { fontSize: "var(--sk-text-medium-mobile-font-size)" }, tablet: { fontSize: "var(--sk-text-medium-tablet-font-size)" } }, small: { mobile: { fontSize: "var(--sk-text-small-mobile-font-size)" }, tablet: { fontSize: "var(--sk-text-small-tablet-font-size)" } } }, zIndices: { hide: "var(--sk-z-indices-hide)", auto: "var(--sk-z-indices-auto)", simple: "var(--sk-z-indices-simple)", base: "var(--sk-z-indices-base)", docked: "var(--sk-z-indices-docked)", dropdown: "var(--sk-z-indices-dropdown)", sticky: "var(--sk-z-indices-sticky)", banner: "var(--sk-z-indices-banner)", overlay: "var(--sk-z-indices-overlay)", modal: "var(--sk-z-indices-modal)", skipLink: "var(--sk-z-indices-skip-link)" }, font: { body: "var(--sk-font-body)" } };
function TX(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function _X(e) {
  var t = TX(e, "string");
  return typeof t == "symbol" ? t : String(t);
}
function IX(e, t, n) {
  return t = _X(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function XE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ig(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? XE(Object(n), !0).forEach(function(r) {
      IX(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : XE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var RX = (e) => function() {
  for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
    n[r] = arguments[r];
  var i = Object.assign({}, ...n.map((l) => l.styles)), o = Object.keys(i), s = o.filter((l) => "mappings" in i[l]), a = (l) => {
    var c = [], u = {}, d = Ig({}, l), f = !1;
    for (var h of s) {
      var p = l[h];
      if (p != null) {
        var m = i[h];
        f = !0;
        for (var g of m.mappings)
          u[g] = p, d[g] == null && delete d[g];
      }
    }
    var v = f ? Ig(Ig({}, u), d) : l, w = function() {
      var S = v[x], k = i[x];
      try {
        if (k.mappings)
          return 1;
        if (typeof S == "string" || typeof S == "number") {
          if (ke.env.NODE_ENV !== "production" && !k.values[S].defaultClass)
            throw new Error();
          c.push(k.values[S].defaultClass);
        } else if (Array.isArray(S))
          for (var A = 0; A < S.length; A++) {
            var b = S[A];
            if (b != null) {
              var T = k.responsiveArray[A];
              if (ke.env.NODE_ENV !== "production" && !k.values[b].conditions[T])
                throw new Error();
              c.push(k.values[b].conditions[T]);
            }
          }
        else
          for (var R in S) {
            var B = S[R];
            if (B != null) {
              if (ke.env.NODE_ENV !== "production" && !k.values[B].conditions[R])
                throw new Error();
              c.push(k.values[B].conditions[R]);
            }
          }
      } catch (F) {
        if (ke.env.NODE_ENV !== "production") {
          class $ extends Error {
            constructor(he) {
              super(he), this.name = "SprinklesError";
            }
          }
          var O = (ie) => typeof ie == "string" ? '"'.concat(ie, '"') : ie, L = (ie, he, ae) => {
            throw new $('"'.concat(ie, '" has no value ').concat(O(he), ". Possible values are ").concat(Object.keys(ae).map(O).join(", ")));
          };
          if (!k)
            throw new $('"'.concat(x, '" is not a valid sprinkle'));
          if ((typeof S == "string" || typeof S == "number") && (S in k.values || L(x, S, k.values), !k.values[S].defaultClass))
            throw new $('"'.concat(x, '" has no default condition. You must specify which conditions to target explicitly. Possible options are ').concat(Object.keys(k.values[S].conditions).map(O).join(", ")));
          if (typeof S == "object") {
            if (!("conditions" in k.values[Object.keys(k.values)[0]]))
              throw new $('"'.concat(x, '" is not a conditional property'));
            if (Array.isArray(S)) {
              if (!("responsiveArray" in k))
                throw new $('"'.concat(x, '" does not support responsive arrays'));
              var V = k.responsiveArray.length;
              if (V < S.length)
                throw new $('"'.concat(x, '" only supports up to ').concat(V, " breakpoints. You passed ").concat(S.length));
              for (var N of S)
                k.values[N] || L(x, N, k.values);
            } else
              for (var M in S) {
                var U = S[M];
                if (U != null && (k.values[U] || L(x, U, k.values), !k.values[U].conditions[M]))
                  throw new $('"'.concat(x, '" has no condition named ').concat(O(M), ". Possible values are ").concat(Object.keys(k.values[U].conditions).map(O).join(", ")));
              }
          }
        }
        throw F;
      }
    };
    for (var x in v)
      w();
    return e(c.join(" "));
  };
  return Object.assign(a, {
    properties: new Set(o)
  });
}, PX = (e) => e, OX = function() {
  return RX(PX)(...arguments);
}, ZE = OX({ conditions: void 0, styles: { position: { values: { relative: { defaultClass: "yv8y4r0" }, absolute: { defaultClass: "yv8y4r1" }, sticky: { defaultClass: "yv8y4r2" } } }, opacity: { values: { 0: { defaultClass: "yv8y4r3" }, 1: { defaultClass: "yv8y4r6" }, "0.1": { defaultClass: "yv8y4r4" }, "0.5": { defaultClass: "yv8y4r5" } } }, zIndex: { values: { hide: { defaultClass: "yv8y4r7" }, auto: { defaultClass: "yv8y4r8" }, simple: { defaultClass: "yv8y4r9" }, base: { defaultClass: "yv8y4ra" }, docked: { defaultClass: "yv8y4rb" }, dropdown: { defaultClass: "yv8y4rc" }, sticky: { defaultClass: "yv8y4rd" }, banner: { defaultClass: "yv8y4re" }, overlay: { defaultClass: "yv8y4rf" }, modal: { defaultClass: "yv8y4rg" }, skipLink: { defaultClass: "yv8y4rh" } } }, fontWeight: { values: { normal: { defaultClass: "yv8y4ri" }, medium: { defaultClass: "yv8y4rj" }, semibold: { defaultClass: "yv8y4rk" }, bold: { defaultClass: "yv8y4rl" }, extrabold: { defaultClass: "yv8y4rm" }, modalHeading: { defaultClass: "yv8y4rn" }, tokenSelect: { defaultClass: "yv8y4ro" }, primaryButton: { defaultClass: "yv8y4rp" }, secondaryButton: { defaultClass: "yv8y4rq" } } }, border: { values: { none: { defaultClass: "yv8y4rr" } } }, borderRadius: { values: { none: { defaultClass: "yv8y4rs" }, sm: { defaultClass: "yv8y4rt" }, base: { defaultClass: "yv8y4ru" }, md: { defaultClass: "yv8y4rv" }, lg: { defaultClass: "yv8y4rw" }, xl: { defaultClass: "yv8y4rx" }, "2xl": { defaultClass: "yv8y4ry" }, "3xl": { defaultClass: "yv8y4rz" }, full: { defaultClass: "yv8y4r10" }, half: { defaultClass: "yv8y4r11" }, widgetBorderRadius: { defaultClass: "yv8y4r12" }, primaryButton: { defaultClass: "yv8y4r13" }, secondaryButton: { defaultClass: "yv8y4r14" }, smallButton: { defaultClass: "yv8y4r15" } } }, textAlign: { values: { left: { defaultClass: "yv8y4r16" }, center: { defaultClass: "yv8y4r17" }, right: { defaultClass: "yv8y4r18" }, end: { defaultClass: "yv8y4r19" } } }, flex: { values: { 1: { defaultClass: "yv8y4r1a" }, 2: { defaultClass: "yv8y4r1b" }, 3: { defaultClass: "yv8y4r1c" }, 4: { defaultClass: "yv8y4r1d" }, 5: { defaultClass: "yv8y4r1e" } } }, flexGrow: { values: { 0: { defaultClass: "yv8y4r1f" }, 1: { defaultClass: "yv8y4r1g" }, 2: { defaultClass: "yv8y4r1h" }, 3: { defaultClass: "yv8y4r1i" } } }, flexShrink: { values: { 0: { defaultClass: "yv8y4r1j" }, 1: { defaultClass: "yv8y4r1k" }, 2: { defaultClass: "yv8y4r1l" }, 3: { defaultClass: "yv8y4r1m" } } }, lineHeight: { values: { none: { defaultClass: "yv8y4r1n" }, shorter: { defaultClass: "yv8y4r1o" }, short: { defaultClass: "yv8y4r1p" }, base: { defaultClass: "yv8y4r1q" }, tall: { defaultClass: "yv8y4r1r" }, taller: { defaultClass: "yv8y4r1s" }, xs: { defaultClass: "yv8y4r1t" }, sm: { defaultClass: "yv8y4r1u" }, md: { defaultClass: "yv8y4r1v" }, lg: { defaultClass: "yv8y4r1w" }, xl: { defaultClass: "yv8y4r1x" }, "2xl": { defaultClass: "yv8y4r1y" }, "3xl": { defaultClass: "yv8y4r1z" }, "4xl": { defaultClass: "yv8y4r20" }, "5xl": { defaultClass: "yv8y4r21" }, "6xl": { defaultClass: "yv8y4r22" } } }, letterSpacing: { values: { tighter: { defaultClass: "yv8y4r23" }, tight: { defaultClass: "yv8y4r24" }, normal: { defaultClass: "yv8y4r25" }, wide: { defaultClass: "yv8y4r26" }, wider: { defaultClass: "yv8y4r27" }, widest: { defaultClass: "yv8y4r28" } } }, borderWidth: { values: { 1: { defaultClass: "yv8y4r2a" }, 2: { defaultClass: "yv8y4r2b" }, 3: { defaultClass: "yv8y4r2c" }, "0.5": { defaultClass: "yv8y4r29" } } }, borderStyle: { values: { solid: { defaultClass: "yv8y4r2d" } } }, overflowWrap: { values: { normal: { defaultClass: "yv8y4r2e" }, "break-word": { defaultClass: "yv8y4r2f" }, anywhere: { defaultClass: "yv8y4r2g" } } } } }, { conditions: { defaultCondition: "mobile", conditionNames: ["mobile", "tablet"], responsiveArray: void 0 }, styles: { px: { mappings: ["paddingLeft", "paddingRight"] }, py: { mappings: ["paddingTop", "paddingBottom"] }, mx: { mappings: ["marginLeft", "marginRight"] }, my: { mappings: ["marginTop", "marginBottom"] }, hw: { mappings: ["height", "width"] }, display: { values: { block: { conditions: { mobile: "yv8y4r2h", tablet: "yv8y4r2i" }, defaultClass: "yv8y4r2h" }, inline: { conditions: { mobile: "yv8y4r2j", tablet: "yv8y4r2k" }, defaultClass: "yv8y4r2j" }, "inline-block": { conditions: { mobile: "yv8y4r2l", tablet: "yv8y4r2m" }, defaultClass: "yv8y4r2l" }, flex: { conditions: { mobile: "yv8y4r2n", tablet: "yv8y4r2o" }, defaultClass: "yv8y4r2n" }, "inline-flex": { conditions: { mobile: "yv8y4r2p", tablet: "yv8y4r2q" }, defaultClass: "yv8y4r2p" }, none: { conditions: { mobile: "yv8y4r2r", tablet: "yv8y4r2s" }, defaultClass: "yv8y4r2r" } } }, fontSize: { values: { xs: { conditions: { mobile: "yv8y4r2t", tablet: "yv8y4r2u" }, defaultClass: "yv8y4r2t" }, sm: { conditions: { mobile: "yv8y4r2v", tablet: "yv8y4r2w" }, defaultClass: "yv8y4r2v" }, md: { conditions: { mobile: "yv8y4r2x", tablet: "yv8y4r2y" }, defaultClass: "yv8y4r2x" }, lg: { conditions: { mobile: "yv8y4r2z", tablet: "yv8y4r30" }, defaultClass: "yv8y4r2z" }, lgx: { conditions: { mobile: "yv8y4r31", tablet: "yv8y4r32" }, defaultClass: "yv8y4r31" }, xl: { conditions: { mobile: "yv8y4r33", tablet: "yv8y4r34" }, defaultClass: "yv8y4r33" }, "2xl": { conditions: { mobile: "yv8y4r35", tablet: "yv8y4r36" }, defaultClass: "yv8y4r35" }, "3xl": { conditions: { mobile: "yv8y4r37", tablet: "yv8y4r38" }, defaultClass: "yv8y4r37" }, "4xl": { conditions: { mobile: "yv8y4r39", tablet: "yv8y4r3a" }, defaultClass: "yv8y4r39" }, "5xl": { conditions: { mobile: "yv8y4r3b", tablet: "yv8y4r3c" }, defaultClass: "yv8y4r3b" }, "6xl": { conditions: { mobile: "yv8y4r3d", tablet: "yv8y4r3e" }, defaultClass: "yv8y4r3d" } } }, marginTop: { values: { 0: { conditions: { mobile: "yv8y4r3f", tablet: "yv8y4r3g" }, defaultClass: "yv8y4r3f" }, 1: { conditions: { mobile: "yv8y4r3h", tablet: "yv8y4r3i" }, defaultClass: "yv8y4r3h" }, 2: { conditions: { mobile: "yv8y4r3j", tablet: "yv8y4r3k" }, defaultClass: "yv8y4r3j" }, 3: { conditions: { mobile: "yv8y4r3l", tablet: "yv8y4r3m" }, defaultClass: "yv8y4r3l" }, 4: { conditions: { mobile: "yv8y4r3n", tablet: "yv8y4r3o" }, defaultClass: "yv8y4r3n" }, 5: { conditions: { mobile: "yv8y4r3p", tablet: "yv8y4r3q" }, defaultClass: "yv8y4r3p" }, 6: { conditions: { mobile: "yv8y4r3r", tablet: "yv8y4r3s" }, defaultClass: "yv8y4r3r" }, 7: { conditions: { mobile: "yv8y4r3t", tablet: "yv8y4r3u" }, defaultClass: "yv8y4r3t" }, 8: { conditions: { mobile: "yv8y4r3v", tablet: "yv8y4r3w" }, defaultClass: "yv8y4r3v" }, 9: { conditions: { mobile: "yv8y4r3x", tablet: "yv8y4r3y" }, defaultClass: "yv8y4r3x" }, 10: { conditions: { mobile: "yv8y4r3z", tablet: "yv8y4r40" }, defaultClass: "yv8y4r3z" }, 12: { conditions: { mobile: "yv8y4r41", tablet: "yv8y4r42" }, defaultClass: "yv8y4r41" }, 14: { conditions: { mobile: "yv8y4r43", tablet: "yv8y4r44" }, defaultClass: "yv8y4r43" }, 16: { conditions: { mobile: "yv8y4r45", tablet: "yv8y4r46" }, defaultClass: "yv8y4r45" }, 20: { conditions: { mobile: "yv8y4r47", tablet: "yv8y4r48" }, defaultClass: "yv8y4r47" }, 24: { conditions: { mobile: "yv8y4r49", tablet: "yv8y4r4a" }, defaultClass: "yv8y4r49" }, 28: { conditions: { mobile: "yv8y4r4b", tablet: "yv8y4r4c" }, defaultClass: "yv8y4r4b" }, 32: { conditions: { mobile: "yv8y4r4d", tablet: "yv8y4r4e" }, defaultClass: "yv8y4r4d" }, 36: { conditions: { mobile: "yv8y4r4f", tablet: "yv8y4r4g" }, defaultClass: "yv8y4r4f" }, 40: { conditions: { mobile: "yv8y4r4h", tablet: "yv8y4r4i" }, defaultClass: "yv8y4r4h" }, 44: { conditions: { mobile: "yv8y4r4j", tablet: "yv8y4r4k" }, defaultClass: "yv8y4r4j" }, 48: { conditions: { mobile: "yv8y4r4l", tablet: "yv8y4r4m" }, defaultClass: "yv8y4r4l" }, full: { conditions: { mobile: "yv8y4r4n", tablet: "yv8y4r4o" }, defaultClass: "yv8y4r4n" }, unset: { conditions: { mobile: "yv8y4r4p", tablet: "yv8y4r4q" }, defaultClass: "yv8y4r4p" }, auto: { conditions: { mobile: "yv8y4r4r", tablet: "yv8y4r4s" }, defaultClass: "yv8y4r4r" }, px: { conditions: { mobile: "yv8y4r4t", tablet: "yv8y4r4u" }, defaultClass: "yv8y4r4t" }, buttonMinHeight: { conditions: { mobile: "yv8y4r4v", tablet: "yv8y4r4w" }, defaultClass: "yv8y4r4v" } } }, marginBottom: { values: { 0: { conditions: { mobile: "yv8y4r4x", tablet: "yv8y4r4y" }, defaultClass: "yv8y4r4x" }, 1: { conditions: { mobile: "yv8y4r4z", tablet: "yv8y4r50" }, defaultClass: "yv8y4r4z" }, 2: { conditions: { mobile: "yv8y4r51", tablet: "yv8y4r52" }, defaultClass: "yv8y4r51" }, 3: { conditions: { mobile: "yv8y4r53", tablet: "yv8y4r54" }, defaultClass: "yv8y4r53" }, 4: { conditions: { mobile: "yv8y4r55", tablet: "yv8y4r56" }, defaultClass: "yv8y4r55" }, 5: { conditions: { mobile: "yv8y4r57", tablet: "yv8y4r58" }, defaultClass: "yv8y4r57" }, 6: { conditions: { mobile: "yv8y4r59", tablet: "yv8y4r5a" }, defaultClass: "yv8y4r59" }, 7: { conditions: { mobile: "yv8y4r5b", tablet: "yv8y4r5c" }, defaultClass: "yv8y4r5b" }, 8: { conditions: { mobile: "yv8y4r5d", tablet: "yv8y4r5e" }, defaultClass: "yv8y4r5d" }, 9: { conditions: { mobile: "yv8y4r5f", tablet: "yv8y4r5g" }, defaultClass: "yv8y4r5f" }, 10: { conditions: { mobile: "yv8y4r5h", tablet: "yv8y4r5i" }, defaultClass: "yv8y4r5h" }, 12: { conditions: { mobile: "yv8y4r5j", tablet: "yv8y4r5k" }, defaultClass: "yv8y4r5j" }, 14: { conditions: { mobile: "yv8y4r5l", tablet: "yv8y4r5m" }, defaultClass: "yv8y4r5l" }, 16: { conditions: { mobile: "yv8y4r5n", tablet: "yv8y4r5o" }, defaultClass: "yv8y4r5n" }, 20: { conditions: { mobile: "yv8y4r5p", tablet: "yv8y4r5q" }, defaultClass: "yv8y4r5p" }, 24: { conditions: { mobile: "yv8y4r5r", tablet: "yv8y4r5s" }, defaultClass: "yv8y4r5r" }, 28: { conditions: { mobile: "yv8y4r5t", tablet: "yv8y4r5u" }, defaultClass: "yv8y4r5t" }, 32: { conditions: { mobile: "yv8y4r5v", tablet: "yv8y4r5w" }, defaultClass: "yv8y4r5v" }, 36: { conditions: { mobile: "yv8y4r5x", tablet: "yv8y4r5y" }, defaultClass: "yv8y4r5x" }, 40: { conditions: { mobile: "yv8y4r5z", tablet: "yv8y4r60" }, defaultClass: "yv8y4r5z" }, 44: { conditions: { mobile: "yv8y4r61", tablet: "yv8y4r62" }, defaultClass: "yv8y4r61" }, 48: { conditions: { mobile: "yv8y4r63", tablet: "yv8y4r64" }, defaultClass: "yv8y4r63" }, full: { conditions: { mobile: "yv8y4r65", tablet: "yv8y4r66" }, defaultClass: "yv8y4r65" }, unset: { conditions: { mobile: "yv8y4r67", tablet: "yv8y4r68" }, defaultClass: "yv8y4r67" }, auto: { conditions: { mobile: "yv8y4r69", tablet: "yv8y4r6a" }, defaultClass: "yv8y4r69" }, px: { conditions: { mobile: "yv8y4r6b", tablet: "yv8y4r6c" }, defaultClass: "yv8y4r6b" }, buttonMinHeight: { conditions: { mobile: "yv8y4r6d", tablet: "yv8y4r6e" }, defaultClass: "yv8y4r6d" } } }, marginRight: { values: { 0: { conditions: { mobile: "yv8y4r6f", tablet: "yv8y4r6g" }, defaultClass: "yv8y4r6f" }, 1: { conditions: { mobile: "yv8y4r6h", tablet: "yv8y4r6i" }, defaultClass: "yv8y4r6h" }, 2: { conditions: { mobile: "yv8y4r6j", tablet: "yv8y4r6k" }, defaultClass: "yv8y4r6j" }, 3: { conditions: { mobile: "yv8y4r6l", tablet: "yv8y4r6m" }, defaultClass: "yv8y4r6l" }, 4: { conditions: { mobile: "yv8y4r6n", tablet: "yv8y4r6o" }, defaultClass: "yv8y4r6n" }, 5: { conditions: { mobile: "yv8y4r6p", tablet: "yv8y4r6q" }, defaultClass: "yv8y4r6p" }, 6: { conditions: { mobile: "yv8y4r6r", tablet: "yv8y4r6s" }, defaultClass: "yv8y4r6r" }, 7: { conditions: { mobile: "yv8y4r6t", tablet: "yv8y4r6u" }, defaultClass: "yv8y4r6t" }, 8: { conditions: { mobile: "yv8y4r6v", tablet: "yv8y4r6w" }, defaultClass: "yv8y4r6v" }, 9: { conditions: { mobile: "yv8y4r6x", tablet: "yv8y4r6y" }, defaultClass: "yv8y4r6x" }, 10: { conditions: { mobile: "yv8y4r6z", tablet: "yv8y4r70" }, defaultClass: "yv8y4r6z" }, 12: { conditions: { mobile: "yv8y4r71", tablet: "yv8y4r72" }, defaultClass: "yv8y4r71" }, 14: { conditions: { mobile: "yv8y4r73", tablet: "yv8y4r74" }, defaultClass: "yv8y4r73" }, 16: { conditions: { mobile: "yv8y4r75", tablet: "yv8y4r76" }, defaultClass: "yv8y4r75" }, 20: { conditions: { mobile: "yv8y4r77", tablet: "yv8y4r78" }, defaultClass: "yv8y4r77" }, 24: { conditions: { mobile: "yv8y4r79", tablet: "yv8y4r7a" }, defaultClass: "yv8y4r79" }, 28: { conditions: { mobile: "yv8y4r7b", tablet: "yv8y4r7c" }, defaultClass: "yv8y4r7b" }, 32: { conditions: { mobile: "yv8y4r7d", tablet: "yv8y4r7e" }, defaultClass: "yv8y4r7d" }, 36: { conditions: { mobile: "yv8y4r7f", tablet: "yv8y4r7g" }, defaultClass: "yv8y4r7f" }, 40: { conditions: { mobile: "yv8y4r7h", tablet: "yv8y4r7i" }, defaultClass: "yv8y4r7h" }, 44: { conditions: { mobile: "yv8y4r7j", tablet: "yv8y4r7k" }, defaultClass: "yv8y4r7j" }, 48: { conditions: { mobile: "yv8y4r7l", tablet: "yv8y4r7m" }, defaultClass: "yv8y4r7l" }, full: { conditions: { mobile: "yv8y4r7n", tablet: "yv8y4r7o" }, defaultClass: "yv8y4r7n" }, unset: { conditions: { mobile: "yv8y4r7p", tablet: "yv8y4r7q" }, defaultClass: "yv8y4r7p" }, auto: { conditions: { mobile: "yv8y4r7r", tablet: "yv8y4r7s" }, defaultClass: "yv8y4r7r" }, px: { conditions: { mobile: "yv8y4r7t", tablet: "yv8y4r7u" }, defaultClass: "yv8y4r7t" }, buttonMinHeight: { conditions: { mobile: "yv8y4r7v", tablet: "yv8y4r7w" }, defaultClass: "yv8y4r7v" } } }, marginLeft: { values: { 0: { conditions: { mobile: "yv8y4r7x", tablet: "yv8y4r7y" }, defaultClass: "yv8y4r7x" }, 1: { conditions: { mobile: "yv8y4r7z", tablet: "yv8y4r80" }, defaultClass: "yv8y4r7z" }, 2: { conditions: { mobile: "yv8y4r81", tablet: "yv8y4r82" }, defaultClass: "yv8y4r81" }, 3: { conditions: { mobile: "yv8y4r83", tablet: "yv8y4r84" }, defaultClass: "yv8y4r83" }, 4: { conditions: { mobile: "yv8y4r85", tablet: "yv8y4r86" }, defaultClass: "yv8y4r85" }, 5: { conditions: { mobile: "yv8y4r87", tablet: "yv8y4r88" }, defaultClass: "yv8y4r87" }, 6: { conditions: { mobile: "yv8y4r89", tablet: "yv8y4r8a" }, defaultClass: "yv8y4r89" }, 7: { conditions: { mobile: "yv8y4r8b", tablet: "yv8y4r8c" }, defaultClass: "yv8y4r8b" }, 8: { conditions: { mobile: "yv8y4r8d", tablet: "yv8y4r8e" }, defaultClass: "yv8y4r8d" }, 9: { conditions: { mobile: "yv8y4r8f", tablet: "yv8y4r8g" }, defaultClass: "yv8y4r8f" }, 10: { conditions: { mobile: "yv8y4r8h", tablet: "yv8y4r8i" }, defaultClass: "yv8y4r8h" }, 12: { conditions: { mobile: "yv8y4r8j", tablet: "yv8y4r8k" }, defaultClass: "yv8y4r8j" }, 14: { conditions: { mobile: "yv8y4r8l", tablet: "yv8y4r8m" }, defaultClass: "yv8y4r8l" }, 16: { conditions: { mobile: "yv8y4r8n", tablet: "yv8y4r8o" }, defaultClass: "yv8y4r8n" }, 20: { conditions: { mobile: "yv8y4r8p", tablet: "yv8y4r8q" }, defaultClass: "yv8y4r8p" }, 24: { conditions: { mobile: "yv8y4r8r", tablet: "yv8y4r8s" }, defaultClass: "yv8y4r8r" }, 28: { conditions: { mobile: "yv8y4r8t", tablet: "yv8y4r8u" }, defaultClass: "yv8y4r8t" }, 32: { conditions: { mobile: "yv8y4r8v", tablet: "yv8y4r8w" }, defaultClass: "yv8y4r8v" }, 36: { conditions: { mobile: "yv8y4r8x", tablet: "yv8y4r8y" }, defaultClass: "yv8y4r8x" }, 40: { conditions: { mobile: "yv8y4r8z", tablet: "yv8y4r90" }, defaultClass: "yv8y4r8z" }, 44: { conditions: { mobile: "yv8y4r91", tablet: "yv8y4r92" }, defaultClass: "yv8y4r91" }, 48: { conditions: { mobile: "yv8y4r93", tablet: "yv8y4r94" }, defaultClass: "yv8y4r93" }, full: { conditions: { mobile: "yv8y4r95", tablet: "yv8y4r96" }, defaultClass: "yv8y4r95" }, unset: { conditions: { mobile: "yv8y4r97", tablet: "yv8y4r98" }, defaultClass: "yv8y4r97" }, auto: { conditions: { mobile: "yv8y4r99", tablet: "yv8y4r9a" }, defaultClass: "yv8y4r99" }, px: { conditions: { mobile: "yv8y4r9b", tablet: "yv8y4r9c" }, defaultClass: "yv8y4r9b" }, buttonMinHeight: { conditions: { mobile: "yv8y4r9d", tablet: "yv8y4r9e" }, defaultClass: "yv8y4r9d" } } }, paddingTop: { values: { 0: { conditions: { mobile: "yv8y4r9f", tablet: "yv8y4r9g" }, defaultClass: "yv8y4r9f" }, 1: { conditions: { mobile: "yv8y4r9h", tablet: "yv8y4r9i" }, defaultClass: "yv8y4r9h" }, 2: { conditions: { mobile: "yv8y4r9j", tablet: "yv8y4r9k" }, defaultClass: "yv8y4r9j" }, 3: { conditions: { mobile: "yv8y4r9l", tablet: "yv8y4r9m" }, defaultClass: "yv8y4r9l" }, 4: { conditions: { mobile: "yv8y4r9n", tablet: "yv8y4r9o" }, defaultClass: "yv8y4r9n" }, 5: { conditions: { mobile: "yv8y4r9p", tablet: "yv8y4r9q" }, defaultClass: "yv8y4r9p" }, 6: { conditions: { mobile: "yv8y4r9r", tablet: "yv8y4r9s" }, defaultClass: "yv8y4r9r" }, 7: { conditions: { mobile: "yv8y4r9t", tablet: "yv8y4r9u" }, defaultClass: "yv8y4r9t" }, 8: { conditions: { mobile: "yv8y4r9v", tablet: "yv8y4r9w" }, defaultClass: "yv8y4r9v" }, 9: { conditions: { mobile: "yv8y4r9x", tablet: "yv8y4r9y" }, defaultClass: "yv8y4r9x" }, 10: { conditions: { mobile: "yv8y4r9z", tablet: "yv8y4ra0" }, defaultClass: "yv8y4r9z" }, 12: { conditions: { mobile: "yv8y4ra1", tablet: "yv8y4ra2" }, defaultClass: "yv8y4ra1" }, 14: { conditions: { mobile: "yv8y4ra3", tablet: "yv8y4ra4" }, defaultClass: "yv8y4ra3" }, 16: { conditions: { mobile: "yv8y4ra5", tablet: "yv8y4ra6" }, defaultClass: "yv8y4ra5" }, 20: { conditions: { mobile: "yv8y4ra7", tablet: "yv8y4ra8" }, defaultClass: "yv8y4ra7" }, 24: { conditions: { mobile: "yv8y4ra9", tablet: "yv8y4raa" }, defaultClass: "yv8y4ra9" }, 28: { conditions: { mobile: "yv8y4rab", tablet: "yv8y4rac" }, defaultClass: "yv8y4rab" }, 32: { conditions: { mobile: "yv8y4rad", tablet: "yv8y4rae" }, defaultClass: "yv8y4rad" }, 36: { conditions: { mobile: "yv8y4raf", tablet: "yv8y4rag" }, defaultClass: "yv8y4raf" }, 40: { conditions: { mobile: "yv8y4rah", tablet: "yv8y4rai" }, defaultClass: "yv8y4rah" }, 44: { conditions: { mobile: "yv8y4raj", tablet: "yv8y4rak" }, defaultClass: "yv8y4raj" }, 48: { conditions: { mobile: "yv8y4ral", tablet: "yv8y4ram" }, defaultClass: "yv8y4ral" }, full: { conditions: { mobile: "yv8y4ran", tablet: "yv8y4rao" }, defaultClass: "yv8y4ran" }, unset: { conditions: { mobile: "yv8y4rap", tablet: "yv8y4raq" }, defaultClass: "yv8y4rap" }, auto: { conditions: { mobile: "yv8y4rar", tablet: "yv8y4ras" }, defaultClass: "yv8y4rar" }, px: { conditions: { mobile: "yv8y4rat", tablet: "yv8y4rau" }, defaultClass: "yv8y4rat" }, buttonMinHeight: { conditions: { mobile: "yv8y4rav", tablet: "yv8y4raw" }, defaultClass: "yv8y4rav" } } }, paddingBottom: { values: { 0: { conditions: { mobile: "yv8y4rax", tablet: "yv8y4ray" }, defaultClass: "yv8y4rax" }, 1: { conditions: { mobile: "yv8y4raz", tablet: "yv8y4rb0" }, defaultClass: "yv8y4raz" }, 2: { conditions: { mobile: "yv8y4rb1", tablet: "yv8y4rb2" }, defaultClass: "yv8y4rb1" }, 3: { conditions: { mobile: "yv8y4rb3", tablet: "yv8y4rb4" }, defaultClass: "yv8y4rb3" }, 4: { conditions: { mobile: "yv8y4rb5", tablet: "yv8y4rb6" }, defaultClass: "yv8y4rb5" }, 5: { conditions: { mobile: "yv8y4rb7", tablet: "yv8y4rb8" }, defaultClass: "yv8y4rb7" }, 6: { conditions: { mobile: "yv8y4rb9", tablet: "yv8y4rba" }, defaultClass: "yv8y4rb9" }, 7: { conditions: { mobile: "yv8y4rbb", tablet: "yv8y4rbc" }, defaultClass: "yv8y4rbb" }, 8: { conditions: { mobile: "yv8y4rbd", tablet: "yv8y4rbe" }, defaultClass: "yv8y4rbd" }, 9: { conditions: { mobile: "yv8y4rbf", tablet: "yv8y4rbg" }, defaultClass: "yv8y4rbf" }, 10: { conditions: { mobile: "yv8y4rbh", tablet: "yv8y4rbi" }, defaultClass: "yv8y4rbh" }, 12: { conditions: { mobile: "yv8y4rbj", tablet: "yv8y4rbk" }, defaultClass: "yv8y4rbj" }, 14: { conditions: { mobile: "yv8y4rbl", tablet: "yv8y4rbm" }, defaultClass: "yv8y4rbl" }, 16: { conditions: { mobile: "yv8y4rbn", tablet: "yv8y4rbo" }, defaultClass: "yv8y4rbn" }, 20: { conditions: { mobile: "yv8y4rbp", tablet: "yv8y4rbq" }, defaultClass: "yv8y4rbp" }, 24: { conditions: { mobile: "yv8y4rbr", tablet: "yv8y4rbs" }, defaultClass: "yv8y4rbr" }, 28: { conditions: { mobile: "yv8y4rbt", tablet: "yv8y4rbu" }, defaultClass: "yv8y4rbt" }, 32: { conditions: { mobile: "yv8y4rbv", tablet: "yv8y4rbw" }, defaultClass: "yv8y4rbv" }, 36: { conditions: { mobile: "yv8y4rbx", tablet: "yv8y4rby" }, defaultClass: "yv8y4rbx" }, 40: { conditions: { mobile: "yv8y4rbz", tablet: "yv8y4rc0" }, defaultClass: "yv8y4rbz" }, 44: { conditions: { mobile: "yv8y4rc1", tablet: "yv8y4rc2" }, defaultClass: "yv8y4rc1" }, 48: { conditions: { mobile: "yv8y4rc3", tablet: "yv8y4rc4" }, defaultClass: "yv8y4rc3" }, full: { conditions: { mobile: "yv8y4rc5", tablet: "yv8y4rc6" }, defaultClass: "yv8y4rc5" }, unset: { conditions: { mobile: "yv8y4rc7", tablet: "yv8y4rc8" }, defaultClass: "yv8y4rc7" }, auto: { conditions: { mobile: "yv8y4rc9", tablet: "yv8y4rca" }, defaultClass: "yv8y4rc9" }, px: { conditions: { mobile: "yv8y4rcb", tablet: "yv8y4rcc" }, defaultClass: "yv8y4rcb" }, buttonMinHeight: { conditions: { mobile: "yv8y4rcd", tablet: "yv8y4rce" }, defaultClass: "yv8y4rcd" } } }, paddingRight: { values: { 0: { conditions: { mobile: "yv8y4rcf", tablet: "yv8y4rcg" }, defaultClass: "yv8y4rcf" }, 1: { conditions: { mobile: "yv8y4rch", tablet: "yv8y4rci" }, defaultClass: "yv8y4rch" }, 2: { conditions: { mobile: "yv8y4rcj", tablet: "yv8y4rck" }, defaultClass: "yv8y4rcj" }, 3: { conditions: { mobile: "yv8y4rcl", tablet: "yv8y4rcm" }, defaultClass: "yv8y4rcl" }, 4: { conditions: { mobile: "yv8y4rcn", tablet: "yv8y4rco" }, defaultClass: "yv8y4rcn" }, 5: { conditions: { mobile: "yv8y4rcp", tablet: "yv8y4rcq" }, defaultClass: "yv8y4rcp" }, 6: { conditions: { mobile: "yv8y4rcr", tablet: "yv8y4rcs" }, defaultClass: "yv8y4rcr" }, 7: { conditions: { mobile: "yv8y4rct", tablet: "yv8y4rcu" }, defaultClass: "yv8y4rct" }, 8: { conditions: { mobile: "yv8y4rcv", tablet: "yv8y4rcw" }, defaultClass: "yv8y4rcv" }, 9: { conditions: { mobile: "yv8y4rcx", tablet: "yv8y4rcy" }, defaultClass: "yv8y4rcx" }, 10: { conditions: { mobile: "yv8y4rcz", tablet: "yv8y4rd0" }, defaultClass: "yv8y4rcz" }, 12: { conditions: { mobile: "yv8y4rd1", tablet: "yv8y4rd2" }, defaultClass: "yv8y4rd1" }, 14: { conditions: { mobile: "yv8y4rd3", tablet: "yv8y4rd4" }, defaultClass: "yv8y4rd3" }, 16: { conditions: { mobile: "yv8y4rd5", tablet: "yv8y4rd6" }, defaultClass: "yv8y4rd5" }, 20: { conditions: { mobile: "yv8y4rd7", tablet: "yv8y4rd8" }, defaultClass: "yv8y4rd7" }, 24: { conditions: { mobile: "yv8y4rd9", tablet: "yv8y4rda" }, defaultClass: "yv8y4rd9" }, 28: { conditions: { mobile: "yv8y4rdb", tablet: "yv8y4rdc" }, defaultClass: "yv8y4rdb" }, 32: { conditions: { mobile: "yv8y4rdd", tablet: "yv8y4rde" }, defaultClass: "yv8y4rdd" }, 36: { conditions: { mobile: "yv8y4rdf", tablet: "yv8y4rdg" }, defaultClass: "yv8y4rdf" }, 40: { conditions: { mobile: "yv8y4rdh", tablet: "yv8y4rdi" }, defaultClass: "yv8y4rdh" }, 44: { conditions: { mobile: "yv8y4rdj", tablet: "yv8y4rdk" }, defaultClass: "yv8y4rdj" }, 48: { conditions: { mobile: "yv8y4rdl", tablet: "yv8y4rdm" }, defaultClass: "yv8y4rdl" }, full: { conditions: { mobile: "yv8y4rdn", tablet: "yv8y4rdo" }, defaultClass: "yv8y4rdn" }, unset: { conditions: { mobile: "yv8y4rdp", tablet: "yv8y4rdq" }, defaultClass: "yv8y4rdp" }, auto: { conditions: { mobile: "yv8y4rdr", tablet: "yv8y4rds" }, defaultClass: "yv8y4rdr" }, px: { conditions: { mobile: "yv8y4rdt", tablet: "yv8y4rdu" }, defaultClass: "yv8y4rdt" }, buttonMinHeight: { conditions: { mobile: "yv8y4rdv", tablet: "yv8y4rdw" }, defaultClass: "yv8y4rdv" } } }, paddingLeft: { values: { 0: { conditions: { mobile: "yv8y4rdx", tablet: "yv8y4rdy" }, defaultClass: "yv8y4rdx" }, 1: { conditions: { mobile: "yv8y4rdz", tablet: "yv8y4re0" }, defaultClass: "yv8y4rdz" }, 2: { conditions: { mobile: "yv8y4re1", tablet: "yv8y4re2" }, defaultClass: "yv8y4re1" }, 3: { conditions: { mobile: "yv8y4re3", tablet: "yv8y4re4" }, defaultClass: "yv8y4re3" }, 4: { conditions: { mobile: "yv8y4re5", tablet: "yv8y4re6" }, defaultClass: "yv8y4re5" }, 5: { conditions: { mobile: "yv8y4re7", tablet: "yv8y4re8" }, defaultClass: "yv8y4re7" }, 6: { conditions: { mobile: "yv8y4re9", tablet: "yv8y4rea" }, defaultClass: "yv8y4re9" }, 7: { conditions: { mobile: "yv8y4reb", tablet: "yv8y4rec" }, defaultClass: "yv8y4reb" }, 8: { conditions: { mobile: "yv8y4red", tablet: "yv8y4ree" }, defaultClass: "yv8y4red" }, 9: { conditions: { mobile: "yv8y4ref", tablet: "yv8y4reg" }, defaultClass: "yv8y4ref" }, 10: { conditions: { mobile: "yv8y4reh", tablet: "yv8y4rei" }, defaultClass: "yv8y4reh" }, 12: { conditions: { mobile: "yv8y4rej", tablet: "yv8y4rek" }, defaultClass: "yv8y4rej" }, 14: { conditions: { mobile: "yv8y4rel", tablet: "yv8y4rem" }, defaultClass: "yv8y4rel" }, 16: { conditions: { mobile: "yv8y4ren", tablet: "yv8y4reo" }, defaultClass: "yv8y4ren" }, 20: { conditions: { mobile: "yv8y4rep", tablet: "yv8y4req" }, defaultClass: "yv8y4rep" }, 24: { conditions: { mobile: "yv8y4rer", tablet: "yv8y4res" }, defaultClass: "yv8y4rer" }, 28: { conditions: { mobile: "yv8y4ret", tablet: "yv8y4reu" }, defaultClass: "yv8y4ret" }, 32: { conditions: { mobile: "yv8y4rev", tablet: "yv8y4rew" }, defaultClass: "yv8y4rev" }, 36: { conditions: { mobile: "yv8y4rex", tablet: "yv8y4rey" }, defaultClass: "yv8y4rex" }, 40: { conditions: { mobile: "yv8y4rez", tablet: "yv8y4rf0" }, defaultClass: "yv8y4rez" }, 44: { conditions: { mobile: "yv8y4rf1", tablet: "yv8y4rf2" }, defaultClass: "yv8y4rf1" }, 48: { conditions: { mobile: "yv8y4rf3", tablet: "yv8y4rf4" }, defaultClass: "yv8y4rf3" }, full: { conditions: { mobile: "yv8y4rf5", tablet: "yv8y4rf6" }, defaultClass: "yv8y4rf5" }, unset: { conditions: { mobile: "yv8y4rf7", tablet: "yv8y4rf8" }, defaultClass: "yv8y4rf7" }, auto: { conditions: { mobile: "yv8y4rf9", tablet: "yv8y4rfa" }, defaultClass: "yv8y4rf9" }, px: { conditions: { mobile: "yv8y4rfb", tablet: "yv8y4rfc" }, defaultClass: "yv8y4rfb" }, buttonMinHeight: { conditions: { mobile: "yv8y4rfd", tablet: "yv8y4rfe" }, defaultClass: "yv8y4rfd" } } }, alignItems: { values: { "flex-start": { conditions: { mobile: "yv8y4rff", tablet: "yv8y4rfg" }, defaultClass: "yv8y4rff" }, "flex-end": { conditions: { mobile: "yv8y4rfh", tablet: "yv8y4rfi" }, defaultClass: "yv8y4rfh" }, center: { conditions: { mobile: "yv8y4rfj", tablet: "yv8y4rfk" }, defaultClass: "yv8y4rfj" }, stretch: { conditions: { mobile: "yv8y4rfl", tablet: "yv8y4rfm" }, defaultClass: "yv8y4rfl" } } }, alignSelf: { values: { auto: { conditions: { mobile: "yv8y4rfn", tablet: "yv8y4rfo" }, defaultClass: "yv8y4rfn" }, "flex-start": { conditions: { mobile: "yv8y4rfp", tablet: "yv8y4rfq" }, defaultClass: "yv8y4rfp" }, "flex-end": { conditions: { mobile: "yv8y4rfr", tablet: "yv8y4rfs" }, defaultClass: "yv8y4rfr" }, center: { conditions: { mobile: "yv8y4rft", tablet: "yv8y4rfu" }, defaultClass: "yv8y4rft" }, stretch: { conditions: { mobile: "yv8y4rfv", tablet: "yv8y4rfw" }, defaultClass: "yv8y4rfv" } } }, justifyContent: { values: { "flex-start": { conditions: { mobile: "yv8y4rfx", tablet: "yv8y4rfy" }, defaultClass: "yv8y4rfx" }, "flex-end": { conditions: { mobile: "yv8y4rfz", tablet: "yv8y4rg0" }, defaultClass: "yv8y4rfz" }, center: { conditions: { mobile: "yv8y4rg1", tablet: "yv8y4rg2" }, defaultClass: "yv8y4rg1" }, "space-between": { conditions: { mobile: "yv8y4rg3", tablet: "yv8y4rg4" }, defaultClass: "yv8y4rg3" } } }, flexDirection: { values: { row: { conditions: { mobile: "yv8y4rg5", tablet: "yv8y4rg6" }, defaultClass: "yv8y4rg5" }, column: { conditions: { mobile: "yv8y4rg7", tablet: "yv8y4rg8" }, defaultClass: "yv8y4rg7" }, "row-reverse": { conditions: { mobile: "yv8y4rg9", tablet: "yv8y4rga" }, defaultClass: "yv8y4rg9" }, "column-reverse": { conditions: { mobile: "yv8y4rgb", tablet: "yv8y4rgc" }, defaultClass: "yv8y4rgb" } } }, flexWrap: { values: { wrap: { conditions: { mobile: "yv8y4rgd", tablet: "yv8y4rge" }, defaultClass: "yv8y4rgd" }, nowrap: { conditions: { mobile: "yv8y4rgf", tablet: "yv8y4rgg" }, defaultClass: "yv8y4rgf" } } }, height: { values: { 0: { conditions: { mobile: "yv8y4rgh", tablet: "yv8y4rgi" }, defaultClass: "yv8y4rgh" }, 1: { conditions: { mobile: "yv8y4rgj", tablet: "yv8y4rgk" }, defaultClass: "yv8y4rgj" }, 2: { conditions: { mobile: "yv8y4rgl", tablet: "yv8y4rgm" }, defaultClass: "yv8y4rgl" }, 3: { conditions: { mobile: "yv8y4rgn", tablet: "yv8y4rgo" }, defaultClass: "yv8y4rgn" }, 4: { conditions: { mobile: "yv8y4rgp", tablet: "yv8y4rgq" }, defaultClass: "yv8y4rgp" }, 5: { conditions: { mobile: "yv8y4rgr", tablet: "yv8y4rgs" }, defaultClass: "yv8y4rgr" }, 6: { conditions: { mobile: "yv8y4rgt", tablet: "yv8y4rgu" }, defaultClass: "yv8y4rgt" }, 7: { conditions: { mobile: "yv8y4rgv", tablet: "yv8y4rgw" }, defaultClass: "yv8y4rgv" }, 8: { conditions: { mobile: "yv8y4rgx", tablet: "yv8y4rgy" }, defaultClass: "yv8y4rgx" }, 9: { conditions: { mobile: "yv8y4rgz", tablet: "yv8y4rh0" }, defaultClass: "yv8y4rgz" }, 10: { conditions: { mobile: "yv8y4rh1", tablet: "yv8y4rh2" }, defaultClass: "yv8y4rh1" }, 12: { conditions: { mobile: "yv8y4rh3", tablet: "yv8y4rh4" }, defaultClass: "yv8y4rh3" }, 14: { conditions: { mobile: "yv8y4rh5", tablet: "yv8y4rh6" }, defaultClass: "yv8y4rh5" }, 16: { conditions: { mobile: "yv8y4rh7", tablet: "yv8y4rh8" }, defaultClass: "yv8y4rh7" }, 20: { conditions: { mobile: "yv8y4rh9", tablet: "yv8y4rha" }, defaultClass: "yv8y4rh9" }, 24: { conditions: { mobile: "yv8y4rhb", tablet: "yv8y4rhc" }, defaultClass: "yv8y4rhb" }, 28: { conditions: { mobile: "yv8y4rhd", tablet: "yv8y4rhe" }, defaultClass: "yv8y4rhd" }, 32: { conditions: { mobile: "yv8y4rhf", tablet: "yv8y4rhg" }, defaultClass: "yv8y4rhf" }, 36: { conditions: { mobile: "yv8y4rhh", tablet: "yv8y4rhi" }, defaultClass: "yv8y4rhh" }, 40: { conditions: { mobile: "yv8y4rhj", tablet: "yv8y4rhk" }, defaultClass: "yv8y4rhj" }, 44: { conditions: { mobile: "yv8y4rhl", tablet: "yv8y4rhm" }, defaultClass: "yv8y4rhl" }, 48: { conditions: { mobile: "yv8y4rhn", tablet: "yv8y4rho" }, defaultClass: "yv8y4rhn" }, full: { conditions: { mobile: "yv8y4rhp", tablet: "yv8y4rhq" }, defaultClass: "yv8y4rhp" }, unset: { conditions: { mobile: "yv8y4rhr", tablet: "yv8y4rhs" }, defaultClass: "yv8y4rhr" }, auto: { conditions: { mobile: "yv8y4rht", tablet: "yv8y4rhu" }, defaultClass: "yv8y4rht" }, px: { conditions: { mobile: "yv8y4rhv", tablet: "yv8y4rhw" }, defaultClass: "yv8y4rhv" }, buttonMinHeight: { conditions: { mobile: "yv8y4rhx", tablet: "yv8y4rhy" }, defaultClass: "yv8y4rhx" } } }, width: { values: { 0: { conditions: { mobile: "yv8y4rhz", tablet: "yv8y4ri0" }, defaultClass: "yv8y4rhz" }, 1: { conditions: { mobile: "yv8y4ri1", tablet: "yv8y4ri2" }, defaultClass: "yv8y4ri1" }, 2: { conditions: { mobile: "yv8y4ri3", tablet: "yv8y4ri4" }, defaultClass: "yv8y4ri3" }, 3: { conditions: { mobile: "yv8y4ri5", tablet: "yv8y4ri6" }, defaultClass: "yv8y4ri5" }, 4: { conditions: { mobile: "yv8y4ri7", tablet: "yv8y4ri8" }, defaultClass: "yv8y4ri7" }, 5: { conditions: { mobile: "yv8y4ri9", tablet: "yv8y4ria" }, defaultClass: "yv8y4ri9" }, 6: { conditions: { mobile: "yv8y4rib", tablet: "yv8y4ric" }, defaultClass: "yv8y4rib" }, 7: { conditions: { mobile: "yv8y4rid", tablet: "yv8y4rie" }, defaultClass: "yv8y4rid" }, 8: { conditions: { mobile: "yv8y4rif", tablet: "yv8y4rig" }, defaultClass: "yv8y4rif" }, 9: { conditions: { mobile: "yv8y4rih", tablet: "yv8y4rii" }, defaultClass: "yv8y4rih" }, 10: { conditions: { mobile: "yv8y4rij", tablet: "yv8y4rik" }, defaultClass: "yv8y4rij" }, 12: { conditions: { mobile: "yv8y4ril", tablet: "yv8y4rim" }, defaultClass: "yv8y4ril" }, 14: { conditions: { mobile: "yv8y4rin", tablet: "yv8y4rio" }, defaultClass: "yv8y4rin" }, 16: { conditions: { mobile: "yv8y4rip", tablet: "yv8y4riq" }, defaultClass: "yv8y4rip" }, 20: { conditions: { mobile: "yv8y4rir", tablet: "yv8y4ris" }, defaultClass: "yv8y4rir" }, 24: { conditions: { mobile: "yv8y4rit", tablet: "yv8y4riu" }, defaultClass: "yv8y4rit" }, 28: { conditions: { mobile: "yv8y4riv", tablet: "yv8y4riw" }, defaultClass: "yv8y4riv" }, 32: { conditions: { mobile: "yv8y4rix", tablet: "yv8y4riy" }, defaultClass: "yv8y4rix" }, 36: { conditions: { mobile: "yv8y4riz", tablet: "yv8y4rj0" }, defaultClass: "yv8y4riz" }, 40: { conditions: { mobile: "yv8y4rj1", tablet: "yv8y4rj2" }, defaultClass: "yv8y4rj1" }, 44: { conditions: { mobile: "yv8y4rj3", tablet: "yv8y4rj4" }, defaultClass: "yv8y4rj3" }, 48: { conditions: { mobile: "yv8y4rj5", tablet: "yv8y4rj6" }, defaultClass: "yv8y4rj5" }, full: { conditions: { mobile: "yv8y4rj7", tablet: "yv8y4rj8" }, defaultClass: "yv8y4rj7" }, unset: { conditions: { mobile: "yv8y4rj9", tablet: "yv8y4rja" }, defaultClass: "yv8y4rj9" }, auto: { conditions: { mobile: "yv8y4rjb", tablet: "yv8y4rjc" }, defaultClass: "yv8y4rjb" }, px: { conditions: { mobile: "yv8y4rjd", tablet: "yv8y4rje" }, defaultClass: "yv8y4rjd" }, buttonMinHeight: { conditions: { mobile: "yv8y4rjf", tablet: "yv8y4rjg" }, defaultClass: "yv8y4rjf" } } }, minWidth: { values: { 0: { conditions: { mobile: "yv8y4rjh", tablet: "yv8y4rji" }, defaultClass: "yv8y4rjh" }, 1: { conditions: { mobile: "yv8y4rjj", tablet: "yv8y4rjk" }, defaultClass: "yv8y4rjj" }, 2: { conditions: { mobile: "yv8y4rjl", tablet: "yv8y4rjm" }, defaultClass: "yv8y4rjl" }, 3: { conditions: { mobile: "yv8y4rjn", tablet: "yv8y4rjo" }, defaultClass: "yv8y4rjn" }, 4: { conditions: { mobile: "yv8y4rjp", tablet: "yv8y4rjq" }, defaultClass: "yv8y4rjp" }, 5: { conditions: { mobile: "yv8y4rjr", tablet: "yv8y4rjs" }, defaultClass: "yv8y4rjr" }, 6: { conditions: { mobile: "yv8y4rjt", tablet: "yv8y4rju" }, defaultClass: "yv8y4rjt" }, 7: { conditions: { mobile: "yv8y4rjv", tablet: "yv8y4rjw" }, defaultClass: "yv8y4rjv" }, 8: { conditions: { mobile: "yv8y4rjx", tablet: "yv8y4rjy" }, defaultClass: "yv8y4rjx" }, 9: { conditions: { mobile: "yv8y4rjz", tablet: "yv8y4rk0" }, defaultClass: "yv8y4rjz" }, 10: { conditions: { mobile: "yv8y4rk1", tablet: "yv8y4rk2" }, defaultClass: "yv8y4rk1" }, 12: { conditions: { mobile: "yv8y4rk3", tablet: "yv8y4rk4" }, defaultClass: "yv8y4rk3" }, 14: { conditions: { mobile: "yv8y4rk5", tablet: "yv8y4rk6" }, defaultClass: "yv8y4rk5" }, 16: { conditions: { mobile: "yv8y4rk7", tablet: "yv8y4rk8" }, defaultClass: "yv8y4rk7" }, 20: { conditions: { mobile: "yv8y4rk9", tablet: "yv8y4rka" }, defaultClass: "yv8y4rk9" }, 24: { conditions: { mobile: "yv8y4rkb", tablet: "yv8y4rkc" }, defaultClass: "yv8y4rkb" }, 28: { conditions: { mobile: "yv8y4rkd", tablet: "yv8y4rke" }, defaultClass: "yv8y4rkd" }, 32: { conditions: { mobile: "yv8y4rkf", tablet: "yv8y4rkg" }, defaultClass: "yv8y4rkf" }, 36: { conditions: { mobile: "yv8y4rkh", tablet: "yv8y4rki" }, defaultClass: "yv8y4rkh" }, 40: { conditions: { mobile: "yv8y4rkj", tablet: "yv8y4rkk" }, defaultClass: "yv8y4rkj" }, 44: { conditions: { mobile: "yv8y4rkl", tablet: "yv8y4rkm" }, defaultClass: "yv8y4rkl" }, 48: { conditions: { mobile: "yv8y4rkn", tablet: "yv8y4rko" }, defaultClass: "yv8y4rkn" }, full: { conditions: { mobile: "yv8y4rkp", tablet: "yv8y4rkq" }, defaultClass: "yv8y4rkp" }, unset: { conditions: { mobile: "yv8y4rkr", tablet: "yv8y4rks" }, defaultClass: "yv8y4rkr" }, auto: { conditions: { mobile: "yv8y4rkt", tablet: "yv8y4rku" }, defaultClass: "yv8y4rkt" }, px: { conditions: { mobile: "yv8y4rkv", tablet: "yv8y4rkw" }, defaultClass: "yv8y4rkv" }, buttonMinHeight: { conditions: { mobile: "yv8y4rkx", tablet: "yv8y4rky" }, defaultClass: "yv8y4rkx" } } }, minHeight: { values: { 0: { conditions: { mobile: "yv8y4rkz", tablet: "yv8y4rl0" }, defaultClass: "yv8y4rkz" }, 1: { conditions: { mobile: "yv8y4rl1", tablet: "yv8y4rl2" }, defaultClass: "yv8y4rl1" }, 2: { conditions: { mobile: "yv8y4rl3", tablet: "yv8y4rl4" }, defaultClass: "yv8y4rl3" }, 3: { conditions: { mobile: "yv8y4rl5", tablet: "yv8y4rl6" }, defaultClass: "yv8y4rl5" }, 4: { conditions: { mobile: "yv8y4rl7", tablet: "yv8y4rl8" }, defaultClass: "yv8y4rl7" }, 5: { conditions: { mobile: "yv8y4rl9", tablet: "yv8y4rla" }, defaultClass: "yv8y4rl9" }, 6: { conditions: { mobile: "yv8y4rlb", tablet: "yv8y4rlc" }, defaultClass: "yv8y4rlb" }, 7: { conditions: { mobile: "yv8y4rld", tablet: "yv8y4rle" }, defaultClass: "yv8y4rld" }, 8: { conditions: { mobile: "yv8y4rlf", tablet: "yv8y4rlg" }, defaultClass: "yv8y4rlf" }, 9: { conditions: { mobile: "yv8y4rlh", tablet: "yv8y4rli" }, defaultClass: "yv8y4rlh" }, 10: { conditions: { mobile: "yv8y4rlj", tablet: "yv8y4rlk" }, defaultClass: "yv8y4rlj" }, 12: { conditions: { mobile: "yv8y4rll", tablet: "yv8y4rlm" }, defaultClass: "yv8y4rll" }, 14: { conditions: { mobile: "yv8y4rln", tablet: "yv8y4rlo" }, defaultClass: "yv8y4rln" }, 16: { conditions: { mobile: "yv8y4rlp", tablet: "yv8y4rlq" }, defaultClass: "yv8y4rlp" }, 20: { conditions: { mobile: "yv8y4rlr", tablet: "yv8y4rls" }, defaultClass: "yv8y4rlr" }, 24: { conditions: { mobile: "yv8y4rlt", tablet: "yv8y4rlu" }, defaultClass: "yv8y4rlt" }, 28: { conditions: { mobile: "yv8y4rlv", tablet: "yv8y4rlw" }, defaultClass: "yv8y4rlv" }, 32: { conditions: { mobile: "yv8y4rlx", tablet: "yv8y4rly" }, defaultClass: "yv8y4rlx" }, 36: { conditions: { mobile: "yv8y4rlz", tablet: "yv8y4rm0" }, defaultClass: "yv8y4rlz" }, 40: { conditions: { mobile: "yv8y4rm1", tablet: "yv8y4rm2" }, defaultClass: "yv8y4rm1" }, 44: { conditions: { mobile: "yv8y4rm3", tablet: "yv8y4rm4" }, defaultClass: "yv8y4rm3" }, 48: { conditions: { mobile: "yv8y4rm5", tablet: "yv8y4rm6" }, defaultClass: "yv8y4rm5" }, full: { conditions: { mobile: "yv8y4rm7", tablet: "yv8y4rm8" }, defaultClass: "yv8y4rm7" }, unset: { conditions: { mobile: "yv8y4rm9", tablet: "yv8y4rma" }, defaultClass: "yv8y4rm9" }, auto: { conditions: { mobile: "yv8y4rmb", tablet: "yv8y4rmc" }, defaultClass: "yv8y4rmb" }, px: { conditions: { mobile: "yv8y4rmd", tablet: "yv8y4rme" }, defaultClass: "yv8y4rmd" }, buttonMinHeight: { conditions: { mobile: "yv8y4rmf", tablet: "yv8y4rmg" }, defaultClass: "yv8y4rmf" } } }, maxWidth: { values: { 0: { conditions: { mobile: "yv8y4rmh", tablet: "yv8y4rmi" }, defaultClass: "yv8y4rmh" }, 1: { conditions: { mobile: "yv8y4rmj", tablet: "yv8y4rmk" }, defaultClass: "yv8y4rmj" }, 2: { conditions: { mobile: "yv8y4rml", tablet: "yv8y4rmm" }, defaultClass: "yv8y4rml" }, 3: { conditions: { mobile: "yv8y4rmn", tablet: "yv8y4rmo" }, defaultClass: "yv8y4rmn" }, 4: { conditions: { mobile: "yv8y4rmp", tablet: "yv8y4rmq" }, defaultClass: "yv8y4rmp" }, 5: { conditions: { mobile: "yv8y4rmr", tablet: "yv8y4rms" }, defaultClass: "yv8y4rmr" }, 6: { conditions: { mobile: "yv8y4rmt", tablet: "yv8y4rmu" }, defaultClass: "yv8y4rmt" }, 7: { conditions: { mobile: "yv8y4rmv", tablet: "yv8y4rmw" }, defaultClass: "yv8y4rmv" }, 8: { conditions: { mobile: "yv8y4rmx", tablet: "yv8y4rmy" }, defaultClass: "yv8y4rmx" }, 9: { conditions: { mobile: "yv8y4rmz", tablet: "yv8y4rn0" }, defaultClass: "yv8y4rmz" }, 10: { conditions: { mobile: "yv8y4rn1", tablet: "yv8y4rn2" }, defaultClass: "yv8y4rn1" }, 12: { conditions: { mobile: "yv8y4rn3", tablet: "yv8y4rn4" }, defaultClass: "yv8y4rn3" }, 14: { conditions: { mobile: "yv8y4rn5", tablet: "yv8y4rn6" }, defaultClass: "yv8y4rn5" }, 16: { conditions: { mobile: "yv8y4rn7", tablet: "yv8y4rn8" }, defaultClass: "yv8y4rn7" }, 20: { conditions: { mobile: "yv8y4rn9", tablet: "yv8y4rna" }, defaultClass: "yv8y4rn9" }, 24: { conditions: { mobile: "yv8y4rnb", tablet: "yv8y4rnc" }, defaultClass: "yv8y4rnb" }, 28: { conditions: { mobile: "yv8y4rnd", tablet: "yv8y4rne" }, defaultClass: "yv8y4rnd" }, 32: { conditions: { mobile: "yv8y4rnf", tablet: "yv8y4rng" }, defaultClass: "yv8y4rnf" }, 36: { conditions: { mobile: "yv8y4rnh", tablet: "yv8y4rni" }, defaultClass: "yv8y4rnh" }, 40: { conditions: { mobile: "yv8y4rnj", tablet: "yv8y4rnk" }, defaultClass: "yv8y4rnj" }, 44: { conditions: { mobile: "yv8y4rnl", tablet: "yv8y4rnm" }, defaultClass: "yv8y4rnl" }, 48: { conditions: { mobile: "yv8y4rnn", tablet: "yv8y4rno" }, defaultClass: "yv8y4rnn" }, full: { conditions: { mobile: "yv8y4rnp", tablet: "yv8y4rnq" }, defaultClass: "yv8y4rnp" }, unset: { conditions: { mobile: "yv8y4rnr", tablet: "yv8y4rns" }, defaultClass: "yv8y4rnr" }, auto: { conditions: { mobile: "yv8y4rnt", tablet: "yv8y4rnu" }, defaultClass: "yv8y4rnt" }, px: { conditions: { mobile: "yv8y4rnv", tablet: "yv8y4rnw" }, defaultClass: "yv8y4rnv" }, buttonMinHeight: { conditions: { mobile: "yv8y4rnx", tablet: "yv8y4rny" }, defaultClass: "yv8y4rnx" } } }, maxHeight: { values: { 0: { conditions: { mobile: "yv8y4rnz", tablet: "yv8y4ro0" }, defaultClass: "yv8y4rnz" }, 1: { conditions: { mobile: "yv8y4ro1", tablet: "yv8y4ro2" }, defaultClass: "yv8y4ro1" }, 2: { conditions: { mobile: "yv8y4ro3", tablet: "yv8y4ro4" }, defaultClass: "yv8y4ro3" }, 3: { conditions: { mobile: "yv8y4ro5", tablet: "yv8y4ro6" }, defaultClass: "yv8y4ro5" }, 4: { conditions: { mobile: "yv8y4ro7", tablet: "yv8y4ro8" }, defaultClass: "yv8y4ro7" }, 5: { conditions: { mobile: "yv8y4ro9", tablet: "yv8y4roa" }, defaultClass: "yv8y4ro9" }, 6: { conditions: { mobile: "yv8y4rob", tablet: "yv8y4roc" }, defaultClass: "yv8y4rob" }, 7: { conditions: { mobile: "yv8y4rod", tablet: "yv8y4roe" }, defaultClass: "yv8y4rod" }, 8: { conditions: { mobile: "yv8y4rof", tablet: "yv8y4rog" }, defaultClass: "yv8y4rof" }, 9: { conditions: { mobile: "yv8y4roh", tablet: "yv8y4roi" }, defaultClass: "yv8y4roh" }, 10: { conditions: { mobile: "yv8y4roj", tablet: "yv8y4rok" }, defaultClass: "yv8y4roj" }, 12: { conditions: { mobile: "yv8y4rol", tablet: "yv8y4rom" }, defaultClass: "yv8y4rol" }, 14: { conditions: { mobile: "yv8y4ron", tablet: "yv8y4roo" }, defaultClass: "yv8y4ron" }, 16: { conditions: { mobile: "yv8y4rop", tablet: "yv8y4roq" }, defaultClass: "yv8y4rop" }, 20: { conditions: { mobile: "yv8y4ror", tablet: "yv8y4ros" }, defaultClass: "yv8y4ror" }, 24: { conditions: { mobile: "yv8y4rot", tablet: "yv8y4rou" }, defaultClass: "yv8y4rot" }, 28: { conditions: { mobile: "yv8y4rov", tablet: "yv8y4row" }, defaultClass: "yv8y4rov" }, 32: { conditions: { mobile: "yv8y4rox", tablet: "yv8y4roy" }, defaultClass: "yv8y4rox" }, 36: { conditions: { mobile: "yv8y4roz", tablet: "yv8y4rp0" }, defaultClass: "yv8y4roz" }, 40: { conditions: { mobile: "yv8y4rp1", tablet: "yv8y4rp2" }, defaultClass: "yv8y4rp1" }, 44: { conditions: { mobile: "yv8y4rp3", tablet: "yv8y4rp4" }, defaultClass: "yv8y4rp3" }, 48: { conditions: { mobile: "yv8y4rp5", tablet: "yv8y4rp6" }, defaultClass: "yv8y4rp5" }, full: { conditions: { mobile: "yv8y4rp7", tablet: "yv8y4rp8" }, defaultClass: "yv8y4rp7" }, unset: { conditions: { mobile: "yv8y4rp9", tablet: "yv8y4rpa" }, defaultClass: "yv8y4rp9" }, auto: { conditions: { mobile: "yv8y4rpb", tablet: "yv8y4rpc" }, defaultClass: "yv8y4rpb" }, px: { conditions: { mobile: "yv8y4rpd", tablet: "yv8y4rpe" }, defaultClass: "yv8y4rpd" }, buttonMinHeight: { conditions: { mobile: "yv8y4rpf", tablet: "yv8y4rpg" }, defaultClass: "yv8y4rpf" } } }, gap: { values: { 0: { conditions: { mobile: "yv8y4rph", tablet: "yv8y4rpi" }, defaultClass: "yv8y4rph" }, 1: { conditions: { mobile: "yv8y4rpj", tablet: "yv8y4rpk" }, defaultClass: "yv8y4rpj" }, 2: { conditions: { mobile: "yv8y4rpl", tablet: "yv8y4rpm" }, defaultClass: "yv8y4rpl" }, 3: { conditions: { mobile: "yv8y4rpn", tablet: "yv8y4rpo" }, defaultClass: "yv8y4rpn" }, 4: { conditions: { mobile: "yv8y4rpp", tablet: "yv8y4rpq" }, defaultClass: "yv8y4rpp" }, 5: { conditions: { mobile: "yv8y4rpr", tablet: "yv8y4rps" }, defaultClass: "yv8y4rpr" }, 6: { conditions: { mobile: "yv8y4rpt", tablet: "yv8y4rpu" }, defaultClass: "yv8y4rpt" }, 7: { conditions: { mobile: "yv8y4rpv", tablet: "yv8y4rpw" }, defaultClass: "yv8y4rpv" }, 8: { conditions: { mobile: "yv8y4rpx", tablet: "yv8y4rpy" }, defaultClass: "yv8y4rpx" }, 9: { conditions: { mobile: "yv8y4rpz", tablet: "yv8y4rq0" }, defaultClass: "yv8y4rpz" }, 10: { conditions: { mobile: "yv8y4rq1", tablet: "yv8y4rq2" }, defaultClass: "yv8y4rq1" }, 12: { conditions: { mobile: "yv8y4rq3", tablet: "yv8y4rq4" }, defaultClass: "yv8y4rq3" }, 14: { conditions: { mobile: "yv8y4rq5", tablet: "yv8y4rq6" }, defaultClass: "yv8y4rq5" }, 16: { conditions: { mobile: "yv8y4rq7", tablet: "yv8y4rq8" }, defaultClass: "yv8y4rq7" }, 20: { conditions: { mobile: "yv8y4rq9", tablet: "yv8y4rqa" }, defaultClass: "yv8y4rq9" }, 24: { conditions: { mobile: "yv8y4rqb", tablet: "yv8y4rqc" }, defaultClass: "yv8y4rqb" }, 28: { conditions: { mobile: "yv8y4rqd", tablet: "yv8y4rqe" }, defaultClass: "yv8y4rqd" }, 32: { conditions: { mobile: "yv8y4rqf", tablet: "yv8y4rqg" }, defaultClass: "yv8y4rqf" }, 36: { conditions: { mobile: "yv8y4rqh", tablet: "yv8y4rqi" }, defaultClass: "yv8y4rqh" }, 40: { conditions: { mobile: "yv8y4rqj", tablet: "yv8y4rqk" }, defaultClass: "yv8y4rqj" }, 44: { conditions: { mobile: "yv8y4rql", tablet: "yv8y4rqm" }, defaultClass: "yv8y4rql" }, 48: { conditions: { mobile: "yv8y4rqn", tablet: "yv8y4rqo" }, defaultClass: "yv8y4rqn" }, full: { conditions: { mobile: "yv8y4rqp", tablet: "yv8y4rqq" }, defaultClass: "yv8y4rqp" }, unset: { conditions: { mobile: "yv8y4rqr", tablet: "yv8y4rqs" }, defaultClass: "yv8y4rqr" }, auto: { conditions: { mobile: "yv8y4rqt", tablet: "yv8y4rqu" }, defaultClass: "yv8y4rqt" }, px: { conditions: { mobile: "yv8y4rqv", tablet: "yv8y4rqw" }, defaultClass: "yv8y4rqv" }, buttonMinHeight: { conditions: { mobile: "yv8y4rqx", tablet: "yv8y4rqy" }, defaultClass: "yv8y4rqx" } } } } }, { conditions: { defaultCondition: ["dark", "light"], conditionNames: ["light", "dark"], responsiveArray: void 0 }, styles: { color: { values: { white: { conditions: { light: "yv8y4rqz", dark: "yv8y4rr0" }, defaultClass: "yv8y4rqz yv8y4rr0" }, black: { conditions: { light: "yv8y4rr1", dark: "yv8y4rr2" }, defaultClass: "yv8y4rr1 yv8y4rr2" }, transparent: { conditions: { light: "yv8y4rr3", dark: "yv8y4rr4" }, defaultClass: "yv8y4rr3 yv8y4rr4" }, primary: { conditions: { light: "yv8y4rr5", dark: "yv8y4rr6" }, defaultClass: "yv8y4rr5 yv8y4rr6" }, accent: { conditions: { light: "yv8y4rr7", dark: "yv8y4rr8" }, defaultClass: "yv8y4rr7 yv8y4rr8" }, disabled: { conditions: { light: "yv8y4rr9", dark: "yv8y4rra" }, defaultClass: "yv8y4rr9 yv8y4rra" }, text: { conditions: { light: "yv8y4rrb", dark: "yv8y4rrc" }, defaultClass: "yv8y4rrb yv8y4rrc" }, textMuted: { conditions: { light: "yv8y4rrd", dark: "yv8y4rre" }, defaultClass: "yv8y4rrd yv8y4rre" }, textDanger: { conditions: { light: "yv8y4rrf", dark: "yv8y4rrg" }, defaultClass: "yv8y4rrf yv8y4rrg" }, background: { conditions: { light: "yv8y4rrh", dark: "yv8y4rri" }, defaultClass: "yv8y4rrh yv8y4rri" }, backgroundMuted: { conditions: { light: "yv8y4rrj", dark: "yv8y4rrk" }, defaultClass: "yv8y4rrj yv8y4rrk" }, tokenSelectBackground: { conditions: { light: "yv8y4rrl", dark: "yv8y4rrm" }, defaultClass: "yv8y4rrl yv8y4rrm" }, tokenSelectHoverBackground: { conditions: { light: "yv8y4rrn", dark: "yv8y4rro" }, defaultClass: "yv8y4rrn yv8y4rro" }, tokenSelect: { conditions: { light: "yv8y4rrp", dark: "yv8y4rrq" }, defaultClass: "yv8y4rrp yv8y4rrq" }, skeletonLoaderBase: { conditions: { light: "yv8y4rrr", dark: "yv8y4rrs" }, defaultClass: "yv8y4rrr yv8y4rrs" }, skeletonLoaderHighlight: { conditions: { light: "yv8y4rrt", dark: "yv8y4rru" }, defaultClass: "yv8y4rrt yv8y4rru" }, tabBorder: { conditions: { light: "yv8y4rrv", dark: "yv8y4rrw" }, defaultClass: "yv8y4rrv yv8y4rrw" }, stakeSectionBackground: { conditions: { light: "yv8y4rrx", dark: "yv8y4rry" }, defaultClass: "yv8y4rrx yv8y4rry" }, dropdownBackground: { conditions: { light: "yv8y4rrz", dark: "yv8y4rs0" }, defaultClass: "yv8y4rrz yv8y4rs0" }, selectValidatorMultiSelectedBackground: { conditions: { light: "yv8y4rs1", dark: "yv8y4rs2" }, defaultClass: "yv8y4rs1 yv8y4rs2" }, selectValidatorMultiDefaultBackground: { conditions: { light: "yv8y4rs3", dark: "yv8y4rs4" }, defaultClass: "yv8y4rs3 yv8y4rs4" }, warningBoxBackground: { conditions: { light: "yv8y4rs5", dark: "yv8y4rs6" }, defaultClass: "yv8y4rs5 yv8y4rs6" }, positionsSectionBackgroundColor: { conditions: { light: "yv8y4rs7", dark: "yv8y4rs8" }, defaultClass: "yv8y4rs7 yv8y4rs8" }, positionsSectionBorderColor: { conditions: { light: "yv8y4rs9", dark: "yv8y4rsa" }, defaultClass: "yv8y4rs9 yv8y4rsa" }, positionsSectionDividerColor: { conditions: { light: "yv8y4rsb", dark: "yv8y4rsc" }, defaultClass: "yv8y4rsb yv8y4rsc" }, positionsClaimRewardsBackground: { conditions: { light: "yv8y4rsd", dark: "yv8y4rse" }, defaultClass: "yv8y4rsd yv8y4rse" }, positionsActionRequiredBackground: { conditions: { light: "yv8y4rsf", dark: "yv8y4rsg" }, defaultClass: "yv8y4rsf yv8y4rsg" }, positionsPendingBackground: { conditions: { light: "yv8y4rsh", dark: "yv8y4rsi" }, defaultClass: "yv8y4rsh yv8y4rsi" }, modalOverlayBackground: { conditions: { light: "yv8y4rsj", dark: "yv8y4rsk" }, defaultClass: "yv8y4rsj yv8y4rsk" }, modalBodyBackground: { conditions: { light: "yv8y4rsl", dark: "yv8y4rsm" }, defaultClass: "yv8y4rsl yv8y4rsm" }, tooltipBackground: { conditions: { light: "yv8y4rsn", dark: "yv8y4rso" }, defaultClass: "yv8y4rsn yv8y4rso" }, primaryButtonColor: { conditions: { light: "yv8y4rsp", dark: "yv8y4rsq" }, defaultClass: "yv8y4rsp yv8y4rsq" }, primaryButtonBackground: { conditions: { light: "yv8y4rsr", dark: "yv8y4rss" }, defaultClass: "yv8y4rsr yv8y4rss" }, primaryButtonOutline: { conditions: { light: "yv8y4rst", dark: "yv8y4rsu" }, defaultClass: "yv8y4rst yv8y4rsu" }, primaryButtonHoverColor: { conditions: { light: "yv8y4rsv", dark: "yv8y4rsw" }, defaultClass: "yv8y4rsv yv8y4rsw" }, primaryButtonHoverBackground: { conditions: { light: "yv8y4rsx", dark: "yv8y4rsy" }, defaultClass: "yv8y4rsx yv8y4rsy" }, primaryButtonHoverOutline: { conditions: { light: "yv8y4rsz", dark: "yv8y4rt0" }, defaultClass: "yv8y4rsz yv8y4rt0" }, primaryButtonActiveColor: { conditions: { light: "yv8y4rt1", dark: "yv8y4rt2" }, defaultClass: "yv8y4rt1 yv8y4rt2" }, primaryButtonActiveBackground: { conditions: { light: "yv8y4rt3", dark: "yv8y4rt4" }, defaultClass: "yv8y4rt3 yv8y4rt4" }, primaryButtonActiveOutline: { conditions: { light: "yv8y4rt5", dark: "yv8y4rt6" }, defaultClass: "yv8y4rt5 yv8y4rt6" }, secondaryButtonColor: { conditions: { light: "yv8y4rt7", dark: "yv8y4rt8" }, defaultClass: "yv8y4rt7 yv8y4rt8" }, secondaryButtonBackground: { conditions: { light: "yv8y4rt9", dark: "yv8y4rta" }, defaultClass: "yv8y4rt9 yv8y4rta" }, secondaryButtonOutline: { conditions: { light: "yv8y4rtb", dark: "yv8y4rtc" }, defaultClass: "yv8y4rtb yv8y4rtc" }, secondaryButtonHoverColor: { conditions: { light: "yv8y4rtd", dark: "yv8y4rte" }, defaultClass: "yv8y4rtd yv8y4rte" }, secondaryButtonHoverBackground: { conditions: { light: "yv8y4rtf", dark: "yv8y4rtg" }, defaultClass: "yv8y4rtf yv8y4rtg" }, secondaryButtonHoverOutline: { conditions: { light: "yv8y4rth", dark: "yv8y4rti" }, defaultClass: "yv8y4rth yv8y4rti" }, secondaryButtonActiveColor: { conditions: { light: "yv8y4rtj", dark: "yv8y4rtk" }, defaultClass: "yv8y4rtj yv8y4rtk" }, secondaryButtonActiveBackground: { conditions: { light: "yv8y4rtl", dark: "yv8y4rtm" }, defaultClass: "yv8y4rtl yv8y4rtm" }, secondaryButtonActiveOutline: { conditions: { light: "yv8y4rtn", dark: "yv8y4rto" }, defaultClass: "yv8y4rtn yv8y4rto" }, smallButtonColor: { conditions: { light: "yv8y4rtp", dark: "yv8y4rtq" }, defaultClass: "yv8y4rtp yv8y4rtq" }, smallButtonBackground: { conditions: { light: "yv8y4rtr", dark: "yv8y4rts" }, defaultClass: "yv8y4rtr yv8y4rts" }, smallButtonOutline: { conditions: { light: "yv8y4rtt", dark: "yv8y4rtu" }, defaultClass: "yv8y4rtt yv8y4rtu" }, smallButtonHoverColor: { conditions: { light: "yv8y4rtv", dark: "yv8y4rtw" }, defaultClass: "yv8y4rtv yv8y4rtw" }, smallButtonHoverBackground: { conditions: { light: "yv8y4rtx", dark: "yv8y4rty" }, defaultClass: "yv8y4rtx yv8y4rty" }, smallButtonHoverOutline: { conditions: { light: "yv8y4rtz", dark: "yv8y4ru0" }, defaultClass: "yv8y4rtz yv8y4ru0" }, smallButtonActiveColor: { conditions: { light: "yv8y4ru1", dark: "yv8y4ru2" }, defaultClass: "yv8y4ru1 yv8y4ru2" }, smallButtonActiveBackground: { conditions: { light: "yv8y4ru3", dark: "yv8y4ru4" }, defaultClass: "yv8y4ru3 yv8y4ru4" }, smallButtonActiveOutline: { conditions: { light: "yv8y4ru5", dark: "yv8y4ru6" }, defaultClass: "yv8y4ru5 yv8y4ru6" }, smallLightButtonColor: { conditions: { light: "yv8y4ru7", dark: "yv8y4ru8" }, defaultClass: "yv8y4ru7 yv8y4ru8" }, smallLightButtonBackground: { conditions: { light: "yv8y4ru9", dark: "yv8y4rua" }, defaultClass: "yv8y4ru9 yv8y4rua" }, smallLightButtonOutline: { conditions: { light: "yv8y4rub", dark: "yv8y4ruc" }, defaultClass: "yv8y4rub yv8y4ruc" }, smallLightButtonHoverColor: { conditions: { light: "yv8y4rud", dark: "yv8y4rue" }, defaultClass: "yv8y4rud yv8y4rue" }, smallLightButtonHoverBackground: { conditions: { light: "yv8y4ruf", dark: "yv8y4rug" }, defaultClass: "yv8y4ruf yv8y4rug" }, smallLightButtonHoverOutline: { conditions: { light: "yv8y4ruh", dark: "yv8y4rui" }, defaultClass: "yv8y4ruh yv8y4rui" }, smallLightButtonActiveColor: { conditions: { light: "yv8y4ruj", dark: "yv8y4ruk" }, defaultClass: "yv8y4ruj yv8y4ruk" }, smallLightButtonActiveBackground: { conditions: { light: "yv8y4rul", dark: "yv8y4rum" }, defaultClass: "yv8y4rul yv8y4rum" }, smallLightButtonActiveOutline: { conditions: { light: "yv8y4run", dark: "yv8y4ruo" }, defaultClass: "yv8y4run yv8y4ruo" }, disabledButtonColor: { conditions: { light: "yv8y4rup", dark: "yv8y4ruq" }, defaultClass: "yv8y4rup yv8y4ruq" }, disabledButtonBackground: { conditions: { light: "yv8y4rur", dark: "yv8y4rus" }, defaultClass: "yv8y4rur yv8y4rus" }, disabledButtonOutline: { conditions: { light: "yv8y4rut", dark: "yv8y4ruu" }, defaultClass: "yv8y4rut yv8y4ruu" }, disabledButtonHoverColor: { conditions: { light: "yv8y4ruv", dark: "yv8y4ruw" }, defaultClass: "yv8y4ruv yv8y4ruw" }, disabledButtonHoverBackground: { conditions: { light: "yv8y4rux", dark: "yv8y4ruy" }, defaultClass: "yv8y4rux yv8y4ruy" }, disabledButtonHoverOutline: { conditions: { light: "yv8y4ruz", dark: "yv8y4rv0" }, defaultClass: "yv8y4ruz yv8y4rv0" }, disabledButtonActiveColor: { conditions: { light: "yv8y4rv1", dark: "yv8y4rv2" }, defaultClass: "yv8y4rv1 yv8y4rv2" }, disabledButtonActiveBackground: { conditions: { light: "yv8y4rv3", dark: "yv8y4rv4" }, defaultClass: "yv8y4rv3 yv8y4rv4" }, disabledButtonActiveOutline: { conditions: { light: "yv8y4rv5", dark: "yv8y4rv6" }, defaultClass: "yv8y4rv5 yv8y4rv6" }, connectKit: { conditions: { light: "yv8y4rv7", dark: "yv8y4rv8" }, defaultClass: "yv8y4rv7 yv8y4rv8" } } }, background: { values: { white: { conditions: { light: "yv8y4rv9", dark: "yv8y4rva" }, defaultClass: "yv8y4rv9 yv8y4rva" }, black: { conditions: { light: "yv8y4rvb", dark: "yv8y4rvc" }, defaultClass: "yv8y4rvb yv8y4rvc" }, transparent: { conditions: { light: "yv8y4rvd", dark: "yv8y4rve" }, defaultClass: "yv8y4rvd yv8y4rve" }, primary: { conditions: { light: "yv8y4rvf", dark: "yv8y4rvg" }, defaultClass: "yv8y4rvf yv8y4rvg" }, accent: { conditions: { light: "yv8y4rvh", dark: "yv8y4rvi" }, defaultClass: "yv8y4rvh yv8y4rvi" }, disabled: { conditions: { light: "yv8y4rvj", dark: "yv8y4rvk" }, defaultClass: "yv8y4rvj yv8y4rvk" }, text: { conditions: { light: "yv8y4rvl", dark: "yv8y4rvm" }, defaultClass: "yv8y4rvl yv8y4rvm" }, textMuted: { conditions: { light: "yv8y4rvn", dark: "yv8y4rvo" }, defaultClass: "yv8y4rvn yv8y4rvo" }, textDanger: { conditions: { light: "yv8y4rvp", dark: "yv8y4rvq" }, defaultClass: "yv8y4rvp yv8y4rvq" }, background: { conditions: { light: "yv8y4rvr", dark: "yv8y4rvs" }, defaultClass: "yv8y4rvr yv8y4rvs" }, backgroundMuted: { conditions: { light: "yv8y4rvt", dark: "yv8y4rvu" }, defaultClass: "yv8y4rvt yv8y4rvu" }, tokenSelectBackground: { conditions: { light: "yv8y4rvv", dark: "yv8y4rvw" }, defaultClass: "yv8y4rvv yv8y4rvw" }, tokenSelectHoverBackground: { conditions: { light: "yv8y4rvx", dark: "yv8y4rvy" }, defaultClass: "yv8y4rvx yv8y4rvy" }, tokenSelect: { conditions: { light: "yv8y4rvz", dark: "yv8y4rw0" }, defaultClass: "yv8y4rvz yv8y4rw0" }, skeletonLoaderBase: { conditions: { light: "yv8y4rw1", dark: "yv8y4rw2" }, defaultClass: "yv8y4rw1 yv8y4rw2" }, skeletonLoaderHighlight: { conditions: { light: "yv8y4rw3", dark: "yv8y4rw4" }, defaultClass: "yv8y4rw3 yv8y4rw4" }, tabBorder: { conditions: { light: "yv8y4rw5", dark: "yv8y4rw6" }, defaultClass: "yv8y4rw5 yv8y4rw6" }, stakeSectionBackground: { conditions: { light: "yv8y4rw7", dark: "yv8y4rw8" }, defaultClass: "yv8y4rw7 yv8y4rw8" }, dropdownBackground: { conditions: { light: "yv8y4rw9", dark: "yv8y4rwa" }, defaultClass: "yv8y4rw9 yv8y4rwa" }, selectValidatorMultiSelectedBackground: { conditions: { light: "yv8y4rwb", dark: "yv8y4rwc" }, defaultClass: "yv8y4rwb yv8y4rwc" }, selectValidatorMultiDefaultBackground: { conditions: { light: "yv8y4rwd", dark: "yv8y4rwe" }, defaultClass: "yv8y4rwd yv8y4rwe" }, warningBoxBackground: { conditions: { light: "yv8y4rwf", dark: "yv8y4rwg" }, defaultClass: "yv8y4rwf yv8y4rwg" }, positionsSectionBackgroundColor: { conditions: { light: "yv8y4rwh", dark: "yv8y4rwi" }, defaultClass: "yv8y4rwh yv8y4rwi" }, positionsSectionBorderColor: { conditions: { light: "yv8y4rwj", dark: "yv8y4rwk" }, defaultClass: "yv8y4rwj yv8y4rwk" }, positionsSectionDividerColor: { conditions: { light: "yv8y4rwl", dark: "yv8y4rwm" }, defaultClass: "yv8y4rwl yv8y4rwm" }, positionsClaimRewardsBackground: { conditions: { light: "yv8y4rwn", dark: "yv8y4rwo" }, defaultClass: "yv8y4rwn yv8y4rwo" }, positionsActionRequiredBackground: { conditions: { light: "yv8y4rwp", dark: "yv8y4rwq" }, defaultClass: "yv8y4rwp yv8y4rwq" }, positionsPendingBackground: { conditions: { light: "yv8y4rwr", dark: "yv8y4rws" }, defaultClass: "yv8y4rwr yv8y4rws" }, modalOverlayBackground: { conditions: { light: "yv8y4rwt", dark: "yv8y4rwu" }, defaultClass: "yv8y4rwt yv8y4rwu" }, modalBodyBackground: { conditions: { light: "yv8y4rwv", dark: "yv8y4rww" }, defaultClass: "yv8y4rwv yv8y4rww" }, tooltipBackground: { conditions: { light: "yv8y4rwx", dark: "yv8y4rwy" }, defaultClass: "yv8y4rwx yv8y4rwy" }, primaryButtonColor: { conditions: { light: "yv8y4rwz", dark: "yv8y4rx0" }, defaultClass: "yv8y4rwz yv8y4rx0" }, primaryButtonBackground: { conditions: { light: "yv8y4rx1", dark: "yv8y4rx2" }, defaultClass: "yv8y4rx1 yv8y4rx2" }, primaryButtonOutline: { conditions: { light: "yv8y4rx3", dark: "yv8y4rx4" }, defaultClass: "yv8y4rx3 yv8y4rx4" }, primaryButtonHoverColor: { conditions: { light: "yv8y4rx5", dark: "yv8y4rx6" }, defaultClass: "yv8y4rx5 yv8y4rx6" }, primaryButtonHoverBackground: { conditions: { light: "yv8y4rx7", dark: "yv8y4rx8" }, defaultClass: "yv8y4rx7 yv8y4rx8" }, primaryButtonHoverOutline: { conditions: { light: "yv8y4rx9", dark: "yv8y4rxa" }, defaultClass: "yv8y4rx9 yv8y4rxa" }, primaryButtonActiveColor: { conditions: { light: "yv8y4rxb", dark: "yv8y4rxc" }, defaultClass: "yv8y4rxb yv8y4rxc" }, primaryButtonActiveBackground: { conditions: { light: "yv8y4rxd", dark: "yv8y4rxe" }, defaultClass: "yv8y4rxd yv8y4rxe" }, primaryButtonActiveOutline: { conditions: { light: "yv8y4rxf", dark: "yv8y4rxg" }, defaultClass: "yv8y4rxf yv8y4rxg" }, secondaryButtonColor: { conditions: { light: "yv8y4rxh", dark: "yv8y4rxi" }, defaultClass: "yv8y4rxh yv8y4rxi" }, secondaryButtonBackground: { conditions: { light: "yv8y4rxj", dark: "yv8y4rxk" }, defaultClass: "yv8y4rxj yv8y4rxk" }, secondaryButtonOutline: { conditions: { light: "yv8y4rxl", dark: "yv8y4rxm" }, defaultClass: "yv8y4rxl yv8y4rxm" }, secondaryButtonHoverColor: { conditions: { light: "yv8y4rxn", dark: "yv8y4rxo" }, defaultClass: "yv8y4rxn yv8y4rxo" }, secondaryButtonHoverBackground: { conditions: { light: "yv8y4rxp", dark: "yv8y4rxq" }, defaultClass: "yv8y4rxp yv8y4rxq" }, secondaryButtonHoverOutline: { conditions: { light: "yv8y4rxr", dark: "yv8y4rxs" }, defaultClass: "yv8y4rxr yv8y4rxs" }, secondaryButtonActiveColor: { conditions: { light: "yv8y4rxt", dark: "yv8y4rxu" }, defaultClass: "yv8y4rxt yv8y4rxu" }, secondaryButtonActiveBackground: { conditions: { light: "yv8y4rxv", dark: "yv8y4rxw" }, defaultClass: "yv8y4rxv yv8y4rxw" }, secondaryButtonActiveOutline: { conditions: { light: "yv8y4rxx", dark: "yv8y4rxy" }, defaultClass: "yv8y4rxx yv8y4rxy" }, smallButtonColor: { conditions: { light: "yv8y4rxz", dark: "yv8y4ry0" }, defaultClass: "yv8y4rxz yv8y4ry0" }, smallButtonBackground: { conditions: { light: "yv8y4ry1", dark: "yv8y4ry2" }, defaultClass: "yv8y4ry1 yv8y4ry2" }, smallButtonOutline: { conditions: { light: "yv8y4ry3", dark: "yv8y4ry4" }, defaultClass: "yv8y4ry3 yv8y4ry4" }, smallButtonHoverColor: { conditions: { light: "yv8y4ry5", dark: "yv8y4ry6" }, defaultClass: "yv8y4ry5 yv8y4ry6" }, smallButtonHoverBackground: { conditions: { light: "yv8y4ry7", dark: "yv8y4ry8" }, defaultClass: "yv8y4ry7 yv8y4ry8" }, smallButtonHoverOutline: { conditions: { light: "yv8y4ry9", dark: "yv8y4rya" }, defaultClass: "yv8y4ry9 yv8y4rya" }, smallButtonActiveColor: { conditions: { light: "yv8y4ryb", dark: "yv8y4ryc" }, defaultClass: "yv8y4ryb yv8y4ryc" }, smallButtonActiveBackground: { conditions: { light: "yv8y4ryd", dark: "yv8y4rye" }, defaultClass: "yv8y4ryd yv8y4rye" }, smallButtonActiveOutline: { conditions: { light: "yv8y4ryf", dark: "yv8y4ryg" }, defaultClass: "yv8y4ryf yv8y4ryg" }, smallLightButtonColor: { conditions: { light: "yv8y4ryh", dark: "yv8y4ryi" }, defaultClass: "yv8y4ryh yv8y4ryi" }, smallLightButtonBackground: { conditions: { light: "yv8y4ryj", dark: "yv8y4ryk" }, defaultClass: "yv8y4ryj yv8y4ryk" }, smallLightButtonOutline: { conditions: { light: "yv8y4ryl", dark: "yv8y4rym" }, defaultClass: "yv8y4ryl yv8y4rym" }, smallLightButtonHoverColor: { conditions: { light: "yv8y4ryn", dark: "yv8y4ryo" }, defaultClass: "yv8y4ryn yv8y4ryo" }, smallLightButtonHoverBackground: { conditions: { light: "yv8y4ryp", dark: "yv8y4ryq" }, defaultClass: "yv8y4ryp yv8y4ryq" }, smallLightButtonHoverOutline: { conditions: { light: "yv8y4ryr", dark: "yv8y4rys" }, defaultClass: "yv8y4ryr yv8y4rys" }, smallLightButtonActiveColor: { conditions: { light: "yv8y4ryt", dark: "yv8y4ryu" }, defaultClass: "yv8y4ryt yv8y4ryu" }, smallLightButtonActiveBackground: { conditions: { light: "yv8y4ryv", dark: "yv8y4ryw" }, defaultClass: "yv8y4ryv yv8y4ryw" }, smallLightButtonActiveOutline: { conditions: { light: "yv8y4ryx", dark: "yv8y4ryy" }, defaultClass: "yv8y4ryx yv8y4ryy" }, disabledButtonColor: { conditions: { light: "yv8y4ryz", dark: "yv8y4rz0" }, defaultClass: "yv8y4ryz yv8y4rz0" }, disabledButtonBackground: { conditions: { light: "yv8y4rz1", dark: "yv8y4rz2" }, defaultClass: "yv8y4rz1 yv8y4rz2" }, disabledButtonOutline: { conditions: { light: "yv8y4rz3", dark: "yv8y4rz4" }, defaultClass: "yv8y4rz3 yv8y4rz4" }, disabledButtonHoverColor: { conditions: { light: "yv8y4rz5", dark: "yv8y4rz6" }, defaultClass: "yv8y4rz5 yv8y4rz6" }, disabledButtonHoverBackground: { conditions: { light: "yv8y4rz7", dark: "yv8y4rz8" }, defaultClass: "yv8y4rz7 yv8y4rz8" }, disabledButtonHoverOutline: { conditions: { light: "yv8y4rz9", dark: "yv8y4rza" }, defaultClass: "yv8y4rz9 yv8y4rza" }, disabledButtonActiveColor: { conditions: { light: "yv8y4rzb", dark: "yv8y4rzc" }, defaultClass: "yv8y4rzb yv8y4rzc" }, disabledButtonActiveBackground: { conditions: { light: "yv8y4rzd", dark: "yv8y4rze" }, defaultClass: "yv8y4rzd yv8y4rze" }, disabledButtonActiveOutline: { conditions: { light: "yv8y4rzf", dark: "yv8y4rzg" }, defaultClass: "yv8y4rzf yv8y4rzg" }, connectKit: { conditions: { light: "yv8y4rzh", dark: "yv8y4rzi" }, defaultClass: "yv8y4rzh yv8y4rzi" } } }, borderColor: { values: { white: { conditions: { light: "yv8y4rzj", dark: "yv8y4rzk" }, defaultClass: "yv8y4rzj yv8y4rzk" }, black: { conditions: { light: "yv8y4rzl", dark: "yv8y4rzm" }, defaultClass: "yv8y4rzl yv8y4rzm" }, transparent: { conditions: { light: "yv8y4rzn", dark: "yv8y4rzo" }, defaultClass: "yv8y4rzn yv8y4rzo" }, primary: { conditions: { light: "yv8y4rzp", dark: "yv8y4rzq" }, defaultClass: "yv8y4rzp yv8y4rzq" }, accent: { conditions: { light: "yv8y4rzr", dark: "yv8y4rzs" }, defaultClass: "yv8y4rzr yv8y4rzs" }, disabled: { conditions: { light: "yv8y4rzt", dark: "yv8y4rzu" }, defaultClass: "yv8y4rzt yv8y4rzu" }, text: { conditions: { light: "yv8y4rzv", dark: "yv8y4rzw" }, defaultClass: "yv8y4rzv yv8y4rzw" }, textMuted: { conditions: { light: "yv8y4rzx", dark: "yv8y4rzy" }, defaultClass: "yv8y4rzx yv8y4rzy" }, textDanger: { conditions: { light: "yv8y4rzz", dark: "yv8y4r100" }, defaultClass: "yv8y4rzz yv8y4r100" }, background: { conditions: { light: "yv8y4r101", dark: "yv8y4r102" }, defaultClass: "yv8y4r101 yv8y4r102" }, backgroundMuted: { conditions: { light: "yv8y4r103", dark: "yv8y4r104" }, defaultClass: "yv8y4r103 yv8y4r104" }, tokenSelectBackground: { conditions: { light: "yv8y4r105", dark: "yv8y4r106" }, defaultClass: "yv8y4r105 yv8y4r106" }, tokenSelectHoverBackground: { conditions: { light: "yv8y4r107", dark: "yv8y4r108" }, defaultClass: "yv8y4r107 yv8y4r108" }, tokenSelect: { conditions: { light: "yv8y4r109", dark: "yv8y4r10a" }, defaultClass: "yv8y4r109 yv8y4r10a" }, skeletonLoaderBase: { conditions: { light: "yv8y4r10b", dark: "yv8y4r10c" }, defaultClass: "yv8y4r10b yv8y4r10c" }, skeletonLoaderHighlight: { conditions: { light: "yv8y4r10d", dark: "yv8y4r10e" }, defaultClass: "yv8y4r10d yv8y4r10e" }, tabBorder: { conditions: { light: "yv8y4r10f", dark: "yv8y4r10g" }, defaultClass: "yv8y4r10f yv8y4r10g" }, stakeSectionBackground: { conditions: { light: "yv8y4r10h", dark: "yv8y4r10i" }, defaultClass: "yv8y4r10h yv8y4r10i" }, dropdownBackground: { conditions: { light: "yv8y4r10j", dark: "yv8y4r10k" }, defaultClass: "yv8y4r10j yv8y4r10k" }, selectValidatorMultiSelectedBackground: { conditions: { light: "yv8y4r10l", dark: "yv8y4r10m" }, defaultClass: "yv8y4r10l yv8y4r10m" }, selectValidatorMultiDefaultBackground: { conditions: { light: "yv8y4r10n", dark: "yv8y4r10o" }, defaultClass: "yv8y4r10n yv8y4r10o" }, warningBoxBackground: { conditions: { light: "yv8y4r10p", dark: "yv8y4r10q" }, defaultClass: "yv8y4r10p yv8y4r10q" }, positionsSectionBackgroundColor: { conditions: { light: "yv8y4r10r", dark: "yv8y4r10s" }, defaultClass: "yv8y4r10r yv8y4r10s" }, positionsSectionBorderColor: { conditions: { light: "yv8y4r10t", dark: "yv8y4r10u" }, defaultClass: "yv8y4r10t yv8y4r10u" }, positionsSectionDividerColor: { conditions: { light: "yv8y4r10v", dark: "yv8y4r10w" }, defaultClass: "yv8y4r10v yv8y4r10w" }, positionsClaimRewardsBackground: { conditions: { light: "yv8y4r10x", dark: "yv8y4r10y" }, defaultClass: "yv8y4r10x yv8y4r10y" }, positionsActionRequiredBackground: { conditions: { light: "yv8y4r10z", dark: "yv8y4r110" }, defaultClass: "yv8y4r10z yv8y4r110" }, positionsPendingBackground: { conditions: { light: "yv8y4r111", dark: "yv8y4r112" }, defaultClass: "yv8y4r111 yv8y4r112" }, modalOverlayBackground: { conditions: { light: "yv8y4r113", dark: "yv8y4r114" }, defaultClass: "yv8y4r113 yv8y4r114" }, modalBodyBackground: { conditions: { light: "yv8y4r115", dark: "yv8y4r116" }, defaultClass: "yv8y4r115 yv8y4r116" }, tooltipBackground: { conditions: { light: "yv8y4r117", dark: "yv8y4r118" }, defaultClass: "yv8y4r117 yv8y4r118" }, primaryButtonColor: { conditions: { light: "yv8y4r119", dark: "yv8y4r11a" }, defaultClass: "yv8y4r119 yv8y4r11a" }, primaryButtonBackground: { conditions: { light: "yv8y4r11b", dark: "yv8y4r11c" }, defaultClass: "yv8y4r11b yv8y4r11c" }, primaryButtonOutline: { conditions: { light: "yv8y4r11d", dark: "yv8y4r11e" }, defaultClass: "yv8y4r11d yv8y4r11e" }, primaryButtonHoverColor: { conditions: { light: "yv8y4r11f", dark: "yv8y4r11g" }, defaultClass: "yv8y4r11f yv8y4r11g" }, primaryButtonHoverBackground: { conditions: { light: "yv8y4r11h", dark: "yv8y4r11i" }, defaultClass: "yv8y4r11h yv8y4r11i" }, primaryButtonHoverOutline: { conditions: { light: "yv8y4r11j", dark: "yv8y4r11k" }, defaultClass: "yv8y4r11j yv8y4r11k" }, primaryButtonActiveColor: { conditions: { light: "yv8y4r11l", dark: "yv8y4r11m" }, defaultClass: "yv8y4r11l yv8y4r11m" }, primaryButtonActiveBackground: { conditions: { light: "yv8y4r11n", dark: "yv8y4r11o" }, defaultClass: "yv8y4r11n yv8y4r11o" }, primaryButtonActiveOutline: { conditions: { light: "yv8y4r11p", dark: "yv8y4r11q" }, defaultClass: "yv8y4r11p yv8y4r11q" }, secondaryButtonColor: { conditions: { light: "yv8y4r11r", dark: "yv8y4r11s" }, defaultClass: "yv8y4r11r yv8y4r11s" }, secondaryButtonBackground: { conditions: { light: "yv8y4r11t", dark: "yv8y4r11u" }, defaultClass: "yv8y4r11t yv8y4r11u" }, secondaryButtonOutline: { conditions: { light: "yv8y4r11v", dark: "yv8y4r11w" }, defaultClass: "yv8y4r11v yv8y4r11w" }, secondaryButtonHoverColor: { conditions: { light: "yv8y4r11x", dark: "yv8y4r11y" }, defaultClass: "yv8y4r11x yv8y4r11y" }, secondaryButtonHoverBackground: { conditions: { light: "yv8y4r11z", dark: "yv8y4r120" }, defaultClass: "yv8y4r11z yv8y4r120" }, secondaryButtonHoverOutline: { conditions: { light: "yv8y4r121", dark: "yv8y4r122" }, defaultClass: "yv8y4r121 yv8y4r122" }, secondaryButtonActiveColor: { conditions: { light: "yv8y4r123", dark: "yv8y4r124" }, defaultClass: "yv8y4r123 yv8y4r124" }, secondaryButtonActiveBackground: { conditions: { light: "yv8y4r125", dark: "yv8y4r126" }, defaultClass: "yv8y4r125 yv8y4r126" }, secondaryButtonActiveOutline: { conditions: { light: "yv8y4r127", dark: "yv8y4r128" }, defaultClass: "yv8y4r127 yv8y4r128" }, smallButtonColor: { conditions: { light: "yv8y4r129", dark: "yv8y4r12a" }, defaultClass: "yv8y4r129 yv8y4r12a" }, smallButtonBackground: { conditions: { light: "yv8y4r12b", dark: "yv8y4r12c" }, defaultClass: "yv8y4r12b yv8y4r12c" }, smallButtonOutline: { conditions: { light: "yv8y4r12d", dark: "yv8y4r12e" }, defaultClass: "yv8y4r12d yv8y4r12e" }, smallButtonHoverColor: { conditions: { light: "yv8y4r12f", dark: "yv8y4r12g" }, defaultClass: "yv8y4r12f yv8y4r12g" }, smallButtonHoverBackground: { conditions: { light: "yv8y4r12h", dark: "yv8y4r12i" }, defaultClass: "yv8y4r12h yv8y4r12i" }, smallButtonHoverOutline: { conditions: { light: "yv8y4r12j", dark: "yv8y4r12k" }, defaultClass: "yv8y4r12j yv8y4r12k" }, smallButtonActiveColor: { conditions: { light: "yv8y4r12l", dark: "yv8y4r12m" }, defaultClass: "yv8y4r12l yv8y4r12m" }, smallButtonActiveBackground: { conditions: { light: "yv8y4r12n", dark: "yv8y4r12o" }, defaultClass: "yv8y4r12n yv8y4r12o" }, smallButtonActiveOutline: { conditions: { light: "yv8y4r12p", dark: "yv8y4r12q" }, defaultClass: "yv8y4r12p yv8y4r12q" }, smallLightButtonColor: { conditions: { light: "yv8y4r12r", dark: "yv8y4r12s" }, defaultClass: "yv8y4r12r yv8y4r12s" }, smallLightButtonBackground: { conditions: { light: "yv8y4r12t", dark: "yv8y4r12u" }, defaultClass: "yv8y4r12t yv8y4r12u" }, smallLightButtonOutline: { conditions: { light: "yv8y4r12v", dark: "yv8y4r12w" }, defaultClass: "yv8y4r12v yv8y4r12w" }, smallLightButtonHoverColor: { conditions: { light: "yv8y4r12x", dark: "yv8y4r12y" }, defaultClass: "yv8y4r12x yv8y4r12y" }, smallLightButtonHoverBackground: { conditions: { light: "yv8y4r12z", dark: "yv8y4r130" }, defaultClass: "yv8y4r12z yv8y4r130" }, smallLightButtonHoverOutline: { conditions: { light: "yv8y4r131", dark: "yv8y4r132" }, defaultClass: "yv8y4r131 yv8y4r132" }, smallLightButtonActiveColor: { conditions: { light: "yv8y4r133", dark: "yv8y4r134" }, defaultClass: "yv8y4r133 yv8y4r134" }, smallLightButtonActiveBackground: { conditions: { light: "yv8y4r135", dark: "yv8y4r136" }, defaultClass: "yv8y4r135 yv8y4r136" }, smallLightButtonActiveOutline: { conditions: { light: "yv8y4r137", dark: "yv8y4r138" }, defaultClass: "yv8y4r137 yv8y4r138" }, disabledButtonColor: { conditions: { light: "yv8y4r139", dark: "yv8y4r13a" }, defaultClass: "yv8y4r139 yv8y4r13a" }, disabledButtonBackground: { conditions: { light: "yv8y4r13b", dark: "yv8y4r13c" }, defaultClass: "yv8y4r13b yv8y4r13c" }, disabledButtonOutline: { conditions: { light: "yv8y4r13d", dark: "yv8y4r13e" }, defaultClass: "yv8y4r13d yv8y4r13e" }, disabledButtonHoverColor: { conditions: { light: "yv8y4r13f", dark: "yv8y4r13g" }, defaultClass: "yv8y4r13f yv8y4r13g" }, disabledButtonHoverBackground: { conditions: { light: "yv8y4r13h", dark: "yv8y4r13i" }, defaultClass: "yv8y4r13h yv8y4r13i" }, disabledButtonHoverOutline: { conditions: { light: "yv8y4r13j", dark: "yv8y4r13k" }, defaultClass: "yv8y4r13j yv8y4r13k" }, disabledButtonActiveColor: { conditions: { light: "yv8y4r13l", dark: "yv8y4r13m" }, defaultClass: "yv8y4r13l yv8y4r13m" }, disabledButtonActiveBackground: { conditions: { light: "yv8y4r13n", dark: "yv8y4r13o" }, defaultClass: "yv8y4r13n yv8y4r13o" }, disabledButtonActiveOutline: { conditions: { light: "yv8y4r13p", dark: "yv8y4r13q" }, defaultClass: "yv8y4r13p yv8y4r13q" }, connectKit: { conditions: { light: "yv8y4r13r", dark: "yv8y4r13s" }, defaultClass: "yv8y4r13r yv8y4r13s" } } } } });
const BX = {
  baseContract: {
    none: "0",
    sm: "2px",
    base: "4px",
    md: "6px",
    lg: "8px",
    xl: "12px",
    "2xl": "16px",
    "3xl": "24px",
    full: "9999px",
    half: "50%",
    widgetBorderRadius: "0",
    primaryButton: "16px",
    secondaryButton: "16px",
    smallButton: "7.38px"
  },
  connectKit: {
    ...wy.lightMode.radii,
    actionButton: zt.borderRadius.baseContract["2xl"]
  }
}, NX = {
  full: "100%",
  unset: "unset",
  auto: "auto",
  0: "0",
  1: "4px",
  2: "8px",
  3: "12px",
  4: "16px",
  5: "20px",
  6: "24px",
  7: "28px",
  8: "32px",
  9: "36px",
  10: "40px",
  12: "48px",
  14: "56px",
  16: "64px",
  20: "80px",
  24: "96px",
  28: "112px",
  32: "128px",
  36: "144px",
  40: "160px",
  44: "176px",
  48: "192px",
  px: "1px",
  buttonMinHeight: "64px"
}, DX = {
  tighter: "-0.05em",
  tight: "-0.025em",
  normal: "0",
  wide: "0.025em",
  wider: "0.05em",
  widest: "0.1em"
}, jX = {
  none: "1",
  shorter: "1.25",
  short: "1.375",
  base: "1.5",
  tall: "1.625",
  taller: "2",
  xs: "1rem",
  sm: "1.25rem",
  md: "1.5rem",
  lg: "1.75rem",
  xl: "1.75rem",
  "2xl": "2.25rem",
  "3xl": "2.5rem",
  "4xl": "1",
  "5xl": "1",
  "6xl": "1"
}, MX = {
  normal: "400",
  medium: "500",
  semibold: "600",
  bold: "700",
  extrabold: "800",
  modalHeading: "600",
  tokenSelect: "700",
  primaryButton: "700",
  secondaryButton: "700"
}, ar = {
  xs: "0.615rem",
  sm: "0.717rem",
  md: "0.85rem",
  lg: "1rem",
  lgx: "1.125rem",
  xl: "1.3125rem",
  "2xl": "1.563rem",
  "3xl": "1.953rem",
  "4xl": "2.441rem",
  "5xl": "3.052rem",
  "6xl": "3.815rem"
}, FX = {
  h1: {
    mobile: { fontSize: ar["3xl"] },
    tablet: { fontSize: ar["4xl"] }
  },
  h2: {
    mobile: { fontSize: ar["2xl"] },
    tablet: { fontSize: ar["3xl"] }
  },
  h3: {
    mobile: { fontSize: ar.xl },
    tablet: { fontSize: ar["2xl"] }
  },
  h4: {
    mobile: { fontSize: ar.lgx },
    tablet: { fontSize: ar.lgx }
  }
}, LX = {
  large: {
    mobile: { fontSize: ar.lg },
    tablet: { fontSize: ar.lg }
  },
  medium: {
    mobile: { fontSize: ar.md },
    tablet: { fontSize: ar.md }
  },
  small: {
    mobile: { fontSize: ar.sm },
    tablet: { fontSize: ar.sm }
  }
}, UX = {
  hide: "-1",
  auto: "auto",
  simple: "1",
  base: "0",
  docked: "10",
  dropdown: "1000",
  sticky: "1100",
  banner: "1200",
  overlay: "1300",
  modal: "1400",
  skipLink: "1600"
}, Zo = {
  light: "light-theme",
  lightOverrides: "light-theme-overrides",
  dark: "dark-theme",
  darkOverrides: "dark-theme-overrides"
}, fR = {
  fontSize: ar,
  letterSpacing: DX,
  lineHeight: jX,
  fontWeight: MX,
  borderRadius: BX,
  space: NX,
  heading: FX,
  text: LX,
  zIndices: UX,
  font: AX
}, qf = {
  ...fR,
  color: EX
}, zX = {
  ...fR,
  color: SX
}, lc = Tn.chainNullable((e) => e.document), VX = () => {
  const e = kX();
  Bo(() => {
    e === "dark" ? lc.ifJust((t) => {
      t.body.classList.remove(Zo.light), t.body.classList.remove(Zo.lightOverrides), t.body.classList.add(Zo.dark), t.body.classList.add(Zo.darkOverrides);
    }) : lc.ifJust((t) => {
      t.body.classList.add(Zo.light), t.body.classList.add(Zo.lightOverrides), t.body.classList.remove(Zo.dark), t.body.classList.remove(Zo.darkOverrides);
    });
  }, [e]);
}, Dt = (e) => {
  const t = It(e);
  return Te(() => {
    t.current = e;
  }), t;
}, qX = () => {
  const { disconnect: e } = wt();
  return li({
    mutationFn: async () => (await de(e).chain(() => de(() => indexedDB.databases())).ifRight(
      (t) => t.forEach((n) => n.name && indexedDB.deleteDatabase(n.name))
    ), null)
  });
}, dr = (e) => {
  var t;
  return `${e.network}-${(t = e.address) == null ? void 0 : t.toLowerCase()}`;
}, xy = (e, t) => dr(e) === dr(t), Uc = ({
  token: e,
  baseToken: t,
  amount: n,
  prices: r,
  pricePerShare: i
}) => {
  const o = Re(n);
  if (i && t) {
    const a = new Re(
      r.getByToken(t).chainNullable((c) => c.price).orDefault(0)
    ), l = Re(i);
    return o.times(a).times(l);
  }
  const s = new Re(
    r.getByToken(e).chainNullable((a) => a.price).orDefault(0)
  );
  return o.times(s);
}, $X = ({
  stakeToken: e,
  yieldDto: t
}) => xy(e, hR(t)), WX = ({
  availableAmount: e,
  gasEstimateTotal: t,
  integrationMaxLimit: n
}) => Re.max(
  Re.min(n, e.minus(t)),
  new Re(0)
), GX = (e) => e.metadata.token, hR = (e) => e.metadata.gasFeeToken, d1 = (e) => {
  const t = {
    ...e,
    transactions: e.transactions.filter(
      (n) => n.status !== "SKIPPED"
    )
  };
  return t.transactions.some((n) => pR(n.status)) ? Xe(new Error("Transaction failed")) : _e(t);
}, pR = (e) => e === "FAILED" || e === "BLOCKED", Wb = (e) => {
  var t, n, r;
  return !!((r = (n = (t = e.args) == null ? void 0 : t.args) == null ? void 0 : n.validatorAddresses) != null && r.required);
}, Gb = (e) => {
  var t, n, r;
  return !!((r = (n = (t = e.args) == null ? void 0 : t.args) == null ? void 0 : n.validatorAddress) != null && r.required);
}, yR = /* @__PURE__ */ new Set([
  "P2P_NODE_REQUEST",
  "LUGANODES_PROVISION",
  "LUGANODES_EXIT_REQUEST"
]), HX = (e) => e.filter((t) => !yR.has(t.type)), KX = (e) => {
  const t = hG(e);
  return Number.isNaN(t) ? e : t;
}, Zd = (e) => J(() => e.map((t) => GX(t)), [e]), YX = (e) => J(() => e.map((t) => hR(t)), [e]);
var QX = (e, t, n) => {
  if (t.length === 1 && t[0] === n) {
    let r = !1;
    try {
      const i = {};
      e(i) === i && (r = !0);
    } catch {
    }
    if (r) {
      let i;
      try {
        throw new Error();
      } catch (o) {
        ({ stack: i } = o);
      }
    }
  }
}, JX = (e, t, n) => {
  const { memoize: r, memoizeOptions: i } = t, { inputSelectorResults: o, inputSelectorResultsCopy: s } = e, a = r(() => ({}), ...i);
  if (!(a.apply(null, o) === a.apply(null, s))) {
    let c;
    try {
      throw new Error();
    } catch (u) {
      ({ stack: c } = u);
    }
  }
}, XX = {
  inputStabilityCheck: "once",
  identityFunctionCheck: "once"
};
function ZX(e, t = `expected a function, instead received ${typeof e}`) {
  if (typeof e != "function")
    throw new TypeError(t);
}
function eZ(e, t = `expected an object, instead received ${typeof e}`) {
  if (typeof e != "object")
    throw new TypeError(t);
}
function tZ(e, t = "expected all items to be functions, instead received the following types: ") {
  if (!e.every((n) => typeof n == "function")) {
    const n = e.map(
      (r) => typeof r == "function" ? `function ${r.name || "unnamed"}()` : typeof r
    ).join(", ");
    throw new TypeError(`${t}[${n}]`);
  }
}
var e4 = (e) => Array.isArray(e) ? e : [e];
function nZ(e) {
  const t = Array.isArray(e[0]) ? e[0] : e;
  return tZ(
    t,
    "createSelector expects all input-selectors to be functions, but received the following types: "
  ), t;
}
function t4(e, t) {
  const n = [], { length: r } = e;
  for (let i = 0; i < r; i++)
    n.push(e[i].apply(null, t));
  return n;
}
var rZ = (e, t) => {
  const { identityFunctionCheck: n, inputStabilityCheck: r } = {
    ...XX,
    ...t
  };
  return {
    identityFunctionCheck: {
      shouldRun: n === "always" || n === "once" && e,
      run: QX
    },
    inputStabilityCheck: {
      shouldRun: r === "always" || r === "once" && e,
      run: JX
    }
  };
}, iZ = class {
  constructor(e) {
    this.value = e;
  }
  deref() {
    return this.value;
  }
}, oZ = typeof WeakRef < "u" ? WeakRef : iZ, sZ = 0, n4 = 1;
function $f() {
  return {
    s: sZ,
    v: void 0,
    o: null,
    p: null
  };
}
function mR(e, t = {}) {
  let n = $f();
  const { resultEqualityCheck: r } = t;
  let i, o = 0;
  function s() {
    var d;
    let a = n;
    const { length: l } = arguments;
    for (let f = 0, h = l; f < h; f++) {
      const p = arguments[f];
      if (typeof p == "function" || typeof p == "object" && p !== null) {
        let m = a.o;
        m === null && (a.o = m = /* @__PURE__ */ new WeakMap());
        const g = m.get(p);
        g === void 0 ? (a = $f(), m.set(p, a)) : a = g;
      } else {
        let m = a.p;
        m === null && (a.p = m = /* @__PURE__ */ new Map());
        const g = m.get(p);
        g === void 0 ? (a = $f(), m.set(p, a)) : a = g;
      }
    }
    const c = a;
    let u;
    if (a.s === n4)
      u = a.v;
    else if (u = e.apply(null, arguments), o++, r) {
      const f = ((d = i == null ? void 0 : i.deref) == null ? void 0 : d.call(i)) ?? i;
      f != null && r(f, u) && (u = f, o !== 0 && o--), i = typeof u == "object" && u !== null || typeof u == "function" ? new oZ(u) : u;
    }
    return c.s = n4, c.v = u, u;
  }
  return s.clearCache = () => {
    n = $f(), s.resetResultsCount();
  }, s.resultsCount = () => o, s.resetResultsCount = () => {
    o = 0;
  }, s;
}
function aZ(e, ...t) {
  const n = typeof e == "function" ? {
    memoize: e,
    memoizeOptions: t
  } : e, r = (...i) => {
    let o = 0, s = 0, a, l = {}, c = i.pop();
    typeof c == "object" && (l = c, c = i.pop()), ZX(
      c,
      `createSelector expects an output function after the inputs, but received: [${typeof c}]`
    );
    const u = {
      ...n,
      ...l
    }, {
      memoize: d,
      memoizeOptions: f = [],
      argsMemoize: h = mR,
      argsMemoizeOptions: p = [],
      devModeChecks: m = {}
    } = u, g = e4(f), v = e4(p), w = nZ(i), x = d(function() {
      return o++, c.apply(
        null,
        arguments
      );
    }, ...g);
    let C = !0;
    const S = h(function() {
      s++;
      const A = t4(
        w,
        arguments
      );
      if (a = x.apply(null, A), ke.env.NODE_ENV !== "production") {
        const { identityFunctionCheck: b, inputStabilityCheck: T } = rZ(C, m);
        if (b.shouldRun && b.run(
          c,
          A,
          a
        ), T.shouldRun) {
          const R = t4(
            w,
            arguments
          );
          T.run(
            { inputSelectorResults: A, inputSelectorResultsCopy: R },
            { memoize: d, memoizeOptions: g },
            arguments
          );
        }
        C && (C = !1);
      }
      return a;
    }, ...v);
    return Object.assign(S, {
      resultFunc: c,
      memoizedResultFunc: x,
      dependencies: w,
      dependencyRecomputations: () => s,
      resetDependencyRecomputations: () => {
        s = 0;
      },
      lastResult: () => a,
      recomputations: () => o,
      resetRecomputations: () => {
        o = 0;
      },
      memoize: d,
      argsMemoize: h
    });
  };
  return Object.assign(r, {
    withTypes: () => r
  }), r;
}
var zc = /* @__PURE__ */ aZ(mR), lZ = Object.assign(
  (e, t = zc) => {
    eZ(
      e,
      `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof e}`
    );
    const n = Object.keys(e), r = n.map(
      (o) => e[o]
    );
    return t(
      r,
      (...o) => o.reduce((s, a, l) => (s[n[l]] = a, s), {})
    );
  },
  { withTypes: () => lZ }
);
class f1 {
  constructor(t) {
    this.value = t;
  }
  getByToken(t) {
    return G.fromNullable(this.value.get(dr(t)));
  }
}
const gR = (e) => h1(e) ? "native_staking" : wR(e) ? "pooled_staking" : e.metadata.type, vR = (e, t) => {
  const n = {
    staking: {
      type: "staking",
      title: t("yield_types.staking.title"),
      review: t("yield_types.staking.review"),
      cta: t("yield_types.staking.cta")
    },
    "liquid-staking": {
      type: "liquid-staking",
      title: t("yield_types.liquid-staking.title"),
      review: t("yield_types.liquid-staking.review"),
      cta: t("yield_types.liquid-staking.cta")
    },
    vault: {
      type: "vault",
      title: t("yield_types.vault.title"),
      review: t("yield_types.vault.review"),
      cta: t("yield_types.vault.cta")
    },
    lending: {
      type: "lending",
      title: t("yield_types.lending.title"),
      review: t("yield_types.lending.review"),
      cta: t("yield_types.lending.cta")
    },
    restaking: {
      type: "restaking",
      title: t("yield_types.restaking.title"),
      review: t("yield_types.restaking.review"),
      cta: t("yield_types.restaking.cta")
    },
    native_staking: {
      type: "native_staking",
      title: t("yield_types.native_staking.title"),
      review: t("yield_types.native_staking.review"),
      cta: t("yield_types.native_staking.cta")
    },
    pooled_staking: {
      type: "pooled_staking",
      title: t("yield_types.pooled_staking.title"),
      review: t("yield_types.pooled_staking.review"),
      cta: t("yield_types.pooled_staking.cta")
    }
  };
  return h1(e) ? n.native_staking : wR(e) ? n.pooled_staking : n[e.metadata.type];
}, cZ = {
  staking: 1,
  native_staking: 2,
  pooled_staking: 3,
  "liquid-staking": 4,
  vault: 5,
  lending: 6,
  restaking: 7
}, r4 = (e) => cZ[gR(e)], bR = (e) => e.metadata.type === "staking" && e.token.network === Ue.Ethereum && e.token.symbol === "ETH", h1 = (e) => G.fromFalsy(bR(e)).chain(
  () => {
    var t, n;
    return G.fromFalsy((n = (t = e.args.enter.args) == null ? void 0 : t.amount) == null ? void 0 : n.required).chain(
      () => {
        var r, i;
        return G.fromNullable((i = (r = e.args.enter.args) == null ? void 0 : r.amount) == null ? void 0 : i.minimum);
      }
    );
  }
).map(Re).filter((t) => t.isEqualTo(32)).isJust(), wR = (e) => bR(e) && !h1(e), uZ = /* @__PURE__ */ new Set([
  "polkadot-dot-validator-staking"
]), dZ = (e, t) => uZ.has(e) ? G.fromNullable(t.get("polkadot-dot-validator-staking")).map((n) => [...n.balanceData.values()]).map((n) => n.some((r) => r.balances.some((i) => i.type === "staked"))).orDefault(!1) : !1, fZ = (e) => ({
  price: e.price,
  price24H: e.price_24_h
}), hZ = (e) => new f1(
  Object.keys(e).reduce((t, n) => (t.set(n, fZ(e[n])), t), /* @__PURE__ */ new Map())
), pZ = {
  currency: "USD",
  tokenList: [
    { network: "ethereum", name: "Ethereum", symbol: "ETH", decimals: 18 }
  ]
}, yZ = zc(
  (e) => e,
  (e) => hZ(e)
), xR = (e) => r7(e ?? pZ, {
  query: { enabled: !!e, select: yZ }
}), Cy = ({
  token: e,
  yieldDto: t
}) => {
  const n = Zd(t), r = YX(t), i = J(
    () => G.fromRecord({ baseToken: n, gasFeeToken: r, token: e }).map((o) => ({
      currency: Vt.currency,
      tokenList: [o.token, o.baseToken, o.gasFeeToken]
    })).extractNullable(),
    [n, r, e]
  );
  return xR(i);
}, ky = ({
  queryClient: e,
  yieldGetMyNetworks: t
}) => de(
  () => e.fetchQuery({
    staleTime: Number.POSITIVE_INFINITY,
    queryKey: [Vt.appPrefix, "enabled-networks"],
    queryFn: async () => (await de(() => t()).map(
      (n) => new Set(n)
    )).unsafeCoerce()
  })
).mapLeft(() => new Error("Could not get enabled networks")), mZ = (e) => {
  var t, n, r, i;
  return {
    id: e.chain_id,
    iconUrl: Je(e.chain_id).map((o) => {
      var s, a;
      return o === "osmosis-1" ? hs(qe.Osmosis) : o === "mars-1" ? Fa("mars") : ((s = e.logo_URIs) == null ? void 0 : s.png) ?? ((a = e.logo_URIs) == null ? void 0 : a.svg) ?? hs(e.chain_name);
    }).unsafeCoerce(),
    name: e.wagmiName,
    cosmosChainName: e.chain_name,
    // TODO: change this
    nativeCurrency: Fc.nativeCurrency,
    rpcUrls: {
      default: {
        http: ((n = (t = e.apis) == null ? void 0 : t.rpc) == null ? void 0 : n.map((o) => o.address)) ?? [""]
      },
      public: {
        http: ((i = (r = e.apis) == null ? void 0 : r.rpc) == null ? void 0 : i.map((o) => o.address)) ?? [""]
      }
    }
  };
}, gZ = [Vt.appPrefix, "cosmos-config"], vZ = Number.POSITIVE_INFINITY, bZ = async ({
  queryClient: e,
  forceWalletConnectOnly: t,
  yieldGetMyNetworks: n
}) => ky({ queryClient: e, yieldGetMyNetworks: n }).chain((r) => {
  const i = sT.filter(
    (o) => r.has(o)
  );
  return i.length ? de(() => import("./chain-registry-PcOar8bW.js")).mapLeft(() => new Error("Could not import cosmos chain registry")).map((o) => {
    const s = new Set(i), a = Bp(
      Np(
        o.cosmosRegistryChains.reduce((l, c) => {
          const u = o.registryIdsToSKCosmosNetworks[c.chain_id];
          return !u || !s.has(u) ? l : {
            // biome-ignore lint/performance/noAccumulatingSpread: <explanation>
            ...l,
            [u]: {
              type: "cosmos",
              skChainName: u,
              chain: c,
              wagmiChain: mZ(c)
            }
          };
        }, {})
      ).filter(([l, c]) => r.has(c.skChainName))
    );
    return {
      cosmosChainsMap: a,
      cosmosWagmiChains: Object.values(a).map(
        (l) => l.wagmiChain
      )
    };
  }).chain(
    ({ cosmosChainsMap: o, cosmosWagmiChains: s }) => de(() => import("./wallet-manager-DQiksBMp.js").then((a) => a.x)).mapLeft(() => new Error("Could not import cosmos wallet manager")).map(
      (a) => a.getWalletManager({ cosmosChainsMap: o, forceWalletConnectOnly: t })
    ).map((a) => ({ ...a, cosmosWagmiChains: s, cosmosChainsMap: o }))
  ).chain(
    (o) => de(() => o.walletManager.onMounted()).chainLeft(
      () => de(() => cosmosWalletManager._restoreAccounts().catch(() => {
      }))
    ).mapLeft((s) => new Error("cosmosWalletManager onMounted failed")).map(() => ({
      cosmosChainsMap: o.cosmosChainsMap,
      cosmosWagmiChains: o.cosmosWagmiChains,
      connector: G.fromPredicate(
        () => !!o.cosmosWagmiChains.length,
        o.connector
      )
    }))
  ) : de.liftEither(
    _e({
      cosmosChainsMap: {},
      cosmosWagmiChains: [],
      connector: G.empty()
    })
  );
}).caseOf({
  Right: (r) => Promise.resolve(r),
  Left: (r) => Promise.reject(r)
}), wZ = (e) => de(
  () => e.queryClient.fetchQuery({
    staleTime: vZ,
    queryKey: gZ,
    queryFn: () => bZ(e)
  })
).mapLeft((t) => new Error("Could not get cosmos config"));
function CR(e) {
  const t = typeof window < "u" ? window : void 0;
  if (typeof t > "u" || typeof t.ethereum > "u")
    return;
  const n = t.ethereum.providers;
  return n ? n.find((r) => r[e]) : t.ethereum[e] ? t.ethereum : void 0;
}
function kR(e) {
  const t = (n, r) => {
    const [i, ...o] = r.split("."), s = n[i];
    if (s)
      return o.length === 0 ? s : t(s, o.join("."));
  };
  if (typeof window < "u")
    return t(window, e);
}
function ER({
  flag: e,
  namespace: t
}) {
  return !!(t && typeof kR(t) < "u" || e && typeof CR(e) < "u");
}
function xZ({
  flag: e,
  namespace: t
}) {
  var i;
  const n = typeof window < "u" ? window : void 0;
  if (typeof n > "u")
    return;
  if (t) {
    const o = kR(t);
    if (o)
      return o;
  }
  const r = (i = n.ethereum) == null ? void 0 : i.providers;
  if (e) {
    const o = CR(e);
    if (o)
      return o;
  }
  return typeof r < "u" && r.length > 0 ? r[0] : n.ethereum;
}
function CZ(e) {
  return (t) => {
    const n = e ? {
      target: () => ({
        id: t.rkDetails.id,
        name: t.rkDetails.name,
        provider: e
      })
    } : {};
    return (r) => ({
      // Spread the injectedConfig object, which may be empty or contain the target function
      ...iy(n)(r),
      ...t
    });
  };
}
function p1({
  flag: e,
  namespace: t,
  target: n
}) {
  const r = n || xZ({ flag: e, namespace: t });
  return CZ(r);
}
function SR() {
  return typeof navigator < "u" && /android/i.test(navigator.userAgent);
}
function kZ() {
  return typeof navigator < "u" && /iPhone|iPod/.test(navigator.userAgent);
}
function EZ() {
  return typeof navigator < "u" && (/iPad/.test(navigator.userAgent) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
}
function y1() {
  return kZ() || EZ();
}
var i4 = /* @__PURE__ */ new Map(), SZ = ({
  projectId: e,
  walletConnectParameters: t,
  rkDetailsShowQrModal: n
}) => {
  let r = {
    ...t || {},
    projectId: e,
    showQrModal: !1
    // Required. Otherwise WalletConnect modal (Web3Modal) will popup during time of connection for a wallet
  };
  n && (r = { ...r, showQrModal: !0 });
  const i = JSON.stringify(r), o = i4.get(i);
  if (o)
    return o;
  const s = Xw(r);
  return i4.set(i, s), s;
};
function AZ({
  projectId: e,
  walletDetails: t,
  walletConnectParameters: n
}) {
  return (r) => ({
    ...SZ({
      projectId: e,
      walletConnectParameters: n,
      // Used in `connectorsForWallets` to add another
      // walletConnect wallet into rainbowkit with modal popup option
      rkDetailsShowQrModal: t.rkDetails.showQrModal
    })(r),
    ...t
  });
}
function m1({
  projectId: e,
  walletConnectParameters: t
}) {
  const n = "21fef48091f12692cad574a6f7753643";
  if (!e || e === "")
    throw new Error(
      "No projectId found. Every dApp must now provide a WalletConnect Cloud projectId to enable WalletConnect v2 https://www.rainbowkit.com/docs/installation#configure"
    );
  return e === "YOUR_PROJECT_ID" && (e = n), (r) => AZ({
    projectId: e,
    walletDetails: r,
    walletConnectParameters: t
  });
}
var o4 = ({
  projectId: e,
  options: t
}) => ({
  id: "walletConnect",
  name: "WalletConnect",
  installed: void 0,
  iconUrl: async () => (await import("./walletConnectWallet-FNSU4KNU-BcDqBkw6.js")).default,
  iconBackground: "#3b99fc",
  qrCode: { getUri: (r) => r },
  createConnector: m1({
    projectId: e,
    walletConnectParameters: t
  })
}), TZ = ({
  projectId: e,
  walletConnectParameters: t
}) => {
  const n = ER({ flag: "isRainbow" }), r = !n, i = (o) => SR() ? o : y1() ? `rainbow://wc?uri=${encodeURIComponent(o)}&connector=rainbowkit` : `https://rnbwapp.com/wc?uri=${encodeURIComponent(
    o
  )}&connector=rainbowkit`;
  return {
    id: "rainbow",
    name: "Rainbow",
    rdns: "me.rainbow",
    iconUrl: async () => (await import("./rainbowWallet-2SR6TVBF-Bl7JUym4.js")).default,
    iconBackground: "#0c2f78",
    installed: r ? void 0 : n,
    downloadUrls: {
      android: "https://play.google.com/store/apps/details?id=me.rainbow&referrer=utm_source%3Drainbowkit&utm_source=rainbowkit",
      ios: "https://apps.apple.com/app/apple-store/id1457119021?pt=119997837&ct=rainbowkit&mt=8",
      mobile: "https://rainbow.download?utm_source=rainbowkit",
      qrCode: "https://rainbow.download?utm_source=rainbowkit&utm_medium=qrcode",
      browserExtension: "https://rainbow.me/extension?utm_source=rainbowkit"
    },
    mobile: { getUri: r ? i : void 0 },
    qrCode: r ? {
      getUri: i,
      instructions: {
        learnMoreUrl: "https://learn.rainbow.me/connect-to-a-website-or-app?utm_source=rainbowkit&utm_medium=connector&utm_campaign=learnmore",
        steps: [
          {
            description: "wallet_connectors.rainbow.qr_code.step1.description",
            step: "install",
            title: "wallet_connectors.rainbow.qr_code.step1.title"
          },
          {
            description: "wallet_connectors.rainbow.qr_code.step2.description",
            step: "create",
            title: "wallet_connectors.rainbow.qr_code.step2.title"
          },
          {
            description: "wallet_connectors.rainbow.qr_code.step3.description",
            step: "scan",
            title: "wallet_connectors.rainbow.qr_code.step3.title"
          }
        ]
      }
    } : void 0,
    createConnector: r ? m1({
      projectId: e,
      walletConnectParameters: t
    }) : p1({ flag: "isRainbow" })
  };
};
function _Z(e) {
  return !(!(e != null && e.isMetaMask) || e.isBraveWallet && !e._events && !e._state || e.isApexWallet || e.isAvalanche || e.isBackpack || e.isBifrost || e.isBitKeep || e.isBitski || e.isBlockWallet || e.isCoinbaseWallet || e.isDawn || e.isEnkrypt || e.isExodus || e.isFrame || e.isFrontier || e.isGamestop || e.isHyperPay || e.isImToken || e.isKuCoinWallet || e.isMathWallet || e.isNestWallet || e.isOkxWallet || e.isOKExWallet || e.isOneInchIOSWallet || e.isOneInchAndroidWallet || e.isOpera || e.isPhantom || e.isPortal || e.isRabby || e.isRainbow || e.isStatus || e.isTalisman || e.isTally || e.isTokenPocket || e.isTokenary || e.isTrust || e.isTrustWallet || e.isXDEFI || e.isZeal || e.isZerion || e.__seif);
}
var IZ = ({
  projectId: e,
  walletConnectParameters: t
}) => {
  var o, s;
  const n = ER({ flag: "isMetaMask" }), r = !n, i = (a) => SR() ? a : y1() ? (
    // currently broken in MetaMask v6.5.0 https://github.com/MetaMask/metamask-mobile/issues/6457
    `metamask://wc?uri=${encodeURIComponent(a)}`
  ) : `https://metamask.app.link/wc?uri=${encodeURIComponent(a)}`;
  return {
    id: "metaMask",
    name: "MetaMask",
    rdns: "io.metamask",
    iconUrl: async () => (await import("./metaMaskWallet-YFHEHW7V-C_orXIhs.js")).default,
    iconAccent: "#f6851a",
    iconBackground: "#fff",
    installed: r ? void 0 : n,
    downloadUrls: {
      android: "https://play.google.com/store/apps/details?id=io.metamask",
      ios: "https://apps.apple.com/us/app/metamask/id1438144202",
      mobile: "https://metamask.io/download",
      qrCode: "https://metamask.io/download",
      chrome: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn",
      edge: "https://microsoftedge.microsoft.com/addons/detail/metamask/ejbalbakoplchlghecdalmeeeajnimhm",
      firefox: "https://addons.mozilla.org/firefox/addon/ether-metamask",
      opera: "https://addons.opera.com/extensions/details/metamask-10",
      browserExtension: "https://metamask.io/download"
    },
    mobile: {
      getUri: r ? i : void 0
    },
    qrCode: r ? {
      getUri: i,
      instructions: {
        learnMoreUrl: "https://metamask.io/faqs/",
        steps: [
          {
            description: "wallet_connectors.metamask.qr_code.step1.description",
            step: "install",
            title: "wallet_connectors.metamask.qr_code.step1.title"
          },
          {
            description: "wallet_connectors.metamask.qr_code.step2.description",
            step: "create",
            title: "wallet_connectors.metamask.qr_code.step2.title"
          },
          {
            description: "wallet_connectors.metamask.qr_code.step3.description",
            step: "refresh",
            title: "wallet_connectors.metamask.qr_code.step3.title"
          }
        ]
      }
    } : void 0,
    extension: {
      instructions: {
        learnMoreUrl: "https://metamask.io/faqs/",
        steps: [
          {
            description: "wallet_connectors.metamask.extension.step1.description",
            step: "install",
            title: "wallet_connectors.metamask.extension.step1.title"
          },
          {
            description: "wallet_connectors.metamask.extension.step2.description",
            step: "create",
            title: "wallet_connectors.metamask.extension.step2.title"
          },
          {
            description: "wallet_connectors.metamask.extension.step3.description",
            step: "refresh",
            title: "wallet_connectors.metamask.extension.step3.title"
          }
        ]
      }
    },
    createConnector: r ? m1({
      projectId: e,
      walletConnectParameters: t
    }) : p1({
      target: typeof window < "u" ? ((s = (o = window.ethereum) == null ? void 0 : o.providers) == null ? void 0 : s.find(
        _Z
      )) ?? window.ethereum : void 0
    })
  };
}, RZ = () => ({
  id: "injected",
  name: "Browser Wallet",
  iconUrl: async () => (await import("./injectedWallet-H7LYKTQS-BcH4iEPb.js")).default,
  iconBackground: "#fff",
  createConnector: p1({})
}), AR = ({ appName: e, appIcon: t }) => {
  const n = (i) => i, r = y1();
  return {
    id: "coinbase",
    name: "Coinbase Wallet",
    shortName: "Coinbase",
    rdns: "com.coinbase.wallet",
    iconUrl: async () => (await import("./coinbaseWallet-WWX6LF36-8KvfY4sn.js")).default,
    iconAccent: "#2c5ff6",
    iconBackground: "#2c5ff6",
    // If the coinbase wallet browser extension is not installed, a popup will appear
    // prompting the user to connect or create a wallet via passkey. This means if you either have
    // or don't have the coinbase wallet browser extension installed it'll do some action anyways
    installed: !0,
    downloadUrls: {
      android: "https://play.google.com/store/apps/details?id=org.toshi",
      ios: "https://apps.apple.com/us/app/coinbase-wallet-store-crypto/id1278383455",
      mobile: "https://coinbase.com/wallet/downloads",
      qrCode: "https://coinbase-wallet.onelink.me/q5Sx/fdb9b250",
      chrome: "https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad",
      browserExtension: "https://coinbase.com/wallet"
    },
    ...r ? {} : {
      qrCode: {
        getUri: n,
        instructions: {
          learnMoreUrl: "https://coinbase.com/wallet/articles/getting-started-mobile",
          steps: [
            {
              description: "wallet_connectors.coinbase.qr_code.step1.description",
              step: "install",
              title: "wallet_connectors.coinbase.qr_code.step1.title"
            },
            {
              description: "wallet_connectors.coinbase.qr_code.step2.description",
              step: "create",
              title: "wallet_connectors.coinbase.qr_code.step2.title"
            },
            {
              description: "wallet_connectors.coinbase.qr_code.step3.description",
              step: "scan",
              title: "wallet_connectors.coinbase.qr_code.step3.title"
            }
          ]
        }
      },
      extension: {
        instructions: {
          learnMoreUrl: "https://coinbase.com/wallet/articles/getting-started-extension",
          steps: [
            {
              description: "wallet_connectors.coinbase.extension.step1.description",
              step: "install",
              title: "wallet_connectors.coinbase.extension.step1.title"
            },
            {
              description: "wallet_connectors.coinbase.extension.step2.description",
              step: "create",
              title: "wallet_connectors.coinbase.extension.step2.title"
            },
            {
              description: "wallet_connectors.coinbase.extension.step3.description",
              step: "refresh",
              title: "wallet_connectors.coinbase.extension.step3.title"
            }
          ]
        }
      }
    },
    createConnector: (i) => {
      const o = hy({
        appName: e,
        appLogoUrl: t,
        preference: AR.preference
      });
      return (s) => ({
        ...o(s),
        ...i
      });
    }
  };
};
const PZ = {
  id: 88,
  name: "Viction",
  iconUrl: Fa("vic"),
  nativeCurrency: {
    decimals: 18,
    name: "Viction",
    symbol: "VIC"
  },
  rpcUrls: {
    public: { http: ["https://rpc.tomochain.com"] },
    default: { http: ["https://rpc.tomochain.com"] }
  }
}, OZ = async ({
  queryClient: e,
  forceWalletConnectOnly: t,
  yieldGetMyNetworks: n
}) => ky({ queryClient: e, yieldGetMyNetworks: n }).caseOf({
  Right: (r) => {
    const i = Bp(
      Np({
        [Ue.Ethereum]: {
          type: "evm",
          skChainName: Ue.Ethereum,
          wagmiChain: Fc
        },
        [Ue.Polygon]: {
          type: "evm",
          skChainName: Ue.Polygon,
          wagmiChain: tK
        },
        [Ue.Optimism]: {
          type: "evm",
          skChainName: Ue.Optimism,
          wagmiChain: eK
        },
        [Ue.Arbitrum]: {
          type: "evm",
          skChainName: Ue.Arbitrum,
          wagmiChain: PH
        },
        [Ue.AvalancheC]: {
          type: "evm",
          skChainName: Ue.AvalancheC,
          wagmiChain: OH
        },
        [Ue.Celo]: {
          type: "evm",
          skChainName: Ue.Celo,
          wagmiChain: {
            ...GH,
            iconUrl: hs(Ue.Celo)
          }
        },
        [Ue.Harmony]: {
          type: "evm",
          skChainName: Ue.Harmony,
          wagmiChain: {
            ...YH,
            iconUrl: hs(Ue.Harmony)
          }
        },
        [Ue.Viction]: {
          type: "evm",
          skChainName: Ue.Viction,
          wagmiChain: PZ
        },
        [Ue.Binance]: {
          type: "evm",
          skChainName: Ue.Binance,
          wagmiChain: NH
        },
        [Ue.Base]: {
          type: "evm",
          skChainName: Ue.Base,
          wagmiChain: BH
        },
        [Ue.Linea]: {
          type: "evm",
          skChainName: Ue.Linea,
          wagmiChain: {
            ...ZH,
            iconUrl: hs(Ue.Linea)
          }
        },
        [Ue.Core]: {
          type: "evm",
          skChainName: Ue.Core,
          wagmiChain: {
            ...HH,
            name: "Core",
            iconUrl: hs(Ue.Core)
          }
        },
        [Ue.EthereumHolesky]: {
          type: "evm",
          skChainName: Ue.EthereumHolesky,
          wagmiChain: QH
        },
        [Ue.EthereumGoerli]: {
          type: "evm",
          skChainName: Ue.EthereumGoerli,
          wagmiChain: KH
        }
      }).filter(([a, l]) => r.has(l.skChainName))
    ), o = Object.values(i).map(
      (a) => a.wagmiChain
    ), s = {
      groupName: "Ethereum",
      wallets: t ? [o4] : [
        IZ,
        RZ,
        o4,
        TZ,
        AR
      ]
    };
    return Promise.resolve({
      evmChainsMap: i,
      evmChains: o,
      connector: G.fromPredicate(() => !!o.length, s)
    });
  },
  Left: (r) => Promise.reject(r)
}), BZ = (e) => de(
  () => e.queryClient.fetchQuery({
    staleTime: Number.POSITIVE_INFINITY,
    queryKey: [Vt.appPrefix, "evm-config"],
    queryFn: () => OZ(e)
  })
).mapLeft((t) => new Error("Could not get evm config"));
class NZ {
  constructor(t) {
    this.variantProvider = t;
  }
  invalidProviderType() {
    return de.liftEither(Xe(new Error("Invalid provider type")));
  }
  sendTransaction(t) {
    const n = this.variantProvider.current.provider.sendTransaction;
    return n ? de(() => n(t)).mapLeft((r) => new Error("Failed to send transaction")) : this.invalidProviderType();
  }
  switchChain({ chainId: t }) {
    return de(
      () => this.variantProvider.current.provider.switchChain(t)
    ).mapLeft((n) => new Error("Failed to switch chain"));
  }
  signMessage(t) {
    return de(
      () => this.variantProvider.current.provider.signMessage(t)
    ).mapLeft((n) => new Error("Failed to sign message"));
  }
}
const ul = {
  id: "externalProviderConnector",
  name: "External Provider",
  type: "externalProvider"
}, ld = (e) => e.id === ul.id, DZ = (e) => ({
  groupName: "External Providers",
  wallets: [
    () => ({
      id: ul.id,
      name: ul.name,
      iconUrl: Vt.appIcon,
      iconBackground: "#fff",
      createConnector: () => (t) => {
        const n = new Ua(
          G.fromNullable(e.current.supportedChainIds).map((m) => new Set(m)).mapOrDefault(
            (m) => t.chains.filter((g) => m.has(g.id)),
            t.chains
          )
        ), r = new NZ(e), i = async () => [e.current.currentAddress], o = async () => n.getValue()[0].id, s = async () => {
          t.emitter.emit("message", { type: "connecting" });
          const [m, g] = await Promise.all([
            i(),
            o()
          ]);
          return { accounts: m, chainId: g };
        }, a = async ({ chainId: m }) => (await de.liftEither(
          pt.find(
            (g) => g.id === m,
            t.chains
          ).toEither(new Error("Chain not found"))
        ).chain(
          (g) => r.switchChain({ chainId: `0x${m.toString(16)}` }).map(() => g)
        ).ifRight((g) => f(g.id.toString()))).unsafeCoerce(), l = async () => {
        }, c = async () => ({}), u = async () => !0, d = () => {
          t.emitter.emit("disconnect");
        }, f = (m) => {
          t.emitter.emit("change", {
            chainId: KX(m)
          });
        }, h = (m) => {
          t.emitter.emit("change", {
            accounts: m.filter((g) => !!g).map((g) => Qn(g))
          });
        }, p = ({ currentChainId: m, supportedChainIds: g }) => {
          n.next(
            G.fromFalsy(!!g.length).map(() => new Set(g)).mapOrDefault(
              (v) => t.chains.filter((w) => v.has(w.id)),
              t.chains
            )
          ), n.getValue().every((v) => v.id !== m) && o().then(
            (v) => f(v.toString())
          );
        };
        return {
          id: ul.id,
          name: ul.name,
          type: ul.type,
          getAccounts: i,
          getChainId: o,
          connect: s,
          disconnect: l,
          getProvider: c,
          isAuthorized: u,
          onDisconnect: d,
          onChainChanged: f,
          onAccountsChanged: h,
          switchChain: a,
          sendTransaction: r.sendTransaction.bind(r),
          signMessage: r.signMessage.bind(r),
          $filteredChains: n.asObservable(),
          onSupportedChainsChanged: p
        };
      }
    })
  ]
}), jZ = [Vt.appPrefix, "ledger-live-config"], MZ = Number.POSITIVE_INFINITY, FZ = async ({
  enabledChainsMap: e,
  queryParams: t
}) => de.liftEither(
  G.fromFalsy(Pd()).toEither(null)
).chain(
  () => de(() => import("./ledger-connector-CMXXjUEM.js")).mapLeft(() => new Error("Could not import ledger-connector")).map((n) => n.ledgerLiveConnector({ enabledChainsMap: e, queryParams: t }))
).chainLeft((n) => de.liftEither(n ? Xe(n) : _e(null))).caseOf({
  Right: (n) => Promise.resolve(n),
  Left: (n) => Promise.reject(n)
}), LZ = (e) => de(
  () => e.queryClient.fetchQuery({
    staleTime: MZ,
    queryKey: jZ,
    queryFn: () => FZ(e)
  })
).mapLeft((t) => new Error("Could not get ledger live config")), UZ = {
  id: 397,
  name: "NEAR Protocol",
  iconUrl: Fa("near"),
  nativeCurrency: {
    decimals: 24,
    name: "Near",
    symbol: "NEAR"
  },
  rpcUrls: {
    public: { http: ["https://rpc.mainnet.near.org"] },
    default: { http: ["https://rpc.mainnet.near.org"] }
  }
}, zZ = {
  id: 1729,
  name: "Tezos",
  iconUrl: Fa("xtz"),
  nativeCurrency: {
    decimals: 6,
    name: "Tezos",
    symbol: "XTZ"
  },
  rpcUrls: {
    public: { http: ["https://rpc.tzbeta.net/"] },
    default: { http: ["https://rpc.tzbeta.net/"] }
  }
}, VZ = {
  id: 501,
  name: "Solana",
  iconUrl: Fa("sol"),
  nativeCurrency: {
    decimals: 9,
    name: "Solana",
    symbol: "SOL"
  },
  rpcUrls: {
    public: { http: ["https://api.mainnet-beta.solana.com/"] },
    default: { http: ["https://api.mainnet-beta.solana.com/"] }
  }
}, qZ = {
  id: 79,
  name: "Tron",
  iconUrl: Fa("trx"),
  nativeCurrency: {
    decimals: 6,
    name: "Tron",
    symbol: "TRX"
  },
  rpcUrls: {
    public: { http: ["https://api.trongrid.io"] },
    default: { http: ["https://api.trongrid.io"] }
  }
}, $Z = {
  id: 3412,
  name: "Ton",
  iconUrl: Fa("ton"),
  nativeCurrency: {
    decimals: 9,
    name: "Toncoin",
    symbol: "TON"
  },
  rpcUrls: {
    public: { http: ["https://ton.nownodes.io"] },
    default: { http: ["https://ton.nownodes.io"] }
  }
}, WZ = [Vt.appPrefix, "misc-config"], GZ = Number.POSITIVE_INFINITY, HZ = async ({
  enabledNetworks: e,
  forceWalletConnectOnly: t
}) => {
  const n = Np({
    [Jt.Near]: {
      type: "misc",
      skChainName: Jt.Near,
      wagmiChain: UZ
    },
    [Jt.Tezos]: {
      type: "misc",
      skChainName: Jt.Tezos,
      wagmiChain: zZ
    },
    [Jt.Solana]: {
      type: "misc",
      skChainName: Jt.Solana,
      wagmiChain: VZ
    },
    [Jt.Tron]: {
      type: "misc",
      skChainName: Jt.Tron,
      wagmiChain: qZ
    },
    [Jt.Ton]: {
      type: "misc",
      skChainName: Jt.Ton,
      wagmiChain: $Z
    }
  }).filter(([o, s]) => e.has(s.skChainName)), r = Bp(n), i = Object.values(r).map((o) => o.wagmiChain);
  return Promise.all([
    Fn.liftMaybe(G.fromFalsy(r.tron)).chain(
      () => Fn(() => import("./tron-connector-Duacdtte.js").then((o) => o.t)).map(
        (o) => o.getTronConnectors({ forceWalletConnectOnly: t })
      )
    )
  ]).then((o) => ({
    miscChainsMap: r,
    miscChains: i,
    connectors: o
  }));
}, KZ = (e) => de(
  () => e.queryClient.fetchQuery({
    staleTime: GZ,
    queryKey: WZ,
    queryFn: () => HZ(e)
  })
).mapLeft((t) => new Error("Could not get misc config")), YZ = [Vt.appPrefix, "safe-config"], QZ = Number.POSITIVE_INFINITY, JZ = async () => de(() => import("./safe-connector-6S3BtLW7.js")).mapLeft(() => new Error("Could not import safe-connector")).map((e) => e.safeConnector()).chainLeft((e) => de.liftEither(e ? Xe(e) : _e(null))).caseOf({
  Right: (e) => Promise.resolve(e),
  Left: (e) => Promise.reject(e)
}), XZ = (e) => de(
  () => e.queryClient.fetchQuery({
    staleTime: QZ,
    queryKey: YZ,
    queryFn: () => JZ()
  })
).mapLeft((t) => new Error("Could not get safe config")), ZZ = {
  id: 9999,
  name: "Polkadot",
  iconUrl: hs(W.Polkadot),
  nativeCurrency: {
    decimals: 10,
    name: "Polkadot",
    symbol: "DOT"
  },
  rpcUrls: {
    public: {
      http: [
        "https://rpc.polkadot.io",
        "https://flashy-side-arrow.dot-mainnet.quiknode.pro/97d5006f66e37488fb9dc1575ef8960e3870dd0f/"
      ],
      webSocket: ["wss://rpc.polkadot.io"]
    },
    default: {
      http: [
        "https://rpc.polkadot.io",
        "https://flashy-side-arrow.dot-mainnet.quiknode.pro/97d5006f66e37488fb9dc1575ef8960e3870dd0f/"
      ],
      webSocket: ["wss://rpc.polkadot.io"]
    }
  }
}, eee = [Vt.appPrefix, "substrate-config"], tee = Number.POSITIVE_INFINITY, nee = async ({
  queryClient: e,
  yieldGetMyNetworks: t
}) => ky({ queryClient: e, yieldGetMyNetworks: t }).caseOf({
  Right: (n) => {
    const r = Bp(
      Np({
        [Ta.Polkadot]: {
          type: "substrate",
          skChainName: Ta.Polkadot,
          wagmiChain: ZZ
        }
      }).filter(([o, s]) => n.has(s.skChainName))
    ), i = Pd() ? Object.values(r).map((o) => o.wagmiChain) : [];
    return Promise.resolve({ substrateChainsMap: r, substrateChains: i });
  },
  Left: (n) => Promise.reject(n)
}), ree = (e) => de(
  () => e.queryClient.fetchQuery({
    staleTime: tee,
    queryKey: eee,
    queryFn: () => nee(e)
  })
).mapLeft((t) => new Error("Could not get substrate config")), iee = async (e) => ky({
  queryClient: e.queryClient,
  yieldGetMyNetworks: e.yieldGetMyNetworks
}).chain(
  (t) => de.fromPromise(
    () => {
      var n;
      return Promise.all([
        BZ({
          forceWalletConnectOnly: e.forceWalletConnectOnly,
          queryClient: e.queryClient,
          yieldGetMyNetworks: e.yieldGetMyNetworks
        }),
        wZ({
          forceWalletConnectOnly: e.forceWalletConnectOnly,
          queryClient: e.queryClient,
          yieldGetMyNetworks: e.yieldGetMyNetworks
        }),
        KZ({
          enabledNetworks: t,
          queryClient: e.queryClient,
          forceWalletConnectOnly: e.forceWalletConnectOnly
        }),
        ree({
          queryClient: e.queryClient,
          yieldGetMyNetworks: e.yieldGetMyNetworks
        }),
        _y({
          isLedgerLive: e.isLedgerLive,
          queryClient: e.queryClient,
          yieldYieldOpportunity: e.yieldYieldOpportunity,
          externalProviders: (n = e.externalProviders) == null ? void 0 : n.current
        })
      ]).then(
        ([r, i, o, s, a]) => r.chain(
          (l) => i.chain(
            (c) => o.chain(
              (u) => s.chain(
                (d) => a.map((f) => ({
                  evmConfig: l,
                  cosmosConfig: c,
                  miscConfig: u,
                  substrateConfig: d,
                  queryParams: f
                }))
              )
            )
          )
        )
      );
    }
  )
).chain(
  (t) => LZ({
    enabledChainsMap: {
      evm: t.evmConfig.evmChainsMap,
      cosmos: t.cosmosConfig.cosmosChainsMap,
      misc: t.miscConfig.miscChainsMap,
      substrate: t.substrateConfig.substrateChainsMap
    },
    queryClient: e.queryClient,
    queryParams: t.queryParams
  }).map((n) => ({ ...t, ledgerLiveConnector: n }))
).chain(
  (t) => de.liftEither(G.fromFalsy(e.isSafe).toEither(null)).chain(() => XZ({ queryClient: e.queryClient })).chainLeft((n) => de.liftEither(n ? Xe(n) : _e(null))).map((n) => ({ ...t, safeConnector: n }))
).map((t) => {
  const {
    evmConfig: n,
    cosmosConfig: r,
    miscConfig: i,
    substrateConfig: o,
    ledgerLiveConnector: s
  } = t, a = [
    ...n.evmChains,
    ...r.cosmosWagmiChains,
    ...i.miscChains,
    ...o.substrateChains
  ], l = !e.disableInjectedProviderDiscovery && !e.externalProviders && !t.ledgerLiveConnector && !t.safeConnector, c = (e.externalProviders ? [DZ(e.externalProviders)] : t.safeConnector ? [t.safeConnector] : s ? [s] : e.customConnectors ? e.customConnectors(a) : G.catMaybes([
    n.connector,
    r.connector,
    ...i.connectors
  ])).map((d) => ({
    ...d,
    wallets: d.wallets.map((f) => (h) => {
      const p = f(h);
      return e.mapWalletFn ? {
        ...p,
        ...e.mapWalletFn({
          iconBackground: p.iconBackground,
          iconUrl: p.iconUrl,
          id: p.id,
          name: p.name
        })
      } : p;
    })
  })), u = G.fromNullable(t.queryParams.network).chainNullable(
    (d) => t.evmConfig.evmChainsMap[d] ?? t.cosmosConfig.cosmosChainsMap[d] ?? t.miscConfig.miscChainsMap[d] ?? t.substrateConfig.substrateChainsMap[d]
  ).map((d) => d.wagmiChain.id).extract();
  return {
    ...t,
    wagmiConfig: mI({
      chains: a,
      client: ({ chain: d }) => ry({ chain: d, transport: uI() }),
      multiInjectedProviderDiscovery: l,
      connectors: xX(c, {
        appName: Vt.appName,
        appIcon: Vt.appIcon,
        projectId: Vt.walletConnectV2.projectId
      })
    }),
    queryParamsInitChainId: u
  };
}).caseOf({
  Right: async (t) => t,
  Left: (t) => Promise.reject(t)
}), oee = [Vt.appPrefix, "wagmi-config"], see = Number.POSITIVE_INFINITY, ef = () => {
  const {
    wagmi: e,
    externalProviders: t,
    isSafe: n,
    disableInjectedProviderDiscovery: r,
    mapWalletFn: i
  } = bt(), o = ci(), s = l7(), a = Fs(), l = Dt(t);
  return Ut({
    staleTime: see,
    queryKey: oee,
    queryFn: () => iee({
      mapWalletFn: i,
      disableInjectedProviderDiscovery: !!r,
      forceWalletConnectOnly: !!(e != null && e.forceWalletConnectOnly),
      customConnectors: e == null ? void 0 : e.__customConnectors__,
      queryClient: o,
      isLedgerLive: Pd(),
      isSafe: !!n,
      yieldGetMyNetworks: s,
      yieldYieldOpportunity: a,
      ...l.current && {
        externalProviders: l
      }
    })
  });
}, aee = mI({
  chains: [Fc],
  client: ({ chain: e }) => ry({
    chain: e,
    transport: uI(e.rpcUrls.default.http.find((t) => !!t))
  })
}), lee = () => {
  const e = ef(), { externalProviders: t } = bt();
  return Ut({
    staleTime: Number.POSITIVE_INFINITY,
    enabled: !!e.data,
    queryKey: ["wagmi-config-init"],
    queryFn: () => {
      var i, o;
      const n = (i = e.data) == null ? void 0 : i.wagmiConfig, r = (o = e.data) == null ? void 0 : o.queryParamsInitChainId;
      if (n)
        return de(() => UW(n)).chainLeft(async () => _e(null)).chain(async (s) => t || s != null && s.length || Pd() || !yL() ? _e(null) : de.liftEither(
          pt.find(
            (a) => a.id === "injected" || a.id === uT.id,
            n.connectors
          ).toEither(new Error("Could not find injected connector"))
        ).chain(
          (a) => de(
            () => aI(n, {
              connector: a,
              chainId: r
            })
          )
        ).chainLeft(async () => _e(null))).chain(() => r && n.state.chainId !== r ? de(
          () => fI(n, { chainId: r })
        ).chainLeft(async () => _e(null)) : de.liftEither(_e(null))).run().then((s) => s.unsafeCoerce());
    }
  });
}, cee = () => {
  const { variant: e, tracking: t } = bt(), n = Ut({
    queryKey: ["tracking", e],
    staleTime: Number.POSITIVE_INFINITY,
    queryFn: async () => e !== "zerion" ? null : (await de(() => import("./tracking-variants-Cd5F3ZlN.js")).ifRight((r) => (r.initMixpanel(Vt[e].tracking), r.tracking)).map((r) => r.tracking)).unsafeCoerce()
  });
  return { tracking: t, variantTracking: n.data ?? void 0 };
}, s4 = {
  earn: "Earn",
  positions: "Positions",
  activity: "Activity",
  positionDetails: "Position details",
  stakeReview: "Stake review",
  unstakeReview: "Unstake review",
  pendingActionReview: "Pending action review",
  stakingSteps: "Staking steps",
  unstakeSteps: "Unstake steps",
  activitySteps: "Activity steps",
  pendingActionSteps: "Pending action steps",
  stakeComplete: "Stake complete",
  activityComplete: "Activity complete",
  unstakeComplete: "Unstake complete",
  pendingActionCompelete: "Pending action complete"
}, a4 = {
  tabClicked: "Tab clicked",
  connectWalletClicked: "Connect wallet clicked",
  addLedgerAccountClicked: "Add ledger account clicked",
  selectTokenModalOpened: "Select token modal opened",
  tokenSelected: "Token selected",
  selectYieldModalOpened: "Select yield modal opened",
  yieldSelected: "Yield selected",
  selectValidatorModalOpened: "Select validator modal opened",
  selectValidatorModalClosed: "Select validator modal closed",
  selectValidatorViewMoreClicked: "Select validator view more clicked",
  validatorSelected: "Validator selected",
  validatorRemoved: "Validator removed",
  widgetDisconnectClicked: "Widget disconnect clicked",
  backClicked: "Back clicked",
  helpModalOpened: "Help modal opened",
  earnPageMaxClicked: "Earn page max clicked",
  connectedWallet: "Connected wallet",
  importValidatorModalOpened: "Import validator modal opened",
  chainModalOpened: "Chain modal opened",
  accountModalOpened: "Account modal opened",
  termsClicked: "Terms clicked",
  txSigned: "Transaction signed",
  txSubmitted: "Transaction submitted",
  txNotConfirmed: "Transaction not confirmed",
  positionDetailsPageMaxClicked: "Position details page max clicked",
  unstakeClicked: "Unstake clicked",
  pendingActionClicked: "Pending action clicked",
  validatorsSubmitted: "Validators submitted",
  validatorImported: "Validator imported",
  viewTxClicked: "View transaction clicked"
}, g1 = Ge(
  void 0
), uee = ({
  children: e,
  tracking: t,
  variantTracking: n
}) => {
  const r = Ie(
    (s, a) => {
      t == null || t.trackEvent(a4[s], ...a ? [a] : []), n == null || n.trackEvent(
        a4[s],
        ...a ? [a] : []
      );
    },
    [t, n]
  ), i = Ie(
    (s, a) => {
      t == null || t.trackPageView(s4[s], ...a ? [a] : []), n == null || n.trackPageView(
        s4[s],
        ...a ? [a] : []
      );
    },
    [t, n]
  ), o = J(
    () => ({ trackEvent: r, trackPageView: i }),
    [r, i]
  );
  return /* @__PURE__ */ y.jsx(g1.Provider, { value: o, children: e });
}, TR = () => {
  const e = we(g1);
  if (e === void 0)
    throw new Error("useTracking must be used within a TrackingContext");
  return e;
}, dee = ({
  children: e
}) => /* @__PURE__ */ y.jsx(uee, { ...cee(), children: e }), cn = () => TR().trackEvent;
class fee extends Error {
  constructor() {
    super(...arguments);
    pr(this, "name", "SendTransactionError");
  }
}
class hee extends Error {
  constructor() {
    super(...arguments);
    pr(this, "name", "NotSupportedFlowError");
  }
}
class l4 extends Error {
  constructor({ network: n, txId: r }) {
    super();
    pr(this, "txId");
    pr(this, "network");
    pr(this, "name", "SignError");
    this.txId = r, this.network = n;
  }
}
class lu extends Error {
  constructor() {
    super(...arguments);
    pr(this, "name", "TransactionConstructError");
  }
}
class pee extends Error {
  constructor() {
    super(...arguments);
    pr(this, "name", "TXCheckError");
  }
}
class Wf extends Error {
  constructor() {
    super(...arguments);
    pr(this, "name", "TransactionDecodeError");
  }
}
class yee extends Error {
  constructor() {
    super(...arguments);
    pr(this, "name", "SubmitHashError");
  }
}
class mee extends Error {
  constructor() {
    super(...arguments);
    pr(this, "name", "SubmitError");
  }
}
const gee = { type: "cosmosProvider" }, Ey = (e) => e.type === gee.type, vee = {
  id: "ledgerLive",
  name: "Ledger Live",
  type: "ledgerLive"
}, bo = (e) => e.id === vee.id, bee = {
  tronLink: {
    id: "tronLink",
    name: "TronLink",
    type: "tronLinkProvider"
  },
  tronWc: {
    id: "tronWc",
    name: "Wallet Connect",
    type: "tronWcProvider"
  },
  tronBg: {
    id: "tronBg",
    name: "Bitget",
    type: "tronBgProvider"
  },
  tronLedger: {
    id: "tronLedger",
    name: "Ledger",
    type: "tronLedgerProvider"
  }
}, wee = (e) => Object.values(bee).some((t) => t.id === e.id), ys = (e) => `${Vt.appPrefix}@1//${e}`, xee = {
  [ys("skPubKeys")]: jm(lr, lr),
  [ys("customValidators")]: jm(
    lr,
    jm(
      lr,
      nk(
        wn.interface({
          integrationId: lr,
          validatorAddresses: nk(lr)
        })
      )
    )
  ),
  [ys("referralCode")]: lr,
  [ys("shimDisconnect/tron")]: iL
}, Sy = (e) => {
  const t = Tn.extractNullable();
  if (!t) return _e(null);
  const n = t.localStorage.getItem(e);
  return n ? Hn.encase(() => JSON.parse(n)).chainLeft(() => _e(n)).chain(
    (r) => xee[e].decode(r).map((i) => i).mapLeft((i) => new Error(i))
  ) : _e(null);
}, np = (e, t) => {
  const n = Tn.extractNullable();
  return Hn.encase(
    () => n == null ? void 0 : n.localStorage.setItem(e, JSON.stringify(t))
  ).ifRight(() => kee(e));
}, Hb = {
  [ys("customValidators")]: /* @__PURE__ */ new Map(),
  [ys("skPubKeys")]: /* @__PURE__ */ new Map(),
  [ys("referralCode")]: /* @__PURE__ */ new Map(),
  [ys("shimDisconnect/tron")]: /* @__PURE__ */ new Map()
}, Cee = (e, t) => (Hb[e].set(t, t), () => Hb[e].delete(t)), kee = (e) => {
  Sy(e).ifRight(
    (t) => Hb[e].forEach((n) => {
      n(t);
    })
  );
}, _R = (e) => {
  const [t] = Oe(
    () => new Ua(null)
  ), n = Ie(
    (o) => {
      if (!e || !Ey(e))
        return () => {
        };
      const s = e.$chainWallet.subscribe((a) => {
        t.next(a), o();
      });
      return () => s.unsubscribe();
    },
    [e, t]
  ), r = Ie(() => t.value, [t]), i = Ie(() => t.value, [t.value]);
  return Dr(n, r, i);
}, Eee = ({
  connector: e,
  address: t,
  isConnected: n
}) => {
  const r = _R(e);
  return Ut({
    queryKey: [
      "additional-addresses",
      e == null ? void 0 : e.id,
      r == null ? void 0 : r.chainId,
      t,
      n
    ],
    enabled: !!(e && t && n),
    queryFn: async () => r && e && Ey(e) ? (await See({ connector: e, chainWallet: r })).unsafeCoerce() : Promise.resolve(null)
  });
}, See = (e) => Ey(e.connector) ? Aee(e).map(
  (t) => ({
    cosmosPubKey: t
  })
) : de.liftEither(_e(null)), Aee = (e) => de.liftEither(Sy("sk-widget@1//skPubKeys")).chain((t) => t ? de(() => e.connector.getAccounts()).chain(
  (n) => de.liftEither(
    pt.head(n).toEither(new Error("no account"))
  )
).chain((n) => {
  const r = t[n];
  return r ? de.liftEither(_e(r)) : de.liftEither(Xe(null));
}) : de.liftEither(Xe(null))).chainLeft(
  () => de(
    () => e.chainWallet.client.getAccount(e.chainWallet.chainId)
  ).mapLeft((t) => new Error("missing account")).map((t) => e.connector.toBase64(t.pubkey))
), c4 = (e) => !!e.$filteredChains, IR = (e) => !ld(e) && !bo(e) && !ow(e), Tee = (e) => ow(e), _ee = ({
  wagmiConfig: e,
  connector: t
}) => {
  const [n] = Oe(() => new Ua([])), r = Ie(
    (s) => {
      if (!t || !c4(t))
        return () => {
        };
      const a = t.$filteredChains.subscribe((l) => {
        n.next(l), s();
      });
      return () => a.unsubscribe();
    },
    [t, n]
  ), i = Ie(() => !t || !c4(t) ? (e == null ? void 0 : e.evmConfig.evmChains) ?? Iee : n.value, [t, n.value, e == null ? void 0 : e.evmConfig.evmChains]), o = Ie(() => n.value, [n.value]);
  return Dr(r, i, o);
}, Iee = [], Ree = (e) => {
  const [t] = Oe(() => new Ua([])), n = Ie(
    (o) => {
      if (!e || !bo(e))
        return () => {
        };
      const s = e.$accountsOnCurrentChain.subscribe((a) => {
        t.next(a), o();
      });
      return () => s.unsubscribe();
    },
    [e, t]
  ), r = Ie(() => t.value, [t]), i = Ie(() => t.value, [t.value]);
  return Dr(n, r, i);
}, Pee = (e) => {
  const [t] = Oe(
    () => new Ua(void 0)
  ), n = Ie(
    (o) => {
      if (!e || !bo(e))
        return () => {
        };
      const s = e.$currentAccountId.subscribe((a) => {
        t.next(a), o();
      });
      return () => s.unsubscribe();
    },
    [e, t]
  ), r = Ie(() => t.value, [t]), i = Ie(() => t.value, [t.value]);
  return Dr(n, r, i);
}, RR = () => {
  const e = It(!0);
  return Te(() => {
    e.current && (e.current = !1);
  }, []), e.current;
}, Oee = (e, t) => {
  const n = RR();
  Te(() => {
    if (!n)
      return e();
  }, t);
}, Bee = ({
  address: e,
  chain: t,
  isConnected: n,
  isConnecting: r
}) => {
  const { externalProviders: i } = bt(), { connect: o } = SI(), s = EI(), a = J(
    () => pt.find(
      (d) => ld(d),
      s
    ).filter(ld),
    [s]
  ), l = Dt(o), c = Dt(a), u = Dt(t);
  Te(() => {
    n || r || !(i != null && i.currentAddress) || a.ifJust(
      (d) => l.current({ connector: d })
    );
  }, [
    n,
    r,
    i == null ? void 0 : i.currentAddress,
    a,
    l
  ]), Oee(() => {
    c.current.chain(
      (d) => G.fromNullable(u.current).map((f) => ({ c: f, conn: d }))
    ).ifJust((d) => {
      d.conn.onSupportedChainsChanged({
        supportedChainIds: (i == null ? void 0 : i.supportedChainIds) ?? [],
        currentChainId: d.c.id
      });
    });
  }, [i == null ? void 0 : i.supportedChainIds, c, u]), Te(() => {
    G.fromRecord({
      externalProviderConnector: a,
      address: G.fromNullable(e),
      chain: G.fromNullable(t)
    }).filter((d) => !!(d.address && d.chain && n)).ifJust((d) => {
      const f = i == null ? void 0 : i.currentAddress, h = i == null ? void 0 : i.currentChain;
      f !== d.address && d.externalProviderConnector.onAccountsChanged([
        f ?? ""
      ]), h && h !== d.chain.id && d.externalProviderConnector.onChainChanged(h.toString());
    });
  }, [
    e,
    t,
    a,
    i == null ? void 0 : i.currentAddress,
    i == null ? void 0 : i.currentChain,
    n
  ]);
};
var Kb = /* @__PURE__ */ ((e) => (e.Legacy = "0x1", e.EIP1559 = "0x2", e))(Kb || {});
const Nee = ({
  chain: e,
  cosmosChainsMap: t,
  evmChainsMap: n,
  miscChainsMap: r,
  substrateChainsMap: i
}) => {
  var o;
  return ((o = Object.values({
    ...n,
    ...t,
    ...r,
    ...i
  }).find((s) => s.wagmiChain.id === e.id)) == null ? void 0 : o.skChainName) ?? null;
}, u4 = ({
  address: e,
  decodedTx: t
}) => ({
  to: t.to,
  from: e,
  data: t.data,
  value: t.value ? Fe(t.value) : void 0,
  nonce: Fe(t.nonce),
  gas: Fe(t.gasLimit),
  chainId: Fe(t.chainId),
  ...t.maxFeePerGas ? {
    type: Kb.EIP1559,
    maxFeePerGas: Fe(t.maxFeePerGas),
    maxPriorityFeePerGas: t.maxPriorityFeePerGas ? Fe(t.maxPriorityFeePerGas) : void 0
  } : { type: Kb.Legacy }
}), Gf = wn.custom({
  decode: (e) => {
    if (typeof e != "string" && typeof e != "number")
      return Xe("Invalid value type");
    const t = BigInt(e);
    return _e(t);
  },
  encode: (e) => e.toString()
}), Dee = wn.custom({
  decode: (e) => typeof e == "string" && e.startsWith("0x") ? _e(e) : Xe("Invalid hex string"),
  encode: (e) => e
}), d4 = wn.custom({
  decode: (e) => typeof e == "string" && e.startsWith("0x") ? _e(e) : Xe("Invalid address"),
  encode: (e) => e
}), Rg = wn.interface({
  data: Dee,
  to: d4,
  gasLimit: Gf,
  from: d4,
  value: Dm(Gf),
  nonce: Tu,
  type: Tu,
  maxFeePerGas: Dm(Gf),
  maxPriorityFeePerGas: Dm(Gf),
  chainId: Tu
}), jee = wn.custom({
  decode(e) {
    const t = e;
    return t.raw_data && t.raw_data_hex && t.txID && "visible" in t ? _e(t) : Xe("Invalid Tron transaction");
  },
  encode(e) {
    return e;
  }
}), PR = Ge(void 0), Mee = ({ children: e }) => {
  const {
    isReconnecting: t,
    isConnected: n,
    isConnecting: r,
    address: i,
    connector: o,
    chain: s
  } = ur(), a = i, l = H9(), { isLoading: c } = lee(), u = o != null && o.connect && o.emitter ? o : void 0, { disconnectAsync: d } = oy(), { sendTransactionAsync: f } = UG(), { signMessageAsync: h } = AI(), p = Ree(u), m = Pee(u), g = _R(u), v = ef(), w = _ee({
    wagmiConfig: v.data,
    connector: u
  }), x = J(
    () => G.fromRecord({
      chain: G.fromNullable(s),
      wagmiConfig: G.fromNullable(v.data)
    }).map(
      (V) => Nee({
        chain: V.chain,
        evmChainsMap: V.wagmiConfig.evmConfig.evmChainsMap,
        cosmosChainsMap: V.wagmiConfig.cosmosConfig.cosmosChainsMap,
        miscChainsMap: V.wagmiConfig.miscConfig.miscChainsMap,
        substrateChainsMap: V.wagmiConfig.substrateConfig.substrateChainsMap
      })
    ).extractNullable(),
    [s, v.data]
  ), C = n && !!a && !!u && !!x, S = Eee({
    address: a,
    connector: u,
    isConnected: C
  }), k = c || r || t || v.isLoading || S.isLoading, A = cn();
  Te(() => {
    C && A("connectedWallet", { address: a, network: x });
  }, [a, C, x, A]), Bee({
    address: a,
    chain: s,
    isConnected: C,
    isConnecting: k
  }), Bo(() => {
    !k && n && !C && d();
  }, [n, d, C]);
  const b = J(
    () => de.liftEither(
      !C || !x || !u || !a ? Xe(new Error("No wallet connected")) : _e({
        conn: u,
        network: x,
        address: a
      })
    ),
    [u, C, x, a]
  ), T = Ie(
    ({ tx: V, ledgerHwAppId: N }) => b.chain(({ conn: M, address: U }) => bo(M) ? de.liftEither(
      G.fromNullable(m).toEither(
        new Error("currentAccountId missing")
      )
    ).chain(
      (F) => de.liftEither(
        Hn.encase(() => JSON.parse(V)).mapLeft(() => new Error("JSON.parse failed")).chain(
          ($) => Hn.encase(
            () => M.deserializeTransaction($)
          ).mapLeft(() => new Error("deserializeTransaction failed"))
        )
      ).map(($) => ({
        accountId: F,
        deserializedTransaction: $
      }))
    ).chain(
      ({ accountId: F, deserializedTransaction: $ }) => de(
        () => M.walletApiClient.transaction.signAndBroadcast(
          F,
          $,
          G.fromNullable(N).map((ie) => ({ hwAppId: ie })).extract()
        )
      ).mapLeft((ie) => new Error("sign failed"))
    ).map((F) => ({ signedTx: F, broadcasted: !0 })) : Ey(M) ? de.liftEither(
      G.fromNullable(g).toEither(new Error("cosmosCW missing"))
    ).chain(
      (F) => (
        // We need to sign + broadcast as `walletconnect` cosmos client does not support `sendTx`
        M.signTransaction({ cw: F, tx: V }).map(($) => ({ signedTx: $, broadcasted: !1 }))
      )
    ) : wee(M) ? de.liftEither(
      Hn.encase(() => JSON.parse(V)).chain((F) => jee.decode(F)).mapLeft((F) => new Wf())
    ).chain(
      (F) => de(() => M.signTransaction(F)).mapLeft(($) => new Error("sign failed"))
    ).map((F) => ({
      signedTx: JSON.stringify(F),
      broadcasted: !1
    })) : ld(M) ? de.liftEither(
      Hn.encase(() => JSON.parse(V)).chain((F) => Rg.decode(F)).mapLeft((F) => new Wf())
    ).chain(
      (F) => M.sendTransaction(u4({ address: U, decodedTx: F }))
    ).map((F) => ({ signedTx: F, broadcasted: !0 })) : de.liftEither(
      Hn.encase(() => JSON.parse(V)).chain((F) => Rg.decode(F)).mapLeft((F) => new Wf())
    ).chain(
      (F) => de(
        () => (
          /**
           * Params need to be in strict format, don't spread the object(val)!
           */
          f({
            data: F.data,
            to: F.to,
            value: F.value,
            nonce: F.nonce,
            maxFeePerGas: F.maxFeePerGas,
            maxPriorityFeePerGas: F.maxPriorityFeePerGas,
            chainId: F.chainId,
            gas: F.gasLimit,
            type: F.maxFeePerGas ? "eip1559" : "legacy"
          })
        )
      ).mapLeft(() => new fee()).map(($) => ({ signedTx: $, broadcasted: !0 }))
    )),
    [b, g, m, f]
  ), R = Ie(
    ({ txs: V }) => b.chain(({ conn: N, address: M }) => ow(N) ? de.liftEither(
      Hn.sequence(
        V.map(
          (U) => Hn.encase(() => JSON.parse(U)).chain((F) => Rg.decode(F)).map((F) => u4({ address: M, decodedTx: F })).mapLeft(() => new Wf())
        )
      )
    ).chain(
      (U) => N.sendTransactions({
        txs: U.map((F) => ({
          data: F.data,
          to: F.to,
          value: F.value ?? "0"
        }))
      }).map((F) => F.safeTxHash)
    ).chain(
      (U) => Kn({
        fn: () => N.getTxStatus(U).chain(
          (F) => !F.txHash || F.txStatus !== N.txStatus.SUCCESS ? de.liftEither(
            Xe(
              new K9(
                F.txStatus === N.txStatus.FAILED || F.txStatus === N.txStatus.CANCELLED ? "FAILED" : "NOT_READY"
              )
            )
          ) : de.liftEither(_e(F.txHash))
        ).run().then((F) => F.unsafeCoerce()),
        shouldRetry: (F, $) => G.fromNullable(F).chainNullable(
          (ie) => ie._tag === "SafeFailedError" ? ie : null
        ).filter((ie) => ie.type !== "FAILED" && !l()).map(() => $ < 120).orDefault(!1),
        retryWaitForMs: () => 7e3
      })
    ).mapLeft(() => new Error("sendTransactions failed")).map((U) => ({ signedTx: U, broadcasted: !0 })) : de.liftEither(Xe(new hee()))),
    [b, l]
  ), B = Ie(
    (V) => b.chain(({ conn: N }) => ld(N) ? N.signMessage(V) : de(() => h({ message: V }))).mapLeft((N) => new Error("sign failed")),
    [b, h]
  ), O = Ie(
    (V) => {
      u && bo(u) && u.switchAccount(V);
    },
    [u]
  ), L = J(() => {
    const V = Pd() || !!(u && bo(u)), N = {
      disconnect: d,
      signTransaction: T,
      signMultipleTransactions: R,
      signMessage: B,
      connectorChains: w,
      isLedgerLive: V
    };
    return C && s && !k ? {
      ...N,
      network: x,
      address: a,
      chain: s,
      isConnected: !0,
      isConnecting: !1,
      additionalAddresses: S.data ?? null,
      ledgerAccounts: p,
      onLedgerAccountChange: O,
      connector: u,
      isLedgerLiveAccountPlaceholder: u && bo(u) && a === u.noAccountPlaceholder
    } : {
      ...N,
      network: null,
      address: null,
      chain: null,
      isConnected: !1,
      isConnecting: k,
      additionalAddresses: null,
      ledgerAccounts: null,
      onLedgerAccountChange: null,
      connector: null,
      isLedgerLiveAccountPlaceholder: !1
    };
  }, [
    w,
    S.data,
    a,
    s,
    u,
    d,
    C,
    k,
    p,
    x,
    O,
    T,
    R,
    B
  ]);
  return /* @__PURE__ */ y.jsx(PR.Provider, { value: L, children: e });
}, wt = () => {
  const e = we(PR);
  if (e === void 0)
    throw new Error("useSKWallet must be used within a SKWalletProvider");
  return e;
}, OR = 1e3 * 60 * 2, v1 = (e) => [
  "yield-opportunity",
  e.yieldId,
  e.isLedgerLive
], Ay = (e) => {
  const { isLedgerLive: t } = wt(), n = e ?? "", r = Fs();
  return Ut({
    queryKey: v1({ yieldId: n, isLedgerLive: t }),
    enabled: !!e,
    staleTime: OR,
    queryFn: ({ signal: i }) => BR({ yieldId: n, isLedgerLive: t, yieldYieldOpportunity: r, signal: i })
  });
}, Ty = (e) => de(
  () => e.queryClient.fetchQuery({
    queryKey: v1(e),
    staleTime: OR,
    queryFn: ({ signal: t }) => BR({ ...e, signal: t })
  })
).mapLeft((t) => new Error("Could not get yield opportunity")), BR = async (e) => (await Fee(e)).unsafeCoerce(), Fee = ({
  isLedgerLive: e,
  yieldId: t,
  yieldYieldOpportunity: n,
  signal: r
}) => Kn({
  fn: () => n(
    t,
    {
      ledgerWalletAPICompatible: e
    },
    r
  )
}).mapLeft((i) => new Error("Could not get yield opportunity")), Lee = ({
  yieldDto: e,
  isLedgerLive: t,
  queryClient: n
}) => {
  n.setQueryData(
    v1({ isLedgerLive: t, yieldId: e.id }),
    e
  );
}, NR = ["init-params"], DR = 0, jR = 0, cd = (e) => {
  const { isLedgerLive: t } = wt(), { externalProviders: n } = bt(), r = ci(), i = Fs();
  return Ut({
    queryKey: NR,
    staleTime: DR,
    gcTime: jR,
    queryFn: () => MR({
      isLedgerLive: t,
      queryClient: r,
      yieldYieldOpportunity: i,
      externalProviders: n
    }),
    select: e == null ? void 0 : e.select
  });
}, _y = (e) => de(
  () => e.queryClient.fetchQuery({
    queryKey: NR,
    staleTime: DR,
    gcTime: jR,
    queryFn: () => MR(e)
  })
).mapLeft((t) => new Error("could not get init query params")), MR = async (e) => (await Uee(e)).unsafeCoerce(), Uee = ({
  isLedgerLive: e,
  queryClient: t,
  yieldYieldOpportunity: n,
  externalProviders: r
}) => de.liftEither(
  lT({
    externalProviderInitToken: r == null ? void 0 : r.initToken
  }).toEither(new Error("missing query params"))
).chain((i) => {
  const o = i.yieldId;
  return o ? Ty({
    isLedgerLive: e,
    yieldId: o,
    queryClient: t,
    yieldYieldOpportunity: n
  }).map((s) => ({
    ...i,
    network: s.token.network,
    token: s.token.symbol,
    yieldData: s
  })).chainLeft(async () => _e({ ...i, yieldData: null })) : de.liftEither(_e({ ...i, yieldData: null }));
}), zee = () => {
  const { data: e, error: t } = IL({
    query: { refetchInterval: 3e4 }
  });
  return !!((t == null ? void 0 : t.status) === 500 || e != null && e.db && e.db !== "OK");
}, Vee = ({
  language: e,
  countryCode: t
}) => new Intl.DisplayNames([e], { type: "region" }).of(t), xs = (e) => {
  const { rewardRate: t, rewardType: n } = e;
  return n === "variable" || !t ? "- %" : `${Kv(t)}%`;
}, FR = (e) => {
  switch (e) {
    case "apr":
      return "APR";
    case "apy":
      return "APY";
    default:
      return "";
  }
}, b1 = ({
  yieldDto: e,
  gas: t,
  prices: n
}) => G.fromRecord({
  yieldDto: e,
  gas: t
}).map((r) => ({
  ...r,
  gasFeeInUSD: Uc({
    amount: r.gas.toString(),
    prices: n.orDefault(new f1(/* @__PURE__ */ new Map())),
    token: r.yieldDto.metadata.gasFeeToken,
    pricePerShare: null,
    baseToken: null
  })
})).mapOrDefault(
  (r) => `${Sn(r.gas, 10)} ${r.yieldDto.metadata.gasFeeToken.symbol} ${r.gasFeeInUSD.isGreaterThan(0) ? ` ($${Xn(r.gasFeeInUSD)})` : ""}`,
  ""
), qee = ({
  amount: e,
  prices: t,
  token: n
}) => G.fromRecord({ token: n, amount: e }).map((r) => ({
  ...r,
  feeInUSD: Uc({
    amount: r.amount,
    prices: t.orDefault(new f1(/* @__PURE__ */ new Map())),
    token: r.token,
    pricePerShare: null,
    baseToken: null
  })
})).mapOrDefault(
  (r) => `${Sn(r.amount, 10)} ${r.token.symbol} ${r.feeInUSD.isGreaterThan(0) ? ` ($${Xn(r.feeInUSD)})` : ""}`,
  ""
), rp = (e) => G.fromNullable(e).map(
  (t) => t.split(" ").map(
    (n) => n.charAt(0).toUpperCase() + n.slice(1).toLowerCase()
  ).join(" ")
).orDefault(""), f4 = ({
  integrationData: e,
  validatorAddress: t
}) => {
  const n = e.chain(
    (r) => G.fromNullable(r.metadata.provider).map((i) => ({
      logo: i.logoURI,
      name: i.name,
      rewardRateFormatted: xs({
        rewardRate: r.rewardRate,
        rewardType: r.rewardType
      }),
      rewardRate: r.rewardRate,
      rewardType: r.rewardType,
      website: i.externalLink
    })).altLazy(
      () => G.of({
        logo: r.metadata.logoURI,
        name: r.metadata.name,
        rewardRateFormatted: xs({
          rewardRate: r.rewardRate,
          rewardType: r.rewardType
        }),
        rewardRate: r.rewardRate,
        rewardType: r.rewardType
      })
    )
  );
  return e.chain(
    (r) => t.chain(
      (i) => pt.find(
        (o) => o.address === i || o.providerId === i,
        r.validators
      ).map((o) => ({
        logo: o.image,
        name: o.name ?? o.address,
        rewardRateFormatted: xs({
          rewardRate: o.apr,
          rewardType: r.rewardType
        }),
        rewardRate: o.apr,
        rewardType: r.rewardType,
        address: o.address,
        stakedBalance: o.stakedBalance,
        votingPower: o.votingPower,
        commission: o.commission,
        status: o.status,
        website: o.website,
        preferred: o.preferred
      }))
    ).altLazy(() => n)
  );
}, Uo = ({
  integrationData: e,
  validatorsAddresses: t
}) => J(
  () => t.chain(
    (n) => G.sequence(
      (n instanceof Map ? [...n.values()].map((r) => r.address) : n).map(
        (r) => f4({
          integrationData: e,
          validatorAddress: G.of(r)
        })
      )
    ).chain(
      (r) => r.length ? G.of(r) : f4({
        integrationData: e,
        validatorAddress: G.empty()
      }).map((i) => [i])
    )
  ),
  [e, t]
), _s = (e) => {
  const { t } = ze();
  return e.chainNullable((n) => vR(n, t));
}, h4 = /* @__PURE__ */ new Set();
function Iy(e, t, n) {
  e || h4.has(t) || h4.add(t);
}
function $ee(e) {
  if (typeof Proxy > "u")
    return e;
  const t = /* @__PURE__ */ new Map(), n = (...r) => (ke.env.NODE_ENV !== "production" && Iy(!1, "motion() is deprecated. Use motion.create() instead."), e(...r));
  return new Proxy(n, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (r, i) => i === "create" ? e : (t.has(i) || t.set(i, e(i)), t.get(i))
  });
}
function ud(e) {
  return e !== null && typeof e == "object" && typeof e.start == "function";
}
const Yb = (e) => Array.isArray(e);
function LR(e, t) {
  if (!Array.isArray(t))
    return !1;
  const n = t.length;
  if (n !== e.length)
    return !1;
  for (let r = 0; r < n; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
function dd(e) {
  return typeof e == "string" || Array.isArray(e);
}
function p4(e) {
  const t = [{}, {}];
  return e == null || e.values.forEach((n, r) => {
    t[0][r] = n.get(), t[1][r] = n.getVelocity();
  }), t;
}
function w1(e, t, n, r) {
  if (typeof t == "function") {
    const [i, o] = p4(r);
    t = t(n !== void 0 ? n : e.custom, i, o);
  }
  if (typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function") {
    const [i, o] = p4(r);
    t = t(n !== void 0 ? n : e.custom, i, o);
  }
  return t;
}
function Ry(e, t, n) {
  const r = e.getProps();
  return w1(r, t, n !== void 0 ? n : r.custom, e);
}
const x1 = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], C1 = ["initial", ...x1], tf = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], zs = new Set(tf), Si = (e) => e * 1e3, Ki = (e) => e / 1e3, Wee = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, Gee = (e) => ({
  type: "spring",
  stiffness: 550,
  damping: e === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), Hee = {
  type: "keyframes",
  duration: 0.8
}, Kee = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, Yee = (e, { keyframes: t }) => t.length > 2 ? Hee : zs.has(e) ? e.startsWith("scale") ? Gee(t[1]) : Wee : Kee;
function Qee({ when: e, delay: t, delayChildren: n, staggerChildren: r, staggerDirection: i, repeat: o, repeatType: s, repeatDelay: a, from: l, elapsed: c, ...u }) {
  return !!Object.keys(u).length;
}
function k1(e, t) {
  return e[t] || e.default || e;
}
const Jee = {
  skipAnimations: !1,
  useManualTiming: !1
}, Xee = (e) => e !== null;
function Py(e, { repeat: t, repeatType: n = "loop" }, r) {
  const i = e.filter(Xee), o = t && n !== "loop" && t % 2 === 1 ? 0 : i.length - 1;
  return !o || r === void 0 ? i[o] : r;
}
const Un = (e) => e;
function Zee(e) {
  let t = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set(), r = !1, i = !1;
  const o = /* @__PURE__ */ new WeakSet();
  let s = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function a(c) {
    o.has(c) && (l.schedule(c), e()), c(s);
  }
  const l = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (c, u = !1, d = !1) => {
      const h = d && r ? t : n;
      return u && o.add(c), h.has(c) || h.add(c), c;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (c) => {
      n.delete(c), o.delete(c);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (c) => {
      if (s = c, r) {
        i = !0;
        return;
      }
      r = !0, [t, n] = [n, t], n.clear(), t.forEach(a), r = !1, i && (i = !1, l.process(c));
    }
  };
  return l;
}
const Hf = [
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
], ete = 40;
function UR(e, t) {
  let n = !1, r = !0;
  const i = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, o = () => n = !0, s = Hf.reduce((v, w) => (v[w] = Zee(o), v), {}), { read: a, resolveKeyframes: l, update: c, preRender: u, render: d, postRender: f } = s, h = () => {
    const v = performance.now();
    n = !1, i.delta = r ? 1e3 / 60 : Math.max(Math.min(v - i.timestamp, ete), 1), i.timestamp = v, i.isProcessing = !0, a.process(i), l.process(i), c.process(i), u.process(i), d.process(i), f.process(i), i.isProcessing = !1, n && t && (r = !1, e(h));
  }, p = () => {
    n = !0, r = !0, i.isProcessing || e(h);
  };
  return { schedule: Hf.reduce((v, w) => {
    const x = s[w];
    return v[w] = (C, S = !1, k = !1) => (n || p(), x.schedule(C, S, k)), v;
  }, {}), cancel: (v) => {
    for (let w = 0; w < Hf.length; w++)
      s[Hf[w]].cancel(v);
  }, state: i, steps: s };
}
const { schedule: Pt, cancel: eo, state: Ln, steps: Pg } = UR(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Un, !0), zR = (e) => /^0[^.\s]+$/u.test(e);
function tte(e) {
  return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || zR(e) : !0;
}
let Vc = Un, Br = Un;
ke.env.NODE_ENV !== "production" && (Vc = (e, t) => {
}, Br = (e, t) => {
  if (!e)
    throw new Error(t);
});
const VR = (e) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e), qR = (e) => (t) => typeof t == "string" && t.startsWith(e), $R = qR("--"), nte = qR("var(--"), E1 = (e) => nte(e) ? rte.test(e.split("/*")[0].trim()) : !1, rte = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, ite = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function ote(e) {
  const t = ite.exec(e);
  if (!t)
    return [,];
  const [, n, r, i] = t;
  return [`--${n ?? r}`, i];
}
const ste = 4;
function WR(e, t, n = 1) {
  Br(n <= ste, `Max CSS variable fallback depth detected in property "${e}". This may indicate a circular fallback dependency.`);
  const [r, i] = ote(e);
  if (!r)
    return;
  const o = window.getComputedStyle(t).getPropertyValue(r);
  if (o) {
    const s = o.trim();
    return VR(s) ? parseFloat(s) : s;
  }
  return E1(i) ? WR(i, t, n + 1) : i;
}
const Is = (e, t, n) => n > t ? t : n < e ? e : n, qc = {
  test: (e) => typeof e == "number",
  parse: parseFloat,
  transform: (e) => e
}, Pu = {
  ...qc,
  transform: (e) => Is(0, 1, e)
}, Kf = {
  ...qc,
  default: 1
}, Ou = (e) => Math.round(e * 1e5) / 1e5, S1 = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu, ate = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu, lte = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;
function nf(e) {
  return typeof e == "string";
}
function cte(e) {
  return e == null;
}
const rf = (e) => ({
  test: (t) => nf(t) && t.endsWith(e) && t.split(" ").length === 1,
  parse: parseFloat,
  transform: (t) => `${t}${e}`
}), ts = /* @__PURE__ */ rf("deg"), Yi = /* @__PURE__ */ rf("%"), Qe = /* @__PURE__ */ rf("px"), ute = /* @__PURE__ */ rf("vh"), dte = /* @__PURE__ */ rf("vw"), y4 = {
  ...Yi,
  parse: (e) => Yi.parse(e) / 100,
  transform: (e) => Yi.transform(e * 100)
}, fte = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y",
  "translateX",
  "translateY"
]), m4 = (e) => e === qc || e === Qe, g4 = (e, t) => parseFloat(e.split(", ")[t]), v4 = (e, t) => (n, { transform: r }) => {
  if (r === "none" || !r)
    return 0;
  const i = r.match(/^matrix3d\((.+)\)$/u);
  if (i)
    return g4(i[1], t);
  {
    const o = r.match(/^matrix\((.+)\)$/u);
    return o ? g4(o[1], e) : 0;
  }
}, hte = /* @__PURE__ */ new Set(["x", "y", "z"]), pte = tf.filter((e) => !hte.has(e));
function yte(e) {
  const t = [];
  return pte.forEach((n) => {
    const r = e.getValue(n);
    r !== void 0 && (t.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0));
  }), t;
}
const cc = {
  // Dimensions
  width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  top: (e, { top: t }) => parseFloat(t),
  left: (e, { left: t }) => parseFloat(t),
  bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min),
  right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min),
  // Transform
  x: v4(4, 13),
  y: v4(5, 14)
};
cc.translateX = cc.x;
cc.translateY = cc.y;
const GR = (e) => (t) => t.test(e), mte = {
  test: (e) => e === "auto",
  parse: (e) => e
}, HR = [qc, Qe, Yi, ts, dte, ute, mte], b4 = (e) => HR.find(GR(e)), xa = /* @__PURE__ */ new Set();
let Qb = !1, Jb = !1;
function KR() {
  if (Jb) {
    const e = Array.from(xa).filter((r) => r.needsMeasurement), t = new Set(e.map((r) => r.element)), n = /* @__PURE__ */ new Map();
    t.forEach((r) => {
      const i = yte(r);
      i.length && (n.set(r, i), r.render());
    }), e.forEach((r) => r.measureInitialState()), t.forEach((r) => {
      r.render();
      const i = n.get(r);
      i && i.forEach(([o, s]) => {
        var a;
        (a = r.getValue(o)) === null || a === void 0 || a.set(s);
      });
    }), e.forEach((r) => r.measureEndState()), e.forEach((r) => {
      r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY);
    });
  }
  Jb = !1, Qb = !1, xa.forEach((e) => e.complete()), xa.clear();
}
function YR() {
  xa.forEach((e) => {
    e.readKeyframes(), e.needsMeasurement && (Jb = !0);
  });
}
function gte() {
  YR(), KR();
}
class A1 {
  constructor(t, n, r, i, o, s = !1) {
    this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...t], this.onComplete = n, this.name = r, this.motionValue = i, this.element = o, this.isAsync = s;
  }
  scheduleResolve() {
    this.isScheduled = !0, this.isAsync ? (xa.add(this), Qb || (Qb = !0, Pt.read(YR), Pt.resolveKeyframes(KR))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, name: n, element: r, motionValue: i } = this;
    for (let o = 0; o < t.length; o++)
      if (t[o] === null)
        if (o === 0) {
          const s = i == null ? void 0 : i.get(), a = t[t.length - 1];
          if (s !== void 0)
            t[0] = s;
          else if (r && n) {
            const l = r.readValue(n, a);
            l != null && (t[0] = l);
          }
          t[0] === void 0 && (t[0] = a), i && s === void 0 && i.set(t[0]);
        } else
          t[o] = t[o - 1];
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete() {
    this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), xa.delete(this);
  }
  cancel() {
    this.isComplete || (this.isScheduled = !1, xa.delete(this));
  }
  resume() {
    this.isComplete || this.scheduleResolve();
  }
}
const T1 = (e, t) => (n) => !!(nf(n) && lte.test(n) && n.startsWith(e) || t && !cte(n) && Object.prototype.hasOwnProperty.call(n, t)), QR = (e, t, n) => (r) => {
  if (!nf(r))
    return r;
  const [i, o, s, a] = r.match(S1);
  return {
    [e]: parseFloat(i),
    [t]: parseFloat(o),
    [n]: parseFloat(s),
    alpha: a !== void 0 ? parseFloat(a) : 1
  };
}, vte = (e) => Is(0, 255, e), Og = {
  ...qc,
  transform: (e) => Math.round(vte(e))
}, la = {
  test: /* @__PURE__ */ T1("rgb", "red"),
  parse: /* @__PURE__ */ QR("red", "green", "blue"),
  transform: ({ red: e, green: t, blue: n, alpha: r = 1 }) => "rgba(" + Og.transform(e) + ", " + Og.transform(t) + ", " + Og.transform(n) + ", " + Ou(Pu.transform(r)) + ")"
};
function bte(e) {
  let t = "", n = "", r = "", i = "";
  return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), r = e.substring(5, 7), i = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), r = e.substring(3, 4), i = e.substring(4, 5), t += t, n += n, r += r, i += i), {
    red: parseInt(t, 16),
    green: parseInt(n, 16),
    blue: parseInt(r, 16),
    alpha: i ? parseInt(i, 16) / 255 : 1
  };
}
const Xb = {
  test: /* @__PURE__ */ T1("#"),
  parse: bte,
  transform: la.transform
}, ml = {
  test: /* @__PURE__ */ T1("hsl", "hue"),
  parse: /* @__PURE__ */ QR("hue", "saturation", "lightness"),
  transform: ({ hue: e, saturation: t, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(e) + ", " + Yi.transform(Ou(t)) + ", " + Yi.transform(Ou(n)) + ", " + Ou(Pu.transform(r)) + ")"
}, $n = {
  test: (e) => la.test(e) || Xb.test(e) || ml.test(e),
  parse: (e) => la.test(e) ? la.parse(e) : ml.test(e) ? ml.parse(e) : Xb.parse(e),
  transform: (e) => nf(e) ? e : e.hasOwnProperty("red") ? la.transform(e) : ml.transform(e)
};
function wte(e) {
  var t, n;
  return isNaN(e) && nf(e) && (((t = e.match(S1)) === null || t === void 0 ? void 0 : t.length) || 0) + (((n = e.match(ate)) === null || n === void 0 ? void 0 : n.length) || 0) > 0;
}
const JR = "number", XR = "color", xte = "var", Cte = "var(", w4 = "${}", kte = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function fd(e) {
  const t = e.toString(), n = [], r = {
    color: [],
    number: [],
    var: []
  }, i = [];
  let o = 0;
  const a = t.replace(kte, (l) => ($n.test(l) ? (r.color.push(o), i.push(XR), n.push($n.parse(l))) : l.startsWith(Cte) ? (r.var.push(o), i.push(xte), n.push(l)) : (r.number.push(o), i.push(JR), n.push(parseFloat(l))), ++o, w4)).split(w4);
  return { values: n, split: a, indexes: r, types: i };
}
function ZR(e) {
  return fd(e).values;
}
function eP(e) {
  const { split: t, types: n } = fd(e), r = t.length;
  return (i) => {
    let o = "";
    for (let s = 0; s < r; s++)
      if (o += t[s], i[s] !== void 0) {
        const a = n[s];
        a === JR ? o += Ou(i[s]) : a === XR ? o += $n.transform(i[s]) : o += i[s];
      }
    return o;
  };
}
const Ete = (e) => typeof e == "number" ? 0 : e;
function Ste(e) {
  const t = ZR(e);
  return eP(e)(t.map(Ete));
}
const Rs = {
  test: wte,
  parse: ZR,
  createTransformer: eP,
  getAnimatableNone: Ste
}, Ate = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function Tte(e) {
  const [t, n] = e.slice(0, -1).split("(");
  if (t === "drop-shadow")
    return e;
  const [r] = n.match(S1) || [];
  if (!r)
    return e;
  const i = n.replace(r, "");
  let o = Ate.has(t) ? 1 : 0;
  return r !== n && (o *= 100), t + "(" + o + i + ")";
}
const _te = /\b([a-z-]*)\(.*?\)/gu, Zb = {
  ...Rs,
  getAnimatableNone: (e) => {
    const t = e.match(_te);
    return t ? t.map(Tte).join(" ") : e;
  }
}, x4 = {
  ...qc,
  transform: Math.round
}, _1 = {
  // Border props
  borderWidth: Qe,
  borderTopWidth: Qe,
  borderRightWidth: Qe,
  borderBottomWidth: Qe,
  borderLeftWidth: Qe,
  borderRadius: Qe,
  radius: Qe,
  borderTopLeftRadius: Qe,
  borderTopRightRadius: Qe,
  borderBottomRightRadius: Qe,
  borderBottomLeftRadius: Qe,
  // Positioning props
  width: Qe,
  maxWidth: Qe,
  height: Qe,
  maxHeight: Qe,
  size: Qe,
  top: Qe,
  right: Qe,
  bottom: Qe,
  left: Qe,
  // Spacing props
  padding: Qe,
  paddingTop: Qe,
  paddingRight: Qe,
  paddingBottom: Qe,
  paddingLeft: Qe,
  margin: Qe,
  marginTop: Qe,
  marginRight: Qe,
  marginBottom: Qe,
  marginLeft: Qe,
  // Transform props
  rotate: ts,
  rotateX: ts,
  rotateY: ts,
  rotateZ: ts,
  scale: Kf,
  scaleX: Kf,
  scaleY: Kf,
  scaleZ: Kf,
  skew: ts,
  skewX: ts,
  skewY: ts,
  distance: Qe,
  translateX: Qe,
  translateY: Qe,
  translateZ: Qe,
  x: Qe,
  y: Qe,
  z: Qe,
  perspective: Qe,
  transformPerspective: Qe,
  opacity: Pu,
  originX: y4,
  originY: y4,
  originZ: Qe,
  // Misc
  zIndex: x4,
  backgroundPositionX: Qe,
  backgroundPositionY: Qe,
  // SVG
  fillOpacity: Pu,
  strokeOpacity: Pu,
  numOctaves: x4
}, Ite = {
  ..._1,
  // Color props
  color: $n,
  backgroundColor: $n,
  outlineColor: $n,
  fill: $n,
  stroke: $n,
  // Border props
  borderColor: $n,
  borderTopColor: $n,
  borderRightColor: $n,
  borderBottomColor: $n,
  borderLeftColor: $n,
  filter: Zb,
  WebkitFilter: Zb
}, I1 = (e) => Ite[e];
function tP(e, t) {
  let n = I1(e);
  return n !== Zb && (n = Rs), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0;
}
const Rte = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function Pte(e, t, n) {
  let r = 0, i;
  for (; r < e.length && !i; ) {
    const o = e[r];
    typeof o == "string" && !Rte.has(o) && fd(o).values.length && (i = e[r]), r++;
  }
  if (i && n)
    for (const o of t)
      e[o] = tP(n, i);
}
class nP extends A1 {
  constructor(t, n, r, i, o) {
    super(t, n, r, i, o, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, element: n, name: r } = this;
    if (!n || !n.current)
      return;
    super.readKeyframes();
    for (let l = 0; l < t.length; l++) {
      let c = t[l];
      if (typeof c == "string" && (c = c.trim(), E1(c))) {
        const u = WR(c, n.current);
        u !== void 0 && (t[l] = u), l === t.length - 1 && (this.finalKeyframe = c);
      }
    }
    if (this.resolveNoneKeyframes(), !fte.has(r) || t.length !== 2)
      return;
    const [i, o] = t, s = b4(i), a = b4(o);
    if (s !== a)
      if (m4(s) && m4(a))
        for (let l = 0; l < t.length; l++) {
          const c = t[l];
          typeof c == "string" && (t[l] = parseFloat(c));
        }
      else
        this.needsMeasurement = !0;
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: t, name: n } = this, r = [];
    for (let i = 0; i < t.length; i++)
      tte(t[i]) && r.push(i);
    r.length && Pte(t, r, n);
  }
  measureInitialState() {
    const { element: t, unresolvedKeyframes: n, name: r } = this;
    if (!t || !t.current)
      return;
    r === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = cc[r](t.measureViewportBox(), window.getComputedStyle(t.current)), n[0] = this.measuredOrigin;
    const i = n[n.length - 1];
    i !== void 0 && t.getValue(r, i).jump(i, !1);
  }
  measureEndState() {
    var t;
    const { element: n, name: r, unresolvedKeyframes: i } = this;
    if (!n || !n.current)
      return;
    const o = n.getValue(r);
    o && o.jump(this.measuredOrigin, !1);
    const s = i.length - 1, a = i[s];
    i[s] = cc[r](n.measureViewportBox(), window.getComputedStyle(n.current)), a !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = a), !((t = this.removedTransforms) === null || t === void 0) && t.length && this.removedTransforms.forEach(([l, c]) => {
      n.getValue(l).set(c);
    }), this.resolveNoneKeyframes();
  }
}
function rP(e) {
  let t;
  return () => (t === void 0 && (t = e()), t);
}
let Ch;
function Ote() {
  Ch = void 0;
}
const Eo = {
  now: () => (Ch === void 0 && Eo.set(Ln.isProcessing || Jee.useManualTiming ? Ln.timestamp : performance.now()), Ch),
  set: (e) => {
    Ch = e, queueMicrotask(Ote);
  }
}, C4 = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && // It's animatable if we have a string
(Rs.test(e) || e === "0") && // And it contains numbers and/or colors
!e.startsWith("url("));
function Bte(e) {
  const t = e[0];
  if (e.length === 1)
    return !0;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t)
      return !0;
}
function Nte(e, t, n, r) {
  const i = e[0];
  if (i === null)
    return !1;
  if (t === "display" || t === "visibility")
    return !0;
  const o = e[e.length - 1], s = C4(i, t), a = C4(o, t);
  return Vc(s === a, `You are trying to animate ${t} from "${i}" to "${o}". ${i} is not an animatable value - to enable this animation set ${i} to a value animatable to ${o} via the \`style\` property.`), !s || !a ? !1 : Bte(e) || n === "spring" && r;
}
const Dte = 40;
class iP {
  constructor({ autoplay: t = !0, delay: n = 0, type: r = "keyframes", repeat: i = 0, repeatDelay: o = 0, repeatType: s = "loop", ...a }) {
    this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = Eo.now(), this.options = {
      autoplay: t,
      delay: n,
      type: r,
      repeat: i,
      repeatDelay: o,
      repeatType: s,
      ...a
    }, this.updateFinishedPromise();
  }
  /**
   * This method uses the createdAt and resolvedAt to calculate the
   * animation startTime. *Ideally*, we would use the createdAt time as t=0
   * as the following frame would then be the first frame of the animation in
   * progress, which would feel snappier.
   *
   * However, if there's a delay (main thread work) between the creation of
   * the animation and the first commited frame, we prefer to use resolvedAt
   * to avoid a sudden jump into the animation.
   */
  calcStartTime() {
    return this.resolvedAt ? this.resolvedAt - this.createdAt > Dte ? this.resolvedAt : this.createdAt : this.createdAt;
  }
  /**
   * A getter for resolved data. If keyframes are not yet resolved, accessing
   * this.resolved will synchronously flush all pending keyframe resolvers.
   * This is a deoptimisation, but at its worst still batches read/writes.
   */
  get resolved() {
    return !this._resolved && !this.hasAttemptedResolve && gte(), this._resolved;
  }
  /**
   * A method to be called when the keyframes resolver completes. This method
   * will check if its possible to run the animation and, if not, skip it.
   * Otherwise, it will call initPlayback on the implementing class.
   */
  onKeyframesResolved(t, n) {
    this.resolvedAt = Eo.now(), this.hasAttemptedResolve = !0;
    const { name: r, type: i, velocity: o, delay: s, onComplete: a, onUpdate: l, isGenerator: c } = this.options;
    if (!c && !Nte(t, r, i, o))
      if (s)
        this.options.duration = 0;
      else {
        l == null || l(Py(t, this.options, n)), a == null || a(), this.resolveFinishedPromise();
        return;
      }
    const u = this.initPlayback(t, n);
    u !== !1 && (this._resolved = {
      keyframes: t,
      finalKeyframe: n,
      ...u
    }, this.onPostResolved());
  }
  onPostResolved() {
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(t, n) {
    return this.currentFinishedPromise.then(t, n);
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise((t) => {
      this.resolveFinishedPromise = t;
    });
  }
}
function oP(e, t) {
  return t ? e * (1e3 / t) : 0;
}
const jte = 5;
function sP(e, t, n) {
  const r = Math.max(t - jte, 0);
  return oP(n - e(r), t - r);
}
const Bg = 1e-3, Mte = 0.01, k4 = 10, Fte = 0.05, Lte = 1;
function Ute({ duration: e = 800, bounce: t = 0.25, velocity: n = 0, mass: r = 1 }) {
  let i, o;
  Vc(e <= Si(k4), "Spring duration must be 10 seconds or less");
  let s = 1 - t;
  s = Is(Fte, Lte, s), e = Is(Mte, k4, Ki(e)), s < 1 ? (i = (c) => {
    const u = c * s, d = u * e, f = u - n, h = e0(c, s), p = Math.exp(-d);
    return Bg - f / h * p;
  }, o = (c) => {
    const d = c * s * e, f = d * n + n, h = Math.pow(s, 2) * Math.pow(c, 2) * e, p = Math.exp(-d), m = e0(Math.pow(c, 2), s);
    return (-i(c) + Bg > 0 ? -1 : 1) * ((f - h) * p) / m;
  }) : (i = (c) => {
    const u = Math.exp(-c * e), d = (c - n) * e + 1;
    return -Bg + u * d;
  }, o = (c) => {
    const u = Math.exp(-c * e), d = (n - c) * (e * e);
    return u * d;
  });
  const a = 5 / e, l = Vte(i, o, a);
  if (e = Si(e), isNaN(l))
    return {
      stiffness: 100,
      damping: 10,
      duration: e
    };
  {
    const c = Math.pow(l, 2) * r;
    return {
      stiffness: c,
      damping: s * 2 * Math.sqrt(r * c),
      duration: e
    };
  }
}
const zte = 12;
function Vte(e, t, n) {
  let r = n;
  for (let i = 1; i < zte; i++)
    r = r - e(r) / t(r);
  return r;
}
function e0(e, t) {
  return e * Math.sqrt(1 - t * t);
}
const qte = ["duration", "bounce"], $te = ["stiffness", "damping", "mass"];
function E4(e, t) {
  return t.some((n) => e[n] !== void 0);
}
function Wte(e) {
  let t = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...e
  };
  if (!E4(e, $te) && E4(e, qte)) {
    const n = Ute(e);
    t = {
      ...t,
      ...n,
      mass: 1
    }, t.isResolvedFromDuration = !0;
  }
  return t;
}
function R1({ keyframes: e, restDelta: t, restSpeed: n, ...r }) {
  const i = e[0], o = e[e.length - 1], s = { done: !1, value: i }, { stiffness: a, damping: l, mass: c, duration: u, velocity: d, isResolvedFromDuration: f } = Wte({
    ...r,
    velocity: -Ki(r.velocity || 0)
  }), h = d || 0, p = l / (2 * Math.sqrt(a * c)), m = o - i, g = Ki(Math.sqrt(a / c)), v = Math.abs(m) < 5;
  n || (n = v ? 0.01 : 2), t || (t = v ? 5e-3 : 0.5);
  let w;
  if (p < 1) {
    const x = e0(g, p);
    w = (C) => {
      const S = Math.exp(-p * g * C);
      return o - S * ((h + p * g * m) / x * Math.sin(x * C) + m * Math.cos(x * C));
    };
  } else if (p === 1)
    w = (x) => o - Math.exp(-g * x) * (m + (h + g * m) * x);
  else {
    const x = g * Math.sqrt(p * p - 1);
    w = (C) => {
      const S = Math.exp(-p * g * C), k = Math.min(x * C, 300);
      return o - S * ((h + p * g * m) * Math.sinh(k) + x * m * Math.cosh(k)) / x;
    };
  }
  return {
    calculatedDuration: f && u || null,
    next: (x) => {
      const C = w(x);
      if (f)
        s.done = x >= u;
      else {
        let S = 0;
        p < 1 && (S = x === 0 ? Si(h) : sP(w, x, C));
        const k = Math.abs(S) <= n, A = Math.abs(o - C) <= t;
        s.done = k && A;
      }
      return s.value = s.done ? o : C, s;
    }
  };
}
function S4({ keyframes: e, velocity: t = 0, power: n = 0.8, timeConstant: r = 325, bounceDamping: i = 10, bounceStiffness: o = 500, modifyTarget: s, min: a, max: l, restDelta: c = 0.5, restSpeed: u }) {
  const d = e[0], f = {
    done: !1,
    value: d
  }, h = (b) => a !== void 0 && b < a || l !== void 0 && b > l, p = (b) => a === void 0 ? l : l === void 0 || Math.abs(a - b) < Math.abs(l - b) ? a : l;
  let m = n * t;
  const g = d + m, v = s === void 0 ? g : s(g);
  v !== g && (m = v - d);
  const w = (b) => -m * Math.exp(-b / r), x = (b) => v + w(b), C = (b) => {
    const T = w(b), R = x(b);
    f.done = Math.abs(T) <= c, f.value = f.done ? v : R;
  };
  let S, k;
  const A = (b) => {
    h(f.value) && (S = b, k = R1({
      keyframes: [f.value, p(f.value)],
      velocity: sP(x, b, f.value),
      // TODO: This should be passing * 1000
      damping: i,
      stiffness: o,
      restDelta: c,
      restSpeed: u
    }));
  };
  return A(0), {
    calculatedDuration: null,
    next: (b) => {
      let T = !1;
      return !k && S === void 0 && (T = !0, C(b), A(b)), S !== void 0 && b >= S ? k.next(b - S) : (!T && C(b), f);
    }
  };
}
const aP = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, Gte = 1e-7, Hte = 12;
function Kte(e, t, n, r, i) {
  let o, s, a = 0;
  do
    s = t + (n - t) / 2, o = aP(s, r, i) - e, o > 0 ? n = s : t = s;
  while (Math.abs(o) > Gte && ++a < Hte);
  return s;
}
function of(e, t, n, r) {
  if (e === t && n === r)
    return Un;
  const i = (o) => Kte(o, 0, 1, e, n);
  return (o) => o === 0 || o === 1 ? o : aP(i(o), t, r);
}
const Yte = /* @__PURE__ */ of(0.42, 0, 1, 1), Qte = /* @__PURE__ */ of(0, 0, 0.58, 1), lP = /* @__PURE__ */ of(0.42, 0, 0.58, 1), cP = (e) => Array.isArray(e) && typeof e[0] != "number", uP = (e) => (t) => t <= 0.5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, dP = (e) => (t) => 1 - e(1 - t), P1 = (e) => 1 - Math.sin(Math.acos(e)), fP = dP(P1), Jte = uP(P1), hP = /* @__PURE__ */ of(0.33, 1.53, 0.69, 0.99), O1 = /* @__PURE__ */ dP(hP), Xte = /* @__PURE__ */ uP(O1), Zte = (e) => (e *= 2) < 1 ? 0.5 * O1(e) : 0.5 * (2 - Math.pow(2, -10 * (e - 1))), A4 = {
  linear: Un,
  easeIn: Yte,
  easeInOut: lP,
  easeOut: Qte,
  circIn: P1,
  circInOut: Jte,
  circOut: fP,
  backIn: O1,
  backInOut: Xte,
  backOut: hP,
  anticipate: Zte
}, T4 = (e) => {
  if (Array.isArray(e)) {
    Br(e.length === 4, "Cubic bezier arrays must contain four numerical values.");
    const [t, n, r, i] = e;
    return of(t, n, r, i);
  } else if (typeof e == "string")
    return Br(A4[e] !== void 0, `Invalid easing type '${e}'`), A4[e];
  return e;
}, ene = (e, t) => (n) => t(e(n)), So = (...e) => e.reduce(ene), uc = (e, t, n) => {
  const r = t - e;
  return r === 0 ? 1 : (n - e) / r;
}, Xt = (e, t, n) => e + (t - e) * n;
function Ng(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function tne({ hue: e, saturation: t, lightness: n, alpha: r }) {
  e /= 360, t /= 100, n /= 100;
  let i = 0, o = 0, s = 0;
  if (!t)
    i = o = s = n;
  else {
    const a = n < 0.5 ? n * (1 + t) : n + t - n * t, l = 2 * n - a;
    i = Ng(l, a, e + 1 / 3), o = Ng(l, a, e), s = Ng(l, a, e - 1 / 3);
  }
  return {
    red: Math.round(i * 255),
    green: Math.round(o * 255),
    blue: Math.round(s * 255),
    alpha: r
  };
}
function ip(e, t) {
  return (n) => n > 0 ? t : e;
}
const Dg = (e, t, n) => {
  const r = e * e, i = n * (t * t - r) + r;
  return i < 0 ? 0 : Math.sqrt(i);
}, nne = [Xb, la, ml], rne = (e) => nne.find((t) => t.test(e));
function _4(e) {
  const t = rne(e);
  if (Vc(!!t, `'${e}' is not an animatable color. Use the equivalent color code instead.`), !t)
    return !1;
  let n = t.parse(e);
  return t === ml && (n = tne(n)), n;
}
const I4 = (e, t) => {
  const n = _4(e), r = _4(t);
  if (!n || !r)
    return ip(e, t);
  const i = { ...n };
  return (o) => (i.red = Dg(n.red, r.red, o), i.green = Dg(n.green, r.green, o), i.blue = Dg(n.blue, r.blue, o), i.alpha = Xt(n.alpha, r.alpha, o), la.transform(i));
}, t0 = /* @__PURE__ */ new Set(["none", "hidden"]);
function ine(e, t) {
  return t0.has(e) ? (n) => n <= 0 ? e : t : (n) => n >= 1 ? t : e;
}
function one(e, t) {
  return (n) => Xt(e, t, n);
}
function B1(e) {
  return typeof e == "number" ? one : typeof e == "string" ? E1(e) ? ip : $n.test(e) ? I4 : lne : Array.isArray(e) ? pP : typeof e == "object" ? $n.test(e) ? I4 : sne : ip;
}
function pP(e, t) {
  const n = [...e], r = n.length, i = e.map((o, s) => B1(o)(o, t[s]));
  return (o) => {
    for (let s = 0; s < r; s++)
      n[s] = i[s](o);
    return n;
  };
}
function sne(e, t) {
  const n = { ...e, ...t }, r = {};
  for (const i in n)
    e[i] !== void 0 && t[i] !== void 0 && (r[i] = B1(e[i])(e[i], t[i]));
  return (i) => {
    for (const o in r)
      n[o] = r[o](i);
    return n;
  };
}
function ane(e, t) {
  var n;
  const r = [], i = { color: 0, var: 0, number: 0 };
  for (let o = 0; o < t.values.length; o++) {
    const s = t.types[o], a = e.indexes[s][i[s]], l = (n = e.values[a]) !== null && n !== void 0 ? n : 0;
    r[o] = l, i[s]++;
  }
  return r;
}
const lne = (e, t) => {
  const n = Rs.createTransformer(t), r = fd(e), i = fd(t);
  return r.indexes.var.length === i.indexes.var.length && r.indexes.color.length === i.indexes.color.length && r.indexes.number.length >= i.indexes.number.length ? t0.has(e) && !i.values.length || t0.has(t) && !r.values.length ? ine(e, t) : So(pP(ane(r, i), i.values), n) : (Vc(!0, `Complex values '${e}' and '${t}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), ip(e, t));
};
function yP(e, t, n) {
  return typeof e == "number" && typeof t == "number" && typeof n == "number" ? Xt(e, t, n) : B1(e)(e, t);
}
function cne(e, t, n) {
  const r = [], i = n || yP, o = e.length - 1;
  for (let s = 0; s < o; s++) {
    let a = i(e[s], e[s + 1]);
    if (t) {
      const l = Array.isArray(t) ? t[s] || Un : t;
      a = So(l, a);
    }
    r.push(a);
  }
  return r;
}
function mP(e, t, { clamp: n = !0, ease: r, mixer: i } = {}) {
  const o = e.length;
  if (Br(o === t.length, "Both input and output ranges must be the same length"), o === 1)
    return () => t[0];
  if (o === 2 && e[0] === e[1])
    return () => t[1];
  e[0] > e[o - 1] && (e = [...e].reverse(), t = [...t].reverse());
  const s = cne(t, r, i), a = s.length, l = (c) => {
    let u = 0;
    if (a > 1)
      for (; u < e.length - 2 && !(c < e[u + 1]); u++)
        ;
    const d = uc(e[u], e[u + 1], c);
    return s[u](d);
  };
  return n ? (c) => l(Is(e[0], e[o - 1], c)) : l;
}
function gP(e, t) {
  const n = e[e.length - 1];
  for (let r = 1; r <= t; r++) {
    const i = uc(0, t, r);
    e.push(Xt(n, 1, i));
  }
}
function vP(e) {
  const t = [0];
  return gP(t, e.length - 1), t;
}
function une(e, t) {
  return e.map((n) => n * t);
}
function dne(e, t) {
  return e.map(() => t || lP).splice(0, e.length - 1);
}
function op({ duration: e = 300, keyframes: t, times: n, ease: r = "easeInOut" }) {
  const i = cP(r) ? r.map(T4) : T4(r), o = {
    done: !1,
    value: t[0]
  }, s = une(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    n && n.length === t.length ? n : vP(t),
    e
  ), a = mP(s, t, {
    ease: Array.isArray(i) ? i : dne(t, i)
  });
  return {
    calculatedDuration: e,
    next: (l) => (o.value = a(l), o.done = l >= e, o)
  };
}
const n0 = 2e4;
function bP(e) {
  let t = 0;
  const n = 50;
  let r = e.next(t);
  for (; !r.done && t < n0; )
    t += n, r = e.next(t);
  return t >= n0 ? 1 / 0 : t;
}
const fne = (e) => {
  const t = ({ timestamp: n }) => e(n);
  return {
    start: () => Pt.update(t, !0),
    stop: () => eo(t),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => Ln.isProcessing ? Ln.timestamp : Eo.now()
  };
}, hne = {
  decay: S4,
  inertia: S4,
  tween: op,
  keyframes: op,
  spring: R1
}, pne = (e) => e / 100;
class N1 extends iP {
  constructor(t) {
    super(t), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => {
      if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
        return;
      this.teardown();
      const { onStop: l } = this.options;
      l && l();
    };
    const { name: n, motionValue: r, element: i, keyframes: o } = this.options, s = (i == null ? void 0 : i.KeyframeResolver) || A1, a = (l, c) => this.onKeyframesResolved(l, c);
    this.resolver = new s(o, a, n, r, i), this.resolver.scheduleResolve();
  }
  initPlayback(t) {
    const { type: n = "keyframes", repeat: r = 0, repeatDelay: i = 0, repeatType: o, velocity: s = 0 } = this.options, a = hne[n] || op;
    let l, c;
    a !== op && typeof t[0] != "number" && (ke.env.NODE_ENV !== "production" && Br(t.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${t}`), l = So(pne, yP(t[0], t[1])), t = [0, 100]);
    const u = a({ ...this.options, keyframes: t });
    o === "mirror" && (c = a({
      ...this.options,
      keyframes: [...t].reverse(),
      velocity: -s
    })), u.calculatedDuration === null && (u.calculatedDuration = bP(u));
    const { calculatedDuration: d } = u, f = d + i, h = f * (r + 1) - i;
    return {
      generator: u,
      mirroredGenerator: c,
      mapPercentToKeyframes: l,
      calculatedDuration: d,
      resolvedDuration: f,
      totalDuration: h
    };
  }
  onPostResolved() {
    const { autoplay: t = !0 } = this.options;
    this.play(), this.pendingPlayState === "paused" || !t ? this.pause() : this.state = this.pendingPlayState;
  }
  tick(t, n = !1) {
    const { resolved: r } = this;
    if (!r) {
      const { keyframes: b } = this.options;
      return { done: !0, value: b[b.length - 1] };
    }
    const { finalKeyframe: i, generator: o, mirroredGenerator: s, mapPercentToKeyframes: a, keyframes: l, calculatedDuration: c, totalDuration: u, resolvedDuration: d } = r;
    if (this.startTime === null)
      return o.next(0);
    const { delay: f, repeat: h, repeatType: p, repeatDelay: m, onUpdate: g } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - u / this.speed, this.startTime)), n ? this.currentTime = t : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(t - this.startTime) * this.speed;
    const v = this.currentTime - f * (this.speed >= 0 ? 1 : -1), w = this.speed >= 0 ? v < 0 : v > u;
    this.currentTime = Math.max(v, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = u);
    let x = this.currentTime, C = o;
    if (h) {
      const b = Math.min(this.currentTime, u) / d;
      let T = Math.floor(b), R = b % 1;
      !R && b >= 1 && (R = 1), R === 1 && T--, T = Math.min(T, h + 1), !!(T % 2) && (p === "reverse" ? (R = 1 - R, m && (R -= m / d)) : p === "mirror" && (C = s)), x = Is(0, 1, R) * d;
    }
    const S = w ? { done: !1, value: l[0] } : C.next(x);
    a && (S.value = a(S.value));
    let { done: k } = S;
    !w && c !== null && (k = this.speed >= 0 ? this.currentTime >= u : this.currentTime <= 0);
    const A = this.holdTime === null && (this.state === "finished" || this.state === "running" && k);
    return A && i !== void 0 && (S.value = Py(l, this.options, i)), g && g(S.value), A && this.finish(), S;
  }
  get duration() {
    const { resolved: t } = this;
    return t ? Ki(t.calculatedDuration) : 0;
  }
  get time() {
    return Ki(this.currentTime);
  }
  set time(t) {
    t = Si(t), this.currentTime = t, this.holdTime !== null || this.speed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.speed);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(t) {
    const n = this.playbackSpeed !== t;
    this.playbackSpeed = t, n && (this.time = Ki(this.currentTime));
  }
  play() {
    if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) {
      this.pendingPlayState = "running";
      return;
    }
    if (this.isStopped)
      return;
    const { driver: t = fne, onPlay: n, startTime: r } = this.options;
    this.driver || (this.driver = t((o) => this.tick(o))), n && n();
    const i = this.driver.now();
    this.holdTime !== null ? this.startTime = i - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = i) : this.startTime = r ?? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    var t;
    if (!this._resolved) {
      this.pendingPlayState = "paused";
      return;
    }
    this.state = "paused", this.holdTime = (t = this.currentTime) !== null && t !== void 0 ? t : 0;
  }
  complete() {
    this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null;
  }
  finish() {
    this.teardown(), this.state = "finished";
    const { onComplete: t } = this.options;
    t && t();
  }
  cancel() {
    this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise();
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel();
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(t) {
    return this.startTime = 0, this.tick(t, !0);
  }
}
const wP = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved
  // or until we implement support for linear() easing.
  // "background-color"
]), xP = (e) => Array.isArray(e) && typeof e[0] == "number";
function CP(e) {
  return !!(!e || typeof e == "string" && e in D1 || xP(e) || Array.isArray(e) && e.every(CP));
}
const xu = ([e, t, n, r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`, D1 = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ xu([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ xu([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ xu([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ xu([0.33, 1.53, 0.69, 0.99])
};
function yne(e) {
  return kP(e) || D1.easeOut;
}
function kP(e) {
  if (e)
    return xP(e) ? xu(e) : Array.isArray(e) ? e.map(yne) : D1[e];
}
function mne(e, t, n, { delay: r = 0, duration: i = 300, repeat: o = 0, repeatType: s = "loop", ease: a, times: l } = {}) {
  const c = { [t]: n };
  l && (c.offset = l);
  const u = kP(a);
  return Array.isArray(u) && (c.easing = u), e.animate(c, {
    delay: r,
    duration: i,
    easing: Array.isArray(u) ? "linear" : u,
    fill: "both",
    iterations: o + 1,
    direction: s === "reverse" ? "alternate" : "normal"
  });
}
const gne = /* @__PURE__ */ rP(() => Object.hasOwnProperty.call(Element.prototype, "animate")), sp = 10, vne = 2e4;
function bne(e) {
  return e.type === "spring" || !CP(e.ease);
}
function wne(e, t) {
  const n = new N1({
    ...t,
    keyframes: e,
    repeat: 0,
    delay: 0,
    isGenerator: !0
  });
  let r = { done: !1, value: e[0] };
  const i = [];
  let o = 0;
  for (; !r.done && o < vne; )
    r = n.sample(o), i.push(r.value), o += sp;
  return {
    times: void 0,
    keyframes: i,
    duration: o - sp,
    ease: "linear"
  };
}
class R4 extends iP {
  constructor(t) {
    super(t);
    const { name: n, motionValue: r, element: i, keyframes: o } = this.options;
    this.resolver = new nP(o, (s, a) => this.onKeyframesResolved(s, a), n, r, i), this.resolver.scheduleResolve();
  }
  initPlayback(t, n) {
    var r;
    let { duration: i = 300, times: o, ease: s, type: a, motionValue: l, name: c, startTime: u } = this.options;
    if (!(!((r = l.owner) === null || r === void 0) && r.current))
      return !1;
    if (bne(this.options)) {
      const { onComplete: f, onUpdate: h, motionValue: p, element: m, ...g } = this.options, v = wne(t, g);
      t = v.keyframes, t.length === 1 && (t[1] = t[0]), i = v.duration, o = v.times, s = v.ease, a = "keyframes";
    }
    const d = mne(l.owner.current, c, t, { ...this.options, duration: i, times: o, ease: s });
    return d.startTime = u ?? this.calcStartTime(), this.pendingTimeline ? (d.timeline = this.pendingTimeline, this.pendingTimeline = void 0) : d.onfinish = () => {
      const { onComplete: f } = this.options;
      l.set(Py(t, this.options, n)), f && f(), this.cancel(), this.resolveFinishedPromise();
    }, {
      animation: d,
      duration: i,
      times: o,
      type: a,
      ease: s,
      keyframes: t
    };
  }
  get duration() {
    const { resolved: t } = this;
    if (!t)
      return 0;
    const { duration: n } = t;
    return Ki(n);
  }
  get time() {
    const { resolved: t } = this;
    if (!t)
      return 0;
    const { animation: n } = t;
    return Ki(n.currentTime || 0);
  }
  set time(t) {
    const { resolved: n } = this;
    if (!n)
      return;
    const { animation: r } = n;
    r.currentTime = Si(t);
  }
  get speed() {
    const { resolved: t } = this;
    if (!t)
      return 1;
    const { animation: n } = t;
    return n.playbackRate;
  }
  set speed(t) {
    const { resolved: n } = this;
    if (!n)
      return;
    const { animation: r } = n;
    r.playbackRate = t;
  }
  get state() {
    const { resolved: t } = this;
    if (!t)
      return "idle";
    const { animation: n } = t;
    return n.playState;
  }
  get startTime() {
    const { resolved: t } = this;
    if (!t)
      return null;
    const { animation: n } = t;
    return n.startTime;
  }
  /**
   * Replace the default DocumentTimeline with another AnimationTimeline.
   * Currently used for scroll animations.
   */
  attachTimeline(t) {
    if (!this._resolved)
      this.pendingTimeline = t;
    else {
      const { resolved: n } = this;
      if (!n)
        return Un;
      const { animation: r } = n;
      r.timeline = t, r.onfinish = null;
    }
    return Un;
  }
  play() {
    if (this.isStopped)
      return;
    const { resolved: t } = this;
    if (!t)
      return;
    const { animation: n } = t;
    n.playState === "finished" && this.updateFinishedPromise(), n.play();
  }
  pause() {
    const { resolved: t } = this;
    if (!t)
      return;
    const { animation: n } = t;
    n.pause();
  }
  stop() {
    if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
      return;
    this.resolveFinishedPromise(), this.updateFinishedPromise();
    const { resolved: t } = this;
    if (!t)
      return;
    const { animation: n, keyframes: r, duration: i, type: o, ease: s, times: a } = t;
    if (n.playState === "idle" || n.playState === "finished")
      return;
    if (this.time) {
      const { motionValue: c, onUpdate: u, onComplete: d, element: f, ...h } = this.options, p = new N1({
        ...h,
        keyframes: r,
        duration: i,
        type: o,
        ease: s,
        times: a,
        isGenerator: !0
      }), m = Si(this.time);
      c.setWithVelocity(p.sample(m - sp).value, p.sample(m).value, sp);
    }
    const { onStop: l } = this.options;
    l && l(), this.cancel();
  }
  complete() {
    const { resolved: t } = this;
    t && t.animation.finish();
  }
  cancel() {
    const { resolved: t } = this;
    t && t.animation.cancel();
  }
  static supports(t) {
    const { motionValue: n, name: r, repeatDelay: i, repeatType: o, damping: s, type: a } = t;
    return gne() && r && wP.has(r) && n && n.owner && n.owner.current instanceof HTMLElement && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !n.owner.getProps().onUpdate && !i && o !== "mirror" && s !== 0 && a !== "inertia";
  }
}
function xne(e, t) {
  let n;
  const r = () => {
    const { currentTime: i } = t, s = (i === null ? 0 : i.value) / 100;
    n !== s && e(s), n = s;
  };
  return Pt.update(r, !0), () => eo(r);
}
const Cne = rP(() => window.ScrollTimeline !== void 0);
class j1 {
  constructor(t) {
    this.stop = () => this.runAll("stop"), this.animations = t.filter(Boolean);
  }
  then(t, n) {
    return Promise.all(this.animations).then(t).catch(n);
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(t) {
    return this.animations[0][t];
  }
  setAll(t, n) {
    for (let r = 0; r < this.animations.length; r++)
      this.animations[r][t] = n;
  }
  attachTimeline(t) {
    const n = this.animations.map((r) => {
      if (Cne() && r.attachTimeline)
        r.attachTimeline(t);
      else
        return r.pause(), xne((i) => {
          r.time = r.duration * i;
        }, t);
    });
    return () => {
      n.forEach((r, i) => {
        r && r(), this.animations[i].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(t) {
    this.setAll("time", t);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(t) {
    this.setAll("speed", t);
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    let t = 0;
    for (let n = 0; n < this.animations.length; n++)
      t = Math.max(t, this.animations[n].duration);
    return t;
  }
  runAll(t) {
    this.animations.forEach((n) => n[t]());
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
const M1 = (e, t, n, r = {}, i, o, s) => (a) => {
  const l = k1(r, e) || {}, c = l.delay || r.delay || 0;
  let { elapsed: u = 0 } = r;
  u = u - Si(c);
  let d = {
    keyframes: Array.isArray(n) ? n : [null, n],
    ease: "easeOut",
    velocity: t.getVelocity(),
    ...l,
    delay: -u,
    onUpdate: (h) => {
      t.set(h), l.onUpdate && l.onUpdate(h);
    },
    onComplete: () => {
      a(), l.onComplete && l.onComplete(), s && s();
    },
    onStop: s,
    name: e,
    motionValue: t,
    element: o ? void 0 : i
  };
  Qee(l) || (d = {
    ...d,
    ...Yee(e, d)
  }), d.duration && (d.duration = Si(d.duration)), d.repeatDelay && (d.repeatDelay = Si(d.repeatDelay)), d.from !== void 0 && (d.keyframes[0] = d.from);
  let f = !1;
  if ((d.type === !1 || d.duration === 0 && !d.repeatDelay) && (d.duration = 0, d.delay === 0 && (f = !0)), f && !o && t.get() !== void 0) {
    const h = Py(d.keyframes, l);
    if (h !== void 0)
      return Pt.update(() => {
        d.onUpdate(h), d.onComplete();
      }), new j1([]);
  }
  return !o && R4.supports(d) ? new R4(d) : new N1(d);
}, kne = (e) => !!(e && typeof e == "object" && e.mix && e.toValue), Ene = (e) => Yb(e) ? e[e.length - 1] || 0 : e;
function Oy(e, t) {
  e.indexOf(t) === -1 && e.push(t);
}
function sf(e, t) {
  const n = e.indexOf(t);
  n > -1 && e.splice(n, 1);
}
class F1 {
  constructor() {
    this.subscriptions = [];
  }
  add(t) {
    return Oy(this.subscriptions, t), () => sf(this.subscriptions, t);
  }
  notify(t, n, r) {
    const i = this.subscriptions.length;
    if (i)
      if (i === 1)
        this.subscriptions[0](t, n, r);
      else
        for (let o = 0; o < i; o++) {
          const s = this.subscriptions[o];
          s && s(t, n, r);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const P4 = 30, Sne = (e) => !isNaN(parseFloat(e)), Bu = {
  current: void 0
};
class EP {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(t, n = {}) {
    this.version = "11.5.4", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (r, i = !0) => {
      const o = Eo.now();
      this.updatedAt !== o && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(r), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), i && this.events.renderRequest && this.events.renderRequest.notify(this.current);
    }, this.hasAnimated = !1, this.setCurrent(t), this.owner = n.owner;
  }
  setCurrent(t) {
    this.current = t, this.updatedAt = Eo.now(), this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = Sne(this.current));
  }
  setPrevFrameValue(t = this.current) {
    this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(t) {
    return ke.env.NODE_ENV !== "production" && Iy(!1, 'value.onChange(callback) is deprecated. Switch to value.on("change", callback).'), this.on("change", t);
  }
  on(t, n) {
    this.events[t] || (this.events[t] = new F1());
    const r = this.events[t].add(n);
    return t === "change" ? () => {
      r(), Pt.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : r;
  }
  clearListeners() {
    for (const t in this.events)
      this.events[t].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(t, n) {
    this.passiveEffect = t, this.stopPassiveEffect = n;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(t, n = !0) {
    !n || !this.passiveEffect ? this.updateAndNotify(t, n) : this.passiveEffect(t, this.updateAndNotify);
  }
  setWithVelocity(t, n, r) {
    this.set(n), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - r;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(t, n = !0) {
    this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return Bu.current && Bu.current.push(this), this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const t = Eo.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > P4)
      return 0;
    const n = Math.min(this.updatedAt - this.prevUpdatedAt, P4);
    return oP(parseFloat(this.current) - parseFloat(this.prevFrameValue), n);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(t) {
    return this.stop(), new Promise((n) => {
      this.hasAnimated = !0, this.animation = t(n), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function dc(e, t) {
  return new EP(e, t);
}
function Ane(e, t, n) {
  e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, dc(n));
}
function L1(e, t) {
  const n = Ry(e, t);
  let { transitionEnd: r = {}, transition: i = {}, ...o } = n || {};
  o = { ...o, ...r };
  for (const s in o) {
    const a = Ene(o[s]);
    Ane(e, s, a);
  }
}
const By = (e) => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), Tne = "framerAppearId", SP = "data-" + By(Tne);
function AP(e) {
  return e.props[SP];
}
function TP(e) {
  if (zs.has(e))
    return "transform";
  if (wP.has(e))
    return By(e);
}
class _ne extends EP {
  constructor() {
    super(...arguments), this.output = [], this.counts = /* @__PURE__ */ new Map();
  }
  add(t) {
    const n = TP(t);
    if (!n)
      return;
    const r = this.counts.get(n) || 0;
    this.counts.set(n, r + 1), r === 0 && (this.output.push(n), this.update());
    let i = !1;
    return () => {
      if (i)
        return;
      i = !0;
      const o = this.counts.get(n) - 1;
      this.counts.set(n, o), o === 0 && (sf(this.output, n), this.update());
    };
  }
  update() {
    this.set(this.output.length ? this.output.join(", ") : "auto");
  }
}
const Nn = (e) => !!(e && e.getVelocity);
function Ine(e) {
  return !!(Nn(e) && e.add);
}
function r0(e, t) {
  var n;
  if (!e.applyWillChange)
    return;
  let r = e.getValue("willChange");
  if (!r && !(!((n = e.props.style) === null || n === void 0) && n.willChange) && (r = new _ne("auto"), e.addValue("willChange", r)), Ine(r))
    return r.add(t);
}
function Rne({ protectedKeys: e, needsAnimating: t }, n) {
  const r = e.hasOwnProperty(n) && t[n] !== !0;
  return t[n] = !1, r;
}
function U1(e, t, { delay: n = 0, transitionOverride: r, type: i } = {}) {
  var o;
  let { transition: s = e.getDefaultTransition(), transitionEnd: a, ...l } = t;
  r && (s = r);
  const c = [], u = i && e.animationState && e.animationState.getState()[i];
  for (const d in l) {
    const f = e.getValue(d, (o = e.latestValues[d]) !== null && o !== void 0 ? o : null), h = l[d];
    if (h === void 0 || u && Rne(u, d))
      continue;
    const p = {
      delay: n,
      ...k1(s || {}, d)
    };
    let m = !1;
    if (window.MotionHandoffAnimation) {
      const v = AP(e);
      if (v) {
        const w = window.MotionHandoffAnimation(v, d, Pt);
        w !== null && (p.startTime = w, m = !0);
      }
    }
    f.start(M1(d, f, h, e.shouldReduceMotion && zs.has(d) ? { type: !1 } : p, e, m, r0(e, d)));
    const g = f.animation;
    g && c.push(g);
  }
  return a && Promise.all(c).then(() => {
    Pt.update(() => {
      a && L1(e, a);
    });
  }), c;
}
function i0(e, t, n = {}) {
  var r;
  const i = Ry(e, t, n.type === "exit" ? (r = e.presenceContext) === null || r === void 0 ? void 0 : r.custom : void 0);
  let { transition: o = e.getDefaultTransition() || {} } = i || {};
  n.transitionOverride && (o = n.transitionOverride);
  const s = i ? () => Promise.all(U1(e, i, n)) : () => Promise.resolve(), a = e.variantChildren && e.variantChildren.size ? (c = 0) => {
    const { delayChildren: u = 0, staggerChildren: d, staggerDirection: f } = o;
    return Pne(e, t, u + c, d, f, n);
  } : () => Promise.resolve(), { when: l } = o;
  if (l) {
    const [c, u] = l === "beforeChildren" ? [s, a] : [a, s];
    return c().then(() => u());
  } else
    return Promise.all([s(), a(n.delay)]);
}
function Pne(e, t, n = 0, r = 0, i = 1, o) {
  const s = [], a = (e.variantChildren.size - 1) * r, l = i === 1 ? (c = 0) => c * r : (c = 0) => a - c * r;
  return Array.from(e.variantChildren).sort(One).forEach((c, u) => {
    c.notify("AnimationStart", t), s.push(i0(c, t, {
      ...o,
      delay: n + l(u)
    }).then(() => c.notify("AnimationComplete", t)));
  }), Promise.all(s);
}
function One(e, t) {
  return e.sortNodePosition(t);
}
function _P(e, t, n = {}) {
  e.notify("AnimationStart", t);
  let r;
  if (Array.isArray(t)) {
    const i = t.map((o) => i0(e, o, n));
    r = Promise.all(i);
  } else if (typeof t == "string")
    r = i0(e, t, n);
  else {
    const i = typeof t == "function" ? Ry(e, t, n.custom) : t;
    r = Promise.all(U1(e, i, n));
  }
  return r.then(() => {
    e.notify("AnimationComplete", t);
  });
}
const Bne = [...x1].reverse(), Nne = x1.length;
function Dne(e) {
  return (t) => Promise.all(t.map(({ animation: n, options: r }) => _P(e, n, r)));
}
function jne(e) {
  let t = Dne(e), n = O4(), r = !0;
  const i = (l) => (c, u) => {
    var d;
    const f = Ry(e, u, l === "exit" ? (d = e.presenceContext) === null || d === void 0 ? void 0 : d.custom : void 0);
    if (f) {
      const { transition: h, transitionEnd: p, ...m } = f;
      c = { ...c, ...m, ...p };
    }
    return c;
  };
  function o(l) {
    t = l(e);
  }
  function s(l) {
    const c = e.getProps(), u = e.getVariantContext(!0) || {}, d = [], f = /* @__PURE__ */ new Set();
    let h = {}, p = 1 / 0;
    for (let g = 0; g < Nne; g++) {
      const v = Bne[g], w = n[v], x = c[v] !== void 0 ? c[v] : u[v], C = dd(x), S = v === l ? w.isActive : null;
      S === !1 && (p = g);
      let k = x === u[v] && x !== c[v] && C;
      if (k && r && e.manuallyAnimateOnMount && (k = !1), w.protectedKeys = { ...h }, // If it isn't active and hasn't *just* been set as inactive
      !w.isActive && S === null || // If we didn't and don't have any defined prop for this animation type
      !x && !w.prevProp || // Or if the prop doesn't define an animation
      ud(x) || typeof x == "boolean")
        continue;
      let b = Mne(w.prevProp, x) || // If we're making this variant active, we want to always make it active
      v === l && w.isActive && !k && C || // If we removed a higher-priority variant (i is in reverse order)
      g > p && C, T = !1;
      const R = Array.isArray(x) ? x : [x];
      let B = R.reduce(i(v), {});
      S === !1 && (B = {});
      const { prevResolvedValues: O = {} } = w, L = {
        ...O,
        ...B
      }, V = (N) => {
        b = !0, f.has(N) && (T = !0, f.delete(N)), w.needsAnimating[N] = !0;
        const M = e.getValue(N);
        M && (M.liveStyle = !1);
      };
      for (const N in L) {
        const M = B[N], U = O[N];
        if (h.hasOwnProperty(N))
          continue;
        let F = !1;
        Yb(M) && Yb(U) ? F = !LR(M, U) : F = M !== U, F ? M != null ? V(N) : f.add(N) : M !== void 0 && f.has(N) ? V(N) : w.protectedKeys[N] = !0;
      }
      w.prevProp = x, w.prevResolvedValues = B, w.isActive && (h = { ...h, ...B }), r && e.blockInitialAnimation && (b = !1), b && (!k || T) && d.push(...R.map((N) => ({
        animation: N,
        options: { type: v }
      })));
    }
    if (f.size) {
      const g = {};
      f.forEach((v) => {
        const w = e.getBaseTarget(v), x = e.getValue(v);
        x && (x.liveStyle = !0), g[v] = w ?? null;
      }), d.push({ animation: g });
    }
    let m = !!d.length;
    return r && (c.initial === !1 || c.initial === c.animate) && !e.manuallyAnimateOnMount && (m = !1), r = !1, m ? t(d) : Promise.resolve();
  }
  function a(l, c) {
    var u;
    if (n[l].isActive === c)
      return Promise.resolve();
    (u = e.variantChildren) === null || u === void 0 || u.forEach((f) => {
      var h;
      return (h = f.animationState) === null || h === void 0 ? void 0 : h.setActive(l, c);
    }), n[l].isActive = c;
    const d = s(l);
    for (const f in n)
      n[f].protectedKeys = {};
    return d;
  }
  return {
    animateChanges: s,
    setActive: a,
    setAnimateFunction: o,
    getState: () => n,
    reset: () => {
      n = O4(), r = !0;
    }
  };
}
function Mne(e, t) {
  return typeof t == "string" ? t !== e : Array.isArray(t) ? !LR(t, e) : !1;
}
function Qs(e = !1) {
  return {
    isActive: e,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function O4() {
  return {
    animate: Qs(!0),
    whileInView: Qs(),
    whileHover: Qs(),
    whileTap: Qs(),
    whileDrag: Qs(),
    whileFocus: Qs(),
    exit: Qs()
  };
}
class Vs {
  constructor(t) {
    this.isMounted = !1, this.node = t;
  }
  update() {
  }
}
class Fne extends Vs {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(t) {
    super(t), t.animationState || (t.animationState = jne(t));
  }
  updateAnimationControlsSubscription() {
    const { animate: t } = this.node.getProps();
    ud(t) && (this.unmountControls = t.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: t } = this.node.getProps(), { animate: n } = this.node.prevProps || {};
    t !== n && this.updateAnimationControlsSubscription();
  }
  unmount() {
    var t;
    this.node.animationState.reset(), (t = this.unmountControls) === null || t === void 0 || t.call(this);
  }
}
let Lne = 0;
class Une extends Vs {
  constructor() {
    super(...arguments), this.id = Lne++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: t, onExitComplete: n } = this.node.presenceContext, { isPresent: r } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || t === r)
      return;
    const i = this.node.animationState.setActive("exit", !t);
    n && !t && i.then(() => n(this.id));
  }
  mount() {
    const { register: t } = this.node.presenceContext || {};
    t && (this.unmount = t(this.id));
  }
  unmount() {
  }
}
const zne = {
  animation: {
    Feature: Fne
  },
  exit: {
    Feature: Une
  }
}, IP = (e) => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1;
function Ny(e, t = "page") {
  return {
    point: {
      x: e[`${t}X`],
      y: e[`${t}Y`]
    }
  };
}
const Vne = (e) => (t) => IP(t) && e(t, Ny(t));
function wo(e, t, n, r = { passive: !0 }) {
  return e.addEventListener(t, n, r), () => e.removeEventListener(t, n);
}
function Ao(e, t, n, r) {
  return wo(e, t, Vne(n), r);
}
const B4 = (e, t) => Math.abs(e - t);
function qne(e, t) {
  const n = B4(e.x, t.x), r = B4(e.y, t.y);
  return Math.sqrt(n ** 2 + r ** 2);
}
class RP {
  constructor(t, n, { transformPagePoint: r, contextWindow: i, dragSnapToOrigin: o = !1 } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const d = Mg(this.lastMoveEventInfo, this.history), f = this.startEvent !== null, h = qne(d.offset, { x: 0, y: 0 }) >= 3;
      if (!f && !h)
        return;
      const { point: p } = d, { timestamp: m } = Ln;
      this.history.push({ ...p, timestamp: m });
      const { onStart: g, onMove: v } = this.handlers;
      f || (g && g(this.lastMoveEvent, d), this.startEvent = this.lastMoveEvent), v && v(this.lastMoveEvent, d);
    }, this.handlePointerMove = (d, f) => {
      this.lastMoveEvent = d, this.lastMoveEventInfo = jg(f, this.transformPagePoint), Pt.update(this.updatePoint, !0);
    }, this.handlePointerUp = (d, f) => {
      this.end();
      const { onEnd: h, onSessionEnd: p, resumeAnimation: m } = this.handlers;
      if (this.dragSnapToOrigin && m && m(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const g = Mg(d.type === "pointercancel" ? this.lastMoveEventInfo : jg(f, this.transformPagePoint), this.history);
      this.startEvent && h && h(d, g), p && p(d, g);
    }, !IP(t))
      return;
    this.dragSnapToOrigin = o, this.handlers = n, this.transformPagePoint = r, this.contextWindow = i || window;
    const s = Ny(t), a = jg(s, this.transformPagePoint), { point: l } = a, { timestamp: c } = Ln;
    this.history = [{ ...l, timestamp: c }];
    const { onSessionStart: u } = n;
    u && u(t, Mg(a, this.history)), this.removeListeners = So(Ao(this.contextWindow, "pointermove", this.handlePointerMove), Ao(this.contextWindow, "pointerup", this.handlePointerUp), Ao(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(t) {
    this.handlers = t;
  }
  end() {
    this.removeListeners && this.removeListeners(), eo(this.updatePoint);
  }
}
function jg(e, t) {
  return t ? { point: t(e.point) } : e;
}
function N4(e, t) {
  return { x: e.x - t.x, y: e.y - t.y };
}
function Mg({ point: e }, t) {
  return {
    point: e,
    delta: N4(e, PP(t)),
    offset: N4(e, $ne(t)),
    velocity: Wne(t, 0.1)
  };
}
function $ne(e) {
  return e[0];
}
function PP(e) {
  return e[e.length - 1];
}
function Wne(e, t) {
  if (e.length < 2)
    return { x: 0, y: 0 };
  let n = e.length - 1, r = null;
  const i = PP(e);
  for (; n >= 0 && (r = e[n], !(i.timestamp - r.timestamp > Si(t))); )
    n--;
  if (!r)
    return { x: 0, y: 0 };
  const o = Ki(i.timestamp - r.timestamp);
  if (o === 0)
    return { x: 0, y: 0 };
  const s = {
    x: (i.x - r.x) / o,
    y: (i.y - r.y) / o
  };
  return s.x === 1 / 0 && (s.x = 0), s.y === 1 / 0 && (s.y = 0), s;
}
function OP(e) {
  let t = null;
  return () => {
    const n = () => {
      t = null;
    };
    return t === null ? (t = e, n) : !1;
  };
}
const D4 = OP("dragHorizontal"), j4 = OP("dragVertical");
function BP(e) {
  let t = !1;
  if (e === "y")
    t = j4();
  else if (e === "x")
    t = D4();
  else {
    const n = D4(), r = j4();
    n && r ? t = () => {
      n(), r();
    } : (n && n(), r && r());
  }
  return t;
}
function NP() {
  const e = BP(!0);
  return e ? (e(), !1) : !0;
}
function gl(e) {
  return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current");
}
const DP = 1e-4, Gne = 1 - DP, Hne = 1 + DP, jP = 0.01, Kne = 0 - jP, Yne = 0 + jP;
function Nr(e) {
  return e.max - e.min;
}
function Qne(e, t, n) {
  return Math.abs(e - t) <= n;
}
function M4(e, t, n, r = 0.5) {
  e.origin = r, e.originPoint = Xt(t.min, t.max, e.origin), e.scale = Nr(n) / Nr(t), e.translate = Xt(n.min, n.max, e.origin) - e.originPoint, (e.scale >= Gne && e.scale <= Hne || isNaN(e.scale)) && (e.scale = 1), (e.translate >= Kne && e.translate <= Yne || isNaN(e.translate)) && (e.translate = 0);
}
function Nu(e, t, n, r) {
  M4(e.x, t.x, n.x, r ? r.originX : void 0), M4(e.y, t.y, n.y, r ? r.originY : void 0);
}
function F4(e, t, n) {
  e.min = n.min + t.min, e.max = e.min + Nr(t);
}
function Jne(e, t, n) {
  F4(e.x, t.x, n.x), F4(e.y, t.y, n.y);
}
function L4(e, t, n) {
  e.min = t.min - n.min, e.max = e.min + Nr(t);
}
function Du(e, t, n) {
  L4(e.x, t.x, n.x), L4(e.y, t.y, n.y);
}
function Xne(e, { min: t, max: n }, r) {
  return t !== void 0 && e < t ? e = r ? Xt(t, e, r.min) : Math.max(e, t) : n !== void 0 && e > n && (e = r ? Xt(n, e, r.max) : Math.min(e, n)), e;
}
function U4(e, t, n) {
  return {
    min: t !== void 0 ? e.min + t : void 0,
    max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0
  };
}
function Zne(e, { top: t, left: n, bottom: r, right: i }) {
  return {
    x: U4(e.x, n, i),
    y: U4(e.y, t, r)
  };
}
function z4(e, t) {
  let n = t.min - e.min, r = t.max - e.max;
  return t.max - t.min < e.max - e.min && ([n, r] = [r, n]), { min: n, max: r };
}
function ere(e, t) {
  return {
    x: z4(e.x, t.x),
    y: z4(e.y, t.y)
  };
}
function tre(e, t) {
  let n = 0.5;
  const r = Nr(e), i = Nr(t);
  return i > r ? n = uc(t.min, t.max - r, e.min) : r > i && (n = uc(e.min, e.max - i, t.min)), Is(0, 1, n);
}
function nre(e, t) {
  const n = {};
  return t.min !== void 0 && (n.min = t.min - e.min), t.max !== void 0 && (n.max = t.max - e.min), n;
}
const o0 = 0.35;
function rre(e = o0) {
  return e === !1 ? e = 0 : e === !0 && (e = o0), {
    x: V4(e, "left", "right"),
    y: V4(e, "top", "bottom")
  };
}
function V4(e, t, n) {
  return {
    min: q4(e, t),
    max: q4(e, n)
  };
}
function q4(e, t) {
  return typeof e == "number" ? e : e[t] || 0;
}
const $4 = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), vl = () => ({
  x: $4(),
  y: $4()
}), W4 = () => ({ min: 0, max: 0 }), dn = () => ({
  x: W4(),
  y: W4()
});
function Gr(e) {
  return [e("x"), e("y")];
}
function MP({ top: e, left: t, right: n, bottom: r }) {
  return {
    x: { min: t, max: n },
    y: { min: e, max: r }
  };
}
function ire({ x: e, y: t }) {
  return { top: t.min, right: e.max, bottom: t.max, left: e.min };
}
function ore(e, t) {
  if (!t)
    return e;
  const n = t({ x: e.left, y: e.top }), r = t({ x: e.right, y: e.bottom });
  return {
    top: n.y,
    left: n.x,
    bottom: r.y,
    right: r.x
  };
}
function Fg(e) {
  return e === void 0 || e === 1;
}
function s0({ scale: e, scaleX: t, scaleY: n }) {
  return !Fg(e) || !Fg(t) || !Fg(n);
}
function Js(e) {
  return s0(e) || FP(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY;
}
function FP(e) {
  return G4(e.x) || G4(e.y);
}
function G4(e) {
  return e && e !== "0%";
}
function ap(e, t, n) {
  const r = e - n, i = t * r;
  return n + i;
}
function H4(e, t, n, r, i) {
  return i !== void 0 && (e = ap(e, i, r)), ap(e, n, r) + t;
}
function a0(e, t = 0, n = 1, r, i) {
  e.min = H4(e.min, t, n, r, i), e.max = H4(e.max, t, n, r, i);
}
function LP(e, { x: t, y: n }) {
  a0(e.x, t.translate, t.scale, t.originPoint), a0(e.y, n.translate, n.scale, n.originPoint);
}
const K4 = 0.999999999999, Y4 = 1.0000000000001;
function sre(e, t, n, r = !1) {
  const i = n.length;
  if (!i)
    return;
  t.x = t.y = 1;
  let o, s;
  for (let a = 0; a < i; a++) {
    o = n[a], s = o.projectionDelta;
    const { visualElement: l } = o.options;
    l && l.props.style && l.props.style.display === "contents" || (r && o.options.layoutScroll && o.scroll && o !== o.root && wl(e, {
      x: -o.scroll.offset.x,
      y: -o.scroll.offset.y
    }), s && (t.x *= s.x.scale, t.y *= s.y.scale, LP(e, s)), r && Js(o.latestValues) && wl(e, o.latestValues));
  }
  t.x < Y4 && t.x > K4 && (t.x = 1), t.y < Y4 && t.y > K4 && (t.y = 1);
}
function bl(e, t) {
  e.min = e.min + t, e.max = e.max + t;
}
function Q4(e, t, n, r, i = 0.5) {
  const o = Xt(e.min, e.max, i);
  a0(e, t, n, o, r);
}
function wl(e, t) {
  Q4(e.x, t.x, t.scaleX, t.scale, t.originX), Q4(e.y, t.y, t.scaleY, t.scale, t.originY);
}
function UP(e, t) {
  return MP(ore(e.getBoundingClientRect(), t));
}
function are(e, t, n) {
  const r = UP(e, n), { scroll: i } = t;
  return i && (bl(r.x, i.offset.x), bl(r.y, i.offset.y)), r;
}
const zP = ({ current: e }) => e ? e.ownerDocument.defaultView : null, lre = /* @__PURE__ */ new WeakMap();
class cre {
  constructor(t) {
    this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = dn(), this.visualElement = t;
  }
  start(t, { snapToCursor: n = !1 } = {}) {
    const { presenceContext: r } = this.visualElement;
    if (r && r.isPresent === !1)
      return;
    const i = (u) => {
      const { dragSnapToOrigin: d } = this.getProps();
      d ? this.pauseAnimation() : this.stopAnimation(), n && this.snapToCursor(Ny(u, "page").point);
    }, o = (u, d) => {
      var f;
      const { drag: h, dragPropagation: p, onDragStart: m } = this.getProps();
      if (h && !p && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = BP(h), !this.openGlobalLock))
        return;
      this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Gr((v) => {
        let w = this.getAxisMotionValue(v).get() || 0;
        if (Yi.test(w)) {
          const { projection: x } = this.visualElement;
          if (x && x.layout) {
            const C = x.layout.layoutBox[v];
            C && (w = Nr(C) * (parseFloat(w) / 100));
          }
        }
        this.originPoint[v] = w;
      }), m && Pt.postRender(() => m(u, d)), (f = this.removeWillChange) === null || f === void 0 || f.call(this), this.removeWillChange = r0(this.visualElement, "transform");
      const { animationState: g } = this.visualElement;
      g && g.setActive("whileDrag", !0);
    }, s = (u, d) => {
      const { dragPropagation: f, dragDirectionLock: h, onDirectionLock: p, onDrag: m } = this.getProps();
      if (!f && !this.openGlobalLock)
        return;
      const { offset: g } = d;
      if (h && this.currentDirection === null) {
        this.currentDirection = ure(g), this.currentDirection !== null && p && p(this.currentDirection);
        return;
      }
      this.updateAxis("x", d.point, g), this.updateAxis("y", d.point, g), this.visualElement.render(), m && m(u, d);
    }, a = (u, d) => this.stop(u, d), l = () => Gr((u) => {
      var d;
      return this.getAnimationState(u) === "paused" && ((d = this.getAxisMotionValue(u).animation) === null || d === void 0 ? void 0 : d.play());
    }), { dragSnapToOrigin: c } = this.getProps();
    this.panSession = new RP(t, {
      onSessionStart: i,
      onStart: o,
      onMove: s,
      onSessionEnd: a,
      resumeAnimation: l
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin: c,
      contextWindow: zP(this.visualElement)
    });
  }
  stop(t, n) {
    var r;
    (r = this.removeWillChange) === null || r === void 0 || r.call(this);
    const i = this.isDragging;
    if (this.cancel(), !i)
      return;
    const { velocity: o } = n;
    this.startAnimation(o);
    const { onDragEnd: s } = this.getProps();
    s && Pt.postRender(() => s(t, n));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: t, animationState: n } = this.visualElement;
    t && (t.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation: r } = this.getProps();
    !r && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), n && n.setActive("whileDrag", !1);
  }
  updateAxis(t, n, r) {
    const { drag: i } = this.getProps();
    if (!r || !Yf(t, i, this.currentDirection))
      return;
    const o = this.getAxisMotionValue(t);
    let s = this.originPoint[t] + r[t];
    this.constraints && this.constraints[t] && (s = Xne(s, this.constraints[t], this.elastic[t])), o.set(s);
  }
  resolveConstraints() {
    var t;
    const { dragConstraints: n, dragElastic: r } = this.getProps(), i = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (t = this.visualElement.projection) === null || t === void 0 ? void 0 : t.layout, o = this.constraints;
    n && gl(n) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : n && i ? this.constraints = Zne(i.layoutBox, n) : this.constraints = !1, this.elastic = rre(r), o !== this.constraints && i && this.constraints && !this.hasMutatedConstraints && Gr((s) => {
      this.constraints !== !1 && this.getAxisMotionValue(s) && (this.constraints[s] = nre(i.layoutBox[s], this.constraints[s]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: t, onMeasureDragConstraints: n } = this.getProps();
    if (!t || !gl(t))
      return !1;
    const r = t.current;
    Br(r !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection: i } = this.visualElement;
    if (!i || !i.layout)
      return !1;
    const o = are(r, i.root, this.visualElement.getTransformPagePoint());
    let s = ere(i.layout.layoutBox, o);
    if (n) {
      const a = n(ire(s));
      this.hasMutatedConstraints = !!a, a && (s = MP(a));
    }
    return s;
  }
  startAnimation(t) {
    const { drag: n, dragMomentum: r, dragElastic: i, dragTransition: o, dragSnapToOrigin: s, onDragTransitionEnd: a } = this.getProps(), l = this.constraints || {}, c = Gr((u) => {
      if (!Yf(u, n, this.currentDirection))
        return;
      let d = l && l[u] || {};
      s && (d = { min: 0, max: 0 });
      const f = i ? 200 : 1e6, h = i ? 40 : 1e7, p = {
        type: "inertia",
        velocity: r ? t[u] : 0,
        bounceStiffness: f,
        bounceDamping: h,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...o,
        ...d
      };
      return this.startAxisValueAnimation(u, p);
    });
    return Promise.all(c).then(a);
  }
  startAxisValueAnimation(t, n) {
    const r = this.getAxisMotionValue(t);
    return r.start(M1(t, r, 0, n, this.visualElement, !1, r0(this.visualElement, t)));
  }
  stopAnimation() {
    Gr((t) => this.getAxisMotionValue(t).stop());
  }
  pauseAnimation() {
    Gr((t) => {
      var n;
      return (n = this.getAxisMotionValue(t).animation) === null || n === void 0 ? void 0 : n.pause();
    });
  }
  getAnimationState(t) {
    var n;
    return (n = this.getAxisMotionValue(t).animation) === null || n === void 0 ? void 0 : n.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(t) {
    const n = `_drag${t.toUpperCase()}`, r = this.visualElement.getProps(), i = r[n];
    return i || this.visualElement.getValue(t, (r.initial ? r.initial[t] : void 0) || 0);
  }
  snapToCursor(t) {
    Gr((n) => {
      const { drag: r } = this.getProps();
      if (!Yf(n, r, this.currentDirection))
        return;
      const { projection: i } = this.visualElement, o = this.getAxisMotionValue(n);
      if (i && i.layout) {
        const { min: s, max: a } = i.layout.layoutBox[n];
        o.set(t[n] - Xt(s, a, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: t, dragConstraints: n } = this.getProps(), { projection: r } = this.visualElement;
    if (!gl(n) || !r || !this.constraints)
      return;
    this.stopAnimation();
    const i = { x: 0, y: 0 };
    Gr((s) => {
      const a = this.getAxisMotionValue(s);
      if (a && this.constraints !== !1) {
        const l = a.get();
        i[s] = tre({ min: l, max: l }, this.constraints[s]);
      }
    });
    const { transformTemplate: o } = this.visualElement.getProps();
    this.visualElement.current.style.transform = o ? o({}, "") : "none", r.root && r.root.updateScroll(), r.updateLayout(), this.resolveConstraints(), Gr((s) => {
      if (!Yf(s, t, null))
        return;
      const a = this.getAxisMotionValue(s), { min: l, max: c } = this.constraints[s];
      a.set(Xt(l, c, i[s]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    lre.set(this.visualElement, this);
    const t = this.visualElement.current, n = Ao(t, "pointerdown", (l) => {
      const { drag: c, dragListener: u = !0 } = this.getProps();
      c && u && this.start(l);
    }), r = () => {
      const { dragConstraints: l } = this.getProps();
      gl(l) && l.current && (this.constraints = this.resolveRefConstraints());
    }, { projection: i } = this.visualElement, o = i.addEventListener("measure", r);
    i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), Pt.read(r);
    const s = wo(window, "resize", () => this.scalePositionWithinConstraints()), a = i.addEventListener("didUpdate", ({ delta: l, hasLayoutChanged: c }) => {
      this.isDragging && c && (Gr((u) => {
        const d = this.getAxisMotionValue(u);
        d && (this.originPoint[u] += l[u].translate, d.set(d.get() + l[u].translate));
      }), this.visualElement.render());
    });
    return () => {
      s(), n(), o(), a && a();
    };
  }
  getProps() {
    const t = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: r = !1, dragPropagation: i = !1, dragConstraints: o = !1, dragElastic: s = o0, dragMomentum: a = !0 } = t;
    return {
      ...t,
      drag: n,
      dragDirectionLock: r,
      dragPropagation: i,
      dragConstraints: o,
      dragElastic: s,
      dragMomentum: a
    };
  }
}
function Yf(e, t, n) {
  return (t === !0 || t === e) && (n === null || n === e);
}
function ure(e, t = 10) {
  let n = null;
  return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"), n;
}
class dre extends Vs {
  constructor(t) {
    super(t), this.removeGroupControls = Un, this.removeListeners = Un, this.controls = new cre(t);
  }
  mount() {
    const { dragControls: t } = this.node.getProps();
    t && (this.removeGroupControls = t.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || Un;
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const J4 = (e) => (t, n) => {
  e && Pt.postRender(() => e(t, n));
};
class fre extends Vs {
  constructor() {
    super(...arguments), this.removePointerDownListener = Un;
  }
  onPointerDown(t) {
    this.session = new RP(t, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: zP(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart: t, onPanStart: n, onPan: r, onPanEnd: i } = this.node.getProps();
    return {
      onSessionStart: J4(t),
      onStart: J4(n),
      onMove: r,
      onEnd: (o, s) => {
        delete this.session, i && Pt.postRender(() => i(o, s));
      }
    };
  }
  mount() {
    this.removePointerDownListener = Ao(this.node.current, "pointerdown", (t) => this.onPointerDown(t));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
const af = Ge(null);
function VP() {
  const e = we(af);
  if (e === null)
    return [!0, null];
  const { isPresent: t, onExitComplete: n, register: r } = e, i = M0();
  Te(() => r(i), []);
  const o = Ie(() => n && n(i), [i, n]);
  return !t && n ? [!1, o] : [!0];
}
function hre() {
  return pre(we(af));
}
function pre(e) {
  return e === null ? !0 : e.isPresent;
}
const hd = Ge({}), qP = Ge({}), kh = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
};
function X4(e, t) {
  return t.max === t.min ? 0 : e / (t.max - t.min) * 100;
}
const cu = {
  correct: (e, t) => {
    if (!t.target)
      return e;
    if (typeof e == "string")
      if (Qe.test(e))
        e = parseFloat(e);
      else
        return e;
    const n = X4(e, t.target.x), r = X4(e, t.target.y);
    return `${n}% ${r}%`;
  }
}, yre = {
  correct: (e, { treeScale: t, projectionDelta: n }) => {
    const r = e, i = Rs.parse(e);
    if (i.length > 5)
      return r;
    const o = Rs.createTransformer(e), s = typeof i[0] != "number" ? 1 : 0, a = n.x.scale * t.x, l = n.y.scale * t.y;
    i[0 + s] /= a, i[1 + s] /= l;
    const c = Xt(a, l, 0.5);
    return typeof i[2 + s] == "number" && (i[2 + s] /= c), typeof i[3 + s] == "number" && (i[3 + s] /= c), o(i);
  }
}, lp = {};
function mre(e) {
  Object.assign(lp, e);
}
const { schedule: z1, cancel: bbe } = UR(queueMicrotask, !1);
class gre extends iD {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: r, layoutId: i } = this.props, { projection: o } = t;
    mre(vre), o && (n.group && n.group.add(o), r && r.register && i && r.register(o), o.root.didUpdate(), o.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), o.setOptions({
      ...o.options,
      onExitComplete: () => this.safeToRemove()
    })), kh.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(t) {
    const { layoutDependency: n, visualElement: r, drag: i, isPresent: o } = this.props, s = r.projection;
    return s && (s.isPresent = o, i || t.layoutDependency !== n || n === void 0 ? s.willUpdate() : this.safeToRemove(), t.isPresent !== o && (o ? s.promote() : s.relegate() || Pt.postRender(() => {
      const a = s.getStack();
      (!a || !a.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: t } = this.props.visualElement;
    t && (t.root.didUpdate(), z1.postRender(() => {
      !t.currentAnimation && t.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: r } = this.props, { projection: i } = t;
    i && (i.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(i), r && r.deregister && r.deregister(i));
  }
  safeToRemove() {
    const { safeToRemove: t } = this.props;
    t && t();
  }
  render() {
    return null;
  }
}
function $P(e) {
  const [t, n] = VP(), r = we(hd);
  return y.jsx(gre, { ...e, layoutGroup: r, switchLayoutGroup: we(qP), isPresent: t, safeToRemove: n });
}
const vre = {
  borderRadius: {
    ...cu,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: cu,
  borderTopRightRadius: cu,
  borderBottomLeftRadius: cu,
  borderBottomRightRadius: cu,
  boxShadow: yre
}, WP = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], bre = WP.length, Z4 = (e) => typeof e == "string" ? parseFloat(e) : e, e8 = (e) => typeof e == "number" || Qe.test(e);
function wre(e, t, n, r, i, o) {
  i ? (e.opacity = Xt(
    0,
    // TODO Reinstate this if only child
    n.opacity !== void 0 ? n.opacity : 1,
    xre(r)
  ), e.opacityExit = Xt(t.opacity !== void 0 ? t.opacity : 1, 0, Cre(r))) : o && (e.opacity = Xt(t.opacity !== void 0 ? t.opacity : 1, n.opacity !== void 0 ? n.opacity : 1, r));
  for (let s = 0; s < bre; s++) {
    const a = `border${WP[s]}Radius`;
    let l = t8(t, a), c = t8(n, a);
    if (l === void 0 && c === void 0)
      continue;
    l || (l = 0), c || (c = 0), l === 0 || c === 0 || e8(l) === e8(c) ? (e[a] = Math.max(Xt(Z4(l), Z4(c), r), 0), (Yi.test(c) || Yi.test(l)) && (e[a] += "%")) : e[a] = c;
  }
  (t.rotate || n.rotate) && (e.rotate = Xt(t.rotate || 0, n.rotate || 0, r));
}
function t8(e, t) {
  return e[t] !== void 0 ? e[t] : e.borderRadius;
}
const xre = /* @__PURE__ */ GP(0, 0.5, fP), Cre = /* @__PURE__ */ GP(0.5, 0.95, Un);
function GP(e, t, n) {
  return (r) => r < e ? 0 : r > t ? 1 : n(uc(e, t, r));
}
function n8(e, t) {
  e.min = t.min, e.max = t.max;
}
function Vr(e, t) {
  n8(e.x, t.x), n8(e.y, t.y);
}
function r8(e, t) {
  e.translate = t.translate, e.scale = t.scale, e.originPoint = t.originPoint, e.origin = t.origin;
}
function i8(e, t, n, r, i) {
  return e -= t, e = ap(e, 1 / n, r), i !== void 0 && (e = ap(e, 1 / i, r)), e;
}
function kre(e, t = 0, n = 1, r = 0.5, i, o = e, s = e) {
  if (Yi.test(t) && (t = parseFloat(t), t = Xt(s.min, s.max, t / 100) - s.min), typeof t != "number")
    return;
  let a = Xt(o.min, o.max, r);
  e === o && (a -= t), e.min = i8(e.min, t, n, a, i), e.max = i8(e.max, t, n, a, i);
}
function o8(e, t, [n, r, i], o, s) {
  kre(e, t[n], t[r], t[i], t.scale, o, s);
}
const Ere = ["x", "scaleX", "originX"], Sre = ["y", "scaleY", "originY"];
function s8(e, t, n, r) {
  o8(e.x, t, Ere, n ? n.x : void 0, r ? r.x : void 0), o8(e.y, t, Sre, n ? n.y : void 0, r ? r.y : void 0);
}
function a8(e) {
  return e.translate === 0 && e.scale === 1;
}
function HP(e) {
  return a8(e.x) && a8(e.y);
}
function l8(e, t) {
  return e.min === t.min && e.max === t.max;
}
function Are(e, t) {
  return l8(e.x, t.x) && l8(e.y, t.y);
}
function c8(e, t) {
  return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max);
}
function KP(e, t) {
  return c8(e.x, t.x) && c8(e.y, t.y);
}
function u8(e) {
  return Nr(e.x) / Nr(e.y);
}
function d8(e, t) {
  return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint;
}
class Tre {
  constructor() {
    this.members = [];
  }
  add(t) {
    Oy(this.members, t), t.scheduleRender();
  }
  remove(t) {
    if (sf(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) {
      const n = this.members[this.members.length - 1];
      n && this.promote(n);
    }
  }
  relegate(t) {
    const n = this.members.findIndex((i) => t === i);
    if (n === 0)
      return !1;
    let r;
    for (let i = n; i >= 0; i--) {
      const o = this.members[i];
      if (o.isPresent !== !1) {
        r = o;
        break;
      }
    }
    return r ? (this.promote(r), !0) : !1;
  }
  promote(t, n) {
    const r = this.lead;
    if (t !== r && (this.prevLead = r, this.lead = t, t.show(), r)) {
      r.instance && r.scheduleRender(), t.scheduleRender(), t.resumeFrom = r, n && (t.resumeFrom.preserveOpacity = !0), r.snapshot && (t.snapshot = r.snapshot, t.snapshot.latestValues = r.animationValues || r.latestValues), t.root && t.root.isUpdating && (t.isLayoutDirty = !0);
      const { crossfade: i } = t.options;
      i === !1 && r.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((t) => {
      const { options: n, resumingFrom: r } = t;
      n.onExitComplete && n.onExitComplete(), r && r.options.onExitComplete && r.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((t) => {
      t.instance && t.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function _re(e, t, n) {
  let r = "";
  const i = e.x.translate / t.x, o = e.y.translate / t.y, s = (n == null ? void 0 : n.z) || 0;
  if ((i || o || s) && (r = `translate3d(${i}px, ${o}px, ${s}px) `), (t.x !== 1 || t.y !== 1) && (r += `scale(${1 / t.x}, ${1 / t.y}) `), n) {
    const { transformPerspective: c, rotate: u, rotateX: d, rotateY: f, skewX: h, skewY: p } = n;
    c && (r = `perspective(${c}px) ${r}`), u && (r += `rotate(${u}deg) `), d && (r += `rotateX(${d}deg) `), f && (r += `rotateY(${f}deg) `), h && (r += `skewX(${h}deg) `), p && (r += `skewY(${p}deg) `);
  }
  const a = e.x.scale * t.x, l = e.y.scale * t.y;
  return (a !== 1 || l !== 1) && (r += `scale(${a}, ${l})`), r || "none";
}
const Ire = (e, t) => e.depth - t.depth;
class Rre {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(t) {
    Oy(this.children, t), this.isDirty = !0;
  }
  remove(t) {
    sf(this.children, t), this.isDirty = !0;
  }
  forEach(t) {
    this.isDirty && this.children.sort(Ire), this.isDirty = !1, this.children.forEach(t);
  }
}
function Eh(e) {
  const t = Nn(e) ? e.get() : e;
  return kne(t) ? t.toValue() : t;
}
function Pre(e, t) {
  const n = Eo.now(), r = ({ timestamp: i }) => {
    const o = i - n;
    o >= t && (eo(r), e(o - t));
  };
  return Pt.read(r, !0), () => eo(r);
}
function YP(e) {
  return e instanceof SVGElement && e.tagName !== "svg";
}
function V1(e, t, n) {
  const r = Nn(e) ? e : dc(e);
  return r.start(M1("", r, t, n)), r.animation;
}
const Xs = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
}, Cu = typeof window < "u" && window.MotionDebug !== void 0, Lg = ["", "X", "Y", "Z"], Ore = { visibility: "hidden" }, f8 = 1e3;
let Bre = 0;
function Ug(e, t, n, r) {
  const { latestValues: i } = t;
  i[e] && (n[e] = i[e], t.setStaticValue(e, 0), r && (r[e] = 0));
}
function QP(e) {
  if (e.hasCheckedOptimisedAppear = !0, e.root === e)
    return;
  const { visualElement: t } = e.options;
  if (!t)
    return;
  const n = AP(t);
  if (window.MotionHasOptimisedAnimation(n, "transform")) {
    const { layout: i, layoutId: o } = e.options;
    window.MotionCancelOptimisedAnimation(n, "transform", Pt, !(i || o));
  }
  const { parent: r } = e;
  r && !r.hasCheckedOptimisedAppear && QP(r);
}
function JP({ attachResizeListener: e, defaultParent: t, measureScroll: n, checkIsScrollRoot: r, resetTransform: i }) {
  return class {
    constructor(s = {}, a = t == null ? void 0 : t()) {
      this.id = Bre++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, Cu && (Xs.totalNodes = Xs.resolvedTargetDeltas = Xs.recalculatedProjection = 0), this.nodes.forEach(jre), this.nodes.forEach(zre), this.nodes.forEach(Vre), this.nodes.forEach(Mre), Cu && window.MotionDebug.record(Xs);
      }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = s, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0;
      for (let l = 0; l < this.path.length; l++)
        this.path[l].shouldResetTransform = !0;
      this.root === this && (this.nodes = new Rre());
    }
    addEventListener(s, a) {
      return this.eventHandlers.has(s) || this.eventHandlers.set(s, new F1()), this.eventHandlers.get(s).add(a);
    }
    notifyListeners(s, ...a) {
      const l = this.eventHandlers.get(s);
      l && l.notify(...a);
    }
    hasListeners(s) {
      return this.eventHandlers.has(s);
    }
    /**
     * Lifecycles
     */
    mount(s, a = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = YP(s), this.instance = s;
      const { layoutId: l, layout: c, visualElement: u } = this.options;
      if (u && !u.current && u.mount(s), this.root.nodes.add(this), this.parent && this.parent.children.add(this), a && (c || l) && (this.isLayoutDirty = !0), e) {
        let d;
        const f = () => this.root.updateBlockedByResize = !1;
        e(s, () => {
          this.root.updateBlockedByResize = !0, d && d(), d = Pre(f, 250), kh.hasAnimatedSinceResize && (kh.hasAnimatedSinceResize = !1, this.nodes.forEach(p8));
        });
      }
      l && this.root.registerSharedNode(l, this), this.options.animate !== !1 && u && (l || c) && this.addEventListener("didUpdate", ({ delta: d, hasLayoutChanged: f, hasRelativeTargetChanged: h, layout: p }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const m = this.options.transition || u.getDefaultTransition() || Hre, { onLayoutAnimationStart: g, onLayoutAnimationComplete: v } = u.getProps(), w = !this.targetLayout || !KP(this.targetLayout, p) || h, x = !f && h;
        if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || x || f && (w || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(d, x);
          const C = {
            ...k1(m, "layout"),
            onPlay: g,
            onComplete: v
          };
          (u.shouldReduceMotion || this.options.layoutRoot) && (C.delay = 0, C.type = !1), this.startAnimation(C);
        } else
          f || p8(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = p;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const s = this.getStack();
      s && s.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, eo(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(qre), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: s } = this.options;
      return s && s.getProps().transformTemplate;
    }
    willUpdate(s = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && QP(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let u = 0; u < this.path.length; u++) {
        const d = this.path[u];
        d.shouldResetTransform = !0, d.updateScroll("snapshot"), d.options.layoutRoot && d.willUpdate(!1);
      }
      const { layoutId: a, layout: l } = this.options;
      if (a === void 0 && !l)
        return;
      const c = this.getTransformTemplate();
      this.prevTransformTemplateValue = c ? c(this.latestValues, "") : void 0, this.updateSnapshot(), s && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(h8);
        return;
      }
      this.isUpdating || this.nodes.forEach(Lre), this.isUpdating = !1, this.nodes.forEach(Ure), this.nodes.forEach(Nre), this.nodes.forEach(Dre), this.clearAllSnapshots();
      const a = Eo.now();
      Ln.delta = Is(0, 1e3 / 60, a - Ln.timestamp), Ln.timestamp = a, Ln.isProcessing = !0, Pg.update.process(Ln), Pg.preRender.process(Ln), Pg.render.process(Ln), Ln.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, z1.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(Fre), this.sharedNodes.forEach($re);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Pt.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      Pt.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let l = 0; l < this.path.length; l++)
          this.path[l].updateScroll();
      const s = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = dn(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: a } = this.options;
      a && a.notify("LayoutMeasure", this.layout.layoutBox, s ? s.layoutBox : void 0);
    }
    updateScroll(s = "measure") {
      let a = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === s && (a = !1), a) {
        const l = r(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: s,
          isRoot: l,
          offset: n(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : l
        };
      }
    }
    resetTransform() {
      if (!i)
        return;
      const s = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, a = this.projectionDelta && !HP(this.projectionDelta), l = this.getTransformTemplate(), c = l ? l(this.latestValues, "") : void 0, u = c !== this.prevTransformTemplateValue;
      s && (a || Js(this.latestValues) || u) && (i(this.instance, c), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(s = !0) {
      const a = this.measurePageBox();
      let l = this.removeElementScroll(a);
      return s && (l = this.removeTransform(l)), Kre(l), {
        animationId: this.root.animationId,
        measuredBox: a,
        layoutBox: l,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      var s;
      const { visualElement: a } = this.options;
      if (!a)
        return dn();
      const l = a.measureViewportBox();
      if (!(((s = this.scroll) === null || s === void 0 ? void 0 : s.wasRoot) || this.path.some(Yre))) {
        const { scroll: u } = this.root;
        u && (bl(l.x, u.offset.x), bl(l.y, u.offset.y));
      }
      return l;
    }
    removeElementScroll(s) {
      var a;
      const l = dn();
      if (Vr(l, s), !((a = this.scroll) === null || a === void 0) && a.wasRoot)
        return l;
      for (let c = 0; c < this.path.length; c++) {
        const u = this.path[c], { scroll: d, options: f } = u;
        u !== this.root && d && f.layoutScroll && (d.wasRoot && Vr(l, s), bl(l.x, d.offset.x), bl(l.y, d.offset.y));
      }
      return l;
    }
    applyTransform(s, a = !1) {
      const l = dn();
      Vr(l, s);
      for (let c = 0; c < this.path.length; c++) {
        const u = this.path[c];
        !a && u.options.layoutScroll && u.scroll && u !== u.root && wl(l, {
          x: -u.scroll.offset.x,
          y: -u.scroll.offset.y
        }), Js(u.latestValues) && wl(l, u.latestValues);
      }
      return Js(this.latestValues) && wl(l, this.latestValues), l;
    }
    removeTransform(s) {
      const a = dn();
      Vr(a, s);
      for (let l = 0; l < this.path.length; l++) {
        const c = this.path[l];
        if (!c.instance || !Js(c.latestValues))
          continue;
        s0(c.latestValues) && c.updateSnapshot();
        const u = dn(), d = c.measurePageBox();
        Vr(u, d), s8(a, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, u);
      }
      return Js(this.latestValues) && s8(a, this.latestValues), a;
    }
    setTargetDelta(s) {
      this.targetDelta = s, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(s) {
      this.options = {
        ...this.options,
        ...s,
        crossfade: s.crossfade !== void 0 ? s.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Ln.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(s = !1) {
      var a;
      const l = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = l.isSharedProjectionDirty);
      const c = !!this.resumingFrom || this !== l;
      if (!(s || c && this.isSharedProjectionDirty || this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: d, layoutId: f } = this.options;
      if (!(!this.layout || !(d || f))) {
        if (this.resolvedRelativeTargetAt = Ln.timestamp, !this.targetDelta && !this.relativeTarget) {
          const h = this.getClosestProjectingParent();
          h && h.layout && this.animationProgress !== 1 ? (this.relativeParent = h, this.forceRelativeParentToResolveTarget(), this.relativeTarget = dn(), this.relativeTargetOrigin = dn(), Du(this.relativeTargetOrigin, this.layout.layoutBox, h.layout.layoutBox), Vr(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (this.target || (this.target = dn(), this.targetWithTransforms = dn()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), Jne(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Vr(this.target, this.layout.layoutBox), LP(this.target, this.targetDelta)) : Vr(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
            this.attemptToResolveRelativeTarget = !1;
            const h = this.getClosestProjectingParent();
            h && !!h.resumingFrom == !!this.resumingFrom && !h.options.layoutScroll && h.target && this.animationProgress !== 1 ? (this.relativeParent = h, this.forceRelativeParentToResolveTarget(), this.relativeTarget = dn(), this.relativeTargetOrigin = dn(), Du(this.relativeTargetOrigin, this.target, h.target), Vr(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
          }
          Cu && Xs.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || s0(this.parent.latestValues) || FP(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var s;
      const a = this.getLead(), l = !!this.resumingFrom || this !== a;
      let c = !0;
      if ((this.isProjectionDirty || !((s = this.parent) === null || s === void 0) && s.isProjectionDirty) && (c = !1), l && (this.isSharedProjectionDirty || this.isTransformDirty) && (c = !1), this.resolvedRelativeTargetAt === Ln.timestamp && (c = !1), c)
        return;
      const { layout: u, layoutId: d } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(u || d))
        return;
      Vr(this.layoutCorrected, this.layout.layoutBox);
      const f = this.treeScale.x, h = this.treeScale.y;
      sre(this.layoutCorrected, this.treeScale, this.path, l), a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox, a.targetWithTransforms = dn());
      const { target: p } = a;
      if (!p) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (r8(this.prevProjectionDelta.x, this.projectionDelta.x), r8(this.prevProjectionDelta.y, this.projectionDelta.y)), Nu(this.projectionDelta, this.layoutCorrected, p, this.latestValues), (this.treeScale.x !== f || this.treeScale.y !== h || !d8(this.projectionDelta.x, this.prevProjectionDelta.x) || !d8(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", p)), Cu && Xs.recalculatedProjection++;
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(s = !0) {
      var a;
      if ((a = this.options.visualElement) === null || a === void 0 || a.scheduleRender(), s) {
        const l = this.getStack();
        l && l.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = vl(), this.projectionDelta = vl(), this.projectionDeltaWithTransform = vl();
    }
    setAnimationOrigin(s, a = !1) {
      const l = this.snapshot, c = l ? l.latestValues : {}, u = { ...this.latestValues }, d = vl();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a;
      const f = dn(), h = l ? l.source : void 0, p = this.layout ? this.layout.source : void 0, m = h !== p, g = this.getStack(), v = !g || g.members.length <= 1, w = !!(m && !v && this.options.crossfade === !0 && !this.path.some(Gre));
      this.animationProgress = 0;
      let x;
      this.mixTargetDelta = (C) => {
        const S = C / 1e3;
        y8(d.x, s.x, S), y8(d.y, s.y, S), this.setTargetDelta(d), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Du(f, this.layout.layoutBox, this.relativeParent.layout.layoutBox), Wre(this.relativeTarget, this.relativeTargetOrigin, f, S), x && Are(this.relativeTarget, x) && (this.isProjectionDirty = !1), x || (x = dn()), Vr(x, this.relativeTarget)), m && (this.animationValues = u, wre(u, c, this.latestValues, S, w, v)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = S;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(s) {
      this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (eo(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Pt.update(() => {
        kh.hasAnimatedSinceResize = !0, this.currentAnimation = V1(0, f8, {
          ...s,
          onUpdate: (a) => {
            this.mixTargetDelta(a), s.onUpdate && s.onUpdate(a);
          },
          onComplete: () => {
            s.onComplete && s.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const s = this.getStack();
      s && s.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(f8), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const s = this.getLead();
      let { targetWithTransforms: a, target: l, layout: c, latestValues: u } = s;
      if (!(!a || !l || !c)) {
        if (this !== s && this.layout && c && XP(this.options.animationType, this.layout.layoutBox, c.layoutBox)) {
          l = this.target || dn();
          const d = Nr(this.layout.layoutBox.x);
          l.x.min = s.target.x.min, l.x.max = l.x.min + d;
          const f = Nr(this.layout.layoutBox.y);
          l.y.min = s.target.y.min, l.y.max = l.y.min + f;
        }
        Vr(a, l), wl(a, u), Nu(this.projectionDeltaWithTransform, this.layoutCorrected, a, u);
      }
    }
    registerSharedNode(s, a) {
      this.sharedNodes.has(s) || this.sharedNodes.set(s, new Tre()), this.sharedNodes.get(s).add(a);
      const c = a.options.initialPromotionConfig;
      a.promote({
        transition: c ? c.transition : void 0,
        preserveFollowOpacity: c && c.shouldPreserveFollowOpacity ? c.shouldPreserveFollowOpacity(a) : void 0
      });
    }
    isLead() {
      const s = this.getStack();
      return s ? s.lead === this : !0;
    }
    getLead() {
      var s;
      const { layoutId: a } = this.options;
      return a ? ((s = this.getStack()) === null || s === void 0 ? void 0 : s.lead) || this : this;
    }
    getPrevLead() {
      var s;
      const { layoutId: a } = this.options;
      return a ? (s = this.getStack()) === null || s === void 0 ? void 0 : s.prevLead : void 0;
    }
    getStack() {
      const { layoutId: s } = this.options;
      if (s)
        return this.root.sharedNodes.get(s);
    }
    promote({ needsReset: s, transition: a, preserveFollowOpacity: l } = {}) {
      const c = this.getStack();
      c && c.promote(this, l), s && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a });
    }
    relegate() {
      const s = this.getStack();
      return s ? s.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: s } = this.options;
      if (!s)
        return;
      let a = !1;
      const { latestValues: l } = s;
      if ((l.z || l.rotate || l.rotateX || l.rotateY || l.rotateZ || l.skewX || l.skewY) && (a = !0), !a)
        return;
      const c = {};
      l.z && Ug("z", s, c, this.animationValues);
      for (let u = 0; u < Lg.length; u++)
        Ug(`rotate${Lg[u]}`, s, c, this.animationValues), Ug(`skew${Lg[u]}`, s, c, this.animationValues);
      s.render();
      for (const u in c)
        s.setStaticValue(u, c[u]), this.animationValues && (this.animationValues[u] = c[u]);
      s.scheduleRender();
    }
    getProjectionStyles(s) {
      var a, l;
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible)
        return Ore;
      const c = {
        visibility: ""
      }, u = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = !1, c.opacity = "", c.pointerEvents = Eh(s == null ? void 0 : s.pointerEvents) || "", c.transform = u ? u(this.latestValues, "") : "none", c;
      const d = this.getLead();
      if (!this.projectionDelta || !this.layout || !d.target) {
        const m = {};
        return this.options.layoutId && (m.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, m.pointerEvents = Eh(s == null ? void 0 : s.pointerEvents) || ""), this.hasProjected && !Js(this.latestValues) && (m.transform = u ? u({}, "") : "none", this.hasProjected = !1), m;
      }
      const f = d.animationValues || d.latestValues;
      this.applyTransformsToTarget(), c.transform = _re(this.projectionDeltaWithTransform, this.treeScale, f), u && (c.transform = u(f, c.transform));
      const { x: h, y: p } = this.projectionDelta;
      c.transformOrigin = `${h.origin * 100}% ${p.origin * 100}% 0`, d.animationValues ? c.opacity = d === this ? (l = (a = f.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && l !== void 0 ? l : 1 : this.preserveOpacity ? this.latestValues.opacity : f.opacityExit : c.opacity = d === this ? f.opacity !== void 0 ? f.opacity : "" : f.opacityExit !== void 0 ? f.opacityExit : 0;
      for (const m in lp) {
        if (f[m] === void 0)
          continue;
        const { correct: g, applyTo: v } = lp[m], w = c.transform === "none" ? f[m] : g(f[m], d);
        if (v) {
          const x = v.length;
          for (let C = 0; C < x; C++)
            c[v[C]] = w;
        } else
          c[m] = w;
      }
      return this.options.layoutId && (c.pointerEvents = d === this ? Eh(s == null ? void 0 : s.pointerEvents) || "" : "none"), c;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((s) => {
        var a;
        return (a = s.currentAnimation) === null || a === void 0 ? void 0 : a.stop();
      }), this.root.nodes.forEach(h8), this.root.sharedNodes.clear();
    }
  };
}
function Nre(e) {
  e.updateLayout();
}
function Dre(e) {
  var t;
  const n = ((t = e.resumeFrom) === null || t === void 0 ? void 0 : t.snapshot) || e.snapshot;
  if (e.isLead() && e.layout && n && e.hasListeners("didUpdate")) {
    const { layoutBox: r, measuredBox: i } = e.layout, { animationType: o } = e.options, s = n.source !== e.layout.source;
    o === "size" ? Gr((d) => {
      const f = s ? n.measuredBox[d] : n.layoutBox[d], h = Nr(f);
      f.min = r[d].min, f.max = f.min + h;
    }) : XP(o, n.layoutBox, r) && Gr((d) => {
      const f = s ? n.measuredBox[d] : n.layoutBox[d], h = Nr(r[d]);
      f.max = f.min + h, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[d].max = e.relativeTarget[d].min + h);
    });
    const a = vl();
    Nu(a, r, n.layoutBox);
    const l = vl();
    s ? Nu(l, e.applyTransform(i, !0), n.measuredBox) : Nu(l, r, n.layoutBox);
    const c = !HP(a);
    let u = !1;
    if (!e.resumeFrom) {
      const d = e.getClosestProjectingParent();
      if (d && !d.resumeFrom) {
        const { snapshot: f, layout: h } = d;
        if (f && h) {
          const p = dn();
          Du(p, n.layoutBox, f.layoutBox);
          const m = dn();
          Du(m, r, h.layoutBox), KP(p, m) || (u = !0), d.options.layoutRoot && (e.relativeTarget = m, e.relativeTargetOrigin = p, e.relativeParent = d);
        }
      }
    }
    e.notifyListeners("didUpdate", {
      layout: r,
      snapshot: n,
      delta: l,
      layoutDelta: a,
      hasLayoutChanged: c,
      hasRelativeTargetChanged: u
    });
  } else if (e.isLead()) {
    const { onExitComplete: r } = e.options;
    r && r();
  }
  e.options.transition = void 0;
}
function jre(e) {
  Cu && Xs.totalNodes++, e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty));
}
function Mre(e) {
  e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1;
}
function Fre(e) {
  e.clearSnapshot();
}
function h8(e) {
  e.clearMeasurements();
}
function Lre(e) {
  e.isLayoutDirty = !1;
}
function Ure(e) {
  const { visualElement: t } = e.options;
  t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform();
}
function p8(e) {
  e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0;
}
function zre(e) {
  e.resolveTargetDelta();
}
function Vre(e) {
  e.calcProjection();
}
function qre(e) {
  e.resetSkewAndRotation();
}
function $re(e) {
  e.removeLeadSnapshot();
}
function y8(e, t, n) {
  e.translate = Xt(t.translate, 0, n), e.scale = Xt(t.scale, 1, n), e.origin = t.origin, e.originPoint = t.originPoint;
}
function m8(e, t, n, r) {
  e.min = Xt(t.min, n.min, r), e.max = Xt(t.max, n.max, r);
}
function Wre(e, t, n, r) {
  m8(e.x, t.x, n.x, r), m8(e.y, t.y, n.y, r);
}
function Gre(e) {
  return e.animationValues && e.animationValues.opacityExit !== void 0;
}
const Hre = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, g8 = (e) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e), v8 = g8("applewebkit/") && !g8("chrome/") ? Math.round : Un;
function b8(e) {
  e.min = v8(e.min), e.max = v8(e.max);
}
function Kre(e) {
  b8(e.x), b8(e.y);
}
function XP(e, t, n) {
  return e === "position" || e === "preserve-aspect" && !Qne(u8(t), u8(n), 0.2);
}
function Yre(e) {
  var t;
  return e !== e.root && ((t = e.scroll) === null || t === void 0 ? void 0 : t.wasRoot);
}
const Qre = JP({
  attachResizeListener: (e, t) => wo(e, "resize", t),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), zg = {
  current: void 0
}, ZP = JP({
  measureScroll: (e) => ({
    x: e.scrollLeft,
    y: e.scrollTop
  }),
  defaultParent: () => {
    if (!zg.current) {
      const e = new Qre({});
      e.mount(window), e.setOptions({ layoutScroll: !0 }), zg.current = e;
    }
    return zg.current;
  },
  resetTransform: (e, t) => {
    e.style.transform = t !== void 0 ? t : "none";
  },
  checkIsScrollRoot: (e) => window.getComputedStyle(e).position === "fixed"
}), Jre = {
  pan: {
    Feature: fre
  },
  drag: {
    Feature: dre,
    ProjectionNode: ZP,
    MeasureLayout: $P
  }
};
function w8(e, t) {
  const n = t ? "pointerenter" : "pointerleave", r = t ? "onHoverStart" : "onHoverEnd", i = (o, s) => {
    if (o.pointerType === "touch" || NP())
      return;
    const a = e.getProps();
    e.animationState && a.whileHover && e.animationState.setActive("whileHover", t);
    const l = a[r];
    l && Pt.postRender(() => l(o, s));
  };
  return Ao(e.current, n, i, {
    passive: !e.getProps()[r]
  });
}
class Xre extends Vs {
  mount() {
    this.unmount = So(w8(this.node, !0), w8(this.node, !1));
  }
  unmount() {
  }
}
class Zre extends Vs {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let t = !1;
    try {
      t = this.node.current.matches(":focus-visible");
    } catch {
      t = !0;
    }
    !t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = So(wo(this.node.current, "focus", () => this.onFocus()), wo(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
const eO = (e, t) => t ? e === t ? !0 : eO(e, t.parentElement) : !1;
function Vg(e, t) {
  if (!t)
    return;
  const n = new PointerEvent("pointer" + e);
  t(n, Ny(n));
}
class eie extends Vs {
  constructor() {
    super(...arguments), this.removeStartListeners = Un, this.removeEndListeners = Un, this.removeAccessibleListeners = Un, this.startPointerPress = (t, n) => {
      if (this.isPressing)
        return;
      this.removeEndListeners();
      const r = this.node.getProps(), o = Ao(window, "pointerup", (a, l) => {
        if (!this.checkPressEnd())
          return;
        const { onTap: c, onTapCancel: u, globalTapTarget: d } = this.node.getProps(), f = !d && !eO(this.node.current, a.target) ? u : c;
        f && Pt.update(() => f(a, l));
      }, {
        passive: !(r.onTap || r.onPointerUp)
      }), s = Ao(window, "pointercancel", (a, l) => this.cancelPress(a, l), {
        passive: !(r.onTapCancel || r.onPointerCancel)
      });
      this.removeEndListeners = So(o, s), this.startPress(t, n);
    }, this.startAccessiblePress = () => {
      const t = (o) => {
        if (o.key !== "Enter" || this.isPressing)
          return;
        const s = (a) => {
          a.key !== "Enter" || !this.checkPressEnd() || Vg("up", (l, c) => {
            const { onTap: u } = this.node.getProps();
            u && Pt.postRender(() => u(l, c));
          });
        };
        this.removeEndListeners(), this.removeEndListeners = wo(this.node.current, "keyup", s), Vg("down", (a, l) => {
          this.startPress(a, l);
        });
      }, n = wo(this.node.current, "keydown", t), r = () => {
        this.isPressing && Vg("cancel", (o, s) => this.cancelPress(o, s));
      }, i = wo(this.node.current, "blur", r);
      this.removeAccessibleListeners = So(n, i);
    };
  }
  startPress(t, n) {
    this.isPressing = !0;
    const { onTapStart: r, whileTap: i } = this.node.getProps();
    i && this.node.animationState && this.node.animationState.setActive("whileTap", !0), r && Pt.postRender(() => r(t, n));
  }
  checkPressEnd() {
    return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !NP();
  }
  cancelPress(t, n) {
    if (!this.checkPressEnd())
      return;
    const { onTapCancel: r } = this.node.getProps();
    r && Pt.postRender(() => r(t, n));
  }
  mount() {
    const t = this.node.getProps(), n = Ao(t.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
      passive: !(t.onTapStart || t.onPointerStart)
    }), r = wo(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = So(n, r);
  }
  unmount() {
    this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners();
  }
}
const l0 = /* @__PURE__ */ new WeakMap(), qg = /* @__PURE__ */ new WeakMap(), tie = (e) => {
  const t = l0.get(e.target);
  t && t(e);
}, nie = (e) => {
  e.forEach(tie);
};
function rie({ root: e, ...t }) {
  const n = e || document;
  qg.has(n) || qg.set(n, {});
  const r = qg.get(n), i = JSON.stringify(t);
  return r[i] || (r[i] = new IntersectionObserver(nie, { root: e, ...t })), r[i];
}
function iie(e, t, n) {
  const r = rie(t);
  return l0.set(e, n), r.observe(e), () => {
    l0.delete(e), r.unobserve(e);
  };
}
const oie = {
  some: 0,
  all: 1
};
class sie extends Vs {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: t = {} } = this.node.getProps(), { root: n, margin: r, amount: i = "some", once: o } = t, s = {
      root: n ? n.current : void 0,
      rootMargin: r,
      threshold: typeof i == "number" ? i : oie[i]
    }, a = (l) => {
      const { isIntersecting: c } = l;
      if (this.isInView === c || (this.isInView = c, o && !c && this.hasEnteredView))
        return;
      c && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", c);
      const { onViewportEnter: u, onViewportLeave: d } = this.node.getProps(), f = c ? u : d;
      f && f(l);
    };
    return iie(this.node.current, s, a);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: t, prevProps: n } = this.node;
    ["amount", "margin", "root"].some(aie(t, n)) && this.startObserver();
  }
  unmount() {
  }
}
function aie({ viewport: e = {} }, { viewport: t = {} } = {}) {
  return (n) => e[n] !== t[n];
}
const lie = {
  inView: {
    Feature: sie
  },
  tap: {
    Feature: eie
  },
  focus: {
    Feature: Zre
  },
  hover: {
    Feature: Xre
  }
}, cie = {
  layout: {
    ProjectionNode: ZP,
    MeasureLayout: $P
  }
}, Dy = Ge({
  transformPagePoint: (e) => e,
  isStatic: !1,
  reducedMotion: "never"
}), jy = Ge({}), q1 = typeof window < "u", lf = q1 ? js : Te, tO = Ge({ strict: !1 });
let x8 = !1;
function uie(e, t, n, r, i) {
  var o;
  const { visualElement: s } = we(jy), a = we(tO), l = we(af), c = we(Dy).reducedMotion, u = It();
  r = r || a.renderer, !u.current && r && (u.current = r(e, {
    visualState: t,
    parent: s,
    props: n,
    presenceContext: l,
    blockInitialAnimation: l ? l.initial === !1 : !1,
    reducedMotionConfig: c
  }));
  const d = u.current, f = we(qP);
  d && !d.projection && i && (d.type === "html" || d.type === "svg") && fie(u.current, n, i, f), aA(() => {
    d && d.update(n, l);
  });
  const h = n[SP], p = It(!!h && !window.MotionHandoffIsComplete && ((o = window.MotionHasOptimisedAnimation) === null || o === void 0 ? void 0 : o.call(window, h)));
  return lf(() => {
    d && (d.updateFeatures(), z1.render(d.render), p.current && d.animationState && d.animationState.animateChanges());
  }), Te(() => {
    d && (!p.current && d.animationState && d.animationState.animateChanges(), p.current = !1, x8 || (x8 = !0, queueMicrotask(die)));
  }), d;
}
function die() {
  window.MotionHandoffIsComplete = !0;
}
function fie(e, t, n, r) {
  const { layoutId: i, layout: o, drag: s, dragConstraints: a, layoutScroll: l, layoutRoot: c } = t;
  e.projection = new n(e.latestValues, t["data-framer-portal-id"] ? void 0 : nO(e.parent)), e.projection.setOptions({
    layoutId: i,
    layout: o,
    alwaysMeasureLayout: !!s || a && gl(a),
    visualElement: e,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof o == "string" ? o : "both",
    initialPromotionConfig: r,
    layoutScroll: l,
    layoutRoot: c
  });
}
function nO(e) {
  if (e)
    return e.options.allowProjection !== !1 ? e.projection : nO(e.parent);
}
function hie(e, t, n) {
  return Ie(
    (r) => {
      r && e.mount && e.mount(r), t && (r ? t.mount(r) : t.unmount()), n && (typeof n == "function" ? n(r) : gl(n) && (n.current = r));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [t]
  );
}
function My(e) {
  return ud(e.animate) || C1.some((t) => dd(e[t]));
}
function rO(e) {
  return !!(My(e) || e.variants);
}
function pie(e, t) {
  if (My(e)) {
    const { initial: n, animate: r } = e;
    return {
      initial: n === !1 || dd(n) ? n : void 0,
      animate: dd(r) ? r : void 0
    };
  }
  return e.inherit !== !1 ? t : {};
}
function yie(e) {
  const { initial: t, animate: n } = pie(e, we(jy));
  return J(() => ({ initial: t, animate: n }), [C8(t), C8(n)]);
}
function C8(e) {
  return Array.isArray(e) ? e.join(" ") : e;
}
const k8 = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, fc = {};
for (const e in k8)
  fc[e] = {
    isEnabled: (t) => k8[e].some((n) => !!t[n])
  };
function mie(e) {
  for (const t in e)
    fc[t] = {
      ...fc[t],
      ...e[t]
    };
}
const gie = Symbol.for("motionComponentSymbol");
function vie({ preloadedFeatures: e, createVisualElement: t, useRender: n, useVisualState: r, Component: i }) {
  e && mie(e);
  function o(a, l) {
    let c;
    const u = {
      ...we(Dy),
      ...a,
      layoutId: bie(a)
    }, { isStatic: d } = u, f = yie(a), h = r(a, d);
    if (!d && q1) {
      wie(u, e);
      const p = xie(u);
      c = p.MeasureLayout, f.visualElement = uie(i, h, u, t, p.ProjectionNode);
    }
    return y.jsxs(jy.Provider, { value: f, children: [c && f.visualElement ? y.jsx(c, { visualElement: f.visualElement, ...u }) : null, n(i, a, hie(h, f.visualElement, l), h, d, f.visualElement)] });
  }
  const s = lA(o);
  return s[gie] = i, s;
}
function bie({ layoutId: e }) {
  const t = we(hd).id;
  return t && e !== void 0 ? t + "-" + e : e;
}
function wie(e, t) {
  const n = we(tO).strict;
  if (ke.env.NODE_ENV !== "production" && t && n) {
    const r = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
    e.ignoreStrict ? Vc(!1, r) : Br(!1, r);
  }
}
function xie(e) {
  const { drag: t, layout: n } = fc;
  if (!t && !n)
    return {};
  const r = { ...t, ...n };
  return {
    MeasureLayout: t != null && t.isEnabled(e) || n != null && n.isEnabled(e) ? r.MeasureLayout : void 0,
    ProjectionNode: r.ProjectionNode
  };
}
const Cie = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function $1(e) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof e != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    e.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(Cie.indexOf(e) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(e))
    )
  );
}
function iO(e, { style: t, vars: n }, r, i) {
  Object.assign(e.style, t, i && i.getProjectionStyles(r));
  for (const o in n)
    e.style.setProperty(o, n[o]);
}
const oO = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function sO(e, t, n, r) {
  iO(e, t, void 0, r);
  for (const i in t.attrs)
    e.setAttribute(oO.has(i) ? i : By(i), t.attrs[i]);
}
function aO(e, { layout: t, layoutId: n }) {
  return zs.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!lp[e] || e === "opacity");
}
function W1(e, t, n) {
  var r;
  const { style: i } = e, o = {};
  for (const s in i)
    (Nn(i[s]) || t.style && Nn(t.style[s]) || aO(s, e) || ((r = n == null ? void 0 : n.getValue(s)) === null || r === void 0 ? void 0 : r.liveStyle) !== void 0) && (o[s] = i[s]);
  return n && i && typeof i.willChange == "string" && (n.applyWillChange = !1), o;
}
function lO(e, t, n) {
  const r = W1(e, t, n);
  for (const i in e)
    if (Nn(e[i]) || Nn(t[i])) {
      const o = tf.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i;
      r[o] = e[i];
    }
  return r;
}
function Ps(e) {
  const t = It(null);
  return t.current === null && (t.current = e()), t.current;
}
function kie({ applyWillChange: e = !1, scrapeMotionValuesFromProps: t, createRenderState: n, onMount: r }, i, o, s, a) {
  const l = {
    latestValues: Sie(i, o, s, a ? !1 : e, t),
    renderState: n()
  };
  return r && (l.mount = (c) => r(i, c, l)), l;
}
const cO = (e) => (t, n) => {
  const r = we(jy), i = we(af), o = () => kie(e, t, r, i, n);
  return n ? o() : Ps(o);
};
function Eie(e, t) {
  const n = TP(t);
  n && Oy(e, n);
}
function E8(e, t, n) {
  const r = Array.isArray(t) ? t : [t];
  for (let i = 0; i < r.length; i++) {
    const o = w1(e, r[i]);
    if (o) {
      const { transitionEnd: s, transition: a, ...l } = o;
      n(l, s);
    }
  }
}
function Sie(e, t, n, r, i) {
  var o;
  const s = {}, a = [], l = r && ((o = e.style) === null || o === void 0 ? void 0 : o.willChange) === void 0, c = i(e, {});
  for (const g in c)
    s[g] = Eh(c[g]);
  let { initial: u, animate: d } = e;
  const f = My(e), h = rO(e);
  t && h && !f && e.inherit !== !1 && (u === void 0 && (u = t.initial), d === void 0 && (d = t.animate));
  let p = n ? n.initial === !1 : !1;
  p = p || u === !1;
  const m = p ? d : u;
  return m && typeof m != "boolean" && !ud(m) && E8(e, m, (g, v) => {
    for (const w in g) {
      let x = g[w];
      if (Array.isArray(x)) {
        const C = p ? x.length - 1 : 0;
        x = x[C];
      }
      x !== null && (s[w] = x);
    }
    for (const w in v)
      s[w] = v[w];
  }), l && (d && u !== !1 && !ud(d) && E8(e, d, (g) => {
    for (const v in g)
      Eie(a, v);
  }), a.length && (s.willChange = a.join(","))), s;
}
const G1 = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
}), uO = () => ({
  ...G1(),
  attrs: {}
}), dO = (e, t) => t && typeof e == "number" ? t.transform(e) : e, Aie = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, Tie = tf.length;
function _ie(e, t, n) {
  let r = "", i = !0;
  for (let o = 0; o < Tie; o++) {
    const s = tf[o], a = e[s];
    if (a === void 0)
      continue;
    let l = !0;
    if (typeof a == "number" ? l = a === (s.startsWith("scale") ? 1 : 0) : l = parseFloat(a) === 0, !l || n) {
      const c = dO(a, _1[s]);
      if (!l) {
        i = !1;
        const u = Aie[s] || s;
        r += `${u}(${c}) `;
      }
      n && (t[s] = c);
    }
  }
  return r = r.trim(), n ? r = n(t, i ? "" : r) : i && (r = "none"), r;
}
function H1(e, t, n) {
  const { style: r, vars: i, transformOrigin: o } = e;
  let s = !1, a = !1;
  for (const l in t) {
    const c = t[l];
    if (zs.has(l)) {
      s = !0;
      continue;
    } else if ($R(l)) {
      i[l] = c;
      continue;
    } else {
      const u = dO(c, _1[l]);
      l.startsWith("origin") ? (a = !0, o[l] = u) : r[l] = u;
    }
  }
  if (t.transform || (s || n ? r.transform = _ie(t, e.transform, n) : r.transform && (r.transform = "none")), a) {
    const { originX: l = "50%", originY: c = "50%", originZ: u = 0 } = o;
    r.transformOrigin = `${l} ${c} ${u}`;
  }
}
function S8(e, t, n) {
  return typeof e == "string" ? e : Qe.transform(t + n * e);
}
function Iie(e, t, n) {
  const r = S8(t, e.x, e.width), i = S8(n, e.y, e.height);
  return `${r} ${i}`;
}
const Rie = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, Pie = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function Oie(e, t, n = 1, r = 0, i = !0) {
  e.pathLength = 1;
  const o = i ? Rie : Pie;
  e[o.offset] = Qe.transform(-r);
  const s = Qe.transform(t), a = Qe.transform(n);
  e[o.array] = `${s} ${a}`;
}
function K1(e, {
  attrX: t,
  attrY: n,
  attrScale: r,
  originX: i,
  originY: o,
  pathLength: s,
  pathSpacing: a = 1,
  pathOffset: l = 0,
  // This is object creation, which we try to avoid per-frame.
  ...c
}, u, d) {
  if (H1(e, c, d), u) {
    e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
    return;
  }
  e.attrs = e.style, e.style = {};
  const { attrs: f, style: h, dimensions: p } = e;
  f.transform && (p && (h.transform = f.transform), delete f.transform), p && (i !== void 0 || o !== void 0 || h.transform) && (h.transformOrigin = Iie(p, i !== void 0 ? i : 0.5, o !== void 0 ? o : 0.5)), t !== void 0 && (f.x = t), n !== void 0 && (f.y = n), r !== void 0 && (f.scale = r), s !== void 0 && Oie(f, s, a, l, !1);
}
const Y1 = (e) => typeof e == "string" && e.toLowerCase() === "svg", Bie = {
  useVisualState: cO({
    scrapeMotionValuesFromProps: lO,
    createRenderState: uO,
    onMount: (e, t, { renderState: n, latestValues: r }) => {
      Pt.read(() => {
        try {
          n.dimensions = typeof t.getBBox == "function" ? t.getBBox() : t.getBoundingClientRect();
        } catch {
          n.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
      }), Pt.render(() => {
        K1(n, r, Y1(t.tagName), e.transformTemplate), sO(t, n);
      });
    }
  })
}, Nie = {
  useVisualState: cO({
    applyWillChange: !0,
    scrapeMotionValuesFromProps: W1,
    createRenderState: G1
  })
};
function fO(e, t, n) {
  for (const r in t)
    !Nn(t[r]) && !aO(r, n) && (e[r] = t[r]);
}
function Die({ transformTemplate: e }, t) {
  return J(() => {
    const n = G1();
    return H1(n, t, e), Object.assign({}, n.vars, n.style);
  }, [t]);
}
function jie(e, t) {
  const n = e.style || {}, r = {};
  return fO(r, n, e), Object.assign(r, Die(e, t)), r;
}
function Mie(e, t) {
  const n = {}, r = jie(e, t);
  return e.drag && e.dragListener !== !1 && (n.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0), n.style = r, n;
}
const Fie = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function cp(e) {
  return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || Fie.has(e);
}
let hO = (e) => !cp(e);
function Lie(e) {
  e && (hO = (t) => t.startsWith("on") ? !cp(t) : e(t));
}
try {
  Lie(require("@emotion/is-prop-valid").default);
} catch {
}
function Uie(e, t, n) {
  const r = {};
  for (const i in e)
    i === "values" && typeof e.values == "object" || (hO(i) || n === !0 && cp(i) || !t && !cp(i) || // If trying to use native HTML drag events, forward drag listeners
    e.draggable && i.startsWith("onDrag")) && (r[i] = e[i]);
  return r;
}
function zie(e, t, n, r) {
  const i = J(() => {
    const o = uO();
    return K1(o, t, Y1(r), e.transformTemplate), {
      ...o.attrs,
      style: { ...o.style }
    };
  }, [t]);
  if (e.style) {
    const o = {};
    fO(o, e.style, e), i.style = { ...o, ...i.style };
  }
  return i;
}
function Vie(e = !1) {
  return (n, r, i, { latestValues: o }, s) => {
    const l = ($1(n) ? zie : Mie)(r, o, s, n), c = Uie(r, typeof n == "string", e), u = n !== Tc ? { ...c, ...l, ref: i } : {}, { children: d } = r, f = J(() => Nn(d) ? d.get() : d, [d]);
    return Rr(n, {
      ...u,
      children: f
    });
  };
}
function qie(e, t) {
  return function(r, { forwardMotionProps: i } = { forwardMotionProps: !1 }) {
    const s = {
      ...$1(r) ? Bie : Nie,
      preloadedFeatures: e,
      useRender: Vie(i),
      createVisualElement: t,
      Component: r
    };
    return vie(s);
  };
}
const c0 = { current: null }, pO = { current: !1 };
function $ie() {
  if (pO.current = !0, !!q1)
    if (window.matchMedia) {
      const e = window.matchMedia("(prefers-reduced-motion)"), t = () => c0.current = e.matches;
      e.addListener(t), t();
    } else
      c0.current = !1;
}
function Wie(e, t, n) {
  for (const r in t) {
    const i = t[r], o = n[r];
    if (Nn(i))
      e.addValue(r, i), ke.env.NODE_ENV === "development" && Iy(i.version === "11.5.4", `Attempting to mix Framer Motion versions ${i.version} with 11.5.4 may not work as expected.`);
    else if (Nn(o))
      e.addValue(r, dc(i, { owner: e }));
    else if (o !== i)
      if (e.hasValue(r)) {
        const s = e.getValue(r);
        s.liveStyle === !0 ? s.jump(i) : s.hasAnimated || s.set(i);
      } else {
        const s = e.getStaticValue(r);
        e.addValue(r, dc(s !== void 0 ? s : i, { owner: e }));
      }
  }
  for (const r in n)
    t[r] === void 0 && e.removeValue(r);
  return t;
}
const pd = /* @__PURE__ */ new WeakMap(), Gie = [...HR, $n, Rs], Hie = (e) => Gie.find(GR(e)), A8 = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
], Kie = C1.length;
class Yie {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(t, n, r) {
    return {};
  }
  constructor({ parent: t, props: n, presenceContext: r, reducedMotionConfig: i, blockInitialAnimation: o, visualState: s }, a = {}) {
    this.applyWillChange = !1, this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = A1, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.isRenderScheduled = !1, this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.isRenderScheduled = !1, this.scheduleRender = () => {
      this.isRenderScheduled || (this.isRenderScheduled = !0, Pt.render(this.render, !1, !0));
    };
    const { latestValues: l, renderState: c } = s;
    this.latestValues = l, this.baseTarget = { ...l }, this.initialValues = n.initial ? { ...l } : {}, this.renderState = c, this.parent = t, this.props = n, this.presenceContext = r, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = i, this.options = a, this.blockInitialAnimation = !!o, this.isControllingVariants = My(n), this.isVariantNode = rO(n), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(t && t.current);
    const { willChange: u, ...d } = this.scrapeMotionValuesFromProps(n, {}, this);
    for (const f in d) {
      const h = d[f];
      l[f] !== void 0 && Nn(h) && h.set(l[f], !1);
    }
  }
  mount(t) {
    this.current = t, pd.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, r) => this.bindToMotionValue(r, n)), pO.current || $ie(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : c0.current, ke.env.NODE_ENV !== "production" && Iy(this.shouldReduceMotion !== !0, "You have Reduced Motion enabled on your device. Animations may not appear as expected."), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    pd.delete(this.current), this.projection && this.projection.unmount(), eo(this.notifyUpdate), eo(this.render), this.valueSubscriptions.forEach((t) => t()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
    for (const t in this.events)
      this.events[t].clear();
    for (const t in this.features) {
      const n = this.features[t];
      n && (n.unmount(), n.isMounted = !1);
    }
    this.current = null;
  }
  bindToMotionValue(t, n) {
    this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)();
    const r = zs.has(t), i = n.on("change", (a) => {
      this.latestValues[t] = a, this.props.onUpdate && Pt.preRender(this.notifyUpdate), r && this.projection && (this.projection.isTransformDirty = !0);
    }), o = n.on("renderRequest", this.scheduleRender);
    let s;
    window.MotionCheckAppearSync && (s = window.MotionCheckAppearSync(this, t, n)), this.valueSubscriptions.set(t, () => {
      i(), o(), s && s(), n.owner && n.stop();
    });
  }
  sortNodePosition(t) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current);
  }
  updateFeatures() {
    let t = "animation";
    for (t in fc) {
      const n = fc[t];
      if (!n)
        continue;
      const { isEnabled: r, Feature: i } = n;
      if (!this.features[t] && i && r(this.props) && (this.features[t] = new i(this)), this.features[t]) {
        const o = this.features[t];
        o.isMounted ? o.update() : (o.mount(), o.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : dn();
  }
  getStaticValue(t) {
    return this.latestValues[t];
  }
  setStaticValue(t, n) {
    this.latestValues[t] = n;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(t, n) {
    (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = n;
    for (let r = 0; r < A8.length; r++) {
      const i = A8[r];
      this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]);
      const o = "on" + i, s = t[o];
      s && (this.propEventSubscriptions[i] = this.on(i, s));
    }
    this.prevMotionValues = Wie(this, this.scrapeMotionValuesFromProps(t, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(t) {
    return this.props.variants ? this.props.variants[t] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  getVariantContext(t = !1) {
    if (t)
      return this.parent ? this.parent.getVariantContext() : void 0;
    if (!this.isControllingVariants) {
      const r = this.parent ? this.parent.getVariantContext() || {} : {};
      return this.props.initial !== void 0 && (r.initial = this.props.initial), r;
    }
    const n = {};
    for (let r = 0; r < Kie; r++) {
      const i = C1[r], o = this.props[i];
      (dd(o) || o === !1) && (n[i] = o);
    }
    return n;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(t) {
    const n = this.getClosestVariantNode();
    if (n)
      return n.variantChildren && n.variantChildren.add(t), () => n.variantChildren.delete(t);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(t, n) {
    const r = this.values.get(t);
    n !== r && (r && this.removeValue(t), this.bindToMotionValue(t, n), this.values.set(t, n), this.latestValues[t] = n.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(t) {
    this.values.delete(t);
    const n = this.valueSubscriptions.get(t);
    n && (n(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(t) {
    return this.values.has(t);
  }
  getValue(t, n) {
    if (this.props.values && this.props.values[t])
      return this.props.values[t];
    let r = this.values.get(t);
    return r === void 0 && n !== void 0 && (r = dc(n === null ? void 0 : n, { owner: this }), this.addValue(t, r)), r;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(t, n) {
    var r;
    let i = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : (r = this.getBaseTargetFromProps(this.props, t)) !== null && r !== void 0 ? r : this.readValueFromInstance(this.current, t, this.options);
    return i != null && (typeof i == "string" && (VR(i) || zR(i)) ? i = parseFloat(i) : !Hie(i) && Rs.test(n) && (i = tP(t, n)), this.setBaseTarget(t, Nn(i) ? i.get() : i)), Nn(i) ? i.get() : i;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(t, n) {
    this.baseTarget[t] = n;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(t) {
    var n;
    const { initial: r } = this.props;
    let i;
    if (typeof r == "string" || typeof r == "object") {
      const s = w1(this.props, r, (n = this.presenceContext) === null || n === void 0 ? void 0 : n.custom);
      s && (i = s[t]);
    }
    if (r && i !== void 0)
      return i;
    const o = this.getBaseTargetFromProps(this.props, t);
    return o !== void 0 && !Nn(o) ? o : this.initialValues[t] !== void 0 && i === void 0 ? void 0 : this.baseTarget[t];
  }
  on(t, n) {
    return this.events[t] || (this.events[t] = new F1()), this.events[t].add(n);
  }
  notify(t, ...n) {
    this.events[t] && this.events[t].notify(...n);
  }
}
class yO extends Yie {
  constructor() {
    super(...arguments), this.KeyframeResolver = nP;
  }
  sortInstanceNodePosition(t, n) {
    return t.compareDocumentPosition(n) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(t, n) {
    return t.style ? t.style[n] : void 0;
  }
  removeValueFromRenderState(t, { vars: n, style: r }) {
    delete n[t], delete r[t];
  }
}
function Qie(e) {
  return window.getComputedStyle(e);
}
class mO extends yO {
  constructor() {
    super(...arguments), this.type = "html", this.applyWillChange = !0, this.renderInstance = iO;
  }
  readValueFromInstance(t, n) {
    if (zs.has(n)) {
      const r = I1(n);
      return r && r.default || 0;
    } else {
      const r = Qie(t), i = ($R(n) ? r.getPropertyValue(n) : r[n]) || 0;
      return typeof i == "string" ? i.trim() : i;
    }
  }
  measureInstanceViewportBox(t, { transformPagePoint: n }) {
    return UP(t, n);
  }
  build(t, n, r) {
    H1(t, n, r.transformTemplate);
  }
  scrapeMotionValuesFromProps(t, n, r) {
    return W1(t, n, r);
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: t } = this.props;
    Nn(t) && (this.childSubscription = t.on("change", (n) => {
      this.current && (this.current.textContent = `${n}`);
    }));
  }
}
class gO extends yO {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = dn;
  }
  getBaseTargetFromProps(t, n) {
    return t[n];
  }
  readValueFromInstance(t, n) {
    if (zs.has(n)) {
      const r = I1(n);
      return r && r.default || 0;
    }
    return n = oO.has(n) ? n : By(n), t.getAttribute(n);
  }
  scrapeMotionValuesFromProps(t, n, r) {
    return lO(t, n, r);
  }
  build(t, n, r) {
    K1(t, n, this.isSVGTag, r.transformTemplate);
  }
  renderInstance(t, n, r, i) {
    sO(t, n, r, i);
  }
  mount(t) {
    this.isSVGTag = Y1(t.tagName), super.mount(t);
  }
}
const Jie = (e, t) => $1(e) ? new gO(t) : new mO(t, {
  allowProjection: e !== Tc
}), Xie = /* @__PURE__ */ qie({
  ...zne,
  ...lie,
  ...Jre,
  ...cie
}, Jie), Zt = /* @__PURE__ */ $ee(Xie);
class Zie extends P.Component {
  getSnapshotBeforeUpdate(t) {
    const n = this.props.childRef.current;
    if (n && t.isPresent && !this.props.isPresent) {
      const r = this.props.sizeRef.current;
      r.height = n.offsetHeight || 0, r.width = n.offsetWidth || 0, r.top = n.offsetTop, r.left = n.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function eoe({ children: e, isPresent: t }) {
  const n = M0(), r = It(null), i = It({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  }), { nonce: o } = we(Dy);
  return aA(() => {
    const { width: s, height: a, top: l, left: c } = i.current;
    if (t || !r.current || !s || !a)
      return;
    r.current.dataset.motionPopId = n;
    const u = document.createElement("style");
    return o && (u.nonce = o), document.head.appendChild(u), u.sheet && u.sheet.insertRule(`
          [data-motion-pop-id="${n}"] {
            position: absolute !important;
            width: ${s}px !important;
            height: ${a}px !important;
            top: ${l}px !important;
            left: ${c}px !important;
          }
        `), () => {
      document.head.removeChild(u);
    };
  }, [t]), y.jsx(Zie, { isPresent: t, childRef: r, sizeRef: i, children: P.cloneElement(e, { ref: r }) });
}
const toe = ({ children: e, initial: t, isPresent: n, onExitComplete: r, custom: i, presenceAffectsLayout: o, mode: s }) => {
  const a = Ps(noe), l = M0(), c = J(
    () => ({
      id: l,
      initial: t,
      isPresent: n,
      custom: i,
      onExitComplete: (u) => {
        a.set(u, !0);
        for (const d of a.values())
          if (!d)
            return;
        r && r();
      },
      register: (u) => (a.set(u, !1), () => a.delete(u))
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    o ? [Math.random()] : [n]
  );
  return J(() => {
    a.forEach((u, d) => a.set(d, !1));
  }, [n]), P.useEffect(() => {
    !n && !a.size && r && r();
  }, [n]), s === "popLayout" && (e = y.jsx(eoe, { isPresent: n, children: e })), y.jsx(af.Provider, { value: c, children: e });
};
function noe() {
  return /* @__PURE__ */ new Map();
}
const Qf = (e) => e.key || "";
function T8(e) {
  const t = [];
  return sA.forEach(e, (n) => {
    $l(n) && t.push(n);
  }), t;
}
const Fy = ({ children: e, exitBeforeEnter: t, custom: n, initial: r = !0, onExitComplete: i, presenceAffectsLayout: o = !0, mode: s = "sync" }) => {
  Br(!t, "Replace exitBeforeEnter with mode='wait'");
  const a = J(() => T8(e), [e]), l = a.map(Qf), c = It(!0), u = It(a), d = Ps(() => /* @__PURE__ */ new Map()), [f, h] = Oe(a), [p, m] = Oe(a);
  lf(() => {
    c.current = !1, u.current = a;
    for (let w = 0; w < p.length; w++) {
      const x = Qf(p[w]);
      l.includes(x) ? d.delete(x) : d.get(x) !== !0 && d.set(x, !1);
    }
  }, [p, l.length, l.join("-")]);
  const g = [];
  if (a !== f) {
    let w = [...a];
    for (let x = 0; x < p.length; x++) {
      const C = p[x], S = Qf(C);
      l.includes(S) || (w.splice(x, 0, C), g.push(C));
    }
    s === "wait" && g.length && (w = g), m(T8(w)), h(a);
    return;
  }
  ke.env.NODE_ENV !== "production" && s === "wait" && p.length > 1;
  const { forceRender: v } = we(hd);
  return y.jsx(y.Fragment, { children: p.map((w) => {
    const x = Qf(w), C = a === p || l.includes(x), S = () => {
      if (d.has(x))
        d.set(x, !0);
      else
        return;
      let k = !0;
      d.forEach((A) => {
        A || (k = !1);
      }), k && (v == null || v(), m(u.current), i && i());
    };
    return y.jsx(toe, { isPresent: C, initial: !c.current || r ? void 0 : !1, custom: C ? void 0 : n, presenceAffectsLayout: o, mode: s, onExitComplete: C ? void 0 : S, children: w }, x);
  }) });
}, roe = Ge(null);
function ioe() {
  const e = It(!1);
  return lf(() => (e.current = !0, () => {
    e.current = !1;
  }), []), e;
}
function ooe() {
  const e = ioe(), [t, n] = Oe(0), r = Ie(() => {
    e.current && n(t + 1);
  }, [t]);
  return [Ie(() => Pt.postRender(r), [r]), t];
}
const soe = (e) => !e.isLayoutDirty && e.willUpdate(!1);
function _8() {
  const e = /* @__PURE__ */ new Set(), t = /* @__PURE__ */ new WeakMap(), n = () => e.forEach(soe);
  return {
    add: (r) => {
      e.add(r), t.set(r, r.addEventListener("willUpdate", n));
    },
    remove: (r) => {
      e.delete(r);
      const i = t.get(r);
      i && (i(), t.delete(r)), n();
    },
    dirty: n
  };
}
const vO = (e) => e === !0, aoe = (e) => vO(e === !0) || e === "id", loe = ({ children: e, id: t, inherit: n = !0 }) => {
  const r = we(hd), i = we(roe), [o, s] = ooe(), a = It(null), l = r.id || i;
  a.current === null && (aoe(n) && l && (t = t ? l + "-" + t : l), a.current = {
    id: t,
    group: vO(n) && r.group || _8()
  });
  const c = J(() => ({ ...a.current, forceRender: o }), [s]);
  return y.jsx(hd.Provider, { value: c, children: e });
};
function bO(e) {
  const t = Ps(() => dc(e)), { isStatic: n } = we(Dy);
  if (n) {
    const [, r] = Oe(e);
    Te(() => t.on("change", r), []);
  }
  return t;
}
function wO(e, t) {
  const n = bO(t()), r = () => n.set(t());
  return r(), lf(() => {
    const i = () => Pt.preRender(r, !1, !0), o = e.map((s) => s.on("change", i));
    return () => {
      o.forEach((s) => s()), eo(r);
    };
  }), n;
}
const coe = (e) => e && typeof e == "object" && e.mix, uoe = (e) => coe(e) ? e.mix : void 0;
function doe(...e) {
  const t = !Array.isArray(e[0]), n = t ? 0 : -1, r = e[0 + n], i = e[1 + n], o = e[2 + n], s = e[3 + n], a = mP(i, o, {
    mixer: uoe(o[0]),
    ...s
  });
  return t ? a(r) : a;
}
function foe(e) {
  Bu.current = [], e();
  const t = wO(Bu.current, e);
  return Bu.current = void 0, t;
}
function hoe(e, t, n, r) {
  if (typeof e == "function")
    return foe(e);
  const i = typeof t == "function" ? t : doe(t, n, r);
  return Array.isArray(e) ? I8(e, i) : I8([e], ([o]) => i(o));
}
function I8(e, t) {
  const n = Ps(() => []);
  return wO(e, () => {
    n.length = 0;
    const r = e.length;
    for (let i = 0; i < r; i++)
      n[i] = e[i].get();
    return t(n);
  });
}
function xO(e, t, n) {
  var r;
  if (typeof e == "string") {
    let i = document;
    t && (Br(!!t.current, "Scope provided, but no element detected."), i = t.current), n ? ((r = n[e]) !== null && r !== void 0 || (n[e] = i.querySelectorAll(e)), e = n[e]) : e = i.querySelectorAll(e);
  } else e instanceof Element && (e = [e]);
  return Array.from(e || []);
}
function poe(e) {
  e.values.forEach((t) => t.stop());
}
function u0(e, t) {
  [...t].reverse().forEach((r) => {
    const i = e.getVariant(r);
    i && L1(e, i), e.variantChildren && e.variantChildren.forEach((o) => {
      u0(o, t);
    });
  });
}
function yoe(e, t) {
  if (Array.isArray(t))
    return u0(e, t);
  if (typeof t == "string")
    return u0(e, [t]);
  L1(e, t);
}
function moe() {
  let e = !1;
  const t = /* @__PURE__ */ new Set(), n = {
    subscribe(r) {
      return t.add(r), () => void t.delete(r);
    },
    start(r, i) {
      Br(e, "controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.");
      const o = [];
      return t.forEach((s) => {
        o.push(_P(s, r, {
          transitionOverride: i
        }));
      }), Promise.all(o);
    },
    set(r) {
      return Br(e, "controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook."), t.forEach((i) => {
        yoe(i, r);
      });
    },
    stop() {
      t.forEach((r) => {
        poe(r);
      });
    },
    mount() {
      return e = !0, () => {
        e = !1, n.stop();
      };
    }
  };
  return n;
}
function goe(e) {
  return Te(() => () => e(), []);
}
function voe(e) {
  return typeof e == "object" && !Array.isArray(e);
}
function boe(e) {
  const t = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        transform: {},
        transformOrigin: {},
        style: {},
        vars: {},
        attrs: {}
      },
      latestValues: {}
    }
  }, n = YP(e) ? new gO(t) : new mO(t);
  n.mount(e), pd.set(e, n);
}
function woe(e, t = 100) {
  const n = R1({ keyframes: [0, t], ...e }), r = Math.min(bP(n), n0);
  return {
    type: "keyframes",
    ease: (i) => n.next(r * i).value / t,
    duration: Ki(r)
  };
}
function R8(e, t, n, r) {
  var i;
  return typeof t == "number" ? t : t.startsWith("-") || t.startsWith("+") ? Math.max(0, e + parseFloat(t)) : t === "<" ? n : (i = r.get(t)) !== null && i !== void 0 ? i : e;
}
const xoe = (e, t, n) => {
  const r = t - e;
  return ((n - e) % r + r) % r + e;
};
function Coe(e, t) {
  return cP(e) ? e[xoe(0, e.length, t)] : e;
}
function koe(e, t, n) {
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    i.at > t && i.at < n && (sf(e, i), r--);
  }
}
function Eoe(e, t, n, r, i, o) {
  koe(e, i, o);
  for (let s = 0; s < t.length; s++)
    e.push({
      value: t[s],
      at: Xt(i, o, r[s]),
      easing: Coe(n, s)
    });
}
function Soe(e, t) {
  return e.at === t.at ? e.value === null ? 1 : t.value === null ? -1 : 0 : e.at - t.at;
}
const Aoe = "easeInOut";
function Toe(e, { defaultTransition: t = {}, ...n } = {}, r) {
  const i = t.duration || 0.3, o = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), a = {}, l = /* @__PURE__ */ new Map();
  let c = 0, u = 0, d = 0;
  for (let f = 0; f < e.length; f++) {
    const h = e[f];
    if (typeof h == "string") {
      l.set(h, u);
      continue;
    } else if (!Array.isArray(h)) {
      l.set(h.name, R8(u, h.at, c, l));
      continue;
    }
    let [p, m, g = {}] = h;
    g.at !== void 0 && (u = R8(u, g.at, c, l));
    let v = 0;
    const w = (x, C, S, k = 0, A = 0) => {
      const b = _oe(x), { delay: T = 0, times: R = vP(b), type: B = "keyframes", ...O } = C;
      let { ease: L = t.ease || "easeOut", duration: V } = C;
      const N = typeof T == "function" ? T(k, A) : T, M = b.length;
      if (M <= 2 && B === "spring") {
        let ie = 100;
        if (M === 2 && Poe(b)) {
          const se = b[1] - b[0];
          ie = Math.abs(se);
        }
        const he = { ...O };
        V !== void 0 && (he.duration = Si(V));
        const ae = woe(he, ie);
        L = ae.ease, V = ae.duration;
      }
      V ?? (V = i);
      const U = u + N, F = U + V;
      R.length === 1 && R[0] === 0 && (R[1] = 1);
      const $ = R.length - b.length;
      $ > 0 && gP(R, $), b.length === 1 && b.unshift(null), Eoe(S, b, L, R, U, F), v = Math.max(N + V, v), d = Math.max(F, d);
    };
    if (Nn(p)) {
      const x = P8(p, s);
      w(m, g, O8("default", x));
    } else {
      const x = xO(p, r, a), C = x.length;
      for (let S = 0; S < C; S++) {
        m = m, g = g;
        const k = x[S], A = P8(k, s);
        for (const b in m)
          w(m[b], Ioe(g, b), O8(b, A), S, C);
      }
    }
    c = u, u += v;
  }
  return s.forEach((f, h) => {
    for (const p in f) {
      const m = f[p];
      m.sort(Soe);
      const g = [], v = [], w = [];
      for (let C = 0; C < m.length; C++) {
        const { at: S, value: k, easing: A } = m[C];
        g.push(k), v.push(uc(0, d, S)), w.push(A || "easeOut");
      }
      v[0] !== 0 && (v.unshift(0), g.unshift(g[0]), w.unshift(Aoe)), v[v.length - 1] !== 1 && (v.push(1), g.push(null)), o.has(h) || o.set(h, {
        keyframes: {},
        transition: {}
      });
      const x = o.get(h);
      x.keyframes[p] = g, x.transition[p] = {
        ...t,
        duration: d,
        ease: w,
        times: v,
        ...n
      };
    }
  }), o;
}
function P8(e, t) {
  return !t.has(e) && t.set(e, {}), t.get(e);
}
function O8(e, t) {
  return t[e] || (t[e] = []), t[e];
}
function _oe(e) {
  return Array.isArray(e) ? e : [e];
}
function Ioe(e, t) {
  return e[t] ? {
    ...e,
    ...e[t]
  } : { ...e };
}
const Roe = (e) => typeof e == "number", Poe = (e) => e.every(Roe);
function CO(e, t, n, r) {
  const i = xO(e, r), o = i.length;
  Br(!!o, "No valid element provided.");
  const s = [];
  for (let a = 0; a < o; a++) {
    const l = i[a];
    pd.has(l) || boe(l);
    const c = pd.get(l), u = { ...n };
    typeof u.delay == "function" && (u.delay = u.delay(a, o)), s.push(...U1(c, { ...t, transition: u }, {}));
  }
  return new j1(s);
}
const Ooe = (e) => Array.isArray(e) && Array.isArray(e[0]);
function Boe(e, t, n) {
  const r = [];
  return Toe(e, t, n).forEach(({ keyframes: o, transition: s }, a) => {
    let l;
    Nn(a) ? l = V1(a, o.default, s.default) : l = CO(a, o, s), r.push(l);
  }), new j1(r);
}
const kO = (e) => {
  function t(n, r, i) {
    let o;
    return Ooe(n) ? o = Boe(n, r, e) : voe(r) ? o = CO(n, r, i, e) : o = V1(n, r, i), e && e.animations.push(o), o;
  }
  return t;
}, Noe = kO();
function Doe() {
  const e = Ps(() => ({
    current: null,
    // Will be hydrated by React
    animations: []
  })), t = Ps(() => kO(e));
  return goe(() => {
    e.animations.forEach((n) => n.stop());
  }), [e, t];
}
function joe() {
  const e = Ps(moe);
  return lf(e.mount, []), e;
}
const Moe = joe;
function EO(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var i = e.length;
    for (t = 0; t < i; t++) e[t] && (n = EO(e[t])) && (r && (r += " "), r += n);
  } else for (n in e) e[n] && (r && (r += " "), r += n);
  return r;
}
function wr() {
  for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++) (e = arguments[n]) && (t = EO(e)) && (r && (r += " "), r += t);
  return r;
}
const z = lA(
  ({ children: e, as: t = "div", className: n, ...r }, i) => {
    const o = {}, s = {};
    return Object.entries(r).forEach(([a, l]) => {
      ZE.properties.has(a) ? o[a] = l : s[a] = l;
    }), Rr(t, {
      className: wr([ZE(o), n]),
      children: e,
      ref: i,
      ...s
    });
  }
);
function Foe(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Loe(e) {
  var t = Foe(e, "string");
  return typeof t == "symbol" ? t : String(t);
}
function Uoe(e, t, n) {
  return t = Loe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function B8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function N8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? B8(Object(n), !0).forEach(function(r) {
      Uoe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : B8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function D8(e, t) {
  var n = {};
  for (var r in e)
    n[r] = t(e[r], r);
  return n;
}
var zoe = (e, t, n) => {
  for (var r of Object.keys(e)) {
    var i;
    if (e[r] !== ((i = t[r]) !== null && i !== void 0 ? i : n[r]))
      return !1;
  }
  return !0;
}, $c = (e) => {
  var t = (n) => {
    var r = e.defaultClassName, i = N8(N8({}, e.defaultVariants), n);
    for (var o in i) {
      var s, a = (s = i[o]) !== null && s !== void 0 ? s : e.defaultVariants[o];
      if (a != null) {
        var l = a;
        typeof l == "boolean" && (l = l === !0 ? "true" : "false");
        var c = (
          // @ts-expect-error
          e.variantClassNames[o][l]
        );
        c && (r += " " + c);
      }
    }
    for (var [u, d] of e.compoundVariants)
      zoe(u, i, e.defaultVariants) && (r += " " + d);
    return r;
  };
  return t.variants = () => Object.keys(e.variantClassNames), t.classNames = {
    get base() {
      return e.defaultClassName.split(" ")[0];
    },
    get variants() {
      return D8(e.variantClassNames, (n) => D8(n, (r) => r.split(" ")[0]));
    }
  }, t;
}, Voe = $c({ defaultClassName: "_2epb0q4", variantClassNames: { size: { regular: "_2epb0q5", small: "_2epb0q6" }, color: { regular: "_2epb0q7 _2epb0q2 yv8y4rzr yv8y4rzs yv8y4rr7 yv8y4rr8", inverted: "_2epb0q8 _2epb0q3 yv8y4rzj yv8y4rzk yv8y4rrh yv8y4rri" } }, defaultVariants: { size: "regular", color: "regular" }, compoundVariants: [] });
const ei = ({
  variant: e
}) => /* @__PURE__ */ y.jsx("span", { className: Voe(e) });
var Ly = "_15z228e0", qoe = $c({ defaultClassName: "_15z228ec _15z228e1 yv8y4r24 yv8y4r2n yv8y4rg1 yv8y4rfj yv8y4rpl yv8y4rj7 yv8y4rr yv8y4r2z yv8y4rp yv8y4r13", variantClassNames: { color: { primary: "_15z228ed _15z228e2 yv8y4rx1 yv8y4rx2 yv8y4rsp yv8y4rsq yv8y4r11d yv8y4r11e yv8y4r13 yv8y4rp", secondary: "_15z228ee _15z228e3 yv8y4rxj yv8y4rxk yv8y4rt7 yv8y4rt8 yv8y4r11v yv8y4r11w yv8y4r14 yv8y4rq", disabled: "_15z228ef _15z228e4 yv8y4rz1 yv8y4rz2 yv8y4rup yv8y4ruq yv8y4r13d yv8y4r13e", smallButton: "_15z228eg _15z228e5 yv8y4ry1 yv8y4ry2 yv8y4rtp yv8y4rtq yv8y4r12d yv8y4r12e yv8y4r14 yv8y4rq", smallButtonLight: "_15z228eh _15z228e6 yv8y4ryj yv8y4ryk yv8y4ru7 yv8y4ru8 yv8y4r12v yv8y4r12w yv8y4r14 yv8y4rq" }, animation: { none: "_15z228ei", press: "_15z228ej _15z228e0" }, height: { small: "_15z228ek _15z228e7 yv8y4rll" }, border: { regular: "_15z228el _15z228e8 yv8y4r2a" }, size: { regular: "_15z228em _15z228e9 yv8y4rmf", small: "_15z228en _15z228ea _15z228eb yv8y4re9 yv8y4rcr yv8y4r9l yv8y4rb3 yv8y4rmb yv8y4r15" } }, defaultVariants: { color: "primary", animation: "press", border: "regular", size: "regular" }, compoundVariants: [] });
const si = ({ children: e, variant: t, isLoading: n, ...r }) => /* @__PURE__ */ y.jsxs("button", { className: qoe(t), ...r, children: [
  n && /* @__PURE__ */ y.jsx(ei, {}),
  e
] }), ti = (e) => /* @__PURE__ */ y.jsx(z, { height: "px", width: "full", background: "backgroundMuted", ...e });
/**
 * @remix-run/router v1.19.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function an() {
  return an = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, an.apply(this, arguments);
}
var fn;
(function(e) {
  e.Pop = "POP", e.Push = "PUSH", e.Replace = "REPLACE";
})(fn || (fn = {}));
function $oe(e) {
  e === void 0 && (e = {});
  let {
    initialEntries: t = ["/"],
    initialIndex: n,
    v5Compat: r = !1
  } = e, i;
  i = t.map((h, p) => u(h, typeof h == "string" ? null : h.state, p === 0 ? "default" : void 0));
  let o = l(n ?? i.length - 1), s = fn.Pop, a = null;
  function l(h) {
    return Math.min(Math.max(h, 0), i.length - 1);
  }
  function c() {
    return i[o];
  }
  function u(h, p, m) {
    p === void 0 && (p = null);
    let g = d0(i ? c().pathname : "/", h, p, m);
    return gn(g.pathname.charAt(0) === "/", "relative pathnames are not supported in memory history: " + JSON.stringify(h)), g;
  }
  function d(h) {
    return typeof h == "string" ? h : Ba(h);
  }
  return {
    get index() {
      return o;
    },
    get action() {
      return s;
    },
    get location() {
      return c();
    },
    createHref: d,
    createURL(h) {
      return new URL(d(h), "http://localhost");
    },
    encodeLocation(h) {
      let p = typeof h == "string" ? oo(h) : h;
      return {
        pathname: p.pathname || "",
        search: p.search || "",
        hash: p.hash || ""
      };
    },
    push(h, p) {
      s = fn.Push;
      let m = u(h, p);
      o += 1, i.splice(o, i.length, m), r && a && a({
        action: s,
        location: m,
        delta: 1
      });
    },
    replace(h, p) {
      s = fn.Replace;
      let m = u(h, p);
      i[o] = m, r && a && a({
        action: s,
        location: m,
        delta: 0
      });
    },
    go(h) {
      s = fn.Pop;
      let p = l(o + h), m = i[p];
      o = p, a && a({
        action: s,
        location: m,
        delta: h
      });
    },
    listen(h) {
      return a = h, () => {
        a = null;
      };
    }
  };
}
function Ne(e, t) {
  if (e === !1 || e === null || typeof e > "u")
    throw new Error(t);
}
function gn(e, t) {
  if (!e)
    try {
      throw new Error(t);
    } catch {
    }
}
function Woe() {
  return Math.random().toString(36).substr(2, 8);
}
function d0(e, t, n, r) {
  return n === void 0 && (n = null), an({
    pathname: typeof e == "string" ? e : e.pathname,
    search: "",
    hash: ""
  }, typeof t == "string" ? oo(t) : t, {
    state: n,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: t && t.key || r || Woe()
  });
}
function Ba(e) {
  let {
    pathname: t = "/",
    search: n = "",
    hash: r = ""
  } = e;
  return n && n !== "?" && (t += n.charAt(0) === "?" ? n : "?" + n), r && r !== "#" && (t += r.charAt(0) === "#" ? r : "#" + r), t;
}
function oo(e) {
  let t = {};
  if (e) {
    let n = e.indexOf("#");
    n >= 0 && (t.hash = e.substr(n), e = e.substr(0, n));
    let r = e.indexOf("?");
    r >= 0 && (t.search = e.substr(r), e = e.substr(0, r)), e && (t.pathname = e);
  }
  return t;
}
var Mt;
(function(e) {
  e.data = "data", e.deferred = "deferred", e.redirect = "redirect", e.error = "error";
})(Mt || (Mt = {}));
const Goe = /* @__PURE__ */ new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
function Hoe(e) {
  return e.index === !0;
}
function yd(e, t, n, r) {
  return n === void 0 && (n = []), r === void 0 && (r = {}), e.map((i, o) => {
    let s = [...n, String(o)], a = typeof i.id == "string" ? i.id : s.join("-");
    if (Ne(i.index !== !0 || !i.children, "Cannot specify children on an index route"), Ne(!r[a], 'Found a route id collision on id "' + a + `".  Route id's must be globally unique within Data Router usages`), Hoe(i)) {
      let l = an({}, i, t(i), {
        id: a
      });
      return r[a] = l, l;
    } else {
      let l = an({}, i, t(i), {
        id: a,
        children: void 0
      });
      return r[a] = l, i.children && (l.children = yd(i.children, t, s, r)), l;
    }
  });
}
function ta(e, t, n) {
  return n === void 0 && (n = "/"), Sh(e, t, n, !1);
}
function Sh(e, t, n, r) {
  let i = typeof t == "string" ? oo(t) : t, o = Ti(i.pathname || "/", n);
  if (o == null)
    return null;
  let s = SO(e);
  Yoe(s);
  let a = null;
  for (let l = 0; a == null && l < s.length; ++l) {
    let c = TO(o);
    a = ise(s[l], c, r);
  }
  return a;
}
function Koe(e, t) {
  let {
    route: n,
    pathname: r,
    params: i
  } = e;
  return {
    id: n.id,
    pathname: r,
    params: i,
    data: t[n.id],
    handle: n.handle
  };
}
function SO(e, t, n, r) {
  t === void 0 && (t = []), n === void 0 && (n = []), r === void 0 && (r = "");
  let i = (o, s, a) => {
    let l = {
      relativePath: a === void 0 ? o.path || "" : a,
      caseSensitive: o.caseSensitive === !0,
      childrenIndex: s,
      route: o
    };
    l.relativePath.startsWith("/") && (Ne(l.relativePath.startsWith(r), 'Absolute route path "' + l.relativePath + '" nested under path ' + ('"' + r + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), l.relativePath = l.relativePath.slice(r.length));
    let c = Qi([r, l.relativePath]), u = n.concat(l);
    o.children && o.children.length > 0 && (Ne(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      o.index !== !0,
      "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + c + '".')
    ), SO(o.children, t, u, c)), !(o.path == null && !o.index) && t.push({
      path: c,
      score: nse(c, o.index),
      routesMeta: u
    });
  };
  return e.forEach((o, s) => {
    var a;
    if (o.path === "" || !((a = o.path) != null && a.includes("?")))
      i(o, s);
    else
      for (let l of AO(o.path))
        i(o, s, l);
  }), t;
}
function AO(e) {
  let t = e.split("/");
  if (t.length === 0) return [];
  let [n, ...r] = t, i = n.endsWith("?"), o = n.replace(/\?$/, "");
  if (r.length === 0)
    return i ? [o, ""] : [o];
  let s = AO(r.join("/")), a = [];
  return a.push(...s.map((l) => l === "" ? o : [o, l].join("/"))), i && a.push(...s), a.map((l) => e.startsWith("/") && l === "" ? "/" : l);
}
function Yoe(e) {
  e.sort((t, n) => t.score !== n.score ? n.score - t.score : rse(t.routesMeta.map((r) => r.childrenIndex), n.routesMeta.map((r) => r.childrenIndex)));
}
const Qoe = /^:[\w-]+$/, Joe = 3, Xoe = 2, Zoe = 1, ese = 10, tse = -2, j8 = (e) => e === "*";
function nse(e, t) {
  let n = e.split("/"), r = n.length;
  return n.some(j8) && (r += tse), t && (r += Xoe), n.filter((i) => !j8(i)).reduce((i, o) => i + (Qoe.test(o) ? Joe : o === "" ? Zoe : ese), r);
}
function rse(e, t) {
  return e.length === t.length && e.slice(0, -1).every((r, i) => r === t[i]) ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    e[e.length - 1] - t[t.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function ise(e, t, n) {
  n === void 0 && (n = !1);
  let {
    routesMeta: r
  } = e, i = {}, o = "/", s = [];
  for (let a = 0; a < r.length; ++a) {
    let l = r[a], c = a === r.length - 1, u = o === "/" ? t : t.slice(o.length) || "/", d = md({
      path: l.relativePath,
      caseSensitive: l.caseSensitive,
      end: c
    }, u), f = l.route;
    if (!d && c && n && !r[r.length - 1].route.index && (d = md({
      path: l.relativePath,
      caseSensitive: l.caseSensitive,
      end: !1
    }, u)), !d)
      return null;
    Object.assign(i, d.params), s.push({
      // TODO: Can this as be avoided?
      params: i,
      pathname: Qi([o, d.pathname]),
      pathnameBase: lse(Qi([o, d.pathnameBase])),
      route: f
    }), d.pathnameBase !== "/" && (o = Qi([o, d.pathnameBase]));
  }
  return s;
}
function md(e, t) {
  typeof e == "string" && (e = {
    path: e,
    caseSensitive: !1,
    end: !0
  });
  let [n, r] = ose(e.path, e.caseSensitive, e.end), i = t.match(n);
  if (!i) return null;
  let o = i[0], s = o.replace(/(.)\/+$/, "$1"), a = i.slice(1);
  return {
    params: r.reduce((c, u, d) => {
      let {
        paramName: f,
        isOptional: h
      } = u;
      if (f === "*") {
        let m = a[d] || "";
        s = o.slice(0, o.length - m.length).replace(/(.)\/+$/, "$1");
      }
      const p = a[d];
      return h && !p ? c[f] = void 0 : c[f] = (p || "").replace(/%2F/g, "/"), c;
    }, {}),
    pathname: o,
    pathnameBase: s,
    pattern: e
  };
}
function ose(e, t, n) {
  t === void 0 && (t = !1), n === void 0 && (n = !0), gn(e === "*" || !e.endsWith("*") || e.endsWith("/*"), 'Route path "' + e + '" will be treated as if it were ' + ('"' + e.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + e.replace(/\*$/, "/*") + '".'));
  let r = [], i = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (s, a, l) => (r.push({
    paramName: a,
    isOptional: l != null
  }), l ? "/?([^\\/]+)?" : "/([^\\/]+)"));
  return e.endsWith("*") ? (r.push({
    paramName: "*"
  }), i += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : e !== "" && e !== "/" && (i += "(?:(?=\\/|$))"), [new RegExp(i, t ? void 0 : "i"), r];
}
function TO(e) {
  try {
    return e.split("/").map((t) => decodeURIComponent(t).replace(/\//g, "%2F")).join("/");
  } catch (t) {
    return gn(!1, 'The URL path "' + e + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + t + ").")), e;
  }
}
function Ti(e, t) {
  if (t === "/") return e;
  if (!e.toLowerCase().startsWith(t.toLowerCase()))
    return null;
  let n = t.endsWith("/") ? t.length - 1 : t.length, r = e.charAt(n);
  return r && r !== "/" ? null : e.slice(n) || "/";
}
function sse(e, t) {
  t === void 0 && (t = "/");
  let {
    pathname: n,
    search: r = "",
    hash: i = ""
  } = typeof e == "string" ? oo(e) : e;
  return {
    pathname: n ? n.startsWith("/") ? n : ase(n, t) : t,
    search: cse(r),
    hash: use(i)
  };
}
function ase(e, t) {
  let n = t.replace(/\/+$/, "").split("/");
  return e.split("/").forEach((i) => {
    i === ".." ? n.length > 1 && n.pop() : i !== "." && n.push(i);
  }), n.length > 1 ? n.join("/") : "/";
}
function $g(e, t, n, r) {
  return "Cannot include a '" + e + "' character in a manually specified " + ("`to." + t + "` field [" + JSON.stringify(r) + "].  Please separate it out to the ") + ("`to." + n + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function _O(e) {
  return e.filter((t, n) => n === 0 || t.route.path && t.route.path.length > 0);
}
function Uy(e, t) {
  let n = _O(e);
  return t ? n.map((r, i) => i === n.length - 1 ? r.pathname : r.pathnameBase) : n.map((r) => r.pathnameBase);
}
function zy(e, t, n, r) {
  r === void 0 && (r = !1);
  let i;
  typeof e == "string" ? i = oo(e) : (i = an({}, e), Ne(!i.pathname || !i.pathname.includes("?"), $g("?", "pathname", "search", i)), Ne(!i.pathname || !i.pathname.includes("#"), $g("#", "pathname", "hash", i)), Ne(!i.search || !i.search.includes("#"), $g("#", "search", "hash", i)));
  let o = e === "" || i.pathname === "", s = o ? "/" : i.pathname, a;
  if (s == null)
    a = n;
  else {
    let d = t.length - 1;
    if (!r && s.startsWith("..")) {
      let f = s.split("/");
      for (; f[0] === ".."; )
        f.shift(), d -= 1;
      i.pathname = f.join("/");
    }
    a = d >= 0 ? t[d] : "/";
  }
  let l = sse(i, a), c = s && s !== "/" && s.endsWith("/"), u = (o || s === ".") && n.endsWith("/");
  return !l.pathname.endsWith("/") && (c || u) && (l.pathname += "/"), l;
}
const Qi = (e) => e.join("/").replace(/\/\/+/g, "/"), lse = (e) => e.replace(/\/+$/, "").replace(/^\/*/, "/"), cse = (e) => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e, use = (e) => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e;
class f0 {
  constructor(t, n, r, i) {
    i === void 0 && (i = !1), this.status = t, this.statusText = n || "", this.internal = i, r instanceof Error ? (this.data = r.toString(), this.error = r) : this.data = r;
  }
}
function Vy(e) {
  return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data" in e;
}
const IO = ["post", "put", "patch", "delete"], dse = new Set(IO), fse = ["get", ...IO], hse = new Set(fse), pse = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]), yse = /* @__PURE__ */ new Set([307, 308]), Wg = {
  state: "idle",
  location: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
}, mse = {
  state: "idle",
  data: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
}, uu = {
  state: "unblocked",
  proceed: void 0,
  reset: void 0,
  location: void 0
}, Q1 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, gse = (e) => ({
  hasErrorBoundary: !!e.hasErrorBoundary
}), RO = "remix-router-transitions";
function vse(e) {
  const t = e.window ? e.window : typeof window < "u" ? window : void 0, n = typeof t < "u" && typeof t.document < "u" && typeof t.document.createElement < "u", r = !n;
  Ne(e.routes.length > 0, "You must provide a non-empty routes array to createRouter");
  let i;
  if (e.mapRouteProperties)
    i = e.mapRouteProperties;
  else if (e.detectErrorBoundary) {
    let Q = e.detectErrorBoundary;
    i = (ee) => ({
      hasErrorBoundary: Q(ee)
    });
  } else
    i = gse;
  let o = {}, s = yd(e.routes, i, void 0, o), a, l = e.basename || "/", c = e.unstable_dataStrategy || Ese, u = e.unstable_patchRoutesOnNavigation, d = an({
    v7_fetcherPersist: !1,
    v7_normalizeFormMethod: !1,
    v7_partialHydration: !1,
    v7_prependBasename: !1,
    v7_relativeSplatPath: !1,
    v7_skipActionErrorRevalidation: !1
  }, e.future), f = null, h = /* @__PURE__ */ new Set(), p = 1e3, m = /* @__PURE__ */ new Set(), g = null, v = null, w = null, x = e.hydrationData != null, C = ta(s, e.history.location, l), S = null;
  if (C == null && !u) {
    let Q = or(404, {
      pathname: e.history.location.pathname
    }), {
      matches: ee,
      route: Y
    } = W8(s);
    C = ee, S = {
      [Y.id]: Q
    };
  }
  C && !e.hydrationData && ji(C, s, e.history.location.pathname).active && (C = null);
  let k;
  if (C)
    if (C.some((Q) => Q.route.lazy))
      k = !1;
    else if (!C.some((Q) => Q.route.loader))
      k = !0;
    else if (d.v7_partialHydration) {
      let Q = e.hydrationData ? e.hydrationData.loaderData : null, ee = e.hydrationData ? e.hydrationData.errors : null, Y = (j) => j.route.loader ? typeof j.route.loader == "function" && j.route.loader.hydrate === !0 ? !1 : Q && Q[j.route.id] !== void 0 || ee && ee[j.route.id] !== void 0 : !0;
      if (ee) {
        let j = C.findIndex((te) => ee[te.route.id] !== void 0);
        k = C.slice(0, j + 1).every(Y);
      } else
        k = C.every(Y);
    } else
      k = e.hydrationData != null;
  else if (k = !1, C = [], d.v7_partialHydration) {
    let Q = ji(null, s, e.history.location.pathname);
    Q.active && Q.matches && (C = Q.matches);
  }
  let A, b = {
    historyAction: e.history.action,
    location: e.history.location,
    matches: C,
    initialized: k,
    navigation: Wg,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: e.hydrationData != null ? !1 : null,
    preventScrollReset: !1,
    revalidation: "idle",
    loaderData: e.hydrationData && e.hydrationData.loaderData || {},
    actionData: e.hydrationData && e.hydrationData.actionData || null,
    errors: e.hydrationData && e.hydrationData.errors || S,
    fetchers: /* @__PURE__ */ new Map(),
    blockers: /* @__PURE__ */ new Map()
  }, T = fn.Pop, R = !1, B, O = !1, L = /* @__PURE__ */ new Map(), V = null, N = !1, M = !1, U = [], F = /* @__PURE__ */ new Set(), $ = /* @__PURE__ */ new Map(), ie = 0, he = -1, ae = /* @__PURE__ */ new Map(), se = /* @__PURE__ */ new Set(), oe = /* @__PURE__ */ new Map(), ye = /* @__PURE__ */ new Map(), ve = /* @__PURE__ */ new Set(), Be = /* @__PURE__ */ new Map(), it = /* @__PURE__ */ new Map(), lt = /* @__PURE__ */ new Map(), yt;
  function gt() {
    if (f = e.history.listen((Q) => {
      let {
        action: ee,
        location: Y,
        delta: j
      } = Q;
      if (yt) {
        yt(), yt = void 0;
        return;
      }
      gn(it.size === 0 || j != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
      let te = Di({
        currentLocation: b.location,
        nextLocation: Y,
        historyAction: ee
      });
      if (te && j != null) {
        let le = new Promise((ge) => {
          yt = ge;
        });
        e.history.go(j * -1), Ze(te, {
          state: "blocked",
          location: Y,
          proceed() {
            Ze(te, {
              state: "proceeding",
              proceed: void 0,
              reset: void 0,
              location: Y
            }), le.then(() => e.history.go(j));
          },
          reset() {
            let ge = new Map(b.blockers);
            ge.set(te, uu), Le({
              blockers: ge
            });
          }
        });
        return;
      }
      return en(ee, Y);
    }), n) {
      Lse(t, L);
      let Q = () => Use(t, L);
      t.addEventListener("pagehide", Q), V = () => t.removeEventListener("pagehide", Q);
    }
    return b.initialized || en(fn.Pop, b.location, {
      initialHydration: !0
    }), A;
  }
  function vt() {
    f && f(), V && V(), h.clear(), B && B.abort(), b.fetchers.forEach((Q, ee) => q(ee)), b.blockers.forEach((Q, ee) => Ct(ee));
  }
  function ot(Q) {
    return h.add(Q), () => h.delete(Q);
  }
  function Le(Q, ee) {
    ee === void 0 && (ee = {}), b = an({}, b, Q);
    let Y = [], j = [];
    d.v7_fetcherPersist && b.fetchers.forEach((te, le) => {
      te.state === "idle" && (ve.has(le) ? j.push(le) : Y.push(le));
    }), [...h].forEach((te) => te(b, {
      deletedFetchers: j,
      unstable_viewTransitionOpts: ee.viewTransitionOpts,
      unstable_flushSync: ee.flushSync === !0
    })), d.v7_fetcherPersist && (Y.forEach((te) => b.fetchers.delete(te)), j.forEach((te) => q(te)));
  }
  function tt(Q, ee, Y) {
    var j, te;
    let {
      flushSync: le
    } = Y === void 0 ? {} : Y, ge = b.actionData != null && b.navigation.formMethod != null && xi(b.navigation.formMethod) && b.navigation.state === "loading" && ((j = Q.state) == null ? void 0 : j._isRedirect) !== !0, me;
    ee.actionData ? Object.keys(ee.actionData).length > 0 ? me = ee.actionData : me = null : ge ? me = b.actionData : me = null;
    let Ee = ee.loaderData ? q8(b.loaderData, ee.loaderData, ee.matches || [], ee.errors) : b.loaderData, Ce = b.blockers;
    Ce.size > 0 && (Ce = new Map(Ce), Ce.forEach((We, Ke) => Ce.set(Ke, uu)));
    let xe = R === !0 || b.navigation.formMethod != null && xi(b.navigation.formMethod) && ((te = Q.state) == null ? void 0 : te._isRedirect) !== !0;
    a && (s = a, a = void 0), N || T === fn.Pop || (T === fn.Push ? e.history.push(Q, Q.state) : T === fn.Replace && e.history.replace(Q, Q.state));
    let et;
    if (T === fn.Pop) {
      let We = L.get(b.location.pathname);
      We && We.has(Q.pathname) ? et = {
        currentLocation: b.location,
        nextLocation: Q
      } : L.has(Q.pathname) && (et = {
        currentLocation: Q,
        nextLocation: b.location
      });
    } else if (O) {
      let We = L.get(b.location.pathname);
      We ? We.add(Q.pathname) : (We = /* @__PURE__ */ new Set([Q.pathname]), L.set(b.location.pathname, We)), et = {
        currentLocation: b.location,
        nextLocation: Q
      };
    }
    Le(an({}, ee, {
      actionData: me,
      loaderData: Ee,
      historyAction: T,
      location: Q,
      initialized: !0,
      navigation: Wg,
      revalidation: "idle",
      restoreScrollPosition: Mn(Q, ee.matches || b.matches),
      preventScrollReset: xe,
      blockers: Ce
    }), {
      viewTransitionOpts: et,
      flushSync: le === !0
    }), T = fn.Pop, R = !1, O = !1, N = !1, M = !1, U = [];
  }
  async function jt(Q, ee) {
    if (typeof Q == "number") {
      e.history.go(Q);
      return;
    }
    let Y = h0(b.location, b.matches, l, d.v7_prependBasename, Q, d.v7_relativeSplatPath, ee == null ? void 0 : ee.fromRouteId, ee == null ? void 0 : ee.relative), {
      path: j,
      submission: te,
      error: le
    } = M8(d.v7_normalizeFormMethod, !1, Y, ee), ge = b.location, me = d0(b.location, j, ee && ee.state);
    me = an({}, me, e.history.encodeLocation(me));
    let Ee = ee && ee.replace != null ? ee.replace : void 0, Ce = fn.Push;
    Ee === !0 ? Ce = fn.Replace : Ee === !1 || te != null && xi(te.formMethod) && te.formAction === b.location.pathname + b.location.search && (Ce = fn.Replace);
    let xe = ee && "preventScrollReset" in ee ? ee.preventScrollReset === !0 : void 0, et = (ee && ee.unstable_flushSync) === !0, We = Di({
      currentLocation: ge,
      nextLocation: me,
      historyAction: Ce
    });
    if (We) {
      Ze(We, {
        state: "blocked",
        location: me,
        proceed() {
          Ze(We, {
            state: "proceeding",
            proceed: void 0,
            reset: void 0,
            location: me
          }), jt(Q, ee);
        },
        reset() {
          let Ke = new Map(b.blockers);
          Ke.set(We, uu), Le({
            blockers: Ke
          });
        }
      });
      return;
    }
    return await en(Ce, me, {
      submission: te,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: le,
      preventScrollReset: xe,
      replace: ee && ee.replace,
      enableViewTransition: ee && ee.unstable_viewTransition,
      flushSync: et
    });
  }
  function rn() {
    if (tn(), Le({
      revalidation: "loading"
    }), b.navigation.state !== "submitting") {
      if (b.navigation.state === "idle") {
        en(b.historyAction, b.location, {
          startUninterruptedRevalidation: !0
        });
        return;
      }
      en(T || b.historyAction, b.navigation.location, {
        overrideNavigation: b.navigation,
        // Proxy through any rending view transition
        enableViewTransition: O === !0
      });
    }
  }
  async function en(Q, ee, Y) {
    B && B.abort(), B = null, T = Q, N = (Y && Y.startUninterruptedRevalidation) === !0, lo(b.location, b.matches), R = (Y && Y.preventScrollReset) === !0, O = (Y && Y.enableViewTransition) === !0;
    let j = a || s, te = Y && Y.overrideNavigation, le = ta(j, ee, l), ge = (Y && Y.flushSync) === !0, me = ji(le, j, ee.pathname);
    if (me.active && me.matches && (le = me.matches), !le) {
      let {
        error: rt,
        notFoundMatches: Bt,
        route: Tt
      } = kn(ee.pathname);
      tt(ee, {
        matches: Bt,
        loaderData: {},
        errors: {
          [Tt.id]: rt
        }
      }, {
        flushSync: ge
      });
      return;
    }
    if (b.initialized && !M && Rse(b.location, ee) && !(Y && Y.submission && xi(Y.submission.formMethod))) {
      tt(ee, {
        matches: le
      }, {
        flushSync: ge
      });
      return;
    }
    B = new AbortController();
    let Ee = rl(e.history, ee, B.signal, Y && Y.submission), Ce;
    if (Y && Y.pendingError)
      Ce = [xl(le).route.id, {
        type: Mt.error,
        error: Y.pendingError
      }];
    else if (Y && Y.submission && xi(Y.submission.formMethod)) {
      let rt = await Gt(Ee, ee, Y.submission, le, me.active, {
        replace: Y.replace,
        flushSync: ge
      });
      if (rt.shortCircuited)
        return;
      if (rt.pendingActionResult) {
        let [Bt, Tt] = rt.pendingActionResult;
        if (_r(Tt) && Vy(Tt.error) && Tt.error.status === 404) {
          B = null, tt(ee, {
            matches: rt.matches,
            loaderData: {},
            errors: {
              [Bt]: Tt.error
            }
          });
          return;
        }
      }
      le = rt.matches || le, Ce = rt.pendingActionResult, te = Gg(ee, Y.submission), ge = !1, me.active = !1, Ee = rl(e.history, Ee.url, Ee.signal);
    }
    let {
      shortCircuited: xe,
      matches: et,
      loaderData: We,
      errors: Ke
    } = await jn(Ee, ee, le, me.active, te, Y && Y.submission, Y && Y.fetcherSubmission, Y && Y.replace, Y && Y.initialHydration === !0, ge, Ce);
    xe || (B = null, tt(ee, an({
      matches: et || le
    }, $8(Ce), {
      loaderData: We,
      errors: Ke
    })));
  }
  async function Gt(Q, ee, Y, j, te, le) {
    le === void 0 && (le = {}), tn();
    let ge = Mse(ee, Y);
    if (Le({
      navigation: ge
    }, {
      flushSync: le.flushSync === !0
    }), te) {
      let Ce = await Mi(j, ee.pathname, Q.signal);
      if (Ce.type === "aborted")
        return {
          shortCircuited: !0
        };
      if (Ce.type === "error") {
        let {
          boundaryId: xe,
          error: et
        } = hi(ee.pathname, Ce);
        return {
          matches: Ce.partialMatches,
          pendingActionResult: [xe, {
            type: Mt.error,
            error: et
          }]
        };
      } else if (Ce.matches)
        j = Ce.matches;
      else {
        let {
          notFoundMatches: xe,
          error: et,
          route: We
        } = kn(ee.pathname);
        return {
          matches: xe,
          pendingActionResult: [We.id, {
            type: Mt.error,
            error: et
          }]
        };
      }
    }
    let me, Ee = ku(j, ee);
    if (!Ee.route.action && !Ee.route.lazy)
      me = {
        type: Mt.error,
        error: or(405, {
          method: Q.method,
          pathname: ee.pathname,
          routeId: Ee.route.id
        })
      };
    else if (me = (await je("action", b, Q, [Ee], j, null))[Ee.route.id], Q.signal.aborted)
      return {
        shortCircuited: !0
      };
    if (ca(me)) {
      let Ce;
      return le && le.replace != null ? Ce = le.replace : Ce = U8(me.response.headers.get("Location"), new URL(Q.url), l) === b.location.pathname + b.location.search, await nt(Q, me, !0, {
        submission: Y,
        replace: Ce
      }), {
        shortCircuited: !0
      };
    }
    if (ms(me))
      throw or(400, {
        type: "defer-action"
      });
    if (_r(me)) {
      let Ce = xl(j, Ee.route.id);
      return (le && le.replace) !== !0 && (T = fn.Push), {
        matches: j,
        pendingActionResult: [Ce.route.id, me]
      };
    }
    return {
      matches: j,
      pendingActionResult: [Ee.route.id, me]
    };
  }
  async function jn(Q, ee, Y, j, te, le, ge, me, Ee, Ce, xe) {
    let et = te || Gg(ee, le), We = le || ge || H8(et), Ke = !N && (!d.v7_partialHydration || !Ee);
    if (j) {
      if (Ke) {
        let Ht = tr(xe);
        Le(an({
          navigation: et
        }, Ht !== void 0 ? {
          actionData: Ht
        } : {}), {
          flushSync: Ce
        });
      }
      let ft = await Mi(Y, ee.pathname, Q.signal);
      if (ft.type === "aborted")
        return {
          shortCircuited: !0
        };
      if (ft.type === "error") {
        let {
          boundaryId: Ht,
          error: nr
        } = hi(ee.pathname, ft);
        return {
          matches: ft.partialMatches,
          loaderData: {},
          errors: {
            [Ht]: nr
          }
        };
      } else if (ft.matches)
        Y = ft.matches;
      else {
        let {
          error: Ht,
          notFoundMatches: nr,
          route: Kt
        } = kn(ee.pathname);
        return {
          matches: nr,
          loaderData: {},
          errors: {
            [Kt.id]: Ht
          }
        };
      }
    }
    let rt = a || s, [Bt, Tt] = F8(e.history, b, Y, We, ee, d.v7_partialHydration && Ee === !0, d.v7_skipActionErrorRevalidation, M, U, F, ve, oe, se, rt, l, xe);
    if (so((ft) => !(Y && Y.some((Ht) => Ht.route.id === ft)) || Bt && Bt.some((Ht) => Ht.route.id === ft)), he = ++ie, Bt.length === 0 && Tt.length === 0) {
      let ft = He();
      return tt(ee, an({
        matches: Y,
        loaderData: {},
        // Commit pending error if we're short circuiting
        errors: xe && _r(xe[1]) ? {
          [xe[0]]: xe[1].error
        } : null
      }, $8(xe), ft ? {
        fetchers: new Map(b.fetchers)
      } : {}), {
        flushSync: Ce
      }), {
        shortCircuited: !0
      };
    }
    if (Ke) {
      let ft = {};
      if (!j) {
        ft.navigation = et;
        let Ht = tr(xe);
        Ht !== void 0 && (ft.actionData = Ht);
      }
      Tt.length > 0 && (ft.fetchers = Ot(Tt)), Le(ft, {
        flushSync: Ce
      });
    }
    Tt.forEach((ft) => {
      $.has(ft.key) && re(ft.key), ft.controller && $.set(ft.key, ft.controller);
    });
    let on = () => Tt.forEach((ft) => re(ft.key));
    B && B.signal.addEventListener("abort", on);
    let {
      loaderResults: Rn,
      fetcherResults: pi
    } = await st(b, Y, Bt, Tt, Q);
    if (Q.signal.aborted)
      return {
        shortCircuited: !0
      };
    B && B.signal.removeEventListener("abort", on), Tt.forEach((ft) => $.delete(ft.key));
    let Lr = Jf(Rn);
    if (Lr)
      return await nt(Q, Lr.result, !0, {
        replace: me
      }), {
        shortCircuited: !0
      };
    if (Lr = Jf(pi), Lr)
      return se.add(Lr.key), await nt(Q, Lr.result, !0, {
        replace: me
      }), {
        shortCircuited: !0
      };
    let {
      loaderData: Ka,
      errors: yi
    } = V8(b, Y, Bt, Rn, xe, Tt, pi, Be);
    Be.forEach((ft, Ht) => {
      ft.subscribe((nr) => {
        (nr || ft.done) && Be.delete(Ht);
      });
    }), d.v7_partialHydration && Ee && b.errors && Object.entries(b.errors).filter((ft) => {
      let [Ht] = ft;
      return !Bt.some((nr) => nr.route.id === Ht);
    }).forEach((ft) => {
      let [Ht, nr] = ft;
      yi = Object.assign(yi || {}, {
        [Ht]: nr
      });
    });
    let Gs = He(), Ya = xt(he), Qa = Gs || Ya || Tt.length > 0;
    return an({
      matches: Y,
      loaderData: Ka,
      errors: yi
    }, Qa ? {
      fetchers: new Map(b.fetchers)
    } : {});
  }
  function tr(Q) {
    if (Q && !_r(Q[1]))
      return {
        [Q[0]]: Q[1].data
      };
    if (b.actionData)
      return Object.keys(b.actionData).length === 0 ? null : b.actionData;
  }
  function Ot(Q) {
    return Q.forEach((ee) => {
      let Y = b.fetchers.get(ee.key), j = du(void 0, Y ? Y.data : void 0);
      b.fetchers.set(ee.key, j);
    }), new Map(b.fetchers);
  }
  function qt(Q, ee, Y, j) {
    if (r)
      throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
    $.has(Q) && re(Q);
    let te = (j && j.unstable_flushSync) === !0, le = a || s, ge = h0(b.location, b.matches, l, d.v7_prependBasename, Y, d.v7_relativeSplatPath, ee, j == null ? void 0 : j.relative), me = ta(le, ge, l), Ee = ji(me, le, ge);
    if (Ee.active && Ee.matches && (me = Ee.matches), !me) {
      E(Q, ee, or(404, {
        pathname: ge
      }), {
        flushSync: te
      });
      return;
    }
    let {
      path: Ce,
      submission: xe,
      error: et
    } = M8(d.v7_normalizeFormMethod, !0, ge, j);
    if (et) {
      E(Q, ee, et, {
        flushSync: te
      });
      return;
    }
    let We = ku(me, Ce);
    if (R = (j && j.preventScrollReset) === !0, xe && xi(xe.formMethod)) {
      Cn(Q, ee, Ce, We, me, Ee.active, te, xe);
      return;
    }
    oe.set(Q, {
      routeId: ee,
      path: Ce
    }), Ve(Q, ee, Ce, We, me, Ee.active, te, xe);
  }
  async function Cn(Q, ee, Y, j, te, le, ge, me) {
    tn(), oe.delete(Q);
    function Ee(Kt) {
      if (!Kt.route.action && !Kt.route.lazy) {
        let mi = or(405, {
          method: me.formMethod,
          pathname: Y,
          routeId: ee
        });
        return E(Q, ee, mi, {
          flushSync: ge
        }), !0;
      }
      return !1;
    }
    if (!le && Ee(j))
      return;
    let Ce = b.fetchers.get(Q);
    D(Q, Fse(me, Ce), {
      flushSync: ge
    });
    let xe = new AbortController(), et = rl(e.history, Y, xe.signal, me);
    if (le) {
      let Kt = await Mi(te, Y, et.signal);
      if (Kt.type === "aborted")
        return;
      if (Kt.type === "error") {
        let {
          error: mi
        } = hi(Y, Kt);
        E(Q, ee, mi, {
          flushSync: ge
        });
        return;
      } else if (Kt.matches) {
        if (te = Kt.matches, j = ku(te, Y), Ee(j))
          return;
      } else {
        E(Q, ee, or(404, {
          pathname: Y
        }), {
          flushSync: ge
        });
        return;
      }
    }
    $.set(Q, xe);
    let We = ie, rt = (await je("action", b, et, [j], te, Q))[j.route.id];
    if (et.signal.aborted) {
      $.get(Q) === xe && $.delete(Q);
      return;
    }
    if (d.v7_fetcherPersist && ve.has(Q)) {
      if (ca(rt) || _r(rt)) {
        D(Q, ns(void 0));
        return;
      }
    } else {
      if (ca(rt))
        if ($.delete(Q), he > We) {
          D(Q, ns(void 0));
          return;
        } else
          return se.add(Q), D(Q, du(me)), nt(et, rt, !1, {
            fetcherSubmission: me
          });
      if (_r(rt)) {
        E(Q, ee, rt.error);
        return;
      }
    }
    if (ms(rt))
      throw or(400, {
        type: "defer-action"
      });
    let Bt = b.navigation.location || b.location, Tt = rl(e.history, Bt, xe.signal), on = a || s, Rn = b.navigation.state !== "idle" ? ta(on, b.navigation.location, l) : b.matches;
    Ne(Rn, "Didn't find any matches after fetcher action");
    let pi = ++ie;
    ae.set(Q, pi);
    let Lr = du(me, rt.data);
    b.fetchers.set(Q, Lr);
    let [Ka, yi] = F8(e.history, b, Rn, me, Bt, !1, d.v7_skipActionErrorRevalidation, M, U, F, ve, oe, se, on, l, [j.route.id, rt]);
    yi.filter((Kt) => Kt.key !== Q).forEach((Kt) => {
      let mi = Kt.key, bf = b.fetchers.get(mi), pm = du(void 0, bf ? bf.data : void 0);
      b.fetchers.set(mi, pm), $.has(mi) && re(mi), Kt.controller && $.set(mi, Kt.controller);
    }), Le({
      fetchers: new Map(b.fetchers)
    });
    let Gs = () => yi.forEach((Kt) => re(Kt.key));
    xe.signal.addEventListener("abort", Gs);
    let {
      loaderResults: Ya,
      fetcherResults: Qa
    } = await st(b, Rn, Ka, yi, Tt);
    if (xe.signal.aborted)
      return;
    xe.signal.removeEventListener("abort", Gs), ae.delete(Q), $.delete(Q), yi.forEach((Kt) => $.delete(Kt.key));
    let ft = Jf(Ya);
    if (ft)
      return nt(Tt, ft.result, !1);
    if (ft = Jf(Qa), ft)
      return se.add(ft.key), nt(Tt, ft.result, !1);
    let {
      loaderData: Ht,
      errors: nr
    } = V8(b, Rn, Ka, Ya, void 0, yi, Qa, Be);
    if (b.fetchers.has(Q)) {
      let Kt = ns(rt.data);
      b.fetchers.set(Q, Kt);
    }
    xt(pi), b.navigation.state === "loading" && pi > he ? (Ne(T, "Expected pending action"), B && B.abort(), tt(b.navigation.location, {
      matches: Rn,
      loaderData: Ht,
      errors: nr,
      fetchers: new Map(b.fetchers)
    })) : (Le({
      errors: nr,
      loaderData: q8(b.loaderData, Ht, Rn, nr),
      fetchers: new Map(b.fetchers)
    }), M = !1);
  }
  async function Ve(Q, ee, Y, j, te, le, ge, me) {
    let Ee = b.fetchers.get(Q);
    D(Q, du(me, Ee ? Ee.data : void 0), {
      flushSync: ge
    });
    let Ce = new AbortController(), xe = rl(e.history, Y, Ce.signal);
    if (le) {
      let rt = await Mi(te, Y, xe.signal);
      if (rt.type === "aborted")
        return;
      if (rt.type === "error") {
        let {
          error: Bt
        } = hi(Y, rt);
        E(Q, ee, Bt, {
          flushSync: ge
        });
        return;
      } else if (rt.matches)
        te = rt.matches, j = ku(te, Y);
      else {
        E(Q, ee, or(404, {
          pathname: Y
        }), {
          flushSync: ge
        });
        return;
      }
    }
    $.set(Q, Ce);
    let et = ie, Ke = (await je("loader", b, xe, [j], te, Q))[j.route.id];
    if (ms(Ke) && (Ke = await J1(Ke, xe.signal, !0) || Ke), $.get(Q) === Ce && $.delete(Q), !xe.signal.aborted) {
      if (ve.has(Q)) {
        D(Q, ns(void 0));
        return;
      }
      if (ca(Ke))
        if (he > et) {
          D(Q, ns(void 0));
          return;
        } else {
          se.add(Q), await nt(xe, Ke, !1);
          return;
        }
      if (_r(Ke)) {
        E(Q, ee, Ke.error);
        return;
      }
      Ne(!ms(Ke), "Unhandled fetcher deferred data"), D(Q, ns(Ke.data));
    }
  }
  async function nt(Q, ee, Y, j) {
    let {
      submission: te,
      fetcherSubmission: le,
      replace: ge
    } = j === void 0 ? {} : j;
    ee.response.headers.has("X-Remix-Revalidate") && (M = !0);
    let me = ee.response.headers.get("Location");
    Ne(me, "Expected a Location header on the redirect Response"), me = U8(me, new URL(Q.url), l);
    let Ee = d0(b.location, me, {
      _isRedirect: !0
    });
    if (n) {
      let rt = !1;
      if (ee.response.headers.has("X-Remix-Reload-Document"))
        rt = !0;
      else if (Q1.test(me)) {
        const Bt = e.history.createURL(me);
        rt = // Hard reload if it's an absolute URL to a new origin
        Bt.origin !== t.location.origin || // Hard reload if it's an absolute URL that does not match our basename
        Ti(Bt.pathname, l) == null;
      }
      if (rt) {
        ge ? t.location.replace(me) : t.location.assign(me);
        return;
      }
    }
    B = null;
    let Ce = ge === !0 || ee.response.headers.has("X-Remix-Replace") ? fn.Replace : fn.Push, {
      formMethod: xe,
      formAction: et,
      formEncType: We
    } = b.navigation;
    !te && !le && xe && et && We && (te = H8(b.navigation));
    let Ke = te || le;
    if (yse.has(ee.response.status) && Ke && xi(Ke.formMethod))
      await en(Ce, Ee, {
        submission: an({}, Ke, {
          formAction: me
        }),
        // Preserve these flags across redirects
        preventScrollReset: R,
        enableViewTransition: Y ? O : void 0
      });
    else {
      let rt = Gg(Ee, te);
      await en(Ce, Ee, {
        overrideNavigation: rt,
        // Send fetcher submissions through for shouldRevalidate
        fetcherSubmission: le,
        // Preserve these flags across redirects
        preventScrollReset: R,
        enableViewTransition: Y ? O : void 0
      });
    }
  }
  async function je(Q, ee, Y, j, te, le) {
    let ge, me = {};
    try {
      ge = await Sse(c, Q, ee, Y, j, te, le, o, i);
    } catch (Ee) {
      return j.forEach((Ce) => {
        me[Ce.route.id] = {
          type: Mt.error,
          error: Ee
        };
      }), me;
    }
    for (let [Ee, Ce] of Object.entries(ge))
      if (Ose(Ce)) {
        let xe = Ce.result;
        me[Ee] = {
          type: Mt.redirect,
          response: _se(xe, Y, Ee, te, l, d.v7_relativeSplatPath)
        };
      } else
        me[Ee] = await Tse(Ce);
    return me;
  }
  async function st(Q, ee, Y, j, te) {
    let le = Q.matches, ge = je("loader", Q, te, Y, ee, null), me = Promise.all(j.map(async (xe) => {
      if (xe.matches && xe.match && xe.controller) {
        let We = (await je("loader", Q, rl(e.history, xe.path, xe.controller.signal), [xe.match], xe.matches, xe.key))[xe.match.route.id];
        return {
          [xe.key]: We
        };
      } else
        return Promise.resolve({
          [xe.key]: {
            type: Mt.error,
            error: or(404, {
              pathname: xe.path
            })
          }
        });
    })), Ee = await ge, Ce = (await me).reduce((xe, et) => Object.assign(xe, et), {});
    return await Promise.all([Dse(ee, Ee, te.signal, le, Q.loaderData), jse(ee, Ce, j)]), {
      loaderResults: Ee,
      fetcherResults: Ce
    };
  }
  function tn() {
    M = !0, U.push(...so()), oe.forEach((Q, ee) => {
      $.has(ee) && (F.add(ee), re(ee));
    });
  }
  function D(Q, ee, Y) {
    Y === void 0 && (Y = {}), b.fetchers.set(Q, ee), Le({
      fetchers: new Map(b.fetchers)
    }, {
      flushSync: (Y && Y.flushSync) === !0
    });
  }
  function E(Q, ee, Y, j) {
    j === void 0 && (j = {});
    let te = xl(b.matches, ee);
    q(Q), Le({
      errors: {
        [te.route.id]: Y
      },
      fetchers: new Map(b.fetchers)
    }, {
      flushSync: (j && j.flushSync) === !0
    });
  }
  function _(Q) {
    return d.v7_fetcherPersist && (ye.set(Q, (ye.get(Q) || 0) + 1), ve.has(Q) && ve.delete(Q)), b.fetchers.get(Q) || mse;
  }
  function q(Q) {
    let ee = b.fetchers.get(Q);
    $.has(Q) && !(ee && ee.state === "loading" && ae.has(Q)) && re(Q), oe.delete(Q), ae.delete(Q), se.delete(Q), ve.delete(Q), F.delete(Q), b.fetchers.delete(Q);
  }
  function Z(Q) {
    if (d.v7_fetcherPersist) {
      let ee = (ye.get(Q) || 0) - 1;
      ee <= 0 ? (ye.delete(Q), ve.add(Q)) : ye.set(Q, ee);
    } else
      q(Q);
    Le({
      fetchers: new Map(b.fetchers)
    });
  }
  function re(Q) {
    let ee = $.get(Q);
    Ne(ee, "Expected fetch controller: " + Q), ee.abort(), $.delete(Q);
  }
  function pe(Q) {
    for (let ee of Q) {
      let Y = _(ee), j = ns(Y.data);
      b.fetchers.set(ee, j);
    }
  }
  function He() {
    let Q = [], ee = !1;
    for (let Y of se) {
      let j = b.fetchers.get(Y);
      Ne(j, "Expected fetcher: " + Y), j.state === "loading" && (se.delete(Y), Q.push(Y), ee = !0);
    }
    return pe(Q), ee;
  }
  function xt(Q) {
    let ee = [];
    for (let [Y, j] of ae)
      if (j < Q) {
        let te = b.fetchers.get(Y);
        Ne(te, "Expected fetcher: " + Y), te.state === "loading" && (re(Y), ae.delete(Y), ee.push(Y));
      }
    return pe(ee), ee.length > 0;
  }
  function St(Q, ee) {
    let Y = b.blockers.get(Q) || uu;
    return it.get(Q) !== ee && it.set(Q, ee), Y;
  }
  function Ct(Q) {
    b.blockers.delete(Q), it.delete(Q);
  }
  function Ze(Q, ee) {
    let Y = b.blockers.get(Q) || uu;
    Ne(Y.state === "unblocked" && ee.state === "blocked" || Y.state === "blocked" && ee.state === "blocked" || Y.state === "blocked" && ee.state === "proceeding" || Y.state === "blocked" && ee.state === "unblocked" || Y.state === "proceeding" && ee.state === "unblocked", "Invalid blocker state transition: " + Y.state + " -> " + ee.state);
    let j = new Map(b.blockers);
    j.set(Q, ee), Le({
      blockers: j
    });
  }
  function Di(Q) {
    let {
      currentLocation: ee,
      nextLocation: Y,
      historyAction: j
    } = Q;
    if (it.size === 0)
      return;
    it.size > 1 && gn(!1, "A router only supports one blocker at a time");
    let te = Array.from(it.entries()), [le, ge] = te[te.length - 1], me = b.blockers.get(le);
    if (!(me && me.state === "proceeding") && ge({
      currentLocation: ee,
      nextLocation: Y,
      historyAction: j
    }))
      return le;
  }
  function kn(Q) {
    let ee = or(404, {
      pathname: Q
    }), Y = a || s, {
      matches: j,
      route: te
    } = W8(Y);
    return so(), {
      notFoundMatches: j,
      route: te,
      error: ee
    };
  }
  function hi(Q, ee) {
    return {
      boundaryId: xl(ee.partialMatches).route.id,
      error: or(400, {
        type: "route-discovery",
        pathname: Q,
        message: ee.error != null && "message" in ee.error ? ee.error : String(ee.error)
      })
    };
  }
  function so(Q) {
    let ee = [];
    return Be.forEach((Y, j) => {
      (!Q || Q(j)) && (Y.cancel(), ee.push(j), Be.delete(j));
    }), ee;
  }
  function ao(Q, ee, Y) {
    if (g = Q, w = ee, v = Y || null, !x && b.navigation === Wg) {
      x = !0;
      let j = Mn(b.location, b.matches);
      j != null && Le({
        restoreScrollPosition: j
      });
    }
    return () => {
      g = null, w = null, v = null;
    };
  }
  function Go(Q, ee) {
    return v && v(Q, ee.map((j) => Koe(j, b.loaderData))) || Q.key;
  }
  function lo(Q, ee) {
    if (g && w) {
      let Y = Go(Q, ee);
      g[Y] = w();
    }
  }
  function Mn(Q, ee) {
    if (g) {
      let Y = Go(Q, ee), j = g[Y];
      if (typeof j == "number")
        return j;
    }
    return null;
  }
  function ji(Q, ee, Y) {
    if (u) {
      if (m.has(Y))
        return {
          active: !1,
          matches: Q
        };
      if (Q) {
        if (Object.keys(Q[0].params).length > 0)
          return {
            active: !0,
            matches: Sh(ee, Y, l, !0)
          };
      } else
        return {
          active: !0,
          matches: Sh(ee, Y, l, !0) || []
        };
    }
    return {
      active: !1,
      matches: null
    };
  }
  async function Mi(Q, ee, Y) {
    let j = Q;
    for (; ; ) {
      let te = a == null, le = a || s;
      try {
        await Cse(u, ee, j, le, o, i, lt, Y);
      } catch (Ee) {
        return {
          type: "error",
          error: Ee,
          partialMatches: j
        };
      } finally {
        te && (s = [...s]);
      }
      if (Y.aborted)
        return {
          type: "aborted"
        };
      let ge = ta(le, ee, l);
      if (ge)
        return co(ee, m), {
          type: "success",
          matches: ge
        };
      let me = Sh(le, ee, l, !0);
      if (!me || j.length === me.length && j.every((Ee, Ce) => Ee.route.id === me[Ce].route.id))
        return co(ee, m), {
          type: "success",
          matches: null
        };
      j = me;
    }
  }
  function co(Q, ee) {
    if (ee.size >= p) {
      let Y = ee.values().next().value;
      ee.delete(Y);
    }
    ee.add(Q);
  }
  function Ho(Q) {
    o = {}, a = yd(Q, i, void 0, o);
  }
  function Ws(Q, ee) {
    let Y = a == null;
    OO(Q, ee, a || s, o, i), Y && (s = [...s], Le({}));
  }
  return A = {
    get basename() {
      return l;
    },
    get future() {
      return d;
    },
    get state() {
      return b;
    },
    get routes() {
      return s;
    },
    get window() {
      return t;
    },
    initialize: gt,
    subscribe: ot,
    enableScrollRestoration: ao,
    navigate: jt,
    fetch: qt,
    revalidate: rn,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: (Q) => e.history.createHref(Q),
    encodeLocation: (Q) => e.history.encodeLocation(Q),
    getFetcher: _,
    deleteFetcher: Z,
    dispose: vt,
    getBlocker: St,
    deleteBlocker: Ct,
    patchRoutes: Ws,
    _internalFetchControllers: $,
    _internalActiveDeferreds: Be,
    // TODO: Remove setRoutes, it's temporary to avoid dealing with
    // updating the tree while validating the update algorithm.
    _internalSetRoutes: Ho
  }, A;
}
function bse(e) {
  return e != null && ("formData" in e && e.formData != null || "body" in e && e.body !== void 0);
}
function h0(e, t, n, r, i, o, s, a) {
  let l, c;
  if (s) {
    l = [];
    for (let d of t)
      if (l.push(d), d.route.id === s) {
        c = d;
        break;
      }
  } else
    l = t, c = t[t.length - 1];
  let u = zy(i || ".", Uy(l, o), Ti(e.pathname, n) || e.pathname, a === "path");
  return i == null && (u.search = e.search, u.hash = e.hash), (i == null || i === "" || i === ".") && c && c.route.index && !X1(u.search) && (u.search = u.search ? u.search.replace(/^\?/, "?index&") : "?index"), r && n !== "/" && (u.pathname = u.pathname === "/" ? n : Qi([n, u.pathname])), Ba(u);
}
function M8(e, t, n, r) {
  if (!r || !bse(r))
    return {
      path: n
    };
  if (r.formMethod && !Nse(r.formMethod))
    return {
      path: n,
      error: or(405, {
        method: r.formMethod
      })
    };
  let i = () => ({
    path: n,
    error: or(400, {
      type: "invalid-body"
    })
  }), o = r.formMethod || "get", s = e ? o.toUpperCase() : o.toLowerCase(), a = BO(n);
  if (r.body !== void 0) {
    if (r.formEncType === "text/plain") {
      if (!xi(s))
        return i();
      let f = typeof r.body == "string" ? r.body : r.body instanceof FormData || r.body instanceof URLSearchParams ? (
        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
        Array.from(r.body.entries()).reduce((h, p) => {
          let [m, g] = p;
          return "" + h + m + "=" + g + `
`;
        }, "")
      ) : String(r.body);
      return {
        path: n,
        submission: {
          formMethod: s,
          formAction: a,
          formEncType: r.formEncType,
          formData: void 0,
          json: void 0,
          text: f
        }
      };
    } else if (r.formEncType === "application/json") {
      if (!xi(s))
        return i();
      try {
        let f = typeof r.body == "string" ? JSON.parse(r.body) : r.body;
        return {
          path: n,
          submission: {
            formMethod: s,
            formAction: a,
            formEncType: r.formEncType,
            formData: void 0,
            json: f,
            text: void 0
          }
        };
      } catch {
        return i();
      }
    }
  }
  Ne(typeof FormData == "function", "FormData is not available in this environment");
  let l, c;
  if (r.formData)
    l = p0(r.formData), c = r.formData;
  else if (r.body instanceof FormData)
    l = p0(r.body), c = r.body;
  else if (r.body instanceof URLSearchParams)
    l = r.body, c = z8(l);
  else if (r.body == null)
    l = new URLSearchParams(), c = new FormData();
  else
    try {
      l = new URLSearchParams(r.body), c = z8(l);
    } catch {
      return i();
    }
  let u = {
    formMethod: s,
    formAction: a,
    formEncType: r && r.formEncType || "application/x-www-form-urlencoded",
    formData: c,
    json: void 0,
    text: void 0
  };
  if (xi(u.formMethod))
    return {
      path: n,
      submission: u
    };
  let d = oo(n);
  return t && d.search && X1(d.search) && l.append("index", ""), d.search = "?" + l, {
    path: Ba(d),
    submission: u
  };
}
function wse(e, t) {
  let n = e;
  if (t) {
    let r = e.findIndex((i) => i.route.id === t);
    r >= 0 && (n = e.slice(0, r));
  }
  return n;
}
function F8(e, t, n, r, i, o, s, a, l, c, u, d, f, h, p, m) {
  let g = m ? _r(m[1]) ? m[1].error : m[1].data : void 0, v = e.createURL(t.location), w = e.createURL(i), x = m && _r(m[1]) ? m[0] : void 0, C = x ? wse(n, x) : n, S = m ? m[1].statusCode : void 0, k = s && S && S >= 400, A = C.filter((T, R) => {
    let {
      route: B
    } = T;
    if (B.lazy)
      return !0;
    if (B.loader == null)
      return !1;
    if (o)
      return typeof B.loader != "function" || B.loader.hydrate ? !0 : t.loaderData[B.id] === void 0 && // Don't re-run if the loader ran and threw an error
      (!t.errors || t.errors[B.id] === void 0);
    if (xse(t.loaderData, t.matches[R], T) || l.some((V) => V === T.route.id))
      return !0;
    let O = t.matches[R], L = T;
    return L8(T, an({
      currentUrl: v,
      currentParams: O.params,
      nextUrl: w,
      nextParams: L.params
    }, r, {
      actionResult: g,
      actionStatus: S,
      defaultShouldRevalidate: k ? !1 : (
        // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
        a || v.pathname + v.search === w.pathname + w.search || // Search params affect all loaders
        v.search !== w.search || PO(O, L)
      )
    }));
  }), b = [];
  return d.forEach((T, R) => {
    if (o || !n.some((N) => N.route.id === T.routeId) || u.has(R))
      return;
    let B = ta(h, T.path, p);
    if (!B) {
      b.push({
        key: R,
        routeId: T.routeId,
        path: T.path,
        matches: null,
        match: null,
        controller: null
      });
      return;
    }
    let O = t.fetchers.get(R), L = ku(B, T.path), V = !1;
    f.has(R) ? V = !1 : c.has(R) ? (c.delete(R), V = !0) : O && O.state !== "idle" && O.data === void 0 ? V = a : V = L8(L, an({
      currentUrl: v,
      currentParams: t.matches[t.matches.length - 1].params,
      nextUrl: w,
      nextParams: n[n.length - 1].params
    }, r, {
      actionResult: g,
      actionStatus: S,
      defaultShouldRevalidate: k ? !1 : a
    })), V && b.push({
      key: R,
      routeId: T.routeId,
      path: T.path,
      matches: B,
      match: L,
      controller: new AbortController()
    });
  }), [A, b];
}
function xse(e, t, n) {
  let r = (
    // [a] -> [a, b]
    !t || // [a, b] -> [a, c]
    n.route.id !== t.route.id
  ), i = e[n.route.id] === void 0;
  return r || i;
}
function PO(e, t) {
  let n = e.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    e.pathname !== t.pathname || // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    n != null && n.endsWith("*") && e.params["*"] !== t.params["*"]
  );
}
function L8(e, t) {
  if (e.route.shouldRevalidate) {
    let n = e.route.shouldRevalidate(t);
    if (typeof n == "boolean")
      return n;
  }
  return t.defaultShouldRevalidate;
}
async function Cse(e, t, n, r, i, o, s, a) {
  let l = [t, ...n.map((c) => c.route.id)].join("-");
  try {
    let c = s.get(l);
    c || (c = e({
      path: t,
      matches: n,
      patch: (u, d) => {
        a.aborted || OO(u, d, r, i, o);
      }
    }), s.set(l, c)), c && Pse(c) && await c;
  } finally {
    s.delete(l);
  }
}
function OO(e, t, n, r, i) {
  if (e) {
    var o;
    let s = r[e];
    Ne(s, "No route found to patch children into: routeId = " + e);
    let a = yd(t, i, [e, "patch", String(((o = s.children) == null ? void 0 : o.length) || "0")], r);
    s.children ? s.children.push(...a) : s.children = a;
  } else {
    let s = yd(t, i, ["patch", String(n.length || "0")], r);
    n.push(...s);
  }
}
async function kse(e, t, n) {
  if (!e.lazy)
    return;
  let r = await e.lazy();
  if (!e.lazy)
    return;
  let i = n[e.id];
  Ne(i, "No route found in manifest");
  let o = {};
  for (let s in r) {
    let l = i[s] !== void 0 && // This property isn't static since it should always be updated based
    // on the route updates
    s !== "hasErrorBoundary";
    gn(!l, 'Route "' + i.id + '" has a static property "' + s + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + s + '" will be ignored.')), !l && !Goe.has(s) && (o[s] = r[s]);
  }
  Object.assign(i, o), Object.assign(i, an({}, t(i), {
    lazy: void 0
  }));
}
async function Ese(e) {
  let {
    matches: t
  } = e, n = t.filter((i) => i.shouldLoad);
  return (await Promise.all(n.map((i) => i.resolve()))).reduce((i, o, s) => Object.assign(i, {
    [n[s].route.id]: o
  }), {});
}
async function Sse(e, t, n, r, i, o, s, a, l, c) {
  let u = o.map((h) => h.route.lazy ? kse(h.route, l, a) : void 0), d = o.map((h, p) => {
    let m = u[p], g = i.some((w) => w.route.id === h.route.id);
    return an({}, h, {
      shouldLoad: g,
      resolve: async (w) => (w && r.method === "GET" && (h.route.lazy || h.route.loader) && (g = !0), g ? Ase(t, r, h, m, w, c) : Promise.resolve({
        type: Mt.data,
        result: void 0
      }))
    });
  }), f = await e({
    matches: d,
    request: r,
    params: o[0].params,
    fetcherKey: s,
    context: c
  });
  try {
    await Promise.all(u);
  } catch {
  }
  return f;
}
async function Ase(e, t, n, r, i, o) {
  let s, a, l = (c) => {
    let u, d = new Promise((p, m) => u = m);
    a = () => u(), t.signal.addEventListener("abort", a);
    let f = (p) => typeof c != "function" ? Promise.reject(new Error("You cannot call the handler for a route which defines a boolean " + ('"' + e + '" [routeId: ' + n.route.id + "]"))) : c({
      request: t,
      params: n.params,
      context: o
    }, ...p !== void 0 ? [p] : []), h = (async () => {
      try {
        return {
          type: "data",
          result: await (i ? i((m) => f(m)) : f())
        };
      } catch (p) {
        return {
          type: "error",
          result: p
        };
      }
    })();
    return Promise.race([h, d]);
  };
  try {
    let c = n.route[e];
    if (r)
      if (c) {
        let u, [d] = await Promise.all([
          // If the handler throws, don't let it immediately bubble out,
          // since we need to let the lazy() execution finish so we know if this
          // route has a boundary that can handle the error
          l(c).catch((f) => {
            u = f;
          }),
          r
        ]);
        if (u !== void 0)
          throw u;
        s = d;
      } else if (await r, c = n.route[e], c)
        s = await l(c);
      else if (e === "action") {
        let u = new URL(t.url), d = u.pathname + u.search;
        throw or(405, {
          method: t.method,
          pathname: d,
          routeId: n.route.id
        });
      } else
        return {
          type: Mt.data,
          result: void 0
        };
    else if (c)
      s = await l(c);
    else {
      let u = new URL(t.url), d = u.pathname + u.search;
      throw or(404, {
        pathname: d
      });
    }
    Ne(s.result !== void 0, "You defined " + (e === "action" ? "an action" : "a loader") + " for route " + ('"' + n.route.id + "\" but didn't return anything from your `" + e + "` ") + "function. Please return a value or `null`.");
  } catch (c) {
    return {
      type: Mt.error,
      result: c
    };
  } finally {
    a && t.signal.removeEventListener("abort", a);
  }
  return s;
}
async function Tse(e) {
  let {
    result: t,
    type: n
  } = e;
  if (NO(t)) {
    let c;
    try {
      let u = t.headers.get("Content-Type");
      u && /\bapplication\/json\b/.test(u) ? t.body == null ? c = null : c = await t.json() : c = await t.text();
    } catch (u) {
      return {
        type: Mt.error,
        error: u
      };
    }
    return n === Mt.error ? {
      type: Mt.error,
      error: new f0(t.status, t.statusText, c),
      statusCode: t.status,
      headers: t.headers
    } : {
      type: Mt.data,
      data: c,
      statusCode: t.status,
      headers: t.headers
    };
  }
  if (n === Mt.error) {
    if (G8(t)) {
      var r;
      if (t.data instanceof Error) {
        var i;
        return {
          type: Mt.error,
          error: t.data,
          statusCode: (i = t.init) == null ? void 0 : i.status
        };
      }
      t = new f0(((r = t.init) == null ? void 0 : r.status) || 500, void 0, t.data);
    }
    return {
      type: Mt.error,
      error: t,
      statusCode: Vy(t) ? t.status : void 0
    };
  }
  if (Bse(t)) {
    var o, s;
    return {
      type: Mt.deferred,
      deferredData: t,
      statusCode: (o = t.init) == null ? void 0 : o.status,
      headers: ((s = t.init) == null ? void 0 : s.headers) && new Headers(t.init.headers)
    };
  }
  if (G8(t)) {
    var a, l;
    return {
      type: Mt.data,
      data: t.data,
      statusCode: (a = t.init) == null ? void 0 : a.status,
      headers: (l = t.init) != null && l.headers ? new Headers(t.init.headers) : void 0
    };
  }
  return {
    type: Mt.data,
    data: t
  };
}
function _se(e, t, n, r, i, o) {
  let s = e.headers.get("Location");
  if (Ne(s, "Redirects returned/thrown from loaders/actions must have a Location header"), !Q1.test(s)) {
    let a = r.slice(0, r.findIndex((l) => l.route.id === n) + 1);
    s = h0(new URL(t.url), a, i, !0, s, o), e.headers.set("Location", s);
  }
  return e;
}
function U8(e, t, n) {
  if (Q1.test(e)) {
    let r = e, i = r.startsWith("//") ? new URL(t.protocol + r) : new URL(r), o = Ti(i.pathname, n) != null;
    if (i.origin === t.origin && o)
      return i.pathname + i.search + i.hash;
  }
  return e;
}
function rl(e, t, n, r) {
  let i = e.createURL(BO(t)).toString(), o = {
    signal: n
  };
  if (r && xi(r.formMethod)) {
    let {
      formMethod: s,
      formEncType: a
    } = r;
    o.method = s.toUpperCase(), a === "application/json" ? (o.headers = new Headers({
      "Content-Type": a
    }), o.body = JSON.stringify(r.json)) : a === "text/plain" ? o.body = r.text : a === "application/x-www-form-urlencoded" && r.formData ? o.body = p0(r.formData) : o.body = r.formData;
  }
  return new Request(i, o);
}
function p0(e) {
  let t = new URLSearchParams();
  for (let [n, r] of e.entries())
    t.append(n, typeof r == "string" ? r : r.name);
  return t;
}
function z8(e) {
  let t = new FormData();
  for (let [n, r] of e.entries())
    t.append(n, r);
  return t;
}
function Ise(e, t, n, r, i) {
  let o = {}, s = null, a, l = !1, c = {}, u = n && _r(n[1]) ? n[1].error : void 0;
  return e.forEach((d) => {
    if (!(d.route.id in t))
      return;
    let f = d.route.id, h = t[f];
    if (Ne(!ca(h), "Cannot handle redirect results in processLoaderData"), _r(h)) {
      let p = h.error;
      u !== void 0 && (p = u, u = void 0), s = s || {};
      {
        let m = xl(e, f);
        s[m.route.id] == null && (s[m.route.id] = p);
      }
      o[f] = void 0, l || (l = !0, a = Vy(h.error) ? h.error.status : 500), h.headers && (c[f] = h.headers);
    } else
      ms(h) ? (r.set(f, h.deferredData), o[f] = h.deferredData.data, h.statusCode != null && h.statusCode !== 200 && !l && (a = h.statusCode), h.headers && (c[f] = h.headers)) : (o[f] = h.data, h.statusCode && h.statusCode !== 200 && !l && (a = h.statusCode), h.headers && (c[f] = h.headers));
  }), u !== void 0 && n && (s = {
    [n[0]]: u
  }, o[n[0]] = void 0), {
    loaderData: o,
    errors: s,
    statusCode: a || 200,
    loaderHeaders: c
  };
}
function V8(e, t, n, r, i, o, s, a) {
  let {
    loaderData: l,
    errors: c
  } = Ise(t, r, i, a);
  return o.forEach((u) => {
    let {
      key: d,
      match: f,
      controller: h
    } = u, p = s[d];
    if (Ne(p, "Did not find corresponding fetcher result"), !(h && h.signal.aborted))
      if (_r(p)) {
        let m = xl(e.matches, f == null ? void 0 : f.route.id);
        c && c[m.route.id] || (c = an({}, c, {
          [m.route.id]: p.error
        })), e.fetchers.delete(d);
      } else if (ca(p))
        Ne(!1, "Unhandled fetcher revalidation redirect");
      else if (ms(p))
        Ne(!1, "Unhandled fetcher deferred data");
      else {
        let m = ns(p.data);
        e.fetchers.set(d, m);
      }
  }), {
    loaderData: l,
    errors: c
  };
}
function q8(e, t, n, r) {
  let i = an({}, t);
  for (let o of n) {
    let s = o.route.id;
    if (t.hasOwnProperty(s) ? t[s] !== void 0 && (i[s] = t[s]) : e[s] !== void 0 && o.route.loader && (i[s] = e[s]), r && r.hasOwnProperty(s))
      break;
  }
  return i;
}
function $8(e) {
  return e ? _r(e[1]) ? {
    // Clear out prior actionData on errors
    actionData: {}
  } : {
    actionData: {
      [e[0]]: e[1].data
    }
  } : {};
}
function xl(e, t) {
  return (t ? e.slice(0, e.findIndex((r) => r.route.id === t) + 1) : [...e]).reverse().find((r) => r.route.hasErrorBoundary === !0) || e[0];
}
function W8(e) {
  let t = e.length === 1 ? e[0] : e.find((n) => n.index || !n.path || n.path === "/") || {
    id: "__shim-error-route__"
  };
  return {
    matches: [{
      params: {},
      pathname: "",
      pathnameBase: "",
      route: t
    }],
    route: t
  };
}
function or(e, t) {
  let {
    pathname: n,
    routeId: r,
    method: i,
    type: o,
    message: s
  } = t === void 0 ? {} : t, a = "Unknown Server Error", l = "Unknown @remix-run/router error";
  return e === 400 ? (a = "Bad Request", o === "route-discovery" ? l = 'Unable to match URL "' + n + '" - the `unstable_patchRoutesOnNavigation()` ' + (`function threw the following error:
` + s) : i && n && r ? l = "You made a " + i + ' request to "' + n + '" but ' + ('did not provide a `loader` for route "' + r + '", ') + "so there is no way to handle the request." : o === "defer-action" ? l = "defer() is not supported in actions" : o === "invalid-body" && (l = "Unable to encode submission body")) : e === 403 ? (a = "Forbidden", l = 'Route "' + r + '" does not match URL "' + n + '"') : e === 404 ? (a = "Not Found", l = 'No route matches URL "' + n + '"') : e === 405 && (a = "Method Not Allowed", i && n && r ? l = "You made a " + i.toUpperCase() + ' request to "' + n + '" but ' + ('did not provide an `action` for route "' + r + '", ') + "so there is no way to handle the request." : i && (l = 'Invalid request method "' + i.toUpperCase() + '"')), new f0(e || 500, a, new Error(l), !0);
}
function Jf(e) {
  let t = Object.entries(e);
  for (let n = t.length - 1; n >= 0; n--) {
    let [r, i] = t[n];
    if (ca(i))
      return {
        key: r,
        result: i
      };
  }
}
function BO(e) {
  let t = typeof e == "string" ? oo(e) : e;
  return Ba(an({}, t, {
    hash: ""
  }));
}
function Rse(e, t) {
  return e.pathname !== t.pathname || e.search !== t.search ? !1 : e.hash === "" ? t.hash !== "" : e.hash === t.hash ? !0 : t.hash !== "";
}
function Pse(e) {
  return typeof e == "object" && e != null && "then" in e;
}
function Ose(e) {
  return NO(e.result) && pse.has(e.result.status);
}
function ms(e) {
  return e.type === Mt.deferred;
}
function _r(e) {
  return e.type === Mt.error;
}
function ca(e) {
  return (e && e.type) === Mt.redirect;
}
function G8(e) {
  return typeof e == "object" && e != null && "type" in e && "data" in e && "init" in e && e.type === "DataWithResponseInit";
}
function Bse(e) {
  let t = e;
  return t && typeof t == "object" && typeof t.data == "object" && typeof t.subscribe == "function" && typeof t.cancel == "function" && typeof t.resolveData == "function";
}
function NO(e) {
  return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.headers == "object" && typeof e.body < "u";
}
function Nse(e) {
  return hse.has(e.toLowerCase());
}
function xi(e) {
  return dse.has(e.toLowerCase());
}
async function Dse(e, t, n, r, i) {
  let o = Object.entries(t);
  for (let s = 0; s < o.length; s++) {
    let [a, l] = o[s], c = e.find((f) => (f == null ? void 0 : f.route.id) === a);
    if (!c)
      continue;
    let u = r.find((f) => f.route.id === c.route.id), d = u != null && !PO(u, c) && (i && i[c.route.id]) !== void 0;
    ms(l) && d && await J1(l, n, !1).then((f) => {
      f && (t[a] = f);
    });
  }
}
async function jse(e, t, n) {
  for (let r = 0; r < n.length; r++) {
    let {
      key: i,
      routeId: o,
      controller: s
    } = n[r], a = t[i];
    e.find((c) => (c == null ? void 0 : c.route.id) === o) && ms(a) && (Ne(s, "Expected an AbortController for revalidating fetcher deferred result"), await J1(a, s.signal, !0).then((c) => {
      c && (t[i] = c);
    }));
  }
}
async function J1(e, t, n) {
  if (n === void 0 && (n = !1), !await e.deferredData.resolveData(t)) {
    if (n)
      try {
        return {
          type: Mt.data,
          data: e.deferredData.unwrappedData
        };
      } catch (i) {
        return {
          type: Mt.error,
          error: i
        };
      }
    return {
      type: Mt.data,
      data: e.deferredData.data
    };
  }
}
function X1(e) {
  return new URLSearchParams(e).getAll("index").some((t) => t === "");
}
function ku(e, t) {
  let n = typeof t == "string" ? oo(t).search : t.search;
  if (e[e.length - 1].route.index && X1(n || ""))
    return e[e.length - 1];
  let r = _O(e);
  return r[r.length - 1];
}
function H8(e) {
  let {
    formMethod: t,
    formAction: n,
    formEncType: r,
    text: i,
    formData: o,
    json: s
  } = e;
  if (!(!t || !n || !r)) {
    if (i != null)
      return {
        formMethod: t,
        formAction: n,
        formEncType: r,
        formData: void 0,
        json: void 0,
        text: i
      };
    if (o != null)
      return {
        formMethod: t,
        formAction: n,
        formEncType: r,
        formData: o,
        json: void 0,
        text: void 0
      };
    if (s !== void 0)
      return {
        formMethod: t,
        formAction: n,
        formEncType: r,
        formData: void 0,
        json: s,
        text: void 0
      };
  }
}
function Gg(e, t) {
  return t ? {
    state: "loading",
    location: e,
    formMethod: t.formMethod,
    formAction: t.formAction,
    formEncType: t.formEncType,
    formData: t.formData,
    json: t.json,
    text: t.text
  } : {
    state: "loading",
    location: e,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
  };
}
function Mse(e, t) {
  return {
    state: "submitting",
    location: e,
    formMethod: t.formMethod,
    formAction: t.formAction,
    formEncType: t.formEncType,
    formData: t.formData,
    json: t.json,
    text: t.text
  };
}
function du(e, t) {
  return e ? {
    state: "loading",
    formMethod: e.formMethod,
    formAction: e.formAction,
    formEncType: e.formEncType,
    formData: e.formData,
    json: e.json,
    text: e.text,
    data: t
  } : {
    state: "loading",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data: t
  };
}
function Fse(e, t) {
  return {
    state: "submitting",
    formMethod: e.formMethod,
    formAction: e.formAction,
    formEncType: e.formEncType,
    formData: e.formData,
    json: e.json,
    text: e.text,
    data: t ? t.data : void 0
  };
}
function ns(e) {
  return {
    state: "idle",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data: e
  };
}
function Lse(e, t) {
  try {
    let n = e.sessionStorage.getItem(RO);
    if (n) {
      let r = JSON.parse(n);
      for (let [i, o] of Object.entries(r || {}))
        o && Array.isArray(o) && t.set(i, new Set(o || []));
    }
  } catch {
  }
}
function Use(e, t) {
  if (t.size > 0) {
    let n = {};
    for (let [r, i] of t)
      n[r] = [...i];
    try {
      e.sessionStorage.setItem(RO, JSON.stringify(n));
    } catch (r) {
      gn(!1, "Failed to save applied view transitions in sessionStorage (" + r + ").");
    }
  }
}
function hc() {
  return hc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, hc.apply(this, arguments);
}
const Wc = /* @__PURE__ */ P.createContext(null);
ke.env.NODE_ENV !== "production" && (Wc.displayName = "DataRouter");
const qy = /* @__PURE__ */ P.createContext(null);
ke.env.NODE_ENV !== "production" && (qy.displayName = "DataRouterState");
const zse = /* @__PURE__ */ P.createContext(null);
ke.env.NODE_ENV !== "production" && (zse.displayName = "Await");
const fi = /* @__PURE__ */ P.createContext(null);
ke.env.NODE_ENV !== "production" && (fi.displayName = "Navigation");
const cf = /* @__PURE__ */ P.createContext(null);
ke.env.NODE_ENV !== "production" && (cf.displayName = "Location");
const Oi = /* @__PURE__ */ P.createContext({
  outlet: null,
  matches: [],
  isDataRoute: !1
});
ke.env.NODE_ENV !== "production" && (Oi.displayName = "Route");
const Z1 = /* @__PURE__ */ P.createContext(null);
ke.env.NODE_ENV !== "production" && (Z1.displayName = "RouteError");
function Vse(e, t) {
  let {
    relative: n
  } = t === void 0 ? {} : t;
  qa() || (ke.env.NODE_ENV !== "production" ? Ne(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component."
  ) : Ne(!1));
  let {
    basename: r,
    navigator: i
  } = P.useContext(fi), {
    hash: o,
    pathname: s,
    search: a
  } = uf(e, {
    relative: n
  }), l = s;
  return r !== "/" && (l = s === "/" ? r : Qi([r, s])), i.createHref({
    pathname: l,
    search: a,
    hash: o
  });
}
function qa() {
  return P.useContext(cf) != null;
}
function Bi() {
  return qa() || (ke.env.NODE_ENV !== "production" ? Ne(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ) : Ne(!1)), P.useContext(cf).location;
}
function ni(e) {
  qa() || (ke.env.NODE_ENV !== "production" ? Ne(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useMatch() may be used only in the context of a <Router> component."
  ) : Ne(!1));
  let {
    pathname: t
  } = Bi();
  return P.useMemo(() => md(e, TO(t)), [t, e]);
}
const DO = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function jO(e) {
  P.useContext(fi).static || P.useLayoutEffect(e);
}
function er() {
  let {
    isDataRoute: e
  } = P.useContext(Oi);
  return e ? rae() : qse();
}
function qse() {
  qa() || (ke.env.NODE_ENV !== "production" ? Ne(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  ) : Ne(!1));
  let e = P.useContext(Wc), {
    basename: t,
    future: n,
    navigator: r
  } = P.useContext(fi), {
    matches: i
  } = P.useContext(Oi), {
    pathname: o
  } = Bi(), s = JSON.stringify(Uy(i, n.v7_relativeSplatPath)), a = P.useRef(!1);
  return jO(() => {
    a.current = !0;
  }), P.useCallback(function(c, u) {
    if (u === void 0 && (u = {}), ke.env.NODE_ENV !== "production" && gn(a.current, DO), !a.current) return;
    if (typeof c == "number") {
      r.go(c);
      return;
    }
    let d = zy(c, JSON.parse(s), o, u.relative === "path");
    e == null && t !== "/" && (d.pathname = d.pathname === "/" ? t : Qi([t, d.pathname])), (u.replace ? r.replace : r.push)(d, u.state, u);
  }, [t, r, s, o, e]);
}
const $se = /* @__PURE__ */ P.createContext(null);
function Wse(e) {
  let t = P.useContext(Oi).outlet;
  return t && /* @__PURE__ */ P.createElement($se.Provider, {
    value: e
  }, t);
}
function uf(e, t) {
  let {
    relative: n
  } = t === void 0 ? {} : t, {
    future: r
  } = P.useContext(fi), {
    matches: i
  } = P.useContext(Oi), {
    pathname: o
  } = Bi(), s = JSON.stringify(Uy(i, r.v7_relativeSplatPath));
  return P.useMemo(() => zy(e, JSON.parse(s), o, n === "path"), [e, s, o, n]);
}
function Gse(e, t) {
  return MO(e, t);
}
function MO(e, t, n, r) {
  qa() || (ke.env.NODE_ENV !== "production" ? Ne(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useRoutes() may be used only in the context of a <Router> component."
  ) : Ne(!1));
  let {
    navigator: i
  } = P.useContext(fi), {
    matches: o
  } = P.useContext(Oi), s = o[o.length - 1], a = s ? s.params : {}, l = s ? s.pathname : "/", c = s ? s.pathnameBase : "/", u = s && s.route;
  if (ke.env.NODE_ENV !== "production") {
    let w = u && u.path || "";
    LO(l, !u || w.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + l + '" (under <Route path="' + w + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + w + '"> to <Route ') + ('path="' + (w === "/" ? "*" : w + "/*") + '">.'));
  }
  let d = Bi(), f;
  if (t) {
    var h;
    let w = typeof t == "string" ? oo(t) : t;
    c === "/" || (h = w.pathname) != null && h.startsWith(c) || (ke.env.NODE_ENV !== "production" ? Ne(!1, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was " + ('matched by all parent routes. The current pathname base is "' + c + '" ') + ('but pathname "' + w.pathname + '" was given in the `location` prop.')) : Ne(!1)), f = w;
  } else
    f = d;
  let p = f.pathname || "/", m = p;
  if (c !== "/") {
    let w = c.replace(/^\//, "").split("/");
    m = "/" + p.replace(/^\//, "").split("/").slice(w.length).join("/");
  }
  let g = ta(e, {
    pathname: m
  });
  ke.env.NODE_ENV !== "production" && (ke.env.NODE_ENV !== "production" && gn(u || g != null, 'No routes matched location "' + f.pathname + f.search + f.hash + '" '), ke.env.NODE_ENV !== "production" && gn(g == null || g[g.length - 1].route.element !== void 0 || g[g.length - 1].route.Component !== void 0 || g[g.length - 1].route.lazy !== void 0, 'Matched leaf route at location "' + f.pathname + f.search + f.hash + '" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.'));
  let v = Jse(g && g.map((w) => Object.assign({}, w, {
    params: Object.assign({}, a, w.params),
    pathname: Qi([
      c,
      // Re-encode pathnames that were decoded inside matchRoutes
      i.encodeLocation ? i.encodeLocation(w.pathname).pathname : w.pathname
    ]),
    pathnameBase: w.pathnameBase === "/" ? c : Qi([
      c,
      // Re-encode pathnames that were decoded inside matchRoutes
      i.encodeLocation ? i.encodeLocation(w.pathnameBase).pathname : w.pathnameBase
    ])
  })), o, n, r);
  return t && v ? /* @__PURE__ */ P.createElement(cf.Provider, {
    value: {
      location: hc({
        pathname: "/",
        search: "",
        hash: "",
        state: null,
        key: "default"
      }, f),
      navigationType: fn.Pop
    }
  }, v) : v;
}
function Hse() {
  let e = nae(), t = Vy(e) ? e.status + " " + e.statusText : e instanceof Error ? e.message : JSON.stringify(e), n = e instanceof Error ? e.stack : null, r = "rgba(200,200,200, 0.5)", i = {
    padding: "0.5rem",
    backgroundColor: r
  }, o = {
    padding: "2px 4px",
    backgroundColor: r
  }, s = null;
  return ke.env.NODE_ENV !== "production" && (s = /* @__PURE__ */ P.createElement(P.Fragment, null, /* @__PURE__ */ P.createElement("p", null, "💿 Hey developer 👋"), /* @__PURE__ */ P.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ P.createElement("code", {
    style: o
  }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ P.createElement("code", {
    style: o
  }, "errorElement"), " prop on your route."))), /* @__PURE__ */ P.createElement(P.Fragment, null, /* @__PURE__ */ P.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ P.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, t), n ? /* @__PURE__ */ P.createElement("pre", {
    style: i
  }, n) : null, s);
}
const Kse = /* @__PURE__ */ P.createElement(Hse, null);
class Yse extends P.Component {
  constructor(t) {
    super(t), this.state = {
      location: t.location,
      revalidation: t.revalidation,
      error: t.error
    };
  }
  static getDerivedStateFromError(t) {
    return {
      error: t
    };
  }
  static getDerivedStateFromProps(t, n) {
    return n.location !== t.location || n.revalidation !== "idle" && t.revalidation === "idle" ? {
      error: t.error,
      location: t.location,
      revalidation: t.revalidation
    } : {
      error: t.error !== void 0 ? t.error : n.error,
      location: n.location,
      revalidation: t.revalidation || n.revalidation
    };
  }
  componentDidCatch(t, n) {
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ P.createElement(Oi.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ P.createElement(Z1.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function Qse(e) {
  let {
    routeContext: t,
    match: n,
    children: r
  } = e, i = P.useContext(Wc);
  return i && i.static && i.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (i.staticContext._deepestRenderedBoundaryId = n.route.id), /* @__PURE__ */ P.createElement(Oi.Provider, {
    value: t
  }, r);
}
function Jse(e, t, n, r) {
  var i;
  if (t === void 0 && (t = []), n === void 0 && (n = null), r === void 0 && (r = null), e == null) {
    var o;
    if (!n)
      return null;
    if (n.errors)
      e = n.matches;
    else if ((o = r) != null && o.v7_partialHydration && t.length === 0 && !n.initialized && n.matches.length > 0)
      e = n.matches;
    else
      return null;
  }
  let s = e, a = (i = n) == null ? void 0 : i.errors;
  if (a != null) {
    let u = s.findIndex((d) => d.route.id && (a == null ? void 0 : a[d.route.id]) !== void 0);
    u >= 0 || (ke.env.NODE_ENV !== "production" ? Ne(!1, "Could not find a matching route for errors on route IDs: " + Object.keys(a).join(",")) : Ne(!1)), s = s.slice(0, Math.min(s.length, u + 1));
  }
  let l = !1, c = -1;
  if (n && r && r.v7_partialHydration)
    for (let u = 0; u < s.length; u++) {
      let d = s[u];
      if ((d.route.HydrateFallback || d.route.hydrateFallbackElement) && (c = u), d.route.id) {
        let {
          loaderData: f,
          errors: h
        } = n, p = d.route.loader && f[d.route.id] === void 0 && (!h || h[d.route.id] === void 0);
        if (d.route.lazy || p) {
          l = !0, c >= 0 ? s = s.slice(0, c + 1) : s = [s[0]];
          break;
        }
      }
    }
  return s.reduceRight((u, d, f) => {
    let h, p = !1, m = null, g = null;
    n && (h = a && d.route.id ? a[d.route.id] : void 0, m = d.route.errorElement || Kse, l && (c < 0 && f === 0 ? (LO("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"), p = !0, g = null) : c === f && (p = !0, g = d.route.hydrateFallbackElement || null)));
    let v = t.concat(s.slice(0, f + 1)), w = () => {
      let x;
      return h ? x = m : p ? x = g : d.route.Component ? x = /* @__PURE__ */ P.createElement(d.route.Component, null) : d.route.element ? x = d.route.element : x = u, /* @__PURE__ */ P.createElement(Qse, {
        match: d,
        routeContext: {
          outlet: u,
          matches: v,
          isDataRoute: n != null
        },
        children: x
      });
    };
    return n && (d.route.ErrorBoundary || d.route.errorElement || f === 0) ? /* @__PURE__ */ P.createElement(Yse, {
      location: n.location,
      revalidation: n.revalidation,
      component: m,
      error: h,
      children: w(),
      routeContext: {
        outlet: null,
        matches: v,
        isDataRoute: !0
      }
    }) : w();
  }, null);
}
var FO = /* @__PURE__ */ function(e) {
  return e.UseBlocker = "useBlocker", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e;
}(FO || {}), gd = /* @__PURE__ */ function(e) {
  return e.UseBlocker = "useBlocker", e.UseLoaderData = "useLoaderData", e.UseActionData = "useActionData", e.UseRouteError = "useRouteError", e.UseNavigation = "useNavigation", e.UseRouteLoaderData = "useRouteLoaderData", e.UseMatches = "useMatches", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e.UseRouteId = "useRouteId", e;
}(gd || {});
function ex(e) {
  return e + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function Xse(e) {
  let t = P.useContext(Wc);
  return t || (ke.env.NODE_ENV !== "production" ? Ne(!1, ex(e)) : Ne(!1)), t;
}
function Zse(e) {
  let t = P.useContext(qy);
  return t || (ke.env.NODE_ENV !== "production" ? Ne(!1, ex(e)) : Ne(!1)), t;
}
function eae(e) {
  let t = P.useContext(Oi);
  return t || (ke.env.NODE_ENV !== "production" ? Ne(!1, ex(e)) : Ne(!1)), t;
}
function tx(e) {
  let t = eae(e), n = t.matches[t.matches.length - 1];
  return n.route.id || (ke.env.NODE_ENV !== "production" ? Ne(!1, e + ' can only be used on routes that contain a unique "id"') : Ne(!1)), n.route.id;
}
function tae() {
  return tx(gd.UseRouteId);
}
function nae() {
  var e;
  let t = P.useContext(Z1), n = Zse(gd.UseRouteError), r = tx(gd.UseRouteError);
  return t !== void 0 ? t : (e = n.errors) == null ? void 0 : e[r];
}
function rae() {
  let {
    router: e
  } = Xse(FO.UseNavigateStable), t = tx(gd.UseNavigateStable), n = P.useRef(!1);
  return jO(() => {
    n.current = !0;
  }), P.useCallback(function(i, o) {
    o === void 0 && (o = {}), ke.env.NODE_ENV !== "production" && gn(n.current, DO), n.current && (typeof i == "number" ? e.navigate(i) : e.navigate(i, hc({
      fromRouteId: t
    }, o)));
  }, [e, t]);
}
const K8 = {};
function LO(e, t, n) {
  !t && !K8[e] && (K8[e] = !0, ke.env.NODE_ENV !== "production" && gn(!1, n));
}
function UO(e) {
  let {
    to: t,
    replace: n,
    state: r,
    relative: i
  } = e;
  qa() || (ke.env.NODE_ENV !== "production" ? Ne(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of
    // the router loaded. We can help them understand how to avoid that.
    "<Navigate> may be used only in the context of a <Router> component."
  ) : Ne(!1));
  let {
    future: o,
    static: s
  } = P.useContext(fi);
  ke.env.NODE_ENV !== "production" && gn(!s, "<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.");
  let {
    matches: a
  } = P.useContext(Oi), {
    pathname: l
  } = Bi(), c = er(), u = zy(t, Uy(a, o.v7_relativeSplatPath), l, i === "path"), d = JSON.stringify(u);
  return P.useEffect(() => c(JSON.parse(d), {
    replace: n,
    state: r,
    relative: i
  }), [c, d, i, n, r]), null;
}
function nx(e) {
  return Wse(e.context);
}
function Lt(e) {
  ke.env.NODE_ENV !== "production" ? Ne(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.") : Ne(!1);
}
function iae(e) {
  let {
    basename: t = "/",
    children: n = null,
    location: r,
    navigationType: i = fn.Pop,
    navigator: o,
    static: s = !1,
    future: a
  } = e;
  qa() && (ke.env.NODE_ENV !== "production" ? Ne(!1, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : Ne(!1));
  let l = t.replace(/^\/*/, "/"), c = P.useMemo(() => ({
    basename: l,
    navigator: o,
    static: s,
    future: hc({
      v7_relativeSplatPath: !1
    }, a)
  }), [l, a, o, s]);
  typeof r == "string" && (r = oo(r));
  let {
    pathname: u = "/",
    search: d = "",
    hash: f = "",
    state: h = null,
    key: p = "default"
  } = r, m = P.useMemo(() => {
    let g = Ti(u, l);
    return g == null ? null : {
      location: {
        pathname: g,
        search: d,
        hash: f,
        state: h,
        key: p
      },
      navigationType: i
    };
  }, [l, u, d, f, h, p, i]);
  return ke.env.NODE_ENV !== "production" && gn(m != null, '<Router basename="' + l + '"> is not able to match the URL ' + ('"' + u + d + f + '" because it does not start with the ') + "basename, so the <Router> won't render anything."), m == null ? null : /* @__PURE__ */ P.createElement(fi.Provider, {
    value: c
  }, /* @__PURE__ */ P.createElement(cf.Provider, {
    children: n,
    value: m
  }));
}
function oae(e) {
  let {
    children: t,
    location: n
  } = e;
  return Gse(y0(t), n);
}
new Promise(() => {
});
function y0(e, t) {
  t === void 0 && (t = []);
  let n = [];
  return P.Children.forEach(e, (r, i) => {
    if (!/* @__PURE__ */ P.isValidElement(r))
      return;
    let o = [...t, i];
    if (r.type === P.Fragment) {
      n.push.apply(n, y0(r.props.children, o));
      return;
    }
    r.type !== Lt && (ke.env.NODE_ENV !== "production" ? Ne(!1, "[" + (typeof r.type == "string" ? r.type : r.type.name) + "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>") : Ne(!1)), !r.props.index || !r.props.children || (ke.env.NODE_ENV !== "production" ? Ne(!1, "An index route cannot have child routes.") : Ne(!1));
    let s = {
      id: r.props.id || o.join("-"),
      caseSensitive: r.props.caseSensitive,
      element: r.props.element,
      Component: r.props.Component,
      index: r.props.index,
      path: r.props.path,
      loader: r.props.loader,
      action: r.props.action,
      errorElement: r.props.errorElement,
      ErrorBoundary: r.props.ErrorBoundary,
      hasErrorBoundary: r.props.ErrorBoundary != null || r.props.errorElement != null,
      shouldRevalidate: r.props.shouldRevalidate,
      handle: r.props.handle,
      lazy: r.props.lazy
    };
    r.props.children && (s.children = y0(r.props.children, o)), n.push(s);
  }), n;
}
function sae(e) {
  let t = {
    // Note: this check also occurs in createRoutesFromChildren so update
    // there if you change this -- please and thank you!
    hasErrorBoundary: e.ErrorBoundary != null || e.errorElement != null
  };
  return e.Component && (ke.env.NODE_ENV !== "production" && e.element && ke.env.NODE_ENV !== "production" && gn(!1, "You should not include both `Component` and `element` on your route - `Component` will be used."), Object.assign(t, {
    element: /* @__PURE__ */ P.createElement(e.Component),
    Component: void 0
  })), e.HydrateFallback && (ke.env.NODE_ENV !== "production" && e.hydrateFallbackElement && ke.env.NODE_ENV !== "production" && gn(!1, "You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used."), Object.assign(t, {
    hydrateFallbackElement: /* @__PURE__ */ P.createElement(e.HydrateFallback),
    HydrateFallback: void 0
  })), e.ErrorBoundary && (ke.env.NODE_ENV !== "production" && e.errorElement && ke.env.NODE_ENV !== "production" && gn(!1, "You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used."), Object.assign(t, {
    errorElement: /* @__PURE__ */ P.createElement(e.ErrorBoundary),
    ErrorBoundary: void 0
  })), t;
}
function aae(e, t) {
  return vse({
    basename: void 0,
    future: hc({}, void 0, {
      v7_prependBasename: !0
    }),
    history: $oe({
      initialEntries: void 0,
      initialIndex: void 0
    }),
    hydrationData: void 0,
    routes: e,
    mapRouteProperties: sae,
    unstable_dataStrategy: void 0,
    unstable_patchRoutesOnNavigation: void 0
  }).initialize();
}
function pc() {
  return pc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, pc.apply(this, arguments);
}
function rx(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
const Ah = "get", Th = "application/x-www-form-urlencoded";
function $y(e) {
  return e != null && typeof e.tagName == "string";
}
function lae(e) {
  return $y(e) && e.tagName.toLowerCase() === "button";
}
function cae(e) {
  return $y(e) && e.tagName.toLowerCase() === "form";
}
function uae(e) {
  return $y(e) && e.tagName.toLowerCase() === "input";
}
function dae(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
function fae(e, t) {
  return e.button === 0 && // Ignore everything but left clicks
  (!t || t === "_self") && // Let browser handle "target=_blank" etc.
  !dae(e);
}
let Xf = null;
function hae() {
  if (Xf === null)
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      ), Xf = !1;
    } catch {
      Xf = !0;
    }
  return Xf;
}
const pae = /* @__PURE__ */ new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function Hg(e) {
  return e != null && !pae.has(e) ? (ke.env.NODE_ENV !== "production" && gn(!1, '"' + e + '" is not a valid `encType` for `<Form>`/`<fetcher.Form>` ' + ('and will default to "' + Th + '"')), null) : e;
}
function yae(e, t) {
  let n, r, i, o, s;
  if (cae(e)) {
    let a = e.getAttribute("action");
    r = a ? Ti(a, t) : null, n = e.getAttribute("method") || Ah, i = Hg(e.getAttribute("enctype")) || Th, o = new FormData(e);
  } else if (lae(e) || uae(e) && (e.type === "submit" || e.type === "image")) {
    let a = e.form;
    if (a == null)
      throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
    let l = e.getAttribute("formaction") || a.getAttribute("action");
    if (r = l ? Ti(l, t) : null, n = e.getAttribute("formmethod") || a.getAttribute("method") || Ah, i = Hg(e.getAttribute("formenctype")) || Hg(a.getAttribute("enctype")) || Th, o = new FormData(a, e), !hae()) {
      let {
        name: c,
        type: u,
        value: d
      } = e;
      if (u === "image") {
        let f = c ? c + "." : "";
        o.append(f + "x", "0"), o.append(f + "y", "0");
      } else c && o.append(c, d);
    }
  } else {
    if ($y(e))
      throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
    n = Ah, r = null, i = Th, s = e;
  }
  return o && i === "text/plain" && (s = o, o = void 0), {
    action: r,
    method: n.toLowerCase(),
    encType: i,
    formData: o,
    body: s
  };
}
const mae = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"], gae = ["aria-current", "caseSensitive", "className", "end", "style", "to", "unstable_viewTransition", "children"], vae = ["fetcherKey", "navigate", "reloadDocument", "replace", "state", "method", "action", "onSubmit", "relative", "preventScrollReset", "unstable_viewTransition"], bae = "6";
try {
  window.__reactRouterVersion = bae;
} catch {
}
const ix = /* @__PURE__ */ P.createContext({
  isTransitioning: !1
});
ke.env.NODE_ENV !== "production" && (ix.displayName = "ViewTransition");
const zO = /* @__PURE__ */ P.createContext(/* @__PURE__ */ new Map());
ke.env.NODE_ENV !== "production" && (zO.displayName = "Fetchers");
const wae = "startTransition", Y8 = P[wae], xae = "flushSync", Q8 = Sp[xae];
function Cae(e) {
  Y8 ? Y8(e) : e();
}
function fu(e) {
  Q8 ? Q8(e) : e();
}
class kae {
  constructor() {
    this.status = "pending", this.promise = new Promise((t, n) => {
      this.resolve = (r) => {
        this.status === "pending" && (this.status = "resolved", t(r));
      }, this.reject = (r) => {
        this.status === "pending" && (this.status = "rejected", n(r));
      };
    });
  }
}
function Eae(e) {
  let {
    fallbackElement: t,
    router: n,
    future: r
  } = e, [i, o] = P.useState(n.state), [s, a] = P.useState(), [l, c] = P.useState({
    isTransitioning: !1
  }), [u, d] = P.useState(), [f, h] = P.useState(), [p, m] = P.useState(), g = P.useRef(/* @__PURE__ */ new Map()), {
    v7_startTransition: v
  } = r || {}, w = P.useCallback((b) => {
    v ? Cae(b) : b();
  }, [v]), x = P.useCallback((b, T) => {
    let {
      deletedFetchers: R,
      unstable_flushSync: B,
      unstable_viewTransitionOpts: O
    } = T;
    R.forEach((V) => g.current.delete(V)), b.fetchers.forEach((V, N) => {
      V.data !== void 0 && g.current.set(N, V.data);
    });
    let L = n.window == null || n.window.document == null || typeof n.window.document.startViewTransition != "function";
    if (!O || L) {
      B ? fu(() => o(b)) : w(() => o(b));
      return;
    }
    if (B) {
      fu(() => {
        f && (u && u.resolve(), f.skipTransition()), c({
          isTransitioning: !0,
          flushSync: !0,
          currentLocation: O.currentLocation,
          nextLocation: O.nextLocation
        });
      });
      let V = n.window.document.startViewTransition(() => {
        fu(() => o(b));
      });
      V.finished.finally(() => {
        fu(() => {
          d(void 0), h(void 0), a(void 0), c({
            isTransitioning: !1
          });
        });
      }), fu(() => h(V));
      return;
    }
    f ? (u && u.resolve(), f.skipTransition(), m({
      state: b,
      currentLocation: O.currentLocation,
      nextLocation: O.nextLocation
    })) : (a(b), c({
      isTransitioning: !0,
      flushSync: !1,
      currentLocation: O.currentLocation,
      nextLocation: O.nextLocation
    }));
  }, [n.window, f, u, g, w]);
  P.useLayoutEffect(() => n.subscribe(x), [n, x]), P.useEffect(() => {
    l.isTransitioning && !l.flushSync && d(new kae());
  }, [l]), P.useEffect(() => {
    if (u && s && n.window) {
      let b = s, T = u.promise, R = n.window.document.startViewTransition(async () => {
        w(() => o(b)), await T;
      });
      R.finished.finally(() => {
        d(void 0), h(void 0), a(void 0), c({
          isTransitioning: !1
        });
      }), h(R);
    }
  }, [w, s, u, n.window]), P.useEffect(() => {
    u && s && i.location.key === s.location.key && u.resolve();
  }, [u, f, i.location, s]), P.useEffect(() => {
    !l.isTransitioning && p && (a(p.state), c({
      isTransitioning: !0,
      flushSync: !1,
      currentLocation: p.currentLocation,
      nextLocation: p.nextLocation
    }), m(void 0));
  }, [l.isTransitioning, p]), P.useEffect(() => {
    ke.env.NODE_ENV !== "production" && gn(t == null || !n.future.v7_partialHydration, "`<RouterProvider fallbackElement>` is deprecated when using `v7_partialHydration`, use a `HydrateFallback` component instead");
  }, []);
  let C = P.useMemo(() => ({
    createHref: n.createHref,
    encodeLocation: n.encodeLocation,
    go: (b) => n.navigate(b),
    push: (b, T, R) => n.navigate(b, {
      state: T,
      preventScrollReset: R == null ? void 0 : R.preventScrollReset
    }),
    replace: (b, T, R) => n.navigate(b, {
      replace: !0,
      state: T,
      preventScrollReset: R == null ? void 0 : R.preventScrollReset
    })
  }), [n]), S = n.basename || "/", k = P.useMemo(() => ({
    router: n,
    navigator: C,
    static: !1,
    basename: S
  }), [n, C, S]), A = P.useMemo(() => ({
    v7_relativeSplatPath: n.future.v7_relativeSplatPath
  }), [n.future.v7_relativeSplatPath]);
  return /* @__PURE__ */ P.createElement(P.Fragment, null, /* @__PURE__ */ P.createElement(Wc.Provider, {
    value: k
  }, /* @__PURE__ */ P.createElement(qy.Provider, {
    value: i
  }, /* @__PURE__ */ P.createElement(zO.Provider, {
    value: g.current
  }, /* @__PURE__ */ P.createElement(ix.Provider, {
    value: l
  }, /* @__PURE__ */ P.createElement(iae, {
    basename: S,
    location: i.location,
    navigationType: i.historyAction,
    navigator: C,
    future: A
  }, i.initialized || n.future.v7_partialHydration ? /* @__PURE__ */ P.createElement(Sae, {
    routes: n.routes,
    future: n.future,
    state: i
  }) : t))))), null);
}
const Sae = /* @__PURE__ */ P.memo(Aae);
function Aae(e) {
  let {
    routes: t,
    future: n,
    state: r
  } = e;
  return MO(t, void 0, r, n);
}
ke.env.NODE_ENV;
const Tae = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", _ae = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, ox = /* @__PURE__ */ P.forwardRef(function(t, n) {
  let {
    onClick: r,
    relative: i,
    reloadDocument: o,
    replace: s,
    state: a,
    target: l,
    to: c,
    preventScrollReset: u,
    unstable_viewTransition: d
  } = t, f = rx(t, mae), {
    basename: h
  } = P.useContext(fi), p, m = !1;
  if (typeof c == "string" && _ae.test(c) && (p = c, Tae))
    try {
      let x = new URL(window.location.href), C = c.startsWith("//") ? new URL(x.protocol + c) : new URL(c), S = Ti(C.pathname, h);
      C.origin === x.origin && S != null ? c = S + C.search + C.hash : m = !0;
    } catch {
      ke.env.NODE_ENV !== "production" && gn(!1, '<Link to="' + c + '"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.');
    }
  let g = Vse(c, {
    relative: i
  }), v = Oae(c, {
    replace: s,
    state: a,
    target: l,
    preventScrollReset: u,
    relative: i,
    unstable_viewTransition: d
  });
  function w(x) {
    r && r(x), x.defaultPrevented || v(x);
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ P.createElement("a", pc({}, f, {
      href: p || g,
      onClick: m || o ? r : w,
      ref: n,
      target: l
    }))
  );
});
ke.env.NODE_ENV !== "production" && (ox.displayName = "Link");
const Iae = /* @__PURE__ */ P.forwardRef(function(t, n) {
  let {
    "aria-current": r = "page",
    caseSensitive: i = !1,
    className: o = "",
    end: s = !1,
    style: a,
    to: l,
    unstable_viewTransition: c,
    children: u
  } = t, d = rx(t, gae), f = uf(l, {
    relative: d.relative
  }), h = Bi(), p = P.useContext(qy), {
    navigator: m,
    basename: g
  } = P.useContext(fi), v = p != null && // Conditional usage is OK here because the usage of a data router is static
  // eslint-disable-next-line react-hooks/rules-of-hooks
  Fae(f) && c === !0, w = m.encodeLocation ? m.encodeLocation(f).pathname : f.pathname, x = h.pathname, C = p && p.navigation && p.navigation.location ? p.navigation.location.pathname : null;
  i || (x = x.toLowerCase(), C = C ? C.toLowerCase() : null, w = w.toLowerCase()), C && g && (C = Ti(C, g) || C);
  const S = w !== "/" && w.endsWith("/") ? w.length - 1 : w.length;
  let k = x === w || !s && x.startsWith(w) && x.charAt(S) === "/", A = C != null && (C === w || !s && C.startsWith(w) && C.charAt(w.length) === "/"), b = {
    isActive: k,
    isPending: A,
    isTransitioning: v
  }, T = k ? r : void 0, R;
  typeof o == "function" ? R = o(b) : R = [o, k ? "active" : null, A ? "pending" : null, v ? "transitioning" : null].filter(Boolean).join(" ");
  let B = typeof a == "function" ? a(b) : a;
  return /* @__PURE__ */ P.createElement(ox, pc({}, d, {
    "aria-current": T,
    className: R,
    ref: n,
    style: B,
    to: l,
    unstable_viewTransition: c
  }), typeof u == "function" ? u(b) : u);
});
ke.env.NODE_ENV !== "production" && (Iae.displayName = "NavLink");
const Rae = /* @__PURE__ */ P.forwardRef((e, t) => {
  let {
    fetcherKey: n,
    navigate: r,
    reloadDocument: i,
    replace: o,
    state: s,
    method: a = Ah,
    action: l,
    onSubmit: c,
    relative: u,
    preventScrollReset: d,
    unstable_viewTransition: f
  } = e, h = rx(e, vae), p = jae(), m = Mae(l, {
    relative: u
  }), g = a.toLowerCase() === "get" ? "get" : "post", v = (w) => {
    if (c && c(w), w.defaultPrevented) return;
    w.preventDefault();
    let x = w.nativeEvent.submitter, C = (x == null ? void 0 : x.getAttribute("formmethod")) || a;
    p(x || w.currentTarget, {
      fetcherKey: n,
      method: C,
      navigate: r,
      replace: o,
      state: s,
      relative: u,
      preventScrollReset: d,
      unstable_viewTransition: f
    });
  };
  return /* @__PURE__ */ P.createElement("form", pc({
    ref: t,
    method: g,
    action: m,
    onSubmit: i ? c : v
  }, h));
});
ke.env.NODE_ENV !== "production" && (Rae.displayName = "Form");
ke.env.NODE_ENV;
var up;
(function(e) {
  e.UseScrollRestoration = "useScrollRestoration", e.UseSubmit = "useSubmit", e.UseSubmitFetcher = "useSubmitFetcher", e.UseFetcher = "useFetcher", e.useViewTransitionState = "useViewTransitionState";
})(up || (up = {}));
var J8;
(function(e) {
  e.UseFetcher = "useFetcher", e.UseFetchers = "useFetchers", e.UseScrollRestoration = "useScrollRestoration";
})(J8 || (J8 = {}));
function Pae(e) {
  return e + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function VO(e) {
  let t = P.useContext(Wc);
  return t || (ke.env.NODE_ENV !== "production" ? Ne(!1, Pae(e)) : Ne(!1)), t;
}
function Oae(e, t) {
  let {
    target: n,
    replace: r,
    state: i,
    preventScrollReset: o,
    relative: s,
    unstable_viewTransition: a
  } = t === void 0 ? {} : t, l = er(), c = Bi(), u = uf(e, {
    relative: s
  });
  return P.useCallback((d) => {
    if (fae(d, n)) {
      d.preventDefault();
      let f = r !== void 0 ? r : Ba(c) === Ba(u);
      l(e, {
        replace: f,
        state: i,
        preventScrollReset: o,
        relative: s,
        unstable_viewTransition: a
      });
    }
  }, [c, l, u, r, i, n, e, o, s, a]);
}
function Bae() {
  if (typeof document > "u")
    throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
}
let Nae = 0, Dae = () => "__" + String(++Nae) + "__";
function jae() {
  let {
    router: e
  } = VO(up.UseSubmit), {
    basename: t
  } = P.useContext(fi), n = tae();
  return P.useCallback(function(r, i) {
    i === void 0 && (i = {}), Bae();
    let {
      action: o,
      method: s,
      encType: a,
      formData: l,
      body: c
    } = yae(r, t);
    if (i.navigate === !1) {
      let u = i.fetcherKey || Dae();
      e.fetch(u, n, i.action || o, {
        preventScrollReset: i.preventScrollReset,
        formData: l,
        body: c,
        formMethod: i.method || s,
        formEncType: i.encType || a,
        unstable_flushSync: i.unstable_flushSync
      });
    } else
      e.navigate(i.action || o, {
        preventScrollReset: i.preventScrollReset,
        formData: l,
        body: c,
        formMethod: i.method || s,
        formEncType: i.encType || a,
        replace: i.replace,
        state: i.state,
        fromRouteId: n,
        unstable_flushSync: i.unstable_flushSync,
        unstable_viewTransition: i.unstable_viewTransition
      });
  }, [e, t, n]);
}
function Mae(e, t) {
  let {
    relative: n
  } = t === void 0 ? {} : t, {
    basename: r
  } = P.useContext(fi), i = P.useContext(Oi);
  i || (ke.env.NODE_ENV !== "production" ? Ne(!1, "useFormAction must be used inside a RouteContext") : Ne(!1));
  let [o] = i.matches.slice(-1), s = pc({}, uf(e || ".", {
    relative: n
  })), a = Bi();
  if (e == null) {
    s.search = a.search;
    let l = new URLSearchParams(s.search);
    l.has("index") && l.get("index") === "" && (l.delete("index"), s.search = l.toString() ? "?" + l.toString() : "");
  }
  return (!e || e === ".") && o.route.index && (s.search = s.search ? s.search.replace(/^\?/, "?index&") : "?index"), r !== "/" && (s.pathname = s.pathname === "/" ? r : Qi([r, s.pathname])), Ba(s);
}
function Fae(e, t) {
  t === void 0 && (t = {});
  let n = P.useContext(ix);
  n == null && (ke.env.NODE_ENV !== "production" ? Ne(!1, "`unstable_useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?") : Ne(!1));
  let {
    basename: r
  } = VO(up.useViewTransitionState), i = uf(e, {
    relative: t.relative
  });
  if (!n.isTransitioning)
    return !1;
  let o = Ti(n.currentLocation.pathname, r) || n.currentLocation.pathname, s = Ti(n.nextLocation.pathname, r) || n.nextLocation.pathname;
  return md(i.pathname, s) != null || md(i.pathname, o) != null;
}
const qO = () => {
  const e = ni("/"), t = ni("/positions"), n = ni("/activity");
  return e || t || n;
}, Lae = () => /* @__PURE__ */ y.jsx("svg", { width: 16, height: 16, fill: "none", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ y.jsx(
  "path",
  {
    d: "m11 9 2 2-2 2M3 11h10M5 7 3 5l2-2M13 5H3",
    stroke: "#999",
    strokeWidth: 1.5,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
) }), Uae = () => /* @__PURE__ */ y.jsx("svg", { width: 24, height: 24, fill: "none", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ y.jsx(
  "path",
  {
    d: "M15 19.5 7.5 12 15 4.5",
    stroke: "#999",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
) }), zae = () => /* @__PURE__ */ y.jsxs("svg", { width: 16, height: 16, fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
  /* @__PURE__ */ y.jsx(
    "path",
    {
      d: "M8 5v3M10.6 9.5 8 8M11.513 6.231h2.5v-2.5",
      stroke: "#999",
      strokeWidth: 1.5,
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }
  ),
  /* @__PURE__ */ y.jsx(
    "path",
    {
      d: "M11.888 11.887a5.5 5.5 0 1 1 0-7.775l2.125 2.12",
      stroke: "#999",
      strokeWidth: 1.5,
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }
  )
] }), Vae = () => /* @__PURE__ */ y.jsx("svg", { width: 16, height: 16, fill: "none", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ y.jsx(
  "path",
  {
    d: "M13.5 5h-11a.5.5 0 0 0-.5.5v2a.5.5 0 0 0 .5.5h11a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 0-.5-.5ZM13 8v4.5a.5.5 0 0 1-.5.5h-9a.5.5 0 0 1-.5-.5V8M8 5v8M10.831 4.294C10.12 5 8 5 8 5s0-2.119.706-2.831a1.503 1.503 0 0 1 2.125 2.125ZM5.169 4.294C5.88 5 7.999 5 7.999 5s0-2.119-.705-2.831a1.503 1.503 0 0 0-2.125 2.125Z",
    stroke: "#999",
    strokeWidth: 1.5,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
) }), qae = () => /* @__PURE__ */ y.jsxs("svg", { width: 32, height: 32, fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
  /* @__PURE__ */ y.jsx(
    "path",
    {
      d: "M16 25a9 9 0 1 0 0-18 9 9 0 0 0 0 18Z",
      stroke: "#999",
      strokeWidth: 2,
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }
  ),
  /* @__PURE__ */ y.jsx(
    "path",
    {
      d: "M16 22a1.125 1.125 0 1 0 0-2.25A1.125 1.125 0 0 0 16 22Z",
      fill: "#999"
    }
  ),
  /* @__PURE__ */ y.jsx(
    "path",
    {
      d: "M16 17.5v-.75a2.625 2.625 0 1 0-2.625-2.625",
      stroke: "#999",
      strokeWidth: 2,
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }
  )
] }), Il = (e) => /* @__PURE__ */ y.jsx(
  "svg",
  {
    viewBox: "0 0 24 24",
    width: e.hw ?? 24,
    height: e.hw ?? 24,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: /* @__PURE__ */ y.jsx(
      "path",
      {
        d: "m18.75 5.25-13.5 13.5M18.75 18.75 5.25 5.25",
        stroke: e.color ? zt.color[e.color] : zt.color.textMuted,
        strokeWidth: e.strokeWidth ?? 2,
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    )
  }
), $a = ({ size: e = 12 }) => /* @__PURE__ */ y.jsx(
  "svg",
  {
    width: e,
    height: e,
    viewBox: "0 0 12 12",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: /* @__PURE__ */ y.jsx(
      "path",
      {
        d: "M9.75 4.5L6 8.25L2.25 4.5",
        stroke: zt.color.text,
        strokeWidth: "1.33333",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    )
  }
), $ae = () => /* @__PURE__ */ y.jsx(
  "svg",
  {
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: zt.color.text,
    xmlns: "http://www.w3.org/2000/svg",
    children: /* @__PURE__ */ y.jsx(
      "path",
      {
        d: "M13.5307 12.4693L10.5625 9.49998C11.4525 8.34027 11.868 6.88547 11.7247 5.43069C11.5815 3.97591 10.8902 2.63008 9.79119 1.66622C8.69215 0.702356 7.26764 0.192633 5.8066 0.24045C4.34557 0.288266 2.95742 0.890041 1.92376 1.9237C0.890102 2.95736 0.288327 4.34551 0.240511 5.80654C0.192694 7.26757 0.702417 8.69209 1.66628 9.79113C2.63014 10.8902 3.97597 11.5814 5.43075 11.7247C6.88553 11.8679 8.34033 11.4524 9.50004 10.5625L12.4707 13.5337C12.5404 13.6035 12.6232 13.6588 12.7144 13.6966C12.8056 13.7343 12.9032 13.7538 13.0019 13.7538C13.1006 13.7538 13.1983 13.7343 13.2894 13.6966C13.3806 13.6588 13.4634 13.6035 13.5332 13.5337C13.6029 13.464 13.6583 13.3811 13.696 13.29C13.7338 13.1988 13.7532 13.1011 13.7532 13.0025C13.7532 12.9038 13.7338 12.8061 13.696 12.715C13.6583 12.6238 13.6029 12.541 13.5332 12.4712L13.5307 12.4693ZM1.75004 5.99998C1.75004 5.15941 1.99929 4.33771 2.46629 3.6388C2.93329 2.93989 3.59705 2.39516 4.37363 2.07349C5.15022 1.75182 6.00475 1.66765 6.82917 1.83164C7.65359 1.99563 8.41087 2.4004 9.00524 2.99477C9.59961 3.58914 10.0044 4.34642 10.1684 5.17084C10.3324 5.99526 10.2482 6.84979 9.92652 7.62638C9.60485 8.40297 9.06012 9.06672 8.36121 9.53372C7.6623 10.0007 6.84061 10.25 6.00004 10.25C4.87322 10.2488 3.79289 9.80068 2.99611 9.0039C2.19933 8.20712 1.75119 7.12679 1.75004 5.99998Z",
        fill: zt.color.text
      }
    )
  }
);
var Wae = "_33v9qv0", Gae = "_33v9qv2 _33v9qv1 yv8y4rn", Hae = "_33v9qv3";
const Kae = () => {
  const e = cn(), { address: t } = wt(), n = we(t1);
  return /* @__PURE__ */ y.jsx(Xd.Custom, { children: ({ account: r, openAccountModal: i }) => G.fromNullable(r).map((o) => /* @__PURE__ */ y.jsx(
    z,
    {
      "data-rk": "account-modal-container",
      borderRadius: "2xl",
      background: "backgroundMuted",
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      className: Wae,
      onClick: () => {
        e("accountModalOpened"), i();
      },
      children: /* @__PURE__ */ y.jsxs(
        z,
        {
          as: "button",
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          paddingLeft: "2",
          py: "2",
          children: [
            o.ensAvatar ? /* @__PURE__ */ y.jsx(z, { as: "img", src: o.ensAvatar, hw: "6", borderRadius: "half" }) : /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
              /* @__PURE__ */ y.jsx(
                z,
                {
                  borderRadius: "half",
                  marginRight: "2",
                  className: Hae,
                  children: /* @__PURE__ */ y.jsx(n, { address: t, size: 24 })
                }
              ),
              /* @__PURE__ */ y.jsx(ue, { className: Gae, children: o.ensName ?? o.displayName })
            ] }),
            /* @__PURE__ */ y.jsx(z, { mx: "2", children: /* @__PURE__ */ y.jsx($a, {}) })
          ]
        }
      )
    }
  )).extractNullable() });
};
var Yae = "_1910ja40", Qae = "_1910ja42 _1910ja41 yv8y4rn";
const Jae = () => {
  const e = cn(), { t } = ze(), { variant: n } = bt();
  return /* @__PURE__ */ y.jsx(Xd.Custom, { children: ({ chain: r, openChainModal: i }) => G.fromNullable(r).map((o) => /* @__PURE__ */ y.jsx(
    z,
    {
      "data-rk": "chain-modal-container",
      borderRadius: "2xl",
      background: "backgroundMuted",
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      className: Yae,
      onClick: () => {
        e("chainModalOpened"), i();
      },
      children: G.fromFalsy(o.unsupported && n !== "zerion").map(() => /* @__PURE__ */ y.jsx(z, { px: "2", py: "2", children: /* @__PURE__ */ y.jsx(ue, { variant: { type: "danger" }, children: t("shared.unsupported_network") }) })).orDefaultLazy(() => /* @__PURE__ */ y.jsxs(
        z,
        {
          as: "button",
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          paddingLeft: "2",
          py: "2",
          children: [
            o.iconUrl && /* @__PURE__ */ y.jsx(
              z,
              {
                as: "img",
                borderRadius: "full",
                hw: "6",
                src: o.iconUrl
              }
            ),
            o.name && /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
              /* @__PURE__ */ y.jsx(z, { marginLeft: "2", children: /* @__PURE__ */ y.jsx(ue, { className: Qae, children: o.name }) }),
              /* @__PURE__ */ y.jsx(z, { mx: "2", children: /* @__PURE__ */ y.jsx($a, {}) })
            ] })
          ]
        }
      ))
    }
  )).extractNullable() });
};
var Xae = "v3r9r70", Zae = "v3r9r72 v3r9r71 yv8y4rpl";
const Wy = (e) => {
  const t = It(null), n = Dt(e);
  return Bo(() => {
    if (!t.current) return;
    const r = new ResizeObserver((i) => {
      const o = i[0];
      n.current(o.target.clientHeight);
    });
    return r.observe(t.current), () => {
      r.disconnect();
    };
  }, [n]), { containerRef: t };
}, df = (e) => {
  const t = Ge(void 0), n = (o, s) => Rr(t.Provider, o, s);
  return [() => {
    const o = we(t);
    if (o == null)
      throw new Error("useStateContext must be used inside a StateProvider.");
    return o;
  }, ({
    children: o,
    initialValue: s
  }) => {
    const a = Oe(
      s !== void 0 ? s : e
    );
    return n({ value: a }, o);
  }, t];
}, [$O, ele] = df(0), tle = () => Wy($O()[1]), nle = () => {
  const e = er(), { containerRef: t } = tle(), { variant: n } = bt(), { isConnected: r, isConnecting: i, connector: o } = wt(), s = J(
    () => G.fromNullable(o).map(IR).orDefault(!1),
    [o]
  ), a = ef(), l = !qO(), c = cn(), u = () => {
    l && (c("backClicked"), e(-1));
  }, { mutate: d } = qX(), f = () => {
    c("widgetDisconnectClicked"), d();
  };
  return /* @__PURE__ */ y.jsx(z, { ref: t, "data-rk": "header", children: /* @__PURE__ */ y.jsxs(z, { paddingTop: "4", paddingBottom: "1", children: [
    /* @__PURE__ */ y.jsxs(z, { display: "flex", justifyContent: "space-between", alignItems: "center", children: [
      /* @__PURE__ */ y.jsx(
        z,
        {
          hw: "7",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          children: l ? /* @__PURE__ */ y.jsx(
            z,
            {
              as: "button",
              onClick: u,
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              children: /* @__PURE__ */ y.jsx(Uae, {})
            }
          ) : /* @__PURE__ */ y.jsx(z, {})
        }
      ),
      s && /* @__PURE__ */ y.jsx(
        z,
        {
          as: "button",
          onClick: f,
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          children: /* @__PURE__ */ y.jsx(Il, { hw: 24 })
        }
      )
    ] }),
    G.fromFalsy(
      !a.isLoading && a.data && n !== "zerion"
    ).map(() => /* @__PURE__ */ y.jsx(Xd.Custom, { children: ({ account: h, chain: p, mounted: m }) => /* @__PURE__ */ y.jsx(
      z,
      {
        className: wr({ [Xae]: !m }),
        "aria-hidden": !m,
        children: G.fromFalsy(
          (r || i) && p && h
        ).map(() => /* @__PURE__ */ y.jsxs(
          Zt.div,
          {
            className: Zae,
            initial: { opacity: 0 },
            animate: { opacity: 1 },
            transition: { delay: 0.2, duration: 0.2 },
            children: [
              /* @__PURE__ */ y.jsx(Jae, {}),
              /* @__PURE__ */ y.jsx(Kae, {})
            ]
          }
        )).extractNullable()
      }
    ) })).extractNullable()
  ] }) });
}, Kg = ({ children: e, className: t }) => /* @__PURE__ */ y.jsx(
  z,
  {
    background: "backgroundMuted",
    display: "inline",
    px: "1",
    borderRadius: "lg",
    marginRight: "1",
    my: "1",
    as: "span",
    className: t,
    children: e
  }
);
var rle = $c({ defaultClassName: "_1qt23ex6 _1qt23ex0 yv8y4rrb yv8y4rrc", variantClassNames: { level: { h1: "_1qt23ex7", h2: "_1qt23ex8", h3: "_1qt23ex9", h4: "_1qt23exa" }, weight: { normal: "_1qt23exb _1qt23ex1 yv8y4ri", medium: "_1qt23exc _1qt23ex2 yv8y4rj", semibold: "_1qt23exd _1qt23ex3 yv8y4rk", bold: "_1qt23exe _1qt23ex4 yv8y4rl", extrabold: "_1qt23exf _1qt23ex5 yv8y4rm" } }, defaultVariants: { weight: "normal" }, compoundVariants: [] }), ile = $c({ defaultClassName: "_1qt23exr", variantClassNames: { weight: { normal: "_1qt23exs _1qt23exg yv8y4ri", medium: "_1qt23ext _1qt23exh yv8y4rj", semibold: "_1qt23exu _1qt23exi yv8y4rk", bold: "_1qt23exv _1qt23exj yv8y4rl", extrabold: "_1qt23exw _1qt23exk yv8y4rm" }, type: { accent: "_1qt23exx _1qt23exl yv8y4rr7 yv8y4rr8", regular: "_1qt23exy _1qt23exm yv8y4rrb yv8y4rrc", muted: "_1qt23exz _1qt23exn yv8y4rrd yv8y4rre", inverted: "_1qt23ex10 _1qt23exo yv8y4rr5 yv8y4rr6", white: "_1qt23ex11 _1qt23exp yv8y4rqz yv8y4rr0", danger: "_1qt23ex12 _1qt23exq yv8y4rrf yv8y4rrg" }, size: { large: "_1qt23ex13", medium: "_1qt23ex14", small: "_1qt23ex15" } }, defaultVariants: { type: "regular", size: "medium", weight: "medium" }, compoundVariants: [] });
const ue = ({ children: e, variant: t, className: n, ...r }) => /* @__PURE__ */ y.jsx(
  z,
  {
    as: "p",
    className: wr(n, ile(t)),
    ...r,
    children: e
  }
), to = ({ children: e, variant: t, className: n, ...r }) => /* @__PURE__ */ y.jsx(
  z,
  {
    as: (t == null ? void 0 : t.level) ?? "h1",
    className: wr(rle(t), n),
    ...r,
    children: e
  }
);
function ct(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(i) {
    if (e == null || e(i), n === !1 || !i.defaultPrevented)
      return t == null ? void 0 : t(i);
  };
}
function ole(e, t) {
  typeof e == "function" ? e(t) : e != null && (e.current = t);
}
function Gy(...e) {
  return (t) => e.forEach((n) => ole(n, t));
}
function _n(...e) {
  return P.useCallback(Gy(...e), e);
}
function sle(e, t) {
  const n = P.createContext(t);
  function r(o) {
    const { children: s, ...a } = o, l = P.useMemo(() => a, Object.values(a));
    return /* @__PURE__ */ y.jsx(n.Provider, { value: l, children: s });
  }
  function i(o) {
    const s = P.useContext(n);
    if (s) return s;
    if (t !== void 0) return t;
    throw new Error(`\`${o}\` must be used within \`${e}\``);
  }
  return r.displayName = e + "Provider", [r, i];
}
function Wa(e, t = []) {
  let n = [];
  function r(o, s) {
    const a = P.createContext(s), l = n.length;
    n = [...n, s];
    function c(d) {
      const { scope: f, children: h, ...p } = d, m = (f == null ? void 0 : f[e][l]) || a, g = P.useMemo(() => p, Object.values(p));
      return /* @__PURE__ */ y.jsx(m.Provider, { value: g, children: h });
    }
    function u(d, f) {
      const h = (f == null ? void 0 : f[e][l]) || a, p = P.useContext(h);
      if (p) return p;
      if (s !== void 0) return s;
      throw new Error(`\`${d}\` must be used within \`${o}\``);
    }
    return c.displayName = o + "Provider", [c, u];
  }
  const i = () => {
    const o = n.map((s) => P.createContext(s));
    return function(a) {
      const l = (a == null ? void 0 : a[e]) || o;
      return P.useMemo(
        () => ({ [`__scope${e}`]: { ...a, [e]: l } }),
        [a, l]
      );
    };
  };
  return i.scopeName = e, [r, ale(i, ...t)];
}
function ale(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(o) {
      const s = r.reduce((a, { useScope: l, scopeName: c }) => {
        const d = l(o)[`__scope${c}`];
        return { ...a, ...d };
      }, {});
      return P.useMemo(() => ({ [`__scope${t.scopeName}`]: s }), [s]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
var Na = globalThis != null && globalThis.document ? P.useLayoutEffect : () => {
}, lle = P.useId || (() => {
}), cle = 0;
function Ca(e) {
  const [t, n] = P.useState(lle());
  return Na(() => {
    n((r) => r ?? String(cle++));
  }, [e]), t ? `radix-${t}` : "";
}
function _i(e) {
  const t = P.useRef(e);
  return P.useEffect(() => {
    t.current = e;
  }), P.useMemo(() => (...n) => {
    var r;
    return (r = t.current) == null ? void 0 : r.call(t, ...n);
  }, []);
}
function Hy({
  prop: e,
  defaultProp: t,
  onChange: n = () => {
  }
}) {
  const [r, i] = ule({ defaultProp: t, onChange: n }), o = e !== void 0, s = o ? e : r, a = _i(n), l = P.useCallback(
    (c) => {
      if (o) {
        const d = typeof c == "function" ? c(e) : c;
        d !== e && a(d);
      } else
        i(c);
    },
    [o, e, i, a]
  );
  return [s, l];
}
function ule({
  defaultProp: e,
  onChange: t
}) {
  const n = P.useState(e), [r] = n, i = P.useRef(r), o = _i(t);
  return P.useEffect(() => {
    i.current !== r && (o(r), i.current = r);
  }, [r, i, o]), n;
}
var yc = P.forwardRef((e, t) => {
  const { children: n, ...r } = e, i = P.Children.toArray(n), o = i.find(dle);
  if (o) {
    const s = o.props.children, a = i.map((l) => l === o ? P.Children.count(s) > 1 ? P.Children.only(null) : P.isValidElement(s) ? s.props.children : null : l);
    return /* @__PURE__ */ y.jsx(m0, { ...r, ref: t, children: P.isValidElement(s) ? P.cloneElement(s, void 0, a) : null });
  }
  return /* @__PURE__ */ y.jsx(m0, { ...r, ref: t, children: n });
});
yc.displayName = "Slot";
var m0 = P.forwardRef((e, t) => {
  const { children: n, ...r } = e;
  if (P.isValidElement(n)) {
    const i = hle(n);
    return P.cloneElement(n, {
      ...fle(r, n.props),
      // @ts-ignore
      ref: t ? Gy(t, i) : i
    });
  }
  return P.Children.count(n) > 1 ? P.Children.only(null) : null;
});
m0.displayName = "SlotClone";
var WO = ({ children: e }) => /* @__PURE__ */ y.jsx(y.Fragment, { children: e });
function dle(e) {
  return P.isValidElement(e) && e.type === WO;
}
function fle(e, t) {
  const n = { ...t };
  for (const r in t) {
    const i = e[r], o = t[r];
    /^on[A-Z]/.test(r) ? i && o ? n[r] = (...a) => {
      o(...a), i(...a);
    } : i && (n[r] = i) : r === "style" ? n[r] = { ...i, ...o } : r === "className" && (n[r] = [i, o].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function hle(e) {
  var r, i;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var ple = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], un = ple.reduce((e, t) => {
  const n = P.forwardRef((r, i) => {
    const { asChild: o, ...s } = r, a = o ? yc : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ y.jsx(a, { ...s, ref: i });
  });
  return n.displayName = `Primitive.${t}`, { ...e, [t]: n };
}, {});
function GO(e, t) {
  e && Sp.flushSync(() => e.dispatchEvent(t));
}
function yle(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = _i(e);
  P.useEffect(() => {
    const r = (i) => {
      i.key === "Escape" && n(i);
    };
    return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 });
  }, [n, t]);
}
var mle = "DismissableLayer", g0 = "dismissableLayer.update", gle = "dismissableLayer.pointerDownOutside", vle = "dismissableLayer.focusOutside", X8, HO = P.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), Ky = P.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: i,
      onFocusOutside: o,
      onInteractOutside: s,
      onDismiss: a,
      ...l
    } = e, c = P.useContext(HO), [u, d] = P.useState(null), f = (u == null ? void 0 : u.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, h] = P.useState({}), p = _n(t, (A) => d(A)), m = Array.from(c.layers), [g] = [...c.layersWithOutsidePointerEventsDisabled].slice(-1), v = m.indexOf(g), w = u ? m.indexOf(u) : -1, x = c.layersWithOutsidePointerEventsDisabled.size > 0, C = w >= v, S = xle((A) => {
      const b = A.target, T = [...c.branches].some((R) => R.contains(b));
      !C || T || (i == null || i(A), s == null || s(A), A.defaultPrevented || a == null || a());
    }, f), k = Cle((A) => {
      const b = A.target;
      [...c.branches].some((R) => R.contains(b)) || (o == null || o(A), s == null || s(A), A.defaultPrevented || a == null || a());
    }, f);
    return yle((A) => {
      w === c.layers.size - 1 && (r == null || r(A), !A.defaultPrevented && a && (A.preventDefault(), a()));
    }, f), P.useEffect(() => {
      if (u)
        return n && (c.layersWithOutsidePointerEventsDisabled.size === 0 && (X8 = f.body.style.pointerEvents, f.body.style.pointerEvents = "none"), c.layersWithOutsidePointerEventsDisabled.add(u)), c.layers.add(u), Z8(), () => {
          n && c.layersWithOutsidePointerEventsDisabled.size === 1 && (f.body.style.pointerEvents = X8);
        };
    }, [u, f, n, c]), P.useEffect(() => () => {
      u && (c.layers.delete(u), c.layersWithOutsidePointerEventsDisabled.delete(u), Z8());
    }, [u, c]), P.useEffect(() => {
      const A = () => h({});
      return document.addEventListener(g0, A), () => document.removeEventListener(g0, A);
    }, []), /* @__PURE__ */ y.jsx(
      un.div,
      {
        ...l,
        ref: p,
        style: {
          pointerEvents: x ? C ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: ct(e.onFocusCapture, k.onFocusCapture),
        onBlurCapture: ct(e.onBlurCapture, k.onBlurCapture),
        onPointerDownCapture: ct(
          e.onPointerDownCapture,
          S.onPointerDownCapture
        )
      }
    );
  }
);
Ky.displayName = mle;
var ble = "DismissableLayerBranch", wle = P.forwardRef((e, t) => {
  const n = P.useContext(HO), r = P.useRef(null), i = _n(t, r);
  return P.useEffect(() => {
    const o = r.current;
    if (o)
      return n.branches.add(o), () => {
        n.branches.delete(o);
      };
  }, [n.branches]), /* @__PURE__ */ y.jsx(un.div, { ...e, ref: i });
});
wle.displayName = ble;
function xle(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = _i(e), r = P.useRef(!1), i = P.useRef(() => {
  });
  return P.useEffect(() => {
    const o = (a) => {
      if (a.target && !r.current) {
        let l = function() {
          KO(
            gle,
            n,
            c,
            { discrete: !0 }
          );
        };
        const c = { originalEvent: a };
        a.pointerType === "touch" ? (t.removeEventListener("click", i.current), i.current = l, t.addEventListener("click", i.current, { once: !0 })) : l();
      } else
        t.removeEventListener("click", i.current);
      r.current = !1;
    }, s = window.setTimeout(() => {
      t.addEventListener("pointerdown", o);
    }, 0);
    return () => {
      window.clearTimeout(s), t.removeEventListener("pointerdown", o), t.removeEventListener("click", i.current);
    };
  }, [t, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function Cle(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = _i(e), r = P.useRef(!1);
  return P.useEffect(() => {
    const i = (o) => {
      o.target && !r.current && KO(vle, n, { originalEvent: o }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", i), () => t.removeEventListener("focusin", i);
  }, [t, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function Z8() {
  const e = new CustomEvent(g0);
  document.dispatchEvent(e);
}
function KO(e, t, n, { discrete: r }) {
  const i = n.originalEvent.target, o = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && i.addEventListener(e, t, { once: !0 }), r ? GO(i, o) : i.dispatchEvent(o);
}
var Yg = "focusScope.autoFocusOnMount", Qg = "focusScope.autoFocusOnUnmount", eS = { bubbles: !1, cancelable: !0 }, kle = "FocusScope", sx = P.forwardRef((e, t) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: i,
    onUnmountAutoFocus: o,
    ...s
  } = e, [a, l] = P.useState(null), c = _i(i), u = _i(o), d = P.useRef(null), f = _n(t, (m) => l(m)), h = P.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  P.useEffect(() => {
    if (r) {
      let m = function(x) {
        if (h.paused || !a) return;
        const C = x.target;
        a.contains(C) ? d.current = C : rs(d.current, { select: !0 });
      }, g = function(x) {
        if (h.paused || !a) return;
        const C = x.relatedTarget;
        C !== null && (a.contains(C) || rs(d.current, { select: !0 }));
      }, v = function(x) {
        if (document.activeElement === document.body)
          for (const S of x)
            S.removedNodes.length > 0 && rs(a);
      };
      document.addEventListener("focusin", m), document.addEventListener("focusout", g);
      const w = new MutationObserver(v);
      return a && w.observe(a, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", m), document.removeEventListener("focusout", g), w.disconnect();
      };
    }
  }, [r, a, h.paused]), P.useEffect(() => {
    if (a) {
      nS.add(h);
      const m = document.activeElement;
      if (!a.contains(m)) {
        const v = new CustomEvent(Yg, eS);
        a.addEventListener(Yg, c), a.dispatchEvent(v), v.defaultPrevented || (Ele(Ile(YO(a)), { select: !0 }), document.activeElement === m && rs(a));
      }
      return () => {
        a.removeEventListener(Yg, c), setTimeout(() => {
          const v = new CustomEvent(Qg, eS);
          a.addEventListener(Qg, u), a.dispatchEvent(v), v.defaultPrevented || rs(m ?? document.body, { select: !0 }), a.removeEventListener(Qg, u), nS.remove(h);
        }, 0);
      };
    }
  }, [a, c, u, h]);
  const p = P.useCallback(
    (m) => {
      if (!n && !r || h.paused) return;
      const g = m.key === "Tab" && !m.altKey && !m.ctrlKey && !m.metaKey, v = document.activeElement;
      if (g && v) {
        const w = m.currentTarget, [x, C] = Sle(w);
        x && C ? !m.shiftKey && v === C ? (m.preventDefault(), n && rs(x, { select: !0 })) : m.shiftKey && v === x && (m.preventDefault(), n && rs(C, { select: !0 })) : v === w && m.preventDefault();
      }
    },
    [n, r, h.paused]
  );
  return /* @__PURE__ */ y.jsx(un.div, { tabIndex: -1, ...s, ref: f, onKeyDown: p });
});
sx.displayName = kle;
function Ele(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const r of e)
    if (rs(r, { select: t }), document.activeElement !== n) return;
}
function Sle(e) {
  const t = YO(e), n = tS(t, e), r = tS(t.reverse(), e);
  return [n, r];
}
function YO(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const i = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function tS(e, t) {
  for (const n of e)
    if (!Ale(n, { upTo: t })) return n;
}
function Ale(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function Tle(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function rs(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== n && Tle(e) && t && e.select();
  }
}
var nS = _le();
function _le() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && (n == null || n.pause()), e = rS(e, t), e.unshift(t);
    },
    remove(t) {
      var n;
      e = rS(e, t), (n = e[0]) == null || n.resume();
    }
  };
}
function rS(e, t) {
  const n = [...e], r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
function Ile(e) {
  return e.filter((t) => t.tagName !== "A");
}
var Rle = "Portal", ax = P.forwardRef((e, t) => {
  var a;
  const { container: n, ...r } = e, [i, o] = P.useState(!1);
  Na(() => o(!0), []);
  const s = n || i && ((a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : a.body);
  return s ? cA.createPortal(/* @__PURE__ */ y.jsx(un.div, { ...r, ref: t }), s) : null;
});
ax.displayName = Rle;
function Ple(e, t) {
  return P.useReducer((n, r) => t[n][r] ?? n, e);
}
var zo = (e) => {
  const { present: t, children: n } = e, r = Ole(t), i = typeof n == "function" ? n({ present: r.isPresent }) : P.Children.only(n), o = _n(r.ref, Ble(i));
  return typeof n == "function" || r.isPresent ? P.cloneElement(i, { ref: o }) : null;
};
zo.displayName = "Presence";
function Ole(e) {
  const [t, n] = P.useState(), r = P.useRef({}), i = P.useRef(e), o = P.useRef("none"), s = e ? "mounted" : "unmounted", [a, l] = Ple(s, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return P.useEffect(() => {
    const c = Zf(r.current);
    o.current = a === "mounted" ? c : "none";
  }, [a]), Na(() => {
    const c = r.current, u = i.current;
    if (u !== e) {
      const f = o.current, h = Zf(c);
      e ? l("MOUNT") : h === "none" || (c == null ? void 0 : c.display) === "none" ? l("UNMOUNT") : l(u && f !== h ? "ANIMATION_OUT" : "UNMOUNT"), i.current = e;
    }
  }, [e, l]), Na(() => {
    if (t) {
      const c = (d) => {
        const h = Zf(r.current).includes(d.animationName);
        d.target === t && h && Sp.flushSync(() => l("ANIMATION_END"));
      }, u = (d) => {
        d.target === t && (o.current = Zf(r.current));
      };
      return t.addEventListener("animationstart", u), t.addEventListener("animationcancel", c), t.addEventListener("animationend", c), () => {
        t.removeEventListener("animationstart", u), t.removeEventListener("animationcancel", c), t.removeEventListener("animationend", c);
      };
    } else
      l("ANIMATION_END");
  }, [t, l]), {
    isPresent: ["mounted", "unmountSuspended"].includes(a),
    ref: P.useCallback((c) => {
      c && (r.current = getComputedStyle(c)), n(c);
    }, [])
  };
}
function Zf(e) {
  return (e == null ? void 0 : e.animationName) || "none";
}
function Ble(e) {
  var r, i;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var Jg = 0;
function QO() {
  P.useEffect(() => {
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e[0] ?? iS()), document.body.insertAdjacentElement("beforeend", e[1] ?? iS()), Jg++, () => {
      Jg === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), Jg--;
    };
  }, []);
}
function iS() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none", e;
}
var Nle = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, il = /* @__PURE__ */ new WeakMap(), eh = /* @__PURE__ */ new WeakMap(), th = {}, Xg = 0, JO = function(e) {
  return e && (e.host || JO(e.parentNode));
}, Dle = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var r = JO(n);
    return r && e.contains(r) ? r : null;
  }).filter(function(n) {
    return !!n;
  });
}, jle = function(e, t, n, r) {
  var i = Dle(t, Array.isArray(e) ? e : [e]);
  th[n] || (th[n] = /* @__PURE__ */ new WeakMap());
  var o = th[n], s = [], a = /* @__PURE__ */ new Set(), l = new Set(i), c = function(d) {
    !d || a.has(d) || (a.add(d), c(d.parentNode));
  };
  i.forEach(c);
  var u = function(d) {
    !d || l.has(d) || Array.prototype.forEach.call(d.children, function(f) {
      if (a.has(f))
        u(f);
      else {
        var h = f.getAttribute(r), p = h !== null && h !== "false", m = (il.get(f) || 0) + 1, g = (o.get(f) || 0) + 1;
        il.set(f, m), o.set(f, g), s.push(f), m === 1 && p && eh.set(f, !0), g === 1 && f.setAttribute(n, "true"), p || f.setAttribute(r, "true");
      }
    });
  };
  return u(t), a.clear(), Xg++, function() {
    s.forEach(function(d) {
      var f = il.get(d) - 1, h = o.get(d) - 1;
      il.set(d, f), o.set(d, h), f || (eh.has(d) || d.removeAttribute(r), eh.delete(d)), h || d.removeAttribute(n);
    }), Xg--, Xg || (il = /* @__PURE__ */ new WeakMap(), il = /* @__PURE__ */ new WeakMap(), eh = /* @__PURE__ */ new WeakMap(), th = {});
  };
}, XO = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(e) ? e : [e]), i = Nle(e);
  return i ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live]"))), jle(r, i, n, "aria-hidden")) : function() {
    return null;
  };
}, lx = "Dialog", [ZO, xbe] = Wa(lx), [Mle, Ni] = ZO(lx), e6 = (e) => {
  const {
    __scopeDialog: t,
    children: n,
    open: r,
    defaultOpen: i,
    onOpenChange: o,
    modal: s = !0
  } = e, a = P.useRef(null), l = P.useRef(null), [c = !1, u] = Hy({
    prop: r,
    defaultProp: i,
    onChange: o
  });
  return /* @__PURE__ */ y.jsx(
    Mle,
    {
      scope: t,
      triggerRef: a,
      contentRef: l,
      contentId: Ca(),
      titleId: Ca(),
      descriptionId: Ca(),
      open: c,
      onOpenChange: u,
      onOpenToggle: P.useCallback(() => u((d) => !d), [u]),
      modal: s,
      children: n
    }
  );
};
e6.displayName = lx;
var t6 = "DialogTrigger", n6 = P.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Ni(t6, n), o = _n(t, i.triggerRef);
    return /* @__PURE__ */ y.jsx(
      un.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": i.open,
        "aria-controls": i.contentId,
        "data-state": dx(i.open),
        ...r,
        ref: o,
        onClick: ct(e.onClick, i.onOpenToggle)
      }
    );
  }
);
n6.displayName = t6;
var cx = "DialogPortal", [Fle, r6] = ZO(cx, {
  forceMount: void 0
}), i6 = (e) => {
  const { __scopeDialog: t, forceMount: n, children: r, container: i } = e, o = Ni(cx, t);
  return /* @__PURE__ */ y.jsx(Fle, { scope: t, forceMount: n, children: P.Children.map(r, (s) => /* @__PURE__ */ y.jsx(zo, { present: n || o.open, children: /* @__PURE__ */ y.jsx(ax, { asChild: !0, container: i, children: s }) })) });
};
i6.displayName = cx;
var dp = "DialogOverlay", o6 = P.forwardRef(
  (e, t) => {
    const n = r6(dp, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, o = Ni(dp, e.__scopeDialog);
    return o.modal ? /* @__PURE__ */ y.jsx(zo, { present: r || o.open, children: /* @__PURE__ */ y.jsx(Lle, { ...i, ref: t }) }) : null;
  }
);
o6.displayName = dp;
var Lle = P.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Ni(dp, n);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ y.jsx(ly, { as: yc, allowPinchZoom: !0, shards: [i.contentRef], children: /* @__PURE__ */ y.jsx(
        un.div,
        {
          "data-state": dx(i.open),
          ...r,
          ref: t,
          style: { pointerEvents: "auto", ...r.style }
        }
      ) })
    );
  }
), Da = "DialogContent", s6 = P.forwardRef(
  (e, t) => {
    const n = r6(Da, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, o = Ni(Da, e.__scopeDialog);
    return /* @__PURE__ */ y.jsx(zo, { present: r || o.open, children: o.modal ? /* @__PURE__ */ y.jsx(Ule, { ...i, ref: t }) : /* @__PURE__ */ y.jsx(zle, { ...i, ref: t }) });
  }
);
s6.displayName = Da;
var Ule = P.forwardRef(
  (e, t) => {
    const n = Ni(Da, e.__scopeDialog), r = P.useRef(null), i = _n(t, n.contentRef, r);
    return P.useEffect(() => {
      const o = r.current;
      if (o) return XO(o);
    }, []), /* @__PURE__ */ y.jsx(
      a6,
      {
        ...e,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: ct(e.onCloseAutoFocus, (o) => {
          var s;
          o.preventDefault(), (s = n.triggerRef.current) == null || s.focus();
        }),
        onPointerDownOutside: ct(e.onPointerDownOutside, (o) => {
          const s = o.detail.originalEvent, a = s.button === 0 && s.ctrlKey === !0;
          (s.button === 2 || a) && o.preventDefault();
        }),
        onFocusOutside: ct(
          e.onFocusOutside,
          (o) => o.preventDefault()
        )
      }
    );
  }
), zle = P.forwardRef(
  (e, t) => {
    const n = Ni(Da, e.__scopeDialog), r = P.useRef(!1), i = P.useRef(!1);
    return /* @__PURE__ */ y.jsx(
      a6,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (o) => {
          var s, a;
          (s = e.onCloseAutoFocus) == null || s.call(e, o), o.defaultPrevented || (r.current || (a = n.triggerRef.current) == null || a.focus(), o.preventDefault()), r.current = !1, i.current = !1;
        },
        onInteractOutside: (o) => {
          var l, c;
          (l = e.onInteractOutside) == null || l.call(e, o), o.defaultPrevented || (r.current = !0, o.detail.originalEvent.type === "pointerdown" && (i.current = !0));
          const s = o.target;
          ((c = n.triggerRef.current) == null ? void 0 : c.contains(s)) && o.preventDefault(), o.detail.originalEvent.type === "focusin" && i.current && o.preventDefault();
        }
      }
    );
  }
), a6 = P.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: i, onCloseAutoFocus: o, ...s } = e, a = Ni(Da, n), l = P.useRef(null), c = _n(t, l);
    return QO(), /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      /* @__PURE__ */ y.jsx(
        sx,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: i,
          onUnmountAutoFocus: o,
          children: /* @__PURE__ */ y.jsx(
            Ky,
            {
              role: "dialog",
              id: a.contentId,
              "aria-describedby": a.descriptionId,
              "aria-labelledby": a.titleId,
              "data-state": dx(a.open),
              ...s,
              ref: c,
              onDismiss: () => a.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
        /* @__PURE__ */ y.jsx($le, { titleId: a.titleId }),
        /* @__PURE__ */ y.jsx(Gle, { contentRef: l, descriptionId: a.descriptionId })
      ] })
    ] });
  }
), ux = "DialogTitle", l6 = P.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Ni(ux, n);
    return /* @__PURE__ */ y.jsx(un.h2, { id: i.titleId, ...r, ref: t });
  }
);
l6.displayName = ux;
var c6 = "DialogDescription", Vle = P.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Ni(c6, n);
    return /* @__PURE__ */ y.jsx(un.p, { id: i.descriptionId, ...r, ref: t });
  }
);
Vle.displayName = c6;
var u6 = "DialogClose", qle = P.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Ni(u6, n);
    return /* @__PURE__ */ y.jsx(
      un.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: ct(e.onClick, () => i.onOpenChange(!1))
      }
    );
  }
);
qle.displayName = u6;
function dx(e) {
  return e ? "open" : "closed";
}
var d6 = "DialogTitleWarning", [Cbe, f6] = sle(d6, {
  contentName: Da,
  titleName: ux,
  docsSlug: "dialog"
}), $le = ({ titleId: e }) => {
  const t = f6(d6), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
  return P.useEffect(() => {
    if (e) {
      const r = document.getElementById(e);
    }
  }, [n, e]), null;
}, Wle = "DialogDescriptionWarning", Gle = ({ contentRef: e, descriptionId: t }) => {
  const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${f6(Wle).contentName}}.`;
  return P.useEffect(() => {
    var o;
    const i = (o = e.current) == null ? void 0 : o.getAttribute("aria-describedby");
    if (t && i) {
      const s = document.getElementById(t);
    }
  }, [r, e, t]), null;
}, Hle = e6, mc = n6, Kle = i6, Yle = o6, Qle = s6, oS = l6, Jle = "VisuallyHidden", h6 = P.forwardRef(
  (e, t) => /* @__PURE__ */ y.jsx(
    un.span,
    {
      ...e,
      ref: t,
      style: {
        // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
        position: "absolute",
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        ...e.style
      }
    }
  )
);
h6.displayName = Jle;
var p6 = h6;
const Yy = "stakekit", v0 = `[data-rk="${Yy}"]`;
var Xle = $c({ defaultClassName: "asebzi1 asebzi0 yv8y4re6 yv8y4re3 yv8y4rco yv8y4rcl yv8y4r9l yv8y4rb3 yv8y4r2n yv8y4rg3 yv8y4rfj yv8y4rx yv8y4r1a yv8y4rvv yv8y4rvw", variantClassNames: { hover: { disabled: "asebzi2", enabled: "asebzi3" }, type: { disabled: "asebzi4", enabled: "asebzi5" } }, defaultVariants: { hover: "enabled", type: "enabled" }, compoundVariants: [] });
const Qy = ({
  children: e,
  onClick: t,
  testId: n,
  variant: r,
  className: i,
  ...o
}) => /* @__PURE__ */ y.jsx(
  z,
  {
    className: wr(Xle(r), i),
    onClick: t,
    "data-testid": n,
    ...o,
    children: e
  }
);
var Zle = "_7eq6502", ece = "_7eq6503", tce = "_7eq6505 _7eq6504 yv8y4r9n yv8y4rb5 yv8y4rj7 yv8y4rwv yv8y4rww", nce = "_7eq6506", rce = "_7eq6507";
const y6 = Ge(
  void 0
), m6 = () => {
  const e = we(y6);
  if (!e)
    throw new Error("SelectModalContext is not provided");
  return e;
}, ice = ({
  children: e,
  trigger: t,
  title: n,
  onSearch: r,
  searchValue: i,
  inputPlaceholder: o,
  onClose: s,
  onOpen: a,
  isLoading: l,
  errorMessage: c,
  disableClose: u,
  hideTopBar: d
}) => {
  const { isOpen: f, setOpen: h } = m6(), p = Dt(s), m = Dt(a);
  Te(() => {
    var v, w;
    f ? (w = m.current) == null || w.call(m) : (v = p.current) == null || v.call(p);
  }, [f, p, m]);
  const g = !!n || !d || r;
  return /* @__PURE__ */ y.jsxs(Hle, { open: f, onOpenChange: h, children: [
    t,
    /* @__PURE__ */ y.jsx(Kle, { children: /* @__PURE__ */ y.jsxs(z, { className: Zle, "data-select-modal": !0, "data-rk": Yy, children: [
      /* @__PURE__ */ y.jsx(Yle, { onClick: () => h(!1), className: ece }),
      /* @__PURE__ */ y.jsx(
        Qle,
        {
          "data-testid": "select-modal__container",
          className: tce,
          "aria-describedby": void 0,
          children: /* @__PURE__ */ y.jsxs(z, { display: "flex", flexDirection: "column", height: "full", children: [
            g && /* @__PURE__ */ y.jsxs(
              z,
              {
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                px: "4",
                children: [
                  /* @__PURE__ */ y.jsxs(z, { flex: 1, display: "flex", alignItems: "center", gap: "2", children: [
                    n ? /* @__PURE__ */ y.jsx(oS, { children: /* @__PURE__ */ y.jsx(
                      ue,
                      {
                        "data-testid": "select-modal__title",
                        variant: { weight: "bold", size: "large" },
                        children: n
                      }
                    ) }) : /* @__PURE__ */ y.jsx(p6, { asChild: !0, children: /* @__PURE__ */ y.jsx(oS, { children: "Selection Modal" }) }),
                    l && /* @__PURE__ */ y.jsx(ei, {})
                  ] }),
                  !u && /* @__PURE__ */ y.jsx(z, { as: "button", onClick: () => h(!1), children: /* @__PURE__ */ y.jsx(Il, {}) })
                ]
              }
            ),
            r && /* @__PURE__ */ y.jsxs(
              z,
              {
                display: "flex",
                mx: "4",
                my: "2",
                background: "tokenSelectBackground",
                borderRadius: "xl",
                alignItems: "center",
                as: "label",
                children: [
                  /* @__PURE__ */ y.jsx(z, { mx: "3", display: "flex", alignItems: "center", children: /* @__PURE__ */ y.jsx($ae, {}) }),
                  /* @__PURE__ */ y.jsx(
                    z,
                    {
                      "data-testid": "select-modal__search-input",
                      className: nce,
                      as: "input",
                      border: "none",
                      flex: 1,
                      py: "3",
                      borderRadius: "xl",
                      color: "text",
                      placeholder: o ?? "",
                      value: i,
                      onChange: (v) => r(v.target.value)
                    }
                  )
                ]
              }
            ),
            !!c && /* @__PURE__ */ y.jsx(
              z,
              {
                display: "flex",
                justifyContent: "center",
                marginTop: "4",
                marginBottom: "2",
                children: /* @__PURE__ */ y.jsx(ue, { variant: { type: "danger" }, children: c })
              }
            ),
            e
          ] })
        }
      )
    ] }) })
  ] });
}, qs = ({ state: e, ...t }) => {
  const [n, r] = Oe(!1), i = J(
    () => e ?? {
      isOpen: n,
      setOpen: (o) => r(o)
    },
    [n, e]
  );
  return /* @__PURE__ */ y.jsx(y6.Provider, { value: i, children: /* @__PURE__ */ y.jsx(ice, { ...t }) });
}, gc = ({ children: e }) => /* @__PURE__ */ y.jsx(z, { mx: "4", className: rce, children: e }), Jy = ({
  children: e,
  onItemClick: t,
  testId: n,
  variant: r
}) => {
  const { setOpen: i } = m6(), o = () => t == null ? void 0 : t({ closeModal: () => i(!1) });
  return /* @__PURE__ */ y.jsx(Qy, { variant: r, onClick: o, testId: n, children: e });
}, g6 = Ge(
  void 0
), oce = ({ children: e }) => {
  const [t, n] = Oe(null);
  return js(() => {
    lc.chainNullable(
      (r) => r.querySelector(v0)
    ).ifJust((r) => n(r));
  }, []), /* @__PURE__ */ y.jsx(g6.Provider, { value: t, children: e });
}, sce = () => {
  const e = we(g6);
  if (e === void 0)
    throw new Error("RootElementProvider not found in the tree");
  return e;
};
var ace = "var(--sk-font-size-3xl)", lce = "_1s53f1w3 _1s53f1w1 _1s53f1w0 yv8y4ri _1s53f1w2 yv8y4r1a yv8y4rjh yv8y4rrb yv8y4rrc", cce = "_1s53f1w4 _1s53f1w1 _1s53f1w0 yv8y4ri", uce = "_1s53f1w5";
const fp = (e) => {
  const t = It(null), n = It(null);
  return Te(() => {
    t.current = n.current, n.current = e;
  }, [e]), e === n.current ? t.current : n.current;
}, dce = ({
  inputVal: e,
  inputRef: t,
  spanRef: n
}) => {
  const r = fp(e), { disableResizingInputFontSize: i } = bt();
  Te(() => {
    if (!t.current || !n.current || !r || e.length === r.length || i)
      return;
    const o = fce({
      inputEl: t.current,
      spanEl: n.current
    });
    t.current.style.fontSize = `${o}px`, n.current.style.fontSize = `${o}px`;
  }, [t, e, r, n, i]);
}, fce = ({
  inputEl: e,
  spanEl: t
}) => Tn.map((n) => {
  const r = e.offsetWidth, i = pce(e);
  let o = Number.parseFloat(
    n.getComputedStyle(t).fontSize
  );
  for (const s of i)
    if (t.style.fontSize = `${s}px`, t.offsetWidth < r) {
      o = s;
      break;
    }
  return o;
}).extractNullable(), hce = (e) => e * Number.parseFloat(
  lc.map(
    (t) => getComputedStyle(t.documentElement).fontSize
  ).orDefault("0")
), pce = (e) => Tn.map(
  (t) => [
    ace,
    zt.fontSize["2xl"],
    zt.fontSize.xl,
    zt.fontSize.lgx,
    zt.fontSize.lg
  ].map(
    (n) => hce(
      Number.parseFloat(
        t.getComputedStyle(e).getPropertyValue(n.replace(/(var\()|(\))/g, ""))
      )
    )
  )
).orDefault([]), v6 = Td(
  ({
    onChange: e,
    value: t,
    disabled: n,
    onBlur: r,
    isInvalid: i,
    shakeOnInvalid: o
  }) => {
    const [s, a] = Oe("0"), [l, c] = Oe(!1);
    Te(() => {
      l || a((g) => t.isEqualTo(sS(g)) ? g : Sn(t));
    }, [t, l]);
    const u = (g) => {
      const v = g.target.value;
      if (!g.target.validity.valid) return;
      if (a(v), !v) return e(new Re(0));
      const w = sS(v);
      w.isNaN() || e(w);
    }, d = s === "0" || s === "", f = It(null), h = It(null);
    dce({
      inputRef: f,
      spanRef: h,
      inputVal: s
    });
    const p = sce(), m = Moe();
    return Te(() => {
      !o || !i || m.start("shake");
    }, [m, i, o]), /* @__PURE__ */ y.jsxs(
      Zt.div,
      {
        animate: m,
        variants: {
          shake: {
            rotate: [-1.5, 1.5, 0],
            transition: { repeat: 3, duration: 0.12, ease: "easeInOut" }
          }
        },
        className: uce,
        children: [
          /* @__PURE__ */ y.jsx(
            z,
            {
              as: "input",
              color: o && i ? "textDanger" : "text",
              disabled: n,
              name: "stake-amount",
              ref: f,
              "data-testid": "number-input",
              type: "text",
              inputMode: "decimal",
              className: lce,
              value: s,
              onChange: u,
              autoComplete: "off",
              autoCorrect: "off",
              spellCheck: "false",
              pattern: "^(?!0\\d)\\d*([.,])?(\\d+)?$",
              minLength: 1,
              maxLength: 79,
              onBlur: () => {
                c(!1), d && a("0"), r == null || r();
              },
              onFocus: () => {
                c(!0), d && a("");
              }
            }
          ),
          p && uA(
            /* @__PURE__ */ y.jsx("span", { ref: h, className: cce, children: s }),
            p
          )
        ]
      }
    );
  }
), sS = (e) => new Re(e.replace(/,/g, ".")), yce = ({
  height: e,
  width: t
}) => /* @__PURE__ */ y.jsxs(
  "svg",
  {
    width: t ?? 16,
    height: e ?? 16,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 16 16",
    children: [
      /* @__PURE__ */ y.jsx(
        "path",
        {
          d: "M10.75 6.5 7.081 10 5.25 8.25",
          stroke: zt.color.text,
          strokeWidth: 2,
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ),
      /* @__PURE__ */ y.jsx(
        "path",
        {
          d: "M8 14A6 6 0 1 0 8 2a6 6 0 0 0 0 12Z",
          stroke: zt.color.text,
          strokeWidth: 2,
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      )
    ]
  }
), nh = /* @__PURE__ */ new Set(), Ii = ({
  fallback: e,
  src: t,
  containerProps: n,
  imageProps: r
}) => {
  const [i, o] = Oe(() => ({
    src: t,
    loaded: !1,
    timeoutFallback: !1
  }));
  i.src !== t && o({ src: t, loaded: !1, timeoutFallback: !1 }), Te(() => {
    if (t && nh.has(t)) return;
    const c = setTimeout(() => {
      o((u) => ({ ...u, timeoutFallback: !0 }));
    }, 500);
    return () => clearTimeout(c);
  }, [t]);
  const s = (c) => {
    var u;
    o((d) => ({ ...d, loaded: !0 })), (u = r == null ? void 0 : r.onLoad) == null || u.call(r, c);
  }, a = (c) => {
    var u;
    t && nh.add(t), (u = r == null ? void 0 : r.onError) == null || u.call(r, c);
  }, l = J(
    () => (t && nh.has(t) || i.timeoutFallback && !i.loaded) && $l(e),
    [e, i.loaded, i.timeoutFallback, t]
  );
  return /* @__PURE__ */ y.jsxs(
    z,
    {
      ...n,
      position: "relative",
      display: "flex",
      justifyContent: "center",
      children: [
        l && /* @__PURE__ */ y.jsx(z, { position: "absolute", children: e }),
        !!(t && !nh.has(t)) && /* @__PURE__ */ y.jsx(
          z,
          {
            ...r,
            src: t,
            as: "img",
            style: { visibility: i.loaded ? "visible" : "hidden" },
            onLoad: s,
            onError: a
          }
        )
      ]
    }
  );
};
function aS(e) {
  var t = e.match(/^var\((.*)\)$/);
  return t ? t[1] : e;
}
function mce(e, t) {
  var n = e;
  for (var r of t) {
    if (!(r in n))
      throw new Error("Path ".concat(t.join(" -> "), " does not exist in object"));
    n = n[r];
  }
  return n;
}
function b6(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], r = {};
  for (var i in e) {
    var o = e[i], s = [...n, i];
    typeof o == "string" || typeof o == "number" || o == null ? r[i] = t(o, s) : typeof o == "object" && !Array.isArray(o) && (r[i] = b6(o, t, s));
  }
  return r;
}
function b0(e, t) {
  var n = {};
  if (typeof t == "object") {
    var r = e;
    b6(t, (a, l) => {
      if (a != null) {
        var c = mce(r, l);
        n[aS(c)] = String(a);
      }
    });
  } else {
    var i = e;
    for (var o in i) {
      var s = i[o];
      s != null && (n[aS(o)] = s);
    }
  }
  return Object.defineProperty(n, "toString", {
    value: function() {
      return Object.keys(this).map((l) => "".concat(l, ":").concat(this[l])).join(";");
    },
    writable: !1
  }), n;
}
var gce = "var(--_3w72kd0)", vce = "_3w72kd1";
const Vo = ({
  name: e,
  tokenLogoHw: t,
  textVariant: n
}) => /* @__PURE__ */ y.jsx(
  z,
  {
    className: vce,
    borderRadius: "half",
    style: b0({
      [gce]: pL(e)
    }),
    hw: t ?? "9",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    children: /* @__PURE__ */ y.jsx(
      ue,
      {
        variant: n ?? {
          size: "large",
          type: "white",
          weight: "bold"
        },
        children: e.charAt(0).toUpperCase()
      }
    )
  }
);
var bce = "_6teug80", wce = "_6teug81";
const w6 = ({
  networkLogoUri: e,
  tokenNetworkLogoHw: t = "3"
}) => /* @__PURE__ */ y.jsx(z, { className: bce, "data-rk": "token-network-logo", children: /* @__PURE__ */ y.jsx(
  Ii,
  {
    src: e,
    fallback: null,
    containerProps: { hw: t },
    imageProps: { className: wce }
  }
) }), xce = (e, t) => {
  const { variant: n } = bt();
  return J(() => {
    var i;
    return t ? {
      mainUrl: G.fromFalsy(n === "zerion").filter(
        () => Cce.some((s) => t.logoURI.endsWith(s))
      ).map(() => lS).orDefault(t.logoURI),
      fallbackUrl: t.logoURI ?? e.logoURI,
      name: t.name,
      providerIcon: (i = t.provider) == null ? void 0 : i.logoURI
    } : {
      mainUrl: G.fromFalsy(n === "zerion").map(() => e.address && e.symbol === "MATIC" ? kce(e.address) : e.symbol === "ETH" ? lS : e.logoURI).orDefault(e.logoURI),
      fallbackUrl: e.logoURI,
      name: e.name,
      providerIcon: void 0
    };
  }, [e, t, n]);
}, Cce = ["/tokens/eth.svg", "/tokens/steth2.svg"], kce = (e) => `${Vt.zerion.iconsByAddress}${e}.png`, lS = `${Vt.zerion.iconsByAddress}eth.png`, x6 = ({
  token: e,
  metadata: t,
  hideNetwork: n,
  children: r
}) => {
  const { mainUrl: i, fallbackUrl: o, name: s, providerIcon: a } = xce(
    e,
    t
  ), l = hs(e.network);
  return /* @__PURE__ */ y.jsx(
    z,
    {
      position: "relative",
      marginRight: n ? "0" : "2",
      display: "flex",
      children: r({ mainUrl: i, fallbackUrl: o, name: s, networkLogoUri: l, providerIcon: a })
    }
  );
}, C6 = ({
  mainUrl: e,
  fallbackUrl: t,
  name: n,
  tokenLogoHw: r = "9"
}) => /* @__PURE__ */ y.jsx(
  Ii,
  {
    "data-rk": "token-logo",
    containerProps: { hw: r, "data-rk": "token-logo" },
    src: e,
    fallback: /* @__PURE__ */ y.jsx(
      Ii,
      {
        "data-rk": "token-logo",
        containerProps: { hw: r, "data-rk": "token-logo" },
        src: t,
        fallback: /* @__PURE__ */ y.jsx(Vo, { name: n, tokenLogoHw: r })
      }
    )
  }
), No = ({
  token: e,
  metadata: t,
  tokenLogoHw: n,
  tokenNetworkLogoHw: r,
  hideNetwork: i
}) => {
  const { hideNetworkLogo: o } = bt();
  return /* @__PURE__ */ y.jsx(
    x6,
    {
      hideNetwork: i,
      token: e,
      metadata: t,
      children: ({ fallbackUrl: s, mainUrl: a, name: l, networkLogoUri: c }) => /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
        /* @__PURE__ */ y.jsx(
          C6,
          {
            fallbackUrl: s,
            mainUrl: a,
            name: l,
            tokenLogoHw: n
          }
        ),
        !i && !o && /* @__PURE__ */ y.jsx(
          w6,
          {
            networkLogoUri: c,
            tokenNetworkLogoHw: r
          }
        )
      ] })
    }
  );
}, ff = ({ children: e }) => /* @__PURE__ */ y.jsx(
  Zt.div,
  {
    initial: { opacity: 0, scale: 1, translateY: "-15px" },
    animate: {
      opacity: 1,
      translateY: 0,
      transition: { duration: 0.5, delay: 0.1 }
    },
    exit: {
      opacity: 0,
      filter: "blur(8px)",
      scale: 0.8,
      transition: { duration: 0.4 }
    },
    children: e
  }
), Zg = Symbol("cachedRes"), Ece = (e) => {
  const t = /* @__PURE__ */ new Map();
  return (...r) => {
    let i = t;
    for (const s of r)
      if (i.has(s))
        i = i.get(s);
      else {
        const a = /* @__PURE__ */ new Map();
        i.set(s, a), i = a;
      }
    if (i.has(Zg))
      return i.get(Zg).cachedRes;
    const o = e(...r);
    return i.set(Zg, { cachedRes: o }), o;
  };
}, k6 = Ece(
  (e) => e.charAt(0).toUpperCase() + e.slice(1).toLowerCase()
), E6 = Ge(void 0), Sce = ({ children: e }) => {
  const [t, n] = Oe(null), { pathname: r } = Bi(), i = Dt(r), o = Ie(
    ({ height: a, pathname: l }) => {
      i.current === l && n({ pathname: l, height: a });
    },
    [i]
  ), s = J(
    () => ({ state: t, setState: o }),
    [o, t]
  );
  return /* @__PURE__ */ y.jsx(E6.Provider, { value: s, children: e });
}, S6 = () => {
  const e = we(E6);
  if (!e)
    throw new Error(
      "useCurrentLayout must be used within a CurrentLayoutContextProvider"
    );
  return e;
};
var Ace = "_1qbrdb71 _1qbrdb70 yv8y4re5 yv8y4rcn", Tce = "_1qbrdb72";
const _ce = ({ currentPathname: e }) => {
  const { setState: t } = S6(), { containerRef: n } = Wy((r) => {
    r !== 0 && t({ pathname: e, height: r });
  });
  return /* @__PURE__ */ y.jsx(
    Zt.div,
    {
      layout: "position",
      ref: n,
      className: Tce,
      children: /* @__PURE__ */ y.jsx(nx, {})
    }
  );
}, $s = ({
  children: e,
  ...t
}) => /* @__PURE__ */ y.jsx(
  z,
  {
    "data-rk": "page-container",
    display: "flex",
    flexDirection: "column",
    px: "4",
    marginBottom: "4",
    flex: 1,
    paddingTop: "2",
    ...t,
    children: e
  }
), Ice = () => ni("activity/unstake/complete") || ni("activity/unstake-review/complete"), Rce = () => ni("activity/pending/complete") || ni("activity/pending-review/complete"), Pce = () => ni("activity/stake-review/complete") || ni("activity/unstake-review/complete") || ni("activity/pending-review/complete"), fx = (e) => ni(`positions/:integrationId/:balanceId/${e ?? "*"}`), Oce = (e) => fx("pending-action/*"), Bce = (e) => fx("unstake/*"), [hx, Nce] = df(0), [A6, Dce] = df(null), jce = () => Wy(hx()[1]), Ga = (e) => {
  const [, t] = A6(), n = hre();
  Bo(() => {
    n || t((r) => r === e ? null : r);
  }, [n, t, e]), Bo(() => {
    if (!(!n || e != null && e.hide))
      return t(e), () => {
        t((r) => r === e ? null : r);
      };
  }, [t, e]);
}, Mce = () => {
  var h;
  const e = er(), n = ((h = Bi().state) == null ? void 0 : h.urls) ?? [], r = cn(), i = () => {
    e("/");
  }, o = (p) => Tn.ifJust((m) => {
    r("viewTxClicked"), m.open(p, "_blank");
  }), s = Bce(), a = Oce(), l = Ice(), c = Rce(), u = Pce(), d = Dt(i), { t: f } = ze();
  return Ga(
    J(
      () => ({
        disabled: !1,
        isLoading: !1,
        label: f("shared.ok"),
        onClick: () => d.current(),
        hide: !!u
      }),
      [d, f, u]
    )
  ), {
    urls: n,
    unstakeMatch: s || l,
    pendingActionMatch: a || c,
    onViewTransactionClick: o
  };
}, Xy = ({
  amount: e,
  metadata: t,
  network: n,
  token: r,
  pendingActionType: i,
  yieldType: o,
  providersDetails: s
}) => {
  const { t: a } = ze(), { onViewTransactionClick: l, unstakeMatch: c, pendingActionMatch: u, urls: d } = Mce();
  return /* @__PURE__ */ y.jsx(ff, { children: /* @__PURE__ */ y.jsx($s, { children: /* @__PURE__ */ y.jsx(
    z,
    {
      flex: 1,
      display: "flex",
      flexDirection: "column",
      justifyContent: "space-between",
      my: "4",
      children: /* @__PURE__ */ y.jsxs(
        z,
        {
          flex: 1,
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center",
          textAlign: "center",
          children: [
            G.fromRecord({ token: r, metadata: t }).map((f) => /* @__PURE__ */ y.jsx(
              Zt.div,
              {
                initial: { opacity: 0, scale: 0.1 },
                animate: {
                  opacity: 1,
                  scale: 1,
                  transition: { delay: 0.2, duration: 0.3 }
                },
                children: /* @__PURE__ */ y.jsx(z, { my: "4", children: /* @__PURE__ */ y.jsx(
                  No,
                  {
                    metadata: f.metadata,
                    tokenLogoHw: "32",
                    tokenNetworkLogoHw: "8",
                    token: f.token
                  }
                ) })
              }
            )).extractNullable(),
            /* @__PURE__ */ y.jsx(
              Zt.div,
              {
                initial: { opacity: 0, translateX: "-40px" },
                animate: {
                  opacity: 1,
                  translateX: 0,
                  transition: { delay: 0.2, duration: 0.8 }
                },
                children: /* @__PURE__ */ y.jsx(to, { overflowWrap: "anywhere", variant: { level: "h3" }, children: a(
                  c ? "complete.successfully_unstaked" : u ? "complete.successfully_pending_action" : "complete.successfully_staked",
                  {
                    action: o.mapOrDefault(
                      (f) => a(c ? `complete.unstake.${f}` : `complete.stake.${f}`),
                      ""
                    ),
                    amount: e,
                    tokenNetwork: n,
                    pendingAction: a(
                      `complete.pending_action.${i == null ? void 0 : i.toLowerCase()}`
                    )
                  }
                ) })
              }
            ),
            !c && !u ? s.map(
              (f) => f.map((h, p) => /* @__PURE__ */ y.jsxs(
                z,
                {
                  display: "flex",
                  marginTop: "2",
                  justifyContent: "center",
                  alignItems: "center",
                  gap: "1",
                  children: [
                    h.logo && /* @__PURE__ */ y.jsx(
                      Ii,
                      {
                        imageProps: { borderRadius: "full" },
                        containerProps: { hw: "5" },
                        src: h.logo,
                        fallback: /* @__PURE__ */ y.jsx(
                          Vo,
                          {
                            name: h.name || h.logo,
                            tokenLogoHw: "5"
                          }
                        )
                      }
                    ),
                    /* @__PURE__ */ y.jsx(ue, { variant: { type: "muted" }, children: a("complete.via", { providerName: h.name }) })
                  ]
                },
                p
              ))
            ).extractNullable() : null,
            d.map((f) => /* @__PURE__ */ y.jsxs(
              z,
              {
                marginTop: "4",
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                as: "button",
                onClick: () => l(f.url),
                children: [
                  /* @__PURE__ */ y.jsx(
                    z,
                    {
                      marginRight: "1",
                      display: "flex",
                      justifyContent: "center",
                      alignItems: "center",
                      children: /* @__PURE__ */ y.jsx(yce, { width: 22, height: 22 })
                    }
                  ),
                  /* @__PURE__ */ y.jsx(ue, { variant: { type: "muted" }, children: a("complete.view_transaction", {
                    type: Je(f.type).map((h) => a(`steps.tx_type.${h}`)).map(k6).extract()
                  }) })
                ]
              },
              f.url
            ))
          ]
        }
      )
    }
  ) }) });
}, Fce = typeof Symbol == "function" && Symbol.observable || "@@observable";
function cS(e, t, n) {
  var o, s, a;
  const r = typeof e == "object", i = r ? e : void 0;
  return {
    next: (o = r ? e.next : e) == null ? void 0 : o.bind(i),
    error: (s = r ? e.error : t) == null ? void 0 : s.bind(i),
    complete: (a = r ? e.complete : n) == null ? void 0 : a.bind(i)
  };
}
function Lce(e, t) {
  return t(e);
}
const ol = /* @__PURE__ */ new WeakMap();
function uS(e, t, n) {
  let r, i;
  const o = {
    context: e,
    status: "active",
    output: void 0,
    error: void 0
  };
  let s = o;
  const a = (d) => {
    if (!i)
      return;
    const f = d.type, h = i.get(f);
    h && h.forEach((p) => p(d));
  }, l = Uce(t);
  function c(d) {
    var h;
    let f;
    [s, f] = l(s, d), (h = ol.get(u)) == null || h.forEach((p) => {
      var m;
      (m = p.next) == null || m.call(p, {
        type: "@xstate.snapshot",
        event: d,
        snapshot: s,
        actorRef: u,
        rootId: u.sessionId
      });
    }), r == null || r.forEach((p) => {
      var m;
      return (m = p.next) == null ? void 0 : m.call(p, s);
    }), f.forEach(a);
  }
  const u = {
    on(d, f) {
      i || (i = /* @__PURE__ */ new Map());
      let h = i.get(d);
      h || (h = /* @__PURE__ */ new Set(), i.set(d, h));
      const p = f.bind(void 0);
      return h.add(p), {
        unsubscribe() {
          h.delete(p);
        }
      };
    },
    sessionId: zce(),
    send(d) {
      var f;
      (f = ol.get(u)) == null || f.forEach((h) => {
        var p;
        (p = h.next) == null || p.call(h, {
          type: "@xstate.event",
          event: d,
          sourceRef: void 0,
          actorRef: u,
          rootId: u.sessionId
        });
      }), c(d);
    },
    getSnapshot() {
      return s;
    },
    getInitialSnapshot() {
      return o;
    },
    subscribe(d) {
      const f = cS(d);
      return r ?? (r = /* @__PURE__ */ new Set()), r.add(f), {
        unsubscribe() {
          return r == null ? void 0 : r.delete(f);
        }
      };
    },
    [Fce]() {
      return this;
    },
    inspect: (d) => {
      var h, p;
      const f = cS(d);
      return ol.set(u, ol.get(u) ?? /* @__PURE__ */ new Set()), ol.get(u).add(f), (h = f.next) == null || h.call(f, {
        type: "@xstate.actor",
        actorRef: u,
        rootId: u.sessionId
      }), (p = f.next) == null || p.call(f, {
        type: "@xstate.snapshot",
        snapshot: o,
        event: {
          type: "@xstate.init"
        },
        actorRef: u,
        rootId: u.sessionId
      }), {
        unsubscribe() {
          var m;
          return (m = ol.get(u)) == null ? void 0 : m.delete(f);
        }
      };
    }
  };
  return u;
}
function Zy(e, t) {
  return t === void 0 ? uS(e.context, e.on) : uS(e, t);
}
function Uce(e, t) {
  return (n, r) => {
    let i = n.context;
    const o = e == null ? void 0 : e[r.type], s = [], a = {
      emit: (l) => {
        s.push(l);
      }
    };
    if (!o)
      return [n, s];
    if (typeof o == "function")
      i = Lce(i, (l) => Object.assign({}, i, o == null ? void 0 : o(
        l,
        r,
        // TODO: help me
        a
      )));
    else {
      const l = {};
      for (const c of Object.keys(o)) {
        const u = o[c];
        l[c] = typeof u == "function" ? u(i, r, a) : u;
      }
      i = Object.assign({}, i, l);
    }
    return [{
      ...n,
      context: i
    }, s];
  };
}
function zce() {
  return Math.random().toString(36).slice(6);
}
const Vce = Zy(
  {
    selectedAction: G.empty(),
    selectedYield: G.empty()
  },
  {
    setSelectedAction: (e, t) => ({
      selectedAction: t.data.map(({ selectedAction: n }) => n),
      selectedYield: t.data.map(({ selectedYield: n }) => n)
    })
  }
), T6 = Ge(void 0), qce = ({ children: e }) => /* @__PURE__ */ y.jsx(T6.Provider, { value: Vce, children: e }), vc = () => {
  const e = we(T6);
  if (!e)
    throw new Error(
      "useActivityContext must be used within a ActivityProvider"
    );
  return e;
};
function $ce(e, t) {
  return e === t;
}
function Wce(e, t) {
  const n = It();
  return (r) => {
    const i = e(r);
    return t(n.current, i) ? n.current : n.current = i;
  };
}
function fr(e, t, n = $ce) {
  const r = Wce(t, n);
  return Dr(Ie((i) => e.subscribe(i).unsubscribe, [e]), () => r(e.getSnapshot()), () => r(e.getInitialSnapshot()));
}
const Vn = (e, t) => {
  const { trackPageView: n } = TR(), r = Dt(t);
  Te(() => {
    r.current ? n(e, r.current) : n(e);
  }, [e, r, n]);
}, Gce = () => {
  Vn("activityComplete");
  const e = fr(
    vc(),
    (l) => l.context.selectedAction
  ).unsafeCoerce(), t = J(
    () => G.fromNullable(e.amount).map(Xn).unsafeCoerce(),
    [e]
  ), n = fr(
    vc(),
    (l) => l.context.selectedYield
  ), r = _s(n).map((l) => l.type), i = J(
    () => G.fromNullable(e).map((l) => l.inputToken),
    [e]
  ), o = J(
    () => n.map((l) => l.metadata),
    [n]
  ), s = i.mapOrDefault((l) => l.symbol, ""), a = Uo({
    integrationData: n,
    validatorsAddresses: G.of(e.validatorAddresses ?? [])
  });
  return /* @__PURE__ */ y.jsx(
    Xy,
    {
      yieldType: r,
      providersDetails: a,
      token: i,
      metadata: o,
      network: s,
      amount: t,
      pendingActionType: e.type
    }
  );
}, _6 = () => ni("positions/:integrationId/:balanceId/select-validator/:pendingActionType"), px = () => {
  const e = fx(), t = _6();
  return J(() => {
    const { balanceId: n, integrationId: r } = (e == null ? void 0 : e.params) ?? (t == null ? void 0 : t.params) ?? {}, i = t == null ? void 0 : t.params.pendingActionType;
    return {
      balanceId: G.fromNullable(n),
      integrationId: G.fromNullable(r),
      pendingActionType: G.fromNullable(i),
      plain: {
        balanceId: n,
        integrationId: r,
        pendingActionType: i
      }
    };
  }, [
    t == null ? void 0 : t.params,
    e == null ? void 0 : e.params
  ]);
}, I6 = Ge(void 0), Hce = ({
  children: e
}) => {
  const [t, n] = Oe(G.empty()), r = Ie(() => {
    n(G.of({ timestamp: Date.now() }));
  }, []), i = J(
    () => [t, r],
    [t, r]
  );
  return /* @__PURE__ */ y.jsx(I6.Provider, { value: i, children: e });
}, R6 = () => {
  const e = we(I6);
  if (e === void 0)
    throw new Error(
      "useActionHistory must be used within a ActionHistoryContextProvider"
    );
  return e;
}, Kce = () => R6()[0], Yce = () => R6()[1], Qce = ({
  key: e,
  shouldRefetch: t,
  enabled: n,
  queryKey: r,
  waitMs: i = 4e3,
  times: o = 2
}) => {
  const s = ci();
  Ut({
    queryKey: ["refetch-n-times", ...e],
    refetchOnMount: !1,
    enabled: n,
    queryFn: async () => (t() && await de.sequence(
      Array.from({ length: o }).map(
        () => de(async () => {
          await I2(i), await s.invalidateQueries({ queryKey: r });
        }).chainLeft(async () => _e(null))
      )
    ), null)
  });
}, P6 = (e) => {
  const [t] = Oe(
    () => Sy(e).mapLeft(() => null).extract()
  ), n = It(t);
  return Dr(
    Ie(
      (r) => {
        const i = Cee(e, (o) => {
          n.current = o, r();
        });
        return () => i();
      },
      [e]
    ),
    Ie(() => n.current, []),
    Ie(() => null, [])
  );
}, Jce = (e) => {
  const { network: t, address: n, additionalAddresses: r } = wt(), i = Kce(), o = J(
    () => i.map((c) => c.timestamp).extractNullable(),
    [i]
  ), s = P6(
    "sk-widget@1//customValidators"
  ), a = J(
    () => G.fromRecord({
      additionalAddresses: Je(r ?? void 0),
      address: G.fromNullable(n),
      network: G.fromNullable(t)
    }).mapOrDefault(
      (c) => ({
        enabled: !0,
        dto: {
          addresses: {
            address: c.address,
            additionalAddresses: c.additionalAddresses
          },
          network: c.network,
          customValidators: G.fromNullable(s).chainNullable((u) => u[c.network]).chainNullable((u) => u[c.address]).orDefault([])
        }
      }),
      {
        enabled: !1,
        dto: {
          addresses: { address: "", additionalAddresses: void 0 },
          network: "ethereum"
        }
      }
    ),
    [r, n, s, t]
  ), l = a7(a.dto, {
    query: {
      enabled: a.enabled,
      select: e == null ? void 0 : e.select,
      refetchInterval: 1e3 * 60
    }
  });
  return Qce({
    enabled: !!o,
    key: ["yield-balances-refetch", o],
    queryKey: [nw(a.dto)[0]],
    waitMs: 4e3,
    shouldRefetch: () => !!o && Date.now() - o < 1e3 * 12
  }), l;
}, Xce = () => {
  const e = ci();
  return Ie(
    () => e.invalidateQueries({
      queryKey: [
        nw(
          {}
        )[0]
      ]
    }),
    [e]
  );
}, yx = () => {
  const { data: e, ...t } = Jce({
    select: Zce
  });
  return { data: J(
    () => e ?? /* @__PURE__ */ new Map(),
    [e]
  ), ...t };
}, Zce = zc(
  (e) => e,
  (e) => e.reduce((t, n) => (t.set(n.integrationId, {
    integrationId: n.integrationId,
    balanceData: n.balances.toSorted((r, i) => (r.groupId ?? "").localeCompare(i.groupId ?? "")).reduce((r, i) => {
      const o = r.get(i.groupId);
      return o ? o.balances.push(i) : i.validatorAddresses || i.validatorAddress || i.providerId ? r.set(i.groupId, {
        balances: [i],
        type: "validators",
        validatorsAddresses: i.validatorAddresses ?? (i.providerId ? [i.providerId] : [i.validatorAddress])
      }) : r.set(i.groupId, {
        balances: [i],
        type: "default"
      }), r;
    }, /* @__PURE__ */ new Map())
  }), t), /* @__PURE__ */ new Map())
), eue = ({
  integrationId: e
}) => {
  const { data: t, ...n } = yx();
  return { data: J(
    () => G.fromRecord({
      id: G.fromNullable(e),
      data: G.fromNullable(t)
    }).chainNullable((i) => i.data.get(i.id)),
    [e, t]
  ), ...n };
}, mx = ({
  balanceId: e,
  integrationId: t
}) => {
  const { data: n, ...r } = eue({ integrationId: t });
  return { data: J(
    () => G.fromRecord({
      positionData: n,
      balanceId: G.fromNullable(e)
    }).chainNullable(
      (o) => o.positionData.balanceData.get(o.balanceId)
    ),
    [e, n]
  ), ...r };
}, tue = Zy(
  { data: G.empty() },
  {
    initFlow: (e, t) => ({
      data: G.of({ ...t.data, actionDto: G.empty() })
    }),
    setActionDto: (e, t) => ({
      data: e.data.map((n) => ({
        ...n,
        actionDto: G.of(t.data)
      }))
    })
  }
), O6 = Ge(
  void 0
), nue = ({ children: e }) => /* @__PURE__ */ y.jsx(O6.Provider, { value: tue, children: e }), hf = () => {
  const e = we(O6);
  if (!e)
    throw new Error(
      "usePendingActionStore must be used within a PendingActionProvider"
    );
  return e;
}, rue = () => {
  var u;
  const { plain: e } = px(), t = mx({
    balanceId: e.balanceId,
    integrationId: e.integrationId
  }), n = fr(
    hf(),
    (d) => d.context.data
  ).unsafeCoerce(), r = J(
    () => G.of(n.integrationData),
    [n.integrationData]
  ), i = J(
    () => G.of(n.interactedToken),
    [n.interactedToken]
  );
  Vn("pendingActionCompelete");
  const o = Uo({
    integrationData: r,
    validatorsAddresses: t.data.map(
      (d) => d.type === "validators" ? d.validatorsAddresses : []
    )
  }), s = r.map((d) => d.metadata), a = i.mapOrDefault((d) => d.symbol, ""), l = J(
    () => {
      var d;
      return G.fromNullable((d = n.requestDto.args) == null ? void 0 : d.amount).map((f) => new Re(f ?? 0)).mapOrDefault((f) => Sn(f), "");
    },
    [(u = n.requestDto.args) == null ? void 0 : u.amount]
  ), c = _s(r).map((d) => d.type);
  return /* @__PURE__ */ y.jsx(
    Xy,
    {
      providersDetails: o,
      yieldType: c,
      token: i,
      metadata: s,
      network: a,
      amount: l,
      pendingActionType: n.pendingActionType
    }
  );
}, iue = Zy(
  { data: G.empty() },
  {
    initFlow: (e, t) => ({
      data: G.of({ ...t.data, actionDto: G.empty() })
    }),
    setActionDto: (e, t) => ({
      data: e.data.map((n) => ({
        ...n,
        actionDto: G.of(t.data)
      }))
    })
  }
), B6 = Ge(
  void 0
), oue = ({ children: e }) => /* @__PURE__ */ y.jsx(B6.Provider, { value: iue, children: e }), bc = () => {
  const e = we(B6);
  if (!e)
    throw new Error(
      "useExitStakeStore must be used within a ExitStakeStoreProvider"
    );
  return e;
}, sue = () => {
  const { plain: e } = px(), t = mx({
    balanceId: e.balanceId,
    integrationId: e.integrationId
  }), n = fr(
    bc(),
    (u) => u.context.data
  ).unsafeCoerce(), r = J(
    () => G.of(n.integrationData),
    [n.integrationData]
  );
  Vn("unstakeComplete");
  const i = Uo({
    integrationData: r,
    validatorsAddresses: t.data.map(
      (u) => u.type === "validators" ? u.validatorsAddresses : []
    )
  }), o = J(
    () => G.of(n.unstakeToken),
    [n.unstakeToken]
  ), s = r.map((u) => u.metadata), a = o.mapOrDefault((u) => u.symbol, ""), l = J(
    () => Sn(n.requestDto.args.amount),
    [n.requestDto.args.amount]
  ), c = _s(r).map((u) => u.type);
  return /* @__PURE__ */ y.jsx(
    Xy,
    {
      providersDetails: i,
      yieldType: c,
      token: o,
      metadata: s,
      network: a,
      amount: l
    }
  );
}, sl = (e) => `${Vt.assetsUrl}/widget/${e}`, vr = {
  bitget: sl("bitget.png"),
  fees: sl("fees.png"),
  ledgerLogo: sl("ledger-logo.svg"),
  poweredBy: sl("powered-by.png"),
  wcLogo: sl("wc-logo.svg"),
  whatIsLiquidStaking: sl("what-is-liquid-staking.png")
}, aue = () => lc.map(
  () => Object.values(vr).forEach((e) => {
    const t = new Image();
    t.src = e;
  })
), lue = () => /* @__PURE__ */ y.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: 17, height: 16, fill: "none", children: [
  /* @__PURE__ */ y.jsx("g", { clipPath: "url(#a)", filter: "url(#b)", children: /* @__PURE__ */ y.jsx(
    "path",
    {
      fill: "url(#c)",
      d: "M13.573 6.92c.028-2.343.043-3.515-.703-4.17-.747-.657-1.905-.491-4.222-.16l-3.065.439a1.142 1.142 0 1 0 .395 2.248l1.952-.405c.702-.146 1.053-.218 1.205-.126.14.086.223.24.216.405-.008.178-.264.429-.776.93L6.787 7.834c-.423.414-.634.621-.737.804-.375.671-.169 1.52.474 1.943.175.116.458.203 1.024.377.177.054.265.081.32.117.198.132.26.396.14.603-.032.056-.1.12-.234.246l-1.93 1.825a1.232 1.232 0 1 0 1.814 1.654l2.104-2.696c.645-.826.967-1.239.944-1.659a1.122 1.122 0 0 0-.12-.444c-.189-.375-.675-.573-1.646-.967-.344-.14-.516-.21-.576-.34a.361.361 0 0 1-.032-.153c0-.144.13-.278.387-.545l1.604-1.665c.413-.428.619-.642.779-.662a.456.456 0 0 1 .44.207c.086.135.054.431-.01 1.022l-.218 1.996a1.115 1.115 0 1 0 2.226.137l.033-2.714Z"
    }
  ) }),
  /* @__PURE__ */ y.jsxs("defs", { children: [
    /* @__PURE__ */ y.jsxs(
      "linearGradient",
      {
        id: "c",
        x1: 11.651,
        x2: 4.464,
        y1: 2.55,
        y2: 16.736,
        gradientUnits: "userSpaceOnUse",
        children: [
          /* @__PURE__ */ y.jsx("stop", { offset: 0.052, stopColor: "#FFC21B" }),
          /* @__PURE__ */ y.jsx("stop", { offset: 0.234, stopColor: "#B1A5B9" }),
          /* @__PURE__ */ y.jsx("stop", { offset: 0.385, stopColor: "#F46FC8" }),
          /* @__PURE__ */ y.jsx("stop", { offset: 0.797, stopColor: "#FF5F25" }),
          /* @__PURE__ */ y.jsx("stop", { offset: 1, stopColor: "#6D05F3" })
        ]
      }
    ),
    /* @__PURE__ */ y.jsx("clipPath", { id: "a", children: /* @__PURE__ */ y.jsx("path", { fill: "#fff", d: "M.935.975h16v15h-16z" }) }),
    /* @__PURE__ */ y.jsxs(
      "filter",
      {
        id: "b",
        width: 8.977,
        height: 13.756,
        x: 4.605,
        y: 2.3,
        colorInterpolationFilters: "sRGB",
        filterUnits: "userSpaceOnUse",
        children: [
          /* @__PURE__ */ y.jsx("feFlood", { floodOpacity: 0, result: "BackgroundImageFix" }),
          /* @__PURE__ */ y.jsx("feBlend", { in: "SourceGraphic", in2: "BackgroundImageFix", result: "shape" }),
          /* @__PURE__ */ y.jsx(
            "feColorMatrix",
            {
              in: "SourceAlpha",
              result: "hardAlpha",
              values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"
            }
          ),
          /* @__PURE__ */ y.jsx("feOffset", { dy: 0.18 }),
          /* @__PURE__ */ y.jsx("feGaussianBlur", { stdDeviation: 0.51 }),
          /* @__PURE__ */ y.jsx("feComposite", { in2: "hardAlpha", k2: -1, k3: 1, operator: "arithmetic" }),
          /* @__PURE__ */ y.jsx("feColorMatrix", { values: "0 0 0 0 0.98 0 0 0 0 1 0 0 0 0 0 0 0 0 0.3 0" }),
          /* @__PURE__ */ y.jsx("feBlend", { in2: "shape", result: "effect1_innerShadow_1687_4078" })
        ]
      }
    )
  ] })
] }), N6 = Ge(void 0), cue = ({
  children: e
}) => {
  const t = Bi(), n = fp(t), r = J(() => ({
    current: t,
    prev: n
  }), [t, n]);
  return /* @__PURE__ */ y.jsx(N6.Provider, { value: r, children: e });
}, gx = () => {
  const e = we(N6);
  if (!e)
    throw new Error("useSKLocation must be used within a SKLocationProvider");
  return e;
}, uue = () => ({
  earnPage: !1,
  layout: !1
}), due = (e, t) => {
  switch (t.type) {
    case "layout":
      return { ...e, layout: !0 };
    case "earnPage":
      return { ...e, earnPage: !0 };
    case "all":
      return { layout: !0, earnPage: !0 };
    default:
      return e;
  }
}, D6 = Ge(
  void 0
), fue = x7(), hue = ({ children: e }) => {
  const t = Dt(
    bt().onMountAnimationComplete
  ), [n, r] = _c(due, uue());
  Te(() => {
    var a;
    n.layout && n.earnPage && (fue(), (a = t.current) == null || a.call(t));
  }, [t, n.earnPage, n.layout]);
  const { current: i } = gx();
  Te(() => {
    i.pathname !== "/" && r({ type: "all" });
  }, [i.pathname]);
  const o = n.layout && n.earnPage, s = J(
    () => ({ dispatch: r, state: n, mountAnimationFinished: o }),
    [o, n]
  );
  return /* @__PURE__ */ y.jsx(D6.Provider, { value: s, children: e });
}, qo = () => {
  const e = we(D6);
  if (!e)
    throw new Error(
      "useMountAnimation must be used within a MountAnimationProvider"
    );
  return e;
}, [j6, pue] = df(0), yue = () => Wy(j6()[1]), M6 = ({ opacity: e }) => {
  const { containerRef: t } = yue(), { t: n } = ze(), { state: r } = qo();
  return /* @__PURE__ */ y.jsx(
    Zt.div,
    {
      "data-rk": "powered-by",
      ref: t,
      initial: { opacity: 0 },
      animate: {
        opacity: e || r.layout ? 1 : 0,
        transition: { duration: 0.3, delay: 0.2 }
      },
      children: /* @__PURE__ */ y.jsxs(
        z,
        {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          marginBottom: "3",
          gap: "1",
          children: [
            /* @__PURE__ */ y.jsx(ue, { variant: { type: "muted", weight: "normal" }, children: /* @__PURE__ */ y.jsx(
              Wn,
              {
                i18nKey: "shared.powered_by",
                values: { name: n("shared.stake_kit") },
                components: {
                  span0: /* @__PURE__ */ y.jsx(
                    ue,
                    {
                      as: "span",
                      variant: { type: "muted", weight: "semibold" }
                    }
                  )
                }
              }
            ) }),
            /* @__PURE__ */ y.jsx(lue, {})
          ]
        }
      )
    }
  );
};
var F6 = "_1eove2b3 _1eove2b2 yv8y4rvr yv8y4rvs", mue = "_1eove2b5 _1eove2b4 yv8y4r0 yv8y4rhp yv8y4r2n yv8y4rg7 yv8y4rfz", gue = "_1eove2b6", vue = "_1c1q0ss0", bue = "_1c1q0ss1";
const wue = () => {
  const { t: e } = ze();
  return /* @__PURE__ */ y.jsxs(z, { className: F6, children: [
    /* @__PURE__ */ y.jsxs(
      z,
      {
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        paddingBottom: { mobile: "8" },
        className: bue,
        "data-testid": "under-maintenance",
        children: [
          /* @__PURE__ */ y.jsx(z, { as: "img", src: vr.fees, className: vue }),
          /* @__PURE__ */ y.jsxs(z, { children: [
            /* @__PURE__ */ y.jsx(
              to,
              {
                marginBottom: "4",
                textAlign: "center",
                variant: { level: "h4" },
                children: e("help_modals.under_maintenance.title")
              }
            ),
            /* @__PURE__ */ y.jsx(
              ue,
              {
                variant: { type: "muted", weight: "normal" },
                textAlign: "center",
                marginBottom: "4",
                children: e("help_modals.under_maintenance.description")
              }
            ),
            /* @__PURE__ */ y.jsx(
              ue,
              {
                variant: { type: "muted", weight: "normal" },
                textAlign: "center",
                marginBottom: "4",
                children: e("help_modals.under_maintenance.description2")
              }
            )
          ] })
        ]
      }
    ),
    /* @__PURE__ */ y.jsx(M6, { opacity: 1 })
  ] });
}, xue = I.createContext({}), L6 = !0;
function Cue({ baseColor: e, highlightColor: t, width: n, height: r, borderRadius: i, circle: o, direction: s, duration: a, enableAnimation: l = L6 }) {
  const c = {};
  return s === "rtl" && (c["--animation-direction"] = "reverse"), typeof a == "number" && (c["--animation-duration"] = `${a}s`), l || (c["--pseudo-element-display"] = "none"), (typeof n == "string" || typeof n == "number") && (c.width = n), (typeof r == "string" || typeof r == "number") && (c.height = r), (typeof i == "string" || typeof i == "number") && (c.borderRadius = i), o && (c.borderRadius = "50%"), typeof e < "u" && (c["--base-color"] = e), typeof t < "u" && (c["--highlight-color"] = t), c;
}
function kue({ count: e = 1, wrapper: t, className: n, containerClassName: r, containerTestId: i, circle: o = !1, style: s, ...a }) {
  var l, c, u;
  const d = I.useContext(xue), f = { ...a };
  for (const [x, C] of Object.entries(a))
    typeof C > "u" && delete f[x];
  const h = {
    ...d,
    ...f,
    circle: o
  }, p = {
    ...s,
    ...Cue(h)
  };
  let m = "react-loading-skeleton";
  n && (m += ` ${n}`);
  const g = (l = h.inline) !== null && l !== void 0 ? l : !1, v = [], w = Math.ceil(e);
  for (let x = 0; x < w; x++) {
    let C = p;
    if (w > e && x === w - 1) {
      const k = (c = C.width) !== null && c !== void 0 ? c : "100%", A = e % 1, b = typeof k == "number" ? k * A : `calc(${k} * ${A})`;
      C = { ...C, width: b };
    }
    const S = I.createElement("span", { className: m, style: C, key: x }, "‌");
    g ? v.push(S) : v.push(I.createElement(
      I.Fragment,
      { key: x },
      S,
      I.createElement("br", null)
    ));
  }
  return I.createElement("span", { className: r, "data-testid": i, "aria-live": "polite", "aria-busy": (u = h.enableAnimation) !== null && u !== void 0 ? u : L6 }, t ? v.map((x, C) => I.createElement(t, { key: C }, x)) : v);
}
const $o = ({
  heightPx: e,
  variant: t
}) => /* @__PURE__ */ y.jsx(
  kue,
  {
    height: e,
    baseColor: zt.color.skeletonLoaderBase,
    highlightColor: zt.color.skeletonLoaderHighlight,
    enableAnimation: !0,
    borderRadius: (t == null ? void 0 : t.size) === "medium" ? zt.borderRadius.baseContract.md : zt.borderRadius.baseContract.xl
  }
), Eue = Ge(void 0), U6 = () => we(Eue), Sue = {
  mobile: 0,
  tablet: 520
  // desktop: 1280,
};
function al(e, t, n) {
  let r = n.initialDeps ?? [], i;
  return () => {
    var o, s, a, l;
    let c;
    n.key && ((o = n.debug) != null && o.call(n)) && (c = Date.now());
    const u = e();
    if (!(u.length !== r.length || u.some((h, p) => r[p] !== h)))
      return i;
    r = u;
    let f;
    if (n.key && ((s = n.debug) != null && s.call(n)) && (f = Date.now()), i = t(...u), n.key && ((a = n.debug) != null && a.call(n))) {
      const h = Math.round((Date.now() - c) * 100) / 100, m = Math.round((Date.now() - f) * 100) / 100 / 16, g = (v, w) => {
        for (v = String(v); v.length < w; )
          v = " " + v;
        return v;
      };
    }
    return (l = n == null ? void 0 : n.onChange) == null || l.call(n, i), i;
  };
}
function ev(e, t) {
  if (e === void 0)
    throw new Error("Unexpected undefined");
  return e;
}
const Aue = (e, t) => Math.abs(e - t) < 1, Tue = (e, t, n) => {
  let r;
  return function(...i) {
    e.clearTimeout(r), r = e.setTimeout(() => t.apply(this, i), n);
  };
}, _ue = (e) => e, Iue = (e) => {
  const t = Math.max(e.startIndex - e.overscan, 0), n = Math.min(e.endIndex + e.overscan, e.count - 1), r = [];
  for (let i = t; i <= n; i++)
    r.push(i);
  return r;
}, Rue = (e, t) => {
  const n = e.scrollElement;
  if (!n)
    return;
  const r = e.targetWindow;
  if (!r)
    return;
  const i = (s) => {
    const { width: a, height: l } = s;
    t({ width: Math.round(a), height: Math.round(l) });
  };
  if (i(n.getBoundingClientRect()), !r.ResizeObserver)
    return () => {
    };
  const o = new r.ResizeObserver((s) => {
    const a = s[0];
    if (a != null && a.borderBoxSize) {
      const l = a.borderBoxSize[0];
      if (l) {
        i({ width: l.inlineSize, height: l.blockSize });
        return;
      }
    }
    i(n.getBoundingClientRect());
  });
  return o.observe(n, { box: "border-box" }), () => {
    o.unobserve(n);
  };
}, dS = {
  passive: !0
}, Pue = typeof window > "u" ? !0 : "onscrollend" in window, Oue = (e, t) => {
  const n = e.scrollElement;
  if (!n)
    return;
  const r = e.targetWindow;
  if (!r)
    return;
  let i = 0;
  const o = Pue ? () => {
  } : Tue(
    r,
    () => {
      t(i, !1);
    },
    e.options.isScrollingResetDelay
  ), s = (c) => () => {
    const { horizontal: u, isRtl: d } = e.options;
    i = u ? n.scrollLeft * (d && -1 || 1) : n.scrollTop, o(), t(i, c);
  }, a = s(!0), l = s(!1);
  return l(), n.addEventListener("scroll", a, dS), n.addEventListener("scrollend", l, dS), () => {
    n.removeEventListener("scroll", a), n.removeEventListener("scrollend", l);
  };
}, Bue = (e, t, n) => {
  if (t != null && t.borderBoxSize) {
    const r = t.borderBoxSize[0];
    if (r)
      return Math.round(
        r[n.options.horizontal ? "inlineSize" : "blockSize"]
      );
  }
  return Math.round(
    e.getBoundingClientRect()[n.options.horizontal ? "width" : "height"]
  );
}, Nue = (e, {
  adjustments: t = 0,
  behavior: n
}, r) => {
  var i, o;
  const s = e + t;
  (o = (i = r.scrollElement) == null ? void 0 : i.scrollTo) == null || o.call(i, {
    [r.options.horizontal ? "left" : "top"]: s,
    behavior: n
  });
};
class Due {
  constructor(t) {
    this.unsubs = [], this.scrollElement = null, this.targetWindow = null, this.isScrolling = !1, this.scrollToIndexTimeoutId = null, this.measurementsCache = [], this.itemSizeCache = /* @__PURE__ */ new Map(), this.pendingMeasuredCacheIndexes = [], this.scrollRect = null, this.scrollOffset = null, this.scrollDirection = null, this.scrollAdjustments = 0, this.elementsCache = /* @__PURE__ */ new Map(), this.observer = /* @__PURE__ */ (() => {
      let n = null;
      const r = () => n || (!this.targetWindow || !this.targetWindow.ResizeObserver ? null : n = new this.targetWindow.ResizeObserver((i) => {
        i.forEach((o) => {
          this._measureElement(o.target, o);
        });
      }));
      return {
        disconnect: () => {
          var i;
          (i = r()) == null || i.disconnect(), n = null;
        },
        observe: (i) => {
          var o;
          return (o = r()) == null ? void 0 : o.observe(i, { box: "border-box" });
        },
        unobserve: (i) => {
          var o;
          return (o = r()) == null ? void 0 : o.unobserve(i);
        }
      };
    })(), this.range = null, this.setOptions = (n) => {
      Object.entries(n).forEach(([r, i]) => {
        typeof i > "u" && delete n[r];
      }), this.options = {
        debug: !1,
        initialOffset: 0,
        overscan: 1,
        paddingStart: 0,
        paddingEnd: 0,
        scrollPaddingStart: 0,
        scrollPaddingEnd: 0,
        horizontal: !1,
        getItemKey: _ue,
        rangeExtractor: Iue,
        onChange: () => {
        },
        measureElement: Bue,
        initialRect: { width: 0, height: 0 },
        scrollMargin: 0,
        gap: 0,
        indexAttribute: "data-index",
        initialMeasurementsCache: [],
        lanes: 1,
        isScrollingResetDelay: 150,
        enabled: !0,
        isRtl: !1,
        ...n
      };
    }, this.notify = (n) => {
      var r, i;
      (i = (r = this.options).onChange) == null || i.call(r, this, n);
    }, this.maybeNotify = al(
      () => (this.calculateRange(), [
        this.isScrolling,
        this.range ? this.range.startIndex : null,
        this.range ? this.range.endIndex : null
      ]),
      (n) => {
        this.notify(n);
      },
      {
        key: ke.env.NODE_ENV !== "production" && "maybeNotify",
        debug: () => this.options.debug,
        initialDeps: [
          this.isScrolling,
          this.range ? this.range.startIndex : null,
          this.range ? this.range.endIndex : null
        ]
      }
    ), this.cleanup = () => {
      this.unsubs.filter(Boolean).forEach((n) => n()), this.unsubs = [], this.observer.disconnect(), this.scrollElement = null, this.targetWindow = null;
    }, this._didMount = () => () => {
      this.cleanup();
    }, this._willUpdate = () => {
      var n;
      const r = this.options.enabled ? this.options.getScrollElement() : null;
      if (this.scrollElement !== r) {
        if (this.cleanup(), !r) {
          this.maybeNotify();
          return;
        }
        this.scrollElement = r, this.scrollElement && "ownerDocument" in this.scrollElement ? this.targetWindow = this.scrollElement.ownerDocument.defaultView : this.targetWindow = ((n = this.scrollElement) == null ? void 0 : n.window) ?? null, this.elementsCache.forEach((i) => {
          this.observer.observe(i);
        }), this._scrollToOffset(this.getScrollOffset(), {
          adjustments: void 0,
          behavior: void 0
        }), this.unsubs.push(
          this.options.observeElementRect(this, (i) => {
            this.scrollRect = i, this.maybeNotify();
          })
        ), this.unsubs.push(
          this.options.observeElementOffset(this, (i, o) => {
            this.scrollAdjustments = 0, this.scrollDirection = o ? this.getScrollOffset() < i ? "forward" : "backward" : null, this.scrollOffset = i, this.isScrolling = o, this.maybeNotify();
          })
        );
      }
    }, this.getSize = () => this.options.enabled ? (this.scrollRect = this.scrollRect ?? this.options.initialRect, this.scrollRect[this.options.horizontal ? "width" : "height"]) : (this.scrollRect = null, 0), this.getScrollOffset = () => this.options.enabled ? (this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset == "function" ? this.options.initialOffset() : this.options.initialOffset), this.scrollOffset) : (this.scrollOffset = null, 0), this.getFurthestMeasurement = (n, r) => {
      const i = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
      for (let s = r - 1; s >= 0; s--) {
        const a = n[s];
        if (i.has(a.lane))
          continue;
        const l = o.get(
          a.lane
        );
        if (l == null || a.end > l.end ? o.set(a.lane, a) : a.end < l.end && i.set(a.lane, !0), i.size === this.options.lanes)
          break;
      }
      return o.size === this.options.lanes ? Array.from(o.values()).sort((s, a) => s.end === a.end ? s.index - a.index : s.end - a.end)[0] : void 0;
    }, this.getMeasurementOptions = al(
      () => [
        this.options.count,
        this.options.paddingStart,
        this.options.scrollMargin,
        this.options.getItemKey,
        this.options.enabled
      ],
      (n, r, i, o, s) => (this.pendingMeasuredCacheIndexes = [], {
        count: n,
        paddingStart: r,
        scrollMargin: i,
        getItemKey: o,
        enabled: s
      }),
      {
        key: !1
      }
    ), this.getMeasurements = al(
      () => [this.getMeasurementOptions(), this.itemSizeCache],
      ({ count: n, paddingStart: r, scrollMargin: i, getItemKey: o, enabled: s }, a) => {
        if (!s)
          return this.measurementsCache = [], this.itemSizeCache.clear(), [];
        this.measurementsCache.length === 0 && (this.measurementsCache = this.options.initialMeasurementsCache, this.measurementsCache.forEach((u) => {
          this.itemSizeCache.set(u.key, u.size);
        }));
        const l = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;
        this.pendingMeasuredCacheIndexes = [];
        const c = this.measurementsCache.slice(0, l);
        for (let u = l; u < n; u++) {
          const d = o(u), f = this.options.lanes === 1 ? c[u - 1] : this.getFurthestMeasurement(c, u), h = f ? f.end + this.options.gap : r + i, p = a.get(d), m = typeof p == "number" ? p : this.options.estimateSize(u), g = h + m, v = f ? f.lane : u % this.options.lanes;
          c[u] = {
            index: u,
            start: h,
            size: m,
            end: g,
            key: d,
            lane: v
          };
        }
        return this.measurementsCache = c, c;
      },
      {
        key: ke.env.NODE_ENV !== "production" && "getMeasurements",
        debug: () => this.options.debug
      }
    ), this.calculateRange = al(
      () => [this.getMeasurements(), this.getSize(), this.getScrollOffset()],
      (n, r, i) => this.range = n.length > 0 && r > 0 ? jue({
        measurements: n,
        outerSize: r,
        scrollOffset: i
      }) : null,
      {
        key: ke.env.NODE_ENV !== "production" && "calculateRange",
        debug: () => this.options.debug
      }
    ), this.getIndexes = al(
      () => [
        this.options.rangeExtractor,
        this.calculateRange(),
        this.options.overscan,
        this.options.count
      ],
      (n, r, i, o) => r === null ? [] : n({
        startIndex: r.startIndex,
        endIndex: r.endIndex,
        overscan: i,
        count: o
      }),
      {
        key: ke.env.NODE_ENV !== "production" && "getIndexes",
        debug: () => this.options.debug
      }
    ), this.indexFromElement = (n) => {
      const r = this.options.indexAttribute, i = n.getAttribute(r);
      return i ? parseInt(i, 10) : -1;
    }, this._measureElement = (n, r) => {
      const i = this.indexFromElement(n), o = this.measurementsCache[i];
      if (!o)
        return;
      const s = o.key, a = this.elementsCache.get(s);
      a !== n && (a && this.observer.unobserve(a), this.observer.observe(n), this.elementsCache.set(s, n)), n.isConnected && this.resizeItem(i, this.options.measureElement(n, r, this));
    }, this.resizeItem = (n, r) => {
      const i = this.measurementsCache[n];
      if (!i)
        return;
      const o = this.itemSizeCache.get(i.key) ?? i.size, s = r - o;
      s !== 0 && ((this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(i, s, this) : i.start < this.getScrollOffset() + this.scrollAdjustments) && (ke.env.NODE_ENV !== "production" && this.options.debug, this._scrollToOffset(this.getScrollOffset(), {
        adjustments: this.scrollAdjustments += s,
        behavior: void 0
      })), this.pendingMeasuredCacheIndexes.push(i.index), this.itemSizeCache = new Map(this.itemSizeCache.set(i.key, r)), this.notify(!1));
    }, this.measureElement = (n) => {
      if (!n) {
        this.elementsCache.forEach((r, i) => {
          r.isConnected || (this.observer.unobserve(r), this.elementsCache.delete(i));
        });
        return;
      }
      this._measureElement(n, void 0);
    }, this.getVirtualItems = al(
      () => [this.getIndexes(), this.getMeasurements()],
      (n, r) => {
        const i = [];
        for (let o = 0, s = n.length; o < s; o++) {
          const a = n[o], l = r[a];
          i.push(l);
        }
        return i;
      },
      {
        key: ke.env.NODE_ENV !== "production" && "getVirtualItems",
        debug: () => this.options.debug
      }
    ), this.getVirtualItemForOffset = (n) => {
      const r = this.getMeasurements();
      if (r.length !== 0)
        return ev(
          r[z6(
            0,
            r.length - 1,
            (i) => ev(r[i]).start,
            n
          )]
        );
    }, this.getOffsetForAlignment = (n, r) => {
      const i = this.getSize(), o = this.getScrollOffset();
      r === "auto" && (n <= o ? r = "start" : n >= o + i ? r = "end" : r = "start"), r === "start" ? n = n : r === "end" ? n = n - i : r === "center" && (n = n - i / 2);
      const s = this.options.horizontal ? "scrollWidth" : "scrollHeight", l = (this.scrollElement ? "document" in this.scrollElement ? this.scrollElement.document.documentElement[s] : this.scrollElement[s] : 0) - i;
      return Math.max(Math.min(l, n), 0);
    }, this.getOffsetForIndex = (n, r = "auto") => {
      n = Math.max(0, Math.min(n, this.options.count - 1));
      const i = this.measurementsCache[n];
      if (!i)
        return;
      const o = this.getSize(), s = this.getScrollOffset();
      if (r === "auto")
        if (i.end >= s + o - this.options.scrollPaddingEnd)
          r = "end";
        else if (i.start <= s + this.options.scrollPaddingStart)
          r = "start";
        else
          return [s, r];
      const a = r === "end" ? i.end + this.options.scrollPaddingEnd : i.start - this.options.scrollPaddingStart;
      return [this.getOffsetForAlignment(a, r), r];
    }, this.isDynamicMode = () => this.elementsCache.size > 0, this.cancelScrollToIndex = () => {
      this.scrollToIndexTimeoutId !== null && this.targetWindow && (this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId), this.scrollToIndexTimeoutId = null);
    }, this.scrollToOffset = (n, { align: r = "start", behavior: i } = {}) => {
      this.cancelScrollToIndex(), i === "smooth" && this.isDynamicMode(), this._scrollToOffset(this.getOffsetForAlignment(n, r), {
        adjustments: void 0,
        behavior: i
      });
    }, this.scrollToIndex = (n, { align: r = "auto", behavior: i } = {}) => {
      n = Math.max(0, Math.min(n, this.options.count - 1)), this.cancelScrollToIndex(), i === "smooth" && this.isDynamicMode();
      const o = this.getOffsetForIndex(n, r);
      if (!o) return;
      const [s, a] = o;
      this._scrollToOffset(s, { adjustments: void 0, behavior: i }), i !== "smooth" && this.isDynamicMode() && this.targetWindow && (this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(() => {
        if (this.scrollToIndexTimeoutId = null, this.elementsCache.has(
          this.options.getItemKey(n)
        )) {
          const [c] = ev(
            this.getOffsetForIndex(n, a)
          );
          Aue(c, this.getScrollOffset()) || this.scrollToIndex(n, { align: a, behavior: i });
        } else
          this.scrollToIndex(n, { align: a, behavior: i });
      }));
    }, this.scrollBy = (n, { behavior: r } = {}) => {
      this.cancelScrollToIndex(), r === "smooth" && this.isDynamicMode(), this._scrollToOffset(this.getScrollOffset() + n, {
        adjustments: void 0,
        behavior: r
      });
    }, this.getTotalSize = () => {
      var n;
      const r = this.getMeasurements();
      let i;
      return r.length === 0 ? i = this.options.paddingStart : i = this.options.lanes === 1 ? ((n = r[r.length - 1]) == null ? void 0 : n.end) ?? 0 : Math.max(
        ...r.slice(-this.options.lanes).map((o) => o.end)
      ), Math.max(
        i - this.options.scrollMargin + this.options.paddingEnd,
        0
      );
    }, this._scrollToOffset = (n, {
      adjustments: r,
      behavior: i
    }) => {
      this.options.scrollToFn(n, { behavior: i, adjustments: r }, this);
    }, this.measure = () => {
      this.itemSizeCache = /* @__PURE__ */ new Map(), this.notify(!1);
    }, this.setOptions(t);
  }
}
const z6 = (e, t, n, r) => {
  for (; e <= t; ) {
    const i = (e + t) / 2 | 0, o = n(i);
    if (o < r)
      e = i + 1;
    else if (o > r)
      t = i - 1;
    else
      return i;
  }
  return e > 0 ? e - 1 : 0;
};
function jue({
  measurements: e,
  outerSize: t,
  scrollOffset: n
}) {
  const r = e.length - 1, o = z6(0, r, (a) => e[a].start, n);
  let s = o;
  for (; s < r && e[s].end < n + t; )
    s++;
  return { startIndex: o, endIndex: s };
}
const Mue = typeof document < "u" ? P.useLayoutEffect : P.useEffect;
function Fue(e) {
  const t = P.useReducer(() => ({}), {})[1], n = {
    ...e,
    onChange: (i, o) => {
      var s;
      o ? dA(t) : t(), (s = e.onChange) == null || s.call(e, i, o);
    }
  }, [r] = P.useState(
    () => new Due(n)
  );
  return r.setOptions(n), P.useEffect(() => r._didMount(), []), Mue(() => r._willUpdate()), r;
}
function V6(e) {
  return Fue({
    observeElementRect: Rue,
    observeElementOffset: Oue,
    scrollToFn: Nue,
    ...e
  });
}
var q6 = "aruav30", $6 = "aruav31", W6 = "aruav32";
const vx = ({
  data: e,
  itemContent: t,
  className: n,
  estimateSize: r,
  maxHeight: i = 600,
  hasNextPage: o,
  isFetchingNextPage: s,
  fetchNextPage: a
}) => {
  var g;
  const l = It(null), c = U6(), u = G6(), d = V6({
    count: e.length,
    getScrollElement: () => l.current,
    estimateSize: r,
    overscan: 10,
    ...c && { observeElementRect: c }
  }), f = d.getVirtualItems(), h = J(
    () => pt.head([...f].reverse()).filter((v) => v.index >= e.length - 1).isJust(),
    [f, e.length]
  ), p = Dt(a);
  Te(() => {
    G.fromFalsy(h).filter(() => !!o && !s).ifJust(() => {
      var v;
      return (v = p.current) == null ? void 0 : v.call(p);
    });
  }, [h, o, s, p]);
  const m = u ? i : "max(65vh, 400px)";
  return /* @__PURE__ */ y.jsx(z, { ref: l, className: wr([q6, n]), children: /* @__PURE__ */ y.jsx(
    z,
    {
      className: $6,
      style: {
        height: `${d.getTotalSize()}px`,
        maxHeight: m
      },
      children: /* @__PURE__ */ y.jsxs(
        z,
        {
          className: W6,
          style: {
            transform: `translateY(${((g = f[0]) == null ? void 0 : g.start) ?? 0}px)`
          },
          children: [
            f.map((v) => /* @__PURE__ */ y.jsx(
              z,
              {
                "data-index": v.index,
                ref: d.measureElement,
                children: t(v.index, e[v.index])
              },
              v.key
            )),
            s && /* @__PURE__ */ y.jsx(z, { justifyContent: "center", display: "flex", my: "4", children: /* @__PURE__ */ y.jsx(ei, {}) })
          ]
        }
      )
    }
  ) });
}, bx = ({
  itemContent: e,
  groupContent: t,
  increaseViewportBy: n,
  groupCounts: r,
  className: i,
  maxHeight: o = 600,
  estimateSize: s,
  hasNextPage: a,
  isFetchingNextPage: l,
  fetchNextPage: c
}) => {
  var x;
  const u = It(null), d = G6(), f = U6(), h = V6({
    count: r.reduce(
      (C, S) => C + S,
      r.length
    ),
    getScrollElement: () => u.current,
    estimateSize: s,
    overscan: 10,
    paddingStart: n == null ? void 0 : n.top,
    paddingEnd: n == null ? void 0 : n.bottom,
    ...f && { observeElementRect: f }
  }), p = h.getVirtualItems(), m = Dt(c), { resultArray: g } = J(
    () => r.reduce(
      (C, S, k) => (C.resultArray.push({ type: "parent", index: k }), C.resultArray.push(
        ...Array.from(
          { length: S },
          (A, b) => ({
            type: "child",
            index: C.childIndex + b,
            parentIndex: k
          })
        )
      ), C.childIndex += S, C),
      { resultArray: [], childIndex: 0 }
    ),
    [r]
  ), v = J(
    () => pt.head([...p].reverse()).filter((C) => C.index >= g.length - 1).isJust(),
    [p, g.length]
  );
  Te(() => {
    G.fromFalsy(v).filter(() => !!a && !l).ifJust(() => {
      var C;
      return (C = m.current) == null ? void 0 : C.call(m);
    });
  }, [v, a, l, m]);
  const w = d ? o : "max(65vh, 500px)";
  return /* @__PURE__ */ y.jsx(z, { ref: u, className: wr([q6, i]), children: /* @__PURE__ */ y.jsx(
    z,
    {
      className: $6,
      style: {
        height: `${h.getTotalSize()}px`,
        maxHeight: w
      },
      children: /* @__PURE__ */ y.jsxs(
        z,
        {
          className: W6,
          style: {
            transform: `translateY(${((x = h.getVirtualItems()[0]) == null ? void 0 : x.start) ?? 0}px)`
          },
          children: [
            h.getVirtualItems().map((C) => {
              const S = g[C.index], k = S.type;
              return /* @__PURE__ */ y.jsx(
                z,
                {
                  ref: h.measureElement,
                  "data-index": C.index,
                  children: k === "child" ? e(S.index, S.parentIndex) : t(S.index)
                },
                C.index
              );
            }),
            l && /* @__PURE__ */ y.jsx(z, { justifyContent: "center", display: "flex", my: "4", children: /* @__PURE__ */ y.jsx(ei, {}) })
          ]
        }
      )
    }
  ) });
}, G6 = () => {
  const [e] = Oe(
    () => Tn.map((t) => t.innerWidth).orDefault(0)
  );
  return e >= Sue.tablet;
}, Lue = (e) => {
  const t = /* @__PURE__ */ new Date(), n = 1e3 * 60 * 60 * 24, r = Date.UTC(t.getFullYear(), t.getMonth(), t.getDate()), i = Date.UTC(
    e.getFullYear(),
    e.getMonth(),
    e.getDate()
  );
  return Math.floor((i - r) / n);
}, H6 = (e) => {
  const t = /* @__PURE__ */ new Date();
  return t.setDate(t.getDate() - 7), new Date(e) < t;
}, Uue = {
  SUCCESS: "claim",
  FAILED: "actionRequired",
  CREATED: "pending",
  WAITING_FOR_NEXT: "pending",
  CANCELED: "actionRequired",
  PROCESSING: "claim"
}, zue = (e) => {
  const { t } = ze(), n = J(
    () => G.fromNullable(e.yieldData),
    [e.yieldData]
  ), r = Uo({
    integrationData: n,
    validatorsAddresses: G.of(e.actionData.validatorAddresses ?? [])
  }), i = J(
    () => G.of(e.actionData.type).map((c) => c.replaceAll("_", " ")).map(rp).extract(),
    [e]
  ), o = J(
    () => G.of(e.actionData.createdAt).map(H6).orDefault(!1),
    [e]
  ), s = J(
    () => G.fromNullable(e.actionData.status).map((c) => c === Gi.WAITING_FOR_NEXT ? o ? Gi.FAILED : t("activity.review.in_progress") : c).map((c) => c.replaceAll("_", " ")).map(rp).extract(),
    [e, t, o]
  ), a = J(
    () => G.fromNullable(e.actionData.status).map((c) => c === Gi.WAITING_FOR_NEXT && o ? Gi.FAILED : c).map((c) => Uue[c]).extract(),
    [e, o]
  ), l = J(
    () => G.fromNullable(e.actionData.amount).map(Xn),
    [e]
  );
  return {
    integrationData: n,
    providersDetails: r,
    actionType: i,
    amount: l,
    badgeLabel: s,
    badgeColor: a
  };
};
var Vue = "blr5el0", que = "blr5el1", $ue = "blr5el3 blr5el2 yv8y4rpj yv8y4rpm", Wue = "blr5el5 blr5el4 yv8y4rpj", Gue = "blr5el6", Hue = "blr5el8 blr5el7 yv8y4r2n yv8y4rpn yv8y4rdz", w0 = $c({ defaultClassName: "_8stx5f4 _8stx5f0 yv8y4ru", variantClassNames: { type: { claim: "_8stx5f5 _8stx5f1 yv8y4rwn yv8y4rwo", actionRequired: "_8stx5f6 _8stx5f2 yv8y4rwp yv8y4rwq", pending: "_8stx5f7 _8stx5f3 yv8y4rwr yv8y4rws" } }, defaultVariants: {}, compoundVariants: [] }), Kue = "_8stx5f9 _8stx5f8 yv8y4rpj yv8y4rpm", Yue = "_8stx5fa", Que = "_8stx5fb";
const Jue = ({
  action: e,
  onActionSelect: t
}) => {
  const { t: n } = ze(), {
    integrationData: r,
    providersDetails: i,
    actionType: o,
    amount: s,
    badgeLabel: a,
    badgeColor: l
  } = zue(e);
  return /* @__PURE__ */ y.jsx(z, { py: "1", width: "full", children: r.mapOrDefault(
    (c) => /* @__PURE__ */ y.jsx(Qy, { onClick: () => t(e), className: Wue, children: /* @__PURE__ */ y.jsxs(
      z,
      {
        display: "flex",
        width: "full",
        justifyContent: "space-between",
        gap: "2",
        children: [
          /* @__PURE__ */ y.jsxs(
            z,
            {
              display: "flex",
              justifyContent: "flex-start",
              alignItems: "center",
              children: [
                /* @__PURE__ */ y.jsx(No, { metadata: c.metadata, token: c.token }),
                /* @__PURE__ */ y.jsxs(
                  z,
                  {
                    display: "flex",
                    flexDirection: "column",
                    justifyContent: "center",
                    alignItems: "flex-start",
                    gap: "1",
                    children: [
                      /* @__PURE__ */ y.jsxs(z, { className: $ue, children: [
                        /* @__PURE__ */ y.jsx(ue, { children: c.token.symbol }),
                        /* @__PURE__ */ y.jsx(
                          z,
                          {
                            className: w0({
                              type: l
                            }),
                            children: /* @__PURE__ */ y.jsx(
                              ue,
                              {
                                variant: { type: "white", size: "small" },
                                className: Gue,
                                children: a
                              }
                            )
                          }
                        )
                      ] }),
                      i.chain(
                        (u) => pt.head(u).map((d) => /* @__PURE__ */ y.jsx(
                          ue,
                          {
                            className: que,
                            variant: {
                              type: "muted",
                              weight: "normal"
                            },
                            children: n("positions.via", {
                              providerName: d.name ?? d.address,
                              count: Math.max(u.length - 1, 1)
                            })
                          }
                        ))
                      ).extractNullable()
                    ]
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ y.jsxs(
            z,
            {
              display: "flex",
              justifyContent: "center",
              alignItems: "flex-end",
              flexDirection: "column",
              textAlign: "end",
              gap: "1",
              children: [
                /* @__PURE__ */ y.jsx(ue, { variant: { weight: "normal" }, children: o }),
                /* @__PURE__ */ y.jsxs(
                  ue,
                  {
                    overflowWrap: "anywhere",
                    variant: { weight: "normal", type: "muted" },
                    children: [
                      s.extractNullable(),
                      " ",
                      c.token.symbol
                    ]
                  }
                )
              ]
            }
          )
        ]
      }
    ) }),
    /* @__PURE__ */ y.jsx($o, { heightPx: 60 })
  ) });
}, Xue = ({
  isFirst: e,
  isLast: t
}) => /* @__PURE__ */ y.jsxs(
  z,
  {
    flex: 1,
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    gap: "1",
    children: [
      /* @__PURE__ */ y.jsx(
        z,
        {
          flex: 1,
          width: "1",
          background: e ? "transparent" : "tokenSelectBackground"
        }
      ),
      /* @__PURE__ */ y.jsx(
        z,
        {
          width: "3",
          height: "3",
          borderRadius: "full",
          background: "tokenSelectBackground"
        }
      ),
      /* @__PURE__ */ y.jsx(
        z,
        {
          flex: 1,
          width: "1",
          background: t ? "transparent" : "tokenSelectBackground"
        }
      )
    ]
  }
), Zue = () => {
  const { address: e, network: t } = wt(), n = zL(), r = Fs(), { isLedgerLive: i } = wt(), o = ci(), s = $D({
    enabled: !!e && !!t,
    queryKey: VL({
      network: t,
      walletAddress: e
    }),
    queryFn: async ({ pageParam: l = 1 }) => (await de(
      () => n({
        page: l,
        walletAddress: e,
        network: t,
        sort: "createdAtDesc"
      })
    ).mapLeft(() => new Error("Could not get action list")).map((c) => ({
      ...c,
      data: c.data.filter(
        (u) => u.status !== Gi.CREATED
      )
    })).chain(
      async (c) => de.all(
        c.data.map(
          (u) => Ty({
            yieldId: u.integrationId,
            isLedgerLive: i,
            queryClient: o,
            yieldYieldOpportunity: r
          }).map((d) => ({ actionData: u, yieldData: d })).chainLeft(() => de(() => Promise.resolve(null)))
        )
      ).map((u) => u.filter((d) => d !== null)).map((u) => u.filter((d) => !!d.actionData.inputToken)).map((u) => ({ ...c, data: u }))
    )).unsafeCoerce(),
    initialPageParam: 1,
    getNextPageParam: (l) => l.hasNextPage ? l.page + 1 : void 0
  });
  return {
    allItems: J(
      () => {
        var l;
        return (l = s.data) == null ? void 0 : l.pages.flatMap((c) => c.data);
      },
      [s.data]
    ),
    ...s
  };
}, gs = {
  ALONE: "alone",
  FIRST: "first",
  MIDDLE: "middle",
  LAST: "last"
}, K6 = Ge(
  void 0
), ede = ({
  children: e
}) => {
  const t = vc(), { openConnectModal: n } = by(), { isConnected: r } = wt(), i = er(), { i18n: o } = ze(), s = (p) => {
    if (!r) return n == null ? void 0 : n();
    if (t.send({
      type: "setSelectedAction",
      data: G.of({
        selectedAction: p.actionData,
        selectedYield: p.yieldData
      })
    }), p.actionData.status === Gi.SUCCESS || p.actionData.status === Gi.PROCESSING) {
      const m = p.actionData.transactions.map((v) => ({ type: v.type, url: v.explorerUrl })).filter(
        (v) => !!v.url
      ), g = p.actionData.type === oa.UNSTAKE ? "unstake" : p.actionData.type === oa.STAKE ? "stake" : "pending";
      return i(`/activity/${g}-review/complete`, {
        state: {
          urls: m
        }
      });
    }
    if (p.actionData.status === Gi.CREATED || p.actionData.status === Gi.WAITING_FOR_NEXT || p.actionData.status === Gi.FAILED)
      return i("/activity/review");
  }, a = Zue(), l = J(
    () => G.fromNullable(a.allItems),
    [a.allItems]
  ), c = J(
    () => l.map((p) => p.map((m) => m.actionData.createdAt)),
    [l]
  ), [u, d] = J(
    () => vL(c.extract() ?? [], o),
    [c, o]
  ), f = J(
    () => d.reduce(
      (p, m) => p.concat(nde(m)),
      []
    ),
    [d]
  ), h = {
    onActionSelect: s,
    activityActions: a,
    labels: u,
    counts: d,
    bulletLines: f
  };
  return /* @__PURE__ */ y.jsx(K6.Provider, { value: h, children: e });
}, tde = () => {
  const e = we(K6);
  if (!e)
    throw new Error(
      "useActivityPageContext must be used within a ActivityPageContext"
    );
  return e;
}, nde = (e) => Array.from({ length: e }, (t, n) => e === 1 ? gs.ALONE : n === 0 ? gs.FIRST : n === e - 1 ? gs.LAST : gs.MIDDLE), rde = (e, t) => e === "today" ? t("activity.date_group_labels.today") : e === "yesterday" ? t("activity.date_group_labels.yesterday") : e;
let fS = () => {
};
const ide = () => ({
  closeChainModal: fS,
  setCloseChainModal: (e) => {
    fS = e;
  }
}), wx = () => {
  const { connector: e } = wt(), { closeChainModal: t } = ide();
  return li({
    mutationFn: async (n) => {
      (await de.liftEither(
        e && bo(e) ? _e(e) : Xe(new Error("Only Ledger Live is supported"))
      ).chain(
        (r) => r.requestAndSwitchAccount(n)
      ).ifRight(t)).unsafeCoerce();
    }
  });
}, ode = (e) => {
  const { t } = ze(), { isLedgerLiveAccountPlaceholder: n, chain: r } = wt(), i = wx(), { openConnectModal: o } = by(), s = cn(), a = () => {
    if (n && r)
      return s("addLedgerAccountClicked"), i.mutate(r);
    s("connectWalletClicked"), o == null || o();
  };
  return /* @__PURE__ */ y.jsx(si, { onClick: a, ...e, children: t(
    n ? "init.ledger_add_account" : "init.connect_wallet"
  ) });
}, Cl = ({
  type: e
}) => {
  const { t } = ze(), { externalProviders: n } = bt(), r = () => e === "spinner" ? /* @__PURE__ */ y.jsx(z, { display: "flex", justifyContent: "center", children: /* @__PURE__ */ y.jsx(ei, {}) }) : e === "not_connected" && !n ? /* @__PURE__ */ y.jsx(ode, {}) : e === "something_wrong" ? /* @__PURE__ */ y.jsx(ue, { variant: { type: "danger" }, textAlign: "center", children: t("shared.something_went_wrong") }) : e === "no_current_positions" ? /* @__PURE__ */ y.jsx(ue, { variant: { weight: "medium" }, textAlign: "center", children: t("positions.no_current_positions") }) : e === "no_previous_activity" ? /* @__PURE__ */ y.jsx(ue, { variant: { weight: "medium" }, textAlign: "center", children: t("activity.no_previous_activity") }) : null;
  return /* @__PURE__ */ y.jsx(z, { marginTop: "2", marginBottom: "4", children: r() });
}, sde = () => {
  Vn("activity");
  const { t: e } = ze(), { isConnected: t, isConnecting: n } = wt(), { mountAnimationFinished: r } = qo(), { activityActions: i, onActionSelect: o, labels: s, counts: a, bulletLines: l } = tde(), c = i.allItems, u = J(() => !t && !n ? /* @__PURE__ */ y.jsx(Cl, { type: "not_connected" }) : t && !(c != null && c.length) && !i.isPending ? /* @__PURE__ */ y.jsx(z, { my: "4", children: /* @__PURE__ */ y.jsx(Cl, { type: "no_previous_activity" }) }) : t && i.isPending && !i.isFetchingNextPage ? /* @__PURE__ */ y.jsx(z, { display: "flex", gap: "1", flexDirection: "column", children: [...Array(5).keys()].map((d) => /* @__PURE__ */ y.jsx($o, { heightPx: 60 }, d)) }) : null, [
    t,
    n,
    c,
    i.isPending,
    i.isFetchingNextPage
  ]);
  return /* @__PURE__ */ y.jsx(
    Zt.div,
    {
      initial: { opacity: 0, translateY: "-10px" },
      animate: { opacity: 1, translateY: 0 },
      transition: {
        duration: r ? 0.3 : 1,
        delay: r ? 0 : 1.5
      },
      children: /* @__PURE__ */ y.jsx($s, { children: /* @__PURE__ */ y.jsxs(
        z,
        {
          className: Vue,
          display: "flex",
          flex: 1,
          flexDirection: "column",
          children: [
            u,
            /* @__PURE__ */ y.jsx(z, { display: "flex", flexDirection: "column", children: !i.isPending && c && /* @__PURE__ */ y.jsx(
              bx,
              {
                hasNextPage: i.hasNextPage,
                isFetchingNextPage: i.isFetchingNextPage,
                fetchNextPage: i.fetchNextPage,
                estimateSize: () => 60,
                groupCounts: a,
                groupContent: (d) => /* @__PURE__ */ y.jsx(z, { py: "4", children: /* @__PURE__ */ y.jsx(ue, { variant: { weight: "bold" }, children: rde(s[d], e) }) }),
                itemContent: (d) => {
                  const f = c[d];
                  return /* @__PURE__ */ y.jsxs(z, { className: Hue, children: [
                    /* @__PURE__ */ y.jsx(
                      Xue,
                      {
                        isFirst: l[d] === gs.FIRST || l[d] === gs.ALONE,
                        isLast: l[d] === gs.LAST || l[d] === gs.ALONE
                      }
                    ),
                    /* @__PURE__ */ y.jsx(
                      Jue,
                      {
                        onActionSelect: o,
                        action: f
                      }
                    )
                  ] });
                }
              }
            ) })
          ]
        }
      ) })
    }
  );
}, ade = () => /* @__PURE__ */ y.jsx(ede, { children: /* @__PURE__ */ y.jsx(sde, {}) }), ka = () => /* @__PURE__ */ y.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    fill: "#909090",
    viewBox: "0 0 256 256",
    children: /* @__PURE__ */ y.jsx("path", { d: "M108 84a16 16 0 1 1 16 16 16 16 0 0 1-16-16Zm128 44A108 108 0 1 1 128 20a108.12 108.12 0 0 1 108 108Zm-24 0a84 84 0 1 0-84 84 84.09 84.09 0 0 0 84-84Zm-72 36.68V132a20 20 0 0 0-20-20 12 12 0 0 0-4 23.32V168a20 20 0 0 0 20 20 12 12 0 0 0 4-23.32Z" })
  }
), lde = ["top", "right", "bottom", "left"], Os = Math.min, Ir = Math.max, hp = Math.round, rh = Math.floor, Bs = (e) => ({
  x: e,
  y: e
}), cde = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, ude = {
  start: "end",
  end: "start"
};
function x0(e, t, n) {
  return Ir(e, Os(t, n));
}
function Do(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function jo(e) {
  return e.split("-")[0];
}
function Gc(e) {
  return e.split("-")[1];
}
function xx(e) {
  return e === "x" ? "y" : "x";
}
function Cx(e) {
  return e === "y" ? "height" : "width";
}
function Hc(e) {
  return ["top", "bottom"].includes(jo(e)) ? "y" : "x";
}
function kx(e) {
  return xx(Hc(e));
}
function dde(e, t, n) {
  n === void 0 && (n = !1);
  const r = Gc(e), i = kx(e), o = Cx(i);
  let s = i === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[o] > t.floating[o] && (s = pp(s)), [s, pp(s)];
}
function fde(e) {
  const t = pp(e);
  return [C0(e), t, C0(t)];
}
function C0(e) {
  return e.replace(/start|end/g, (t) => ude[t]);
}
function hde(e, t, n) {
  const r = ["left", "right"], i = ["right", "left"], o = ["top", "bottom"], s = ["bottom", "top"];
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? i : r : t ? r : i;
    case "left":
    case "right":
      return t ? o : s;
    default:
      return [];
  }
}
function pde(e, t, n, r) {
  const i = Gc(e);
  let o = hde(jo(e), n === "start", r);
  return i && (o = o.map((s) => s + "-" + i), t && (o = o.concat(o.map(C0)))), o;
}
function pp(e) {
  return e.replace(/left|right|bottom|top/g, (t) => cde[t]);
}
function yde(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function Y6(e) {
  return typeof e != "number" ? yde(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function yp(e) {
  return {
    ...e,
    top: e.y,
    left: e.x,
    right: e.x + e.width,
    bottom: e.y + e.height
  };
}
function hS(e, t, n) {
  let {
    reference: r,
    floating: i
  } = e;
  const o = Hc(t), s = kx(t), a = Cx(s), l = jo(t), c = o === "y", u = r.x + r.width / 2 - i.width / 2, d = r.y + r.height / 2 - i.height / 2, f = r[a] / 2 - i[a] / 2;
  let h;
  switch (l) {
    case "top":
      h = {
        x: u,
        y: r.y - i.height
      };
      break;
    case "bottom":
      h = {
        x: u,
        y: r.y + r.height
      };
      break;
    case "right":
      h = {
        x: r.x + r.width,
        y: d
      };
      break;
    case "left":
      h = {
        x: r.x - i.width,
        y: d
      };
      break;
    default:
      h = {
        x: r.x,
        y: r.y
      };
  }
  switch (Gc(t)) {
    case "start":
      h[s] -= f * (n && c ? -1 : 1);
      break;
    case "end":
      h[s] += f * (n && c ? -1 : 1);
      break;
  }
  return h;
}
const mde = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: o = [],
    platform: s
  } = n, a = o.filter(Boolean), l = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let c = await s.getElementRects({
    reference: e,
    floating: t,
    strategy: i
  }), {
    x: u,
    y: d
  } = hS(c, r, l), f = r, h = {}, p = 0;
  for (let m = 0; m < a.length; m++) {
    const {
      name: g,
      fn: v
    } = a[m], {
      x: w,
      y: x,
      data: C,
      reset: S
    } = await v({
      x: u,
      y: d,
      initialPlacement: r,
      placement: f,
      strategy: i,
      middlewareData: h,
      rects: c,
      platform: s,
      elements: {
        reference: e,
        floating: t
      }
    });
    if (u = w ?? u, d = x ?? d, h = {
      ...h,
      [g]: {
        ...h[g],
        ...C
      }
    }, S && p <= 50) {
      p++, typeof S == "object" && (S.placement && (f = S.placement), S.rects && (c = S.rects === !0 ? await s.getElementRects({
        reference: e,
        floating: t,
        strategy: i
      }) : S.rects), {
        x: u,
        y: d
      } = hS(c, f, l)), m = -1;
      continue;
    }
  }
  return {
    x: u,
    y: d,
    placement: f,
    strategy: i,
    middlewareData: h
  };
};
async function vd(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: i,
    platform: o,
    rects: s,
    elements: a,
    strategy: l
  } = e, {
    boundary: c = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: d = "floating",
    altBoundary: f = !1,
    padding: h = 0
  } = Do(t, e), p = Y6(h), g = a[f ? d === "floating" ? "reference" : "floating" : d], v = yp(await o.getClippingRect({
    element: (n = await (o.isElement == null ? void 0 : o.isElement(g))) == null || n ? g : g.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(a.floating)),
    boundary: c,
    rootBoundary: u,
    strategy: l
  })), w = d === "floating" ? {
    ...s.floating,
    x: r,
    y: i
  } : s.reference, x = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(a.floating)), C = await (o.isElement == null ? void 0 : o.isElement(x)) ? await (o.getScale == null ? void 0 : o.getScale(x)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, S = yp(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: w,
    offsetParent: x,
    strategy: l
  }) : w);
  return {
    top: (v.top - S.top + p.top) / C.y,
    bottom: (S.bottom - v.bottom + p.bottom) / C.y,
    left: (v.left - S.left + p.left) / C.x,
    right: (S.right - v.right + p.right) / C.x
  };
}
const gde = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: r,
      placement: i,
      rects: o,
      platform: s,
      elements: a,
      middlewareData: l
    } = t, {
      element: c,
      padding: u = 0
    } = Do(e, t) || {};
    if (c == null)
      return {};
    const d = Y6(u), f = {
      x: n,
      y: r
    }, h = kx(i), p = Cx(h), m = await s.getDimensions(c), g = h === "y", v = g ? "top" : "left", w = g ? "bottom" : "right", x = g ? "clientHeight" : "clientWidth", C = o.reference[p] + o.reference[h] - f[h] - o.floating[p], S = f[h] - o.reference[h], k = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(c));
    let A = k ? k[x] : 0;
    (!A || !await (s.isElement == null ? void 0 : s.isElement(k))) && (A = a.floating[x] || o.floating[p]);
    const b = C / 2 - S / 2, T = A / 2 - m[p] / 2 - 1, R = Os(d[v], T), B = Os(d[w], T), O = R, L = A - m[p] - B, V = A / 2 - m[p] / 2 + b, N = x0(O, V, L), M = !l.arrow && Gc(i) != null && V != N && o.reference[p] / 2 - (V < O ? R : B) - m[p] / 2 < 0, U = M ? V < O ? V - O : V - L : 0;
    return {
      [h]: f[h] + U,
      data: {
        [h]: N,
        centerOffset: V - N - U,
        ...M && {
          alignmentOffset: U
        }
      },
      reset: M
    };
  }
}), vde = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: i,
        middlewareData: o,
        rects: s,
        initialPlacement: a,
        platform: l,
        elements: c
      } = t, {
        mainAxis: u = !0,
        crossAxis: d = !0,
        fallbackPlacements: f,
        fallbackStrategy: h = "bestFit",
        fallbackAxisSideDirection: p = "none",
        flipAlignment: m = !0,
        ...g
      } = Do(e, t);
      if ((n = o.arrow) != null && n.alignmentOffset)
        return {};
      const v = jo(i), w = jo(a) === a, x = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), C = f || (w || !m ? [pp(a)] : fde(a));
      !f && p !== "none" && C.push(...pde(a, m, p, x));
      const S = [a, ...C], k = await vd(t, g), A = [];
      let b = ((r = o.flip) == null ? void 0 : r.overflows) || [];
      if (u && A.push(k[v]), d) {
        const O = dde(i, s, x);
        A.push(k[O[0]], k[O[1]]);
      }
      if (b = [...b, {
        placement: i,
        overflows: A
      }], !A.every((O) => O <= 0)) {
        var T, R;
        const O = (((T = o.flip) == null ? void 0 : T.index) || 0) + 1, L = S[O];
        if (L)
          return {
            data: {
              index: O,
              overflows: b
            },
            reset: {
              placement: L
            }
          };
        let V = (R = b.filter((N) => N.overflows[0] <= 0).sort((N, M) => N.overflows[1] - M.overflows[1])[0]) == null ? void 0 : R.placement;
        if (!V)
          switch (h) {
            case "bestFit": {
              var B;
              const N = (B = b.map((M) => [M.placement, M.overflows.filter((U) => U > 0).reduce((U, F) => U + F, 0)]).sort((M, U) => M[1] - U[1])[0]) == null ? void 0 : B[0];
              N && (V = N);
              break;
            }
            case "initialPlacement":
              V = a;
              break;
          }
        if (i !== V)
          return {
            reset: {
              placement: V
            }
          };
      }
      return {};
    }
  };
};
function pS(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function yS(e) {
  return lde.some((t) => e[t] >= 0);
}
const bde = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: r = "referenceHidden",
        ...i
      } = Do(e, t);
      switch (r) {
        case "referenceHidden": {
          const o = await vd(t, {
            ...i,
            elementContext: "reference"
          }), s = pS(o, n.reference);
          return {
            data: {
              referenceHiddenOffsets: s,
              referenceHidden: yS(s)
            }
          };
        }
        case "escaped": {
          const o = await vd(t, {
            ...i,
            altBoundary: !0
          }), s = pS(o, n.floating);
          return {
            data: {
              escapedOffsets: s,
              escaped: yS(s)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
async function wde(e, t) {
  const {
    placement: n,
    platform: r,
    elements: i
  } = e, o = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), s = jo(n), a = Gc(n), l = Hc(n) === "y", c = ["left", "top"].includes(s) ? -1 : 1, u = o && l ? -1 : 1, d = Do(t, e);
  let {
    mainAxis: f,
    crossAxis: h,
    alignmentAxis: p
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...d
  };
  return a && typeof p == "number" && (h = a === "end" ? p * -1 : p), l ? {
    x: h * u,
    y: f * c
  } : {
    x: f * c,
    y: h * u
  };
}
const xde = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, r;
      const {
        x: i,
        y: o,
        placement: s,
        middlewareData: a
      } = t, l = await wde(t, e);
      return s === ((n = a.offset) == null ? void 0 : n.placement) && (r = a.arrow) != null && r.alignmentOffset ? {} : {
        x: i + l.x,
        y: o + l.y,
        data: {
          ...l,
          placement: s
        }
      };
    }
  };
}, Cde = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: i
      } = t, {
        mainAxis: o = !0,
        crossAxis: s = !1,
        limiter: a = {
          fn: (g) => {
            let {
              x: v,
              y: w
            } = g;
            return {
              x: v,
              y: w
            };
          }
        },
        ...l
      } = Do(e, t), c = {
        x: n,
        y: r
      }, u = await vd(t, l), d = Hc(jo(i)), f = xx(d);
      let h = c[f], p = c[d];
      if (o) {
        const g = f === "y" ? "top" : "left", v = f === "y" ? "bottom" : "right", w = h + u[g], x = h - u[v];
        h = x0(w, h, x);
      }
      if (s) {
        const g = d === "y" ? "top" : "left", v = d === "y" ? "bottom" : "right", w = p + u[g], x = p - u[v];
        p = x0(w, p, x);
      }
      const m = a.fn({
        ...t,
        [f]: h,
        [d]: p
      });
      return {
        ...m,
        data: {
          x: m.x - n,
          y: m.y - r
        }
      };
    }
  };
}, kde = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: r,
        placement: i,
        rects: o,
        middlewareData: s
      } = t, {
        offset: a = 0,
        mainAxis: l = !0,
        crossAxis: c = !0
      } = Do(e, t), u = {
        x: n,
        y: r
      }, d = Hc(i), f = xx(d);
      let h = u[f], p = u[d];
      const m = Do(a, t), g = typeof m == "number" ? {
        mainAxis: m,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...m
      };
      if (l) {
        const x = f === "y" ? "height" : "width", C = o.reference[f] - o.floating[x] + g.mainAxis, S = o.reference[f] + o.reference[x] - g.mainAxis;
        h < C ? h = C : h > S && (h = S);
      }
      if (c) {
        var v, w;
        const x = f === "y" ? "width" : "height", C = ["top", "left"].includes(jo(i)), S = o.reference[d] - o.floating[x] + (C && ((v = s.offset) == null ? void 0 : v[d]) || 0) + (C ? 0 : g.crossAxis), k = o.reference[d] + o.reference[x] + (C ? 0 : ((w = s.offset) == null ? void 0 : w[d]) || 0) - (C ? g.crossAxis : 0);
        p < S ? p = S : p > k && (p = k);
      }
      return {
        [f]: h,
        [d]: p
      };
    }
  };
}, Ede = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      const {
        placement: n,
        rects: r,
        platform: i,
        elements: o
      } = t, {
        apply: s = () => {
        },
        ...a
      } = Do(e, t), l = await vd(t, a), c = jo(n), u = Gc(n), d = Hc(n) === "y", {
        width: f,
        height: h
      } = r.floating;
      let p, m;
      c === "top" || c === "bottom" ? (p = c, m = u === (await (i.isRTL == null ? void 0 : i.isRTL(o.floating)) ? "start" : "end") ? "left" : "right") : (m = c, p = u === "end" ? "top" : "bottom");
      const g = h - l[p], v = f - l[m], w = !t.middlewareData.shift;
      let x = g, C = v;
      if (d) {
        const k = f - l.left - l.right;
        C = u || w ? Os(v, k) : k;
      } else {
        const k = h - l.top - l.bottom;
        x = u || w ? Os(g, k) : k;
      }
      if (w && !u) {
        const k = Ir(l.left, 0), A = Ir(l.right, 0), b = Ir(l.top, 0), T = Ir(l.bottom, 0);
        d ? C = f - 2 * (k !== 0 || A !== 0 ? k + A : Ir(l.left, l.right)) : x = h - 2 * (b !== 0 || T !== 0 ? b + T : Ir(l.top, l.bottom));
      }
      await s({
        ...t,
        availableWidth: C,
        availableHeight: x
      });
      const S = await i.getDimensions(o.floating);
      return f !== S.width || h !== S.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function Ns(e) {
  return Q6(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function Or(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Wo(e) {
  var t;
  return (t = (Q6(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function Q6(e) {
  return e instanceof Node || e instanceof Or(e).Node;
}
function Mo(e) {
  return e instanceof Element || e instanceof Or(e).Element;
}
function no(e) {
  return e instanceof HTMLElement || e instanceof Or(e).HTMLElement;
}
function mS(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof Or(e).ShadowRoot;
}
function pf(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: i
  } = ai(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(i);
}
function Sde(e) {
  return ["table", "td", "th"].includes(Ns(e));
}
function Ex(e) {
  const t = Sx(), n = ai(e);
  return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((r) => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (n.contain || "").includes(r));
}
function Ade(e) {
  let t = wc(e);
  for (; no(t) && !em(t); ) {
    if (Ex(t))
      return t;
    t = wc(t);
  }
  return null;
}
function Sx() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function em(e) {
  return ["html", "body", "#document"].includes(Ns(e));
}
function ai(e) {
  return Or(e).getComputedStyle(e);
}
function tm(e) {
  return Mo(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.pageXOffset,
    scrollTop: e.pageYOffset
  };
}
function wc(e) {
  if (Ns(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    mS(e) && e.host || // Fallback.
    Wo(e)
  );
  return mS(t) ? t.host : t;
}
function J6(e) {
  const t = wc(e);
  return em(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : no(t) && pf(t) ? t : J6(t);
}
function bd(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const i = J6(e), o = i === ((r = e.ownerDocument) == null ? void 0 : r.body), s = Or(i);
  return o ? t.concat(s, s.visualViewport || [], pf(i) ? i : [], s.frameElement && n ? bd(s.frameElement) : []) : t.concat(i, bd(i, [], n));
}
function X6(e) {
  const t = ai(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const i = no(e), o = i ? e.offsetWidth : n, s = i ? e.offsetHeight : r, a = hp(n) !== o || hp(r) !== s;
  return a && (n = o, r = s), {
    width: n,
    height: r,
    $: a
  };
}
function Ax(e) {
  return Mo(e) ? e : e.contextElement;
}
function Rl(e) {
  const t = Ax(e);
  if (!no(t))
    return Bs(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: i,
    $: o
  } = X6(t);
  let s = (o ? hp(n.width) : n.width) / r, a = (o ? hp(n.height) : n.height) / i;
  return (!s || !Number.isFinite(s)) && (s = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: s,
    y: a
  };
}
const Tde = /* @__PURE__ */ Bs(0);
function Z6(e) {
  const t = Or(e);
  return !Sx() || !t.visualViewport ? Tde : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function _de(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== Or(e) ? !1 : t;
}
function ja(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const i = e.getBoundingClientRect(), o = Ax(e);
  let s = Bs(1);
  t && (r ? Mo(r) && (s = Rl(r)) : s = Rl(e));
  const a = _de(o, n, r) ? Z6(o) : Bs(0);
  let l = (i.left + a.x) / s.x, c = (i.top + a.y) / s.y, u = i.width / s.x, d = i.height / s.y;
  if (o) {
    const f = Or(o), h = r && Mo(r) ? Or(r) : r;
    let p = f.frameElement;
    for (; p && r && h !== f; ) {
      const m = Rl(p), g = p.getBoundingClientRect(), v = ai(p), w = g.left + (p.clientLeft + parseFloat(v.paddingLeft)) * m.x, x = g.top + (p.clientTop + parseFloat(v.paddingTop)) * m.y;
      l *= m.x, c *= m.y, u *= m.x, d *= m.y, l += w, c += x, p = Or(p).frameElement;
    }
  }
  return yp({
    width: u,
    height: d,
    x: l,
    y: c
  });
}
function Ide(e) {
  let {
    rect: t,
    offsetParent: n,
    strategy: r
  } = e;
  const i = no(n), o = Wo(n);
  if (n === o)
    return t;
  let s = {
    scrollLeft: 0,
    scrollTop: 0
  }, a = Bs(1);
  const l = Bs(0);
  if ((i || !i && r !== "fixed") && ((Ns(n) !== "body" || pf(o)) && (s = tm(n)), no(n))) {
    const c = ja(n);
    a = Rl(n), l.x = c.x + n.clientLeft, l.y = c.y + n.clientTop;
  }
  return {
    width: t.width * a.x,
    height: t.height * a.y,
    x: t.x * a.x - s.scrollLeft * a.x + l.x,
    y: t.y * a.y - s.scrollTop * a.y + l.y
  };
}
function Rde(e) {
  return Array.from(e.getClientRects());
}
function eB(e) {
  return ja(Wo(e)).left + tm(e).scrollLeft;
}
function Pde(e) {
  const t = Wo(e), n = tm(e), r = e.ownerDocument.body, i = Ir(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), o = Ir(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let s = -n.scrollLeft + eB(e);
  const a = -n.scrollTop;
  return ai(r).direction === "rtl" && (s += Ir(t.clientWidth, r.clientWidth) - i), {
    width: i,
    height: o,
    x: s,
    y: a
  };
}
function Ode(e, t) {
  const n = Or(e), r = Wo(e), i = n.visualViewport;
  let o = r.clientWidth, s = r.clientHeight, a = 0, l = 0;
  if (i) {
    o = i.width, s = i.height;
    const c = Sx();
    (!c || c && t === "fixed") && (a = i.offsetLeft, l = i.offsetTop);
  }
  return {
    width: o,
    height: s,
    x: a,
    y: l
  };
}
function Bde(e, t) {
  const n = ja(e, !0, t === "fixed"), r = n.top + e.clientTop, i = n.left + e.clientLeft, o = no(e) ? Rl(e) : Bs(1), s = e.clientWidth * o.x, a = e.clientHeight * o.y, l = i * o.x, c = r * o.y;
  return {
    width: s,
    height: a,
    x: l,
    y: c
  };
}
function gS(e, t, n) {
  let r;
  if (t === "viewport")
    r = Ode(e, n);
  else if (t === "document")
    r = Pde(Wo(e));
  else if (Mo(t))
    r = Bde(t, n);
  else {
    const i = Z6(e);
    r = {
      ...t,
      x: t.x - i.x,
      y: t.y - i.y
    };
  }
  return yp(r);
}
function tB(e, t) {
  const n = wc(e);
  return n === t || !Mo(n) || em(n) ? !1 : ai(n).position === "fixed" || tB(n, t);
}
function Nde(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = bd(e, [], !1).filter((a) => Mo(a) && Ns(a) !== "body"), i = null;
  const o = ai(e).position === "fixed";
  let s = o ? wc(e) : e;
  for (; Mo(s) && !em(s); ) {
    const a = ai(s), l = Ex(s);
    !l && a.position === "fixed" && (i = null), (o ? !l && !i : !l && a.position === "static" && !!i && ["absolute", "fixed"].includes(i.position) || pf(s) && !l && tB(e, s)) ? r = r.filter((u) => u !== s) : i = a, s = wc(s);
  }
  return t.set(e, r), r;
}
function Dde(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: i
  } = e;
  const s = [...n === "clippingAncestors" ? Nde(t, this._c) : [].concat(n), r], a = s[0], l = s.reduce((c, u) => {
    const d = gS(t, u, i);
    return c.top = Ir(d.top, c.top), c.right = Os(d.right, c.right), c.bottom = Os(d.bottom, c.bottom), c.left = Ir(d.left, c.left), c;
  }, gS(t, a, i));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function jde(e) {
  const {
    width: t,
    height: n
  } = X6(e);
  return {
    width: t,
    height: n
  };
}
function Mde(e, t, n) {
  const r = no(t), i = Wo(t), o = n === "fixed", s = ja(e, !0, o, t);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = Bs(0);
  if (r || !r && !o)
    if ((Ns(t) !== "body" || pf(i)) && (a = tm(t)), r) {
      const c = ja(t, !0, o, t);
      l.x = c.x + t.clientLeft, l.y = c.y + t.clientTop;
    } else i && (l.x = eB(i));
  return {
    x: s.left + a.scrollLeft - l.x,
    y: s.top + a.scrollTop - l.y,
    width: s.width,
    height: s.height
  };
}
function vS(e, t) {
  return !no(e) || ai(e).position === "fixed" ? null : t ? t(e) : e.offsetParent;
}
function nB(e, t) {
  const n = Or(e);
  if (!no(e))
    return n;
  let r = vS(e, t);
  for (; r && Sde(r) && ai(r).position === "static"; )
    r = vS(r, t);
  return r && (Ns(r) === "html" || Ns(r) === "body" && ai(r).position === "static" && !Ex(r)) ? n : r || Ade(e) || n;
}
const Fde = async function(e) {
  let {
    reference: t,
    floating: n,
    strategy: r
  } = e;
  const i = this.getOffsetParent || nB, o = this.getDimensions;
  return {
    reference: Mde(t, await i(n), r),
    floating: {
      x: 0,
      y: 0,
      ...await o(n)
    }
  };
};
function Lde(e) {
  return ai(e).direction === "rtl";
}
const Ude = {
  convertOffsetParentRelativeRectToViewportRelativeRect: Ide,
  getDocumentElement: Wo,
  getClippingRect: Dde,
  getOffsetParent: nB,
  getElementRects: Fde,
  getClientRects: Rde,
  getDimensions: jde,
  getScale: Rl,
  isElement: Mo,
  isRTL: Lde
};
function zde(e, t) {
  let n = null, r;
  const i = Wo(e);
  function o() {
    clearTimeout(r), n && n.disconnect(), n = null;
  }
  function s(a, l) {
    a === void 0 && (a = !1), l === void 0 && (l = 1), o();
    const {
      left: c,
      top: u,
      width: d,
      height: f
    } = e.getBoundingClientRect();
    if (a || t(), !d || !f)
      return;
    const h = rh(u), p = rh(i.clientWidth - (c + d)), m = rh(i.clientHeight - (u + f)), g = rh(c), w = {
      rootMargin: -h + "px " + -p + "px " + -m + "px " + -g + "px",
      threshold: Ir(0, Os(1, l)) || 1
    };
    let x = !0;
    function C(S) {
      const k = S[0].intersectionRatio;
      if (k !== l) {
        if (!x)
          return s();
        k ? s(!1, k) : r = setTimeout(() => {
          s(!1, 1e-7);
        }, 100);
      }
      x = !1;
    }
    try {
      n = new IntersectionObserver(C, {
        ...w,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(C, w);
    }
    n.observe(e);
  }
  return s(!0), o;
}
function Vde(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: o = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = r, c = Ax(e), u = i || o ? [...c ? bd(c) : [], ...bd(t)] : [];
  u.forEach((v) => {
    i && v.addEventListener("scroll", n, {
      passive: !0
    }), o && v.addEventListener("resize", n);
  });
  const d = c && a ? zde(c, n) : null;
  let f = -1, h = null;
  s && (h = new ResizeObserver((v) => {
    let [w] = v;
    w && w.target === c && h && (h.unobserve(t), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
      h && h.observe(t);
    })), n();
  }), c && !l && h.observe(c), h.observe(t));
  let p, m = l ? ja(e) : null;
  l && g();
  function g() {
    const v = ja(e);
    m && (v.x !== m.x || v.y !== m.y || v.width !== m.width || v.height !== m.height) && n(), m = v, p = requestAnimationFrame(g);
  }
  return n(), () => {
    u.forEach((v) => {
      i && v.removeEventListener("scroll", n), o && v.removeEventListener("resize", n);
    }), d && d(), h && h.disconnect(), h = null, l && cancelAnimationFrame(p);
  };
}
const qde = Cde, $de = vde, Wde = Ede, Gde = bde, bS = gde, Hde = kde, Kde = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), i = {
    platform: Ude,
    ...n
  }, o = {
    ...i.platform,
    _c: r
  };
  return mde(e, t, {
    ...i,
    platform: o
  });
}, Yde = (e) => {
  function t(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(n) {
      const {
        element: r,
        padding: i
      } = typeof e == "function" ? e(n) : e;
      return r && t(r) ? r.current != null ? bS({
        element: r.current,
        padding: i
      }).fn(n) : {} : r ? bS({
        element: r,
        padding: i
      }).fn(n) : {};
    }
  };
};
var _h = typeof document < "u" ? js : Te;
function mp(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, r, i;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n != t.length) return !1;
      for (r = n; r-- !== 0; )
        if (!mp(e[r], t[r]))
          return !1;
      return !0;
    }
    if (i = Object.keys(e), n = i.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(t, i[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const o = i[r];
      if (!(o === "_owner" && e.$$typeof) && !mp(e[o], t[o]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function rB(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function wS(e, t) {
  const n = rB(e);
  return Math.round(t * n) / n;
}
function xS(e) {
  const t = P.useRef(e);
  return _h(() => {
    t.current = e;
  }), t;
}
function Qde(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: i,
    elements: {
      reference: o,
      floating: s
    } = {},
    transform: a = !0,
    whileElementsMounted: l,
    open: c
  } = e, [u, d] = P.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [f, h] = P.useState(r);
  mp(f, r) || h(r);
  const [p, m] = P.useState(null), [g, v] = P.useState(null), w = P.useCallback((M) => {
    M != k.current && (k.current = M, m(M));
  }, [m]), x = P.useCallback((M) => {
    M !== A.current && (A.current = M, v(M));
  }, [v]), C = o || p, S = s || g, k = P.useRef(null), A = P.useRef(null), b = P.useRef(u), T = xS(l), R = xS(i), B = P.useCallback(() => {
    if (!k.current || !A.current)
      return;
    const M = {
      placement: t,
      strategy: n,
      middleware: f
    };
    R.current && (M.platform = R.current), Kde(k.current, A.current, M).then((U) => {
      const F = {
        ...U,
        isPositioned: !0
      };
      O.current && !mp(b.current, F) && (b.current = F, Sp.flushSync(() => {
        d(F);
      }));
    });
  }, [f, t, n, R]);
  _h(() => {
    c === !1 && b.current.isPositioned && (b.current.isPositioned = !1, d((M) => ({
      ...M,
      isPositioned: !1
    })));
  }, [c]);
  const O = P.useRef(!1);
  _h(() => (O.current = !0, () => {
    O.current = !1;
  }), []), _h(() => {
    if (C && (k.current = C), S && (A.current = S), C && S) {
      if (T.current)
        return T.current(C, S, B);
      B();
    }
  }, [C, S, B, T]);
  const L = P.useMemo(() => ({
    reference: k,
    floating: A,
    setReference: w,
    setFloating: x
  }), [w, x]), V = P.useMemo(() => ({
    reference: C,
    floating: S
  }), [C, S]), N = P.useMemo(() => {
    const M = {
      position: n,
      left: 0,
      top: 0
    };
    if (!V.floating)
      return M;
    const U = wS(V.floating, u.x), F = wS(V.floating, u.y);
    return a ? {
      ...M,
      transform: "translate(" + U + "px, " + F + "px)",
      ...rB(V.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: U,
      top: F
    };
  }, [n, a, V.floating, u.x, u.y]);
  return P.useMemo(() => ({
    ...u,
    update: B,
    refs: L,
    elements: V,
    floatingStyles: N
  }), [u, B, L, V, N]);
}
var Jde = "Arrow", iB = P.forwardRef((e, t) => {
  const { children: n, width: r = 10, height: i = 5, ...o } = e;
  return /* @__PURE__ */ y.jsx(
    un.svg,
    {
      ...o,
      ref: t,
      width: r,
      height: i,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e.asChild ? n : /* @__PURE__ */ y.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
iB.displayName = Jde;
var Xde = iB;
function Zde(e) {
  const [t, n] = P.useState(void 0);
  return Na(() => {
    if (e) {
      n({ width: e.offsetWidth, height: e.offsetHeight });
      const r = new ResizeObserver((i) => {
        if (!Array.isArray(i) || !i.length)
          return;
        const o = i[0];
        let s, a;
        if ("borderBoxSize" in o) {
          const l = o.borderBoxSize, c = Array.isArray(l) ? l[0] : l;
          s = c.inlineSize, a = c.blockSize;
        } else
          s = e.offsetWidth, a = e.offsetHeight;
        n({ width: s, height: a });
      });
      return r.observe(e, { box: "border-box" }), () => r.unobserve(e);
    } else
      n(void 0);
  }, [e]), t;
}
var Tx = "Popper", [oB, nm] = Wa(Tx), [efe, sB] = oB(Tx), aB = (e) => {
  const { __scopePopper: t, children: n } = e, [r, i] = P.useState(null);
  return /* @__PURE__ */ y.jsx(efe, { scope: t, anchor: r, onAnchorChange: i, children: n });
};
aB.displayName = Tx;
var lB = "PopperAnchor", cB = P.forwardRef(
  (e, t) => {
    const { __scopePopper: n, virtualRef: r, ...i } = e, o = sB(lB, n), s = P.useRef(null), a = _n(t, s);
    return P.useEffect(() => {
      o.onAnchorChange((r == null ? void 0 : r.current) || s.current);
    }), r ? null : /* @__PURE__ */ y.jsx(un.div, { ...i, ref: a });
  }
);
cB.displayName = lB;
var _x = "PopperContent", [tfe, nfe] = oB(_x), uB = P.forwardRef(
  (e, t) => {
    var Be, it, lt, yt, gt, vt;
    const {
      __scopePopper: n,
      side: r = "bottom",
      sideOffset: i = 0,
      align: o = "center",
      alignOffset: s = 0,
      arrowPadding: a = 0,
      avoidCollisions: l = !0,
      collisionBoundary: c = [],
      collisionPadding: u = 0,
      sticky: d = "partial",
      hideWhenDetached: f = !1,
      updatePositionStrategy: h = "optimized",
      onPlaced: p,
      ...m
    } = e, g = sB(_x, n), [v, w] = P.useState(null), x = _n(t, (ot) => w(ot)), [C, S] = P.useState(null), k = Zde(C), A = (k == null ? void 0 : k.width) ?? 0, b = (k == null ? void 0 : k.height) ?? 0, T = r + (o !== "center" ? "-" + o : ""), R = typeof u == "number" ? u : { top: 0, right: 0, bottom: 0, left: 0, ...u }, B = Array.isArray(c) ? c : [c], O = B.length > 0, L = {
      padding: R,
      boundary: B.filter(ife),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: O
    }, { refs: V, floatingStyles: N, placement: M, isPositioned: U, middlewareData: F } = Qde({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: T,
      whileElementsMounted: (...ot) => Vde(...ot, {
        animationFrame: h === "always"
      }),
      elements: {
        reference: g.anchor
      },
      middleware: [
        xde({ mainAxis: i + b, alignmentAxis: s }),
        l && qde({
          mainAxis: !0,
          crossAxis: !1,
          limiter: d === "partial" ? Hde() : void 0,
          ...L
        }),
        l && $de({ ...L }),
        Wde({
          ...L,
          apply: ({ elements: ot, rects: Le, availableWidth: tt, availableHeight: jt }) => {
            const { width: rn, height: en } = Le.reference, Gt = ot.floating.style;
            Gt.setProperty("--radix-popper-available-width", `${tt}px`), Gt.setProperty("--radix-popper-available-height", `${jt}px`), Gt.setProperty("--radix-popper-anchor-width", `${rn}px`), Gt.setProperty("--radix-popper-anchor-height", `${en}px`);
          }
        }),
        C && Yde({ element: C, padding: a }),
        ofe({ arrowWidth: A, arrowHeight: b }),
        f && Gde({ strategy: "referenceHidden", ...L })
      ]
    }), [$, ie] = hB(M), he = _i(p);
    Na(() => {
      U && (he == null || he());
    }, [U, he]);
    const ae = (Be = F.arrow) == null ? void 0 : Be.x, se = (it = F.arrow) == null ? void 0 : it.y, oe = ((lt = F.arrow) == null ? void 0 : lt.centerOffset) !== 0, [ye, ve] = P.useState();
    return Na(() => {
      v && ve(window.getComputedStyle(v).zIndex);
    }, [v]), /* @__PURE__ */ y.jsx(
      "div",
      {
        ref: V.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...N,
          transform: U ? N.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: ye,
          "--radix-popper-transform-origin": [
            (yt = F.transformOrigin) == null ? void 0 : yt.x,
            (gt = F.transformOrigin) == null ? void 0 : gt.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((vt = F.hide) == null ? void 0 : vt.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: e.dir,
        children: /* @__PURE__ */ y.jsx(
          tfe,
          {
            scope: n,
            placedSide: $,
            onArrowChange: S,
            arrowX: ae,
            arrowY: se,
            shouldHideArrow: oe,
            children: /* @__PURE__ */ y.jsx(
              un.div,
              {
                "data-side": $,
                "data-align": ie,
                ...m,
                ref: x,
                style: {
                  ...m.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: U ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
uB.displayName = _x;
var dB = "PopperArrow", rfe = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, fB = P.forwardRef(function(t, n) {
  const { __scopePopper: r, ...i } = t, o = nfe(dB, r), s = rfe[o.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ y.jsx(
      "span",
      {
        ref: o.onArrowChange,
        style: {
          position: "absolute",
          left: o.arrowX,
          top: o.arrowY,
          [s]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[o.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[o.placedSide],
          visibility: o.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ y.jsx(
          Xde,
          {
            ...i,
            ref: n,
            style: {
              ...i.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
fB.displayName = dB;
function ife(e) {
  return e !== null;
}
var ofe = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    var g, v, w;
    const { placement: n, rects: r, middlewareData: i } = t, s = ((g = i.arrow) == null ? void 0 : g.centerOffset) !== 0, a = s ? 0 : e.arrowWidth, l = s ? 0 : e.arrowHeight, [c, u] = hB(n), d = { start: "0%", center: "50%", end: "100%" }[u], f = (((v = i.arrow) == null ? void 0 : v.x) ?? 0) + a / 2, h = (((w = i.arrow) == null ? void 0 : w.y) ?? 0) + l / 2;
    let p = "", m = "";
    return c === "bottom" ? (p = s ? d : `${f}px`, m = `${-l}px`) : c === "top" ? (p = s ? d : `${f}px`, m = `${r.floating.height + l}px`) : c === "right" ? (p = `${-l}px`, m = s ? d : `${h}px`) : c === "left" && (p = `${r.floating.width + l}px`, m = s ? d : `${h}px`), { data: { x: p, y: m } };
  }
});
function hB(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
var pB = aB, yB = cB, mB = uB, gB = fB, [rm, kbe] = Wa("Tooltip", [
  nm
]), im = nm(), vB = "TooltipProvider", sfe = 700, k0 = "tooltip.open", [afe, Ix] = rm(vB), bB = (e) => {
  const {
    __scopeTooltip: t,
    delayDuration: n = sfe,
    skipDelayDuration: r = 300,
    disableHoverableContent: i = !1,
    children: o
  } = e, [s, a] = P.useState(!0), l = P.useRef(!1), c = P.useRef(0);
  return P.useEffect(() => {
    const u = c.current;
    return () => window.clearTimeout(u);
  }, []), /* @__PURE__ */ y.jsx(
    afe,
    {
      scope: t,
      isOpenDelayed: s,
      delayDuration: n,
      onOpen: P.useCallback(() => {
        window.clearTimeout(c.current), a(!1);
      }, []),
      onClose: P.useCallback(() => {
        window.clearTimeout(c.current), c.current = window.setTimeout(
          () => a(!0),
          r
        );
      }, [r]),
      isPointerInTransitRef: l,
      onPointerInTransitChange: P.useCallback((u) => {
        l.current = u;
      }, []),
      disableHoverableContent: i,
      children: o
    }
  );
};
bB.displayName = vB;
var om = "Tooltip", [lfe, yf] = rm(om), wB = (e) => {
  const {
    __scopeTooltip: t,
    children: n,
    open: r,
    defaultOpen: i = !1,
    onOpenChange: o,
    disableHoverableContent: s,
    delayDuration: a
  } = e, l = Ix(om, e.__scopeTooltip), c = im(t), [u, d] = P.useState(null), f = Ca(), h = P.useRef(0), p = s ?? l.disableHoverableContent, m = a ?? l.delayDuration, g = P.useRef(!1), [v = !1, w] = Hy({
    prop: r,
    defaultProp: i,
    onChange: (A) => {
      A ? (l.onOpen(), document.dispatchEvent(new CustomEvent(k0))) : l.onClose(), o == null || o(A);
    }
  }), x = P.useMemo(() => v ? g.current ? "delayed-open" : "instant-open" : "closed", [v]), C = P.useCallback(() => {
    window.clearTimeout(h.current), g.current = !1, w(!0);
  }, [w]), S = P.useCallback(() => {
    window.clearTimeout(h.current), w(!1);
  }, [w]), k = P.useCallback(() => {
    window.clearTimeout(h.current), h.current = window.setTimeout(() => {
      g.current = !0, w(!0);
    }, m);
  }, [m, w]);
  return P.useEffect(() => () => window.clearTimeout(h.current), []), /* @__PURE__ */ y.jsx(pB, { ...c, children: /* @__PURE__ */ y.jsx(
    lfe,
    {
      scope: t,
      contentId: f,
      open: v,
      stateAttribute: x,
      trigger: u,
      onTriggerChange: d,
      onTriggerEnter: P.useCallback(() => {
        l.isOpenDelayed ? k() : C();
      }, [l.isOpenDelayed, k, C]),
      onTriggerLeave: P.useCallback(() => {
        p ? S() : window.clearTimeout(h.current);
      }, [S, p]),
      onOpen: C,
      onClose: S,
      disableHoverableContent: p,
      children: n
    }
  ) });
};
wB.displayName = om;
var E0 = "TooltipTrigger", xB = P.forwardRef(
  (e, t) => {
    const { __scopeTooltip: n, ...r } = e, i = yf(E0, n), o = Ix(E0, n), s = im(n), a = P.useRef(null), l = _n(t, a, i.onTriggerChange), c = P.useRef(!1), u = P.useRef(!1), d = P.useCallback(() => c.current = !1, []);
    return P.useEffect(() => () => document.removeEventListener("pointerup", d), [d]), /* @__PURE__ */ y.jsx(yB, { asChild: !0, ...s, children: /* @__PURE__ */ y.jsx(
      un.button,
      {
        "aria-describedby": i.open ? i.contentId : void 0,
        "data-state": i.stateAttribute,
        ...r,
        ref: l,
        onPointerMove: ct(e.onPointerMove, (f) => {
          f.pointerType !== "touch" && !u.current && !o.isPointerInTransitRef.current && (i.onTriggerEnter(), u.current = !0);
        }),
        onPointerLeave: ct(e.onPointerLeave, () => {
          i.onTriggerLeave(), u.current = !1;
        }),
        onPointerDown: ct(e.onPointerDown, () => {
          c.current = !0, document.addEventListener("pointerup", d, { once: !0 });
        }),
        onFocus: ct(e.onFocus, () => {
          c.current || i.onOpen();
        }),
        onBlur: ct(e.onBlur, i.onClose),
        onClick: ct(e.onClick, i.onClose)
      }
    ) });
  }
);
xB.displayName = E0;
var Rx = "TooltipPortal", [cfe, ufe] = rm(Rx, {
  forceMount: void 0
}), CB = (e) => {
  const { __scopeTooltip: t, forceMount: n, children: r, container: i } = e, o = yf(Rx, t);
  return /* @__PURE__ */ y.jsx(cfe, { scope: t, forceMount: n, children: /* @__PURE__ */ y.jsx(zo, { present: n || o.open, children: /* @__PURE__ */ y.jsx(ax, { asChild: !0, container: i, children: r }) }) });
};
CB.displayName = Rx;
var xc = "TooltipContent", kB = P.forwardRef(
  (e, t) => {
    const n = ufe(xc, e.__scopeTooltip), { forceMount: r = n.forceMount, side: i = "top", ...o } = e, s = yf(xc, e.__scopeTooltip);
    return /* @__PURE__ */ y.jsx(zo, { present: r || s.open, children: s.disableHoverableContent ? /* @__PURE__ */ y.jsx(EB, { side: i, ...o, ref: t }) : /* @__PURE__ */ y.jsx(dfe, { side: i, ...o, ref: t }) });
  }
), dfe = P.forwardRef((e, t) => {
  const n = yf(xc, e.__scopeTooltip), r = Ix(xc, e.__scopeTooltip), i = P.useRef(null), o = _n(t, i), [s, a] = P.useState(null), { trigger: l, onClose: c } = n, u = i.current, { onPointerInTransitChange: d } = r, f = P.useCallback(() => {
    a(null), d(!1);
  }, [d]), h = P.useCallback(
    (p, m) => {
      const g = p.currentTarget, v = { x: p.clientX, y: p.clientY }, w = pfe(v, g.getBoundingClientRect()), x = yfe(v, w), C = mfe(m.getBoundingClientRect()), S = vfe([...x, ...C]);
      a(S), d(!0);
    },
    [d]
  );
  return P.useEffect(() => () => f(), [f]), P.useEffect(() => {
    if (l && u) {
      const p = (g) => h(g, u), m = (g) => h(g, l);
      return l.addEventListener("pointerleave", p), u.addEventListener("pointerleave", m), () => {
        l.removeEventListener("pointerleave", p), u.removeEventListener("pointerleave", m);
      };
    }
  }, [l, u, h, f]), P.useEffect(() => {
    if (s) {
      const p = (m) => {
        const g = m.target, v = { x: m.clientX, y: m.clientY }, w = (l == null ? void 0 : l.contains(g)) || (u == null ? void 0 : u.contains(g)), x = !gfe(v, s);
        w ? f() : x && (f(), c());
      };
      return document.addEventListener("pointermove", p), () => document.removeEventListener("pointermove", p);
    }
  }, [l, u, s, c, f]), /* @__PURE__ */ y.jsx(EB, { ...e, ref: o });
}), [ffe, hfe] = rm(om, { isInside: !1 }), EB = P.forwardRef(
  (e, t) => {
    const {
      __scopeTooltip: n,
      children: r,
      "aria-label": i,
      onEscapeKeyDown: o,
      onPointerDownOutside: s,
      ...a
    } = e, l = yf(xc, n), c = im(n), { onClose: u } = l;
    return P.useEffect(() => (document.addEventListener(k0, u), () => document.removeEventListener(k0, u)), [u]), P.useEffect(() => {
      if (l.trigger) {
        const d = (f) => {
          const h = f.target;
          h != null && h.contains(l.trigger) && u();
        };
        return window.addEventListener("scroll", d, { capture: !0 }), () => window.removeEventListener("scroll", d, { capture: !0 });
      }
    }, [l.trigger, u]), /* @__PURE__ */ y.jsx(
      Ky,
      {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: o,
        onPointerDownOutside: s,
        onFocusOutside: (d) => d.preventDefault(),
        onDismiss: u,
        children: /* @__PURE__ */ y.jsxs(
          mB,
          {
            "data-state": l.stateAttribute,
            ...c,
            ...a,
            ref: t,
            style: {
              ...a.style,
              "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
              "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
              "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [
              /* @__PURE__ */ y.jsx(WO, { children: r }),
              /* @__PURE__ */ y.jsx(ffe, { scope: n, isInside: !0, children: /* @__PURE__ */ y.jsx(p6, { id: l.contentId, role: "tooltip", children: i || r }) })
            ]
          }
        )
      }
    );
  }
);
kB.displayName = xc;
var SB = "TooltipArrow", AB = P.forwardRef(
  (e, t) => {
    const { __scopeTooltip: n, ...r } = e, i = im(n);
    return hfe(
      SB,
      n
    ).isInside ? null : /* @__PURE__ */ y.jsx(gB, { ...i, ...r, ref: t });
  }
);
AB.displayName = SB;
function pfe(e, t) {
  const n = Math.abs(t.top - e.y), r = Math.abs(t.bottom - e.y), i = Math.abs(t.right - e.x), o = Math.abs(t.left - e.x);
  switch (Math.min(n, r, i, o)) {
    case o:
      return "left";
    case i:
      return "right";
    case n:
      return "top";
    case r:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function yfe(e, t, n = 5) {
  const r = [];
  switch (t) {
    case "top":
      r.push(
        { x: e.x - n, y: e.y + n },
        { x: e.x + n, y: e.y + n }
      );
      break;
    case "bottom":
      r.push(
        { x: e.x - n, y: e.y - n },
        { x: e.x + n, y: e.y - n }
      );
      break;
    case "left":
      r.push(
        { x: e.x + n, y: e.y - n },
        { x: e.x + n, y: e.y + n }
      );
      break;
    case "right":
      r.push(
        { x: e.x - n, y: e.y - n },
        { x: e.x - n, y: e.y + n }
      );
      break;
  }
  return r;
}
function mfe(e) {
  const { top: t, right: n, bottom: r, left: i } = e;
  return [
    { x: i, y: t },
    { x: n, y: t },
    { x: n, y: r },
    { x: i, y: r }
  ];
}
function gfe(e, t) {
  const { x: n, y: r } = e;
  let i = !1;
  for (let o = 0, s = t.length - 1; o < t.length; s = o++) {
    const a = t[o].x, l = t[o].y, c = t[s].x, u = t[s].y;
    l > r != u > r && n < (c - a) * (r - l) / (u - l) + a && (i = !i);
  }
  return i;
}
function vfe(e) {
  const t = e.slice();
  return t.sort((n, r) => n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0), bfe(t);
}
function bfe(e) {
  if (e.length <= 1) return e.slice();
  const t = [];
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    for (; t.length >= 2; ) {
      const o = t[t.length - 1], s = t[t.length - 2];
      if ((o.x - s.x) * (i.y - s.y) >= (o.y - s.y) * (i.x - s.x)) t.pop();
      else break;
    }
    t.push(i);
  }
  t.pop();
  const n = [];
  for (let r = e.length - 1; r >= 0; r--) {
    const i = e[r];
    for (; n.length >= 2; ) {
      const o = n[n.length - 1], s = n[n.length - 2];
      if ((o.x - s.x) * (i.y - s.y) >= (o.y - s.y) * (i.x - s.x)) n.pop();
      else break;
    }
    n.push(i);
  }
  return n.pop(), t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n);
}
var wfe = bB, xfe = wB, Cfe = xB, kfe = CB, Efe = kB, Sfe = AB, Afe = "_1mg6yyw0 yv8y4re1 yv8y4rcj yv8y4r9j yv8y4rb1 yv8y4rv yv8y4rwx yv8y4rwy", Tfe = "_1mg6yyw1 yv8y4r2n";
const wd = ({
  children: e,
  label: t,
  maxWidth: n = 200,
  textAlign: r = "center",
  asChild: i
}) => /* @__PURE__ */ y.jsx(wfe, { children: /* @__PURE__ */ y.jsxs(xfe, { delayDuration: 0, children: [
  /* @__PURE__ */ y.jsx(Cfe, { className: Tfe, asChild: i, children: e }),
  /* @__PURE__ */ y.jsx(kfe, { children: /* @__PURE__ */ y.jsxs(
    Efe,
    {
      className: Afe,
      style: { maxWidth: n },
      sideOffset: 5,
      "data-rk": Yy,
      children: [
        /* @__PURE__ */ y.jsx(ue, { textAlign: r, variant: { type: "white" }, children: t }),
        /* @__PURE__ */ y.jsx(Sfe, {})
      ]
    }
  ) })
] }) }), _fe = () => {
  Vn("stakeReview");
  const e = er(), { t } = ze(), n = fr(
    vc(),
    (m) => m.context.selectedAction
  ).unsafeCoerce(), r = J(
    () => G.of(n.inputToken),
    [n]
  ), i = fr(
    vc(),
    (m) => m.context.selectedYield
  ).unsafeCoerce(), o = J(
    () => G.fromNullable(n).map((m) => m.transactions).map((m) => m.sort((g, v) => g.stepIndex - v.stepIndex)),
    [n]
  ), s = (m) => Tn.ifJust((g) => {
    g.open(m, "_blank");
  }), a = _s(G.of(i)).mapOrDefault(
    (m) => m.review,
    ""
  ), l = J(() => {
    switch (i.metadata.type) {
      case "staking":
      case "liquid-staking":
        return t("position_details.unstake");
      default:
        return t("position_details.withdraw");
    }
  }, [i, t]), c = J(
    () => t(
      `position_details.pending_action_button.${n.type.toLowerCase()}`
    ),
    [n.type, t]
  ), u = J(
    () => n.type === oa.STAKE ? a : n.type === oa.UNSTAKE ? l : c,
    [n, a, l, c]
  ), d = J(
    () => G.fromNullable(n.amount).map(Xn).extractNullable(),
    [n]
  ), f = J(
    () => n.type === oa.UNSTAKE ? "unstake" : n.type === oa.STAKE ? "stake" : "pending",
    [n]
  ), h = J(
    () => o.chain(
      (m) => pt.find(
        (g) => g.status === ok.WAITING_FOR_SIGNATURE,
        m
      ).chain(
        (g) => pt.findIndex((v) => v === g, m).chainNullable((v) => m[v - 1]).filter((v) => v.status === ok.CONFIRMED).map(() => "continue")
      )
    ).orDefault("retry"),
    [o]
  ), p = J(
    () => G.of(n.createdAt).map(H6).orDefault(!1),
    [n]
  );
  return Ga(
    J(
      () => ({
        label: t(`activity.review.${h}`),
        onClick: () => e(`/activity/${f}/steps`),
        disabled: !1,
        isLoading: !1,
        hide: p
      }),
      [e, f, h, p, t]
    )
  ), {
    selectedYield: i,
    selectedAction: n,
    transactions: o,
    onViewTransactionClick: s,
    title: u,
    amount: d,
    inputToken: r,
    actionOlderThan7Days: p,
    labelKey: h
  };
};
var TB = "_7p05ef0", _B = "_7p05ef1", Ife = "_7p05ef2";
const IB = ({
  title: e,
  token: t,
  metadata: n,
  info: r,
  rewardTokenDetailsProps: i
}) => {
  const { t: o } = ze();
  return /* @__PURE__ */ y.jsxs(z, { marginBottom: "4", children: [
    /* @__PURE__ */ y.jsx(
      Zt.div,
      {
        initial: { opacity: 0, translateY: "-20px" },
        animate: { opacity: 1, translateY: 0 },
        transition: { duration: 1 },
        children: /* @__PURE__ */ y.jsxs(
          z,
          {
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            marginBottom: "1",
            children: [
              /* @__PURE__ */ y.jsx(to, { variant: { level: "h1" }, children: e }),
              G.fromRecord({ token: t, metadata: n }).map((s) => /* @__PURE__ */ y.jsx(No, { token: s.token, metadata: s.metadata })).extractNullable()
            ]
          }
        )
      }
    ),
    /* @__PURE__ */ y.jsx(
      Zt.div,
      {
        initial: { opacity: 0, translateY: "-20px" },
        animate: { opacity: 1, translateY: 0 },
        transition: { duration: 1, delay: 0.3 },
        children: /* @__PURE__ */ y.jsx(
          to,
          {
            variant: { level: "h2" },
            overflowWrap: "anywhere",
            className: Ife,
            children: r
          }
        )
      }
    ),
    i == null ? void 0 : i.filter((s) => s.type === "stake").map(() => /* @__PURE__ */ y.jsx(z, { marginTop: "2", children: /* @__PURE__ */ y.jsx(ue, { variant: { type: "muted", weight: "normal" }, children: o("review.estimated_reward") }) })).extractNullable()
  ] });
}, Rfe = () => {
  const { t: e } = ze(), t = cn(), {
    selectedYield: n,
    transactions: r,
    title: i,
    amount: o,
    inputToken: s,
    actionOlderThan7Days: a,
    labelKey: l
  } = _fe(), c = J(
    () => G.fromNullable(n.token).map((u) => `${o} ${u.symbol}`).extractNullable(),
    [o, n.token]
  );
  return /* @__PURE__ */ y.jsx(ff, { children: /* @__PURE__ */ y.jsxs($s, { children: [
    /* @__PURE__ */ y.jsx(
      IB,
      {
        info: c,
        metadata: G.of(n.metadata),
        token: s,
        title: i
      }
    ),
    /* @__PURE__ */ y.jsx(ti, {}),
    /* @__PURE__ */ y.jsxs(ue, { marginTop: "4", marginBottom: "2", children: [
      e("activity.review.transactions"),
      ":"
    ] }),
    r.map(
      (u) => u.map((d) => /* @__PURE__ */ y.jsxs(
        z,
        {
          marginBottom: "2",
          display: "flex",
          justifyContent: "space-between",
          children: [
            /* @__PURE__ */ y.jsx(ue, { as: "span", color: "textMuted", children: rp(d.type) }),
            /* @__PURE__ */ y.jsxs(
              z,
              {
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                gap: "1",
                children: [
                  /* @__PURE__ */ y.jsx(ue, { color: "textMuted", children: G.of(d.status).map((f) => f.replaceAll("_", " ")).map(rp).extract() }),
                  G.fromNullable(d.error).map((f) => /* @__PURE__ */ y.jsx(wd, { maxWidth: 300, label: f, children: /* @__PURE__ */ y.jsx(ka, {}) })).extractNullable()
                ]
              }
            )
          ]
        },
        d.id
      ))
    ).extractNullable(),
    /* @__PURE__ */ y.jsx(ti, { my: "2" }),
    !a && /* @__PURE__ */ y.jsx(z, { marginTop: "4", marginBottom: "16", children: /* @__PURE__ */ y.jsx(ue, { variant: { weight: "normal", type: "muted" }, children: /* @__PURE__ */ y.jsx(
      Wn,
      {
        i18nKey: "activity.review.terms_of_use",
        values: { action: e(`activity.review.${l}`) },
        components: {
          underline0: (
            // biome-ignore lint/a11y/useAnchorContent: <explanation>
            /* @__PURE__ */ y.jsx(
              "a",
              {
                target: "_blank",
                onClick: () => t("termsClicked"),
                href: "https://docs.stakek.it/docs/terms-of-use",
                className: _B,
                rel: "noreferrer"
              }
            )
          )
        }
      }
    ) }) })
  ] }) });
}, Pfe = ({
  addressWithTokenDto: e,
  gasEstimate: t,
  tokenGetTokenBalances: n,
  ...r
}) => Kn({
  fn: () => n({ addresses: [e] })
}).mapLeft(() => new Ofe()).chain(
  (i) => de.liftEither(
    pt.head(i).map((o) => ({ ...o, amount: new Re(o.amount ?? 0) })).toEither(new PB())
  ).chain(async (o) => {
    const s = r.isStake && xy(o.token, r.stakeToken) ? o.amount.minus(r.stakeAmount) : o.amount;
    return t.amount.isGreaterThan(s) ? Xe(new RB()) : _e(null);
  })
).chainLeft(async (i) => _e(i));
class RB extends Error {
  constructor() {
    super("Not enough gas token");
  }
}
class PB extends Error {
  constructor() {
    super("Gas token missing from response");
  }
}
class Ofe extends Error {
  constructor() {
    super("Get gas token failed");
  }
}
const Px = (e) => {
  const t = i7(), n = J(
    () => e.gasAmount.map((r) => ({
      ...e,
      gasAmount: r,
      stakeData: e.isStake ? {
        isStake: e.isStake,
        stakeAmount: e.stakeAmount,
        stakeToken: e.stakeToken
      } : { isStake: e.isStake }
    })),
    [e]
  );
  return Ut({
    queryKey: ["gas-check", n.extract()],
    enabled: n.isJust(),
    staleTime: 0,
    queryFn: async () => (await de.liftEither(
      n.toEither(new Error("Request data is missing"))
    ).chain(
      (r) => Pfe({
        gasEstimate: {
          amount: r.gasAmount,
          token: r.gasFeeToken
        },
        addressWithTokenDto: {
          address: r.address,
          additionalAddresses: r.additionalAddresses,
          network: r.gasFeeToken.network,
          tokenAddress: r.gasFeeToken.address
        },
        tokenGetTokenBalances: t,
        ...r.stakeData
      })
    ).map(
      (r) => r instanceof RB || r instanceof PB
    )).unsafeCoerce()
  });
};
var Bfe = "_1w60nqq0";
const Ox = (e) => e.map(
  (t, n) => t.isPoints ? /* @__PURE__ */ y.jsxs(z, { as: "span", display: "inline-block", children: [
    /* @__PURE__ */ y.jsx(
      z,
      {
        display: "inline-block",
        className: Bfe,
        as: "img",
        src: t.logoURI,
        hw: "5",
        marginRight: "1"
      }
    ),
    CS({
      arrLength: e.length,
      i: n,
      str: t.name.replace(/points/i, "").trim()
    })
  ] }, dr(t)) : /* @__PURE__ */ y.jsx(I.Fragment, { children: CS({
    arrLength: e.length,
    i: n,
    str: t.symbol
  }) }, dr(t))
), CS = ({
  arrLength: e,
  i: t,
  str: n
}) => t !== e - 1 ? /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
  n,
  ", "
] }) : n, Bx = ({
  amount: e,
  feeConfigDto: t,
  prices: n,
  token: r
}) => {
  const { t: i } = ze(), o = Ie(
    (u) => qee({
      amount: Je(mL(Re(u), e)),
      prices: n,
      token: r
    }),
    [e, r, n]
  ), s = Ie(
    (u) => `${gL(u)}%`,
    []
  ), a = J(
    () => t.chainNullable((u) => u.depositFeeBps).map((u) => ({
      inUSD: o(u),
      inPercentage: s(u),
      explanation: i("review.deposit_fee_explanation"),
      label: i("review.deposit_fee")
    })),
    [t, o, s, i]
  ), l = J(
    () => t.chainNullable((u) => u.managementFeeBps).map((u) => ({
      inUSD: o(u),
      inPercentage: s(u),
      explanation: i("review.management_fee_explanation"),
      label: i("review.management_fee")
    })),
    [t, o, s, i]
  ), c = J(
    () => t.chainNullable((u) => u.performanceFeeBps).map((u) => ({
      inUSD: o(u),
      inPercentage: s(u),
      explanation: i("review.performance_fee_explanation"),
      label: i("review.performance_fee")
    })),
    [t, o, s, i]
  );
  return { depositFee: a, managementFee: l, performanceFee: c };
}, Nfe = () => {
  var T;
  const e = hf(), t = fr(
    e,
    (R) => R.context.data
  ).unsafeCoerce(), n = t.requestDto.integrationId, r = GL(
    t.requestDto,
    { query: { staleTime: 0, gcTime: 0 } }
  ), i = rw(n), o = J(
    () => {
      var R;
      return G.fromNullable((R = r.data) == null ? void 0 : R.amount).map(Re);
    },
    [r.data]
  ), s = J(
    () => {
      var R;
      return new Re(((R = t.requestDto.args) == null ? void 0 : R.amount) ?? 0);
    },
    [(T = t.requestDto.args) == null ? void 0 : T.amount]
  ), a = J(
    () => G.of(t.interactedToken),
    [t.interactedToken]
  ), l = J(
    () => G.of(t.integrationData),
    [t.integrationData]
  ), c = Cy({
    token: a,
    yieldDto: l
  }), { depositFee: u, managementFee: d, performanceFee: f } = Bx({
    amount: s,
    token: a,
    feeConfigDto: J(
      () => G.fromNullable(i.data),
      [i.data]
    ),
    prices: J(
      () => G.fromNullable(c.data),
      [c.data]
    )
  }), h = Px({
    gasAmount: o,
    gasFeeToken: t.gasFeeToken,
    address: t.addresses.address,
    additionalAddresses: t.addresses.additionalAddresses,
    isStake: !1
  }), { t: p } = ze(), m = J(
    () => G.of(
      p(
        `position_details.pending_action_button.${t.requestDto.type.toLowerCase()}`
      )
    ),
    [t.requestDto.type, p]
  ), g = er(), v = J(
    () => b1({
      gas: o,
      prices: G.fromNullable(c.data),
      yieldDto: l
    }),
    [l, o, c.data]
  ), w = OL(), x = li({
    mutationFn: async () => (await Kn({
      fn: () => w(t.requestDto)
    }).mapLeft(() => new Error("Pending actions error")).chain(
      (R) => de.liftEither(d1(R))
    )).unsafeCoerce(),
    onSuccess: (R) => {
      e.send({ type: "setActionDto", data: R }), g("../steps", { relative: "path" });
    }
  }), C = () => x.mutate(), S = J(
    () => l.chainNullable(
      (R) => R.metadata.provider ? { provider: R.metadata.provider, rest: R } : null
    ).map((R) => {
      const B = G.of({
        logoUri: R.provider.logoURI,
        providerName: R.provider.name,
        symbols: Ox([R.rest.token]),
        rewardTokens: [R.rest.token]
      });
      return {
        type: "pendingAction",
        pendingAction: t.requestDto.type,
        rewardToken: B
      };
    }),
    [l, t.requestDto.type]
  ), k = Dt(C);
  Ga(
    J(
      () => ({
        label: p("shared.confirm"),
        onClick: () => k.current(),
        disabled: !1,
        isLoading: x.isPending
      }),
      [k, p, x.isPending]
    )
  );
  const A = J(() => ({ showMetaInfo: !1 }), []), b = J(() => Sn(s), [s]);
  return {
    integrationData: l,
    title: m,
    amount: b,
    fee: v,
    rewardTokenDetailsProps: S,
    token: a,
    metaInfo: A,
    isGasCheckWarning: !!h.data,
    gasCheckLoading: r.isLoading || h.isLoading,
    depositFee: u,
    managementFee: d,
    performanceFee: f,
    feeConfigLoading: i.isPending
  };
}, Dfe = () => /* @__PURE__ */ y.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: 17, height: 17, fill: "none", children: [
  /* @__PURE__ */ y.jsx(
    "path",
    {
      stroke: "#FFC21B",
      strokeWidth: 1.5,
      d: "M7.574 2.021a1.25 1.25 0 0 1 2.165 0l5.9 10.219a1.25 1.25 0 0 1-1.083 1.875h-11.8a1.25 1.25 0 0 1-1.082-1.875l5.9-10.219Z"
    }
  ),
  /* @__PURE__ */ y.jsx(
    "path",
    {
      stroke: "#FFC21B",
      strokeLinecap: "round",
      strokeWidth: 1.5,
      d: "M8.656 5.154v3.708"
    }
  ),
  /* @__PURE__ */ y.jsx("circle", { cx: 8.656, cy: 11.325, r: 0.924, fill: "#FFC21B" })
] }), jfe = ({ text: e }) => /* @__PURE__ */ y.jsxs(
  z,
  {
    borderRadius: "md",
    px: "2",
    py: "1",
    display: "inline-flex",
    justifyContent: "center",
    alignItems: "center",
    gap: "3",
    background: "warningBoxBackground",
    children: [
      /* @__PURE__ */ y.jsx(z, { display: "flex", justifyContent: "center", alignItems: "center", children: /* @__PURE__ */ y.jsx(Dfe, {}) }),
      /* @__PURE__ */ y.jsx(z, { children: /* @__PURE__ */ y.jsx(ue, { lineHeight: "short", children: e }) })
    ]
  }
), OB = ({
  selectedStake: e,
  validators: t,
  tokenDto: n
}) => {
  const { t: r } = ze(), i = J(
    () => pt.find((o) => !!(o.name ?? o.address), t).alt(pt.head(t)).map(
      (o) => r("details.selected_validators", {
        providerName: o.name ?? o.address,
        count: t.length - 1
      })
    ),
    [t, r]
  );
  return J(() => G.fromRecord({ selectedStake: e, tokenDto: n }).mapOrDefault(({ selectedStake: o, tokenDto: s }) => {
    var v, w, x, C, S;
    const a = i.extract(), l = s.symbol, c = ((v = o.metadata.rewardTokens) == null ? void 0 : v.filter((k) => !k.isPoints).map((k) => k.symbol).join(", ")) ?? "", u = a ?? (o.metadata.provider ? o.metadata.provider.name : o.metadata.name), d = o.metadata.rewardSchedule, f = ((w = o.metadata.cooldownPeriod) == null ? void 0 : w.days) ?? 0, h = ((x = o.metadata.warmupPeriod) == null ? void 0 : x.days) ?? 0, p = o.metadata.rewardClaiming, m = u.includes("Compound"), g = {
      extra: o.rewardType === "variable" ? r("details.reward_type_varialbe", {
        symbol: k6(o.token.symbol)
      }) : o.metadata.token.network === Jt.Tezos ? r("details.extra_tezos") : void 0
    };
    switch (o.metadata.type) {
      case "staking":
        return {
          description: null,
          earnPeriod: h > 0 ? r("details.native_staking.earn_after_warmup", {
            count: h
          }) : null,
          earnRewards: p === "manual" ? r("details.native_staking.earn_rewards_manual", {
            rewardSchedule: d
          }) : r("details.native_staking.earn_rewards_auto", {
            rewardSchedule: d
          }),
          withdrawnTime: f > 0 ? r("details.native_staking.unstake_time_days", {
            cooldownPeriodDays: f
          }) : r("details.native_staking.unstake_time_immediately"),
          withdrawnNotAvailable: null,
          ...g
        };
      case "lending":
        return {
          earnPeriod: h > 0 ? r("details.lend.earn_after_warmup", {
            count: h
          }) : null,
          earnRewards: p === "manual" ? r("details.lend.earn_interest_manual", { rewardSchedule: d }) : r("details.lend.earn_interest_auto", { rewardSchedule: d }),
          withdrawnTime: f > 0 ? r("details.lend.withdrawn_time_days", {
            cooldownPeriodDays: f
          }) : r("details.lend.withdrawn_time_immediately"),
          description: m ? r("details.lend.description_compound", {
            stakeToken: l,
            rewardTokens: c
          }) : r("details.lend.description", {
            stakeToken: l,
            rewardTokens: c,
            providerName: u
          }),
          withdrawnNotAvailable: null,
          ...g
        };
      case "vault":
        return {
          description: r("details.vault.description", {
            stakeToken: l,
            depositToken: c
          }),
          earnPeriod: h > 0 ? r("details.vault.earn_after_warmup", {
            count: h
          }) : null,
          earnRewards: p === "manual" ? r("details.vault.earn_yield_manual", { rewardSchedule: d }) : r("details.vault.earn_yield_auto", { rewardSchedule: d }),
          withdrawnTime: f > 0 ? r("details.vault.withdrawn_time_days", { cooldownPeriodDays: f }) : r("details.vault.withdrawn_time_immediately"),
          withdrawnNotAvailable: null,
          ...g
        };
      case "liquid-staking":
        return {
          description: r("details.liquid_stake.description", {
            stakeToken: l,
            rewardTokens: c
          }),
          earnPeriod: h > 0 ? r("details.liquid_stake.earn_after_warmup", {
            count: h
          }) : null,
          earnRewards: p === "manual" ? r("details.liquid_stake.earn_rewards_manual", {
            rewardSchedule: d
          }) : r("details.liquid_stake.earn_rewards_auto", {
            rewardSchedule: d
          }),
          withdrawnTime: o.status.exit ? f > 0 ? r("details.liquid_stake.unstake_time_days", {
            cooldownPeriodDays: f,
            claimDays: ((C = o.metadata.withdrawPeriod) == null ? void 0 : C.days) ?? 0,
            context: (((S = o.metadata.withdrawPeriod) == null ? void 0 : S.days) ?? 0) > 0 ? "with_claim_days" : void 0
          }) : r("details.liquid_stake.unstake_time_immediately") : null,
          withdrawnNotAvailable: o.status.exit ? null : r("details.liquid_stake.withdrawn_not_available", {
            rewardTokens: c
          }),
          ...g
        };
      case "restaking":
        return {
          description: r("details.restake.description", {
            stakeToken: l,
            rewardTokens: c
          }),
          earnPeriod: h > 0 ? r("details.restake.earn_after_warmup", {
            count: h
          }) : null,
          earnRewards: p === "manual" ? r("details.restake.earn_rewards_manual", {
            rewardSchedule: d
          }) : r("details.restake.earn_rewards_auto", {
            rewardSchedule: d
          }),
          withdrawnTime: o.status.exit ? f > 0 ? r("details.restake.unstake_time_days", {
            cooldownPeriodDays: f
          }) : r("details.restake.unstake_time_immediately") : null,
          withdrawnNotAvailable: o.status.exit ? null : r("details.restake.withdrawn_not_available", {
            rewardTokens: c
          }),
          ...g
        };
      default:
        return kS;
    }
  }, kS), [e, r, n, i]);
}, kS = {
  description: null,
  earnPeriod: null,
  earnRewards: null,
  withdrawnTime: null,
  withdrawnNotAvailable: null
};
var Mfe = "_56h8890", Ffe = "_56h8891";
const BB = ({
  isLoading: e,
  selectedStake: t,
  selectedToken: n,
  selectedValidators: r
}) => {
  const {
    description: i,
    earnPeriod: o,
    earnRewards: s,
    withdrawnNotAvailable: a,
    withdrawnTime: l,
    extra: c
  } = OB({
    selectedStake: t,
    validators: [...r.values()],
    tokenDto: n
  }), u = J(
    () => [
      { text: i, icon: /* @__PURE__ */ y.jsx(Lae, {}) },
      { text: o, icon: /* @__PURE__ */ y.jsx(zae, {}) },
      { text: s, icon: /* @__PURE__ */ y.jsx(Vae, {}) },
      { text: a, icon: /* @__PURE__ */ y.jsx(ka, {}) },
      { text: l, icon: /* @__PURE__ */ y.jsx(ka, {}) },
      { text: c, icon: /* @__PURE__ */ y.jsx(ka, {}) }
    ].filter((d) => !!d.text),
    [
      i,
      o,
      s,
      a,
      l,
      c
    ]
  );
  return e ? /* @__PURE__ */ y.jsx($o, { heightPx: 150 }) : /* @__PURE__ */ y.jsx(z, { as: "footer", gap: "3", display: "flex", flexDirection: "column", children: u.map((d) => /* @__PURE__ */ y.jsxs(z, { display: "flex", alignItems: "center", gap: "4", children: [
    /* @__PURE__ */ y.jsx(z, { alignItems: "center", justifyContent: "center", display: "flex", children: d.icon ? d.icon : /* @__PURE__ */ y.jsx(z, { className: Mfe, children: /* @__PURE__ */ y.jsx(
      ue,
      {
        className: Ffe,
        variant: { weight: "normal", type: "muted" },
        children: "⬤"
      }
    ) }) }),
    /* @__PURE__ */ y.jsx(z, { children: /* @__PURE__ */ y.jsx(ue, { variant: { weight: "normal", type: "muted" }, children: d.text }) })
  ] }, d.text)) });
}, Nx = ({
  fee: e,
  title: t,
  token: n,
  metadata: r,
  info: i,
  rewardTokenDetailsProps: o,
  isGasCheckError: s,
  loading: a = !1,
  depositFee: l,
  managementFee: c,
  performanceFee: u,
  feeConfigLoading: d = !1,
  ...f
}) => {
  Vn("stakeReview");
  const h = cn(), { t: p } = ze(), m = a || d;
  return /* @__PURE__ */ y.jsx(ff, { children: /* @__PURE__ */ y.jsxs($s, { children: [
    /* @__PURE__ */ y.jsx(
      IB,
      {
        info: i,
        metadata: r,
        rewardTokenDetailsProps: o,
        title: t,
        token: n
      }
    ),
    /* @__PURE__ */ y.jsx(ti, {}),
    /* @__PURE__ */ y.jsx(
      z,
      {
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        marginTop: "4",
        children: /* @__PURE__ */ y.jsx(ue, { variant: { weight: "semibold" }, children: p("shared.fees") })
      }
    ),
    /* @__PURE__ */ y.jsx(
      Lfe,
      {
        label: p("review.estimated_gas_fee"),
        price: e,
        loading: m
      }
    ),
    !m && /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      l.map((g) => /* @__PURE__ */ y.jsx(tv, { feesBps: g })).extractNullable(),
      c.map((g) => /* @__PURE__ */ y.jsx(tv, { feesBps: g })).extractNullable(),
      u.map((g) => /* @__PURE__ */ y.jsx(tv, { feesBps: g })).extractNullable()
    ] }),
    s && /* @__PURE__ */ y.jsx(z, { marginBottom: "2", children: /* @__PURE__ */ y.jsx(jfe, { text: "This action is unlikely to succeed due to insufficient funds to cover gas fees" }) }),
    /* @__PURE__ */ y.jsx(ti, {}),
    f.showMetaInfo && /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      /* @__PURE__ */ y.jsxs(z, { marginBottom: "4", children: [
        /* @__PURE__ */ y.jsx(z, { my: "4", children: /* @__PURE__ */ y.jsx(ue, { variant: { weight: "semibold" }, children: p("review.additional_info") }) }),
        /* @__PURE__ */ y.jsx(BB, { ...f.metaInfoProps })
      ] }),
      /* @__PURE__ */ y.jsx(ti, {})
    ] }),
    /* @__PURE__ */ y.jsx(z, { marginTop: "4", marginBottom: f.showMetaInfo ? "4" : "16", children: /* @__PURE__ */ y.jsx(ue, { variant: { weight: "normal", type: "muted" }, children: /* @__PURE__ */ y.jsx(
      Wn,
      {
        i18nKey: "review.terms_of_use",
        components: {
          underline0: (
            // biome-ignore lint/a11y/useAnchorContent: <explanation>
            /* @__PURE__ */ y.jsx(
              "a",
              {
                target: "_blank",
                onClick: () => h("termsClicked"),
                href: "https://docs.stakek.it/docs/terms-of-use",
                className: _B,
                rel: "noreferrer"
              }
            )
          )
        }
      }
    ) }) })
  ] }) });
}, Lfe = ({
  label: e,
  price: t,
  loading: n
}) => /* @__PURE__ */ y.jsxs(
  z,
  {
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    marginTop: "2",
    marginBottom: "2",
    "data-testid": "estimated_gas_fee",
    height: "4",
    children: [
      /* @__PURE__ */ y.jsx(ue, { variant: { weight: "normal", type: "muted" }, children: e }),
      n ? /* @__PURE__ */ y.jsx(z, { width: "40", children: /* @__PURE__ */ y.jsx($o, { heightPx: 16, variant: { size: "medium" } }) }) : /* @__PURE__ */ y.jsx(
        ue,
        {
          className: TB,
          variant: { type: "muted", weight: "normal" },
          children: t
        }
      )
    ]
  }
), tv = ({ feesBps: e }) => /* @__PURE__ */ y.jsxs(
  z,
  {
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    "data-testid": "estimated_gas_fee",
    marginBottom: "2",
    children: [
      /* @__PURE__ */ y.jsxs(z, { display: "flex", alignItems: "center", justifyContent: "center", gap: "1", children: [
        /* @__PURE__ */ y.jsx(ue, { variant: { weight: "normal", type: "muted" }, children: e.label }),
        /* @__PURE__ */ y.jsx(wd, { label: e.explanation, children: /* @__PURE__ */ y.jsx(z, { display: "flex", children: /* @__PURE__ */ y.jsx(ka, {}) }) })
      ] }),
      /* @__PURE__ */ y.jsx(wd, { label: e.inUSD, children: /* @__PURE__ */ y.jsx(
        ue,
        {
          className: TB,
          variant: { weight: "normal", type: "muted" },
          children: e.inPercentage
        }
      ) })
    ]
  }
), Ufe = () => {
  const {
    amount: e,
    fee: t,
    integrationData: n,
    rewardTokenDetailsProps: r,
    title: i,
    token: o,
    metaInfo: s,
    gasCheckLoading: a,
    isGasCheckWarning: l,
    depositFee: c,
    managementFee: u,
    performanceFee: d,
    feeConfigLoading: f
  } = Nfe();
  Vn("pendingActionReview");
  const h = J(
    () => o.map((p) => `${e} ${p.symbol}`).extractNullable(),
    [e, o]
  );
  return /* @__PURE__ */ y.jsx(
    Nx,
    {
      rewardTokenDetailsProps: r,
      title: i.orDefault(""),
      fee: t,
      depositFee: c,
      managementFee: u,
      performanceFee: d,
      feeConfigLoading: f,
      info: h,
      metadata: n.map((p) => p.metadata),
      token: o,
      isGasCheckError: l,
      loading: a,
      ...s
    }
  );
};
var ES = "_4g9e6t0", zfe = "_4g9e6t2 _4g9e6t1 yv8y4ru yv8y4rwp yv8y4rwq", Vfe = "_4g9e6t3", qfe = "_4g9e6t4", $fe = "_4g9e6t5", Wfe = "_4g9e6t6", Gfe = "_4g9e6t7", Hfe = "_4g9e6t8";
const Kfe = ({
  onCancel: e,
  onClick: t,
  isOpen: n
}) => {
  const { t: r } = ze();
  return /* @__PURE__ */ y.jsx(qs, { state: { isOpen: n, setOpen: e }, onClose: e, children: /* @__PURE__ */ y.jsxs(
    z,
    {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center",
      paddingBottom: { mobile: "8" },
      className: Gfe,
      children: [
        /* @__PURE__ */ y.jsx(
          z,
          {
            as: "img",
            src: vr.poweredBy,
            className: Wfe
          }
        ),
        /* @__PURE__ */ y.jsx(to, { variant: { level: "h4" }, children: r("position_details.unstake_sign.title") }),
        /* @__PURE__ */ y.jsx(z, { marginTop: "2", lineHeight: "short", children: /* @__PURE__ */ y.jsx(
          ue,
          {
            variant: { type: "muted", weight: "normal" },
            textAlign: "center",
            children: r("position_details.unstake_sign.description")
          }
        ) }),
        /* @__PURE__ */ y.jsx(z, { marginTop: "8", width: "full", children: /* @__PURE__ */ y.jsx(si, { onClick: t, children: /* @__PURE__ */ y.jsx(ue, { variant: { type: "inverted", weight: "bold", size: "large" }, children: r("shared.continue") }) }) })
      ]
    }
  ) });
};
var Yfe = js;
function Qfe() {
  if (typeof globalThis < "u")
    return globalThis;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof Uv < "u")
    return Uv;
}
function Jfe() {
  const e = Qfe();
  if (e.__xstate__)
    return e.__xstate__;
}
const Xfe = (e) => {
  if (typeof window > "u")
    return;
  const t = Jfe();
  t && t.register(e);
};
class SS {
  constructor(t) {
    this._process = t, this._active = !1, this._current = null, this._last = null;
  }
  start() {
    this._active = !0, this.flush();
  }
  clear() {
    this._current && (this._current.next = null, this._last = this._current);
  }
  enqueue(t) {
    const n = {
      value: t,
      next: null
    };
    if (this._current) {
      this._last.next = n, this._last = n;
      return;
    }
    this._current = n, this._last = n, this._active && this.flush();
  }
  flush() {
    for (; this._current; ) {
      const t = this._current;
      this._process(t.value), this._current = t.next;
    }
    this._last = null;
  }
}
const NB = ".", Zfe = "", DB = "", ehe = "#", the = "*", jB = "xstate.init", S0 = "xstate.stop";
function nhe(e, t) {
  return {
    type: `xstate.after.${e}.${t}`
  };
}
function A0(e, t) {
  return {
    type: `xstate.done.state.${e}`,
    output: t
  };
}
function rhe(e, t) {
  return {
    type: `xstate.done.actor.${e}`,
    output: t,
    actorId: e
  };
}
function ihe(e, t) {
  return {
    type: `xstate.error.actor.${e}`,
    error: t,
    actorId: e
  };
}
function MB(e) {
  return {
    type: jB,
    input: e
  };
}
function po(e) {
  setTimeout(() => {
    throw e;
  });
}
const ohe = typeof Symbol == "function" && Symbol.observable || "@@observable";
function FB(e, t) {
  const n = AS(e), r = AS(t);
  return typeof r == "string" ? typeof n == "string" ? r === n : !1 : typeof n == "string" ? n in r : Object.keys(n).every((i) => i in r ? FB(n[i], r[i]) : !1);
}
function Dx(e) {
  if (UB(e))
    return e;
  let t = [], n = "";
  for (let r = 0; r < e.length; r++) {
    switch (e.charCodeAt(r)) {
      case 92:
        n += e[r + 1], r++;
        continue;
      case 46:
        t.push(n), n = "";
        continue;
    }
    n += e[r];
  }
  return t.push(n), t;
}
function AS(e) {
  if (Fhe(e))
    return e.value;
  if (typeof e != "string")
    return e;
  const t = Dx(e);
  return she(t);
}
function she(e) {
  if (e.length === 1)
    return e[0];
  const t = {};
  let n = t;
  for (let r = 0; r < e.length - 1; r++)
    if (r === e.length - 2)
      n[e[r]] = e[r + 1];
    else {
      const i = n;
      n = {}, i[e[r]] = n;
    }
  return t;
}
function TS(e, t) {
  const n = {}, r = Object.keys(e);
  for (let i = 0; i < r.length; i++) {
    const o = r[i];
    n[o] = t(e[o], o, e, i);
  }
  return n;
}
function LB(e) {
  return UB(e) ? e : [e];
}
function vs(e) {
  return e === void 0 ? [] : LB(e);
}
function T0(e, t, n, r) {
  return typeof e == "function" ? e({
    context: t,
    event: n,
    self: r
  }) : e;
}
function UB(e) {
  return Array.isArray(e);
}
function ahe(e) {
  return e.type.startsWith("xstate.error.actor");
}
function dl(e) {
  return LB(e).map((t) => typeof t > "u" || typeof t == "string" ? {
    target: t
  } : t);
}
function zB(e) {
  if (!(e === void 0 || e === Zfe))
    return vs(e);
}
function _0(e, t, n) {
  var o, s, a;
  const r = typeof e == "object", i = r ? e : void 0;
  return {
    next: (o = r ? e.next : e) == null ? void 0 : o.bind(i),
    error: (s = r ? e.error : t) == null ? void 0 : s.bind(i),
    complete: (a = r ? e.complete : n) == null ? void 0 : a.bind(i)
  };
}
function _S(e, t) {
  return `${t}.${e}`;
}
function jx(e, t) {
  const n = t.match(/^xstate\.invoke\.(\d+)\.(.*)/);
  if (!n)
    return e.implementations.actors[t];
  const [, r, i] = n, s = e.getStateNodeById(i).config.invoke;
  return (Array.isArray(s) ? s[r] : s).src;
}
function IS(e, t) {
  return `${e.sessionId}.${t}`;
}
let lhe = 0;
function che(e, t) {
  const n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new WeakMap(), o = /* @__PURE__ */ new Set(), s = {}, {
    clock: a,
    logger: l
  } = t, c = {
    schedule: (f, h, p, m, g = Math.random().toString(36).slice(2)) => {
      const v = {
        source: f,
        target: h,
        event: p,
        delay: m,
        id: g,
        startedAt: Date.now()
      }, w = IS(f, g);
      d._snapshot._scheduledEvents[w] = v;
      const x = a.setTimeout(() => {
        delete s[w], delete d._snapshot._scheduledEvents[w], d._relay(f, h, p);
      }, m);
      s[w] = x;
    },
    cancel: (f, h) => {
      const p = IS(f, h), m = s[p];
      delete s[p], delete d._snapshot._scheduledEvents[p], m !== void 0 && a.clearTimeout(m);
    },
    cancelAll: (f) => {
      for (const h in d._snapshot._scheduledEvents) {
        const p = d._snapshot._scheduledEvents[h];
        p.source === f && c.cancel(f, p.id);
      }
    }
  }, u = (f) => {
    if (!o.size)
      return;
    const h = {
      ...f,
      rootId: e.sessionId
    };
    o.forEach((p) => {
      var m;
      return (m = p.next) == null ? void 0 : m.call(p, h);
    });
  }, d = {
    _snapshot: {
      _scheduledEvents: ((t == null ? void 0 : t.snapshot) && t.snapshot.scheduler) ?? {}
    },
    _bookId: () => `x:${lhe++}`,
    _register: (f, h) => (n.set(f, h), f),
    _unregister: (f) => {
      n.delete(f.sessionId);
      const h = i.get(f);
      h !== void 0 && (r.delete(h), i.delete(f));
    },
    get: (f) => r.get(f),
    _set: (f, h) => {
      const p = r.get(f);
      if (p && p !== h)
        throw new Error(`Actor with system ID '${f}' already exists.`);
      r.set(f, h), i.set(h, f);
    },
    inspect: (f) => {
      const h = _0(f);
      return o.add(h), {
        unsubscribe() {
          o.delete(h);
        }
      };
    },
    _sendInspectionEvent: u,
    _relay: (f, h, p) => {
      d._sendInspectionEvent({
        type: "@xstate.event",
        sourceRef: f,
        actorRef: h,
        event: p
      }), h._send(p);
    },
    scheduler: c,
    getSnapshot: () => ({
      _scheduledEvents: {
        ...d._snapshot._scheduledEvents
      }
    }),
    start: () => {
      const f = d._snapshot._scheduledEvents;
      d._snapshot._scheduledEvents = {};
      for (const h in f) {
        const {
          source: p,
          target: m,
          event: g,
          delay: v,
          id: w
        } = f[h];
        c.schedule(p, m, g, v, w);
      }
    },
    _clock: a,
    _logger: l
  };
  return d;
}
const Mx = 1;
let sr = /* @__PURE__ */ function(e) {
  return e[e.NotStarted = 0] = "NotStarted", e[e.Running = 1] = "Running", e[e.Stopped = 2] = "Stopped", e;
}({});
const uhe = {
  clock: {
    setTimeout: (e, t) => setTimeout(e, t),
    clearTimeout: (e) => clearTimeout(e)
  },
  logger: void 0,
  devTools: !1
};
class dhe {
  /**
   * Creates a new actor instance for the given logic with the provided options,
   * if any.
   *
   * @param logic The logic to create an actor from
   * @param options Actor options
   */
  constructor(t, n) {
    this.logic = t, this._snapshot = void 0, this.clock = void 0, this.options = void 0, this.id = void 0, this.mailbox = new SS(this._process.bind(this)), this.observers = /* @__PURE__ */ new Set(), this.eventListeners = /* @__PURE__ */ new Map(), this.logger = void 0, this._processingStatus = sr.NotStarted, this._parent = void 0, this._syncSnapshot = void 0, this.ref = void 0, this._actorScope = void 0, this._systemId = void 0, this.sessionId = void 0, this.system = void 0, this._doneEvent = void 0, this.src = void 0, this._deferred = [];
    const r = {
      ...uhe,
      ...n
    }, {
      clock: i,
      logger: o,
      parent: s,
      syncSnapshot: a,
      id: l,
      systemId: c,
      inspect: u
    } = r;
    this.system = s ? s.system : che(this, {
      clock: i,
      logger: o
    }), u && !s && this.system.inspect(_0(u)), this.sessionId = this.system._bookId(), this.id = l ?? this.sessionId, this.logger = (n == null ? void 0 : n.logger) ?? this.system._logger, this.clock = (n == null ? void 0 : n.clock) ?? this.system._clock, this._parent = s, this._syncSnapshot = a, this.options = r, this.src = r.src ?? t, this.ref = this, this._actorScope = {
      self: this,
      id: this.id,
      sessionId: this.sessionId,
      logger: this.logger,
      defer: (d) => {
        this._deferred.push(d);
      },
      system: this.system,
      stopChild: (d) => {
        if (d._parent !== this)
          throw new Error(`Cannot stop child actor ${d.id} of ${this.id} because it is not a child`);
        d._stop();
      },
      emit: (d) => {
        const f = this.eventListeners.get(d.type), h = this.eventListeners.get("*");
        if (!f && !h)
          return;
        const p = /* @__PURE__ */ new Set([...f ? f.values() : [], ...h ? h.values() : []]);
        for (const m of Array.from(p))
          m(d);
      }
    }, this.send = this.send.bind(this), this.system._sendInspectionEvent({
      type: "@xstate.actor",
      actorRef: this
    }), c && (this._systemId = c, this.system._set(c, this)), this._initState((n == null ? void 0 : n.snapshot) ?? (n == null ? void 0 : n.state)), c && this._snapshot.status !== "active" && this.system._unregister(this);
  }
  _initState(t) {
    var n;
    try {
      this._snapshot = t ? this.logic.restoreSnapshot ? this.logic.restoreSnapshot(t, this._actorScope) : t : this.logic.getInitialSnapshot(this._actorScope, (n = this.options) == null ? void 0 : n.input);
    } catch (r) {
      this._snapshot = {
        status: "error",
        output: void 0,
        error: r
      };
    }
  }
  update(t, n) {
    var i, o;
    this._snapshot = t;
    let r;
    for (; r = this._deferred.shift(); )
      try {
        r();
      } catch (s) {
        this._deferred.length = 0, this._snapshot = {
          ...t,
          status: "error",
          error: s
        };
      }
    switch (this._snapshot.status) {
      case "active":
        for (const s of this.observers)
          try {
            (i = s.next) == null || i.call(s, t);
          } catch (a) {
            po(a);
          }
        break;
      case "done":
        for (const s of this.observers)
          try {
            (o = s.next) == null || o.call(s, t);
          } catch (a) {
            po(a);
          }
        this._stopProcedure(), this._complete(), this._doneEvent = rhe(this.id, this._snapshot.output), this._parent && this.system._relay(this, this._parent, this._doneEvent);
        break;
      case "error":
        this._error(this._snapshot.error);
        break;
    }
    this.system._sendInspectionEvent({
      type: "@xstate.snapshot",
      actorRef: this,
      event: n,
      snapshot: t
    });
  }
  /**
   * Subscribe an observer to an actor’s snapshot values.
   *
   * @remarks
   * The observer will receive the actor’s snapshot value when it is emitted.
   * The observer can be:
   *
   * - A plain function that receives the latest snapshot, or
   * - An observer object whose `.next(snapshot)` method receives the latest
   *   snapshot
   *
   * @example
   *
   * ```ts
   * // Observer as a plain function
   * const subscription = actor.subscribe((snapshot) => {
   *   console.log(snapshot);
   * });
   * ```
   *
   * @example
   *
   * ```ts
   * // Observer as an object
   * const subscription = actor.subscribe({
   *   next(snapshot) {
   *     console.log(snapshot);
   *   },
   *   error(err) {
   *     // ...
   *   },
   *   complete() {
   *     // ...
   *   }
   * });
   * ```
   *
   * The return value of `actor.subscribe(observer)` is a subscription object
   * that has an `.unsubscribe()` method. You can call
   * `subscription.unsubscribe()` to unsubscribe the observer:
   *
   * @example
   *
   * ```ts
   * const subscription = actor.subscribe((snapshot) => {
   *   // ...
   * });
   *
   * // Unsubscribe the observer
   * subscription.unsubscribe();
   * ```
   *
   * When the actor is stopped, all of its observers will automatically be
   * unsubscribed.
   *
   * @param observer - Either a plain function that receives the latest
   *   snapshot, or an observer object whose `.next(snapshot)` method receives
   *   the latest snapshot
   */
  subscribe(t, n, r) {
    var o;
    const i = _0(t, n, r);
    if (this._processingStatus !== sr.Stopped)
      this.observers.add(i);
    else
      switch (this._snapshot.status) {
        case "done":
          try {
            (o = i.complete) == null || o.call(i);
          } catch (s) {
            po(s);
          }
          break;
        case "error": {
          const s = this._snapshot.error;
          if (!i.error)
            po(s);
          else
            try {
              i.error(s);
            } catch (a) {
              po(a);
            }
          break;
        }
      }
    return {
      unsubscribe: () => {
        this.observers.delete(i);
      }
    };
  }
  on(t, n) {
    let r = this.eventListeners.get(t);
    r || (r = /* @__PURE__ */ new Set(), this.eventListeners.set(t, r));
    const i = n.bind(void 0);
    return r.add(i), {
      unsubscribe: () => {
        r.delete(i);
      }
    };
  }
  /** Starts the Actor from the initial state */
  start() {
    if (this._processingStatus === sr.Running)
      return this;
    this._syncSnapshot && this.subscribe({
      next: (r) => {
        r.status === "active" && this.system._relay(this, this._parent, {
          type: `xstate.snapshot.${this.id}`,
          snapshot: r
        });
      },
      error: () => {
      }
    }), this.system._register(this.sessionId, this), this._systemId && this.system._set(this._systemId, this), this._processingStatus = sr.Running;
    const t = MB(this.options.input);
    switch (this.system._sendInspectionEvent({
      type: "@xstate.event",
      sourceRef: this._parent,
      actorRef: this,
      event: t
    }), this._snapshot.status) {
      case "done":
        return this.update(this._snapshot, t), this;
      case "error":
        return this._error(this._snapshot.error), this;
    }
    if (this._parent || this.system.start(), this.logic.start)
      try {
        this.logic.start(this._snapshot, this._actorScope);
      } catch (r) {
        return this._snapshot = {
          ...this._snapshot,
          status: "error",
          error: r
        }, this._error(r), this;
      }
    return this.update(this._snapshot, t), this.options.devTools && this.attachDevTools(), this.mailbox.start(), this;
  }
  _process(t) {
    let n, r;
    try {
      n = this.logic.transition(this._snapshot, t, this._actorScope);
    } catch (i) {
      r = {
        err: i
      };
    }
    if (r) {
      const {
        err: i
      } = r;
      this._snapshot = {
        ...this._snapshot,
        status: "error",
        error: i
      }, this._error(i);
      return;
    }
    this.update(n, t), t.type === S0 && (this._stopProcedure(), this._complete());
  }
  _stop() {
    return this._processingStatus === sr.Stopped ? this : (this.mailbox.clear(), this._processingStatus === sr.NotStarted ? (this._processingStatus = sr.Stopped, this) : (this.mailbox.enqueue({
      type: S0
    }), this));
  }
  /** Stops the Actor and unsubscribe all listeners. */
  stop() {
    if (this._parent)
      throw new Error("A non-root actor cannot be stopped directly.");
    return this._stop();
  }
  _complete() {
    var t;
    for (const n of this.observers)
      try {
        (t = n.complete) == null || t.call(n);
      } catch (r) {
        po(r);
      }
    this.observers.clear();
  }
  _reportError(t) {
    if (!this.observers.size) {
      this._parent || po(t);
      return;
    }
    let n = !1;
    for (const r of this.observers) {
      const i = r.error;
      n || (n = !i);
      try {
        i == null || i(t);
      } catch (o) {
        po(o);
      }
    }
    this.observers.clear(), n && po(t);
  }
  _error(t) {
    this._stopProcedure(), this._reportError(t), this._parent && this.system._relay(this, this._parent, ihe(this.id, t));
  }
  // TODO: atm children don't belong entirely to the actor so
  // in a way - it's not even super aware of them
  // so we can't stop them from here but we really should!
  // right now, they are being stopped within the machine's transition
  // but that could throw and leave us with "orphaned" active actors
  _stopProcedure() {
    return this._processingStatus !== sr.Running ? this : (this.system.scheduler.cancelAll(this), this.mailbox.clear(), this.mailbox = new SS(this._process.bind(this)), this._processingStatus = sr.Stopped, this.system._unregister(this), this);
  }
  /** @internal */
  _send(t) {
    this._processingStatus !== sr.Stopped && this.mailbox.enqueue(t);
  }
  /**
   * Sends an event to the running Actor to trigger a transition.
   *
   * @param event The event to send
   */
  send(t) {
    this.system._relay(void 0, this, t);
  }
  attachDevTools() {
    const {
      devTools: t
    } = this.options;
    t && (typeof t == "function" ? t : Xfe)(this);
  }
  toJSON() {
    return {
      xstate$$type: Mx,
      id: this.id
    };
  }
  /**
   * Obtain the internal state of the actor, which can be persisted.
   *
   * @remarks
   * The internal state can be persisted from any actor, not only machines.
   *
   * Note that the persisted state is not the same as the snapshot from
   * {@link Actor.getSnapshot}. Persisted state represents the internal state of
   * the actor, while snapshots represent the actor's last emitted value.
   *
   * Can be restored with {@link ActorOptions.state}
   * @see https://stately.ai/docs/persistence
   */
  getPersistedSnapshot(t) {
    return this.logic.getPersistedSnapshot(this._snapshot, t);
  }
  [ohe]() {
    return this;
  }
  /**
   * Read an actor’s snapshot synchronously.
   *
   * @remarks
   * The snapshot represent an actor's last emitted value.
   *
   * When an actor receives an event, its internal state may change. An actor
   * may emit a snapshot when a state transition occurs.
   *
   * Note that some actors, such as callback actors generated with
   * `fromCallback`, will not emit snapshots.
   * @see {@link Actor.subscribe} to subscribe to an actor’s snapshot values.
   * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).
   */
  getSnapshot() {
    return this._snapshot;
  }
}
function Cc(e, ...[t]) {
  return new dhe(e, t);
}
function fhe(e, t, n, r, {
  sendId: i
}) {
  const o = typeof i == "function" ? i(n, r) : i;
  return [t, o];
}
function hhe(e, t) {
  e.defer(() => {
    e.system.scheduler.cancel(e.self, t);
  });
}
function phe(e) {
  function t(n, r) {
  }
  return t.type = "xstate.cancel", t.sendId = e, t.resolve = fhe, t.execute = hhe, t;
}
function yhe(e, t, n, r, {
  id: i,
  systemId: o,
  src: s,
  input: a,
  syncSnapshot: l
}) {
  const c = typeof s == "string" ? jx(t.machine, s) : s, u = typeof i == "function" ? i(n) : i;
  let d;
  return c && (d = Cc(c, {
    id: u,
    src: s,
    parent: e.self,
    syncSnapshot: l,
    systemId: o,
    input: typeof a == "function" ? a({
      context: t.context,
      event: n.event,
      self: e.self
    }) : a
  })), [Ma(t, {
    children: {
      ...t.children,
      [u]: d
    }
  }), {
    id: i,
    actorRef: d
  }];
}
function mhe(e, {
  id: t,
  actorRef: n
}) {
  n && e.defer(() => {
    n._processingStatus !== sr.Stopped && n.start();
  });
}
function ghe(...[e, {
  id: t,
  systemId: n,
  input: r,
  syncSnapshot: i = !1
} = {}]) {
  function o(s, a) {
  }
  return o.type = "snapshot.spawnChild", o.id = t, o.systemId = n, o.src = e, o.input = r, o.syncSnapshot = i, o.resolve = yhe, o.execute = mhe, o;
}
function vhe(e, t, n, r, {
  actorRef: i
}) {
  const o = typeof i == "function" ? i(n, r) : i, s = typeof o == "string" ? t.children[o] : o;
  let a = t.children;
  return s && (a = {
    ...a
  }, delete a[s.id]), [Ma(t, {
    children: a
  }), s];
}
function bhe(e, t) {
  if (t) {
    if (e.system._unregister(t), t._processingStatus !== sr.Running) {
      e.stopChild(t);
      return;
    }
    e.defer(() => {
      e.stopChild(t);
    });
  }
}
function VB(e) {
  function t(n, r) {
  }
  return t.type = "xstate.stopChild", t.actorRef = e, t.resolve = vhe, t.execute = bhe, t;
}
function Fx(e, t, n, r) {
  const {
    machine: i
  } = r, o = typeof e == "function", s = o ? e : i.implementations.guards[typeof e == "string" ? e : e.type];
  if (!o && !s)
    throw new Error(`Guard '${typeof e == "string" ? e : e.type}' is not implemented.'.`);
  if (typeof s != "function")
    return Fx(s, t, n, r);
  const a = {
    context: t,
    event: n
  }, l = o || typeof e == "string" ? void 0 : "params" in e ? typeof e.params == "function" ? e.params({
    context: t,
    event: n
  }) : e.params : void 0;
  return "check" in s ? s.check(
    r,
    a,
    s
    // this holds all params
  ) : s(a, l);
}
const Lx = (e) => e.type === "atomic" || e.type === "final";
function kc(e) {
  return Object.values(e.states).filter((t) => t.type !== "history");
}
function mf(e, t) {
  const n = [];
  if (t === e)
    return n;
  let r = e.parent;
  for (; r && r !== t; )
    n.push(r), r = r.parent;
  return n;
}
function gp(e) {
  const t = new Set(e), n = $B(t);
  for (const r of t)
    if (r.type === "compound" && (!n.get(r) || !n.get(r).length))
      RS(r).forEach((i) => t.add(i));
    else if (r.type === "parallel") {
      for (const i of kc(r))
        if (i.type !== "history" && !t.has(i)) {
          const o = RS(i);
          for (const s of o)
            t.add(s);
        }
    }
  for (const r of t) {
    let i = r.parent;
    for (; i; )
      t.add(i), i = i.parent;
  }
  return t;
}
function qB(e, t) {
  const n = t.get(e);
  if (!n)
    return {};
  if (e.type === "compound") {
    const i = n[0];
    if (i) {
      if (Lx(i))
        return i.key;
    } else
      return {};
  }
  const r = {};
  for (const i of n)
    r[i.key] = qB(i, t);
  return r;
}
function $B(e) {
  const t = /* @__PURE__ */ new Map();
  for (const n of e)
    t.has(n) || t.set(n, []), n.parent && (t.has(n.parent) || t.set(n.parent, []), t.get(n.parent).push(n));
  return t;
}
function WB(e, t) {
  const n = gp(t);
  return qB(e, $B(n));
}
function Ux(e, t) {
  return t.type === "compound" ? kc(t).some((n) => n.type === "final" && e.has(n)) : t.type === "parallel" ? kc(t).every((n) => Ux(e, n)) : t.type === "final";
}
const sm = (e) => e[0] === ehe;
function whe(e, t) {
  return e.transitions.get(t) || [...e.transitions.keys()].filter((r) => {
    if (r === the)
      return !0;
    if (!r.endsWith(".*"))
      return !1;
    const i = r.split("."), o = t.split(".");
    for (let s = 0; s < i.length; s++) {
      const a = i[s], l = o[s];
      if (a === "*")
        return s === i.length - 1;
      if (a !== l)
        return !1;
    }
    return !0;
  }).sort((r, i) => i.length - r.length).flatMap((r) => e.transitions.get(r));
}
function xhe(e) {
  const t = e.config.after;
  if (!t)
    return [];
  const n = (i, o) => {
    const s = nhe(i, e.id), a = s.type;
    return e.entry.push(Hhe(s, {
      id: a,
      delay: i
    })), e.exit.push(phe(a)), a;
  };
  return Object.keys(t).flatMap((i, o) => {
    const s = t[i], a = typeof s == "string" ? {
      target: s
    } : s, l = Number.isNaN(+i) ? i : +i, c = n(l);
    return vs(a).map((u) => ({
      ...u,
      event: c,
      delay: l
    }));
  }).map((i) => {
    const {
      delay: o
    } = i;
    return {
      ...na(e, i.event, i),
      delay: o
    };
  });
}
function na(e, t, n) {
  const r = zB(n.target), i = n.reenter ?? !1, o = Ehe(e, r), s = {
    ...n,
    actions: vs(n.actions),
    guard: n.guard,
    target: o,
    source: e,
    reenter: i,
    eventType: t,
    toJSON: () => ({
      ...s,
      source: `#${e.id}`,
      target: o ? o.map((a) => `#${a.id}`) : void 0
    })
  };
  return s;
}
function Che(e) {
  const t = /* @__PURE__ */ new Map();
  if (e.config.on)
    for (const n of Object.keys(e.config.on)) {
      if (n === DB)
        throw new Error('Null events ("") cannot be specified as a transition key. Use `always: { ... }` instead.');
      const r = e.config.on[n];
      t.set(n, dl(r).map((i) => na(e, n, i)));
    }
  if (e.config.onDone) {
    const n = `xstate.done.state.${e.id}`;
    t.set(n, dl(e.config.onDone).map((r) => na(e, n, r)));
  }
  for (const n of e.invoke) {
    if (n.onDone) {
      const r = `xstate.done.actor.${n.id}`;
      t.set(r, dl(n.onDone).map((i) => na(e, r, i)));
    }
    if (n.onError) {
      const r = `xstate.error.actor.${n.id}`;
      t.set(r, dl(n.onError).map((i) => na(e, r, i)));
    }
    if (n.onSnapshot) {
      const r = `xstate.snapshot.${n.id}`;
      t.set(r, dl(n.onSnapshot).map((i) => na(e, r, i)));
    }
  }
  for (const n of e.after) {
    let r = t.get(n.eventType);
    r || (r = [], t.set(n.eventType, r)), r.push(n);
  }
  return t;
}
function khe(e, t) {
  const n = typeof t == "string" ? e.states[t] : t ? e.states[t.target] : void 0;
  if (!n && t)
    throw new Error(`Initial state node "${t}" not found on parent state node #${e.id}`);
  const r = {
    source: e,
    actions: !t || typeof t == "string" ? [] : vs(t.actions),
    eventType: null,
    reenter: !1,
    target: n ? [n] : [],
    toJSON: () => ({
      ...r,
      source: `#${e.id}`,
      target: n ? [`#${n.id}`] : []
    })
  };
  return r;
}
function Ehe(e, t) {
  if (t !== void 0)
    return t.map((n) => {
      if (typeof n != "string")
        return n;
      if (sm(n))
        return e.machine.getStateNodeById(n);
      const r = n[0] === NB;
      if (r && !e.parent)
        return vp(e, n.slice(1));
      const i = r ? e.key + n : n;
      if (e.parent)
        try {
          return vp(e.parent, i);
        } catch (o) {
          throw new Error(`Invalid transition definition for state node '${e.id}':
${o.message}`);
        }
      else
        throw new Error(`Invalid target: "${n}" is not a valid target from the root node. Did you mean ".${n}"?`);
    });
}
function GB(e) {
  const t = zB(e.config.target);
  return t ? {
    target: t.map((n) => typeof n == "string" ? vp(e.parent, n) : n)
  } : e.parent.initial;
}
function ua(e) {
  return e.type === "history";
}
function RS(e) {
  const t = HB(e);
  for (const n of t)
    for (const r of mf(n, e))
      t.add(r);
  return t;
}
function HB(e) {
  const t = /* @__PURE__ */ new Set();
  function n(r) {
    if (!t.has(r)) {
      if (t.add(r), r.type === "compound")
        n(r.initial.target[0]);
      else if (r.type === "parallel")
        for (const i of kc(r))
          n(i);
    }
  }
  return n(e), t;
}
function Ec(e, t) {
  if (sm(t))
    return e.machine.getStateNodeById(t);
  if (!e.states)
    throw new Error(`Unable to retrieve child state '${t}' from '${e.id}'; no child states exist.`);
  const n = e.states[t];
  if (!n)
    throw new Error(`Child state '${t}' does not exist on '${e.id}'`);
  return n;
}
function vp(e, t) {
  if (typeof t == "string" && sm(t))
    try {
      return e.machine.getStateNodeById(t);
    } catch {
    }
  const n = Dx(t).slice();
  let r = e;
  for (; n.length; ) {
    const i = n.shift();
    if (!i.length)
      break;
    r = Ec(r, i);
  }
  return r;
}
function bp(e, t) {
  if (typeof t == "string") {
    const i = e.states[t];
    if (!i)
      throw new Error(`State '${t}' does not exist on '${e.id}'`);
    return [e, i];
  }
  const n = Object.keys(t), r = n.map((i) => Ec(e, i)).filter(Boolean);
  return [e.machine.root, e].concat(r, n.reduce((i, o) => {
    const s = Ec(e, o);
    if (!s)
      return i;
    const a = bp(s, t[o]);
    return i.concat(a);
  }, []));
}
function She(e, t, n, r) {
  const o = Ec(e, t).next(n, r);
  return !o || !o.length ? e.next(n, r) : o;
}
function Ahe(e, t, n, r) {
  const i = Object.keys(t), o = Ec(e, i[0]), s = zx(o, t[i[0]], n, r);
  return !s || !s.length ? e.next(n, r) : s;
}
function The(e, t, n, r) {
  const i = [];
  for (const o of Object.keys(t)) {
    const s = t[o];
    if (!s)
      continue;
    const a = Ec(e, o), l = zx(a, s, n, r);
    l && i.push(...l);
  }
  return i.length ? i : e.next(n, r);
}
function zx(e, t, n, r) {
  return typeof t == "string" ? She(e, t, n, r) : Object.keys(t).length === 1 ? Ahe(e, t, n, r) : The(e, t, n, r);
}
function _he(e) {
  return Object.keys(e.states).map((t) => e.states[t]).filter((t) => t.type === "history");
}
function Ds(e, t) {
  let n = e;
  for (; n.parent && n.parent !== t; )
    n = n.parent;
  return n.parent === t;
}
function Ihe(e, t) {
  const n = new Set(e), r = new Set(t);
  for (const i of n)
    if (r.has(i))
      return !0;
  for (const i of r)
    if (n.has(i))
      return !0;
  return !1;
}
function KB(e, t, n) {
  const r = /* @__PURE__ */ new Set();
  for (const i of e) {
    let o = !1;
    const s = /* @__PURE__ */ new Set();
    for (const a of r)
      if (Ihe(I0([i], t, n), I0([a], t, n)))
        if (Ds(i.source, a.source))
          s.add(a);
        else {
          o = !0;
          break;
        }
    if (!o) {
      for (const a of s)
        r.delete(a);
      r.add(i);
    }
  }
  return Array.from(r);
}
function Rhe(e) {
  const [t, ...n] = e;
  for (const r of mf(t, void 0))
    if (n.every((i) => Ds(i, r)))
      return r;
}
function Vx(e, t) {
  if (!e.target)
    return [];
  const n = /* @__PURE__ */ new Set();
  for (const r of e.target)
    if (ua(r))
      if (t[r.id])
        for (const i of t[r.id])
          n.add(i);
      else
        for (const i of Vx(GB(r), t))
          n.add(i);
    else
      n.add(r);
  return [...n];
}
function YB(e, t) {
  const n = Vx(e, t);
  if (!n)
    return;
  if (!e.reenter && n.every((i) => i === e.source || Ds(i, e.source)))
    return e.source;
  const r = Rhe(n.concat(e.source));
  if (r)
    return r;
  if (!e.reenter)
    return e.source.machine.root;
}
function I0(e, t, n) {
  var i;
  const r = /* @__PURE__ */ new Set();
  for (const o of e)
    if ((i = o.target) != null && i.length) {
      const s = YB(o, n);
      o.reenter && o.source === s && r.add(s);
      for (const a of t)
        Ds(a, s) && r.add(a);
    }
  return [...r];
}
function Phe(e, t) {
  if (e.length !== t.size)
    return !1;
  for (const n of e)
    if (!t.has(n))
      return !1;
  return !0;
}
function R0(e, t, n, r, i, o) {
  if (!e.length)
    return t;
  const s = new Set(t._nodes);
  let a = t.historyValue;
  const l = KB(e, s, a);
  let c = t;
  i || ([c, a] = Dhe(c, r, n, l, s, a, o)), c = Sc(c, r, n, l.flatMap((d) => d.actions), o), c = Bhe(c, r, n, l, s, o, a, i);
  const u = [...s];
  c.status === "done" && (c = Sc(c, r, n, u.sort((d, f) => f.order - d.order).flatMap((d) => d.exit), o));
  try {
    return a === t.historyValue && Phe(t._nodes, s) ? c : Ma(c, {
      _nodes: u,
      historyValue: a
    });
  } catch (d) {
    throw d;
  }
}
function Ohe(e, t, n, r, i) {
  if (r.output === void 0)
    return;
  const o = A0(i.id, i.output !== void 0 && i.parent ? T0(i.output, e.context, t, n.self) : void 0);
  return T0(r.output, e.context, o, n.self);
}
function Bhe(e, t, n, r, i, o, s, a) {
  let l = e;
  const c = /* @__PURE__ */ new Set(), u = /* @__PURE__ */ new Set();
  Nhe(r, s, u, c), a && u.add(e.machine.root);
  const d = /* @__PURE__ */ new Set();
  for (const f of [...c].sort((h, p) => h.order - p.order)) {
    i.add(f);
    const h = [];
    h.push(...f.entry);
    for (const p of f.invoke)
      h.push(ghe(p.src, {
        ...p,
        syncSnapshot: !!p.onSnapshot
      }));
    if (u.has(f)) {
      const p = f.initial.actions;
      h.push(...p);
    }
    if (l = Sc(l, t, n, h, o, f.invoke.map((p) => p.id)), f.type === "final") {
      const p = f.parent;
      let m = (p == null ? void 0 : p.type) === "parallel" ? p : p == null ? void 0 : p.parent, g = m || f;
      for ((p == null ? void 0 : p.type) === "compound" && o.push(A0(p.id, f.output !== void 0 ? T0(f.output, l.context, t, n.self) : void 0)); (m == null ? void 0 : m.type) === "parallel" && !d.has(m) && Ux(i, m); )
        d.add(m), o.push(A0(m.id)), g = m, m = m.parent;
      if (m)
        continue;
      l = Ma(l, {
        status: "done",
        output: Ohe(l, t, n, l.machine.root, g)
      });
    }
  }
  return l;
}
function Nhe(e, t, n, r) {
  for (const i of e) {
    const o = YB(i, t);
    for (const a of i.target || [])
      !ua(a) && // if the target is different than the source then it will *definitely* be entered
      (i.source !== a || // we know that the domain can't lie within the source
      // if it's different than the source then it's outside of it and it means that the target has to be entered as well
      i.source !== o || // reentering transitions always enter the target, even if it's the source itself
      i.reenter) && (r.add(a), n.add(a)), kl(a, t, n, r);
    const s = Vx(i, t);
    for (const a of s) {
      const l = mf(a, o);
      (o == null ? void 0 : o.type) === "parallel" && l.push(o), QB(r, t, n, l, !i.source.parent && i.reenter ? void 0 : o);
    }
  }
}
function kl(e, t, n, r) {
  var i;
  if (ua(e))
    if (t[e.id]) {
      const o = t[e.id];
      for (const s of o)
        r.add(s), kl(s, t, n, r);
      for (const s of o)
        nv(s, e.parent, r, t, n);
    } else {
      const o = GB(e);
      for (const s of o.target)
        r.add(s), o === ((i = e.parent) == null ? void 0 : i.initial) && n.add(e.parent), kl(s, t, n, r);
      for (const s of o.target)
        nv(s, e.parent, r, t, n);
    }
  else if (e.type === "compound") {
    const [o] = e.initial.target;
    ua(o) || (r.add(o), n.add(o)), kl(o, t, n, r), nv(o, e, r, t, n);
  } else if (e.type === "parallel")
    for (const o of kc(e).filter((s) => !ua(s)))
      [...r].some((s) => Ds(s, o)) || (ua(o) || (r.add(o), n.add(o)), kl(o, t, n, r));
}
function QB(e, t, n, r, i) {
  for (const o of r)
    if ((!i || Ds(o, i)) && e.add(o), o.type === "parallel")
      for (const s of kc(o).filter((a) => !ua(a)))
        [...e].some((a) => Ds(a, s)) || (e.add(s), kl(s, t, n, e));
}
function nv(e, t, n, r, i) {
  QB(n, r, i, mf(e, t));
}
function Dhe(e, t, n, r, i, o, s) {
  let a = e;
  const l = I0(r, i, o);
  l.sort((u, d) => d.order - u.order);
  let c;
  for (const u of l)
    for (const d of _he(u)) {
      let f;
      d.history === "deep" ? f = (h) => Lx(h) && Ds(h, u) : f = (h) => h.parent === u, c ?? (c = {
        ...o
      }), c[d.id] = Array.from(i).filter(f);
    }
  for (const u of l)
    a = Sc(a, t, n, [...u.exit, ...u.invoke.map((d) => VB(d.id))], s), i.delete(u);
  return [a, c || o];
}
let PS = !1;
function JB(e, t, n, r, i, o) {
  const {
    machine: s
  } = e;
  let a = e;
  for (const l of r) {
    let h = function() {
      n.system._sendInspectionEvent({
        type: "@xstate.action",
        actorRef: n.self,
        action: {
          type: typeof l == "string" ? l : typeof l == "object" ? l.type : l.name || "(anonymous)",
          params: f
        }
      });
      try {
        PS = u, u(d, f);
      } finally {
        PS = !1;
      }
    };
    const c = typeof l == "function", u = c ? l : (
      // the existing type of `.actions` assumes non-nullable `TExpressionAction`
      // it's fine to cast this here to get a common type and lack of errors in the rest of the code
      // our logic below makes sure that we call those 2 "variants" correctly
      s.implementations.actions[typeof l == "string" ? l : l.type]
    );
    if (!u)
      continue;
    const d = {
      context: a.context,
      event: t,
      self: n.self,
      system: n.system
    }, f = c || typeof l == "string" ? void 0 : "params" in l ? typeof l.params == "function" ? l.params({
      context: a.context,
      event: t
    }) : l.params : void 0;
    if (!("resolve" in u)) {
      n.self._processingStatus === sr.Running ? h() : n.defer(() => {
        h();
      });
      continue;
    }
    const p = u, [m, g, v] = p.resolve(
      n,
      a,
      d,
      f,
      u,
      // this holds all params
      i
    );
    a = m, "retryResolve" in p && (o == null || o.push([p, g])), "execute" in p && (n.self._processingStatus === sr.Running ? p.execute(n, g) : n.defer(p.execute.bind(null, n, g))), v && (a = JB(a, t, n, v, i, o));
  }
  return a;
}
function Sc(e, t, n, r, i, o) {
  const s = o ? [] : void 0, a = JB(e, t, n, r, {
    internalQueue: i,
    deferredActorIds: o
  }, s);
  return s == null || s.forEach(([l, c]) => {
    l.retryResolve(n, a, c);
  }), a;
}
function rv(e, t, n, r = []) {
  let i = e;
  const o = [];
  function s(c, u, d) {
    n.system._sendInspectionEvent({
      type: "@xstate.microstep",
      actorRef: n.self,
      event: u,
      snapshot: c,
      _transitions: d
    }), o.push(c);
  }
  if (t.type === S0)
    return i = Ma(OS(i, t, n), {
      status: "stopped"
    }), s(i, t, []), {
      snapshot: i,
      microstates: o
    };
  let a = t;
  if (a.type !== jB) {
    const c = a, u = ahe(c), d = BS(c, i);
    if (u && !d.length)
      return i = Ma(e, {
        status: "error",
        error: c.error
      }), s(i, c, []), {
        snapshot: i,
        microstates: o
      };
    i = R0(
      d,
      e,
      n,
      a,
      !1,
      // isInitial
      r
    ), s(i, c, d);
  }
  let l = !0;
  for (; i.status === "active"; ) {
    let c = l ? jhe(i, a) : [];
    const u = c.length ? i : void 0;
    if (!c.length) {
      if (!r.length)
        break;
      a = r.shift(), c = BS(a, i);
    }
    i = R0(c, i, n, a, !1, r), l = i !== u, s(i, a, c);
  }
  return i.status !== "active" && OS(i, a, n), {
    snapshot: i,
    microstates: o
  };
}
function OS(e, t, n) {
  return Sc(e, t, n, Object.values(e.children).map((r) => VB(r)), []);
}
function BS(e, t) {
  return t.machine.getTransitionData(t, e);
}
function jhe(e, t) {
  const n = /* @__PURE__ */ new Set(), r = e._nodes.filter(Lx);
  for (const i of r)
    e: for (const o of [i].concat(mf(i, void 0)))
      if (o.always) {
        for (const s of o.always)
          if (s.guard === void 0 || Fx(s.guard, e.context, t, e)) {
            n.add(s);
            break e;
          }
      }
  return KB(Array.from(n), new Set(e._nodes), e.historyValue);
}
function Mhe(e, t) {
  const n = gp(bp(e, t));
  return WB(e, [...n]);
}
function Fhe(e) {
  return !!e && typeof e == "object" && "machine" in e && "value" in e;
}
const Lhe = function(t) {
  return FB(t, this.value);
}, Uhe = function(t) {
  return this.tags.has(t);
}, zhe = function(t) {
  const n = this.machine.getTransitionData(this, t);
  return !!(n != null && n.length) && // Check that at least one transition is not forbidden
  n.some((r) => r.target !== void 0 || r.actions.length);
}, Vhe = function() {
  const {
    _nodes: t,
    tags: n,
    machine: r,
    getMeta: i,
    toJSON: o,
    can: s,
    hasTag: a,
    matches: l,
    ...c
  } = this;
  return {
    ...c,
    tags: Array.from(n)
  };
}, qhe = function() {
  return this._nodes.reduce((t, n) => (n.meta !== void 0 && (t[n.id] = n.meta), t), {});
};
function Ih(e, t) {
  return {
    status: e.status,
    output: e.output,
    error: e.error,
    machine: t,
    context: e.context,
    _nodes: e._nodes,
    value: WB(t.root, e._nodes),
    tags: new Set(e._nodes.flatMap((n) => n.tags)),
    children: e.children,
    historyValue: e.historyValue || {},
    matches: Lhe,
    hasTag: Uhe,
    can: zhe,
    getMeta: qhe,
    toJSON: Vhe
  };
}
function Ma(e, t = {}) {
  return Ih({
    ...e,
    ...t
  }, e.machine);
}
function $he(e, t) {
  const {
    _nodes: n,
    tags: r,
    machine: i,
    children: o,
    context: s,
    can: a,
    hasTag: l,
    matches: c,
    getMeta: u,
    toJSON: d,
    ...f
  } = e, h = {};
  for (const m in o) {
    const g = o[m];
    h[m] = {
      snapshot: g.getPersistedSnapshot(t),
      src: g.src,
      systemId: g._systemId,
      syncSnapshot: g._syncSnapshot
    };
  }
  return {
    ...f,
    context: XB(s),
    children: h
  };
}
function XB(e) {
  let t;
  for (const n in e) {
    const r = e[n];
    if (r && typeof r == "object")
      if ("sessionId" in r && "send" in r && "ref" in r)
        t ?? (t = Array.isArray(e) ? e.slice() : {
          ...e
        }), t[n] = {
          xstate$$type: Mx,
          id: r.id
        };
      else {
        const i = XB(r);
        i !== r && (t ?? (t = Array.isArray(e) ? e.slice() : {
          ...e
        }), t[n] = i);
      }
  }
  return t ?? e;
}
function Whe(e, t, n, r, {
  event: i,
  id: o,
  delay: s
}, {
  internalQueue: a
}) {
  const l = t.machine.implementations.delays;
  if (typeof i == "string")
    throw new Error(`Only event objects may be used with raise; use raise({ type: "${i}" }) instead`);
  const c = typeof i == "function" ? i(n, r) : i;
  let u;
  if (typeof s == "string") {
    const d = l && l[s];
    u = typeof d == "function" ? d(n, r) : d;
  } else
    u = typeof s == "function" ? s(n, r) : s;
  return typeof u != "number" && a.push(c), [t, {
    event: c,
    id: o,
    delay: u
  }];
}
function Ghe(e, t) {
  const {
    event: n,
    delay: r,
    id: i
  } = t;
  if (typeof r == "number") {
    e.defer(() => {
      const o = e.self;
      e.system.scheduler.schedule(o, o, n, r, i);
    });
    return;
  }
}
function Hhe(e, t) {
  function n(r, i) {
  }
  return n.type = "xstate.raise", n.event = e, n.id = t == null ? void 0 : t.id, n.delay = t == null ? void 0 : t.delay, n.resolve = Whe, n.execute = Ghe, n;
}
function Khe(e, {
  machine: t,
  context: n
}, r, i) {
  const o = (s, a = {}) => {
    const {
      systemId: l,
      input: c
    } = a;
    if (typeof s == "string") {
      const u = jx(t, s);
      if (!u)
        throw new Error(`Actor logic '${s}' not implemented in machine '${t.id}'`);
      const d = Cc(u, {
        id: a.id,
        parent: e.self,
        syncSnapshot: a.syncSnapshot,
        input: typeof c == "function" ? c({
          context: n,
          event: r,
          self: e.self
        }) : c,
        src: s,
        systemId: l
      });
      return i[d.id] = d, d;
    } else
      return Cc(s, {
        id: a.id,
        parent: e.self,
        syncSnapshot: a.syncSnapshot,
        input: a.input,
        src: s,
        systemId: l
      });
  };
  return (s, a) => {
    const l = o(s, a);
    return i[l.id] = l, e.defer(() => {
      l._processingStatus !== sr.Stopped && l.start();
    }), l;
  };
}
function Yhe(e, t, n, r, {
  assignment: i
}) {
  if (!t.context)
    throw new Error("Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.");
  const o = {}, s = {
    context: t.context,
    event: n.event,
    spawn: Khe(e, t, n.event, o),
    self: e.self,
    system: e.system
  };
  let a = {};
  if (typeof i == "function")
    a = i(s, r);
  else
    for (const c of Object.keys(i)) {
      const u = i[c];
      a[c] = typeof u == "function" ? u(s, r) : u;
    }
  const l = Object.assign({}, t.context, a);
  return [Ma(t, {
    context: l,
    children: Object.keys(o).length ? {
      ...t.children,
      ...o
    } : t.children
  })];
}
function Gn(e) {
  function t(n, r) {
  }
  return t.type = "xstate.assign", t.assignment = e, t.resolve = Yhe, t;
}
function Qhe(e, t, n, r, {
  event: i
}) {
  const o = typeof i == "function" ? i(n, r) : i;
  return [t, {
    event: o
  }];
}
function Jhe(e, {
  event: t
}) {
  e.defer(() => e.emit(t));
}
function Xhe(e) {
  function t(n, r) {
  }
  return t.type = "xstate.emit", t.event = e, t.resolve = Qhe, t.execute = Jhe, t;
}
const NS = /* @__PURE__ */ new WeakMap();
function ll(e, t, n) {
  let r = NS.get(e);
  return r ? t in r || (r[t] = n()) : (r = {
    [t]: n()
  }, NS.set(e, r)), r[t];
}
const Zhe = {}, hu = (e) => typeof e == "string" ? {
  type: e
} : typeof e == "function" ? "resolve" in e ? {
  type: e.type
} : {
  type: e.name
} : e;
class qx {
  constructor(t, n) {
    if (this.config = t, this.key = void 0, this.id = void 0, this.type = void 0, this.path = void 0, this.states = void 0, this.history = void 0, this.entry = void 0, this.exit = void 0, this.parent = void 0, this.machine = void 0, this.meta = void 0, this.output = void 0, this.order = -1, this.description = void 0, this.tags = [], this.transitions = void 0, this.always = void 0, this.parent = n._parent, this.key = n._key, this.machine = n._machine, this.path = this.parent ? this.parent.path.concat(this.key) : [], this.id = this.config.id || [this.machine.id, ...this.path].join(NB), this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? "compound" : this.config.history ? "history" : "atomic"), this.description = this.config.description, this.order = this.machine.idMap.size, this.machine.idMap.set(this.id, this), this.states = this.config.states ? TS(this.config.states, (r, i) => new qx(r, {
      _parent: this,
      _key: i,
      _machine: this.machine
    })) : Zhe, this.type === "compound" && !this.config.initial)
      throw new Error(`No initial state specified for compound state node "#${this.id}". Try adding { initial: "${Object.keys(this.states)[0]}" } to the state config.`);
    this.history = this.config.history === !0 ? "shallow" : this.config.history || !1, this.entry = vs(this.config.entry).slice(), this.exit = vs(this.config.exit).slice(), this.meta = this.config.meta, this.output = this.type === "final" || !this.parent ? this.config.output : void 0, this.tags = vs(t.tags).slice();
  }
  /** @internal */
  _initialize() {
    this.transitions = Che(this), this.config.always && (this.always = dl(this.config.always).map((t) => na(this, DB, t))), Object.keys(this.states).forEach((t) => {
      this.states[t]._initialize();
    });
  }
  /** The well-structured state node definition. */
  get definition() {
    return {
      id: this.id,
      key: this.key,
      version: this.machine.version,
      type: this.type,
      initial: this.initial ? {
        target: this.initial.target,
        source: this,
        actions: this.initial.actions.map(hu),
        eventType: null,
        reenter: !1,
        toJSON: () => ({
          target: this.initial.target.map((t) => `#${t.id}`),
          source: `#${this.id}`,
          actions: this.initial.actions.map(hu),
          eventType: null
        })
      } : void 0,
      history: this.history,
      states: TS(this.states, (t) => t.definition),
      on: this.on,
      transitions: [...this.transitions.values()].flat().map((t) => ({
        ...t,
        actions: t.actions.map(hu)
      })),
      entry: this.entry.map(hu),
      exit: this.exit.map(hu),
      meta: this.meta,
      order: this.order || -1,
      output: this.output,
      invoke: this.invoke,
      description: this.description,
      tags: this.tags
    };
  }
  /** @internal */
  toJSON() {
    return this.definition;
  }
  /** The logic invoked as actors by this state node. */
  get invoke() {
    return ll(this, "invoke", () => vs(this.config.invoke).map((t, n) => {
      const {
        src: r,
        systemId: i
      } = t, o = t.id ?? _S(this.id, n), s = typeof r == "string" ? r : `xstate.invoke.${_S(this.id, n)}`;
      return {
        ...t,
        src: s,
        id: o,
        systemId: i,
        toJSON() {
          const {
            onDone: a,
            onError: l,
            ...c
          } = t;
          return {
            ...c,
            type: "xstate.invoke",
            src: s,
            id: o
          };
        }
      };
    }));
  }
  /** The mapping of events to transitions. */
  get on() {
    return ll(this, "on", () => [...this.transitions].flatMap(([n, r]) => r.map((i) => [n, i])).reduce((n, [r, i]) => (n[r] = n[r] || [], n[r].push(i), n), {}));
  }
  get after() {
    return ll(this, "delayedTransitions", () => xhe(this));
  }
  get initial() {
    return ll(this, "initial", () => khe(this, this.config.initial));
  }
  /** @internal */
  next(t, n) {
    const r = n.type, i = [];
    let o;
    const s = ll(this, `candidates-${r}`, () => whe(this, r));
    for (const a of s) {
      const {
        guard: l
      } = a, c = t.context;
      let u = !1;
      try {
        u = !l || Fx(l, c, n, t);
      } catch (d) {
        const f = typeof l == "string" ? l : typeof l == "object" ? l.type : void 0;
        throw new Error(`Unable to evaluate guard ${f ? `'${f}' ` : ""}in transition for event '${r}' in state node '${this.id}':
${d.message}`);
      }
      if (u) {
        i.push(...a.actions), o = a;
        break;
      }
    }
    return o ? [o] : void 0;
  }
  /** All the event types accepted by this state node and its descendants. */
  get events() {
    return ll(this, "events", () => {
      const {
        states: t
      } = this, n = new Set(this.ownEvents);
      if (t)
        for (const r of Object.keys(t)) {
          const i = t[r];
          if (i.states)
            for (const o of i.events)
              n.add(`${o}`);
        }
      return Array.from(n);
    });
  }
  /**
   * All the events that have transitions directly from this state node.
   *
   * Excludes any inert events.
   */
  get ownEvents() {
    const t = new Set([...this.transitions.keys()].filter((n) => this.transitions.get(n).some((r) => !(!r.target && !r.actions.length && !r.reenter))));
    return Array.from(t);
  }
}
const epe = "#";
class $x {
  constructor(t, n) {
    this.config = t, this.version = void 0, this.schemas = void 0, this.implementations = void 0, this.__xstatenode = !0, this.idMap = /* @__PURE__ */ new Map(), this.root = void 0, this.id = void 0, this.states = void 0, this.events = void 0, this.id = t.id || "(machine)", this.implementations = {
      actors: (n == null ? void 0 : n.actors) ?? {},
      actions: (n == null ? void 0 : n.actions) ?? {},
      delays: (n == null ? void 0 : n.delays) ?? {},
      guards: (n == null ? void 0 : n.guards) ?? {}
    }, this.version = this.config.version, this.schemas = this.config.schemas, this.transition = this.transition.bind(this), this.getInitialSnapshot = this.getInitialSnapshot.bind(this), this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this), this.restoreSnapshot = this.restoreSnapshot.bind(this), this.start = this.start.bind(this), this.root = new qx(t, {
      _key: this.id,
      _machine: this
    }), this.root._initialize(), this.states = this.root.states, this.events = this.root.events;
  }
  /**
   * Clones this state machine with the provided implementations and merges the
   * `context` (if provided).
   *
   * @param implementations Options (`actions`, `guards`, `actors`, `delays`,
   *   `context`) to recursively merge with the existing options.
   * @returns A new `StateMachine` instance with the provided implementations.
   */
  provide(t) {
    const {
      actions: n,
      guards: r,
      actors: i,
      delays: o
    } = this.implementations;
    return new $x(this.config, {
      actions: {
        ...n,
        ...t.actions
      },
      guards: {
        ...r,
        ...t.guards
      },
      actors: {
        ...i,
        ...t.actors
      },
      delays: {
        ...o,
        ...t.delays
      }
    });
  }
  resolveState(t) {
    const n = Mhe(this.root, t.value), r = gp(bp(this.root, n));
    return Ih({
      _nodes: [...r],
      context: t.context || {},
      children: {},
      status: Ux(r, this.root) ? "done" : t.status || "active",
      output: t.output,
      error: t.error,
      historyValue: t.historyValue
    }, this);
  }
  /**
   * Determines the next snapshot given the current `snapshot` and received
   * `event`. Calculates a full macrostep from all microsteps.
   *
   * @param snapshot The current snapshot
   * @param event The received event
   */
  transition(t, n, r) {
    return rv(t, n, r).snapshot;
  }
  /**
   * Determines the next state given the current `state` and `event`. Calculates
   * a microstep.
   *
   * @param state The current state
   * @param event The received event
   */
  microstep(t, n, r) {
    return rv(t, n, r).microstates;
  }
  getTransitionData(t, n) {
    return zx(this.root, t.value, t, n) || [];
  }
  /**
   * The initial state _before_ evaluating any microsteps. This "pre-initial"
   * state is provided to initial actions executed in the initial state.
   */
  getPreInitialState(t, n, r) {
    const {
      context: i
    } = this.config, o = Ih({
      context: typeof i != "function" && i ? i : {},
      _nodes: [this.root],
      children: {},
      status: "active"
    }, this);
    return typeof i == "function" ? Sc(o, n, t, [Gn(({
      spawn: a,
      event: l,
      self: c
    }) => i({
      spawn: a,
      input: l.input,
      self: c
    }))], r) : o;
  }
  /**
   * Returns the initial `State` instance, with reference to `self` as an
   * `ActorRef`.
   */
  getInitialSnapshot(t, n) {
    const r = MB(n), i = [], o = this.getPreInitialState(t, r, i), s = R0([{
      target: [...HB(this.root)],
      source: this.root,
      reenter: !0,
      actions: [],
      eventType: null,
      toJSON: null
      // TODO: fix
    }], o, t, r, !0, i), {
      snapshot: a
    } = rv(s, r, t, i);
    return a;
  }
  start(t) {
    Object.values(t.children).forEach((n) => {
      n.getSnapshot().status === "active" && n.start();
    });
  }
  getStateNodeById(t) {
    const n = Dx(t), r = n.slice(1), i = sm(n[0]) ? n[0].slice(epe.length) : n[0], o = this.idMap.get(i);
    if (!o)
      throw new Error(`Child state node '#${i}' does not exist on machine '${this.id}'`);
    return vp(o, r);
  }
  get definition() {
    return this.root.definition;
  }
  toJSON() {
    return this.definition;
  }
  getPersistedSnapshot(t, n) {
    return $he(t, n);
  }
  restoreSnapshot(t, n) {
    const r = {}, i = t.children;
    Object.keys(i).forEach((l) => {
      const c = i[l], u = c.snapshot, d = c.src, f = typeof d == "string" ? jx(this, d) : d;
      if (!f)
        return;
      const h = Cc(f, {
        id: l,
        parent: n.self,
        syncSnapshot: c.syncSnapshot,
        snapshot: u,
        src: d,
        systemId: c.systemId
      });
      r[l] = h;
    });
    const o = Ih({
      ...t,
      children: r,
      _nodes: Array.from(gp(bp(this.root, t.value)))
    }, this);
    let s = /* @__PURE__ */ new Set();
    function a(l, c) {
      if (!s.has(l)) {
        s.add(l);
        for (let u in l) {
          const d = l[u];
          if (d && typeof d == "object") {
            if ("xstate$$type" in d && d.xstate$$type === Mx) {
              l[u] = c[d.id];
              continue;
            }
            a(d, c);
          }
        }
      }
    }
    return a(o.context, r), o;
  }
}
function tpe(e, t) {
  return new $x(e, t);
}
function ZB({
  schemas: e,
  actors: t,
  actions: n,
  guards: r,
  delays: i
}) {
  return {
    createMachine: (o) => tpe({
      ...o,
      schemas: e
    }, {
      actors: t,
      actions: n,
      guards: r,
      delays: i
    })
  };
}
var iv = {}, P0 = { exports: {} }, ov = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var DS;
function npe() {
  if (DS) return ov;
  DS = 1;
  var e = I;
  function t(d, f) {
    return d === f && (d !== 0 || 1 / d === 1 / f) || d !== d && f !== f;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, i = e.useEffect, o = e.useLayoutEffect, s = e.useDebugValue;
  function a(d, f) {
    var h = f(), p = r({ inst: { value: h, getSnapshot: f } }), m = p[0].inst, g = p[1];
    return o(function() {
      m.value = h, m.getSnapshot = f, l(m) && g({ inst: m });
    }, [d, h, f]), i(function() {
      return l(m) && g({ inst: m }), d(function() {
        l(m) && g({ inst: m });
      });
    }, [d]), s(h), h;
  }
  function l(d) {
    var f = d.getSnapshot;
    d = d.value;
    try {
      var h = f();
      return !n(d, h);
    } catch {
      return !0;
    }
  }
  function c(d, f) {
    return f();
  }
  var u = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? c : a;
  return ov.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : u, ov;
}
var sv = {}, jS;
function rpe() {
  return jS || (jS = 1, ke.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = I, t = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function n(x) {
      {
        for (var C = arguments.length, S = new Array(C > 1 ? C - 1 : 0), k = 1; k < C; k++)
          S[k - 1] = arguments[k];
        r("error", x, S);
      }
    }
    function r(x, C, S) {
      {
        var k = t.ReactDebugCurrentFrame, A = k.getStackAddendum();
        A !== "" && (C += "%s", S = S.concat([A]));
        var b = S.map(function(T) {
          return String(T);
        });
        b.unshift("Warning: " + C), Function.prototype.apply.call(console[x], console, b);
      }
    }
    function i(x, C) {
      return x === C && (x !== 0 || 1 / x === 1 / C) || x !== x && C !== C;
    }
    var o = typeof Object.is == "function" ? Object.is : i, s = e.useState, a = e.useEffect, l = e.useLayoutEffect, c = e.useDebugValue, u = !1, d = !1;
    function f(x, C, S) {
      u || e.startTransition !== void 0 && (u = !0, n("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var k = C();
      if (!d) {
        var A = C();
        o(k, A) || (n("The result of getSnapshot should be cached to avoid an infinite loop"), d = !0);
      }
      var b = s({
        inst: {
          value: k,
          getSnapshot: C
        }
      }), T = b[0].inst, R = b[1];
      return l(function() {
        T.value = k, T.getSnapshot = C, h(T) && R({
          inst: T
        });
      }, [x, k, C]), a(function() {
        h(T) && R({
          inst: T
        });
        var B = function() {
          h(T) && R({
            inst: T
          });
        };
        return x(B);
      }, [x]), c(k), k;
    }
    function h(x) {
      var C = x.getSnapshot, S = x.value;
      try {
        var k = C();
        return !o(S, k);
      } catch {
        return !0;
      }
    }
    function p(x, C, S) {
      return C();
    }
    var m = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", g = !m, v = g ? p : f, w = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : v;
    sv.useSyncExternalStore = w, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), sv;
}
ke.env.NODE_ENV === "production" ? P0.exports = npe() : P0.exports = rpe();
var Wx = P0.exports;
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var MS;
function ipe() {
  if (MS) return iv;
  MS = 1;
  var e = I, t = Wx;
  function n(c, u) {
    return c === u && (c !== 0 || 1 / c === 1 / u) || c !== c && u !== u;
  }
  var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, o = e.useRef, s = e.useEffect, a = e.useMemo, l = e.useDebugValue;
  return iv.useSyncExternalStoreWithSelector = function(c, u, d, f, h) {
    var p = o(null);
    if (p.current === null) {
      var m = { hasValue: !1, value: null };
      p.current = m;
    } else m = p.current;
    p = a(function() {
      function v(k) {
        if (!w) {
          if (w = !0, x = k, k = f(k), h !== void 0 && m.hasValue) {
            var A = m.value;
            if (h(A, k)) return C = A;
          }
          return C = k;
        }
        if (A = C, r(x, k)) return A;
        var b = f(k);
        return h !== void 0 && h(A, b) ? A : (x = k, C = b);
      }
      var w = !1, x, C, S = d === void 0 ? null : d;
      return [function() {
        return v(u());
      }, S === null ? void 0 : function() {
        return v(S());
      }];
    }, [u, d, f, h]);
    var g = i(c, p[0], p[1]);
    return s(function() {
      m.hasValue = !0, m.value = g;
    }, [g]), l(g), g;
  }, iv;
}
var av = {}, FS;
function ope() {
  return FS || (FS = 1, ke.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = I, t = Wx;
    function n(u, d) {
      return u === d && (u !== 0 || 1 / u === 1 / d) || u !== u && d !== d;
    }
    var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, o = e.useRef, s = e.useEffect, a = e.useMemo, l = e.useDebugValue;
    function c(u, d, f, h, p) {
      var m = o(null), g;
      m.current === null ? (g = {
        hasValue: !1,
        value: null
      }, m.current = g) : g = m.current;
      var v = a(function() {
        var S = !1, k, A, b = function(O) {
          if (!S) {
            S = !0, k = O;
            var L = h(O);
            if (p !== void 0 && g.hasValue) {
              var V = g.value;
              if (p(V, L))
                return A = V, V;
            }
            return A = L, L;
          }
          var N = k, M = A;
          if (r(N, O))
            return M;
          var U = h(O);
          return p !== void 0 && p(M, U) ? M : (k = O, A = U, U);
        }, T = f === void 0 ? null : f, R = function() {
          return b(d());
        }, B = T === null ? void 0 : function() {
          return b(T());
        };
        return [R, B];
      }, [d, f, h, p]), w = v[0], x = v[1], C = i(u, w, x);
      return s(function() {
        g.hasValue = !0, g.value = C;
      }, [C]), l(C), C;
    }
    av.useSyncExternalStoreWithSelector = c, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), av;
}
ke.env.NODE_ENV === "production" ? ipe() : ope();
const e3 = (e, t) => {
  t(e);
  const n = e.getSnapshot().children;
  n && Object.values(n).forEach((r) => {
    e3(r, t);
  });
};
function spe(e) {
  var r, i;
  const t = [];
  e3(e, (o) => {
    t.push([o, o.getSnapshot()]), o.observers = /* @__PURE__ */ new Set();
  });
  const n = (i = (r = e.system).getSnapshot) == null ? void 0 : i.call(r);
  e.stop(), e.system._snapshot = n, t.forEach(([o, s]) => {
    o._processingStatus = 0, o._snapshot = s;
  });
}
function ape(e, ...[t]) {
  let [[n, r], i] = Oe(() => {
    const o = Cc(e, t);
    return [e.config, o];
  });
  if (e.config !== n) {
    const o = Cc(e, {
      ...t,
      snapshot: r.getPersistedSnapshot({
        __unsafeAllowInlineActors: !0
      })
    });
    i([e.config, o]), r = o;
  }
  return Yfe(() => {
    r.logic.implementations = e.implementations;
  }), r;
}
function lpe(e, ...[t]) {
  const n = ape(e, t), r = Ie(() => n.getSnapshot(), [n]), i = Ie((s) => {
    const {
      unsubscribe: a
    } = n.subscribe(s);
    return a;
  }, [n]), o = Wx.useSyncExternalStore(i, r, r);
  return Te(() => (n.start(), () => {
    spe(n);
  }), [n]), [o, n.send, n];
}
function t3(e, ...[t]) {
  return lpe(e, t);
}
const cpe = ({ onDone: e }) => {
  const t = cn(), n = PL(), r = bc(), i = fr(
    bc(),
    (d) => d.context.data
  ).unsafeCoerce(), { network: o, address: s, additionalAddresses: a, signMessage: l } = wt(), c = ZL(), u = Dt({
    onDone: e,
    trackEvent: t,
    exitStore: r,
    actionExit: n,
    signMessage: l,
    transactionGetTransactionVerificationMessageForNetwork: c,
    getData: () => G.fromRecord({
      network: G.fromNullable(o),
      address: G.fromNullable(s)
    }).map((d) => ({ ...d, ...i, additionalAddresses: a }))
  });
  return t3(Oe(() => upe(u))[0]);
}, upe = (e) => ZB({
  types: {
    context: {},
    events: {}
  }
}).createMachine({
  context: {
    error: G.empty(),
    transactionVerificationMessageDto: G.empty(),
    signedMessage: G.empty(),
    data: G.empty()
  },
  on: { UNSTAKE: { target: ".check", reenter: !0 } },
  initial: "initial",
  states: {
    initial: {},
    check: {
      on: {
        __GET_VERIFICATION_MESSAGE__: {
          target: "getVerificationMessage",
          actions: Gn({ data: ({ event: t }) => G.of(t.val) })
        },
        __SUBMIT__: {
          target: "submit",
          actions: Gn({ data: ({ event: t }) => G.of(t.val) })
        },
        __RESET__: "initial"
      },
      entry: ({ self: t }) => e.current.getData().caseOf({
        Just: (n) => {
          var r, i, o;
          e.current.trackEvent("unstakeClicked", {
            yieldId: n.integrationData.id,
            amount: n.requestDto.args.amount
          }), (o = (i = (r = n.integrationData.args.exit) == null ? void 0 : r.args) == null ? void 0 : i.signatureVerification) != null && o.required ? t.send({ type: "__GET_VERIFICATION_MESSAGE__", val: n }) : t.send({ type: "__SUBMIT__", val: n });
        },
        Nothing: () => t.send({ type: "__RESET__" })
      })
    },
    getVerificationMessage: {
      on: {
        __GET_VERIFICATION_MESSAGE_SUCCESS__: {
          target: "showPopup",
          actions: Gn(({ context: t, event: n }) => ({
            ...t,
            transactionVerificationMessageDto: G.of(n.val)
          }))
        },
        __GET_VERIFICATION_MESSAGE_ERROR__: {
          target: ".error",
          actions: Gn(({ context: t, event: n }) => ({
            ...t,
            error: G.of(n.val)
          }))
        }
      },
      initial: "loading",
      states: {
        loading: {
          entry: ({ self: t, context: n }) => de.liftEither(
            n.data.toEither(new Error("Missing init values"))
          ).chain(
            (r) => Kn({
              fn: () => e.current.transactionGetTransactionVerificationMessageForNetwork(
                r.network,
                {
                  addresses: {
                    address: r.address,
                    additionalAddresses: r.additionalAddresses ?? void 0
                  }
                }
              )
            }).mapLeft(
              () => new Error("Failed to get verification message")
            )
          ).caseOf({
            Right(r) {
              t.send({
                type: "__GET_VERIFICATION_MESSAGE_SUCCESS__",
                val: r
              });
            },
            Left(r) {
              t.send({
                type: "__GET_VERIFICATION_MESSAGE_ERROR__",
                val: r
              });
            }
          })
        },
        error: {}
      }
    },
    showPopup: {
      on: {
        CONTINUE_MESSAGE_SIGN: "signMessage",
        CANCEL_MESSAGE_SIGN: "initial"
      }
    },
    signMessage: {
      on: {
        __SIGN_MESSAGE_SUCCESS__: {
          target: "submit",
          actions: Gn(({ context: t, event: n }) => ({
            ...t,
            signedMessage: G.of(n.val)
          }))
        },
        __SIGN_MESSAGE_ERROR__: {
          target: ".error",
          actions: Gn(({ context: t, event: n }) => ({
            ...t,
            error: G.of(n.val)
          }))
        }
      },
      initial: "loading",
      states: {
        loading: {
          entry: ({ self: t, context: n }) => de.liftEither(
            n.transactionVerificationMessageDto.toEither(
              new Error("Missing transaction verification message")
            )
          ).chain((r) => e.current.signMessage(r.message)).caseOf({
            Right(r) {
              t.send({
                type: "__SIGN_MESSAGE_SUCCESS__",
                val: r
              });
            },
            Left(r) {
              t.send({ type: "__SIGN_MESSAGE_ERROR__", val: r });
            }
          })
        },
        error: {}
      }
    },
    submit: {
      on: {
        __SUBMIT_SUCCESS__: "done",
        __SUBMIT_ERROR__: ".error"
      },
      initial: "loading",
      states: {
        loading: {
          entry: ({
            self: t,
            context: {
              data: n,
              signedMessage: r,
              transactionVerificationMessageDto: i
            }
          }) => de.liftEither(
            n.map((o) => o.requestDto).map(
              (o) => G.fromRecord({
                transactionVerificationMessageDto: i,
                signedMessage: r
              }).map(
                (s) => ({
                  ...o,
                  args: {
                    ...o.args,
                    signatureVerification: {
                      message: s.transactionVerificationMessageDto.message,
                      signed: s.signedMessage
                    }
                  }
                })
              ).orDefault(o)
            ).toEither(new Error("Missing params"))
          ).chain(
            (o) => Kn({
              fn: () => e.current.actionExit(o)
            }).mapLeft(() => new Error("Stake exit error")).chain(
              (s) => de.liftEither(d1(s))
            ).ifRight(
              (s) => e.current.exitStore.send({
                type: "setActionDto",
                data: s
              })
            )
          ).caseOf({
            Right() {
              t.send({ type: "__SUBMIT_SUCCESS__" });
            },
            Left(o) {
              Gn(({ context: s }) => ({ ...s, error: o })), t.send({ type: "__SUBMIT_ERROR__" });
            }
          })
        },
        error: {}
      }
    },
    done: {
      type: "final",
      entry: e.current.onDone
    }
  }
}), dpe = () => {
  const e = fr(
    bc(),
    (O) => O.context.data
  ).unsafeCoerce(), t = e.requestDto.integrationId, n = UL(
    e.requestDto,
    { query: { staleTime: 0, gcTime: 0 } }
  ), r = rw(t), i = J(
    () => {
      var O;
      return G.fromNullable((O = n.data) == null ? void 0 : O.amount).map(Re);
    },
    [n.data]
  ), o = J(
    () => G.of(e.unstakeToken),
    [e.unstakeToken]
  ), s = J(
    () => G.of(e.integrationData),
    [e.integrationData]
  ), a = Cy({
    token: o,
    yieldDto: s
  }), l = J(
    () => new Re(e.requestDto.args.amount ?? 0),
    [e.requestDto.args.amount]
  ), { depositFee: c, managementFee: u, performanceFee: d } = Bx({
    amount: l,
    token: o,
    feeConfigDto: J(
      () => G.fromNullable(r.data),
      [r.data]
    ),
    prices: J(
      () => G.fromNullable(a.data),
      [a.data]
    )
  }), f = Px({
    gasAmount: i,
    gasFeeToken: e.gasFeeToken,
    address: e.requestDto.addresses.address,
    additionalAddresses: e.requestDto.addresses.additionalAddresses,
    isStake: !1
  }), { t: h } = ze(), p = J(() => Sn(l), [l]), m = s.map((O) => {
    switch (O.metadata.type) {
      case "staking":
      case "liquid-staking":
        return h("position_details.unstake");
      default:
        return h("position_details.withdraw");
    }
  }), g = er(), v = J(
    () => b1({
      gas: i,
      prices: G.fromNullable(a.data),
      yieldDto: s
    }),
    [s, a.data, i]
  ), w = s.chainNullable(
    (O) => O.metadata.provider ? { provider: O.metadata.provider, rest: O } : null
  ).map((O) => ({ type: "unstake", rewardToken: G.of({
    logoUri: O.provider.logoURI,
    providerName: O.provider.name,
    symbols: Ox([O.rest.token]),
    rewardTokens: [O.rest.token]
  }) })), x = J(() => ({ showMetaInfo: !1 }), []), [C, S] = cpe({
    onDone: () => g("../steps", { relative: "path" })
  }), k = C.matches("check") || C.matches({ getVerificationMessage: "loading" }) || C.matches({ signMessage: "loading" }) || C.matches({ submit: "loading" }), A = C.matches("showPopup"), b = () => S({ type: "CONTINUE_MESSAGE_SIGN" }), T = () => S({ type: "CANCEL_MESSAGE_SIGN" }), B = Dt(() => {
    k || S({ type: "UNSTAKE" });
  });
  return Ga(
    J(
      () => ({
        label: h("shared.confirm"),
        onClick: () => B.current(),
        disabled: !1,
        isLoading: k
      }),
      [B, h, k]
    )
  ), {
    integrationData: s,
    title: m,
    amount: p,
    fee: v,
    rewardTokenDetailsProps: w,
    token: o,
    metaInfo: x,
    onContinueUnstakeSignMessage: b,
    onCloseUnstakeSignMessage: T,
    showUnstakeSignMessagePopup: A,
    gasCheckLoading: n.isLoading || f.isLoading,
    isGasCheckWarning: !!f.data,
    depositFee: c,
    managementFee: u,
    performanceFee: d,
    feeConfigLoading: r.isPending
  };
}, fpe = () => {
  const {
    amount: e,
    fee: t,
    integrationData: n,
    rewardTokenDetailsProps: r,
    title: i,
    token: o,
    metaInfo: s,
    onContinueUnstakeSignMessage: a,
    onCloseUnstakeSignMessage: l,
    showUnstakeSignMessagePopup: c,
    gasCheckLoading: u,
    isGasCheckWarning: d,
    depositFee: f,
    managementFee: h,
    performanceFee: p,
    feeConfigLoading: m
  } = dpe();
  Vn("unstakeReview");
  const g = J(
    () => o.map((v) => `${e} ${v.symbol}`).extractNullable(),
    [e, o]
  );
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    /* @__PURE__ */ y.jsx(
      Nx,
      {
        rewardTokenDetailsProps: r,
        title: i.orDefault(""),
        fee: t,
        depositFee: f,
        managementFee: h,
        performanceFee: p,
        feeConfigLoading: m,
        info: g,
        metadata: n.map((v) => v.metadata),
        token: o,
        isGasCheckError: d,
        loading: u,
        ...s
      }
    ),
    /* @__PURE__ */ y.jsx(
      Kfe,
      {
        isOpen: c,
        onClick: a,
        onCancel: l
      }
    )
  ] });
}, n3 = () => {
  const {
    additionalAddresses: e,
    address: t,
    network: n,
    isLedgerLiveAccountPlaceholder: r
  } = wt(), i = J(
    () => G.fromRecord({
      additionalAddresses: Je(e ?? void 0),
      address: G.fromNullable(t),
      network: G.fromNullable(n)
    }).mapOrDefault(
      (s) => ({
        enabled: !r,
        dto: {
          addresses: {
            address: s.address,
            additionalAddresses: s.additionalAddresses
          },
          network: s.network
        }
      }),
      {
        enabled: !1,
        dto: {
          addresses: { address: "", additionalAddresses: void 0 },
          network: "ethereum"
        }
      }
    ),
    [e, t, r, n]
  ), o = ew();
  return Ut({
    queryKey: tw(i.dto),
    enabled: i.enabled,
    refetchInterval: 1e3 * 60,
    queryFn: async () => (await r3({
      tokenBalanceScanDto: i.dto,
      tokenTokenBalancesScan: o
    })).unsafeCoerce()
  });
}, hpe = (e) => de(
  () => e.queryClient.fetchQuery({
    queryKey: tw(e.tokenBalanceScanDto),
    queryFn: async () => (await r3(e)).unsafeCoerce()
  })
).mapLeft((t) => new Error("could not get multi yields")), r3 = ({
  tokenBalanceScanDto: e,
  tokenTokenBalancesScan: t
}) => de(() => t(e)).mapLeft(
  (n) => new Error("could not get token balances")
), ppe = () => {
  const e = ci();
  return Ie(
    () => e.invalidateQueries({
      queryKey: [
        tw({})[0]
      ]
    }),
    [e]
  );
}, lv = ({
  network: e,
  transactionGetGasForNetwork: t
}) => Kn({ fn: () => t(e) }).mapLeft(() => new Error("Get gas for network error")).chain(
  (n) => de.liftEither(
    pt.find((r) => r.name === "average", n.modes.values).toEither(
      new Error("Average gas mode not found")
    )
  )
), ype = ({
  transactions: e,
  integrationId: t
}) => {
  const {
    signTransaction: n,
    signMultipleTransactions: r,
    signMessage: i,
    connector: o,
    isLedgerLive: s
  } = wt(), a = cn(), l = YL(), c = JL(), u = HL(), d = QL(), f = XL(), h = KL(), p = J(
    () => G.fromNullable(o).map(Tee).orDefault(!1),
    [o]
  ), m = J(
    () => e.sort((v, w) => v.stepIndex - w.stepIndex),
    [e]
  ), g = Dt({
    transactions: m,
    integrationId: t,
    multiSend: p,
    isLedgerLive: s,
    trackEvent: a,
    signMultipleTransactions: r,
    signMessage: i,
    signTransaction: n,
    transactionSubmit: l,
    transactionGetTransactionStatusFromId: c,
    transactionGetTransaction: u,
    transactionSubmitHash: d,
    transactionGetGasForNetwork: f,
    transactionConstruct: h
  });
  return t3(Oe(() => mpe(g))[0]);
}, mpe = (e) => {
  const t = (...r) => Kn({
    fn: () => e.current.transactionConstruct(...r),
    shouldRetry: (i, o) => {
      var s;
      return o <= 3 && _o(i) && ((s = i.response) == null ? void 0 : s.status) === 404;
    }
  }).mapLeft(() => new Error("Transaction construct error")), n = gpe(
    e.current.transactions,
    e.current.integrationId,
    e.current.multiSend
  );
  return ZB({
    types: {
      emitted: {},
      context: {},
      events: {}
    }
  }).createMachine({
    context: {
      yieldId: G.fromNullable(n == null ? void 0 : n.yieldId),
      txStates: (n == null ? void 0 : n.txStates) ?? [],
      currentTxMeta: G.fromNullable(n == null ? void 0 : n.currentTxMeta),
      txCheckTimeoutId: G.empty()
    },
    initial: n.enabled ? "idle" : "disabled",
    states: {
      idle: {
        on: { START: "signLoading" }
      },
      disabled: {},
      signLoading: {
        on: {
          __SIGN_SUCCESS__: {
            target: "broadcastLoading",
            actions: [
              Gn({
                txStates: ({ context: r, event: i }) => r.currentTxMeta.map(
                  (o) => r.txStates.map(
                    (s, a) => a === o.idx ? {
                      ...s,
                      meta: {
                        ...s.meta,
                        txCheckError: null,
                        signError: null,
                        broadcasted: i.val.data.broadcasted,
                        signedTx: i.val.data.signedTx
                      }
                    } : s
                  )
                ).orDefault(r.txStates)
              }),
              Xhe({ type: "signSuccess" })
            ]
          },
          __SIGN_ERROR__: {
            target: "signError",
            actions: Gn({
              txStates: ({ context: r, event: i }) => r.currentTxMeta.map(
                (o) => r.txStates.map(
                  (s, a) => a === o.idx ? {
                    ...s,
                    meta: {
                      ...s.meta,
                      txCheckError: null,
                      signError: i.val
                    }
                  } : s
                )
              ).orDefault(r.txStates)
            })
          },
          __BROADCAST_SUCCESS__: "txCheckLoading"
        },
        entry: ({ context: r, self: i }) => {
          de.liftEither(
            r.currentTxMeta.chainNullable((o) => r.txStates[o.idx].tx).toEither(new Error("missing tx"))
          ).chain((o) => {
            const s = e.current.transactions;
            return e.current.multiSend ? de.liftEither(
              _e(
                s.find(
                  (a) => yR.has(a.type)
                )
              )
            ).chain((a) => a ? lv({
              network: a.network,
              transactionGetGasForNetwork: e.current.transactionGetGasForNetwork
            }).chainLeft(async () => _e(null)).chain(
              (l) => t(a.id, {
                gasArgs: l == null ? void 0 : l.gasArgs,
                ledgerWalletAPICompatible: e.current.isLedgerLive
              }).mapLeft(() => new lu())
            ).chain(
              () => Kn({
                fn: () => e.current.transactionGetTransactionStatusFromId(
                  a.id
                ),
                retryTimes: 10,
                retryWaitForMs: () => 5e3
              }).mapLeft(
                () => new Error(
                  `failed to get ${a.id} tx status`
                )
              )
            ) : de.liftEither(_e(null))).map(() => HX(s)).chain(
              (a) => lv({
                network: o.network,
                transactionGetGasForNetwork: e.current.transactionGetGasForNetwork
              }).chain(
                (l) => de.sequence(
                  a.map(
                    (c) => t(c.id, {
                      gasArgs: l == null ? void 0 : l.gasArgs,
                      ledgerWalletAPICompatible: e.current.isLedgerLive
                    }).mapLeft(() => new lu())
                  )
                )
              )
            ).map(
              (a) => a.map((l) => l.unsignedTransaction).filter((l) => l !== null)
            ).chain((a) => a.length ? e.current.signMultipleTransactions({ txs: a }) : de.liftEither(
              Xe(new lu())
            )).map((a) => ({ type: "regular", data: a })) : lv({
              network: o.network,
              transactionGetGasForNetwork: e.current.transactionGetGasForNetwork
            }).chainLeft(async () => _e(null)).chain(
              (a) => t(o.id, {
                gasArgs: a == null ? void 0 : a.gasArgs,
                ledgerWalletAPICompatible: e.current.isLedgerLive
              }).mapLeft(() => new lu())
            ).chain((a) => a.status === "BROADCASTED" || a.status === "CONFIRMED" ? de.liftEither(
              _e({ type: "broadcasted" })
            ) : a.unsignedTransaction ? a.isMessage ? e.current.signMessage(a.unsignedTransaction).map((l) => ({
              type: "regular",
              data: { signedTx: l, broadcasted: !1 }
            })) : e.current.signTransaction({
              tx: a.unsignedTransaction,
              ledgerHwAppId: a.ledgerHwAppId
            }).map((l) => ({
              ...l,
              network: a.network,
              txId: a.id
            })).ifRight(
              () => e.current.trackEvent("txSigned", {
                txId: a.id,
                network: a.network,
                yieldId: r.yieldId
              })
            ).map((l) => ({ type: "regular", data: l })) : de.liftEither(
              Xe(new lu())
            ));
          }).caseOf({
            Left: (o) => {
              i.send({ type: "__SIGN_ERROR__", val: o });
            },
            Right: (o) => {
              if (o.type === "broadcasted")
                return i.send({ type: "__BROADCAST_SUCCESS__" });
              i.send({ type: "__SIGN_SUCCESS__", val: o });
            }
          });
        }
      },
      signError: {
        on: { __SIGN_RETRY__: "signLoading" }
      },
      broadcastLoading: {
        on: {
          __BROADCAST_SUCCESS__: {
            target: "txCheckLoading",
            actions: Gn({
              txStates: ({ context: r }) => r.currentTxMeta.map(
                (i) => r.txStates.map(
                  (o, s) => s === i.idx ? {
                    ...o,
                    meta: {
                      ...o.meta,
                      txCheckError: null,
                      signError: null
                    }
                  } : o
                )
              ).orDefault(r.txStates)
            })
          },
          __BROADCAST_ERROR__: {
            target: "broadcastError",
            actions: Gn({
              txStates: ({ context: r }) => r.currentTxMeta.map(
                (i) => r.txStates.map(
                  (o, s) => s === i.idx ? {
                    ...o,
                    meta: {
                      ...o.meta,
                      txCheckError: null,
                      signError: null
                    }
                  } : o
                )
              ).orDefault(r.txStates)
            })
          }
        },
        entry: ({ self: r, context: i }) => {
          de.liftEither(
            i.currentTxMeta.chainNullable((o) => i.txStates[o.idx]).toEither(new Error("missing tx"))
          ).chain((o) => o.meta.broadcasted ? Kn({
            fn: () => e.current.transactionSubmitHash(o.tx.id, {
              hash: o.meta.signedTx
            })
          }).mapLeft(() => new yee()).ifRight(() => {
            e.current.trackEvent("txSubmitted", {
              txId: o.tx.id,
              network: o.tx.network,
              yieldId: i.yieldId
            });
          }) : Kn({
            fn: async () => {
              await e.current.transactionSubmit(o.tx.id, {
                signedTransaction: o.meta.signedTx
              });
            }
          }).mapLeft(() => new mee()).ifRight(() => {
            e.current.trackEvent("txSubmitted", {
              txId: o.tx.id,
              network: o.tx.network,
              yieldId: i.yieldId
            });
          })).caseOf({
            Left: (o) => {
              r.send({ type: "__BROADCAST_ERROR__", val: o });
            },
            Right: () => r.send({ type: "__BROADCAST_SUCCESS__" })
          });
        }
      },
      broadcastError: {
        on: { __BROADCAST_RETRY__: "broadcastLoading" }
      },
      txCheckLoading: {
        on: {
          __SIGN_NEXT_TX__: {
            target: "signLoading",
            actions: Gn({
              currentTxMeta: ({ event: r }) => G.of(r.val.newCurrentTxMeta),
              txStates: ({ event: r }) => r.val.newTxStates
            })
          },
          __DONE__: {
            target: "done",
            actions: Gn({ txStates: ({ event: r }) => r.val })
          },
          __TX_CHECK_ERROR__: {
            target: "txCheckError",
            actions: Gn({
              txStates: ({ context: r, event: i }) => r.currentTxMeta.map(
                (o) => r.txStates.map(
                  (s, a) => a === o.idx ? {
                    ...s,
                    meta: {
                      ...s.meta,
                      txCheckError: i.val,
                      signError: null
                    }
                  } : s
                )
              ).orDefault(r.txStates)
            })
          },
          __TX_CHECK_RETRY__: "txCheckRetry"
        },
        entry: ({ self: r, context: i }) => {
          de.liftEither(
            i.currentTxMeta.chainNullable((o) => i.txStates[o.idx]).toEither(new Error("missing tx"))
          ).chain(
            (o) => Kn({
              fn: () => e.current.transactionGetTransactionStatusFromId(
                o.tx.id
              ),
              shouldRetry: (s, a) => {
                var l, c;
                return a <= 3 && _o(s) && (((l = s.response) == null ? void 0 : l.status) === 404 || ((c = s.response) == null ? void 0 : c.status) === 503);
              }
            }).map((s) => ({ url: s.url, status: s.status })).chainLeft(
              () => Kn({
                fn: () => e.current.transactionGetTransaction(o.tx.id)
              }).map((s) => ({
                url: s.explorerUrl,
                status: s.status
              }))
            ).mapLeft(() => new pee()).chain(
              (s) => de.liftEither(
                pR(s.status) ? Xe(
                  new l4({
                    txId: o.tx.id,
                    network: o.tx.network
                  })
                ) : _e({
                  url: s.url,
                  isConfirmed: s.status === "CONFIRMED"
                })
              )
            )
          ).caseOf({
            Left: (o) => {
              o instanceof l4 && e.current.trackEvent("txNotConfirmed", {
                txId: o.txId,
                yieldId: i.yieldId
              }), r.send({ type: "__TX_CHECK_ERROR__", val: o });
            },
            Right: (o) => {
              if (o.isConfirmed) {
                const s = i.currentTxMeta.map(
                  (l) => i.txStates.map(
                    (c, u) => u === l.idx ? {
                      ...c,
                      meta: {
                        ...c.meta,
                        signError: null,
                        txCheckError: null,
                        url: o.url,
                        done: !0
                      }
                    } : c
                  )
                ).orDefault(i.txStates), a = pt.findIndex(
                  (l) => !l.meta.done,
                  s
                ).map((l) => ({
                  idx: l,
                  id: s[l].tx.id
                })).extractNullable();
                if (!a)
                  return r.send({ type: "__DONE__", val: s });
                r.send({
                  type: "__SIGN_NEXT_TX__",
                  val: { newTxStates: s, newCurrentTxMeta: a }
                });
              } else
                r.send({ type: "__TX_CHECK_RETRY__" });
            }
          });
        }
      },
      txCheckRetry: {
        on: {
          __TX_CHECK_RETRY__: "txCheckLoading",
          __TX_CHECK_RETRY_TIMEOUT__: {
            actions: Gn({
              txCheckTimeoutId: ({ event: r }) => G.of(r.val)
            })
          }
        },
        entry: ({ self: r }) => {
          const i = setTimeout(() => {
            r.send({ type: "__TX_CHECK_RETRY__" });
          }, 4e3);
          r.send({
            type: "__TX_CHECK_RETRY_TIMEOUT__",
            val: i
          });
        }
      },
      txCheckError: {
        on: { __TX_CHECK_RETRY__: "txCheckLoading" }
      },
      done: {
        type: "final"
      }
    }
  });
}, gpe = (e, t, n) => {
  if (!e.length)
    return {
      enabled: !1,
      txStates: null,
      currentTxMeta: null,
      yieldId: null
    };
  const r = e.map((s) => ({
    tx: s,
    meta: {
      broadcasted: null,
      signedTx: null,
      url: null,
      signError: null,
      txCheckError: null,
      done: !1
    }
  })), i = 0, o = {
    idx: i,
    id: e[i].id
  };
  return {
    enabled: !0,
    txStates: n ? [r[i]] : r,
    currentTxMeta: o,
    yieldId: t
  };
}, vpe = ({
  session: e,
  onSignSuccess: t
}) => {
  const n = er(), r = Dt({ onSignSuccess: t }), [i, o, s] = ype({
    transactions: e.transactions,
    integrationId: e.integrationId
  });
  js(() => {
    o({ type: "START" });
  }, [o]), Te(() => {
    const m = s.on(
      "signSuccess",
      () => {
        var g, v;
        return (v = (g = r.current).onSignSuccess) == null ? void 0 : v.call(g);
      }
    );
    return () => {
      m.unsubscribe();
    };
  }, [s, r]), Te(() => () => {
    i.context.txCheckTimeoutId.ifJust((m) => clearTimeout(m));
  }, [i.context.txCheckTimeoutId]);
  const a = Xce(), l = ppe(), c = Yce();
  Te(() => {
    i.status === "done" && (a(), l(), c(), n("../complete", {
      state: {
        urls: i.context.txStates.map((m) => ({ type: m.tx.type, url: m.meta.url })).filter(
          (m) => !!m.url
        )
      },
      relative: "path",
      replace: !0
    }));
  }, [
    a,
    l,
    c,
    n,
    i.context.txStates,
    i.status
  ]);
  const u = () => n(-1), d = (() => {
    if (i.matches("signError"))
      return () => o({ type: "__SIGN_RETRY__" });
    if (i.matches("broadcastError"))
      return () => o({ type: "__BROADCAST_RETRY__" });
    if (i.matches("txCheckError"))
      return () => o({ type: "__TX_CHECK_RETRY__" });
  })(), f = J(
    () => i.context.txStates.map((m) => ({
      ...m,
      state: bpe({
        txState: m,
        machineState: i.value,
        currentTxId: i.context.currentTxMeta.map((g) => g.id).extractNullable()
      })
    })),
    [
      i.context.currentTxMeta,
      i.context.txStates,
      i.value
    ]
  ), { t: h } = ze(), p = Dt(u);
  return Ga(
    J(
      () => f.length ? {
        disabled: !1,
        isLoading: !1,
        label: h("shared.cancel"),
        onClick: () => p.current(),
        variant: "secondary"
      } : null,
      [f.length, h, p]
    )
  ), {
    retry: d,
    txStates: f
  };
};
var ut = /* @__PURE__ */ ((e) => (e[e.SIGN_IDLE = 0] = "SIGN_IDLE", e[e.SIGN_ERROR = 1] = "SIGN_ERROR", e[e.SIGN_LOADING = 2] = "SIGN_LOADING", e[e.SIGN_SUCCESS = 3] = "SIGN_SUCCESS", e[e.BROADCAST_IDLE = 4] = "BROADCAST_IDLE", e[e.BROADCAST_ERROR = 5] = "BROADCAST_ERROR", e[e.BROADCAST_LOADING = 6] = "BROADCAST_LOADING", e[e.BROADCAST_SUCCESS = 7] = "BROADCAST_SUCCESS", e[e.CHECK_TX_STATUS_IDLE = 8] = "CHECK_TX_STATUS_IDLE", e[e.CHECK_TX_STATUS_ERROR = 9] = "CHECK_TX_STATUS_ERROR", e[e.CHECK_TX_STATUS_LOADING = 10] = "CHECK_TX_STATUS_LOADING", e[e.CHECK_TX_STATUS_SUCCESS = 11] = "CHECK_TX_STATUS_SUCCESS", e))(ut || {});
const bpe = ({
  currentTxId: e,
  machineState: t,
  txState: n
}) => {
  const r = e === null ? !1 : e === n.tx.id;
  return (() => {
    if (n.meta.done) return 11;
    if (!r) return 0;
    switch (t) {
      case "idle":
      case "signLoading":
        return 2;
      case "signError":
        return 1;
      case "broadcastLoading":
        return 6;
      case "broadcastError":
        return 5;
      case "txCheckError":
        return 9;
      case "txCheckRetry":
      case "txCheckLoading":
        return 10;
      case "done":
        return 11;
      case "disabled":
        return 0;
    }
  })();
}, wpe = () => {
  var n;
  const e = cd(), t = P6(
    "sk-widget@1//referralCode"
  );
  return Te(() => {
    var r;
    (r = e.data) != null && r.referralCode && np(
      "sk-widget@1//referralCode",
      e.data.referralCode
    );
  }, [(n = e.data) == null ? void 0 : n.referralCode]), cd({
    select: (r) => r.referralCode ?? t
  });
}, i3 = ["referral-code"], am = () => {
  const e = wpe(), { referralCheck: t } = bt(), n = Fp();
  return Ut({
    queryKey: i3,
    enabled: !e.isPending && !!t,
    staleTime: Number.POSITIVE_INFINITY,
    queryFn: async () => (await de.liftEither(
      G.fromNullable(e.data).toEither(
        new Error("missing referral code")
      )
    ).chain((r) => o3({ referralCode: r, apiClient: n }))).unsafeCoerce()
  });
}, xpe = () => {
  const e = ci(), t = Fp();
  return li({
    mutationFn: async (n) => (await o3({ referralCode: n, apiClient: t })).unsafeCoerce(),
    onSuccess: (n) => {
      np("sk-widget@1//referralCode", n.code), e.setQueryData(i3, n);
    }
  });
}, o3 = ({
  apiClient: e,
  referralCode: t
}) => de(
  () => e.get(`/v1/referrals/${t}`)
).map((n) => n.data).mapLeft((n) => _o(n) ? n : new Error("unknown error")), [s3, Cpe] = df(!1), kpe = ({ children: e }) => {
  var p;
  const t = S6(), [n] = $O(), [r] = hx(), [i] = j6(), { state: o, dispatch: s } = qo(), { referralCheck: a, disableInitLayoutAnimation: l } = bt(), c = am(), u = !a || !!c.data, d = (p = t.state) != null && p.height && n ? t.state.height + n + r + i : 0, [f] = s3(), h = Je(d).chain(
    (m) => Je(null).map(() => f ? { duration: 0 } : o.layout ? { duration: 0.3 } : l ? { duration: 0 } : { duration: 0.6, delay: 0.3 }).map((g) => ({ height: m, transition: g }))
  ).unsafeCoerce();
  return /* @__PURE__ */ y.jsx(y.Fragment, { children: u ? /* @__PURE__ */ y.jsx(
    Zt.div,
    {
      "data-rk": "widget-container",
      layout: "size",
      className: F6,
      initial: { height: 0 },
      animate: h,
      onAnimationComplete: (m) => {
        !m.height || o.layout || s({ type: "layout" });
      },
      children: e
    }
  ) : c.isLoading ? /* @__PURE__ */ y.jsx(z, { display: "flex", justifyContent: "center", alignItems: "center", children: /* @__PURE__ */ y.jsx(ei, {}) }) : null });
};
var Epe = "xx8dwz0", Spe = "xx8dwz1", Ape = "xx8dwz2";
const a3 = Ge(void 0), Gx = () => {
  const e = we(a3);
  if (!e)
    throw new Error("useCollapsible must be used within a CollapsibleRoot");
  return e;
}, l3 = ({ children: e, ...t }) => {
  const n = Oe(!0), r = J(
    () => t.onClick ? {
      collapsed: t.collapsed,
      onClick: t.onClick
    } : {
      collapsed: n[0],
      onClick: () => n[1]((i) => !i)
    },
    [t.onClick, t.collapsed, n]
  );
  return /* @__PURE__ */ y.jsx(a3.Provider, { value: r, children: e });
}, c3 = ({
  children: e,
  ...t
}) => {
  const { onClick: n } = Gx();
  return /* @__PURE__ */ y.jsx(
    z,
    {
      display: "flex",
      onClick: n,
      justifyContent: "space-between",
      alignItems: "center",
      className: Epe,
      ...t,
      children: e
    }
  );
}, u3 = () => {
  const { collapsed: e } = Gx();
  return /* @__PURE__ */ y.jsx(
    z,
    {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      className: wr([Spe, { [Ape]: !e }]),
      children: /* @__PURE__ */ y.jsx($a, { size: 20 })
    }
  );
}, d3 = ({ children: e }) => {
  const { collapsed: t } = Gx(), n = RR();
  return /* @__PURE__ */ y.jsx(Fy, { children: !t && /* @__PURE__ */ y.jsx(Tpe, { isFirstMount: n, children: e }) });
}, ih = {
  open: { opacity: 1, height: "auto" },
  closed: { opacity: 0, height: 0 }
}, Tpe = ({
  isFirstMount: e,
  children: t
}) => {
  const [n, r] = VP(), [i, o] = Doe(), [, s] = s3();
  return Te(() => {
    n ? (async () => (s(!0), await o(i.current, ih.open), s(!1)))() : (async () => (s(!0), await o(i.current, ih.closed), s(!1), r()))();
  }, [o, n, r, i, s]), /* @__PURE__ */ y.jsx(
    Zt.div,
    {
      ref: i,
      initial: e ? ih.open : ih.closed,
      style: { overflow: "hidden" },
      transition: { duration: 0.3 },
      children: t
    }
  );
}, Eu = (e) => /* @__PURE__ */ y.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 448 512",
    fill: e.color ?? zt.color.background,
    height: e.hw ?? 24,
    width: e.hw ?? 24,
    children: /* @__PURE__ */ y.jsx("path", { d: "M438.6 105.4c12.5 12.5 12.5 32.8 0 45.3l-256 256c-12.5 12.5-32.8 12.5-45.3 0l-128-128c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0L160 338.7l233.4-233.3c12.5-12.5 32.8-12.5 45.3 0z" })
  }
);
var cv = "_1gejx700", uv = "_1gejx701 _1gejx700", dv = "_1gejx702", fv = "_1gejx703 _1gejx702", hv = "_1gejx704";
const _pe = ({ txState: e, position: t, count: n }) => {
  const { t: r } = ze(), i = e.meta.done && t !== "LAST" && t !== "SINGLE" || e.state === ut.SIGN_IDLE, [o, s] = Oe(i);
  return js(() => {
    s(i);
  }, [i]), /* @__PURE__ */ y.jsx(
    z,
    {
      marginTop: t === "FIRST" || t === "SINGLE" ? "0" : "4",
      children: /* @__PURE__ */ y.jsxs(
        l3,
        {
          onClick: () => i && s((a) => !a),
          collapsed: o,
          children: [
            /* @__PURE__ */ y.jsxs(
              c3,
              {
                width: "full",
                marginBottom: "4",
                as: i ? "button" : "div",
                children: [
                  /* @__PURE__ */ y.jsx(ue, { children: r("steps.tx_of", {
                    count: n.total,
                    current: n.current,
                    type: r(`steps.tx_type.${e.tx.type}`)
                  }) }),
                  i && !!n && /* @__PURE__ */ y.jsx(u3, {})
                ]
              }
            ),
            /* @__PURE__ */ y.jsxs(d3, { children: [
              /* @__PURE__ */ y.jsxs(
                z,
                {
                  display: "flex",
                  opacity: e.state > ut.SIGN_IDLE ? 1 : 0.5,
                  children: [
                    /* @__PURE__ */ y.jsx(
                      z,
                      {
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "center",
                        marginRight: "3",
                        className: wr({
                          [cv]: !0,
                          [hv]: e.state < ut.SIGN_SUCCESS,
                          [uv]: e.state > ut.SIGN_IDLE && e.state < ut.SIGN_SUCCESS
                        }),
                        children: /* @__PURE__ */ y.jsx(
                          z,
                          {
                            background: e.state > ut.SIGN_IDLE ? "text" : "white",
                            borderColor: e.state > ut.SIGN_IDLE ? "text" : "textMuted",
                            borderRadius: "half",
                            hw: "10",
                            borderWidth: 3,
                            borderStyle: "solid",
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            "data-rk": "tx-state-step-circle",
                            "data-state": e.state > ut.SIGN_IDLE ? "success" : "pending",
                            children: e.state === ut.SIGN_LOADING ? /* @__PURE__ */ y.jsx(ei, { variant: { color: "inverted" } }) : e.state === ut.SIGN_ERROR ? /* @__PURE__ */ y.jsx(Il, { color: "background" }) : e.state >= ut.SIGN_SUCCESS ? /* @__PURE__ */ y.jsx(Eu, { hw: 18 }) : null
                          }
                        )
                      }
                    ),
                    /* @__PURE__ */ y.jsxs(
                      z,
                      {
                        flexDirection: "column",
                        display: "flex",
                        alignItems: "flex-start",
                        gap: "1",
                        children: [
                          /* @__PURE__ */ y.jsx(ue, { children: r("steps.approve") }),
                          e.state === ut.SIGN_ERROR ? /* @__PURE__ */ y.jsx(ue, { variant: { type: "danger" }, children: r("steps.approve_error") }) : /* @__PURE__ */ y.jsx(ue, { variant: { type: "muted", weight: "normal" }, children: r("steps.approve_desc") })
                        ]
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ y.jsxs(
                z,
                {
                  display: "flex",
                  alignItems: "center",
                  opacity: e.state >= ut.SIGN_SUCCESS ? 1 : 0.5,
                  children: [
                    /* @__PURE__ */ y.jsx(
                      z,
                      {
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "center",
                        marginRight: "3",
                        className: wr({
                          [cv]: !0,
                          [dv]: !0,
                          [uv]: e.state < ut.BROADCAST_SUCCESS,
                          [hv]: e.state === ut.BROADCAST_LOADING || e.state === ut.BROADCAST_ERROR,
                          [fv]: e.state < ut.SIGN_SUCCESS
                        }),
                        children: /* @__PURE__ */ y.jsx(
                          z,
                          {
                            background: e.state >= ut.SIGN_SUCCESS ? "text" : "white",
                            borderColor: e.state >= ut.SIGN_SUCCESS ? "text" : "textMuted",
                            borderRadius: "half",
                            borderWidth: 3,
                            borderStyle: "solid",
                            hw: "10",
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            "data-rk": "tx-state-step-circle",
                            "data-state": e.state >= ut.SIGN_SUCCESS ? "success" : "pending",
                            children: e.state === ut.BROADCAST_LOADING ? /* @__PURE__ */ y.jsx(ei, { variant: { color: "inverted" } }) : e.state === ut.BROADCAST_ERROR ? /* @__PURE__ */ y.jsx(Il, { color: "background" }) : e.state >= ut.BROADCAST_SUCCESS ? /* @__PURE__ */ y.jsx(Eu, { hw: 18 }) : null
                          }
                        )
                      }
                    ),
                    /* @__PURE__ */ y.jsxs(
                      z,
                      {
                        flexDirection: "column",
                        display: "flex",
                        alignItems: "flex-start",
                        gap: "1",
                        marginTop: "6",
                        children: [
                          /* @__PURE__ */ y.jsx(ue, { children: r("steps.submitting") }),
                          e.state === ut.BROADCAST_ERROR && /* @__PURE__ */ y.jsx(ue, { variant: { type: "danger" }, children: r("shared.something_went_wrong") })
                        ]
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ y.jsxs(
                z,
                {
                  display: "flex",
                  alignItems: "center",
                  opacity: e.state >= ut.BROADCAST_SUCCESS ? 1 : 0.5,
                  children: [
                    /* @__PURE__ */ y.jsx(
                      z,
                      {
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "center",
                        marginRight: "3",
                        className: wr({
                          [cv]: !0,
                          [dv]: !0,
                          [uv]: e.state < ut.CHECK_TX_STATUS_SUCCESS,
                          [hv]: e.state === ut.CHECK_TX_STATUS_LOADING || e.state === ut.CHECK_TX_STATUS_ERROR,
                          [fv]: e.state < ut.BROADCAST_SUCCESS
                        }),
                        children: /* @__PURE__ */ y.jsx(
                          z,
                          {
                            background: e.state >= ut.BROADCAST_SUCCESS ? "text" : "white",
                            borderColor: e.state >= ut.BROADCAST_SUCCESS ? "text" : "textMuted",
                            borderRadius: "half",
                            borderWidth: 3,
                            borderStyle: "solid",
                            hw: "10",
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            "data-rk": "tx-state-step-circle",
                            "data-state": e.state >= ut.BROADCAST_SUCCESS ? "success" : "pending",
                            children: e.state === ut.CHECK_TX_STATUS_LOADING ? /* @__PURE__ */ y.jsx(ei, { variant: { color: "inverted" } }) : e.state === ut.CHECK_TX_STATUS_ERROR ? /* @__PURE__ */ y.jsx(Il, { color: "background" }) : e.state >= ut.CHECK_TX_STATUS_SUCCESS ? /* @__PURE__ */ y.jsx(Eu, { hw: 18 }) : null
                          }
                        )
                      }
                    ),
                    /* @__PURE__ */ y.jsxs(
                      z,
                      {
                        flexDirection: "column",
                        display: "flex",
                        alignItems: "flex-start",
                        gap: "1",
                        marginTop: "6",
                        children: [
                          /* @__PURE__ */ y.jsx(ue, { children: r("steps.pending") }),
                          e.state === ut.CHECK_TX_STATUS_ERROR && /* @__PURE__ */ y.jsx(ue, { variant: { type: "danger" }, children: r("shared.something_went_wrong") })
                        ]
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ y.jsxs(
                z,
                {
                  display: "flex",
                  alignItems: "center",
                  opacity: e.state >= ut.CHECK_TX_STATUS_SUCCESS ? 1 : 0.5,
                  children: [
                    /* @__PURE__ */ y.jsx(
                      z,
                      {
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "center",
                        marginRight: "3",
                        paddingBottom: "2",
                        className: wr({
                          [dv]: !0,
                          [fv]: e.state < ut.CHECK_TX_STATUS_SUCCESS
                        }),
                        children: /* @__PURE__ */ y.jsx(
                          z,
                          {
                            background: e.state >= ut.CHECK_TX_STATUS_SUCCESS ? "text" : "white",
                            borderColor: e.state >= ut.CHECK_TX_STATUS_SUCCESS ? "text" : "textMuted",
                            borderWidth: 3,
                            borderStyle: "solid",
                            borderRadius: "half",
                            hw: "10",
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            "data-rk": "tx-state-step-circle",
                            "data-state": e.state >= ut.CHECK_TX_STATUS_SUCCESS ? "success" : "pending",
                            children: e.state >= ut.CHECK_TX_STATUS_SUCCESS && /* @__PURE__ */ y.jsx(Eu, { hw: 18 })
                          }
                        )
                      }
                    ),
                    /* @__PURE__ */ y.jsx(
                      z,
                      {
                        flexDirection: "column",
                        display: "flex",
                        alignItems: "flex-start",
                        gap: "1",
                        marginTop: "4",
                        children: /* @__PURE__ */ y.jsx(ue, { children: r("steps.completed") })
                      }
                    )
                  ]
                }
              )
            ] })
          ]
        }
      )
    },
    e.tx.id
  );
}, lm = ({ session: e, onSignSuccess: t }) => {
  const { retry: n, txStates: r } = vpe({
    session: e,
    onSignSuccess: t
  }), { t: i } = ze();
  return /* @__PURE__ */ y.jsx(ff, { children: /* @__PURE__ */ y.jsx(Zt.div, { layout: "position", children: /* @__PURE__ */ y.jsxs($s, { children: [
    /* @__PURE__ */ y.jsx(z, { marginBottom: "2", children: /* @__PURE__ */ y.jsx(to, { variant: { level: "h4" }, children: i("steps.title") }) }),
    /* @__PURE__ */ y.jsx(z, { flex: 1, display: "flex", children: /* @__PURE__ */ y.jsx(
      z,
      {
        background: "backgroundMuted",
        flexDirection: "column",
        display: "flex",
        px: "4",
        py: "4",
        borderRadius: "xl",
        flex: 1,
        children: r.map((o, s) => /* @__PURE__ */ y.jsx(
          _pe,
          {
            txState: o,
            position: Ipe(r.length, s),
            count: { current: s + 1, total: r.length }
          },
          s
        ))
      }
    ) }),
    n && /* @__PURE__ */ y.jsx(z, { my: "4", children: /* @__PURE__ */ y.jsx(si, { "data-rk": "footer-button-primary", onClick: n, children: i("shared.retry") }) })
  ] }) }) });
}, Ipe = (e, t) => e === 1 ? "SINGLE" : t === 0 ? "FIRST" : t === e - 1 ? "LAST" : "ELSE", Rpe = () => {
  Vn("activitySteps");
  const e = fr(
    vc(),
    (t) => t.context.selectedAction
  ).unsafeCoerce();
  return /* @__PURE__ */ y.jsx(lm, { session: e });
}, Ppe = () => {
  const e = fr(
    hf(),
    (t) => t.context.data
  ).unsafeCoerce();
  return Vn("pendingActionSteps"), /* @__PURE__ */ y.jsx(lm, { session: e.actionDto.unsafeCoerce() });
}, Ope = () => {
  const e = fr(
    bc(),
    (t) => t.context.data
  ).unsafeCoerce();
  return Vn("unstakeSteps"), /* @__PURE__ */ y.jsx(lm, { session: e.actionDto.unsafeCoerce() });
};
var pv = cA;
ke.env.NODE_ENV === "production" ? (pv.createRoot, pv.hydrateRoot) : pv.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
const Bpe = (e) => Ut({
  queryKey: ["region-codes"],
  enabled: !!e,
  staleTime: Number.POSITIVE_INFINITY,
  queryFn: async () => (await de.liftEither(
    G.fromNullable(e).toEither(
      new Error("missing regionCode")
    )
  ).chain(
    (t) => de(() => import("./region-iso-3166-codes-yudYFU1h.js")).mapLeft(() => new Error("Failed to load region-iso-3166-codes")).chain(
      (n) => de.liftEither(
        G.fromNullable(
          n.countries[t].subdivisionName
        ).toEither(new Error("region not found"))
      )
    )
  )).unsafeCoerce()
});
var Npe = "xzdlz11 xzdlz10 yv8y4rrb yv8y4rrc";
const Wr = (e) => /* @__PURE__ */ y.jsx(
  z,
  {
    className: Npe,
    as: "a",
    href: e.href ?? e.children ?? "",
    target: "_blank",
    children: e.children ?? e.href
  }
);
var Dpe = "mk05t70", jpe = "mk05t71";
const Mpe = ({ modal: e, customTrigger: t }) => {
  var f;
  const { t: n, i18n: r } = ze(), i = (h) => {
    switch (h.type) {
      case "geoBlock": {
        const p = n("help_modals.geo_block.title"), m = Vee({
          language: r.language,
          countryCode: h.countryCode
        });
        return h.tags.has("OFAC") && h.tags.has("OFSI") ? {
          title: p,
          description: /* @__PURE__ */ y.jsx(
            Wn,
            {
              i18nKey: "help_modals.geo_block.ofac_ofsi",
              values: { countryName: m },
              components: { link0: /* @__PURE__ */ y.jsx(Wr, {}) }
            }
          ),
          image: vr.fees
        } : h.tags.has("OFSI") && h.tags.has("Crypto Ban") ? {
          title: p,
          description: /* @__PURE__ */ y.jsx(
            Wn,
            {
              i18nKey: "help_modals.geo_block.ofsi_crypto_ban",
              values: { countryName: m },
              components: { link0: /* @__PURE__ */ y.jsx(Wr, {}) }
            }
          ),
          image: vr.fees
        } : h.tags.has("Crypto Ban") ? {
          title: p,
          description: /* @__PURE__ */ y.jsx(
            Wn,
            {
              i18nKey: "help_modals.geo_block.crypto_ban",
              values: { countryName: m },
              components: { link0: /* @__PURE__ */ y.jsx(Wr, {}) }
            }
          ),
          image: vr.fees
        } : h.tags.has("OFAC") ? {
          title: p,
          description: /* @__PURE__ */ y.jsx(
            Wn,
            {
              i18nKey: "help_modals.geo_block.ofac",
              values: { countryName: m },
              components: { link0: /* @__PURE__ */ y.jsx(Wr, {}) }
            }
          ),
          image: vr.fees
        } : h.tags.has("OFSI") ? {
          title: p,
          description: /* @__PURE__ */ y.jsx(
            Wn,
            {
              i18nKey: "help_modals.geo_block.ofsi",
              values: { countryName: m },
              components: { link0: /* @__PURE__ */ y.jsx(Wr, {}) }
            }
          ),
          image: vr.fees
        } : h.tags.has("Pending Litigation") ? {
          title: p,
          description: /* @__PURE__ */ y.jsx(
            Wn,
            {
              i18nKey: "help_modals.geo_block.pending_litigation",
              values: {
                countryName: m,
                nameOfRegion: h.regionCodeName ?? ""
              },
              components: { link0: /* @__PURE__ */ y.jsx(Wr, {}) }
            }
          ),
          image: vr.fees
        } : h.tags.has("Staking Ban") ? {
          title: p,
          description: /* @__PURE__ */ y.jsx(
            Wn,
            {
              i18nKey: "help_modals.geo_block.staking_ban",
              values: { countryName: m },
              components: { link0: /* @__PURE__ */ y.jsx(Wr, {}) }
            }
          ),
          image: vr.fees
        } : {
          title: p,
          description: /* @__PURE__ */ y.jsx(
            Wn,
            {
              i18nKey: "help_modals.geo_block.default",
              values: { countryName: m },
              components: { link0: /* @__PURE__ */ y.jsx(Wr, {}) }
            }
          ),
          image: vr.fees
        };
      }
      case "getInTouch":
        return {
          title: n("help_modals.get_in_touch.title"),
          button: {
            title: n("help_modals.get_in_touch.button"),
            onClick: () => Tn.ifJust(
              (p) => p.open("https://twitter.com/stakekit", "_blank")
            )
          },
          description: "",
          image: vr.whatIsLiquidStaking
        };
      case "whatIsStakeKit":
        return {
          title: n("help_modals.what_is_stakekit.title"),
          description: /* @__PURE__ */ y.jsx(
            Wn,
            {
              i18nKey: "help_modals.what_is_stakekit.description",
              components: {
                br0: /* @__PURE__ */ y.jsx("br", {}),
                link0: /* @__PURE__ */ y.jsx(Wr, { href: "https://www.stakek.it/" }),
                link1: /* @__PURE__ */ y.jsx(Wr, { href: "https://docs.stakek.it/docs/faqs" })
              }
            }
          ),
          image: vr.poweredBy
        };
    }
  }, o = (f = we(g1)) == null ? void 0 : f.trackEvent, { description: s, image: a, title: l, link: c, button: u } = i(e), d = J(() => {
    const h = {
      onOpen: () => o == null ? void 0 : o("helpModalOpened", { modal: l })
    };
    return e.type === "geoBlock" ? {
      ...h,
      state: {
        isOpen: !0,
        setOpen: e.onClose
      }
    } : {
      ...h,
      trigger: /* @__PURE__ */ y.jsx(mc, { asChild: !!t, children: t ?? /* @__PURE__ */ y.jsx(z, { display: "flex", alignItems: "center", justifyContent: "center", children: /* @__PURE__ */ y.jsx(qae, {}) }) })
    };
  }, [t, e, l, o]);
  return /* @__PURE__ */ y.jsx(qs, { ...d, children: /* @__PURE__ */ y.jsxs(
    z,
    {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center",
      paddingBottom: { mobile: "8" },
      className: jpe,
      children: [
        /* @__PURE__ */ y.jsx(z, { as: "img", src: a, className: Dpe }),
        /* @__PURE__ */ y.jsx(to, { variant: { level: "h4" }, children: l }),
        /* @__PURE__ */ y.jsx(z, { marginTop: "2", lineHeight: "short", children: /* @__PURE__ */ y.jsx(
          ue,
          {
            variant: { type: "muted", weight: "normal" },
            textAlign: "center",
            children: s
          }
        ) }),
        !!c && /* @__PURE__ */ y.jsx(Wr, { children: c }),
        u && /* @__PURE__ */ y.jsx(z, { marginTop: "4", width: "full", children: /* @__PURE__ */ y.jsx(si, { variant: { color: "secondary" }, onClick: u.onClick, children: /* @__PURE__ */ y.jsx(ue, { variant: { weight: "bold" }, children: u.title }) }) })
      ]
    }
  ) });
};
var Fpe = "tk2kcv1 tk2kcv0 yv8y4re3 yv8y4rcl yv8y4r9t yv8y4rbb yv8y4rpj yv8y4rvb yv8y4rvc yv8y4rx yv8y4rfj yv8y4rg1", Lpe = "tk2kcv3 tk2kcv2 yv8y4rt yv8y4r39 yv8y4ri yv8y4rqz yv8y4rr0 yv8y4raz", Upe = "tk2kcv4";
const yv = 6, zpe = () => {
  const e = am(), t = xpe(), [n, r] = Oe(
    () => Array.from({ length: 6 }).fill("")
  ), { t: i } = ze(), o = It(
    Array.from({ length: yv }).fill(null)
  ), s = !e.data && !e.isLoading && e.isError, a = J(
    () => t.isPending || n.some((h) => !h),
    [n, t.isPending]
  ), l = () => {
    a || t.mutate(n.join(""));
  }, c = (h, p) => {
    var g;
    const m = [...n];
    m[p] = h, dA(() => {
      r(m);
    }), h && ((g = o.current[p + 1]) == null || g.focus());
  }, u = (h) => r((p) => p.map((m, g) => g < h ? m : "")), d = (h, p) => {
    var g;
    const m = h.toLowerCase();
    m !== "backspace" && m !== "delete" || n[p] || (g = o.current[p - 1]) == null || g.focus();
  }, f = (h) => {
    r(h.slice(0, yv).split("")), lc.ifJust((p) => {
      const m = p.activeElement;
      m && "blur" in m && typeof m.blur == "function" && m.blur();
    });
  };
  return /* @__PURE__ */ y.jsx(qs, { state: { isOpen: s, setOpen: () => {
  } }, disableClose: !0, children: /* @__PURE__ */ y.jsxs(
    z,
    {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center",
      children: [
        /* @__PURE__ */ y.jsx(z, { marginBottom: "4", children: /* @__PURE__ */ y.jsx(ue, { variant: { size: "large" }, children: i("referral_lock.title") }) }),
        /* @__PURE__ */ y.jsxs(gc, { children: [
          /* @__PURE__ */ y.jsx(z, { children: /* @__PURE__ */ y.jsx(ue, { textAlign: "center", variant: { type: "muted" }, children: i("referral_lock.body") }) }),
          /* @__PURE__ */ y.jsx(z, { my: "4", children: /* @__PURE__ */ y.jsx(ti, {}) }),
          /* @__PURE__ */ y.jsx(z, { className: Fpe, children: Array.from({ length: yv }).map((h, p) => /* @__PURE__ */ y.jsx(z, { className: Lpe, children: /* @__PURE__ */ y.jsx(
            "input",
            {
              ref: (m) => {
                m && (o.current[p] = m);
              },
              autoFocus: p === 0,
              value: n[p],
              onPaste: (m) => f(m.clipboardData.getData("text")),
              onFocus: () => u(p),
              onChange: (m) => c(m.target.value, p),
              onKeyDown: (m) => d(m.key, p),
              className: Upe,
              type: "text",
              maxLength: 1,
              disabled: p > 0 && !n[p - 1]
            }
          ) }, p)) }),
          /* @__PURE__ */ y.jsx(z, { marginTop: "4", children: /* @__PURE__ */ y.jsx(
            si,
            {
              variant: { color: a ? "disabled" : "primary" },
              disabled: a,
              onClick: l,
              isLoading: t.isPending,
              children: i("referral_lock.submit")
            }
          ) })
        ] })
      ]
    }
  ) });
};
var Vpe = "_1ax7bim0";
const qpe = () => {
  const { t: e } = ze(), { error: t, resetError: n } = W7(), { message: r, details: i } = t ?? {};
  return /* @__PURE__ */ y.jsx(
    qs,
    {
      state: { isOpen: !!t, setOpen: () => n() },
      onClose: n,
      children: /* @__PURE__ */ y.jsxs(
        z,
        {
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          justifyContent: "center",
          paddingBottom: { mobile: "8" },
          px: "6",
          lineHeight: "sm",
          children: [
            /* @__PURE__ */ y.jsx(z, { as: "img", src: vr.whatIsLiquidStaking, className: Vpe }),
            !r && /* @__PURE__ */ y.jsx(z, { marginBottom: "6", children: /* @__PURE__ */ y.jsx(to, { variant: { level: "h4" }, children: e("shared.something_went_wrong") }) }),
            r && /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
              /* @__PURE__ */ y.jsxs(z, { textAlign: "center", children: [
                /* @__PURE__ */ y.jsx(to, { variant: { level: "h4" }, children: e(`errors.${r}.title`) }),
                /* @__PURE__ */ y.jsx(
                  ue,
                  {
                    variant: { type: "muted", weight: "normal" },
                    textAlign: "center",
                    children: e(`errors.${r}.details`, i)
                  }
                )
              ] }),
              /* @__PURE__ */ y.jsxs(z, { marginTop: "4", textAlign: "center", children: [
                /* @__PURE__ */ y.jsx(ue, { variant: { size: "large" }, children: e("error_modal.solution") }),
                /* @__PURE__ */ y.jsx(
                  z,
                  {
                    borderRadius: "md",
                    background: "backgroundMuted",
                    px: "4",
                    py: "1",
                    marginTop: "2",
                    children: /* @__PURE__ */ y.jsx(ue, { variant: { size: "medium" }, textAlign: "center", children: e(`errors.${r}.solution`) })
                  }
                )
              ] })
            ] })
          ]
        }
      )
    }
  );
}, $pe = () => {
  const e = S7(), t = Bpe(
    e ? e.regionCode : void 0
  ), [n, r] = Oe(!1), { referralCheck: i } = bt();
  return e && !n ? /* @__PURE__ */ y.jsx(
    Mpe,
    {
      modal: {
        type: "geoBlock",
        ...e,
        regionCodeName: t.data,
        onClose: () => r(!0)
      }
    }
  ) : /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    i && /* @__PURE__ */ y.jsx(zpe, {}),
    /* @__PURE__ */ y.jsx(qpe, {})
  ] });
}, wp = ({
  actionType: e,
  balanceType: t,
  token: n
}) => `${t}-${dr(n)}-${e}`, f3 = ({
  pendingActionsState: e,
  additionalAddresses: t,
  address: n,
  pendingActionDto: r,
  integration: i,
  yieldBalance: o,
  selectedValidators: s
}) => G.fromNullable(n).toEither(new Error("missing address")).map((a) => {
  var c, u, d, f, h, p, m, g, v;
  const l = {
    amount: G.fromPredicate(
      Boolean,
      (d = (u = (c = r.args) == null ? void 0 : c.args) == null ? void 0 : u.amount) == null ? void 0 : d.required
    ).chainNullable(
      () => e.get(
        wp({
          balanceType: o.type,
          token: o.token,
          actionType: r.type
        })
      )
    ).map((w) => w.toString()).alt(G.of(o.amount)).extract()
  };
  return s.length && ((p = (h = (f = r.args) == null ? void 0 : f.args) == null ? void 0 : h.validatorAddresses) != null && p.required ? l.validatorAddresses = s : (v = (g = (m = r.args) == null ? void 0 : m.args) == null ? void 0 : g.validatorAddress) != null && v.required && (l.validatorAddress = pt.head(s).orDefault(""))), {
    requestDto: {
      args: l,
      integrationId: i.id,
      passthrough: r.passthrough,
      type: r.type
    },
    address: a,
    additionalAddresses: t ?? void 0,
    gasFeeToken: i.metadata.gasFeeToken,
    integrationData: i
  };
}), h3 = () => {
  const { isLedgerLive: e, isConnected: t, address: n, connector: r, additionalAddresses: i } = wt(), o = ci(), s = h7(), a = Fs(), { externalProviders: l } = bt();
  return Ut({
    staleTime: Number.POSITIVE_INFINITY,
    gcTime: Number.POSITIVE_INFINITY,
    queryKey: ["pending-action-deep-link", e, n],
    enabled: !!(t && n && r),
    queryFn: async () => (await de.liftEither(
      G.fromNullable(n).toEither(
        new Error("missing wagmi config")
      )
    ).chain(
      (c) => Wpe({
        isLedgerLive: e,
        additionalAddresses: i,
        address: c,
        queryClient: o,
        yieldGetSingleYieldBalances: s,
        yieldYieldOpportunity: a,
        externalProviders: l
      })
    )).unsafeCoerce()
  });
}, Wpe = ({
  isLedgerLive: e,
  additionalAddresses: t,
  address: n,
  queryClient: r,
  yieldGetSingleYieldBalances: i,
  yieldYieldOpportunity: o,
  externalProviders: s
}) => _y({
  isLedgerLive: e,
  queryClient: r,
  yieldYieldOpportunity: o,
  externalProviders: s
}).chain((a) => {
  const l = G.of(a).filter(
    (c) => !!c.yieldId && !!c.pendingaction
  ).toEither(new Error("missing yieldId or pendingaction"));
  return l.isLeft() ? de.liftEither(_e(null)) : de.liftEither(l).chain(
    (c) => Kn({
      fn: () => i(c.yieldId, {
        addresses: {
          address: n,
          additionalAddresses: t ?? void 0
        }
      })
    }).mapLeft(() => new Error("could not get yield balances")).map((u) => ({
      yieldId: c.yieldId,
      pendingaction: c.pendingaction,
      validatorAddress: c.validator,
      singleYieldBalances: u,
      address: n,
      additionalAddresses: t ?? void 0
    }))
  ).chain(
    (c) => de.liftEither(
      _e(c.singleYieldBalances).chain((u) => {
        for (const d of u) {
          if (c.validatorAddress && d.validatorAddress !== c.validatorAddress)
            continue;
          const f = d.pendingActions.find(
            (h) => h.type === c.pendingaction
          );
          if (f)
            return _e({
              pendingAction: f,
              balance: d,
              balanceId: d.groupId ?? "default"
            });
        }
        return Xe(new Error("no pending action found"));
      })
    ).chain(
      (u) => Ty({
        isLedgerLive: e,
        yieldId: c.yieldId,
        queryClient: r,
        yieldYieldOpportunity: o
      }).map((d) => ({ ...u, yieldOp: d }))
    ).chain(
      (u) => Wb(u.pendingAction) || Gb(u.pendingAction) ? de.liftEither(
        _e({ type: "positionDetails", ...u })
      ) : de.liftEither(
        f3({
          // TODO: fix this
          pendingActionsState: /* @__PURE__ */ new Map(),
          address: c.address,
          additionalAddresses: c.additionalAddresses ?? null,
          integration: u.yieldOp,
          yieldBalance: u.balance,
          pendingActionDto: u.pendingAction,
          selectedValidators: []
        })
      ).map((d) => ({
        yieldOp: u.yieldOp,
        pendingActionDto: d,
        type: "review",
        balanceId: u.balanceId,
        balance: u.balance
      }))
    )
  );
}), Gpe = () => {
  const e = h3(), t = Dt(er()), n = hf(), r = F9(), { mountAnimationFinished: i } = qo(), { isConnected: o } = wt(), s = i && o;
  Te(() => {
    r.filter(
      (a) => !!(a.yieldId && a.balanceId && !a.pendingaction && s)
    ).ifJust(
      (a) => t.current(`positions/${a.yieldId}/${a.balanceId}`)
    );
  }, [r, t, s]), Te(() => {
    G.fromNullable(e.data).filter(
      (a) => s && a.type === "positionDetails"
    ).ifJust(
      (a) => t.current(
        `positions/${a.yieldOp.id}/${a.balanceId}/select-validator/${a.pendingAction.type}`
      )
    );
  }, [t, e.data, s]), Te(() => {
    G.fromNullable(e.data).filter(
      (a) => s && a.type === "review"
    ).ifJust((a) => {
      n.send({
        type: "initFlow",
        data: {
          requestDto: a.pendingActionDto.requestDto,
          addresses: {
            address: a.pendingActionDto.address,
            additionalAddresses: a.pendingActionDto.additionalAddresses
          },
          gasFeeToken: a.pendingActionDto.gasFeeToken,
          integrationData: a.pendingActionDto.integrationData,
          interactedToken: a.balance.token,
          pendingActionType: a.pendingActionDto.requestDto.type
        }
      }), t.current(
        `positions/${a.yieldOp.id}/${a.balanceId}/pending-action/review`
      );
    });
  }, [
    n,
    e.data,
    s,
    t
  ]);
}, Hpe = () => {
  const { isConnected: e } = wt();
  return e ? /* @__PURE__ */ y.jsx(nx, {}) : /* @__PURE__ */ y.jsx(UO, { to: "/", replace: !0 });
}, Kpe = Zy(
  { data: G.empty() },
  {
    initFlow: (e, t) => ({
      data: G.of({ ...t.data, actionDto: G.empty() })
    }),
    setActionDto: (e, t) => ({
      data: e.data.map((n) => ({
        ...n,
        actionDto: G.of(t.data)
      }))
    })
  }
), p3 = Ge(
  void 0
), Ype = ({ children: e }) => /* @__PURE__ */ y.jsx(p3.Provider, { value: Kpe, children: e }), cm = () => {
  const e = we(p3);
  if (!e)
    throw new Error(
      "useEnterStakeStore must be used within a EnterStakeStoreProvider"
    );
  return e;
}, Qpe = () => {
  Vn("stakeComplete");
  const e = fr(
    cm(),
    (l) => l.context.data
  ).unsafeCoerce(), t = J(
    () => G.of(e.selectedStake),
    [e.selectedStake]
  ), n = J(
    () => G.of(e.selectedToken),
    [e.selectedToken]
  ), r = t.map((l) => l.metadata), i = n.mapOrDefault((l) => l.symbol, ""), o = J(
    () => Sn(new Re(e.requestDto.args.amount)),
    [e.requestDto.args.amount]
  ), s = _s(t).map((l) => l.type), a = Uo({
    integrationData: t,
    validatorsAddresses: G.of(e.selectedValidators)
  });
  return /* @__PURE__ */ y.jsx(
    Xy,
    {
      yieldType: s,
      providersDetails: a,
      token: n,
      metadata: r,
      network: i,
      amount: o
    }
  );
}, y3 = () => {
  const e = bt(), { connectorChains: t, connector: n, chain: r } = wt(), i = J(
    () => t.map((a) => a.id),
    [t]
  ), o = n == null ? void 0 : n.switchChain, s = Ie((a) => o == null ? void 0 : o({ chainId: a }), [o]);
  return e.variant !== "zerion" || !o || !n ? null : G.fromNullable(
    e.chainModal({
      chainIds: i,
      selectedChainId: r.id,
      onSwitchChain: s
    })
  ).map((a) => /* @__PURE__ */ y.jsx(z, { minHeight: "8", "data-rk": "chain-modal", children: a })).extractNullable();
}, Jpe = (e) => {
  const t = Ay(e.integrationId), n = J(
    () => G.fromNullable(t.data),
    [t.data]
  ), r = Uo({
    integrationData: n,
    validatorsAddresses: G.of(
      e.type === "validators" ? e.validatorsAddresses : []
    )
  }), i = J(
    () => G.fromRecord({ providersDetails: r, integrationData: n }).map((s) => ({
      ...s,
      rewardRateAverage: s.providersDetails.reduce(
        (a, l) => a.plus(new Re(l.rewardRate || 0)),
        new Re(0)
      ).dividedBy(s.providersDetails.length)
    })).map(
      (s) => xs({
        rewardRate: s.rewardRateAverage.toNumber(),
        rewardType: s.integrationData.rewardType
      })
    ),
    [n, r]
  ), o = J(
    () => r.chain((s) => pt.find((a) => a.status !== "active", s)).chainNullable((s) => s.status).map((s) => s).extractNullable(),
    [r]
  );
  return {
    integrationData: n,
    providersDetails: r,
    rewardRateAverage: i,
    inactiveValidator: o
  };
};
var Xpe = "_1dulflp0";
const Zpe = ({ children: e, ...t }) => /* @__PURE__ */ y.jsx(ox, { className: Xpe, ...t, children: e }), um = () => /* @__PURE__ */ y.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "none", children: /* @__PURE__ */ y.jsx(
  "path",
  {
    fill: "#45D65C",
    d: "M14.116 6.426c-.235-.246-.48-.5-.571-.723-.085-.204-.09-.543-.095-.871-.01-.61-.02-1.301-.5-1.782-.48-.48-1.172-.49-1.782-.5-.328-.005-.667-.01-.871-.095-.223-.092-.477-.336-.723-.571C9.143 1.469 8.653 1 8 1c-.652 0-1.142.47-1.574.884-.246.235-.5.48-.723.571-.203.085-.543.09-.871.095-.61.01-1.301.02-1.782.5-.48.48-.487 1.172-.5 1.782-.005.328-.01.667-.095.871-.092.223-.336.477-.571.723C1.469 6.857 1 7.347 1 8c0 .652.47 1.142.884 1.574.235.246.48.5.571.723.085.204.09.543.095.871.01.61.02 1.301.5 1.782.48.48 1.172.49 1.782.5.328.005.667.01.871.095.223.092.477.336.723.571.431.415.921.884 1.574.884.652 0 1.142-.47 1.574-.884.246-.235.5-.48.723-.571.204-.085.543-.09.871-.095.61-.01 1.301-.02 1.782-.5.48-.48.49-1.172.5-1.782.005-.328.01-.667.095-.871.092-.223.336-.477.571-.723C14.531 9.143 15 8.653 15 8c0-.652-.47-1.142-.884-1.574Zm-3.262.428-3.5 3.5a.502.502 0 0 1-.708 0l-1.5-1.5a.5.5 0 1 1 .708-.708L7 9.293l3.146-3.147a.501.501 0 0 1 .708.708Z"
  }
) });
var eye = "gsuntr0", LS = "gsuntr1", tye = "gsuntr2", O0 = "gsuntr3", nye = "gsuntr5 gsuntr4 yv8y4rpj";
const rye = ({
  foundValidatorsData: e,
  onValidatorAddressOrNameChange: t,
  errorMessage: n,
  isLoading: r,
  onClose: i,
  onImportValidatorImport: o
}) => {
  const { t: s } = ze(), a = It(null), [l, c] = Oe(""), u = cn();
  return /* @__PURE__ */ y.jsx(
    qs,
    {
      title: s("positions.import_validator_modal_title"),
      searchValue: l,
      onSearch: (d) => {
        c(d), t(d);
      },
      onOpen: () => u("importValidatorModalOpened"),
      errorMessage: n,
      isLoading: r,
      onClose: () => {
        c(""), i == null || i();
      },
      trigger: /* @__PURE__ */ y.jsx(mc, { asChild: !0, children: /* @__PURE__ */ y.jsx(z, { children: /* @__PURE__ */ y.jsx(si, { variant: { size: "small", color: "smallButton" }, children: /* @__PURE__ */ y.jsx(ue, { children: s("positions.import_button") }) }) }) }),
      children: e.map((d) => /* @__PURE__ */ y.jsxs(z, { className: tye, children: [
        !l && /* @__PURE__ */ y.jsx(z, { marginTop: "2", children: /* @__PURE__ */ y.jsx(gc, { children: /* @__PURE__ */ y.jsx(ue, { children: s("positions.search_for_validators") }) }) }),
        /* @__PURE__ */ y.jsx(
          vx,
          {
            data: d,
            estimateSize: () => 60,
            itemContent: (f, h) => /* @__PURE__ */ y.jsx(gc, { children: /* @__PURE__ */ y.jsxs(Jy, { children: [
              /* @__PURE__ */ y.jsxs(z, { display: "flex", gap: "2", minWidth: "0", marginRight: "4", children: [
                /* @__PURE__ */ y.jsx(z, { children: /* @__PURE__ */ y.jsx(
                  Ii,
                  {
                    containerProps: { hw: "9" },
                    imageProps: { borderRadius: "full" },
                    src: h.validator.image,
                    fallback: /* @__PURE__ */ y.jsx(
                      Vo,
                      {
                        name: h.validator.name || h.validator.address,
                        tokenLogoHw: "9"
                      }
                    )
                  }
                ) }),
                /* @__PURE__ */ y.jsxs(z, { display: "flex", flexDirection: "column", minWidth: "0", children: [
                  /* @__PURE__ */ y.jsxs(z, { display: "flex", alignItems: "center", children: [
                    /* @__PURE__ */ y.jsx(
                      ue,
                      {
                        className: wr([
                          eye,
                          LS
                        ]),
                        variant: { weight: "bold" },
                        children: h.validator.name
                      }
                    ),
                    h.validator.preferred && /* @__PURE__ */ y.jsx(z, { marginLeft: "1", display: "flex", children: /* @__PURE__ */ y.jsx(um, {}) })
                  ] }),
                  h.validator.name !== h.validator.address && /* @__PURE__ */ y.jsx(
                    ue,
                    {
                      variant: { weight: "normal" },
                      className: LS,
                      children: h.validator.address
                    }
                  )
                ] })
              ] }),
              /* @__PURE__ */ y.jsx(
                z,
                {
                  display: "flex",
                  justifyContent: "center",
                  alignItems: "flex-end",
                  textAlign: "right",
                  children: h.validator.preferred ? /* @__PURE__ */ y.jsx(ue, { children: s("positions.import_validator_already_imported") }) : /* @__PURE__ */ y.jsx(
                    si,
                    {
                      variant: { size: "small", color: "smallButton" },
                      onClick: () => {
                        var p;
                        o(h), (p = a.current) == null || p.close();
                      },
                      children: /* @__PURE__ */ y.jsx(ue, { children: s("positions.import_button") })
                    }
                  )
                }
              )
            ] }) })
          }
        )
      ] })).extractNullable()
    }
  );
}, iye = Td(
  ({
    item: e
  }) => {
    const { t } = ze(), {
      integrationData: n,
      providersDetails: r,
      inactiveValidator: i,
      rewardRateAverage: o
    } = Jpe(e);
    return /* @__PURE__ */ y.jsx(
      Zpe,
      {
        relative: "path",
        to: `../positions/${e.integrationId}/${e.balanceId}`,
        children: /* @__PURE__ */ y.jsx(z, { py: "1", children: n.mapOrDefault(
          (s) => /* @__PURE__ */ y.jsxs(Qy, { className: nye, children: [
            /* @__PURE__ */ y.jsxs(
              z,
              {
                display: "flex",
                width: "full",
                justifyContent: "space-between",
                gap: "2",
                children: [
                  /* @__PURE__ */ y.jsxs(
                    z,
                    {
                      display: "flex",
                      justifyContent: "flex-start",
                      alignItems: "center",
                      children: [
                        e.token.mapOrDefault(
                          (a) => /* @__PURE__ */ y.jsx(No, { metadata: s.metadata, token: a }),
                          /* @__PURE__ */ y.jsx(z, { display: "flex", marginRight: "2", children: /* @__PURE__ */ y.jsx(ei, {}) })
                        ),
                        /* @__PURE__ */ y.jsxs(
                          z,
                          {
                            display: "flex",
                            flexDirection: "column",
                            justifyContent: "center",
                            alignItems: "flex-start",
                            gap: "1",
                            children: [
                              /* @__PURE__ */ y.jsxs(z, { className: Kue, children: [
                                e.token.map((a) => /* @__PURE__ */ y.jsx(ue, { children: a.symbol })).extractNullable(),
                                e.yieldLabelDto.map((a) => /* @__PURE__ */ y.jsx(
                                  wd,
                                  {
                                    textAlign: "left",
                                    maxWidth: 300,
                                    label: t(
                                      `position_details.labels.${a.type}.details`,
                                      a.params
                                    ),
                                    children: /* @__PURE__ */ y.jsx(
                                      z,
                                      {
                                        className: w0({
                                          type: "actionRequired"
                                        }),
                                        children: /* @__PURE__ */ y.jsx(
                                          ue,
                                          {
                                            variant: { type: "white" },
                                            className: O0,
                                            children: t(
                                              `position_details.labels.${a.type}.label`
                                            )
                                          }
                                        )
                                      }
                                    )
                                  }
                                )).extractNullable(),
                                (e.actionRequired || e.hasPendingClaimRewards || i) && /* @__PURE__ */ y.jsx(
                                  z,
                                  {
                                    className: w0({
                                      type: e.actionRequired || i ? "actionRequired" : "claim"
                                    }),
                                    children: /* @__PURE__ */ y.jsx(
                                      ue,
                                      {
                                        variant: { type: "white" },
                                        className: O0,
                                        children: t(
                                          e.actionRequired ? "positions.action_required" : i ? i === "jailed" ? "details.validators_jailed" : "details.validators_inactive" : "positions.claim_rewards"
                                        )
                                      }
                                    )
                                  }
                                )
                              ] }),
                              r.chain(
                                (a) => pt.head(a).map((l) => /* @__PURE__ */ y.jsx(
                                  ue,
                                  {
                                    className: Yue,
                                    variant: {
                                      type: "muted",
                                      weight: "normal"
                                    },
                                    children: t("positions.via", {
                                      providerName: l.name ?? l.address,
                                      count: Math.max(a.length - 1, 1)
                                    })
                                  }
                                ))
                              ).extractNullable()
                            ]
                          }
                        )
                      ]
                    }
                  ),
                  G.fromRecord({
                    token: e.token,
                    rewardRateAverage: o
                  }).map((a) => /* @__PURE__ */ y.jsxs(
                    z,
                    {
                      display: "flex",
                      justifyContent: "center",
                      alignItems: "flex-end",
                      flexDirection: "column",
                      textAlign: "end",
                      gap: "1",
                      children: [
                        /* @__PURE__ */ y.jsx(ue, { variant: { weight: "normal" }, children: e.actionRequired ? " " : a.rewardRateAverage }),
                        /* @__PURE__ */ y.jsxs(
                          ue,
                          {
                            overflowWrap: "anywhere",
                            variant: { weight: "normal", type: "muted" },
                            children: [
                              e.amount,
                              " ",
                              a.token.symbol
                            ]
                          }
                        )
                      ]
                    }
                  )).extractNullable()
                ]
              }
            ),
            e.pointsRewardTokenBalance.map((a) => /* @__PURE__ */ y.jsxs(
              z,
              {
                alignSelf: "flex-end",
                background: "background",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                borderRadius: "lg",
                px: "2",
                py: "1",
                gap: "1",
                children: [
                  /* @__PURE__ */ y.jsx(
                    No,
                    {
                      token: a.token,
                      hideNetwork: !0,
                      tokenLogoHw: "5"
                    }
                  ),
                  /* @__PURE__ */ y.jsx(
                    ue,
                    {
                      overflowWrap: "anywhere",
                      variant: { type: "muted", weight: "normal" },
                      children: a.amount
                    }
                  )
                ]
              }
            )).extractNullable()
          ] }),
          /* @__PURE__ */ y.jsx($o, { heightPx: 60 })
        ) })
      }
    );
  }
), oye = ({
  importValidators: e
}) => {
  const { t } = ze();
  return /* @__PURE__ */ y.jsx(z, { py: "1", children: /* @__PURE__ */ y.jsx(Qy, { variant: { hover: "disabled" }, children: /* @__PURE__ */ y.jsxs(
    z,
    {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      gap: "2",
      children: [
        /* @__PURE__ */ y.jsxs(z, { display: "flex", flexDirection: "column", gap: "2", flex: 2, children: [
          /* @__PURE__ */ y.jsx(ue, { variant: { weight: "bold" }, children: t("positions.dont_see_position") }),
          /* @__PURE__ */ y.jsx(ue, { variant: { weight: "normal", type: "muted" }, children: t("positions.import_validator") })
        ] }),
        /* @__PURE__ */ y.jsx(
          z,
          {
            flex: 1,
            display: "flex",
            justifyContent: "flex-end",
            alignItems: "center",
            children: /* @__PURE__ */ y.jsx(rye, { ...e })
          }
        )
      ]
    }
  ) }) });
}, m3 = ({
  address: e,
  network: t,
  validatorData: n
}) => Sy("sk-widget@1//customValidators").chain(
  (r) => r ? _e(r) : Xe(new Error("No custom validators"))
).caseOf({
  Right: (r) => {
    const i = G.fromNullable(r[t]).chain((s) => G.fromNullable(s[e])).map((s) => new Map(s.map((a) => [a.integrationId, a]))).orDefault(/* @__PURE__ */ new Map()), o = i.get(n.integrationId);
    return i.set(
      n.integrationId,
      o ? {
        ...o,
        validatorAddresses: [
          ...o.validatorAddresses,
          n.validator.address
        ]
      } : {
        integrationId: n.integrationId,
        validatorAddresses: [n.validator.address]
      }
    ), np("sk-widget@1//customValidators", {
      ...r,
      [t]: {
        ...r[t],
        [e]: [...i.values()]
      }
    });
  },
  Left: () => np("sk-widget@1//customValidators", {
    [t]: {
      [e]: [
        {
          integrationId: n.integrationId,
          validatorAddresses: [n.validator.address]
        }
      ]
    }
  })
}), g3 = () => {
  const { variant: e } = bt(), t = yx(), n = J(
    () => sye({
      positionsData: t.data,
      variant: e
    }),
    [t.data, e]
  ), r = { ...t, data: n }, { network: i, address: o, isConnected: s } = wt(), [a, l] = Oe(""), c = sh(
    a
  ), u = (x) => {
    l(x);
  }, d = f7(
    { query: c, network: i ?? void 0 },
    { query: { enabled: c.length >= 2 } }
  ), f = G.fromNullable(d.data).alt(G.of([])).map(
    (x) => x.reduce(
      (C, S) => (S.validators.forEach((k) => {
        C.push({
          integrationId: S.integrationId,
          validator: k
        });
      }), C),
      new Array()
    )
  ), { t: h } = ze(), p = cn(), m = (x) => {
    G.fromRecord({
      network: G.fromNullable(i),
      address: G.fromNullable(o)
    }).ifJust((C) => {
      m3({ ...C, validatorData: x }), p("validatorImported", {
        yieldId: x.integrationId,
        name: x.validator.name,
        address: x.validator.address
      });
    });
  }, g = {
    foundValidatorsData: f,
    onValidatorAddressOrNameChange: u,
    isLoading: d.isLoading,
    errorMessage: d.error ? h("shared.something_went_wrong") : void 0,
    onClose: () => l(""),
    onImportValidatorImport: m
  }, v = s && (!!r.data.length || !r.isLoading && !r.isError), w = J(
    () => ["header", ...r.data],
    [r.data]
  );
  return {
    positionsData: r,
    listData: w,
    importValidators: g,
    showPositions: v
  };
}, sye = zc(
  (e) => e.positionsData,
  (e) => e.variant,
  (e, t) => Je([...e.values()]).map(
    (n) => n.reduce(
      (r, i) => ([...i.balanceData.entries()].forEach(([o, s]) => {
        Je(
          s.balances.filter(
            (a) => Je(new Re(a.amount)).filter((l) => !l.isZero() && !l.isNaN()).isJust()
          )
        ).filter((a) => !!a.length).ifJust(
          (a) => r.push({
            ...s,
            integrationId: i.integrationId,
            balancesWithAmount: a,
            balanceId: o,
            allBalances: s.balances,
            yieldLabelDto: pt.find(
              (l) => !!l.label,
              s.balances
            ).chainNullable((l) => l.label),
            token: pt.head(
              pt.sort(
                (l, c) => XF(US[l.type], US[c.type]),
                s.balances
              )
            ).map((l) => l.token),
            actionRequired: a.some(
              (l) => l.type === "locked" || l.type === "unstaked"
            ),
            amount: Je(
              a.reduce((l, c) => c.token.isPoints ? l : new Re(c.amount).plus(l), new Re(0))
            ).map(Xn).unsafeCoerce(),
            pointsRewardTokenBalance: pt.find(
              (l) => !!l.token.isPoints,
              a
            ).map((l) => ({
              ...l,
              amount: Xn(l.amount)
            })),
            hasPendingClaimRewards: pt.find(
              (l) => l.type === "rewards",
              a
            ).chain(
              (l) => pt.find(
                (c) => c.type === "CLAIM_REWARDS",
                l.pendingActions
              )
            ).isJust()
          })
        );
      }), r),
      []
    )
  ).map(
    (n) => t === "zerion" ? n.toSorted((r, i) => r.hasPendingClaimRewards ? -1 : i.hasPendingClaimRewards ? 1 : Re(i.amount).minus(Re(r.amount)).toNumber()) : n
  ).unsafeCoerce()
), US = {
  available: 1,
  staked: 2,
  unstaking: 3,
  unstaked: 4,
  preparing: 5,
  locked: 6,
  unlocking: 7,
  rewards: 8
}, aye = () => {
  Vn("positions");
  const { positionsData: e, listData: t, importValidators: n, showPositions: r } = g3(), { isConnected: i, isConnecting: o } = wt(), s = J(() => e.isLoading && e.isFetching && i ? /* @__PURE__ */ y.jsx(Cl, { type: "spinner" }) : !i && !o ? /* @__PURE__ */ y.jsx(Cl, { type: "not_connected" }) : e.isError && !e.data.length ? /* @__PURE__ */ y.jsx(Cl, { type: "something_wrong" }) : null, [
    i,
    o,
    e.data.length,
    e.isError,
    e.isFetching,
    e.isLoading
  ]), { mountAnimationFinished: a } = qo();
  return /* @__PURE__ */ y.jsx(
    Zt.div,
    {
      initial: { opacity: 0, translateY: "-10px" },
      animate: { opacity: 1, translateY: 0 },
      transition: {
        duration: a ? 0.3 : 1,
        delay: a ? 0 : 1.5
      },
      children: /* @__PURE__ */ y.jsx($s, { children: /* @__PURE__ */ y.jsxs(
        z,
        {
          className: Que,
          display: "flex",
          flex: 1,
          flexDirection: "column",
          children: [
            s,
            r && /* @__PURE__ */ y.jsx(z, { flex: 1, display: "flex", flexDirection: "column", children: /* @__PURE__ */ y.jsx(
              vx,
              {
                estimateSize: () => 60,
                data: t,
                itemContent: (l, c) => c === "header" ? /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
                  /* @__PURE__ */ y.jsx(y3, {}),
                  /* @__PURE__ */ y.jsx(
                    oye,
                    {
                      importValidators: n
                    }
                  ),
                  i && !e.data.length && /* @__PURE__ */ y.jsx(z, { my: "4", children: /* @__PURE__ */ y.jsx(Cl, { type: "no_current_positions" }) })
                ] }) : /* @__PURE__ */ y.jsx(iye, { item: c })
              }
            ) })
          ]
        }
      ) })
    }
  );
}, lye = (e, t) => () => {
  let n = 0;
  const r = new Array(e.length), i = (o, s) => {
    if (r[s] = o, n < e.length) {
      const a = n++;
      return e[a]().chain((l) => i(l, a));
    }
    return de.liftEither(_e(null));
  };
  return de.all(
    Array.from({ length: Math.min(t, e.length) }).map(() => {
      const o = n++;
      return e[o]().chain((s) => i(s, o));
    })
  ).map(() => r);
}, Hx = (e) => [
  "multi-yields",
  e
], cye = ({
  queryClient: e,
  yieldIds: t
}) => G.fromNullable(
  e.getQueryData(Hx(t))
), v3 = (e, t) => {
  const { network: n, isConnected: r, isLedgerLive: i } = wt(), o = ci(), s = Fs();
  return Ut({
    queryKey: Hx(e),
    enabled: !!e.length,
    staleTime: Vt.queryClient.cacheTime,
    select: t == null ? void 0 : t.select,
    queryFn: async () => (await w3({
      isConnected: r,
      isLedgerLive: i,
      network: n,
      queryClient: o,
      yieldIds: e,
      yieldYieldOpportunity: s
    })).unsafeCoerce()
  });
}, b3 = (e) => de(
  () => e.queryClient.fetchQuery({
    queryKey: Hx(e.yieldIds),
    queryFn: async () => (await w3(e)).unsafeCoerce()
  })
).mapLeft((t) => new Error("could not get multi yields")), w3 = ({
  yieldIds: e,
  isLedgerLive: t,
  queryClient: n,
  isConnected: r,
  network: i,
  yieldYieldOpportunity: o
}) => lye(
  e.map(
    (s) => () => Ty({
      isLedgerLive: t,
      yieldId: s,
      queryClient: n,
      yieldYieldOpportunity: o
    }).chainLeft(async () => _e(null))
  ),
  5
)().map((s) => s.filter((a) => !!a)).map(
  (s) => pye({ data: s, isConnected: r, network: i, isLedgerLive: t })
).ifRight((s) => {
  s.forEach(
    (a) => Lee({
      isLedgerLive: t,
      yieldDto: a,
      queryClient: n
    })
  );
}), uye = ({
  o: e,
  isConnected: t,
  network: n
}) => {
  var i;
  const r = !((i = e.args.enter.args) != null && i.nfts) && e.id !== "binance-bnb-native-staking" && e.id !== "binance-testnet-bnb-native-staking" && e.id !== "avax-native-staking" && e.status.enter && aT(e.token.network);
  return t ? n === e.token.network && r : r;
}, dye = (e) => e.data, fye = (e) => e.isConnected, hye = (e) => e.network, pye = zc(
  dye,
  fye,
  hye,
  (e, t, n) => e.filter((r) => uye({ o: r, isConnected: t, network: n }))
), yye = (e) => new Re(e.amount).isGreaterThan(0), B0 = (e) => !!e.availableYields.length, mye = (e) => B0(e) && yye(e), gye = (e) => (
  /**
   * TB based on query params
   */
  e.initQueryParams.filter((t) => !!t.token).chain(
    (t) => pt.find(
      (n) => n.token.symbol === t.token && n.token.network === t.network || dr(n.token) === t.token,
      [...e.tokenBalances, ...e.defaultTokens]
    )
  ).altLazy(() => pt.find(mye, e.tokenBalances)).altLazy(() => pt.find(B0, e.tokenBalances)).altLazy(() => pt.find(B0, e.defaultTokens)).map((t) => t.token)
), zS = {
  staking: 1,
  restaking: 2,
  "liquid-staking": 3,
  vault: 4,
  lending: 5
}, x3 = (e) => {
  const t = e.yieldDtos.toSorted(
    (n, r) => zS[n.metadata.type] - zS[r.metadata.type] || xp(r).minus(xp(n)).toNumber()
  );
  return e.initQueryParams.filter((n) => !!n.yieldId).chain((n) => pt.find((r) => n.yieldId === r.id, t)).altLazy(
    () => pt.find(
      (n) => vye({
        tokenBalanceAmount: e.tokenBalanceAmount,
        yieldDto: n
      }),
      t
    )
  ).altLazy(() => pt.head(t));
}, vye = ({
  tokenBalanceAmount: e,
  yieldDto: t
}) => e.isGreaterThanOrEqualTo(xp(t)), xp = (e) => {
  var t, n;
  return new Re(((n = (t = e.args.enter.args) == null ? void 0 : t.amount) == null ? void 0 : n.minimum) ?? 0);
}, bye = (e) => e.initQueryParams.chainNullable((t) => t.validator).chain(
  (t) => pt.find(
    (n) => n.name === t || n.address === t,
    e.yieldDto.validators
  )
).altLazy(() => pt.head(e.yieldDto.validators)).map((t) => /* @__PURE__ */ new Map([[t.address, t]])).orDefault(/* @__PURE__ */ new Map()), Ac = (e) => e.minimum === -1 && e.maximum === -1, Kx = ({
  type: e,
  integration: t
}) => t.chainNullable(
  (n) => {
    var r, i, o;
    return e === "enter" ? (r = n.args.enter.args) == null ? void 0 : r.amount : (o = (i = n.args.exit) == null ? void 0 : i.args) == null ? void 0 : o.amount;
  }
).map(Ac).orDefault(!1), C3 = ({
  type: e,
  yieldOpportunity: t,
  availableAmount: n,
  positionsData: r
}) => {
  const i = Kx({
    type: e,
    integration: t
  }), o = J(() => (i ? n : t.chainNullable((c) => {
    var u, d, f;
    return e === "enter" && dZ(c.id, r) ? new Re(0) : (f = (d = (u = e === "enter" ? c.args.enter : c.args.exit) == null ? void 0 : u.args) == null ? void 0 : d.amount) == null ? void 0 : f.minimum;
  }).map((c) => new Re(c))).orDefault(new Re(0)), [n, i, e, t, r]), s = J(() => (i ? n : t.chainNullable(
    (c) => {
      var u, d, f;
      return (f = (d = (u = e === "enter" ? c.args.enter : c.args.exit) == null ? void 0 : u.args) == null ? void 0 : d.amount) == null ? void 0 : f.maximum;
    }
  ).map((c) => new Re(c))).orDefault(new Re(Number.POSITIVE_INFINITY)), [n, i, e, t]), a = J(
    () => WX({
      availableAmount: n.orDefault(new Re(0)),
      gasEstimateTotal: new Re(0),
      integrationMaxLimit: s
    }),
    [s, n]
  ), l = o;
  return J(
    () => ({
      minEnterOrExitAmount: l,
      maxEnterOrExitAmount: a,
      maxIntegrationAmount: s
    }),
    [a, l, s]
  );
}, wye = ({
  availableAmount: e,
  stakeAmount: t,
  maxEnterOrExitAmount: n,
  minEnterOrExitAmount: r
}) => {
  const i = J(
    () => e.map(() => t.isLessThan(r)).orDefault(!1),
    [e, t, r]
  ), o = J(
    () => e.map(() => t.isGreaterThan(n)).orDefault(!1),
    [e, t, n]
  ), s = J(
    () => e.map(() => t.isZero()).orDefault(!1),
    [t, e]
  ), a = J(
    () => e.map((l) => t.isGreaterThan(l)).orDefault(!1),
    [e, t]
  );
  return {
    stakeAmountLessThanMin: i,
    stakeAmountGreaterThanMax: o,
    stakeAmountGreaterThanAvailableAmount: a,
    stakeAmountIsZero: s
  };
}, k3 = () => {
  const { network: e } = wt(), t = Z0();
  return Ut({
    queryKey: P2({ network: e ?? void 0 }),
    queryFn: async () => (await E3({ network: e, tokenGetTokens: t })).unsafeCoerce(),
    staleTime: 1e3 * 60 * 5
  });
}, xye = (e) => de(
  () => e.queryClient.fetchQuery({
    queryKey: P2({
      network: e.network ?? void 0
    }),
    queryFn: async () => (await E3(e)).unsafeCoerce()
  })
).mapLeft((t) => new Error("could not get multi yields")), E3 = ({
  network: e,
  tokenGetTokens: t
}) => de(() => t({ network: e ?? void 0 })).map(
  (n) => n.map((r) => ({ ...r, amount: "0" }))
), Yx = () => Ie(
  ({
    defaultTokens: e,
    tokenBalancesScan: t
  }) => new Map([
    ...(e ?? []).map((n) => [dr(n.token), n]),
    ...(t ?? []).map(
      (n) => [dr(n.token), n]
    )
  ]),
  []
), S3 = () => {
  const e = n3(), t = k3();
  return Yx()({
    defaultTokens: t.data ?? [],
    tokenBalancesScan: e.data ?? []
  });
}, Cye = () => {
  const e = cd(), t = ci(), n = S3();
  return Ie(
    ({ selectedToken: r }) => G.fromNullable(n.get(dr(r))).chain(
      (i) => cye({
        queryClient: t,
        yieldIds: i.availableYields
      }).map((o) => ({
        yields: o,
        availableAmount: new Re(i.amount)
      }))
    ).chain(
      (i) => x3({
        initQueryParams: G.fromNullable(e.data),
        yieldDtos: i.yields,
        tokenBalanceAmount: i.availableAmount
      })
    ),
    [e.data, t, n]
  );
}, A3 = ({
  additionalAddresses: e,
  address: t,
  network: n,
  queryClient: r,
  tokenGetTokens: i,
  tokenTokenBalancesScan: o
}) => de.fromPromise(
  () => Promise.all([
    xye({ queryClient: r, network: n, tokenGetTokens: i }),
    de.liftEither(
      _e({ additionalAddresses: e, address: t, network: n })
    ).chain(async (s) => !s.address || !s.network ? _e([]) : hpe({
      queryClient: r,
      tokenTokenBalancesScan: o,
      tokenBalanceScanDto: {
        addresses: {
          address: s.address,
          additionalAddresses: s.additionalAddresses ?? void 0
        },
        network: s.network
      }
    }).mapLeft(() => new Error("could not get token balances scan")))
  ]).then(
    ([s, a]) => s.chain(
      (l) => a.map((c) => ({
        defaultTokens: l,
        tokenBalancesScan: c
      }))
    )
  )
).mapLeft(() => new Error("could not get tokens")), kye = () => {
  const e = Yx(), { isLedgerLive: t, isConnected: n, network: r, additionalAddresses: i, address: o } = wt(), s = ci(), a = Fs(), l = Z0(), c = ew(), { externalProviders: u } = bt();
  return Ut({
    staleTime: Number.POSITIVE_INFINITY,
    queryKey: [
      "init-token",
      n,
      r,
      o,
      i
    ],
    queryFn: async () => (await A3({
      additionalAddresses: i,
      address: o,
      network: r,
      queryClient: s,
      tokenGetTokens: l,
      tokenTokenBalancesScan: c
    }).chain(
      (d) => _y({
        isLedgerLive: t,
        queryClient: s,
        yieldYieldOpportunity: a,
        externalProviders: u
      }).chain(
        (f) => de.liftEither(
          gye({
            defaultTokens: d.defaultTokens,
            tokenBalances: d.tokenBalancesScan,
            initQueryParams: G.fromNullable(f)
          }).toEither(new Error("could not get initial token"))
        ).chain(
          (h) => de.liftEither(
            G.fromNullable(
              e(d).get(dr(h))
            ).toEither(new Error("could not get token balance"))
          ).chain(
            (p) => b3({
              isConnected: n,
              isLedgerLive: t,
              queryClient: s,
              yieldYieldOpportunity: a,
              network: r,
              yieldIds: p.availableYields
            })
          ).map(() => h)
        )
      )
    )).unsafeCoerce()
  });
}, Eye = ({
  selectedToken: e
}) => {
  const t = Yx(), { isLedgerLive: n, isConnected: r, network: i, additionalAddresses: o, address: s } = wt(), a = ci(), l = Fs(), c = Z0(), u = ew(), { externalProviders: d } = bt();
  return Ut({
    staleTime: Number.POSITIVE_INFINITY,
    queryKey: [
      "init-yield",
      r,
      i,
      o,
      s,
      e.extract()
    ],
    queryFn: async () => (await de.liftEither(
      e.toEither(new Error("no token selected"))
    ).chain(
      (f) => A3({
        additionalAddresses: o,
        address: s,
        network: i,
        queryClient: a,
        tokenGetTokens: c,
        tokenTokenBalancesScan: u
      }).chain(
        (h) => de.liftEither(
          G.fromNullable(
            t(h).get(dr(f))
          ).toEither(new Error("could not get token balance"))
        )
      ).chain(
        (h) => _y({
          isLedgerLive: n,
          queryClient: a,
          yieldYieldOpportunity: l,
          externalProviders: d
        }).chain(
          (p) => b3({
            isConnected: r,
            isLedgerLive: n,
            queryClient: a,
            yieldYieldOpportunity: l,
            network: i,
            yieldIds: h.availableYields
          }).chain(
            (m) => de.liftEither(
              x3({
                initQueryParams: G.fromNullable(p),
                yieldDtos: m,
                tokenBalanceAmount: new Re(h.amount)
              }).toEither(new Error("could not get initial yield"))
            )
          )
        )
      )
    )).unsafeCoerce()
  });
}, Sye = ({
  selectedToken: e
}) => {
  const t = S3(), n = J(
    () => e.chainNullable(
      (o) => t.get(dr(o))
    ),
    [e, t]
  ), r = J(
    () => n.map((o) => new Re(o.amount)),
    [n]
  ), i = J(
    () => n.map((o) => o.availableYields),
    [n]
  );
  return {
    availableAmount: r,
    availableYields: i,
    tokenBalance: n
  };
}, VS = ({
  yieldDto: e,
  initParams: t
}) => {
  var n, r;
  return {
    selectedStakeId: G.of(e.id),
    stakeAmount: xp(e),
    selectedValidators: bye({
      initQueryParams: t,
      yieldDto: e
    }),
    tronResource: G.fromFalsy(
      (r = (n = e.args.enter.args) == null ? void 0 : n.tronResource) == null ? void 0 : r.required
    ).map(() => "ENERGY")
  };
}, T3 = Ge(
  void 0
), _3 = Ge(
  void 0
), I3 = Ge(!1), Aye = ({
  children: e
}) => /* @__PURE__ */ y.jsx(I3.Provider, { value: !0, children: e }), oh = () => ({
  selectedToken: G.empty(),
  selectedStakeId: G.empty(),
  selectedValidators: /* @__PURE__ */ new Map(),
  stakeAmount: new Re(0),
  tronResource: G.empty()
}), Tye = ({ children: e }) => {
  var se;
  const t = cd(), { network: n, isConnected: r } = wt(), i = Cye(), o = (oe, ye) => {
    switch (ye.type) {
      case "token/select":
        return G.fromFalsy(
          oe.selectedToken.map((ve) => !xy(ve, ye.data)).orDefault(!0)
        ).chain(
          () => i({ selectedToken: ye.data }).map(
            (ve) => VS({
              initParams: G.fromNullable(t.data),
              yieldDto: ve
            })
          ).alt(G.of(null))
        ).map((ve) => ({
          ...oh(),
          selectedToken: G.of(ye.data),
          ...ve
        })).orDefault(oe);
      case "yield/select":
        return G.fromFalsy(
          oe.selectedStakeId.map((ve) => ve !== ye.data.id).orDefault(!0)
        ).map(
          () => VS({
            initParams: G.fromNullable(t.data),
            yieldDto: ye.data
          })
        ).map((ve) => ({
          ...oh(),
          selectedToken: oe.selectedToken,
          ...ve
        })).orDefault(oe);
      case "validator/select": {
        const ve = /* @__PURE__ */ new Map();
        return ve.set(ye.data.address, ye.data), {
          ...oe,
          selectedValidators: ve
        };
      }
      case "validator/multiselect": {
        const ve = new Map(oe.selectedValidators);
        return ve.has(ye.data.address) ? ve.delete(ye.data.address) : ve.set(ye.data.address, ye.data), ve.size === 0 ? oe : {
          ...oe,
          selectedValidators: ve
        };
      }
      case "validator/remove": {
        const ve = new Map(oe.selectedValidators);
        return ve.delete(ye.data.address), {
          ...oe,
          selectedValidators: ve
        };
      }
      case "stakeAmount/change":
        return {
          ...oe,
          stakeAmount: ye.data
        };
      case "stakeAmount/max":
        return {
          ...oe,
          stakeAmount: ye.data
        };
      case "tronResource/select":
        return { ...oe, tronResource: G.of(ye.data) };
      case "state/reset":
        return oh();
      default:
        return oe;
    }
  }, [s, a] = _c(o, oh()), {
    selectedToken: l,
    selectedStakeId: c,
    selectedValidators: u,
    stakeAmount: d,
    tronResource: f
  } = s, h = kye(), p = J(
    () => G.fromNullable(h.data),
    [h.data]
  ), m = Eye({ selectedToken: l }), g = J(
    () => G.fromNullable(m.data),
    [m.data]
  ), { availableAmount: v, availableYields: w } = Sye({
    selectedToken: l
  }), x = v3(w.orDefault([])), C = Ay(c.extract()), { data: S } = yx(), { minEnterOrExitAmount: k, maxEnterOrExitAmount: A } = C3({
    type: "enter",
    yieldOpportunity: G.fromNullable(C.data),
    availableAmount: v,
    positionsData: S
  }), b = J(
    () => G.fromNullable(C.data),
    [C.data]
  ), T = Kx({
    integration: b,
    type: "enter"
  }), R = J(
    () => T ? A : d,
    [T, A, d]
  ), B = Ie(
    (oe) => a({ type: "token/select", data: oe }),
    []
  ), O = Ie(
    (oe) => a({ type: "yield/select", data: oe }),
    []
  );
  l.ifJust((oe) => {
    n && oe.network !== n && a({ type: "state/reset" });
  });
  const L = Dt(l), V = Dt(p), N = Dt(g), M = !x.isLoading && ((se = x.data) == null ? void 0 : se.length) === 0 && p.isJust() && g.isNothing() && c.isNothing();
  Te(() => {
    !r && L.current.isJust() && a({ type: "state/reset" });
  }, [L, r]), Te(() => {
    p.ifJust(B);
  }, [p, B]), Te(() => {
    l.ifNothing(() => V.current.ifJust(B));
  }, [V, l, B]), Te(() => {
    g.ifJust(O);
  }, [g, O]), Te(() => {
    c.ifNothing(() => N.current.ifJust(O));
  }, [N, c, O]), Te(() => {
    p.ifNothing(
      () => l.ifJust(() => a({ type: "state/reset" }))
    );
  }, [p, l]);
  const U = J(
    () => ({
      onMaxClick: () => a({ type: "stakeAmount/max", data: A })
    }),
    [A]
  ), {
    stakeAmountGreaterThanAvailableAmount: F,
    stakeAmountGreaterThanMax: $,
    stakeAmountLessThanMin: ie,
    stakeAmountIsZero: he
  } = wye({
    availableAmount: v,
    stakeAmount: R,
    maxEnterOrExitAmount: A,
    minEnterOrExitAmount: k
  }), ae = J(
    () => ({
      selectedStakeId: c,
      selectedStake: b,
      selectedValidators: u,
      stakeAmount: R,
      actions: U,
      tronResource: f,
      stakeAmountGreaterThanAvailableAmount: F,
      stakeAmountGreaterThanMax: $,
      stakeAmountLessThanMin: ie,
      stakeAmountIsZero: he,
      availableAmount: v,
      availableYields: w,
      selectedToken: l,
      hasNotYieldsForToken: M
    }),
    [
      c,
      b,
      l,
      u,
      R,
      U,
      f,
      F,
      $,
      ie,
      he,
      v,
      w,
      M
    ]
  );
  return /* @__PURE__ */ y.jsx(T3.Provider, { value: ae, children: /* @__PURE__ */ y.jsx(_3.Provider, { value: a, children: e }) });
}, R3 = () => {
  if (!we(I3))
    throw new Error("hook must be used withing EarnPageStateUsageBoundary");
}, P3 = () => {
  R3();
  const e = we(T3);
  if (e === void 0)
    throw new Error("useState must be used within a StateProvider");
  return e;
}, _ye = () => {
  R3();
  const e = we(_3);
  if (e === void 0)
    throw new Error("useDispatch must be used within a StateProvider");
  return e;
};
function O3(e) {
  const t = e + "CollectionProvider", [n, r] = Wa(t), [i, o] = n(
    t,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), s = (h) => {
    const { scope: p, children: m } = h, g = I.useRef(null), v = I.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ y.jsx(i, { scope: p, itemMap: v, collectionRef: g, children: m });
  };
  s.displayName = t;
  const a = e + "CollectionSlot", l = I.forwardRef(
    (h, p) => {
      const { scope: m, children: g } = h, v = o(a, m), w = _n(p, v.collectionRef);
      return /* @__PURE__ */ y.jsx(yc, { ref: w, children: g });
    }
  );
  l.displayName = a;
  const c = e + "CollectionItemSlot", u = "data-radix-collection-item", d = I.forwardRef(
    (h, p) => {
      const { scope: m, children: g, ...v } = h, w = I.useRef(null), x = _n(p, w), C = o(c, m);
      return I.useEffect(() => (C.itemMap.set(w, { ref: w, ...v }), () => void C.itemMap.delete(w))), /* @__PURE__ */ y.jsx(yc, { [u]: "", ref: x, children: g });
    }
  );
  d.displayName = c;
  function f(h) {
    const p = o(e + "CollectionConsumer", h);
    return I.useCallback(() => {
      const g = p.collectionRef.current;
      if (!g) return [];
      const v = Array.from(g.querySelectorAll(`[${u}]`));
      return Array.from(p.itemMap.values()).sort(
        (C, S) => v.indexOf(C.ref.current) - v.indexOf(S.ref.current)
      );
    }, [p.collectionRef, p.itemMap]);
  }
  return [
    { Provider: s, Slot: l, ItemSlot: d },
    f,
    r
  ];
}
var Iye = P.createContext(void 0);
function B3(e) {
  const t = P.useContext(Iye);
  return e || t || "ltr";
}
var mv = "rovingFocusGroup.onEntryFocus", Rye = { bubbles: !1, cancelable: !0 }, dm = "RovingFocusGroup", [N0, N3, Pye] = O3(dm), [Oye, D3] = Wa(
  dm,
  [Pye]
), [Bye, Nye] = Oye(dm), j3 = P.forwardRef(
  (e, t) => /* @__PURE__ */ y.jsx(N0.Provider, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ y.jsx(N0.Slot, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ y.jsx(Dye, { ...e, ref: t }) }) })
);
j3.displayName = dm;
var Dye = P.forwardRef((e, t) => {
  const {
    __scopeRovingFocusGroup: n,
    orientation: r,
    loop: i = !1,
    dir: o,
    currentTabStopId: s,
    defaultCurrentTabStopId: a,
    onCurrentTabStopIdChange: l,
    onEntryFocus: c,
    preventScrollOnEntryFocus: u = !1,
    ...d
  } = e, f = P.useRef(null), h = _n(t, f), p = B3(o), [m = null, g] = Hy({
    prop: s,
    defaultProp: a,
    onChange: l
  }), [v, w] = P.useState(!1), x = _i(c), C = N3(n), S = P.useRef(!1), [k, A] = P.useState(0);
  return P.useEffect(() => {
    const b = f.current;
    if (b)
      return b.addEventListener(mv, x), () => b.removeEventListener(mv, x);
  }, [x]), /* @__PURE__ */ y.jsx(
    Bye,
    {
      scope: n,
      orientation: r,
      dir: p,
      loop: i,
      currentTabStopId: m,
      onItemFocus: P.useCallback(
        (b) => g(b),
        [g]
      ),
      onItemShiftTab: P.useCallback(() => w(!0), []),
      onFocusableItemAdd: P.useCallback(
        () => A((b) => b + 1),
        []
      ),
      onFocusableItemRemove: P.useCallback(
        () => A((b) => b - 1),
        []
      ),
      children: /* @__PURE__ */ y.jsx(
        un.div,
        {
          tabIndex: v || k === 0 ? -1 : 0,
          "data-orientation": r,
          ...d,
          ref: h,
          style: { outline: "none", ...e.style },
          onMouseDown: ct(e.onMouseDown, () => {
            S.current = !0;
          }),
          onFocus: ct(e.onFocus, (b) => {
            const T = !S.current;
            if (b.target === b.currentTarget && T && !v) {
              const R = new CustomEvent(mv, Rye);
              if (b.currentTarget.dispatchEvent(R), !R.defaultPrevented) {
                const B = C().filter((M) => M.focusable), O = B.find((M) => M.active), L = B.find((M) => M.id === m), N = [O, L, ...B].filter(
                  Boolean
                ).map((M) => M.ref.current);
                L3(N, u);
              }
            }
            S.current = !1;
          }),
          onBlur: ct(e.onBlur, () => w(!1))
        }
      )
    }
  );
}), M3 = "RovingFocusGroupItem", F3 = P.forwardRef(
  (e, t) => {
    const {
      __scopeRovingFocusGroup: n,
      focusable: r = !0,
      active: i = !1,
      tabStopId: o,
      ...s
    } = e, a = Ca(), l = o || a, c = Nye(M3, n), u = c.currentTabStopId === l, d = N3(n), { onFocusableItemAdd: f, onFocusableItemRemove: h } = c;
    return P.useEffect(() => {
      if (r)
        return f(), () => h();
    }, [r, f, h]), /* @__PURE__ */ y.jsx(
      N0.ItemSlot,
      {
        scope: n,
        id: l,
        focusable: r,
        active: i,
        children: /* @__PURE__ */ y.jsx(
          un.span,
          {
            tabIndex: u ? 0 : -1,
            "data-orientation": c.orientation,
            ...s,
            ref: t,
            onMouseDown: ct(e.onMouseDown, (p) => {
              r ? c.onItemFocus(l) : p.preventDefault();
            }),
            onFocus: ct(e.onFocus, () => c.onItemFocus(l)),
            onKeyDown: ct(e.onKeyDown, (p) => {
              if (p.key === "Tab" && p.shiftKey) {
                c.onItemShiftTab();
                return;
              }
              if (p.target !== p.currentTarget) return;
              const m = Fye(p, c.orientation, c.dir);
              if (m !== void 0) {
                if (p.metaKey || p.ctrlKey || p.altKey || p.shiftKey) return;
                p.preventDefault();
                let v = d().filter((w) => w.focusable).map((w) => w.ref.current);
                if (m === "last") v.reverse();
                else if (m === "prev" || m === "next") {
                  m === "prev" && v.reverse();
                  const w = v.indexOf(p.currentTarget);
                  v = c.loop ? Lye(v, w + 1) : v.slice(w + 1);
                }
                setTimeout(() => L3(v));
              }
            })
          }
        )
      }
    );
  }
);
F3.displayName = M3;
var jye = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function Mye(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function Fye(e, t, n) {
  const r = Mye(e.key, n);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
    return jye[r];
}
function L3(e, t = !1) {
  const n = document.activeElement;
  for (const r of e)
    if (r === n || (r.focus({ preventScroll: t }), document.activeElement !== n)) return;
}
function Lye(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
var Uye = j3, zye = F3, D0 = ["Enter", " "], Vye = ["ArrowDown", "PageUp", "Home"], U3 = ["ArrowUp", "PageDown", "End"], qye = [...Vye, ...U3], $ye = {
  ltr: [...D0, "ArrowRight"],
  rtl: [...D0, "ArrowLeft"]
}, Wye = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
}, gf = "Menu", [xd, Gye, Hye] = O3(gf), [Ha, z3] = Wa(gf, [
  Hye,
  nm,
  D3
]), fm = nm(), V3 = D3(), [Kye, Kc] = Ha(gf), [Yye, vf] = Ha(gf), q3 = (e) => {
  const { __scopeMenu: t, open: n = !1, children: r, dir: i, onOpenChange: o, modal: s = !0 } = e, a = fm(t), [l, c] = P.useState(null), u = P.useRef(!1), d = _i(o), f = B3(i);
  return P.useEffect(() => {
    const h = () => {
      u.current = !0, document.addEventListener("pointerdown", p, { capture: !0, once: !0 }), document.addEventListener("pointermove", p, { capture: !0, once: !0 });
    }, p = () => u.current = !1;
    return document.addEventListener("keydown", h, { capture: !0 }), () => {
      document.removeEventListener("keydown", h, { capture: !0 }), document.removeEventListener("pointerdown", p, { capture: !0 }), document.removeEventListener("pointermove", p, { capture: !0 });
    };
  }, []), /* @__PURE__ */ y.jsx(pB, { ...a, children: /* @__PURE__ */ y.jsx(
    Kye,
    {
      scope: t,
      open: n,
      onOpenChange: d,
      content: l,
      onContentChange: c,
      children: /* @__PURE__ */ y.jsx(
        Yye,
        {
          scope: t,
          onClose: P.useCallback(() => d(!1), [d]),
          isUsingKeyboardRef: u,
          dir: f,
          modal: s,
          children: r
        }
      )
    }
  ) });
};
q3.displayName = gf;
var Qye = "MenuAnchor", Qx = P.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e, i = fm(n);
    return /* @__PURE__ */ y.jsx(yB, { ...i, ...r, ref: t });
  }
);
Qx.displayName = Qye;
var Jye = "MenuPortal", [Ebe, $3] = Ha(Jye, {
  forceMount: void 0
}), ri = "MenuContent", [Xye, Jx] = Ha(ri), W3 = P.forwardRef(
  (e, t) => {
    const n = $3(ri, e.__scopeMenu), { forceMount: r = n.forceMount, ...i } = e, o = Kc(ri, e.__scopeMenu), s = vf(ri, e.__scopeMenu);
    return /* @__PURE__ */ y.jsx(xd.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ y.jsx(zo, { present: r || o.open, children: /* @__PURE__ */ y.jsx(xd.Slot, { scope: e.__scopeMenu, children: s.modal ? /* @__PURE__ */ y.jsx(Zye, { ...i, ref: t }) : /* @__PURE__ */ y.jsx(eme, { ...i, ref: t }) }) }) });
  }
), Zye = P.forwardRef(
  (e, t) => {
    const n = Kc(ri, e.__scopeMenu), r = P.useRef(null), i = _n(t, r);
    return P.useEffect(() => {
      const o = r.current;
      if (o) return XO(o);
    }, []), /* @__PURE__ */ y.jsx(
      Xx,
      {
        ...e,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: n.open,
        disableOutsideScroll: !0,
        onFocusOutside: ct(
          e.onFocusOutside,
          (o) => o.preventDefault(),
          { checkForDefaultPrevented: !1 }
        ),
        onDismiss: () => n.onOpenChange(!1)
      }
    );
  }
), eme = P.forwardRef((e, t) => {
  const n = Kc(ri, e.__scopeMenu);
  return /* @__PURE__ */ y.jsx(
    Xx,
    {
      ...e,
      ref: t,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => n.onOpenChange(!1)
    }
  );
}), Xx = P.forwardRef(
  (e, t) => {
    const {
      __scopeMenu: n,
      loop: r = !1,
      trapFocus: i,
      onOpenAutoFocus: o,
      onCloseAutoFocus: s,
      disableOutsidePointerEvents: a,
      onEntryFocus: l,
      onEscapeKeyDown: c,
      onPointerDownOutside: u,
      onFocusOutside: d,
      onInteractOutside: f,
      onDismiss: h,
      disableOutsideScroll: p,
      ...m
    } = e, g = Kc(ri, n), v = vf(ri, n), w = fm(n), x = V3(n), C = Gye(n), [S, k] = P.useState(null), A = P.useRef(null), b = _n(t, A, g.onContentChange), T = P.useRef(0), R = P.useRef(""), B = P.useRef(0), O = P.useRef(null), L = P.useRef("right"), V = P.useRef(0), N = p ? ly : P.Fragment, M = p ? { as: yc, allowPinchZoom: !0 } : void 0, U = ($) => {
      var Be, it;
      const ie = R.current + $, he = C().filter((lt) => !lt.disabled), ae = document.activeElement, se = (Be = he.find((lt) => lt.ref.current === ae)) == null ? void 0 : Be.textValue, oe = he.map((lt) => lt.textValue), ye = fme(oe, ie, se), ve = (it = he.find((lt) => lt.textValue === ye)) == null ? void 0 : it.ref.current;
      (function lt(yt) {
        R.current = yt, window.clearTimeout(T.current), yt !== "" && (T.current = window.setTimeout(() => lt(""), 1e3));
      })(ie), ve && setTimeout(() => ve.focus());
    };
    P.useEffect(() => () => window.clearTimeout(T.current), []), QO();
    const F = P.useCallback(($) => {
      var he, ae;
      return L.current === ((he = O.current) == null ? void 0 : he.side) && pme($, (ae = O.current) == null ? void 0 : ae.area);
    }, []);
    return /* @__PURE__ */ y.jsx(
      Xye,
      {
        scope: n,
        searchRef: R,
        onItemEnter: P.useCallback(
          ($) => {
            F($) && $.preventDefault();
          },
          [F]
        ),
        onItemLeave: P.useCallback(
          ($) => {
            var ie;
            F($) || ((ie = A.current) == null || ie.focus(), k(null));
          },
          [F]
        ),
        onTriggerLeave: P.useCallback(
          ($) => {
            F($) && $.preventDefault();
          },
          [F]
        ),
        pointerGraceTimerRef: B,
        onPointerGraceIntentChange: P.useCallback(($) => {
          O.current = $;
        }, []),
        children: /* @__PURE__ */ y.jsx(N, { ...M, children: /* @__PURE__ */ y.jsx(
          sx,
          {
            asChild: !0,
            trapped: i,
            onMountAutoFocus: ct(o, ($) => {
              var ie;
              $.preventDefault(), (ie = A.current) == null || ie.focus({ preventScroll: !0 });
            }),
            onUnmountAutoFocus: s,
            children: /* @__PURE__ */ y.jsx(
              Ky,
              {
                asChild: !0,
                disableOutsidePointerEvents: a,
                onEscapeKeyDown: c,
                onPointerDownOutside: u,
                onFocusOutside: d,
                onInteractOutside: f,
                onDismiss: h,
                children: /* @__PURE__ */ y.jsx(
                  Uye,
                  {
                    asChild: !0,
                    ...x,
                    dir: v.dir,
                    orientation: "vertical",
                    loop: r,
                    currentTabStopId: S,
                    onCurrentTabStopIdChange: k,
                    onEntryFocus: ct(l, ($) => {
                      v.isUsingKeyboardRef.current || $.preventDefault();
                    }),
                    preventScrollOnEntryFocus: !0,
                    children: /* @__PURE__ */ y.jsx(
                      mB,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": aN(g.open),
                        "data-radix-menu-content": "",
                        dir: v.dir,
                        ...w,
                        ...m,
                        ref: b,
                        style: { outline: "none", ...m.style },
                        onKeyDown: ct(m.onKeyDown, ($) => {
                          const he = $.target.closest("[data-radix-menu-content]") === $.currentTarget, ae = $.ctrlKey || $.altKey || $.metaKey, se = $.key.length === 1;
                          he && ($.key === "Tab" && $.preventDefault(), !ae && se && U($.key));
                          const oe = A.current;
                          if ($.target !== oe || !qye.includes($.key)) return;
                          $.preventDefault();
                          const ve = C().filter((Be) => !Be.disabled).map((Be) => Be.ref.current);
                          U3.includes($.key) && ve.reverse(), ume(ve);
                        }),
                        onBlur: ct(e.onBlur, ($) => {
                          $.currentTarget.contains($.target) || (window.clearTimeout(T.current), R.current = "");
                        }),
                        onPointerMove: ct(
                          e.onPointerMove,
                          Cd(($) => {
                            const ie = $.target, he = V.current !== $.clientX;
                            if ($.currentTarget.contains(ie) && he) {
                              const ae = $.clientX > V.current ? "right" : "left";
                              L.current = ae, V.current = $.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
W3.displayName = ri;
var tme = "MenuGroup", Zx = P.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ y.jsx(un.div, { role: "group", ...r, ref: t });
  }
);
Zx.displayName = tme;
var nme = "MenuLabel", G3 = P.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ y.jsx(un.div, { ...r, ref: t });
  }
);
G3.displayName = nme;
var Cp = "MenuItem", qS = "menu.itemSelect", hm = P.forwardRef(
  (e, t) => {
    const { disabled: n = !1, onSelect: r, ...i } = e, o = P.useRef(null), s = vf(Cp, e.__scopeMenu), a = Jx(Cp, e.__scopeMenu), l = _n(t, o), c = P.useRef(!1), u = () => {
      const d = o.current;
      if (!n && d) {
        const f = new CustomEvent(qS, { bubbles: !0, cancelable: !0 });
        d.addEventListener(qS, (h) => r == null ? void 0 : r(h), { once: !0 }), GO(d, f), f.defaultPrevented ? c.current = !1 : s.onClose();
      }
    };
    return /* @__PURE__ */ y.jsx(
      H3,
      {
        ...i,
        ref: l,
        disabled: n,
        onClick: ct(e.onClick, u),
        onPointerDown: (d) => {
          var f;
          (f = e.onPointerDown) == null || f.call(e, d), c.current = !0;
        },
        onPointerUp: ct(e.onPointerUp, (d) => {
          var f;
          c.current || (f = d.currentTarget) == null || f.click();
        }),
        onKeyDown: ct(e.onKeyDown, (d) => {
          const f = a.searchRef.current !== "";
          n || f && d.key === " " || D0.includes(d.key) && (d.currentTarget.click(), d.preventDefault());
        })
      }
    );
  }
);
hm.displayName = Cp;
var H3 = P.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, disabled: r = !1, textValue: i, ...o } = e, s = Jx(Cp, n), a = V3(n), l = P.useRef(null), c = _n(t, l), [u, d] = P.useState(!1), [f, h] = P.useState("");
    return P.useEffect(() => {
      const p = l.current;
      p && h((p.textContent ?? "").trim());
    }, [o.children]), /* @__PURE__ */ y.jsx(
      xd.ItemSlot,
      {
        scope: n,
        disabled: r,
        textValue: i ?? f,
        children: /* @__PURE__ */ y.jsx(zye, { asChild: !0, ...a, focusable: !r, children: /* @__PURE__ */ y.jsx(
          un.div,
          {
            role: "menuitem",
            "data-highlighted": u ? "" : void 0,
            "aria-disabled": r || void 0,
            "data-disabled": r ? "" : void 0,
            ...o,
            ref: c,
            onPointerMove: ct(
              e.onPointerMove,
              Cd((p) => {
                r ? s.onItemLeave(p) : (s.onItemEnter(p), p.defaultPrevented || p.currentTarget.focus({ preventScroll: !0 }));
              })
            ),
            onPointerLeave: ct(
              e.onPointerLeave,
              Cd((p) => s.onItemLeave(p))
            ),
            onFocus: ct(e.onFocus, () => d(!0)),
            onBlur: ct(e.onBlur, () => d(!1))
          }
        ) })
      }
    );
  }
), rme = "MenuCheckboxItem", K3 = P.forwardRef(
  (e, t) => {
    const { checked: n = !1, onCheckedChange: r, ...i } = e;
    return /* @__PURE__ */ y.jsx(Z3, { scope: e.__scopeMenu, checked: n, children: /* @__PURE__ */ y.jsx(
      hm,
      {
        role: "menuitemcheckbox",
        "aria-checked": kp(n) ? "mixed" : n,
        ...i,
        ref: t,
        "data-state": tC(n),
        onSelect: ct(
          i.onSelect,
          () => r == null ? void 0 : r(kp(n) ? !0 : !n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
K3.displayName = rme;
var Y3 = "MenuRadioGroup", [ime, ome] = Ha(
  Y3,
  { value: void 0, onValueChange: () => {
  } }
), Q3 = P.forwardRef(
  (e, t) => {
    const { value: n, onValueChange: r, ...i } = e, o = _i(r);
    return /* @__PURE__ */ y.jsx(ime, { scope: e.__scopeMenu, value: n, onValueChange: o, children: /* @__PURE__ */ y.jsx(Zx, { ...i, ref: t }) });
  }
);
Q3.displayName = Y3;
var J3 = "MenuRadioItem", X3 = P.forwardRef(
  (e, t) => {
    const { value: n, ...r } = e, i = ome(J3, e.__scopeMenu), o = n === i.value;
    return /* @__PURE__ */ y.jsx(Z3, { scope: e.__scopeMenu, checked: o, children: /* @__PURE__ */ y.jsx(
      hm,
      {
        role: "menuitemradio",
        "aria-checked": o,
        ...r,
        ref: t,
        "data-state": tC(o),
        onSelect: ct(
          r.onSelect,
          () => {
            var s;
            return (s = i.onValueChange) == null ? void 0 : s.call(i, n);
          },
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
X3.displayName = J3;
var eC = "MenuItemIndicator", [Z3, sme] = Ha(
  eC,
  { checked: !1 }
), eN = P.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, forceMount: r, ...i } = e, o = sme(eC, n);
    return /* @__PURE__ */ y.jsx(
      zo,
      {
        present: r || kp(o.checked) || o.checked === !0,
        children: /* @__PURE__ */ y.jsx(
          un.span,
          {
            ...i,
            ref: t,
            "data-state": tC(o.checked)
          }
        )
      }
    );
  }
);
eN.displayName = eC;
var ame = "MenuSeparator", tN = P.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ y.jsx(
      un.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...r,
        ref: t
      }
    );
  }
);
tN.displayName = ame;
var lme = "MenuArrow", nN = P.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e, i = fm(n);
    return /* @__PURE__ */ y.jsx(gB, { ...i, ...r, ref: t });
  }
);
nN.displayName = lme;
var cme = "MenuSub", [Sbe, rN] = Ha(cme), Su = "MenuSubTrigger", iN = P.forwardRef(
  (e, t) => {
    const n = Kc(Su, e.__scopeMenu), r = vf(Su, e.__scopeMenu), i = rN(Su, e.__scopeMenu), o = Jx(Su, e.__scopeMenu), s = P.useRef(null), { pointerGraceTimerRef: a, onPointerGraceIntentChange: l } = o, c = { __scopeMenu: e.__scopeMenu }, u = P.useCallback(() => {
      s.current && window.clearTimeout(s.current), s.current = null;
    }, []);
    return P.useEffect(() => u, [u]), P.useEffect(() => {
      const d = a.current;
      return () => {
        window.clearTimeout(d), l(null);
      };
    }, [a, l]), /* @__PURE__ */ y.jsx(Qx, { asChild: !0, ...c, children: /* @__PURE__ */ y.jsx(
      H3,
      {
        id: i.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": n.open,
        "aria-controls": i.contentId,
        "data-state": aN(n.open),
        ...e,
        ref: Gy(t, i.onTriggerChange),
        onClick: (d) => {
          var f;
          (f = e.onClick) == null || f.call(e, d), !(e.disabled || d.defaultPrevented) && (d.currentTarget.focus(), n.open || n.onOpenChange(!0));
        },
        onPointerMove: ct(
          e.onPointerMove,
          Cd((d) => {
            o.onItemEnter(d), !d.defaultPrevented && !e.disabled && !n.open && !s.current && (o.onPointerGraceIntentChange(null), s.current = window.setTimeout(() => {
              n.onOpenChange(!0), u();
            }, 100));
          })
        ),
        onPointerLeave: ct(
          e.onPointerLeave,
          Cd((d) => {
            var h, p;
            u();
            const f = (h = n.content) == null ? void 0 : h.getBoundingClientRect();
            if (f) {
              const m = (p = n.content) == null ? void 0 : p.dataset.side, g = m === "right", v = g ? -5 : 5, w = f[g ? "left" : "right"], x = f[g ? "right" : "left"];
              o.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: d.clientX + v, y: d.clientY },
                  { x: w, y: f.top },
                  { x, y: f.top },
                  { x, y: f.bottom },
                  { x: w, y: f.bottom }
                ],
                side: m
              }), window.clearTimeout(a.current), a.current = window.setTimeout(
                () => o.onPointerGraceIntentChange(null),
                300
              );
            } else {
              if (o.onTriggerLeave(d), d.defaultPrevented) return;
              o.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: ct(e.onKeyDown, (d) => {
          var h;
          const f = o.searchRef.current !== "";
          e.disabled || f && d.key === " " || $ye[r.dir].includes(d.key) && (n.onOpenChange(!0), (h = n.content) == null || h.focus(), d.preventDefault());
        })
      }
    ) });
  }
);
iN.displayName = Su;
var oN = "MenuSubContent", sN = P.forwardRef(
  (e, t) => {
    const n = $3(ri, e.__scopeMenu), { forceMount: r = n.forceMount, ...i } = e, o = Kc(ri, e.__scopeMenu), s = vf(ri, e.__scopeMenu), a = rN(oN, e.__scopeMenu), l = P.useRef(null), c = _n(t, l);
    return /* @__PURE__ */ y.jsx(xd.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ y.jsx(zo, { present: r || o.open, children: /* @__PURE__ */ y.jsx(xd.Slot, { scope: e.__scopeMenu, children: /* @__PURE__ */ y.jsx(
      Xx,
      {
        id: a.contentId,
        "aria-labelledby": a.triggerId,
        ...i,
        ref: c,
        align: "start",
        side: s.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        trapFocus: !1,
        onOpenAutoFocus: (u) => {
          var d;
          s.isUsingKeyboardRef.current && ((d = l.current) == null || d.focus()), u.preventDefault();
        },
        onCloseAutoFocus: (u) => u.preventDefault(),
        onFocusOutside: ct(e.onFocusOutside, (u) => {
          u.target !== a.trigger && o.onOpenChange(!1);
        }),
        onEscapeKeyDown: ct(e.onEscapeKeyDown, (u) => {
          s.onClose(), u.preventDefault();
        }),
        onKeyDown: ct(e.onKeyDown, (u) => {
          var h;
          const d = u.currentTarget.contains(u.target), f = Wye[s.dir].includes(u.key);
          d && f && (o.onOpenChange(!1), (h = a.trigger) == null || h.focus(), u.preventDefault());
        })
      }
    ) }) }) });
  }
);
sN.displayName = oN;
function aN(e) {
  return e ? "open" : "closed";
}
function kp(e) {
  return e === "indeterminate";
}
function tC(e) {
  return kp(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
function ume(e) {
  const t = document.activeElement;
  for (const n of e)
    if (n === t || (n.focus(), document.activeElement !== t)) return;
}
function dme(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
function fme(e, t, n) {
  const i = t.length > 1 && Array.from(t).every((c) => c === t[0]) ? t[0] : t, o = n ? e.indexOf(n) : -1;
  let s = dme(e, Math.max(o, 0));
  i.length === 1 && (s = s.filter((c) => c !== n));
  const l = s.find(
    (c) => c.toLowerCase().startsWith(i.toLowerCase())
  );
  return l !== n ? l : void 0;
}
function hme(e, t) {
  const { x: n, y: r } = e;
  let i = !1;
  for (let o = 0, s = t.length - 1; o < t.length; s = o++) {
    const a = t[o].x, l = t[o].y, c = t[s].x, u = t[s].y;
    l > r != u > r && n < (c - a) * (r - l) / (u - l) + a && (i = !i);
  }
  return i;
}
function pme(e, t) {
  if (!t) return !1;
  const n = { x: e.clientX, y: e.clientY };
  return hme(n, t);
}
function Cd(e) {
  return (t) => t.pointerType === "mouse" ? e(t) : void 0;
}
var yme = q3, mme = Qx, gme = W3, vme = Zx, bme = G3, wme = hm, xme = K3, Cme = Q3, kme = X3, Eme = eN, Sme = tN, Ame = nN, Tme = iN, _me = sN, nC = "DropdownMenu", [Ime, Abe] = Wa(
  nC,
  [z3]
), Sr = z3(), [Rme, lN] = Ime(nC), cN = (e) => {
  const {
    __scopeDropdownMenu: t,
    children: n,
    dir: r,
    open: i,
    defaultOpen: o,
    onOpenChange: s,
    modal: a = !0
  } = e, l = Sr(t), c = P.useRef(null), [u = !1, d] = Hy({
    prop: i,
    defaultProp: o,
    onChange: s
  });
  return /* @__PURE__ */ y.jsx(
    Rme,
    {
      scope: t,
      triggerId: Ca(),
      triggerRef: c,
      contentId: Ca(),
      open: u,
      onOpenChange: d,
      onOpenToggle: P.useCallback(() => d((f) => !f), [d]),
      modal: a,
      children: /* @__PURE__ */ y.jsx(yme, { ...l, open: u, onOpenChange: d, dir: r, modal: a, children: n })
    }
  );
};
cN.displayName = nC;
var uN = "DropdownMenuTrigger", dN = P.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, disabled: r = !1, ...i } = e, o = lN(uN, n), s = Sr(n);
    return /* @__PURE__ */ y.jsx(mme, { asChild: !0, ...s, children: /* @__PURE__ */ y.jsx(
      un.button,
      {
        type: "button",
        id: o.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": o.open,
        "aria-controls": o.open ? o.contentId : void 0,
        "data-state": o.open ? "open" : "closed",
        "data-disabled": r ? "" : void 0,
        disabled: r,
        ...i,
        ref: Gy(t, o.triggerRef),
        onPointerDown: ct(e.onPointerDown, (a) => {
          !r && a.button === 0 && a.ctrlKey === !1 && (o.onOpenToggle(), o.open || a.preventDefault());
        }),
        onKeyDown: ct(e.onKeyDown, (a) => {
          r || (["Enter", " "].includes(a.key) && o.onOpenToggle(), a.key === "ArrowDown" && o.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(a.key) && a.preventDefault());
        })
      }
    ) });
  }
);
dN.displayName = uN;
var fN = "DropdownMenuContent", hN = P.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = lN(fN, n), o = Sr(n), s = P.useRef(!1);
    return /* @__PURE__ */ y.jsx(
      gme,
      {
        id: i.contentId,
        "aria-labelledby": i.triggerId,
        ...o,
        ...r,
        ref: t,
        onCloseAutoFocus: ct(e.onCloseAutoFocus, (a) => {
          var l;
          s.current || (l = i.triggerRef.current) == null || l.focus(), s.current = !1, a.preventDefault();
        }),
        onInteractOutside: ct(e.onInteractOutside, (a) => {
          const l = a.detail.originalEvent, c = l.button === 0 && l.ctrlKey === !0, u = l.button === 2 || c;
          (!i.modal || u) && (s.current = !0);
        }),
        style: {
          ...e.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
hN.displayName = fN;
var Pme = "DropdownMenuGroup", Ome = P.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = Sr(n);
    return /* @__PURE__ */ y.jsx(vme, { ...i, ...r, ref: t });
  }
);
Ome.displayName = Pme;
var Bme = "DropdownMenuLabel", Nme = P.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = Sr(n);
    return /* @__PURE__ */ y.jsx(bme, { ...i, ...r, ref: t });
  }
);
Nme.displayName = Bme;
var Dme = "DropdownMenuItem", jme = P.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = Sr(n);
    return /* @__PURE__ */ y.jsx(wme, { ...i, ...r, ref: t });
  }
);
jme.displayName = Dme;
var Mme = "DropdownMenuCheckboxItem", Fme = P.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = Sr(n);
  return /* @__PURE__ */ y.jsx(xme, { ...i, ...r, ref: t });
});
Fme.displayName = Mme;
var Lme = "DropdownMenuRadioGroup", pN = P.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = Sr(n);
  return /* @__PURE__ */ y.jsx(Cme, { ...i, ...r, ref: t });
});
pN.displayName = Lme;
var Ume = "DropdownMenuRadioItem", yN = P.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = Sr(n);
  return /* @__PURE__ */ y.jsx(kme, { ...i, ...r, ref: t });
});
yN.displayName = Ume;
var zme = "DropdownMenuItemIndicator", Vme = P.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = Sr(n);
  return /* @__PURE__ */ y.jsx(Eme, { ...i, ...r, ref: t });
});
Vme.displayName = zme;
var qme = "DropdownMenuSeparator", mN = P.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = Sr(n);
  return /* @__PURE__ */ y.jsx(Sme, { ...i, ...r, ref: t });
});
mN.displayName = qme;
var $me = "DropdownMenuArrow", Wme = P.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = Sr(n);
    return /* @__PURE__ */ y.jsx(Ame, { ...i, ...r, ref: t });
  }
);
Wme.displayName = $me;
var Gme = "DropdownMenuSubTrigger", Hme = P.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = Sr(n);
  return /* @__PURE__ */ y.jsx(Tme, { ...i, ...r, ref: t });
});
Hme.displayName = Gme;
var Kme = "DropdownMenuSubContent", Yme = P.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = Sr(n);
  return /* @__PURE__ */ y.jsx(
    _me,
    {
      ...i,
      ...r,
      ref: t,
      style: {
        ...e.style,
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
Yme.displayName = Kme;
var Qme = cN, Jme = dN, Xme = hN, Zme = pN, ege = yN, tge = mN, nge = "_12si65s1 _12si65s0 yv8y4re3 yv8y4rcl yv8y4r9j yv8y4rb1 yv8y4rw9 yv8y4rwa", rge = "_12si65s3 _12si65s2 yv8y4rw9 yv8y4rwa", ige = "_12si65s4", oge = "_12si65s6 _12si65s5 yv8y4re7 yv8y4rcp yv8y4r9j yv8y4rb1 yv8y4r2n yv8y4rfj", sge = "_12si65s8 _12si65s7 yv8y4rvr yv8y4rvs";
function age({
  options: e,
  onSelect: t,
  selectedOption: n,
  placeholder: r,
  isError: i
}) {
  return /* @__PURE__ */ y.jsxs(Qme, { children: [
    /* @__PURE__ */ y.jsx(Jme, { children: /* @__PURE__ */ y.jsxs(
      z,
      {
        className: nge,
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        gap: "2",
        borderStyle: "solid",
        borderColor: i ? "textDanger" : "transparent",
        borderWidth: 1,
        children: [
          /* @__PURE__ */ y.jsx(ue, { children: (n == null ? void 0 : n.label) ?? r }),
          /* @__PURE__ */ y.jsx($a, {})
        ]
      }
    ) }),
    /* @__PURE__ */ y.jsx(
      Xme,
      {
        className: rge,
        sideOffset: 3,
        align: "start",
        children: /* @__PURE__ */ y.jsx(
          Zme,
          {
            className: ige,
            value: n == null ? void 0 : n.value,
            onValueChange: t,
            children: e.map((o, s) => /* @__PURE__ */ y.jsxs(Tc, { children: [
              /* @__PURE__ */ y.jsx(
                ege,
                {
                  className: oge,
                  value: o.value,
                  children: /* @__PURE__ */ y.jsx(ue, { children: o.label })
                }
              ),
              s < e.length - 1 && /* @__PURE__ */ y.jsx(tge, { className: sge })
            ] }, o.value))
          }
        )
      }
    )
  ] });
}
const lge = () => {
  const e = er(), { disableAutoScrollToTop: t } = bt();
  return Ie(
    (n, r) => (t || window.scrollTo(0, 0), e(n, r)),
    [e, t]
  );
}, gN = ({
  selectedStake: e,
  stakeAmount: t,
  selectedValidators: n
}) => {
  const r = Uo({
    integrationData: e,
    validatorsAddresses: G.of(n)
  });
  return J(
    () => G.fromRecord({ providersDetails: r, selectedStake: e }).map((i) => ({
      ...i,
      rewardRateAverage: i.providersDetails.reduce(
        (o, s) => o.plus(new Re(s.rewardRate ?? 0)),
        new Re(0)
      ).dividedBy(i.providersDetails.length)
    })).map((i) => ({
      percentage: xs({
        rewardRate: i.rewardRateAverage.toNumber(),
        rewardType: i.selectedStake.rewardType
      }),
      yearly: i.rewardRateAverage.isGreaterThan(0) ? Sn(
        t.times(i.rewardRateAverage).decimalPlaces(5)
      ) : "-",
      monthly: i.rewardRateAverage.isGreaterThan(0) ? Sn(
        t.times(i.rewardRateAverage).dividedBy(12).decimalPlaces(5)
      ) : "-"
    })),
    [r, e, t]
  );
}, vN = (e) => J(
  () => e.chain(
    (t) => G.fromNullable(t.metadata.rewardTokens).chain(
      (n) => G.fromNullable(t.metadata.provider).map((r) => ({ rt: n, p: r }))
    )
  ).map(({ p: t, rt: n }) => ({
    logoUri: t.logoURI ?? null,
    rewardTokens: n,
    symbols: Ox(n),
    providerName: t.name ?? null
  })),
  [e]
), cge = () => {
  var c;
  const {
    selectedStake: e,
    stakeAmount: t,
    selectedValidators: n,
    tronResource: r,
    selectedToken: i
  } = P3(), { address: o, additionalAddresses: s, isLedgerLive: a } = wt(), l = am();
  return J(
    () => G.fromRecord({
      address: G.fromNullable(o),
      selectedStake: e,
      selectedToken: i
    }).map((u) => {
      var f;
      const d = Je(u.selectedStake).chain((h) => {
        var m, g;
        const p = [...n.values()];
        return h.metadata.isIntegrationAggregator ? pt.head(p).map((v) => ({
          providerId: v.providerId
        })) : (g = (m = h.args.enter.args) == null ? void 0 : m.validatorAddresses) != null && g.required ? Je({
          validatorAddresses: p.map((v) => v.address)
        }) : pt.head(p).map((v) => v.address).map((v) => ({ validatorAddress: v }));
      }).orDefault({});
      return {
        selectedValidators: n,
        selectedStake: u.selectedStake,
        gasFeeToken: u.selectedStake.metadata.gasFeeToken,
        dto: {
          addresses: {
            address: u.address,
            additionalAddresses: s ?? void 0
          },
          integrationId: u.selectedStake.id,
          referralCode: (f = l.data) == null ? void 0 : f.code,
          args: {
            inputToken: u.selectedToken,
            ledgerWalletAPICompatible: a ?? void 0,
            tronResource: r.extract(),
            amount: t.toString(10),
            ...d
          }
        }
      };
    }),
    [
      s,
      o,
      a,
      (c = l.data) == null ? void 0 : c.code,
      e,
      i,
      n,
      t,
      r
    ]
  );
}, bN = Ge(
  void 0
), uge = ({ children: e }) => {
  var ee;
  const {
    actions: { onMaxClick: t },
    selectedToken: n,
    selectedStakeId: r,
    selectedValidators: i,
    stakeAmount: o,
    selectedStake: s,
    tronResource: a,
    stakeAmountGreaterThanAvailableAmount: l,
    stakeAmountGreaterThanMax: c,
    stakeAmountLessThanMin: u,
    stakeAmountIsZero: d,
    availableAmount: f,
    availableYields: h,
    hasNotYieldsForToken: p
  } = P3(), m = _ye(), { t: g } = ze(), v = Zd(s), { externalProviders: w } = bt(), { isConnected: x, isConnecting: C, isLedgerLiveAccountPlaceholder: S, chain: k } = wt(), A = _s(s).mapOrDefault(
    (Y) => Y.title,
    ""
  ), b = gN({
    selectedStake: s,
    selectedValidators: i,
    stakeAmount: o
  }), T = vN(s), R = J(
    () => s.chainNullable((Y) => Y.metadata.rewardTokens).map((Y) => Y.filter((j) => j.isPoints)),
    [s]
  ), B = Cy({
    token: n,
    yieldDto: s
  }), O = n.mapOrDefault((Y) => Y.symbol, ""), L = J(
    () => G.fromRecord({
      prices: G.fromNullable(B.data),
      selectedToken: n,
      baseToken: v
    }).map(
      (Y) => Uc({
        baseToken: Y.baseToken,
        amount: o,
        token: Y.selectedToken,
        prices: Y.prices,
        pricePerShare: null
      })
    ).mapOrDefault((Y) => `$${Xn(Y)}`, ""),
    [v, B.data, n, o]
  ), V = J(
    () => f.map((Y) => ({
      symbol: O,
      shortFormattedAmount: Xn(Y),
      fullFormattedAmount: Sn(Y),
      amount: Y
    })),
    [f, O]
  ), [N, M] = Oe(""), U = sh(N), [F, $] = Oe(""), ie = sh(F), [he, ae] = Oe(""), se = sh(he), oe = v3(h.orDefault([])), ye = n3(), ve = k3(), Be = J(
    () => G.fromRecord({
      defTb: G.fromNullable(ve.data).alt(G.of([])),
      tb: G.fromNullable(ye.data).alt(G.of([]))
    }).map((Y) => {
      const { tbWithAmount: j, tbWithoutAmount: te, tbSet: le } = Y.tb.reduce(
        (ge, me) => (ge.tbSet.add(dr(me.token)), new Re(me.amount).isGreaterThan(0) ? ge.tbWithAmount.push(me) : ge.tbWithoutAmount.push(me), ge),
        {
          tbSet: /* @__PURE__ */ new Set(),
          tbWithAmount: [],
          tbWithoutAmount: []
        }
      );
      return [
        ...j,
        ...te,
        ...Y.defTb.filter((ge) => !le.has(dr(ge.token)))
      ];
    }).chain(
      (Y) => G.of(ie).chain(
        (j) => j.length >= 1 ? G.of(j.toLowerCase()) : G.empty()
      ).map((j) => ({
        all: Y,
        filtered: Y.filter(
          (te) => te.token.name.toLowerCase().includes(j) || te.token.symbol.toLowerCase().includes(j)
        )
      })).alt(G.of({ all: Y, filtered: Y }))
    ),
    [ve.data, ie, ye.data]
  ), it = J(
    () => G.fromNullable(oe.data).alt(G.of([])).map((Y) => Y.toSorted((j, te) => te.apy - j.apy)).map((Y) => Y.filter((j) => j.apy > 0)).chain(
      (Y) => G.of(U).chain(
        (j) => j.length >= 1 ? G.of(j.toLowerCase()) : G.empty()
      ).map((j) => ({
        all: Y,
        filteredDtos: Y.filter(
          (te) => {
            var le;
            return te.token.name.toLowerCase().includes(j) || te.token.symbol.toLowerCase().includes(j) || te.metadata.name.toLowerCase().includes(j) || ((le = te.metadata.rewardTokens) == null ? void 0 : le.some(
              (ge) => ge.name.toLowerCase().includes(j) || ge.symbol.toLowerCase().includes(j)
            ));
          }
        )
      })).alt(G.of({ all: Y, filteredDtos: Y }))
    ).map(({ all: Y, filteredDtos: j }) => {
      const te = j.toSorted(
        (ge, me) => r4(ge) - r4(me)
      ), le = [
        ...te.reduce(
          (ge, me) => {
            const Ee = gR(me);
            return ge.has(Ee) ? ge.get(Ee).items.push(me) : ge.set(Ee, {
              type: Ee,
              title: vR(me, g).title,
              items: [me]
            }), ge;
          },
          /* @__PURE__ */ new Map()
        ).values()
      ].reduce(
        (ge, me) => {
          var Ee;
          return ge.set(me.type, {
            title: me.title,
            itemsLength: (((Ee = ge.get(me.type)) == null ? void 0 : Ee.itemsLength) ?? 0) + me.items.length
          }), ge;
        },
        /* @__PURE__ */ new Map()
      );
      return {
        all: Y,
        filtered: te,
        groupsWithCounts: le
      };
    }),
    [U, oe.data, g]
  ), lt = J(
    () => s.chain(
      (Y) => G.fromNullable(se).map((j) => j.toLowerCase()).map(
        (j) => Y.validators.filter(
          (te) => {
            var le;
            return ((le = te.name) == null ? void 0 : le.toLowerCase().includes(j)) || te.address.toLowerCase().includes(j);
          }
        )
      ).alt(G.of(Y.validators))
    ),
    [se, s]
  ), yt = (Y) => M(Y), gt = (Y) => $(Y), vt = (Y) => ae(Y), ot = Ie(
    (Y) => m({ type: "token/select", data: Y.token }),
    [m]
  ), Le = (Y) => {
    G.fromNullable(oe.data).chain((j) => pt.find((te) => te.id === Y, j)).ifJust((j) => m({ type: "yield/select", data: j }));
  }, tt = (Y) => s.ifJust(
    (j) => {
      var te, le;
      return (le = (te = j.args.enter.args) == null ? void 0 : te.validatorAddresses) != null && le.required ? m({ type: "validator/multiselect", data: Y }) : m({ type: "validator/select", data: Y });
    }
  ), jt = (Y) => m({ type: "validator/remove", data: Y }), rn = (Y) => m({ type: "stakeAmount/change", data: Y }), en = cge(), { openConnectModal: Gt } = by(), jn = lge(), tr = cm(), Ot = li({
    mutationFn: async () => {
      if (Cn.hasErrors) return;
      if (!x) return Gt == null ? void 0 : Gt();
      const Y = G.fromRecord({
        stakeEnterRequestDto: en,
        selectedToken: n
      }).unsafeCoerce();
      tr.send({
        type: "initFlow",
        data: {
          requestDto: Y.stakeEnterRequestDto.dto,
          selectedToken: Y.selectedToken,
          gasFeeToken: Y.stakeEnterRequestDto.gasFeeToken,
          selectedStake: Y.stakeEnterRequestDto.selectedStake,
          selectedValidators: Y.stakeEnterRequestDto.selectedValidators
        }
      }), jn("/review");
    }
  }), qt = Dt(Ot.reset);
  Te(() => {
    qt.current();
  }, [x, s, qt]);
  const Cn = J(() => {
    const Y = {
      submitted: !1,
      hasErrors: !1,
      errors: {
        tronResource: !1,
        stakeAmountGreaterThanAvailableAmount: !1,
        stakeAmountGreaterThanMax: !1,
        stakeAmountLessThanMin: !1,
        stakeAmountIsZero: !1
      }
    };
    return x && (s.ifJust((j) => {
      var te, le;
      (le = (te = j.args.enter.args) == null ? void 0 : te.tronResource) != null && le.required && a.isNothing() && (Y.errors.tronResource = !0);
    }), Y.errors = {
      ...Y.errors,
      stakeAmountGreaterThanAvailableAmount: l,
      stakeAmountGreaterThanMax: c,
      stakeAmountLessThanMin: u,
      stakeAmountIsZero: d
    }, Y.submitted = Ot.status !== "idle", Y.hasErrors = Object.values(Y.errors).some(Boolean)), Y;
  }, [
    x,
    Ot.status,
    s,
    l,
    c,
    d,
    u,
    a
  ]), Ve = J(
    () => s.chainNullable((Y) => {
      var j;
      return (j = Y.args.enter.args) == null ? void 0 : j.amount;
    }).filter((Y) => !Ac(Y)).chainNullable((Y) => Y.maximum),
    [s]
  ), nt = J(
    () => s.chainNullable((Y) => {
      var j;
      return (j = Y.args.enter.args) == null ? void 0 : j.amount;
    }).filter((Y) => !Ac(Y)).chainNullable((Y) => Y.minimum).filter((Y) => new Re(Y).isGreaterThan(0)),
    [s]
  ), je = () => M(""), st = () => $(""), tn = ef(), D = h3(), { state: E } = qo(), _ = Ay(
    (ee = s.extract()) == null ? void 0 : ee.id
  ).isLoading, q = am(), Z = n.isNothing() || !tn.data || q.isLoading || tn.isLoading || D.isLoading || C || !E.layout, re = oe.isLoading, pe = ye.isLoading, He = ve.isLoading, xt = oe.isFetching || ye.isFetching, St = !oe.data && oe.isError || !ye.data && ye.isError, Ct = x && (xt || en.isNothing()), Ze = _s(s).mapOrDefault(
    (Y) => Y.cta,
    ""
  ), Di = Uo({
    integrationData: s,
    validatorsAddresses: G.of(i)
  }), kn = cn(), hi = () => {
    kn("earnPageMaxClicked"), t();
  }, so = (Y) => m({
    type: "tronResource/select",
    data: Y
  }), ao = Dt(Ot.mutate), Go = wx(), lo = Dt(() => {
    if (S && k)
      return kn("addLedgerAccountClicked"), Go.mutate(k);
    kn("connectWalletClicked"), Gt == null || Gt();
  }), Mn = J(
    () => G.fromRecord({ selectedStake: s, selectedToken: n }).mapOrDefault(
      (Y) => $X({
        stakeToken: Y.selectedToken,
        yieldDto: Y.selectedStake
      }),
      !1
    ),
    [s, n]
  );
  Ga(
    J(
      () => x && !S ? {
        disabled: Ct,
        isLoading: xt,
        onClick: () => ao.current(),
        label: Ze
      } : w ? null : {
        disabled: Z,
        isLoading: Z,
        label: g(
          S ? "init.ledger_add_account" : "init.connect_wallet"
        ),
        onClick: () => lo.current()
      },
      [
        Z,
        Ze,
        Ct,
        lo,
        x,
        S,
        ao,
        w,
        xt,
        g
      ]
    )
  );
  const ji = pe || He, Mi = r.isNothing() && !p || re || _ || pe || He, co = He || pe || re || _, Ho = He || pe || re || _, { referralCheck: Ws } = bt(), Q = {
    referralCheck: Ws,
    selectedTokenAvailableAmount: V,
    formattedPrice: L,
    symbol: O,
    selectedStakeData: it,
    selectedStake: s,
    onYieldSelect: Le,
    onTokenBalanceSelect: ot,
    onStakeAmountChange: rn,
    estimatedRewards: b,
    yieldType: A,
    onMaxClick: hi,
    stakeAmount: o,
    isFetching: xt,
    buttonDisabled: Ct,
    onClick: Ot.mutate,
    onYieldSearch: yt,
    onValidatorSelect: tt,
    onValidatorRemove: jt,
    selectedValidators: i,
    isError: St,
    rewardToken: T,
    onSelectOpportunityClose: je,
    onSelectTokenClose: st,
    isConnected: x,
    appLoading: Z,
    yieldOpportunityLoading: _,
    multiYieldsLoading: re,
    tokenBalancesScanLoading: pe,
    tokenBalancesData: Be,
    onTokenSearch: gt,
    onValidatorSearch: vt,
    buttonCTAText: Ze,
    providersDetails: Di,
    tokenSearch: F,
    stakeSearch: N,
    defaultTokensIsLoading: He,
    isLedgerLiveAccountPlaceholder: S,
    tronResource: a,
    onTronResourceSelect: so,
    validation: Cn,
    pointsRewardTokens: R,
    selectTokenIsLoading: ji,
    selectYieldIsLoading: Mi,
    selectValidatorIsLoading: co,
    footerIsLoading: Ho,
    stakeMaxAmount: Ve,
    stakeMinAmount: nt,
    selectedToken: n,
    validatorsData: lt,
    validatorSearch: he,
    hasNotYieldsForToken: p,
    isStakeTokenSameAsGasToken: Mn
  };
  return /* @__PURE__ */ y.jsx(bN.Provider, { value: Q, children: e });
}, Fr = () => {
  const e = we(bN);
  if (!e)
    throw new Error("useEarnPageContext must be used within a EarnPageContext");
  return e;
}, dge = () => {
  const { selectedStake: e, tronResource: t, onTronResourceSelect: n, validation: r } = Fr(), { t: i } = ze();
  return e.chainNullable((o) => {
    var s;
    return (s = o.args.enter.args) == null ? void 0 : s.tronResource;
  }).map((o) => {
    const s = o.options.map((c) => ({
      label: c,
      value: c
    })), a = t.map((c) => ({ value: c, label: c })).extract(), l = r.submitted && r.errors.tronResource;
    return /* @__PURE__ */ y.jsxs(z, { children: [
      /* @__PURE__ */ y.jsx(z, { my: "2", children: /* @__PURE__ */ y.jsx(
        ue,
        {
          variant: {
            type: l ? "danger" : "regular"
          },
          children: i("details.tron_resources.label")
        }
      ) }),
      /* @__PURE__ */ y.jsx(
        age,
        {
          options: s,
          onSelect: (c) => n(c),
          selectedOption: a,
          placeholder: i("details.tron_resources.placeholder"),
          isError: l
        }
      ),
      /* @__PURE__ */ y.jsx(z, { marginTop: "3", children: /* @__PURE__ */ y.jsx(ti, {}) })
    ] });
  }).extractNullable();
}, fge = () => {
  const {
    appLoading: e,
    footerIsLoading: t,
    selectedStake: n,
    selectedValidators: r,
    selectedToken: i
  } = Fr();
  return /* @__PURE__ */ y.jsx(
    BB,
    {
      isLoading: e || t,
      selectedStake: n,
      selectedValidators: r,
      selectedToken: i
    }
  );
}, wN = ({
  color: e,
  hw: t = 24,
  className: n
}) => /* @__PURE__ */ y.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: t,
    height: t,
    fill: e ? zt.color[e] : zt.color.textMuted,
    viewBox: "0 0 256 256",
    className: n,
    children: /* @__PURE__ */ y.jsx("path", { d: "m232.49 80.49-128 128a12 12 0 0 1-17 0l-56-56a12 12 0 1 1 17-17L96 183 215.51 63.51a12 12 0 0 1 17 17Z" })
  }
), xN = ({
  hw: e = 24,
  className: t
}) => /* @__PURE__ */ y.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: e,
    height: e,
    fill: "#909090",
    viewBox: "0 0 256 256",
    className: t,
    children: /* @__PURE__ */ y.jsx("path", { d: "M216 28H88a12 12 0 0 0-12 12v36H40a12 12 0 0 0-12 12v128a12 12 0 0 0 12 12h128a12 12 0 0 0 12-12v-36h36a12 12 0 0 0 12-12V40a12 12 0 0 0-12-12Zm-60 176H52V100h104Zm48-48h-24V88a12 12 0 0 0-12-12h-68V52h104Z" })
  }
), $S = ({ address: e, network: t }) => `/v1/networks/${t}/addresses/${e}/referrals`, hge = ({
  address: e,
  network: t
}) => ["own-referral-code", t, e], pge = () => {
  const { address: e, network: t } = wt(), n = Fp(), { referralCheck: r } = bt();
  return Ut({
    enabled: !!(e && t && r),
    queryKey: hge({ address: e, network: t }),
    staleTime: Number.POSITIVE_INFINITY,
    queryFn: async () => (await de.liftEither(
      G.fromNullable(
        e && t ? { address: e, network: t } : null
      ).toEither(new Error("missing args"))
    ).chain(
      (i) => de(() => n.get($S(i))).chainLeft((o) => bL(o) ? de(
        () => n.post($S(i))
      ) : de.liftEither(Xe(o))).mapLeft(
        (o) => _o(o) ? o : new Error("unknown error")
      )
    ).map((i) => i.data)).unsafeCoerce()
  });
}, yge = () => {
  const { appLoading: e } = Fr(), t = pge(), n = e || t.isLoading, r = J(
    () => Tn.chain(
      (l) => G.fromNullable(t.data).map((c) => ({ data: c, w: l }))
    ).map((l) => `${l.w.location.origin}/?ref=${l.data.code}`).extractNullable(),
    [t.data]
  ), { t: i } = ze(), [o, s] = Oe(!1), a = (l) => {
    Tn.ifJust((c) => c.navigator.clipboard.writeText(l)), s(!0);
  };
  return Te(() => {
    if (!o) return;
    const l = setTimeout(() => s(!1), 1e3);
    return () => {
      clearTimeout(l);
    };
  }, [o]), n ? /* @__PURE__ */ y.jsx(z, { marginTop: "2", children: /* @__PURE__ */ y.jsx($o, { heightPx: 20, variant: { size: "medium" } }) }) : G.fromNullable(r).map((l) => /* @__PURE__ */ y.jsxs(
    z,
    {
      px: "3",
      py: "3",
      background: "backgroundMuted",
      borderRadius: "md",
      display: "flex",
      flexDirection: "column",
      children: [
        /* @__PURE__ */ y.jsx(z, { marginBottom: "3", children: /* @__PURE__ */ y.jsx(ue, { variant: { size: "medium" }, children: i("details.referral_code.title") }) }),
        /* @__PURE__ */ y.jsxs(
          z,
          {
            background: "background",
            px: "3",
            py: "3",
            borderRadius: "md",
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            as: "button",
            onClick: () => a(l),
            children: [
              /* @__PURE__ */ y.jsx(ue, { variant: { size: "large" }, children: l }),
              /* @__PURE__ */ y.jsx(Fy, { mode: "wait", children: /* @__PURE__ */ y.jsx(
                Zt.div,
                {
                  whileTap: { scale: o ? 1 : 0.9 },
                  initial: { opacity: 0 },
                  animate: { opacity: 1, transition: { duration: 0.05 } },
                  exit: { opacity: 0, transition: { duration: 0.05 } },
                  children: o ? /* @__PURE__ */ y.jsx(wN, { color: "positionsClaimRewardsBackground" }) : /* @__PURE__ */ y.jsx(xN, {})
                },
                o ? "copy" : "check"
              ) })
            ]
          }
        )
      ]
    }
  )).extractNullable();
}, CN = ({ onMaxClick: e, ...t }) => {
  const { t: n } = ze();
  return /* @__PURE__ */ y.jsx(
    z,
    {
      "data-rk": "stake-token-section-max-button",
      as: "button",
      borderRadius: "xl",
      background: "background",
      px: "2",
      py: "1",
      marginLeft: "2",
      onClick: e,
      className: Ly,
      ...t,
      children: /* @__PURE__ */ y.jsx(ue, { variant: { weight: "semibold", type: "regular" }, children: n("shared.max") })
    }
  );
}, kN = Ge(void 0), EN = ({ children: e, init: t }) => /* @__PURE__ */ y.jsx(kN.Provider, { value: Oe(t ?? "short"), children: e }), SN = ({ fullAmount: e, shortAmount: t, children: n }) => {
  const [r, i] = mge(), o = () => i(r === "full" ? "short" : "full");
  return /* @__PURE__ */ y.jsx(z, { as: "button", onClick: o, children: (n == null ? void 0 : n({ state: r })) ?? (r === "full" ? e : t) });
}, mge = () => {
  const e = we(kN);
  if (!e)
    throw new Error("useAmountContext must be used within a Root");
  return e;
};
var gge = "_1dlf2pf0", AN = "_1a682410", vge = "_1a682412 _1a682411 yv8y4r3j", bge = "_1a682413", WS = "_1a682414", wge = "_1a682415", xge = "_1a682417 _1a682416 yv8y4r2n yv8y4rfj yv8y4rg1 yv8y4rvt yv8y4rvu yv8y4r10", Cge = "_1a682419 _1a682418 yv8y4r10 yv8y4rvt yv8y4rvu yv8y4r2n yv8y4rfj yv8y4rg1", kge = "_1a68241b _1a68241a yv8y4r6j yv8y4r2n yv8y4rfx yv8y4rfl yv8y4r3l yv8y4rgd";
const Ege = Td(
  ({ item: e, isConnected: t, onTokenBalanceSelect: n }) => {
    const r = J(() => new Re(e.amount), [e.amount]), i = J(
      () => Xn(r),
      [r]
    ), o = J(
      () => r.isGreaterThan(0),
      [r]
    ), s = cn(), a = ({ closeModal: l }) => {
      s("tokenSelected", { token: e.token.symbol }), n(e), l();
    };
    return /* @__PURE__ */ y.jsx(gc, { children: /* @__PURE__ */ y.jsxs(
      Jy,
      {
        variant: o || !t ? { type: "enabled", hover: "enabled" } : { type: "disabled", hover: "enabled" },
        onItemClick: a,
        children: [
          /* @__PURE__ */ y.jsx(No, { token: e.token }),
          /* @__PURE__ */ y.jsxs(z, { display: "flex", flexDirection: "column", flex: 1, minWidth: "0", children: [
            /* @__PURE__ */ y.jsxs(
              z,
              {
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                gap: "2",
                children: [
                  /* @__PURE__ */ y.jsx(ue, { className: AN, variant: { weight: "bold" }, children: e.token.name }),
                  o && /* @__PURE__ */ y.jsx(ue, { children: i })
                ]
              }
            ),
            /* @__PURE__ */ y.jsx(
              z,
              {
                display: "flex",
                marginTop: "1",
                justifyContent: "space-between",
                alignItems: "center",
                children: /* @__PURE__ */ y.jsx(ue, { variant: { type: "muted" }, children: e.token.symbol })
              }
            )
          ] })
        ]
      }
    ) });
  }
), Sge = () => {
  const {
    onSelectTokenClose: e,
    onTokenBalanceSelect: t,
    tokenBalancesData: n,
    selectedToken: r,
    onTokenSearch: i,
    tokenSearch: o
  } = Fr(), s = cn(), { t: a } = ze(), { isConnected: l } = wt(), c = J(
    () => r.map((u) => ({
      st: u,
      tokenBalances: n.map((d) => d.filtered).extract() ?? []
    })).extractNullable(),
    [r, n]
  );
  return c ? /* @__PURE__ */ y.jsx(
    qs,
    {
      title: a("select_token.title"),
      onSearch: i,
      searchValue: o,
      onClose: e,
      onOpen: () => s("selectTokenModalOpened"),
      trigger: /* @__PURE__ */ y.jsx(mc, { asChild: !0, children: /* @__PURE__ */ y.jsxs(
        z,
        {
          as: "button",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          background: "background",
          borderRadius: "2xl",
          px: "2",
          py: "1",
          "data-testid": "select-token",
          className: Ly,
          children: [
            /* @__PURE__ */ y.jsxs(
              z,
              {
                marginRight: "2",
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                children: [
                  /* @__PURE__ */ y.jsx(No, { token: c.st }),
                  /* @__PURE__ */ y.jsx(ue, { variant: { weight: "bold" }, children: c.st.symbol })
                ]
              }
            ),
            /* @__PURE__ */ y.jsx($a, {})
          ]
        }
      ) }),
      children: /* @__PURE__ */ y.jsx(
        vx,
        {
          className: vge,
          data: c.tokenBalances,
          estimateSize: () => 60,
          itemContent: (u, d) => /* @__PURE__ */ y.jsx(
            Ege,
            {
              item: d,
              onTokenBalanceSelect: t,
              isConnected: l
            }
          )
        }
      )
    }
  ) : null;
}, TN = () => {
  const {
    appLoading: e,
    yieldType: t,
    selectTokenIsLoading: n,
    selectYieldIsLoading: r,
    selectValidatorIsLoading: i,
    footerIsLoading: o
  } = Fr(), s = e || n || r || i || o;
  return /* @__PURE__ */ y.jsx(z, { display: "flex", alignItems: "center", my: "1", children: s ? /* @__PURE__ */ y.jsx(z, { display: "flex", children: /* @__PURE__ */ y.jsx(ei, {}) }) : /* @__PURE__ */ y.jsx(ue, { children: t }) });
}, Age = () => {
  const { t: e } = ze(), { variant: t } = bt(), {
    appLoading: n,
    selectedTokenAvailableAmount: r,
    formattedPrice: i,
    onMaxClick: o,
    onStakeAmountChange: s,
    stakeAmount: a,
    validation: l,
    selectTokenIsLoading: c,
    stakeMaxAmount: u,
    stakeMinAmount: d,
    symbol: f,
    isStakeTokenSameAsGasToken: h
  } = Fr(), p = n || c, {
    submitted: m,
    errors: {
      stakeAmountGreaterThanAvailableAmount: g,
      stakeAmountGreaterThanMax: v,
      stakeAmountLessThanMin: w,
      stakeAmountIsZero: x
    }
  } = l, C = m && x || g || v || w, S = g, k = Je([
    d.map((A) => `${e("shared.min")} ${A} ${f}`).extractNullable(),
    u.map((A) => `${e("shared.max")} ${A} ${f}`).extractNullable()
  ]).filter((A) => A.some(Boolean)).map(([A, b]) => /* @__PURE__ */ y.jsx(
    z,
    {
      display: "flex",
      justifyContent: "flex-end",
      alignItems: "center",
      ...t === "default" && { marginRight: "2", marginTop: "2" },
      "data-rk": "stake-token-section-min-max",
      children: /* @__PURE__ */ y.jsx(
        ue,
        {
          variant: { type: w ? "danger" : "muted" },
          children: A && b ? `${A} / ${b}` : A ?? b
        },
        "min"
      )
    }
  )).extractNullable();
  return p ? /* @__PURE__ */ y.jsx(z, { marginTop: "2", children: /* @__PURE__ */ y.jsx($o, { heightPx: 112.5 }) }) : /* @__PURE__ */ y.jsxs(
    z,
    {
      "data-rk": "stake-token-section",
      background: "stakeSectionBackground",
      borderRadius: "xl",
      marginTop: "2",
      py: "4",
      px: "4",
      borderStyle: "solid",
      borderWidth: 1,
      borderColor: m && x ? "textDanger" : "transparent",
      children: [
        t === "zerion" && /* @__PURE__ */ y.jsxs(z, { display: "flex", justifyContent: "space-between", children: [
          /* @__PURE__ */ y.jsx(TN, {}),
          k
        ] }),
        /* @__PURE__ */ y.jsxs(z, { display: "flex", justifyContent: "space-between", alignItems: "center", children: [
          /* @__PURE__ */ y.jsx(z, { minWidth: "0", display: "flex", flex: 1, children: /* @__PURE__ */ y.jsx(
            v6,
            {
              shakeOnInvalid: !0,
              isInvalid: C,
              onChange: s,
              value: a
            }
          ) }),
          /* @__PURE__ */ y.jsx(z, { display: "flex", justifyContent: "center", alignItems: "center", children: /* @__PURE__ */ y.jsx(Sge, {}) })
        ] }),
        t === "default" && k,
        /* @__PURE__ */ y.jsxs(
          z,
          {
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            marginTop: "2",
            flexWrap: "wrap",
            "data-rk": "stake-token-section-balance",
            gap: "1",
            children: [
              /* @__PURE__ */ y.jsx(z, { className: gge, display: "flex", children: /* @__PURE__ */ y.jsx(ue, { variant: { type: "muted", weight: "normal" }, children: i }) }),
              /* @__PURE__ */ y.jsxs(
                z,
                {
                  flexGrow: 1,
                  display: "flex",
                  justifyContent: "space-between",
                  alignItems: "center",
                  children: [
                    /* @__PURE__ */ y.jsx(z, { display: "flex", children: /* @__PURE__ */ y.jsx(
                      ue,
                      {
                        variant: {
                          weight: "normal",
                          type: S ? "danger" : "muted"
                        },
                        "data-state": S ? "error" : "valid",
                        children: r.map(
                          (A) => t === "zerion" ? /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
                            /* @__PURE__ */ y.jsxs("span", { children: [
                              e("shared.balance"),
                              ": "
                            ] }),
                            /* @__PURE__ */ y.jsxs(
                              z,
                              {
                                ...h ? { as: "span" } : {
                                  onClick: o,
                                  as: "button"
                                },
                                children: [
                                  A.shortFormattedAmount,
                                  " ",
                                  A.symbol
                                ]
                              }
                            )
                          ] }) : /* @__PURE__ */ y.jsx(EN, { children: /* @__PURE__ */ y.jsx(SN, { children: ({ state: b }) => /* @__PURE__ */ y.jsxs("span", { children: [
                            b === "full" ? A.fullFormattedAmount : A.shortFormattedAmount,
                            " ",
                            A.symbol,
                            " ",
                            e("shared.available")
                          ] }) }) })
                        ).extractNullable()
                      }
                    ) }),
                    !h && /* @__PURE__ */ y.jsx(CN, { onMaxClick: o })
                  ]
                }
              )
            ]
          }
        )
      ]
    }
  );
}, _N = ({
  commission: e,
  stakedBalance: t,
  stakedBalanceToken: n,
  votingPower: r,
  address: i,
  rewardRate: o,
  rewardType: s,
  website: a
}) => {
  const { t: l } = ze();
  return J(
    () => ({
      rewardRate: o && s ? {
        title: FR(s),
        val: xs({
          rewardRate: o,
          rewardType: s
        })
      } : null,
      stakedBalance: t && n ? {
        title: l("details.validators_staked_balance"),
        val: Je(new Re(t)).filter((c) => !c.isNaN()).map(
          (c) => `${Sn(c, 0)} ${n.symbol}`
        ).orDefault("-")
      } : null,
      votingPower: r ? {
        title: l("details.validators_voting_power"),
        val: Je(new Re(r)).filter((c) => !c.isNaN()).map((c) => `${Kv(c.toNumber())}%`).orDefault("-")
      } : null,
      commission: e ? {
        title: l("details.validators_comission"),
        val: Je(new Re(e)).filter((c) => !c.isNaN()).map((c) => `${Sn(Kv(c.toNumber()))}%`).orDefault("-")
      } : null,
      address: i ? {
        title: l("details.validators_address"),
        val: Uh(i, { leadingChars: 6, trailingChars: 6 })
      } : null,
      website: a ? {
        title: l("details.validators_website"),
        val: /* @__PURE__ */ y.jsx(Wr, { href: a, children: Uh(a, {
          leadingChars: 16,
          trailingChars: 8
        }) })
      } : null
    }),
    [
      o,
      s,
      t,
      n,
      l,
      r,
      e,
      i,
      a
    ]
  );
};
var Tge = "_174mpfi1 _174mpfi0 yv8y4r3j", _ge = "_174mpfi4 _174mpfi3 yv8y4r6j _174mpfi2", IN = "_174mpfi6 _174mpfi5 yv8y4ru yv8y4rwp yv8y4rwq", Ige = "_174mpfi7";
const Rge = ({
  multiSelect: e,
  selectedValidators: t,
  onItemClick: n,
  onViewMoreClick: r,
  selectedStake: i,
  groupCounts: o,
  groupedItems: s,
  tableData: a
}) => {
  const { t: l } = ze();
  return /* @__PURE__ */ y.jsx(
    bx,
    {
      increaseViewportBy: { bottom: 50, top: 0 },
      estimateSize: () => 60,
      groupCounts: o,
      groupContent: (c) => s[c].label === "view_more" || !s[c].items.length ? null : /* @__PURE__ */ y.jsxs(
        z,
        {
          py: "4",
          px: "4",
          background: "modalBodyBackground",
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          children: [
            /* @__PURE__ */ y.jsx(ue, { variant: { weight: "medium" }, children: s[c].label }),
            /* @__PURE__ */ y.jsx(z, { marginRight: "4", children: /* @__PURE__ */ y.jsx(ue, { variant: { weight: "normal", type: "muted" }, children: FR(i.rewardType) }) })
          ]
        }
      ),
      className: Tge,
      itemContent: (c, u) => {
        var g;
        if (((g = s[u]) == null ? void 0 : g.label) === "view_more")
          return /* @__PURE__ */ y.jsx(z, { display: "flex", justifyContent: "center", marginTop: "6", children: /* @__PURE__ */ y.jsx(
            si,
            {
              variant: { color: "secondary", size: "small" },
              onClick: r,
              children: /* @__PURE__ */ y.jsx(ue, { children: l("details.validators_view_all") })
            }
          ) });
        const d = a[c], f = d.preferred, h = d.status, p = t.has(d.address), m = ({ closeModal: v }) => {
          n(d), !e && v();
        };
        return /* @__PURE__ */ y.jsx(gc, { children: /* @__PURE__ */ y.jsx(Jy, { onItemClick: m, testId: d.address, children: /* @__PURE__ */ y.jsxs(z, { flex: 1, display: "flex", flexDirection: "column", gap: "3", children: [
          /* @__PURE__ */ y.jsxs(z, { display: "flex", justifyContent: "center", alignItems: "center", children: [
            e && /* @__PURE__ */ y.jsx(
              z,
              {
                background: p ? "selectValidatorMultiSelectedBackground" : "selectValidatorMultiDefaultBackground",
                hw: "8",
                as: "button",
                borderRadius: "full",
                marginRight: "2",
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                children: t.has(d.address) ? /* @__PURE__ */ y.jsx(Eu, { hw: 16, color: zt.color.white }) : /* @__PURE__ */ y.jsx(y.Fragment, {})
              }
            ),
            /* @__PURE__ */ y.jsx(
              Ii,
              {
                containerProps: { hw: "9" },
                imageProps: { borderRadius: "full" },
                src: d.image,
                fallback: /* @__PURE__ */ y.jsx(
                  Vo,
                  {
                    name: d.name || d.address,
                    tokenLogoHw: "9",
                    textVariant: { type: "white", weight: "bold" }
                  }
                )
              }
            ),
            /* @__PURE__ */ y.jsx(
              z,
              {
                display: "flex",
                flexDirection: "column",
                flex: 1,
                marginLeft: "2",
                children: /* @__PURE__ */ y.jsxs(
                  z,
                  {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center",
                    children: [
                      /* @__PURE__ */ y.jsxs(z, { className: _ge, children: [
                        /* @__PURE__ */ y.jsx(ue, { variant: { weight: "bold" }, children: d.name ?? d.address }),
                        f && /* @__PURE__ */ y.jsx(z, { marginLeft: "1", display: "flex", children: /* @__PURE__ */ y.jsx(um, {}) }),
                        h !== "active" && /* @__PURE__ */ y.jsx(z, { marginLeft: "1", className: IN, children: /* @__PURE__ */ y.jsx(
                          ue,
                          {
                            variant: {
                              type: "white",
                              weight: "medium",
                              size: "small"
                            },
                            className: Ige,
                            children: l(
                              h === "jailed" ? "details.validators_jailed" : "details.validators_inactive"
                            )
                          }
                        ) })
                      ] }),
                      /* @__PURE__ */ y.jsx(z, { children: /* @__PURE__ */ y.jsx(ue, { variant: { size: "large" }, children: xs({
                        rewardRate: d.apr,
                        rewardType: i.rewardType
                      }) }) })
                    ]
                  }
                )
              }
            )
          ] }),
          /* @__PURE__ */ y.jsx(
            Pge,
            {
              address: d.address,
              commission: d.commission,
              stakedBalance: d.stakedBalance,
              votingPower: d.votingPower,
              rewardRate: void 0,
              rewardType: void 0,
              stakedBalanceToken: i.token,
              website: void 0
            }
          )
        ] }) }) });
      }
    }
  );
}, Pge = Td((e) => {
  const t = _N(e);
  return /* @__PURE__ */ y.jsx(z, { display: "flex", flexDirection: "column", gap: "1", children: Object.entries(t).filter(
    (n) => !!n[1]
  ).map(([n, r]) => /* @__PURE__ */ y.jsxs(
    z,
    {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      children: [
        /* @__PURE__ */ y.jsx(ue, { variant: { type: "muted" }, children: r.title }),
        /* @__PURE__ */ y.jsx(ue, { variant: { type: "muted", weight: "normal" }, children: r.val })
      ]
    },
    n
  )) });
}), RN = ({
  state: e,
  onClose: t,
  onOpen: n,
  trigger: r,
  selectedValidators: i,
  onItemClick: o,
  onViewMoreClick: s,
  validators: a,
  multiSelect: l,
  selectedStake: c,
  children: u,
  ...d
}) => {
  const { t: f } = ze(), [h, p] = Oe(!1), m = () => {
    s == null || s(), p(!0);
  }, g = () => {
    p(!1), t == null || t();
  }, v = !!l || h || d.searchValue, w = J(() => {
    if (!a.length)
      return {
        tableData: [],
        groupedItems: [],
        groupCounts: []
      };
    const C = a.reduce(
      (A, b) => (b.preferred ? A.preferred.items.push(b) : v && A.other.items.push(b), A),
      {
        preferred: {
          items: [],
          label: f("details.validators_preferred")
        },
        other: {
          items: [],
          label: f("details.validators_other")
        }
      }
    );
    if (!C.preferred.items.length && a.length)
      return {
        tableData: a,
        groupedItems: [
          {
            items: a,
            label: f("details.validators_other")
          }
        ],
        groupCounts: [a.length]
      };
    const S = !v && C.preferred.items.length !== a.length, k = Object.values(C);
    return {
      tableData: k.flatMap((A) => A.items),
      groupedItems: [
        ...k.filter((A) => !!A.items.length),
        ...S ? [{ items: [], label: "view_more" }] : []
      ],
      groupCounts: [
        ...k.filter((A) => !!A.items.length).map((A) => A.items.length),
        ...S ? [1] : []
      ]
    };
  }, [a, f, v]), x = d.onSearch ? {
    onSearch: d.onSearch,
    searchValue: d.searchValue
  } : {};
  return /* @__PURE__ */ y.jsxs(
    qs,
    {
      title: f("details.validator_search_title", {
        count: l ? 2 : 1
      }),
      onClose: g,
      onOpen: n,
      trigger: r,
      state: e,
      ...x,
      children: [
        /* @__PURE__ */ y.jsx(
          Rge,
          {
            ...w,
            selectedValidators: i,
            multiSelect: l,
            onItemClick: o,
            onViewMoreClick: m,
            selectedStake: c
          }
        ),
        u
      ]
    }
  );
}, Oge = (e) => /* @__PURE__ */ y.jsx(
  "svg",
  {
    viewBox: "0 0 24 24",
    width: e.hw ?? 24,
    height: e.hw ?? 24,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    transform: "rotate(45)",
    children: /* @__PURE__ */ y.jsx(
      "path",
      {
        d: "m18.75 5.25-13.5 13.5M18.75 18.75 5.25 5.25",
        stroke: e.color ? zt.color[e.color] : zt.color.textMuted,
        strokeWidth: e.strokeWidth ?? 2,
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    )
  }
), Bge = ({
  onRemoveValidator: e,
  multiSelect: t,
  selectedValidatorsArr: n
}) => {
  const { t: r } = ze();
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    /* @__PURE__ */ y.jsxs(
      z,
      {
        "data-rk": "select-validator-trigger-container",
        className: kge,
        children: [
          /* @__PURE__ */ y.jsx(z, { display: "flex", alignItems: "center", justifyContent: "center", children: /* @__PURE__ */ y.jsx(ue, { className: WS, variant: { weight: "bold" }, children: r("details.earn_with") }) }),
          (() => {
            const i = /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
              n.map((o) => {
                const s = o.name ?? o.address;
                return /* @__PURE__ */ y.jsx(z, { children: /* @__PURE__ */ y.jsxs(
                  z,
                  {
                    "data-rk": "select-validator-trigger",
                    className: xge,
                    children: [
                      /* @__PURE__ */ y.jsx(z, { marginRight: "2", children: /* @__PURE__ */ y.jsx(
                        Ii,
                        {
                          containerProps: { hw: "5" },
                          imageProps: { borderRadius: "full" },
                          src: o.image,
                          fallback: /* @__PURE__ */ y.jsx(z, { marginRight: "1", children: /* @__PURE__ */ y.jsx(
                            Vo,
                            {
                              name: s,
                              tokenLogoHw: "5",
                              textVariant: {
                                type: "white",
                                weight: "bold"
                              }
                            }
                          ) })
                        }
                      ) }),
                      /* @__PURE__ */ y.jsx(ue, { className: WS, variant: { weight: "bold" }, children: s }),
                      o.preferred && /* @__PURE__ */ y.jsx(z, { marginLeft: "1", display: "flex", children: /* @__PURE__ */ y.jsx(um, {}) }),
                      o.status !== "active" && /* @__PURE__ */ y.jsx(z, { marginLeft: "1", className: IN, children: /* @__PURE__ */ y.jsx(
                        ue,
                        {
                          variant: {
                            type: "white",
                            weight: "medium",
                            size: "small"
                          },
                          className: O0,
                          children: r(
                            o.status === "jailed" ? "details.validators_jailed" : "details.validators_inactive"
                          )
                        }
                      ) }),
                      t && n.length > 1 && /* @__PURE__ */ y.jsx(
                        z,
                        {
                          as: "button",
                          display: "flex",
                          marginLeft: "1",
                          onClick: () => e(o),
                          children: /* @__PURE__ */ y.jsx(Il, { hw: 12, strokeWidth: 4.9 })
                        }
                      )
                    ]
                  }
                ) }, o.address);
              }),
              t ? /* @__PURE__ */ y.jsx(z, { children: /* @__PURE__ */ y.jsx(mc, { asChild: !0, children: /* @__PURE__ */ y.jsx(
                z,
                {
                  "data-rk": "select-validator-plus",
                  as: "button",
                  className: Cge,
                  children: /* @__PURE__ */ y.jsx(Oge, { hw: 12, strokeWidth: 4.9 })
                }
              ) }) }) : /* @__PURE__ */ y.jsx(
                z,
                {
                  "data-rk": "select-validator-caret-down",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  children: /* @__PURE__ */ y.jsx($a, {})
                }
              )
            ] });
            return t ? i : /* @__PURE__ */ y.jsx(mc, { asChild: !0, children: /* @__PURE__ */ y.jsx(z, { as: "button", display: "flex", gap: "1", children: i }) });
          })()
        ]
      }
    ),
    /* @__PURE__ */ y.jsx(z, { marginTop: "3", children: /* @__PURE__ */ y.jsx(ti, {}) })
  ] });
}, Nge = () => {
  const {
    appLoading: e,
    onValidatorSelect: t,
    onValidatorRemove: n,
    selectedValidators: r,
    selectedStake: i,
    selectValidatorIsLoading: o,
    onValidatorSearch: s,
    validatorsData: a,
    validatorSearch: l
  } = Fr(), c = e || o, u = cn(), d = () => u("selectValidatorViewMoreClicked"), f = () => u("selectValidatorModalClosed"), h = () => u("selectValidatorModalOpened"), p = (g) => {
    u("validatorSelected", {
      validatorName: g.name,
      validatorAddress: g.address
    }), t(g);
  }, m = (g) => {
    u("validatorRemoved", {
      validatorName: g.name,
      validatorAddress: g.address
    }), n(g);
  };
  return c ? /* @__PURE__ */ y.jsx(z, { marginTop: "2", children: /* @__PURE__ */ y.jsx($o, { heightPx: 20, variant: { size: "medium" } }) }) : G.fromRecord({ selectedStake: i, validatorsData: a }).filter((g) => !!g.selectedStake.validators.length).map((g) => {
    var x, C;
    const v = [...r.values()], w = !!((C = (x = g.selectedStake.args.enter.args) == null ? void 0 : x.validatorAddresses) != null && C.required);
    return /* @__PURE__ */ y.jsx(
      RN,
      {
        trigger: /* @__PURE__ */ y.jsx(
          Bge,
          {
            onRemoveValidator: m,
            selectedValidatorsArr: v,
            multiSelect: w
          }
        ),
        selectedValidators: new Set(v.map((S) => S.address)),
        multiSelect: w,
        selectedStake: g.selectedStake,
        onItemClick: p,
        onViewMoreClick: d,
        onClose: f,
        onOpen: h,
        onSearch: s,
        searchValue: l,
        validators: g.validatorsData
      }
    );
  }).extractNullable();
}, PN = ({
  token: e,
  metadata: t,
  tokenLogoHw: n,
  tokenNetworkLogoHw: r,
  hideNetwork: i
}) => {
  const { hideNetworkLogo: o } = bt();
  return /* @__PURE__ */ y.jsx(
    x6,
    {
      hideNetwork: i,
      token: e,
      metadata: t,
      children: ({ fallbackUrl: s, mainUrl: a, name: l, networkLogoUri: c, providerIcon: u }) => /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
        /* @__PURE__ */ y.jsx(
          C6,
          {
            fallbackUrl: s,
            mainUrl: u,
            name: l,
            tokenLogoHw: n
          }
        ),
        !i && !o && /* @__PURE__ */ y.jsx(
          w6,
          {
            networkLogoUri: a || c,
            tokenNetworkLogoHw: r
          }
        )
      ] })
    }
  );
}, Dge = ({
  item: e,
  index: t
}) => {
  const { onYieldSelect: n } = Fr(), r = cn(), i = ({
    closeModal: o
  }) => {
    r("yieldSelected", { yield: e.id }), n(e.id), o();
  };
  return /* @__PURE__ */ y.jsxs(
    Jy,
    {
      testId: `select-opportunity__item_${e.id}-${t}`,
      onItemClick: i,
      children: [
        /* @__PURE__ */ y.jsx(PN, { metadata: e.metadata, token: e.token }),
        /* @__PURE__ */ y.jsxs(
          z,
          {
            display: "flex",
            flexDirection: "column",
            flex: 1,
            marginLeft: "2",
            minWidth: "0",
            children: [
              /* @__PURE__ */ y.jsxs(
                z,
                {
                  display: "flex",
                  justifyContent: "space-between",
                  alignItems: "center",
                  gap: "2",
                  children: [
                    /* @__PURE__ */ y.jsx(z, { children: /* @__PURE__ */ y.jsx(ue, { className: AN, variant: { weight: "bold" }, children: e.metadata.name }) }),
                    /* @__PURE__ */ y.jsx(z, { children: /* @__PURE__ */ y.jsx(ue, { children: xs({
                      rewardRate: e.rewardRate,
                      rewardType: e.rewardType
                    }) }) })
                  ]
                }
              ),
              /* @__PURE__ */ y.jsxs(z, { display: "flex", marginTop: "1", flexWrap: "wrap", gap: "1", children: [
                /* @__PURE__ */ y.jsx(ue, { variant: { type: "muted" }, children: G.fromNullable(e.metadata.rewardTokens).map((o) => o.map((s) => s.symbol).join(", ")).orDefault(e.token.symbol) }),
                G.fromNullable(e.metadata.rewardTokens).map(() => /* @__PURE__ */ y.jsx(z, { background: "background", borderRadius: "2xl", px: "2", children: /* @__PURE__ */ y.jsx(ue, { variant: { type: "muted" }, children: e.token.symbol }) })).extractNullable()
              ] })
            ]
          }
        )
      ]
    }
  );
}, jge = () => {
  const {
    selectedStake: e,
    selectedStakeData: t,
    onSelectOpportunityClose: n,
    onYieldSearch: r,
    stakeSearch: i
  } = Fr(), o = cn(), { t: s } = ze(), a = J(
    () => t.chain(
      (l) => e.map((c) => {
        const u = [...l.groupsWithCounts.values()];
        return {
          ss: c,
          all: l.filtered,
          groups: u.map((d) => d.title),
          groupCounts: u.map((d) => d.itemsLength)
        };
      })
    ).extractNullable(),
    [e, t]
  );
  return a ? /* @__PURE__ */ y.jsx(
    qs,
    {
      title: s("details.opportunity_search_title"),
      onSearch: r,
      searchValue: i,
      onClose: n,
      onOpen: () => o("selectYieldModalOpened"),
      trigger: /* @__PURE__ */ y.jsx(mc, { asChild: !0, children: /* @__PURE__ */ y.jsxs(
        z,
        {
          as: "button",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          background: "background",
          borderRadius: "2xl",
          px: "2",
          py: "1",
          "data-testid": "select-opportunity",
          className: Ly,
          children: [
            /* @__PURE__ */ y.jsxs(
              z,
              {
                marginRight: "2",
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                children: [
                  /* @__PURE__ */ y.jsx(PN, { token: a.ss.token, metadata: a.ss.metadata }),
                  /* @__PURE__ */ y.jsx(ue, { variant: { weight: "bold" }, children: a.ss.token.symbol })
                ]
              }
            ),
            /* @__PURE__ */ y.jsx($a, {})
          ]
        }
      ) }),
      children: /* @__PURE__ */ y.jsx(
        bx,
        {
          estimateSize: () => 60,
          groupCounts: a.groupCounts,
          groupContent: (l) => /* @__PURE__ */ y.jsx(z, { py: "4", px: "4", background: "modalBodyBackground", children: /* @__PURE__ */ y.jsx(ue, { variant: { weight: "bold" }, children: a.groups[l] }) }),
          itemContent: (l) => {
            const c = a.all[l];
            return /* @__PURE__ */ y.jsx(gc, { children: typeof c == "string" ? /* @__PURE__ */ y.jsx(z, { py: "4", children: /* @__PURE__ */ y.jsx(ue, { variant: { weight: "bold" }, children: c }) }) : /* @__PURE__ */ y.jsx(Dge, { index: l, item: c }) });
          }
        }
      )
    }
  ) : null;
}, ON = () => /* @__PURE__ */ y.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 15 14",
    fill: "none",
    color: "#2470FFe6",
    children: /* @__PURE__ */ y.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M4.79.7a.7.7 0 1 0-1.4 0c0 .21-.112.478-.342.708-.23.23-.498.342-.708.342a.7.7 0 0 0 0 1.4c.21 0 .478.112.708.342.23.23.342.498.342.708a.7.7 0 0 0 1.4 0c0-.21.112-.478.342-.708.23-.23.498-.342.708-.342a.7.7 0 1 0 0-1.4c-.202 0-.47-.113-.705-.35C4.9 1.16 4.79.89 4.79.7Zm5.6 2.1a.7.7 0 0 1 .7.7c0 .527.284 1.147.783 1.652.497.504 1.115.798 1.667.798a.7.7 0 1 1 0 1.4c-.56 0-1.178.287-1.67.78-.493.492-.78 1.11-.78 1.67a.7.7 0 1 1-1.4 0c0-.56-.287-1.178-.78-1.67-.492-.493-1.11-.78-1.67-.78a.7.7 0 1 1 0-1.4c.56 0 1.178-.287 1.67-.78.493-.492.78-1.11.78-1.67a.7.7 0 0 1 .7-.7Zm-7 4.9a.7.7 0 0 1 .7.7c0 .359.196.804.564 1.176.366.37.81.574 1.186.574a.7.7 0 1 1 0 1.4c-.385 0-.828.2-1.19.56-.36.362-.56.805-.56 1.19a.7.7 0 1 1-1.4 0c0-.385-.2-.828-.56-1.19-.361-.36-.805-.56-1.19-.56a.7.7 0 1 1 0-1.4c.385 0 .829-.2 1.19-.56.36-.362.56-.805.56-1.19a.7.7 0 0 1 .7-.7Z",
        clipRule: "evenodd"
      }
    )
  }
);
var Mge = "_10xz6vc1 _10xz6vc0 yv8y4r2t yv8y4rrd yv8y4rre";
const Fge = ({
  rewardToken: e,
  ...t
}) => {
  const n = t.type === "stake" ? "details.reward_token" : t.type === "pendingAction" ? `pending_action_review.pending_action_type.${t.pendingAction.toLowerCase()}` : "unstake_review.unstake_from";
  return e.map((r) => /* @__PURE__ */ y.jsx(y.Fragment, { children: /* @__PURE__ */ y.jsxs(z, { display: "flex", alignItems: "center", gap: "2", children: [
    G.fromNullable(r.logoUri).filter(() => BN(r.providerName)).map((i) => /* @__PURE__ */ y.jsxs(
      z,
      {
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        gap: "1",
        alignSelf: "flex-start",
        children: [
          /* @__PURE__ */ y.jsx(
            Ii,
            {
              imageProps: { borderRadius: "full" },
              containerProps: { hw: "5" },
              src: i,
              fallback: /* @__PURE__ */ y.jsx(Vo, { name: r.providerName, tokenLogoHw: "5" })
            }
          ),
          /* @__PURE__ */ y.jsx(z, { width: "5", height: "5", children: /* @__PURE__ */ y.jsx(ON, {}) })
        ]
      }
    )).extractNullable(),
    /* @__PURE__ */ y.jsx(ue, { variant: { weight: "semibold" }, children: /* @__PURE__ */ y.jsx(
      Wn,
      {
        i18nKey: n,
        values: { providerName: r.providerName },
        components: {
          symbols1: /* @__PURE__ */ y.jsx(y.Fragment, { children: r.symbols }),
          highlight2: /* @__PURE__ */ y.jsx(
            ue,
            {
              as: "span",
              className: Mge,
              variant: { type: "muted", weight: "medium" }
            }
          )
        }
      }
    ) })
  ] }) })).extractNullable();
}, BN = (e) => /morpho/i.test(e), GS = () => {
  const { t: e } = ze(), { variant: t } = bt(), { rewardToken: n, estimatedRewards: r, symbol: i } = Fr(), o = r.mapOrDefault(
    (a) => `${a.yearly} ${i}`,
    ""
  ), s = r.mapOrDefault(
    (a) => `${a.monthly} ${i}`,
    ""
  );
  return /* @__PURE__ */ y.jsxs(z, { "data-rk": "yield-rewards", children: [
    t === "default" && /* @__PURE__ */ y.jsx(z, { marginTop: "3", children: /* @__PURE__ */ y.jsx(Fge, { rewardToken: n, type: "stake" }) }),
    /* @__PURE__ */ y.jsxs(z, { display: "flex", flexDirection: "column", gap: "2", marginTop: "3", children: [
      t === "zerion" && n.map((a) => /* @__PURE__ */ y.jsxs(
        z,
        {
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          gap: "2",
          children: [
            /* @__PURE__ */ y.jsx(ue, { variant: { type: "muted", weight: "normal" }, children: /* @__PURE__ */ y.jsx(
              Wn,
              {
                i18nKey: "details.rewards.receive",
                components: {
                  symbols1: /* @__PURE__ */ y.jsx(z, { as: "span", fontWeight: "bold", children: a.symbols })
                }
              }
            ) }),
            /* @__PURE__ */ y.jsxs(
              z,
              {
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                flexShrink: 0,
                children: [
                  a.logoUri && /* @__PURE__ */ y.jsxs(
                    z,
                    {
                      marginRight: "1",
                      display: "flex",
                      justifyContent: "center",
                      alignItems: "center",
                      gap: "1",
                      children: [
                        /* @__PURE__ */ y.jsx(
                          Ii,
                          {
                            imageProps: { borderRadius: "full" },
                            containerProps: { hw: "5" },
                            src: a.logoUri,
                            fallback: /* @__PURE__ */ y.jsx(
                              Vo,
                              {
                                name: a.providerName,
                                tokenLogoHw: "5"
                              }
                            )
                          }
                        ),
                        BN(a.providerName) && /* @__PURE__ */ y.jsx(z, { width: "5", height: "5", children: /* @__PURE__ */ y.jsx(ON, {}) })
                      ]
                    }
                  ),
                  /* @__PURE__ */ y.jsx(ue, { variant: { type: "muted", weight: "normal" }, children: a.providerName })
                ]
              }
            )
          ]
        }
      )).extractNullable(),
      /* @__PURE__ */ y.jsxs(
        z,
        {
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          "data-testid": "estimated-reward__yearly",
          "data-rk": "estimated-reward__yearly",
          gap: "2",
          children: [
            /* @__PURE__ */ y.jsx(ue, { variant: { type: "muted", weight: "normal" }, children: e(
              t === "zerion" ? "details.rewards.yearly" : "shared.yearly"
            ) }),
            /* @__PURE__ */ y.jsx(ue, { variant: { type: "muted", weight: "normal" }, children: o })
          ]
        }
      ),
      /* @__PURE__ */ y.jsxs(
        z,
        {
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          "data-testid": "estimated-reward__monthly",
          "data-rk": "estimated-reward__monthly",
          gap: "2",
          children: [
            /* @__PURE__ */ y.jsx(ue, { variant: { type: "muted", weight: "normal" }, children: e("shared.monthly") }),
            /* @__PURE__ */ y.jsx(ue, { variant: { type: "muted", weight: "normal" }, children: s })
          ]
        }
      )
    ] })
  ] });
}, Lge = (e) => {
  const t = e.map((i) => {
    const o = Number.parseFloat(i.percentage);
    return Number.isNaN(o) ? i.percentage : o;
  }).extractNullable(), n = bO(0);
  Te(() => {
    if (t === null || typeof t == "string")
      return n.set(0);
    t !== n.get() && Noe(n, t, {
      duration: 0.8,
      ease: "easeInOut"
    });
  }, [t, n]);
  const r = hoe(
    n,
    (i) => `${i.toFixed(2)}%`
  );
  return typeof t == "string" ? t : r;
}, Uge = () => {
  const {
    appLoading: e,
    selectedStakeData: t,
    estimatedRewards: n,
    selectedStake: r,
    selectYieldIsLoading: i
  } = Fr(), { variant: o } = bt(), { t: s } = ze(), a = e || i, l = Lge(n);
  return a ? /* @__PURE__ */ y.jsx(z, { marginTop: "2", children: /* @__PURE__ */ y.jsx($o, { heightPx: 112.5 }) }) : t.map((c) => c.all.length === 0 ? /* @__PURE__ */ y.jsx(
    z,
    {
      my: "4",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      children: /* @__PURE__ */ y.jsx(ue, { children: s("details.no_opportunities") })
    }
  ) : /* @__PURE__ */ y.jsxs(z, { children: [
    o === "default" && /* @__PURE__ */ y.jsx(z, { my: "2", children: /* @__PURE__ */ y.jsx(ue, { children: s("details.earn") }) }),
    /* @__PURE__ */ y.jsxs(
      z,
      {
        "data-rk": "stake-yield-section",
        background: "stakeSectionBackground",
        borderRadius: "xl",
        marginTop: "2",
        py: "4",
        px: "4",
        children: [
          o === "zerion" && /* @__PURE__ */ y.jsx(z, { my: "1", children: /* @__PURE__ */ y.jsx(ue, { children: s("details.earn") }) }),
          /* @__PURE__ */ y.jsxs(
            z,
            {
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              children: [
                /* @__PURE__ */ y.jsx(z, { minWidth: "0", display: "flex", marginRight: "2", flex: 1, children: /* @__PURE__ */ y.jsxs(
                  z,
                  {
                    position: "relative",
                    "data-testid": "estimated-reward__percent",
                    children: [
                      r.filter((u) => u.rewardType === "variable").map(() => /* @__PURE__ */ y.jsx(
                        wd,
                        {
                          asChild: !0,
                          maxWidth: 160,
                          label: s("details.reward_rate_estimate_tooltip"),
                          children: /* @__PURE__ */ y.jsx(z, { className: wge, children: /* @__PURE__ */ y.jsx(ue, { variant: { size: "large" }, children: "*" }) })
                        }
                      )).extractNullable(),
                      /* @__PURE__ */ y.jsx(Zt.div, { className: bge, children: l })
                    ]
                  }
                ) }),
                /* @__PURE__ */ y.jsx(z, { display: "flex", justifyContent: "center", alignItems: "center", children: /* @__PURE__ */ y.jsx(jge, {}) })
              ]
            }
          ),
          o === "default" && /* @__PURE__ */ y.jsx(GS, {})
        ]
      }
    ),
    o === "zerion" && /* @__PURE__ */ y.jsxs(z, { display: "flex", flexDirection: "column", gap: "3", children: [
      /* @__PURE__ */ y.jsx(GS, {}),
      /* @__PURE__ */ y.jsx(ti, {})
    ] })
  ] })).extractNullable();
}, zge = () => {
  const { selectedStake: e, appLoading: t } = Fr(), { t: n } = ze();
  return t ? null : e.filter(
    (r) => !!(r.metadata.type === "staking" && !r.validators.length && r.metadata.provider)
  ).chainNullable((r) => r.metadata.provider).map((r) => /* @__PURE__ */ y.jsxs(
    z,
    {
      display: "flex",
      justifyContent: "flex-start",
      alignItems: "center",
      marginTop: "2",
      gap: "2",
      "data-rk": "stake-token-section-staked-via",
      children: [
        /* @__PURE__ */ y.jsxs(ue, { variant: { type: "regular", size: "medium" }, children: [
          n("details.earn_with"),
          " ",
          /* @__PURE__ */ y.jsx(z, { as: "span", fontWeight: "bold", children: r.name })
        ] }),
        /* @__PURE__ */ y.jsx(
          Ii,
          {
            containerProps: { hw: "7" },
            src: r.logoURI,
            fallback: /* @__PURE__ */ y.jsx(Vo, { name: r.name, tokenLogoHw: "7" })
          }
        )
      ]
    }
  )).extractNullable();
}, Vge = () => {
  Vn("earn");
  const { t: e } = ze(), { variant: t } = bt(), { referralCheck: n, isError: r } = Fr(), { mountAnimationFinished: i, dispatch: o } = qo(), { disableInitLayoutAnimation: s } = bt(), { animate: a, initial: l } = Je({
    opacity: 1,
    translateY: 0
  }).chain(
    (c) => Je(null).map(() => i ? {
      transition: { duration: 0.3, delay: 0 },
      initial: { opacity: 0, translateY: "-10px" }
    } : s ? {
      transition: { duration: 0 },
      initial: { opacity: 1, translateY: 0 }
    } : {
      transition: { duration: 1, delay: 0.8 },
      initial: { opacity: 0, translateY: "-40px" }
    }).map((u) => ({
      animate: { ...c, transition: u.transition },
      initial: u.initial
    }))
  ).unsafeCoerce();
  return /* @__PURE__ */ y.jsx(
    Zt.div,
    {
      initial: l,
      animate: a,
      onAnimationComplete: (c) => {
        c.translateY !== 0 || i || o({ type: "earnPage" });
      },
      children: /* @__PURE__ */ y.jsxs($s, { children: [
        /* @__PURE__ */ y.jsxs(z, { children: [
          t === "default" && /* @__PURE__ */ y.jsx(TN, {}),
          /* @__PURE__ */ y.jsx(y3, {}),
          /* @__PURE__ */ y.jsx(Age, {}),
          /* @__PURE__ */ y.jsx(Uge, {}),
          /* @__PURE__ */ y.jsx(zge, {}),
          /* @__PURE__ */ y.jsx(Nge, {}),
          /* @__PURE__ */ y.jsx(dge, {})
        ] }),
        r && /* @__PURE__ */ y.jsx(
          z,
          {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            my: "4",
            children: /* @__PURE__ */ y.jsx(ue, { variant: { type: "danger" }, textAlign: "center", children: e("shared.something_went_wrong") })
          }
        ),
        /* @__PURE__ */ y.jsx(z, { marginTop: "4", children: /* @__PURE__ */ y.jsx(fge, {}) }),
        n && /* @__PURE__ */ y.jsx(z, { marginTop: "4", children: /* @__PURE__ */ y.jsx(yge, {}) })
      ] })
    }
  );
}, qge = () => /* @__PURE__ */ y.jsx(Aye, { children: /* @__PURE__ */ y.jsx(uge, { children: /* @__PURE__ */ y.jsx(Vge, {}) }) });
var $ge = "_1b4p78a0", Wge = "_1b4p78a2 _1b4p78a1 yv8y4re5 yv8y4rcn yv8y4r9l yv8y4rb3", Gge = "_1b4p78a7 _1b4p78a6 yv8y4ri7 yv8y4rgp yv8y4r10 yv8y4r2n yv8y4rg1 yv8y4rfj yv8y4r1 yv8y4rwp yv8y4rwq", Hge = "_1b4p78a8", Kge = "_1b4p78aa _1b4p78a9 yv8y4rw5 yv8y4rw6 yv8y4r10 yv8y4r1";
const gv = ({
  isSelected: e,
  variant: t,
  pendingActionsCount: n,
  onTabPress: r
}) => {
  const { t: i } = ze();
  return /* @__PURE__ */ y.jsxs(z, { className: $ge, children: [
    /* @__PURE__ */ y.jsx(z, { className: wr([Ly, Wge]), onClick: r, children: /* @__PURE__ */ y.jsxs(
      z,
      {
        ...t === "positions" && { position: "relative" },
        display: "inline-flex",
        children: [
          /* @__PURE__ */ y.jsx(
            ue,
            {
              "data-state": e ? "selected" : "default",
              variant: { type: e ? "regular" : "muted" },
              children: i(`details.tabs.${t}`, t)
            }
          ),
          !!n && /* @__PURE__ */ y.jsx(z, { className: Gge, children: /* @__PURE__ */ y.jsx(ue, { style: { fontSize: 8 }, children: n }) })
        ]
      }
    ) }),
    e ? /* @__PURE__ */ y.jsx(
      Zt.div,
      {
        className: Kge,
        layoutId: "underline",
        transition: { duration: 0.15 }
      }
    ) : null
  ] });
}, Yge = ({
  selectedTab: e,
  onTabPress: t,
  pendingActionsCount: n
}) => {
  const { state: r } = qo(), { disableInitLayoutAnimation: i } = bt(), { animate: o, initial: s } = Je({ opacity: 1, translateY: 0 }).chain(
    (a) => Je(null).map(() => r.layout || i ? {
      transition: { duration: 0 },
      initial: { opacity: 1, translateY: 0 }
    } : {
      transition: { duration: 1, delay: 0.5 },
      initial: { opacity: 0, translateY: "-40px" }
    }).map((l) => ({
      animate: { ...a, transition: l.transition },
      initial: l.initial
    }))
  ).unsafeCoerce();
  return /* @__PURE__ */ y.jsx(Zt.div, { initial: s, animate: o, children: /* @__PURE__ */ y.jsxs(z, { position: "relative", display: "flex", justifyContent: "center", children: [
    /* @__PURE__ */ y.jsxs(
      z,
      {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        "data-rk": "tabs-section",
        zIndex: "simple",
        children: [
          /* @__PURE__ */ y.jsx(
            gv,
            {
              isSelected: e === "earn",
              onTabPress: () => t("earn"),
              variant: "earn"
            }
          ),
          /* @__PURE__ */ y.jsx(
            gv,
            {
              isSelected: e === "positions",
              onTabPress: () => t("positions"),
              variant: "positions",
              pendingActionsCount: n
            }
          ),
          /* @__PURE__ */ y.jsx(
            gv,
            {
              isSelected: e === "activity",
              onTabPress: () => t("activity"),
              variant: "activity"
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ y.jsx(z, { className: Hge, children: /* @__PURE__ */ y.jsx(ti, {}) })
  ] }) });
}, Qge = {
  earn: "/",
  positions: "/positions",
  activity: "/activity"
}, Jge = () => {
  const e = cn(), { positionsData: t } = g3(), n = J(
    () => t.data.reduce((l, c) => c.hasPendingClaimRewards || c.actionRequired ? l + 1 : l, 0),
    [t.data]
  ), { current: r } = gx(), i = er(), [o, s] = Oe("earn");
  r.pathname === "/" && o === "positions" ? s("earn") : r.pathname === "/positions" && o === "earn" ? s("positions") : r.pathname === "/activity" && o === "earn" && s("activity");
  const a = (l) => {
    o !== l && (e("tabClicked", { selected: l }), s(l), i(Qge[l]));
  };
  return /* @__PURE__ */ y.jsx(
    Zt.div,
    {
      exit: { opacity: 0, filter: "blur(8px)", scale: 0.8 },
      transition: { exit: { duration: 0.4 } },
      children: /* @__PURE__ */ y.jsxs(z, { flex: 1, display: "flex", flexDirection: "column", children: [
        /* @__PURE__ */ y.jsx(z, { marginBottom: "1", children: /* @__PURE__ */ y.jsx(
          Yge,
          {
            onTabPress: a,
            selectedTab: o,
            pendingActionsCount: n
          }
        ) }),
        /* @__PURE__ */ y.jsx(z, { display: "flex", flex: 1, flexDirection: "column", children: /* @__PURE__ */ y.jsx(nx, {}) })
      ] })
    }
  );
}, Xge = () => {
  const e = cm(), t = fr(
    e,
    (L) => L.context.data
  ).unsafeCoerce(), n = t.requestDto.integrationId, r = rw(n), i = J(
    () => new Re(t.requestDto.args.amount),
    [t]
  ), o = jL(
    t.requestDto,
    { query: { staleTime: 0, gcTime: 0 } }
  ), s = J(
    () => {
      var L;
      return G.fromNullable((L = o.data) == null ? void 0 : L.amount).map(Re);
    },
    [o.data]
  ), a = Px({
    gasAmount: s,
    gasFeeToken: t.gasFeeToken,
    address: t.requestDto.addresses.address,
    additionalAddresses: t.requestDto.addresses.additionalAddresses,
    isStake: !0,
    stakeAmount: i,
    stakeToken: t.selectedToken
  }), l = J(
    () => G.of(t.selectedStake),
    [t.selectedStake]
  ), c = J(
    () => G.of(t.selectedToken),
    [t.selectedToken]
  ), u = vN(l), d = gN({
    selectedStake: l,
    stakeAmount: i,
    selectedValidators: t.selectedValidators
  }), f = _s(l).mapOrDefault(
    (L) => L.review,
    ""
  ), h = J(() => Sn(i), [i]), p = J(
    () => d.mapOrDefault((L) => L.percentage.toString(), ""),
    [d]
  ), m = Cy({
    token: c,
    yieldDto: l
  }), g = J(
    () => b1({
      gas: s,
      prices: G.fromNullable(m.data),
      yieldDto: l
    }),
    [m.data, l, s]
  ), { depositFee: v, managementFee: w, performanceFee: x } = Bx({
    amount: i,
    token: c,
    feeConfigDto: J(
      () => G.fromNullable(r.data),
      [r.data]
    ),
    prices: J(
      () => G.fromNullable(m.data),
      [m.data]
    )
  }), C = l.map((L) => L.metadata), S = er(), k = RL(), A = li({
    mutationFn: async () => (await Kn({
      fn: () => k(t.requestDto)
    }).mapLeft((L) => {
      var V;
      return _o(L) && j0.isStakingNotAllowedErrorDto(
        (V = L.response) == null ? void 0 : V.data
      ) ? new j0() : new Error("Stake enter error");
    }).chain(
      (L) => de.liftEither(d1(L))
    )).unsafeCoerce(),
    onSuccess: (L) => {
      e.send({ type: "setActionDto", data: L }), S("/steps");
    }
  }), T = Dt(() => A.mutate()), { t: R } = ze();
  Ga(
    J(
      () => ({
        disabled: !1,
        isLoading: A.isPending,
        label: R("shared.confirm"),
        onClick: () => T.current()
      }),
      [T, R, A.isPending]
    )
  );
  const { variant: B } = bt(), O = J(
    () => B === "zerion" ? {
      showMetaInfo: !0,
      metaInfoProps: {
        selectedStake: l,
        selectedToken: c,
        selectedValidators: t.selectedValidators
      }
    } : { showMetaInfo: !1 },
    [l, c, t.selectedValidators, B]
  );
  return {
    token: c,
    amount: h,
    fee: g,
    interestRate: p,
    yieldType: f,
    rewardToken: u,
    metadata: C,
    metaInfo: O,
    isGasCheckWarning: !!a.data,
    gasCheckLoading: o.isLoading || a.isLoading,
    depositFee: v,
    managementFee: w,
    performanceFee: x,
    feeConfigLoading: r.isPending
  };
};
class j0 extends Error {
  constructor() {
    super("Staking not allowed, needs unstaking and trying again");
  }
}
pr(j0, "isStakingNotAllowedErrorDto", (t) => {
  const n = t;
  return n && n.code === 422 && n.type === "STAKING_ERROR";
});
const Zge = () => {
  Vn("stakeReview");
  const {
    fee: e,
    yieldType: t,
    amount: n,
    interestRate: r,
    metadata: i,
    rewardToken: o,
    token: s,
    metaInfo: a,
    gasCheckLoading: l,
    isGasCheckWarning: c,
    depositFee: u,
    managementFee: d,
    performanceFee: f,
    feeConfigLoading: h
  } = Xge(), p = J(
    () => s.map((g) => /* @__PURE__ */ y.jsx(
      Wn,
      {
        i18nKey: "review.amount_and_earn",
        values: {
          amount: n,
          tokenSymbol: g.symbol,
          interestRate: r
        },
        components: {
          highlight0: /* @__PURE__ */ y.jsx(Kg, {}),
          highlight1: /* @__PURE__ */ y.jsx(Kg, {}),
          highlight3: /* @__PURE__ */ y.jsx(Kg, {})
        }
      }
    )).extractNullable(),
    [n, r, s]
  ), m = J(
    () => G.of({ rewardToken: o, type: "stake" }),
    [o]
  );
  return /* @__PURE__ */ y.jsx(
    Nx,
    {
      fee: e,
      depositFee: u,
      managementFee: d,
      performanceFee: f,
      feeConfigLoading: h,
      title: t,
      metadata: i,
      token: s,
      info: p,
      rewardTokenDetailsProps: m,
      isGasCheckError: c,
      loading: l,
      ...a
    }
  );
}, eve = () => {
  Vn("stakingSteps");
  const { address: e, network: t } = wt(), n = fr(
    cm(),
    (i) => i.context.data
  ).unsafeCoerce(), r = () => G.fromRecord({
    network: G.fromNullable(t),
    address: G.fromNullable(e)
  }).ifJust(
    (i) => n.selectedValidators.forEach(
      (o) => m3({
        validatorData: {
          integrationId: n.selectedStake.id,
          validator: o
        },
        network: i.network,
        address: i.address
      })
    )
  );
  return /* @__PURE__ */ y.jsx(
    lm,
    {
      session: n.actionDto.unsafeCoerce(),
      onSignSuccess: r
    }
  );
};
var tve = "pk0cy50";
const nve = ({
  disabled: e,
  isLoading: t,
  onClick: n,
  label: r,
  variant: i
}) => {
  const { containerRef: o } = jce(), { state: s } = qo(), [a, l] = Oe(
    s.layout
  ), { disableInitLayoutAnimation: c } = bt(), { animate: u, initial: d } = Je({ translateY: 0, opacity: 1 }).chain(
    (f) => Je(null).map(() => c && !s.layout ? {
      animate: {},
      initial: { opacity: 1, translateY: 0 }
    } : s.layout ? {
      animate: {
        ...f,
        transition: {
          duration: a ? 0.3 : 0.6,
          delay: 0.2
        }
      },
      initial: { opacity: 0, translateY: "-20px" }
    } : {
      animate: {},
      initial: { opacity: 0, translateY: "-40px" }
    })
  ).unsafeCoerce();
  return /* @__PURE__ */ y.jsx(
    Zt.div,
    {
      "data-rk": "footer-outlet",
      ref: o,
      className: tve,
      initial: d,
      animate: u,
      onAnimationComplete: (f) => {
        f.translateY !== 0 || a || l(!0);
      },
      children: /* @__PURE__ */ y.jsx(z, { px: "4", marginTop: "2", marginBottom: "4", zIndex: "modal", children: /* @__PURE__ */ y.jsx(
        z,
        {
          flex: 1,
          display: "flex",
          justifyContent: "flex-end",
          flexDirection: "column",
          children: /* @__PURE__ */ y.jsx(
            si,
            {
              "data-rk": `footer-button-${i ?? "primary"}`,
              disabled: e,
              isLoading: t,
              onClick: n,
              variant: {
                color: i ?? (e || t ? "disabled" : "primary"),
                animation: "press"
              },
              children: r
            }
          )
        }
      ) })
    }
  );
}, rve = () => {
  const [e] = A6(), [, t] = hx();
  return Bo(() => {
    !e && t(0);
  }, [t, e]), e ? /* @__PURE__ */ y.jsx(nve, { ...e }) : null;
}, ive = ({
  positionBalancesData: e,
  prices: t,
  baseToken: n
}) => J(
  () => G.fromRecord({ positionBalancesData: e, baseToken: n }).map(
    (r) => lve({
      baseToken: r.baseToken,
      prices: t.data,
      pvd: r.positionBalancesData.balances
    })
  ),
  [e, t, n]
), ove = (e) => e.prices, sve = (e) => e.pvd, ave = (e) => e.baseToken, lve = zc(
  ove,
  sve,
  ave,
  (e, t, n) => t.reduce((r, i) => {
    const o = new Re(i.amount);
    if (o.isZero() || o.isNaN()) return r;
    const s = e ? Uc({
      amount: i.amount,
      prices: e,
      token: i.token,
      pricePerShare: i.pricePerShare,
      baseToken: n
    }) : new Re(0), a = r.get(i.type);
    return r.set(i.type, [...a ?? [], { ...i, tokenPriceInUsd: s }]), r;
  }, /* @__PURE__ */ new Map())
), cve = (e) => J(
  () => e.chain(
    (t) => G.fromNullable(t.get("staked")).altLazy(
      () => G.fromNullable(t.get("available"))
    )
  ),
  [e]
), NN = Ge(void 0), DN = Ge(void 0), uve = ({
  children: e
}) => {
  const { plain: t, pendingActionType: n } = px(), r = t.balanceId, i = t.integrationId, o = Ay(i), s = J(
    () => G.fromNullable(o.data),
    [o.data]
  ), a = Zd(s), l = mx({ balanceId: r, integrationId: i }), c = xR(
    J(
      () => G.fromRecord({
        positionBalances: l.data,
        baseToken: a
      }).map((U) => ({
        currency: Vt.currency,
        tokenList: [
          U.baseToken,
          ...U.positionBalances.balances.map((F) => F.token)
        ]
      })).extractNullable(),
      [l, a]
    )
  ), u = ive({
    baseToken: a,
    positionBalancesData: l.data,
    prices: c
  }), d = cve(
    u
  ), f = J(
    () => d.map(
      (U) => U.reduce(
        (F, $) => (F.amount = F.amount.plus(new Re($.amount)), F.token = $.token, F.pricePerShare = $.pricePerShare, F),
        {
          amount: new Re(0),
          token: U[0].token,
          pricePerShare: U[0].pricePerShare
        }
      )
    ),
    [d]
  ), h = J(
    () => d.chain((U) => pt.head(U)).map((U) => U.token),
    [d]
  ), { maxIntegrationAmount: p, maxEnterOrExitAmount: m, minEnterOrExitAmount: g } = C3({
    yieldOpportunity: s,
    type: "exit",
    availableAmount: f.map((U) => U.amount)
  }), v = Kx({
    type: "exit",
    integration: s
  }), w = s.map(
    (U) => {
      var F, $, ie;
      return !!(!v && ((ie = ($ = (F = U.args.exit) == null ? void 0 : F.args) == null ? void 0 : $.amount) != null && ie.required));
    }
  ), x = J(
    () => new Map(
      u.map(
        (U) => [...U.values()].flatMap(
          (F) => F.flatMap(
            ($) => $.pendingActions.map(
              (ie) => [
                wp({
                  balanceType: $.type,
                  token: $.token,
                  actionType: ie.type
                }),
                { pendingAction: ie, balance: $ }
              ]
            )
          )
        )
      ).orDefault([])
    ),
    [u]
  ), C = ({
    state: U,
    amount: F,
    actionType: $,
    balanceType: ie,
    token: he
  }) => {
    const ae = wp({ actionType: $, balanceType: ie, token: he });
    return G.fromNullable(
      x.get(ae)
    ).mapOrDefault((se) => {
      var Be, it, lt, yt, gt, vt, ot, Le;
      const oe = new Map(U);
      oe.set(ae, F);
      const ye = new Re(
        ((lt = (it = (Be = se.pendingAction.args) == null ? void 0 : Be.args) == null ? void 0 : it.amount) == null ? void 0 : lt.maximum) ?? Number.POSITIVE_INFINITY
      ), ve = new Re(
        ((vt = (gt = (yt = se.pendingAction.args) == null ? void 0 : yt.args) == null ? void 0 : gt.amount) == null ? void 0 : vt.minimum) ?? 0
      );
      return G.fromNullable((Le = (ot = se.pendingAction.args) == null ? void 0 : ot.args) == null ? void 0 : Le.amount).mapOrDefault(
        Ac,
        !1
      ) ? oe.set(ae, new Re(se.balance.amount)) : F.isLessThan(ve) ? oe.set(ae, ve) : F.isGreaterThan(ye) && oe.set(ae, ye), oe;
    }, U);
  }, S = (U, F) => {
    switch (F.type) {
      case "unstake/amount/change":
        return {
          ...U,
          unstakeAmount: F.data
        };
      case "unstake/amount/max":
        return {
          ...U,
          unstakeAmount: m
        };
      case "pendingAction/amount/change":
        return {
          ...U,
          pendingActions: C({
            state: U.pendingActions,
            ...F.data
          })
        };
      default:
        return U;
    }
  }, [k, A] = _c(S, {
    unstakeAmount: g,
    pendingActions: /* @__PURE__ */ new Map()
  }), { pendingActions: b, unstakeAmount: T } = k, R = J(
    () => G.fromRecord({
      reducedStakedOrLiquidBalance: f,
      canChangeUnstakeAmount: w
    }).map((U) => (!U.canChangeUnstakeAmount || v) && !U.reducedStakedOrLiquidBalance.amount.isEqualTo(T) ? U.reducedStakedOrLiquidBalance.amount : T).orDefault(T),
    [
      T,
      w,
      v,
      f
    ]
  ), B = J(
    () => R.isGreaterThanOrEqualTo(g) && R.isLessThanOrEqualTo(m) && !R.isZero(),
    [m, g, R]
  ), O = J(
    () => R.isGreaterThan(m),
    [R, m]
  ), L = J(
    () => R.isLessThan(g),
    [R, g]
  ), V = J(
    () => R.isGreaterThan(p) || L,
    [R, L, p]
  ), N = J(
    () => !R.isZero() && L || O || V,
    [
      R,
      L,
      O,
      V
    ]
  ), M = J(
    () => ({
      canChangeUnstakeAmount: w,
      unstakeAmountError: N,
      unstakeToken: h,
      unstakeAmount: R,
      pendingActions: b,
      positionBalancePrices: c,
      reducedStakedOrLiquidBalance: f,
      positionBalancesByType: u,
      stakedOrLiquidBalances: d,
      yieldOpportunity: o,
      positionBalances: l,
      pendingActionType: n,
      integrationData: s,
      unstakeAmountValid: B,
      unstakeIsGreaterOrLessIntegrationLimitError: V
    }),
    [
      w,
      N,
      h,
      R,
      b,
      c,
      f,
      u,
      d,
      o,
      l,
      s,
      B,
      n,
      V
    ]
  );
  return /* @__PURE__ */ y.jsx(NN.Provider, { value: M, children: /* @__PURE__ */ y.jsx(DN.Provider, { value: A, children: e }) });
}, rC = () => {
  const e = we(NN);
  if (e === void 0)
    throw new Error("useState must be used within a UnstakeContextProvider");
  return e;
}, jN = () => {
  const e = we(DN);
  if (e === void 0)
    throw new Error("useDispatch must be used within a UnstakeContextProvider");
  return e;
}, HS = ({
  onAmountChange: e,
  value: t,
  canChangeAmount: n,
  disabled: r,
  onClick: i,
  label: o,
  formattedAmount: s,
  onMaxClick: a,
  balance: l,
  unstakeAmountError: c,
  ...u
}) => {
  const { t: d } = ze(), f = G.fromPredicate(
    (p) => p.variant === "unstake",
    u
  ).map(
    (p) => [
      p.unstakeMinAmount.map(
        (m) => `${d("shared.min")} ${Sn(new Re(m))} ${p.unstakeToken.symbol}`
      ).extractNullable(),
      p.unstakeMaxAmount.map(
        (m) => `${d("shared.max")} ${Sn(new Re(m))} ${p.unstakeToken.symbol}`
      ).extractNullable(),
      p.unstakeIsGreaterOrLessIntegrationLimitError
    ]
  ).filter((p) => p.some(Boolean)).map(([p, m, g]) => /* @__PURE__ */ y.jsx(
    z,
    {
      display: "flex",
      justifyContent: "flex-end",
      alignItems: "center",
      marginTop: "2",
      marginRight: "2",
      children: /* @__PURE__ */ y.jsx(
        ue,
        {
          variant: { type: g ? "danger" : "muted" },
          textAlign: "right",
          children: p && m ? `${p} / ${m}` : p ?? m
        },
        "min"
      )
    }
  )).extractNullable(), h = u.variant === "action" ? {
    background: "background",
    borderWidth: 1,
    borderStyle: "solid",
    borderColor: "backgroundMuted"
  } : { background: "stakeSectionBackground" };
  return /* @__PURE__ */ y.jsxs(z, { ...h, borderRadius: "xl", marginTop: "2", py: "4", px: "4", children: [
    (u.variant === "action" || u.canUnstake) && /* @__PURE__ */ y.jsxs(z, { marginBottom: "3", children: [
      /* @__PURE__ */ y.jsxs(
        z,
        {
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          children: [
            /* @__PURE__ */ y.jsx(z, { minWidth: "0", display: "flex", marginRight: "2", flex: 1, children: /* @__PURE__ */ y.jsx(
              v6,
              {
                onChange: e,
                value: t,
                disabled: !n,
                shakeOnInvalid: !0,
                isInvalid: c
              }
            ) }),
            /* @__PURE__ */ y.jsx(
              si,
              {
                onClick: i,
                disabled: r,
                variant: {
                  size: "small",
                  color: u.variant === "unstake" ? "smallButton" : "smallButtonLight"
                },
                children: /* @__PURE__ */ y.jsx(ue, { children: o })
              }
            )
          ]
        }
      ),
      f,
      /* @__PURE__ */ y.jsxs(
        z,
        {
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          marginTop: "2",
          flexWrap: "wrap",
          children: [
            /* @__PURE__ */ y.jsx(z, { className: Hfe, children: /* @__PURE__ */ y.jsx(ue, { variant: { type: "muted", weight: "normal" }, children: s }) }),
            /* @__PURE__ */ y.jsxs(
              z,
              {
                flexGrow: 1,
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                children: [
                  l && /* @__PURE__ */ y.jsx(EN, { children: /* @__PURE__ */ y.jsx(SN, { children: ({ state: p }) => {
                    var m;
                    return /* @__PURE__ */ y.jsx(ue, { variant: { weight: "normal" }, children: d("position_details.available", {
                      amount: p === "full" ? Sn(l.amount) : Xn(l.amount),
                      symbol: ((m = l.token) == null ? void 0 : m.symbol) ?? ""
                    }) });
                  } }) }),
                  n && a && /* @__PURE__ */ y.jsx(
                    CN,
                    {
                      onMaxClick: a,
                      background: u.variant === "unstake" ? "background" : "backgroundMuted"
                    }
                  )
                ]
              }
            )
          ]
        }
      )
    ] }),
    u.variant === "unstake" && /* @__PURE__ */ y.jsx(z, { children: /* @__PURE__ */ y.jsx(
      dve,
      {
        validators: u.validators,
        yieldDto: u.yieldDto,
        unstakeToken: u.unstakeToken
      }
    ) })
  ] });
}, dve = ({
  validators: e,
  yieldDto: t,
  unstakeToken: n
}) => {
  const { withdrawnTime: r, withdrawnNotAvailable: i } = OB({
    validators: e,
    selectedStake: Je(t),
    tokenDto: Je(n)
  });
  return J(
    () => Je([r, i]).map((o) => o.filter((s) => s !== null)).filter((o) => !!o.length).map((o) => /* @__PURE__ */ y.jsx(z, { display: "flex", flexDirection: "column", gap: "2", children: o.map((s, a) => /* @__PURE__ */ y.jsxs(
      z,
      {
        display: "flex",
        alignItems: "center",
        justifyContent: "flex-start",
        gap: "1",
        children: [
          /* @__PURE__ */ y.jsx(z, { display: "flex", alignItems: "center", justifyContent: "center", children: /* @__PURE__ */ y.jsx(ka, {}) }),
          /* @__PURE__ */ y.jsx(ue, { variant: { type: "muted", size: "small" }, children: s })
        ]
      },
      a
    )) })).extractNullable(),
    [r, i]
  );
}, fve = ({
  yieldBalance: e,
  integrationData: t
}) => {
  const { t: n } = ze(), r = J(() => (e.type === "unstaking" || e.type === "unlocking") && e.date ? Lue(new Date(e.date)) : null, [e.date, e.type]), i = t.metadata.type, o = i === "vault" || i === "lending" ? "yearn_or_deposit" : void 0;
  return /* @__PURE__ */ y.jsxs(
    z,
    {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      gap: "4",
      children: [
        /* @__PURE__ */ y.jsx(ue, { variant: { weight: "normal" }, children: n(`position_details.balance_type.${e.type}`, {
          context: o
        }) }),
        /* @__PURE__ */ y.jsxs(z, { textAlign: "end", children: [
          /* @__PURE__ */ y.jsxs(z, { display: "flex", gap: "1", alignItems: "center", children: [
            e.token.isPoints && /* @__PURE__ */ y.jsx(z, { as: "span", display: "inline-flex", children: /* @__PURE__ */ y.jsx(
              No,
              {
                token: e.token,
                hideNetwork: !0,
                tokenLogoHw: "5"
              }
            ) }),
            /* @__PURE__ */ y.jsxs(
              ue,
              {
                overflowWrap: "anywhere",
                variant: { type: "muted", weight: "normal" },
                children: [
                  Xn(new Re(e.amount ?? 0)),
                  " ",
                  e.token.symbol,
                  !e.token.isPoints && ` ($${Xn(e.tokenPriceInUsd)})`
                ]
              }
            )
          ] }),
          typeof r == "number" && /* @__PURE__ */ y.jsx(ue, { variant: { type: "muted", weight: "normal" }, children: n("position_details.unstaking_days", {
            count: r
          }) })
        ] })
      ]
    }
  );
};
var hve = "ti8s800";
const iC = Ge(
  void 0
), oC = () => {
  const e = we(iC);
  if (!e)
    throw new Error("useCopyText must be used within a CopyTextProvider");
  return e;
}, pve = ({
  text: e,
  children: t
}) => {
  const [n, r] = Oe(!1), i = Ie(() => {
    Tn.ifJust((s) => s.navigator.clipboard.writeText(e)), r(!0);
  }, [e]);
  Te(() => {
    if (!n) return;
    const s = setTimeout(() => r(!1), 1e3);
    return () => {
      clearTimeout(s);
    };
  }, [n]);
  const o = J(
    () => ({ showCopySuccess: n, onClick: i }),
    [i, n]
  );
  return /* @__PURE__ */ y.jsx(iC.Provider, { value: o, children: t });
}, yve = ({
  children: e
}) => {
  const { onClick: t, showCopySuccess: n } = oC();
  return /* @__PURE__ */ y.jsx(
    z,
    {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      onClick: t,
      as: "a",
      className: hve,
      children: typeof e == "function" ? e({ showCopySuccess: n }) : e
    }
  );
}, mve = ({
  children: e,
  className: t
}) => {
  const { showCopySuccess: n, onClick: r } = oC();
  return /* @__PURE__ */ y.jsx(Fy, { mode: "wait", initial: !1, children: /* @__PURE__ */ y.jsx(
    Zt.div,
    {
      whileTap: { scale: n ? 1 : 0.9 },
      initial: { opacity: 0 },
      animate: { opacity: 1, transition: { duration: 0.3 } },
      exit: { opacity: 0, transition: { duration: 0 } },
      className: t,
      children: /* @__PURE__ */ y.jsx(iC.Provider, { value: { showCopySuccess: n, onClick: r }, children: e })
    },
    n ? "check" : "copy"
  ) });
}, gve = ({
  hw: e,
  className: t
}) => {
  const { showCopySuccess: n } = oC();
  return n ? /* @__PURE__ */ y.jsx(
    wN,
    {
      className: t,
      hw: e,
      color: "positionsClaimRewardsBackground"
    }
  ) : /* @__PURE__ */ y.jsx(xN, { className: t, hw: e });
}, vve = ({
  stakeType: e,
  isFirst: t,
  integrationData: n,
  logo: r,
  ...i
}) => {
  const { t: o } = ze(), s = i.name ?? i ?? "";
  return /* @__PURE__ */ y.jsx(y.Fragment, { children: /* @__PURE__ */ y.jsx(l3, { children: /* @__PURE__ */ y.jsxs(z, { display: "flex", flexDirection: "column", children: [
    t && /* @__PURE__ */ y.jsx(ti, {}),
    /* @__PURE__ */ y.jsxs(
      z,
      {
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        my: "2",
        children: [
          /* @__PURE__ */ y.jsxs(z, { display: "flex", justifyContent: "flex-start", alignItems: "center", children: [
            /* @__PURE__ */ y.jsx(z, { marginRight: "2", children: /* @__PURE__ */ y.jsx(
              Ii,
              {
                containerProps: { hw: "8" },
                imageProps: { borderRadius: "full" },
                src: r,
                fallback: /* @__PURE__ */ y.jsx(z, { marginRight: "1", children: /* @__PURE__ */ y.jsx(
                  Vo,
                  {
                    name: s,
                    tokenLogoHw: "8",
                    textVariant: { type: "white", weight: "bold" }
                  }
                ) })
              }
            ) }),
            /* @__PURE__ */ y.jsx(ue, { children: o("position_details.via", {
              stakeType: e,
              providerName: s
            }) }),
            i.preferred && /* @__PURE__ */ y.jsx(z, { marginLeft: "1", display: "flex", children: /* @__PURE__ */ y.jsx(um, {}) }),
            i.status && i.status !== "active" && /* @__PURE__ */ y.jsx(z, { marginLeft: "1", className: zfe, children: /* @__PURE__ */ y.jsx(
              ue,
              {
                variant: {
                  type: "white",
                  weight: "medium",
                  size: "small"
                },
                className: Vfe,
                children: o(
                  i.status === "jailed" ? "details.validators_jailed" : "details.validators_inactive"
                )
              }
            ) })
          ] }),
          /* @__PURE__ */ y.jsx(c3, { flex: 1, justifyContent: "flex-end", children: /* @__PURE__ */ y.jsx(u3, {}) })
        ]
      }
    ),
    /* @__PURE__ */ y.jsx(d3, { children: /* @__PURE__ */ y.jsx(
      bve,
      {
        address: i.address,
        commission: i.commission,
        rewardRate: i.rewardRate,
        stakedBalance: i.stakedBalance,
        votingPower: i.votingPower,
        rewardType: i.rewardType,
        website: i.website,
        stakedBalanceToken: n.token
      }
    ) }),
    /* @__PURE__ */ y.jsx(ti, {})
  ] }) }) });
}, bve = Td((e) => {
  const t = _N(e);
  return /* @__PURE__ */ y.jsx(z, { marginTop: "1", children: Object.entries(t).filter(
    (n) => !!n[1]
  ).map(([n, r]) => /* @__PURE__ */ y.jsxs(
    z,
    {
      marginTop: "1",
      marginBottom: "3",
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      children: [
        /* @__PURE__ */ y.jsx(ue, { variant: { weight: "normal" }, children: r.title }),
        n === "address" && e.address ? /* @__PURE__ */ y.jsx(pve, { text: e.address, children: /* @__PURE__ */ y.jsx(yve, { children: /* @__PURE__ */ y.jsxs(z, { display: "flex", gap: "1", className: qfe, children: [
          /* @__PURE__ */ y.jsx(
            ue,
            {
              variant: { type: "muted", weight: "normal" },
              className: $fe,
              children: r.val
            }
          ),
          /* @__PURE__ */ y.jsx(mve, { children: /* @__PURE__ */ y.jsx(
            z,
            {
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              children: /* @__PURE__ */ y.jsx(gve, { hw: 16 })
            }
          ) })
        ] }) }) }) : /* @__PURE__ */ y.jsx(ue, { variant: { type: "muted", weight: "normal" }, children: r.val })
      ]
    },
    n
  )) });
}), wve = ({
  pendingActionDto: e,
  yieldBalance: t,
  onPendingActionClick: n
}) => {
  const { t: r } = ze();
  return /* @__PURE__ */ y.jsxs(
    z,
    {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      px: "4",
      py: "4",
      borderRadius: "2xl",
      borderColor: "backgroundMuted",
      borderWidth: 1,
      borderStyle: "solid",
      children: [
        /* @__PURE__ */ y.jsx(z, { flex: 2, children: /* @__PURE__ */ y.jsx(ue, { variant: { weight: "normal" }, children: /* @__PURE__ */ y.jsx(
          Wn,
          {
            i18nKey: "position_details.available_to",
            values: {
              amount: Sn(new Re(t.amount)),
              symbol: t.token.symbol,
              pendingAction: r(
                `position_details.pending_action.${e.type.toLowerCase()}`
              )
            },
            components: {
              bold: /* @__PURE__ */ y.jsx(z, { as: "span", fontWeight: "bold", display: "block" })
            }
          }
        ) }) }),
        /* @__PURE__ */ y.jsx(
          z,
          {
            flex: 1,
            maxWidth: "24",
            justifyContent: "flex-end",
            display: "flex",
            alignItems: "center",
            children: /* @__PURE__ */ y.jsx(
              si,
              {
                variant: {
                  size: "small",
                  color: "smallButtonLight"
                },
                onClick: () => n({
                  yieldBalance: t,
                  pendingActionDto: e
                }),
                children: /* @__PURE__ */ y.jsx(ue, { children: r(
                  `position_details.pending_action_button.${e.type.toLowerCase()}`
                ) })
              }
            )
          }
        )
      ]
    }
  );
}, xve = () => {
  const { address: e, additionalAddresses: t } = wt(), { unstakeAmount: n, integrationData: r, stakedOrLiquidBalances: i } = rC();
  return J(
    () => G.fromRecord({
      address: G.fromNullable(e),
      integrationData: r,
      stakedOrLiquidBalances: i
    }).map((o) => {
      const s = Je(null).chain(() => {
        var a, l, c, u, d, f;
        return o.integrationData.metadata.isIntegrationAggregator ? pt.find(
          (h) => !!h.providerId,
          o.stakedOrLiquidBalances
        ).map((h) => ({
          providerId: h.providerId,
          validatorAddress: h.validatorAddress
        })) : (c = (l = (a = o.integrationData.args.exit) == null ? void 0 : a.args) == null ? void 0 : l.validatorAddresses) != null && c.required ? pt.find(
          (h) => !!h.validatorAddresses,
          o.stakedOrLiquidBalances
        ).map((h) => ({ validatorAddresses: h.validatorAddresses })) : (f = (d = (u = o.integrationData.args.exit) == null ? void 0 : u.args) == null ? void 0 : d.validatorAddress) != null && f.required ? pt.find(
          (h) => !!h.validatorAddress,
          o.stakedOrLiquidBalances
        ).map((h) => ({ validatorAddress: h.validatorAddress })) : G.empty();
      }).orDefault({});
      return {
        gasFeeToken: o.integrationData.metadata.gasFeeToken,
        dto: {
          addresses: {
            address: o.address,
            additionalAddresses: t ?? void 0
          },
          integrationId: o.integrationData.id,
          args: {
            amount: n.toString(10),
            ...s
          }
        }
      };
    }),
    [
      t,
      e,
      i,
      r,
      n
    ]
  );
}, Cve = (e, t) => {
  var n, r, i;
  switch (t.type) {
    case "validator/multiselect": {
      const o = new Set(e.selectedValidators);
      return o.has(t.data) ? o.delete(t.data) : o.add(t.data), o.size === 0 ? e : {
        ...e,
        selectedValidators: o
      };
    }
    case "validator/select": {
      const o = /* @__PURE__ */ new Set([t.data]);
      return {
        ...e,
        selectedValidators: o
      };
    }
    case "validator/close":
      return {
        ...e,
        multiSelect: !1,
        pendingActionDto: null,
        yieldBalance: null,
        showValidatorsModal: !1
      };
    case "validator/open": {
      const o = new Set(
        t.data.yieldBalance.validatorAddresses
      );
      return {
        ...e,
        multiSelect: !!((i = (r = (n = t.data.pendingActionDto.args) == null ? void 0 : n.args) == null ? void 0 : r.validatorAddresses) != null && i.required),
        selectedValidators: o,
        pendingActionDto: t.data.pendingActionDto,
        yieldBalance: t.data.yieldBalance,
        showValidatorsModal: !0
      };
    }
    default:
      return e;
  }
}, kve = () => ({
  selectedValidators: /* @__PURE__ */ new Set(),
  showValidatorsModal: !1,
  pendingActionDto: null,
  yieldBalance: null,
  multiSelect: !1
}), Eve = () => {
  const [e, t] = _c(Cve, kve()), n = Ie(
    () => t({ type: "validator/close" }),
    []
  ), r = Ie(
    (s) => t({ type: "validator/open", data: s }),
    []
  ), i = Ie(
    (s) => t({ type: "validator/multiselect", data: s }),
    []
  ), o = J(
    () => ({
      isOpen: e.showValidatorsModal,
      setOpen: (s) => !s && n()
    }),
    [n, e.showValidatorsModal]
  );
  return {
    ...e,
    modalState: o,
    closeModal: n,
    openModal: r,
    onItemClick: i,
    submitDisabled: e.selectedValidators.size === 0
  };
}, Sve = () => {
  const {
    pendingActions: e,
    reducedStakedOrLiquidBalance: t,
    pendingActionType: n,
    positionBalancesByType: r,
    integrationData: i,
    positionBalancePrices: o
  } = rC(), s = Zd(i), a = jN(), l = cn(), c = er(), u = J(
    () => r.map(
      (k) => [...k.values()].flatMap(
        (A) => A.flatMap(
          (b) => b.pendingActions.map((T) => {
            var O, L, V;
            const R = G.fromPredicate(
              (N) => !!N,
              (V = (L = (O = T.args) == null ? void 0 : O.args) == null ? void 0 : L.amount) == null ? void 0 : V.required
            ).chain(
              () => G.fromNullable(
                e.get(
                  wp({
                    balanceType: b.type,
                    token: b.token,
                    actionType: T.type
                  })
                )
              ).altLazy(() => G.of(new Re(0)))
            ), B = G.fromRecord({
              prices: G.fromNullable(o.data),
              amount: R,
              reducedStakedOrLiquidBalance: t,
              baseToken: s
            }).map(
              (N) => Uc({
                amount: N.amount,
                token: N.reducedStakedOrLiquidBalance.token,
                prices: N.prices,
                pricePerShare: b.pricePerShare,
                baseToken: N.baseToken
              })
            ).mapOrDefault((N) => `$${Xn(N)}`, "");
            return {
              amount: R.extractNullable(),
              formattedAmount: B,
              pendingActionDto: T,
              yieldBalance: b
            };
          })
        )
      )
    ),
    [
      e,
      o.data,
      r,
      t,
      s
    ]
  ), d = (k) => {
    a({ type: "pendingAction/amount/change", data: k });
  }, f = Eve(), h = Dt(f), p = It(!1);
  Te(() => {
    p.current || n.chain(
      (k) => u.chain(
        (A) => pt.find(
          (b) => b.pendingActionDto.type === k && !!(Wb(b.pendingActionDto) || Gb(b.pendingActionDto)),
          A
        )
      )
    ).ifJust((k) => {
      p.current = !0, h.current.openModal({
        pendingActionDto: k.pendingActionDto,
        yieldBalance: k.yieldBalance
      });
    });
  }, [n, u, h]);
  const m = ({
    yieldBalance: k,
    pendingActionDto: A
  }) => {
    if (l("pendingActionClicked", {
      yieldId: i.map((b) => b.id).extract(),
      type: A.type
    }), Wb(A) || Gb(A))
      return f.openModal({
        pendingActionDto: A,
        yieldBalance: k
      });
    i.toEither(new Error("missing integration data")).ifRight(
      (b) => S({
        integrationData: b,
        pendingActionDto: A,
        yieldBalance: k,
        selectedValidators: []
      })
    );
  }, g = (k) => i.toEither(new Error("missing integration data")).chain((A) => {
    if (!f.showValidatorsModal)
      return Xe(
        new Error("missing validatorAddressesHandling.showValidatorsModal")
      );
    if (!k.length)
      return Xe(new Error("selectedValidators is empty"));
    const { pendingActionDto: b, yieldBalance: T } = f;
    return _e({
      yieldDto: A,
      selectedValidators: k,
      pendingActionDto: b,
      yieldBalance: T
    });
  }).ifRight(
    ({ selectedValidators: A, pendingActionDto: b, yieldBalance: T, yieldDto: R }) => {
      l("validatorsSubmitted", {
        yieldId: R.id,
        type: b.type,
        validators: A
      }), f.closeModal(), S({
        integrationData: R,
        pendingActionDto: b,
        yieldBalance: T,
        selectedValidators: A
      });
    }
  ), { additionalAddresses: v, address: w } = wt(), x = _6(), C = hf(), S = ({
    integrationData: k,
    pendingActionDto: A,
    yieldBalance: b,
    selectedValidators: T
  }) => {
    f3({
      pendingActionsState: e,
      yieldBalance: b,
      pendingActionDto: A,
      additionalAddresses: v,
      address: w,
      integration: k,
      selectedValidators: T
    }).ifRight((R) => {
      C.send({
        type: "initFlow",
        data: {
          gasFeeToken: R.gasFeeToken,
          integrationData: R.integrationData,
          interactedToken: b.token,
          pendingActionType: A.type,
          requestDto: R.requestDto,
          addresses: {
            address: R.address,
            additionalAddresses: R.additionalAddresses
          }
        }
      }), x ? c("../pending-action/review", { relative: "route" }) : c("pending-action/review");
    });
  };
  return {
    onPendingActionAmountChange: d,
    validatorAddressesHandling: f,
    pendingActions: u,
    onPendingActionClick: m,
    onValidatorsSubmit: g
  };
}, Ave = () => {
  const {
    unstakeAmount: e,
    integrationData: t,
    yieldOpportunity: n,
    positionBalances: r,
    reducedStakedOrLiquidBalance: i,
    positionBalancesByType: o,
    positionBalancePrices: s,
    unstakeAmountValid: a,
    unstakeToken: l,
    unstakeAmountError: c,
    canChangeUnstakeAmount: u,
    unstakeIsGreaterOrLessIntegrationLimitError: d
  } = rC(), f = er(), h = xve(), p = bc(), m = J(
    () => t.chainNullable((ae) => {
      var se, oe;
      return (oe = (se = ae.args.exit) == null ? void 0 : se.args) == null ? void 0 : oe.amount;
    }).filter((ae) => !Ac(ae)).chainNullable((ae) => ae.maximum),
    [t]
  ), g = J(
    () => t.chainNullable((ae) => {
      var se, oe;
      return (oe = (se = ae.args.exit) == null ? void 0 : se.args) == null ? void 0 : oe.amount;
    }).filter((ae) => !Ac(ae)).chainNullable((ae) => ae.minimum).filter((ae) => new Re(ae).isGreaterThan(0)),
    [t]
  ), v = li({
    mutationKey: [e.toString()],
    mutationFn: async () => {
      if (!a) throw new Error("Invalid amount");
      return G.fromRecord({
        stakeExitRequestDto: h,
        integrationData: t,
        unstakeToken: l
      }).ifJust((ae) => {
        p.send({
          type: "initFlow",
          data: {
            gasFeeToken: ae.stakeExitRequestDto.gasFeeToken,
            integrationData: ae.integrationData,
            requestDto: ae.stakeExitRequestDto.dto,
            unstakeAmount: e,
            unstakeToken: ae.unstakeToken
          }
        }), f("unstake/review");
      }), null;
    }
  }), w = v.mutate, x = v.isError || c, C = J(
    () => r.data.chainNullable(
      (ae) => {
        var se;
        return (se = ae.balances.find((oe) => oe.label)) == null ? void 0 : se.label;
      }
    ),
    [r.data]
  ), S = jN(), k = cn(), A = Zd(t), b = Uo({
    integrationData: t,
    validatorsAddresses: r.data.map((ae) => ae.type === "validators" ? ae.validatorsAddresses : [])
  }), T = t.filter((ae) => !!ae.args.exit).isJust(), R = (ae) => S({ type: "unstake/amount/change", data: ae }), B = J(
    () => G.fromRecord({
      prices: G.fromNullable(s.data),
      reducedStakedOrLiquidBalance: i,
      baseToken: A
    }).map(
      (ae) => Uc({
        amount: e,
        token: ae.reducedStakedOrLiquidBalance.token,
        prices: ae.prices,
        pricePerShare: ae.reducedStakedOrLiquidBalance.pricePerShare,
        baseToken: ae.baseToken
      })
    ).mapOrDefault((ae) => `$${Xn(ae)}`, ""),
    [
      s.data,
      i,
      e,
      A
    ]
  ), O = () => {
    k("positionDetailsPageMaxClicked", {
      yieldId: t.map((ae) => ae.id).extract()
    }), S({ type: "unstake/amount/max" });
  }, L = t.mapOrDefault(
    (ae) => ae.status.exit,
    !1
  ), {
    onPendingActionAmountChange: V,
    pendingActions: N,
    onPendingActionClick: M,
    onValidatorsSubmit: U,
    validatorAddressesHandling: F
  } = Sve(), $ = J(
    () => G.fromRecord({
      integrationData: t,
      positionBalancesByType: o,
      baseToken: A
    }).map(
      (ae) => [...ae.positionBalancesByType.values()].reduce((se, oe) => (oe.filter(
        (ye) => !ye.token.isPoints && ye.pricePerShare && !xy(ye.token, ae.baseToken)
      ).forEach((ye) => {
        se.set(
          ye.token.symbol,
          `1 ${ye.token.symbol} = ${Xn(
            new Re(ye.pricePerShare)
          )} ${ae.baseToken.symbol}`
        );
      }), se), /* @__PURE__ */ new Map())
    ),
    [t, o, A]
  ), ie = n.isLoading || !L, he = r.isLoading || s.isLoading || n.isLoading;
  return {
    integrationData: t,
    reducedStakedOrLiquidBalance: i,
    positionBalancesByType: o,
    canUnstake: T,
    unstakeAmount: e,
    onUnstakeAmountChange: R,
    unstakeFormattedAmount: B,
    onMaxClick: O,
    canChangeUnstakeAmount: u,
    onUnstakeClick: w,
    unstakeDisabled: ie,
    isLoading: he,
    onPendingActionClick: M,
    providersDetails: b,
    pendingActions: N,
    liquidTokensToNativeConversion: $,
    validatorAddressesHandling: F,
    onValidatorsSubmit: U,
    onPendingActionAmountChange: V,
    unstakeToken: l,
    positionLabel: C,
    unstakeAmountError: x,
    unstakeMaxAmount: m,
    unstakeMinAmount: g,
    unstakeIsGreaterOrLessIntegrationLimitError: d
  };
}, Tve = () => {
  const {
    onPendingActionAmountChange: e,
    integrationData: t,
    isLoading: n,
    reducedStakedOrLiquidBalance: r,
    positionBalancesByType: i,
    onUnstakeAmountChange: o,
    unstakeAmount: s,
    unstakeFormattedAmount: a,
    canChangeUnstakeAmount: l,
    onMaxClick: c,
    onUnstakeClick: u,
    unstakeDisabled: d,
    onPendingActionClick: f,
    pendingActions: h,
    providersDetails: p,
    liquidTokensToNativeConversion: m,
    validatorAddressesHandling: g,
    onValidatorsSubmit: v,
    unstakeToken: w,
    canUnstake: x,
    unstakeAmountError: C,
    positionLabel: S,
    unstakeMaxAmount: k,
    unstakeMinAmount: A,
    unstakeIsGreaterOrLessIntegrationLimitError: b
  } = Ave();
  Vn("positionDetails", {
    yield: t.map((R) => R.metadata.name).extract()
  });
  const { t: T } = ze();
  return /* @__PURE__ */ y.jsx(ff, { children: /* @__PURE__ */ y.jsx($s, { children: n ? /* @__PURE__ */ y.jsx(
    z,
    {
      className: ES,
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      children: /* @__PURE__ */ y.jsx(ei, {})
    }
  ) : G.fromRecord({ integrationData: t, positionBalancesByType: i }).map((R) => /* @__PURE__ */ y.jsxs(
    z,
    {
      className: ES,
      flex: 1,
      display: "flex",
      flexDirection: "column",
      children: [
        w.altLazy(() => Je(R.integrationData.token)).map((B) => /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
          /* @__PURE__ */ y.jsx(
            z,
            {
              display: "flex",
              justifyContent: "center",
              alignItems: "center",
              children: /* @__PURE__ */ y.jsx(
                No,
                {
                  metadata: R.integrationData.metadata,
                  token: B,
                  tokenLogoHw: "14"
                }
              )
            }
          ),
          /* @__PURE__ */ y.jsxs(
            z,
            {
              marginTop: "3",
              display: "flex",
              justifyContent: "center",
              alignItems: "center",
              flexDirection: "column",
              children: [
                /* @__PURE__ */ y.jsx(to, { variant: { level: "h4" }, textAlign: "center", children: R.integrationData.metadata.name }),
                /* @__PURE__ */ y.jsx(ue, { variant: { type: "muted" }, children: B.symbol })
              ]
            }
          )
        ] })).extractNullable(),
        S.map((B) => /* @__PURE__ */ y.jsx(
          z,
          {
            background: "stakeSectionBackground",
            borderRadius: "xl",
            marginTop: "2",
            py: "4",
            px: "4",
            children: /* @__PURE__ */ y.jsxs(
              z,
              {
                display: "flex",
                alignItems: "center",
                justifyContent: "flex-start",
                gap: "1",
                children: [
                  /* @__PURE__ */ y.jsx(
                    z,
                    {
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      children: /* @__PURE__ */ y.jsx(ka, {})
                    }
                  ),
                  /* @__PURE__ */ y.jsx(ue, { variant: { type: "muted", size: "small" }, children: T(
                    `position_details.labels.${B.type}.details`,
                    B.params
                  ) })
                ]
              }
            )
          }
        )).extractNullable(),
        /* @__PURE__ */ y.jsx(z, { marginTop: "4", children: p.map(
          (B) => B.map((O, L) => /* @__PURE__ */ Rr(
            vve,
            {
              ...O,
              key: O.address ?? L,
              isFirst: L === 0,
              stakeType: T(
                `position_details.stake_type.${R.integrationData.metadata.type}`
              ),
              integrationData: R.integrationData
            }
          ))
        ).extractNullable() }),
        /* @__PURE__ */ y.jsx(z, { py: "3", gap: "2", display: "flex", flexDirection: "column", children: [...R.positionBalancesByType.values()].flatMap(
          (B) => B.map((O, L) => /* @__PURE__ */ y.jsx(
            fve,
            {
              integrationData: R.integrationData,
              yieldBalance: O
            },
            `${O.type}-${L}`
          ))
        ) }),
        m.map((B) => /* @__PURE__ */ y.jsx(
          z,
          {
            my: "2",
            display: "flex",
            alignItems: "flex-end",
            flexDirection: "column",
            gap: "1",
            children: [...B.values()].map((O) => /* @__PURE__ */ y.jsx(
              ue,
              {
                variant: { type: "muted", weight: "normal" },
                children: O
              },
              O
            ))
          }
        )).extractNullable(),
        /* @__PURE__ */ y.jsxs(
          z,
          {
            display: "flex",
            flex: 1,
            justifyContent: "flex-end",
            flexDirection: "column",
            marginTop: "10",
            gap: "2",
            children: [
              h.map(
                (B) => B.map(
                  (O) => O.amount ? /* @__PURE__ */ y.jsx(
                    HS,
                    {
                      variant: "action",
                      onAmountChange: (L) => e({
                        balanceType: O.yieldBalance.type,
                        token: O.yieldBalance.token,
                        actionType: O.pendingActionDto.type,
                        amount: L
                      }),
                      value: O.amount,
                      canChangeAmount: !0,
                      onClick: () => f({
                        pendingActionDto: O.pendingActionDto,
                        yieldBalance: O.yieldBalance
                      }),
                      label: T(
                        `position_details.pending_action_button.${O.pendingActionDto.type.toLowerCase()}`
                      ),
                      onMaxClick: null,
                      formattedAmount: O.formattedAmount,
                      balance: null
                    },
                    `${O.pendingActionDto.type}-${O.pendingActionDto.passthrough}`
                  ) : /* @__PURE__ */ Rr(
                    wve,
                    {
                      ...O,
                      key: `${O.pendingActionDto.type}-${O.pendingActionDto.passthrough}`,
                      onPendingActionClick: f
                    }
                  )
                )
              ).extractNullable(),
              G.fromRecord({
                reducedStakedOrLiquidBalance: r,
                canChangeUnstakeAmount: l,
                unstakeToken: w
              }).map(
                ({
                  reducedStakedOrLiquidBalance: B,
                  canChangeUnstakeAmount: O,
                  unstakeToken: L
                }) => /* @__PURE__ */ y.jsx(
                  HS,
                  {
                    unstakeMaxAmount: k,
                    unstakeMinAmount: A,
                    unstakeIsGreaterOrLessIntegrationLimitError: b,
                    variant: "unstake",
                    canUnstake: x,
                    unstakeToken: L,
                    onAmountChange: o,
                    value: s,
                    canChangeAmount: O,
                    disabled: d,
                    onClick: u,
                    unstakeAmountError: C,
                    onMaxClick: c,
                    label: T(
                      `position_details.unstake_label.${R.integrationData.metadata.type}`
                    ),
                    formattedAmount: a,
                    balance: B,
                    yieldDto: R.integrationData,
                    validators: p.orDefault([])
                  }
                )
              ).extractNullable()
            ]
          }
        ),
        g.showValidatorsModal && /* @__PURE__ */ y.jsx(
          RN,
          {
            selectedValidators: g.selectedValidators,
            onItemClick: (B) => {
              g.onItemClick(B.address), !g.multiSelect && v([B.address]);
            },
            selectedStake: R.integrationData,
            validators: R.integrationData.validators,
            multiSelect: g.multiSelect,
            state: g.modalState,
            children: g.multiSelect && /* @__PURE__ */ y.jsx(
              z,
              {
                px: "4",
                paddingTop: "3",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                children: /* @__PURE__ */ y.jsx(
                  si,
                  {
                    variant: {
                      color: g.submitDisabled ? "disabled" : "primary"
                    },
                    disabled: g.submitDisabled,
                    onClick: () => v([
                      ...g.selectedValidators.values()
                    ]),
                    children: T("position_details.select_validators.submit")
                  }
                )
              }
            )
          }
        )
      ]
    }
  )).extractNullable() }) });
}, KS = () => /* @__PURE__ */ y.jsx(uve, { children: /* @__PURE__ */ y.jsx(Tve, {}) }), _ve = Ge(void 0), Ive = ({ children: e }) => {
  const t = Oe({ positions: null });
  return /* @__PURE__ */ y.jsx(_ve.Provider, { value: t, children: e });
}, Rve = (e) => {
  const [t] = Oe(() => new Ua([])), n = Ie(
    (o) => {
      if (!e || !bo(e))
        return () => {
        };
      const s = e.$disabledChains.subscribe((a) => {
        t.next(a), o();
      });
      return () => s.unsubscribe();
    },
    [e, t]
  ), r = Ie(() => t.value, [t]), i = Ie(() => t.value, [t.value]);
  return Dr(n, r, i);
}, Pve = {
  ...wy.lightMode,
  colors: zt.color.connectKit,
  // ThemeWrapper applies final light/dark colors
  radii: zt.borderRadius.connectKit
}, Ove = ({
  children: e
}) => {
  const { connector: t, connectorChains: n } = wt(), r = Rve(t), i = cn(), o = wx(), { t: s } = ze(), a = J(
    () => new Set(n.map((u) => u.id)),
    [n]
  ), l = J(
    () => r.map((u) => ({
      ...u,
      info: s("chain_modal.disabled_chain_info")
    })),
    [r, s]
  ), c = J(
    () => G.fromNullable(t).map((u) => !IR(u)).orDefault(!0),
    [t]
  );
  return /* @__PURE__ */ y.jsxs(
    XQ,
    {
      chainIdsToUse: a,
      id: Yy,
      modalSize: "compact",
      disabledChains: l,
      onDisabledChainClick: (u) => {
        i("addLedgerAccountClicked"), o.mutate(u);
      },
      appInfo: { disclaimer: Nve, appName: "StakeKit" },
      theme: Pve,
      hideDisconnect: c,
      children: [
        /* @__PURE__ */ y.jsx(Bve, {}),
        e
      ]
    }
  );
}, Bve = () => (uR().closeChainModal, null), Nve = () => /* @__PURE__ */ y.jsx(ue, { children: "Powered by StakeKit" }), Dve = ({ children: e }) => {
  const { ledgerAccounts: t, address: n, onLedgerAccountChange: r } = wt(), i = G.fromNullable(t).map(
    (o) => o.filter((s) => s.address !== n).map((s) => Uh(s.address))
  ).orDefault([]);
  return /* @__PURE__ */ y.jsx(
    Q5.Provider,
    {
      value: {
        otherAddresses: i,
        onOtherAddressClick: (o) => G.fromNullable(t).ifJust(
          (s) => pt.find(
            (a) => Uh(a.address) === o,
            s
          ).ifJust((a) => r == null ? void 0 : r(a))
        )
      },
      children: /* @__PURE__ */ y.jsx(Ove, { children: e })
    }
  );
};
var Ep = { exports: {} };
Ep.exports;
(function(e, t) {
  var n = 200, r = "__lodash_hash_undefined__", i = 800, o = 16, s = 9007199254740991, a = "[object Arguments]", l = "[object Array]", c = "[object AsyncFunction]", u = "[object Boolean]", d = "[object Date]", f = "[object Error]", h = "[object Function]", p = "[object GeneratorFunction]", m = "[object Map]", g = "[object Number]", v = "[object Null]", w = "[object Object]", x = "[object Proxy]", C = "[object RegExp]", S = "[object Set]", k = "[object String]", A = "[object Undefined]", b = "[object WeakMap]", T = "[object ArrayBuffer]", R = "[object DataView]", B = "[object Float32Array]", O = "[object Float64Array]", L = "[object Int8Array]", V = "[object Int16Array]", N = "[object Int32Array]", M = "[object Uint8Array]", U = "[object Uint8ClampedArray]", F = "[object Uint16Array]", $ = "[object Uint32Array]", ie = /[\\^$.*+?()[\]{}|]/g, he = /^\[object .+?Constructor\]$/, ae = /^(?:0|[1-9]\d*)$/, se = {};
  se[B] = se[O] = se[L] = se[V] = se[N] = se[M] = se[U] = se[F] = se[$] = !0, se[a] = se[l] = se[T] = se[u] = se[R] = se[d] = se[f] = se[h] = se[m] = se[g] = se[w] = se[C] = se[S] = se[k] = se[b] = !1;
  var oe = typeof pu == "object" && pu && pu.Object === Object && pu, ye = typeof self == "object" && self && self.Object === Object && self, ve = oe || ye || Function("return this")(), Be = t && !t.nodeType && t, it = Be && !0 && e && !e.nodeType && e, lt = it && it.exports === Be, yt = lt && oe.process, gt = function() {
    try {
      var H = it && it.require && it.require("util").types;
      return H || yt && yt.binding && yt.binding("util");
    } catch {
    }
  }(), vt = gt && gt.isTypedArray;
  function ot(H, ne, ce) {
    switch (ce.length) {
      case 0:
        return H.call(ne);
      case 1:
        return H.call(ne, ce[0]);
      case 2:
        return H.call(ne, ce[0], ce[1]);
      case 3:
        return H.call(ne, ce[0], ce[1], ce[2]);
    }
    return H.apply(ne, ce);
  }
  function Le(H, ne) {
    for (var ce = -1, Me = Array(H); ++ce < H; )
      Me[ce] = ne(ce);
    return Me;
  }
  function tt(H) {
    return function(ne) {
      return H(ne);
    };
  }
  function jt(H, ne) {
    return H == null ? void 0 : H[ne];
  }
  function rn(H, ne) {
    return function(ce) {
      return H(ne(ce));
    };
  }
  var en = Array.prototype, Gt = Function.prototype, jn = Object.prototype, tr = ve["__core-js_shared__"], Ot = Gt.toString, qt = jn.hasOwnProperty, Cn = function() {
    var H = /[^.]+$/.exec(tr && tr.keys && tr.keys.IE_PROTO || "");
    return H ? "Symbol(src)_1." + H : "";
  }(), Ve = jn.toString, nt = Ot.call(Object), je = RegExp(
    "^" + Ot.call(qt).replace(ie, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), st = lt ? ve.Buffer : void 0, tn = ve.Symbol, D = ve.Uint8Array;
  st && st.allocUnsafe;
  var E = rn(Object.getPrototypeOf, Object), _ = Object.create, q = jn.propertyIsEnumerable, Z = en.splice, re = tn ? tn.toStringTag : void 0, pe = function() {
    try {
      var H = ym(Object, "defineProperty");
      return H({}, "", {}), H;
    } catch {
    }
  }(), He = st ? st.isBuffer : void 0, xt = Math.max, St = Date.now, Ct = ym(ve, "Map"), Ze = ym(Object, "create"), Di = /* @__PURE__ */ function() {
    function H() {
    }
    return function(ne) {
      if (!Hs(ne))
        return {};
      if (_)
        return _(ne);
      H.prototype = ne;
      var ce = new H();
      return H.prototype = void 0, ce;
    };
  }();
  function kn(H) {
    var ne = -1, ce = H == null ? 0 : H.length;
    for (this.clear(); ++ne < ce; ) {
      var Me = H[ne];
      this.set(Me[0], Me[1]);
    }
  }
  function hi() {
    this.__data__ = Ze ? Ze(null) : {}, this.size = 0;
  }
  function so(H) {
    var ne = this.has(H) && delete this.__data__[H];
    return this.size -= ne ? 1 : 0, ne;
  }
  function ao(H) {
    var ne = this.__data__;
    if (Ze) {
      var ce = ne[H];
      return ce === r ? void 0 : ce;
    }
    return qt.call(ne, H) ? ne[H] : void 0;
  }
  function Go(H) {
    var ne = this.__data__;
    return Ze ? ne[H] !== void 0 : qt.call(ne, H);
  }
  function lo(H, ne) {
    var ce = this.__data__;
    return this.size += this.has(H) ? 0 : 1, ce[H] = Ze && ne === void 0 ? r : ne, this;
  }
  kn.prototype.clear = hi, kn.prototype.delete = so, kn.prototype.get = ao, kn.prototype.has = Go, kn.prototype.set = lo;
  function Mn(H) {
    var ne = -1, ce = H == null ? 0 : H.length;
    for (this.clear(); ++ne < ce; ) {
      var Me = H[ne];
      this.set(Me[0], Me[1]);
    }
  }
  function ji() {
    this.__data__ = [], this.size = 0;
  }
  function Mi(H) {
    var ne = this.__data__, ce = Bt(ne, H);
    if (ce < 0)
      return !1;
    var Me = ne.length - 1;
    return ce == Me ? ne.pop() : Z.call(ne, ce, 1), --this.size, !0;
  }
  function co(H) {
    var ne = this.__data__, ce = Bt(ne, H);
    return ce < 0 ? void 0 : ne[ce][1];
  }
  function Ho(H) {
    return Bt(this.__data__, H) > -1;
  }
  function Ws(H, ne) {
    var ce = this.__data__, Me = Bt(ce, H);
    return Me < 0 ? (++this.size, ce.push([H, ne])) : ce[Me][1] = ne, this;
  }
  Mn.prototype.clear = ji, Mn.prototype.delete = Mi, Mn.prototype.get = co, Mn.prototype.has = Ho, Mn.prototype.set = Ws;
  function Q(H) {
    var ne = -1, ce = H == null ? 0 : H.length;
    for (this.clear(); ++ne < ce; ) {
      var Me = H[ne];
      this.set(Me[0], Me[1]);
    }
  }
  function ee() {
    this.size = 0, this.__data__ = {
      hash: new kn(),
      map: new (Ct || Mn)(),
      string: new kn()
    };
  }
  function Y(H) {
    var ne = wf(this, H).delete(H);
    return this.size -= ne ? 1 : 0, ne;
  }
  function j(H) {
    return wf(this, H).get(H);
  }
  function te(H) {
    return wf(this, H).has(H);
  }
  function le(H, ne) {
    var ce = wf(this, H), Me = ce.size;
    return ce.set(H, ne), this.size += ce.size == Me ? 0 : 1, this;
  }
  Q.prototype.clear = ee, Q.prototype.delete = Y, Q.prototype.get = j, Q.prototype.has = te, Q.prototype.set = le;
  function ge(H) {
    var ne = this.__data__ = new Mn(H);
    this.size = ne.size;
  }
  function me() {
    this.__data__ = new Mn(), this.size = 0;
  }
  function Ee(H) {
    var ne = this.__data__, ce = ne.delete(H);
    return this.size = ne.size, ce;
  }
  function Ce(H) {
    return this.__data__.get(H);
  }
  function xe(H) {
    return this.__data__.has(H);
  }
  function et(H, ne) {
    var ce = this.__data__;
    if (ce instanceof Mn) {
      var Me = ce.__data__;
      if (!Ct || Me.length < n - 1)
        return Me.push([H, ne]), this.size = ++ce.size, this;
      ce = this.__data__ = new Q(Me);
    }
    return ce.set(H, ne), this.size = ce.size, this;
  }
  ge.prototype.clear = me, ge.prototype.delete = Ee, ge.prototype.get = Ce, ge.prototype.has = xe, ge.prototype.set = et;
  function We(H, ne) {
    var ce = vm(H), Me = !ce && gm(H), At = !ce && !Me && lC(H), Ft = !ce && !Me && !At && uC(H), Yt = ce || Me || At || Ft, Rt = Yt ? Le(H.length, String) : [], Qt = Rt.length;
    for (var gi in H)
      Yt && // Safari 9 has enumerable `arguments.length` in strict mode.
      (gi == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      At && (gi == "offset" || gi == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      Ft && (gi == "buffer" || gi == "byteLength" || gi == "byteOffset") || // Skip index properties.
      sC(gi, Qt)) || Rt.push(gi);
    return Rt;
  }
  function Ke(H, ne, ce) {
    (ce !== void 0 && !xf(H[ne], ce) || ce === void 0 && !(ne in H)) && Tt(H, ne, ce);
  }
  function rt(H, ne, ce) {
    var Me = H[ne];
    (!(qt.call(H, ne) && xf(Me, ce)) || ce === void 0 && !(ne in H)) && Tt(H, ne, ce);
  }
  function Bt(H, ne) {
    for (var ce = H.length; ce--; )
      if (xf(H[ce][0], ne))
        return ce;
    return -1;
  }
  function Tt(H, ne, ce) {
    ne == "__proto__" && pe ? pe(H, ne, {
      configurable: !0,
      enumerable: !0,
      value: ce,
      writable: !0
    }) : H[ne] = ce;
  }
  var on = MN();
  function Rn(H) {
    return H == null ? H === void 0 ? A : v : re && re in Object(H) ? FN(H) : $N(H);
  }
  function pi(H) {
    return Yc(H) && Rn(H) == a;
  }
  function Lr(H) {
    if (!Hs(H) || VN(H))
      return !1;
    var ne = wm(H) ? je : he;
    return ne.test(KN(H));
  }
  function Ka(H) {
    return Yc(H) && cC(H.length) && !!se[Rn(H)];
  }
  function yi(H) {
    if (!Hs(H))
      return qN(H);
    var ne = aC(H), ce = [];
    for (var Me in H)
      Me == "constructor" && (ne || !qt.call(H, Me)) || ce.push(Me);
    return ce;
  }
  function Gs(H, ne, ce, Me, At) {
    H !== ne && on(ne, function(Ft, Yt) {
      if (At || (At = new ge()), Hs(Ft))
        Ya(H, ne, Yt, ce, Gs, Me, At);
      else {
        var Rt = Me ? Me(mm(H, Yt), Ft, Yt + "", H, ne, At) : void 0;
        Rt === void 0 && (Rt = Ft), Ke(H, Yt, Rt);
      }
    }, dC);
  }
  function Ya(H, ne, ce, Me, At, Ft, Yt) {
    var Rt = mm(H, ce), Qt = mm(ne, ce), gi = Yt.get(Qt);
    if (gi) {
      Ke(H, ce, gi);
      return;
    }
    var Ar = Ft ? Ft(Rt, Qt, ce + "", H, ne, Yt) : void 0, Qc = Ar === void 0;
    if (Qc) {
      var xm = vm(Qt), Cm = !xm && lC(Qt), hC = !xm && !Cm && uC(Qt);
      Ar = Qt, xm || Cm || hC ? vm(Rt) ? Ar = Rt : YN(Rt) ? Ar = mi(Rt) : Cm ? (Qc = !1, Ar = Ht(Qt)) : hC ? (Qc = !1, Ar = Kt(Qt)) : Ar = [] : QN(Qt) || gm(Qt) ? (Ar = Rt, gm(Rt) ? Ar = JN(Rt) : (!Hs(Rt) || wm(Rt)) && (Ar = LN(Qt))) : Qc = !1;
    }
    Qc && (Yt.set(Qt, Ar), At(Ar, Qt, Me, Ft, Yt), Yt.delete(Qt)), Ke(H, ce, Ar);
  }
  function Qa(H, ne) {
    return GN(WN(H, ne, fC), H + "");
  }
  var ft = pe ? function(H, ne) {
    return pe(H, "toString", {
      configurable: !0,
      enumerable: !1,
      value: ZN(ne),
      writable: !0
    });
  } : fC;
  function Ht(H, ne) {
    return H.slice();
  }
  function nr(H) {
    var ne = new H.constructor(H.byteLength);
    return new D(ne).set(new D(H)), ne;
  }
  function Kt(H, ne) {
    var ce = nr(H.buffer);
    return new H.constructor(ce, H.byteOffset, H.length);
  }
  function mi(H, ne) {
    var ce = -1, Me = H.length;
    for (ne || (ne = Array(Me)); ++ce < Me; )
      ne[ce] = H[ce];
    return ne;
  }
  function bf(H, ne, ce, Me) {
    var At = !ce;
    ce || (ce = {});
    for (var Ft = -1, Yt = ne.length; ++Ft < Yt; ) {
      var Rt = ne[Ft], Qt = void 0;
      Qt === void 0 && (Qt = H[Rt]), At ? Tt(ce, Rt, Qt) : rt(ce, Rt, Qt);
    }
    return ce;
  }
  function pm(H) {
    return Qa(function(ne, ce) {
      var Me = -1, At = ce.length, Ft = At > 1 ? ce[At - 1] : void 0, Yt = At > 2 ? ce[2] : void 0;
      for (Ft = H.length > 3 && typeof Ft == "function" ? (At--, Ft) : void 0, Yt && UN(ce[0], ce[1], Yt) && (Ft = At < 3 ? void 0 : Ft, At = 1), ne = Object(ne); ++Me < At; ) {
        var Rt = ce[Me];
        Rt && H(ne, Rt, Me, Ft);
      }
      return ne;
    });
  }
  function MN(H) {
    return function(ne, ce, Me) {
      for (var At = -1, Ft = Object(ne), Yt = Me(ne), Rt = Yt.length; Rt--; ) {
        var Qt = Yt[++At];
        if (ce(Ft[Qt], Qt, Ft) === !1)
          break;
      }
      return ne;
    };
  }
  function wf(H, ne) {
    var ce = H.__data__;
    return zN(ne) ? ce[typeof ne == "string" ? "string" : "hash"] : ce.map;
  }
  function ym(H, ne) {
    var ce = jt(H, ne);
    return Lr(ce) ? ce : void 0;
  }
  function FN(H) {
    var ne = qt.call(H, re), ce = H[re];
    try {
      H[re] = void 0;
      var Me = !0;
    } catch {
    }
    var At = Ve.call(H);
    return Me && (ne ? H[re] = ce : delete H[re]), At;
  }
  function LN(H) {
    return typeof H.constructor == "function" && !aC(H) ? Di(E(H)) : {};
  }
  function sC(H, ne) {
    var ce = typeof H;
    return ne = ne ?? s, !!ne && (ce == "number" || ce != "symbol" && ae.test(H)) && H > -1 && H % 1 == 0 && H < ne;
  }
  function UN(H, ne, ce) {
    if (!Hs(ce))
      return !1;
    var Me = typeof ne;
    return (Me == "number" ? bm(ce) && sC(ne, ce.length) : Me == "string" && ne in ce) ? xf(ce[ne], H) : !1;
  }
  function zN(H) {
    var ne = typeof H;
    return ne == "string" || ne == "number" || ne == "symbol" || ne == "boolean" ? H !== "__proto__" : H === null;
  }
  function VN(H) {
    return !!Cn && Cn in H;
  }
  function aC(H) {
    var ne = H && H.constructor, ce = typeof ne == "function" && ne.prototype || jn;
    return H === ce;
  }
  function qN(H) {
    var ne = [];
    if (H != null)
      for (var ce in Object(H))
        ne.push(ce);
    return ne;
  }
  function $N(H) {
    return Ve.call(H);
  }
  function WN(H, ne, ce) {
    return ne = xt(ne === void 0 ? H.length - 1 : ne, 0), function() {
      for (var Me = arguments, At = -1, Ft = xt(Me.length - ne, 0), Yt = Array(Ft); ++At < Ft; )
        Yt[At] = Me[ne + At];
      At = -1;
      for (var Rt = Array(ne + 1); ++At < ne; )
        Rt[At] = Me[At];
      return Rt[ne] = ce(Yt), ot(H, this, Rt);
    };
  }
  function mm(H, ne) {
    if (!(ne === "constructor" && typeof H[ne] == "function") && ne != "__proto__")
      return H[ne];
  }
  var GN = HN(ft);
  function HN(H) {
    var ne = 0, ce = 0;
    return function() {
      var Me = St(), At = o - (Me - ce);
      if (ce = Me, At > 0) {
        if (++ne >= i)
          return arguments[0];
      } else
        ne = 0;
      return H.apply(void 0, arguments);
    };
  }
  function KN(H) {
    if (H != null) {
      try {
        return Ot.call(H);
      } catch {
      }
      try {
        return H + "";
      } catch {
      }
    }
    return "";
  }
  function xf(H, ne) {
    return H === ne || H !== H && ne !== ne;
  }
  var gm = pi(/* @__PURE__ */ function() {
    return arguments;
  }()) ? pi : function(H) {
    return Yc(H) && qt.call(H, "callee") && !q.call(H, "callee");
  }, vm = Array.isArray;
  function bm(H) {
    return H != null && cC(H.length) && !wm(H);
  }
  function YN(H) {
    return Yc(H) && bm(H);
  }
  var lC = He || eD;
  function wm(H) {
    if (!Hs(H))
      return !1;
    var ne = Rn(H);
    return ne == h || ne == p || ne == c || ne == x;
  }
  function cC(H) {
    return typeof H == "number" && H > -1 && H % 1 == 0 && H <= s;
  }
  function Hs(H) {
    var ne = typeof H;
    return H != null && (ne == "object" || ne == "function");
  }
  function Yc(H) {
    return H != null && typeof H == "object";
  }
  function QN(H) {
    if (!Yc(H) || Rn(H) != w)
      return !1;
    var ne = E(H);
    if (ne === null)
      return !0;
    var ce = qt.call(ne, "constructor") && ne.constructor;
    return typeof ce == "function" && ce instanceof ce && Ot.call(ce) == nt;
  }
  var uC = vt ? tt(vt) : Ka;
  function JN(H) {
    return bf(H, dC(H));
  }
  function dC(H) {
    return bm(H) ? We(H) : yi(H);
  }
  var XN = pm(function(H, ne, ce) {
    Gs(H, ne, ce);
  });
  function ZN(H) {
    return function() {
      return H;
    };
  }
  function fC(H) {
    return H;
  }
  function eD() {
    return !1;
  }
  e.exports = XN;
})(Ep, Ep.exports);
var jve = Ep.exports;
const vv = /* @__PURE__ */ F0(jve), Mve = ({ children: e }) => {
  const { theme: t = { lightMode: qf } } = bt(), n = J(
    () => "lightMode" in t ? vv(structuredClone(qf), t.lightMode) : t ? vv(structuredClone(qf), t) : qf,
    [t]
  ), r = J(
    () => "darkMode" in t ? vv(structuredClone(zX), t.darkMode) : null,
    [t]
  );
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    /* @__PURE__ */ y.jsx(
      "style",
      {
        dangerouslySetInnerHTML: {
          __html: [
            n ? `${v0} {${b0(zt, n)}}` : null,
            r ? `@media (prefers-color-scheme: dark) { ${v0} {${b0(
              zt,
              r
            )}} }` : null
          ].join("")
        }
      }
    ),
    e
  ] });
}, Fve = ({ children: e }) => {
  var n;
  const t = ef();
  return /* @__PURE__ */ y.jsx(
    gI.Provider,
    {
      value: ((n = t.data) == null ? void 0 : n.wagmiConfig) ?? aee,
      children: e
    }
  );
}, Lve = ({
  children: e
}) => /* @__PURE__ */ y.jsx(oD, { children: /* @__PURE__ */ y.jsx(oce, { children: /* @__PURE__ */ y.jsx(Qj, { i18n: iw, children: /* @__PURE__ */ y.jsx(H7, { children: /* @__PURE__ */ y.jsx(G9, { children: /* @__PURE__ */ y.jsx(cue, { children: /* @__PURE__ */ y.jsx(hue, { children: /* @__PURE__ */ y.jsx(Fve, { children: /* @__PURE__ */ y.jsx(dee, { children: /* @__PURE__ */ y.jsx(Mee, { children: /* @__PURE__ */ y.jsx(Dve, { children: /* @__PURE__ */ y.jsx(Hce, { children: /* @__PURE__ */ y.jsx(Tye, { children: /* @__PURE__ */ y.jsx(Mve, { children: /* @__PURE__ */ y.jsx(Ive, { children: /* @__PURE__ */ y.jsx(Sce, { children: /* @__PURE__ */ y.jsx(ele, { children: /* @__PURE__ */ y.jsx(Nce, { children: /* @__PURE__ */ y.jsx(Dce, { children: /* @__PURE__ */ y.jsx(pue, { children: /* @__PURE__ */ y.jsx(Cpe, { children: /* @__PURE__ */ y.jsx(Ype, { children: /* @__PURE__ */ y.jsx(oue, { children: /* @__PURE__ */ y.jsx(nue, { children: /* @__PURE__ */ y.jsx(qce, { children: e }) }) }) }) }) }) }) }) }) }) }) }) }) }) }) }) }) }) }) }) }) }) }) }) });
aue();
const Uve = () => {
  var d;
  VX();
  const e = zee();
  R9();
  const { chain: t, address: n } = wt(), r = fp(t), i = fp(n), { current: o } = gx(), s = Dt(o.pathname), a = Dt(er());
  Bo(() => {
    s.current !== "/" && s.current !== "/positions" && s.current !== "/activity" && (r && t !== r || i && n !== i) && Tn.ifJust((f) => {
      const h = new URL(f.location.href), p = new URL(f.location.origin);
      h.searchParams.has("embed") && p.searchParams.set("embed", "true"), f.history.pushState({}, f.document.title, p.href), a.current("/", { replace: !0 });
    });
  }, [t, n, s, a, r, i]);
  const l = (d = cd().data) == null ? void 0 : d.tab;
  Te(() => {
    l && a.current(l === "earn" ? "/" : "/positions");
  }, [l, a]), Gpe();
  const u = qO() ? "/" : o.pathname;
  return e ? /* @__PURE__ */ y.jsx(wue, {}) : /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    /* @__PURE__ */ y.jsx(kpe, { children: /* @__PURE__ */ y.jsxs(loe, { children: [
      /* @__PURE__ */ y.jsx(Zt.div, { layout: "position", className: Ace, children: /* @__PURE__ */ y.jsx(nle, {}) }),
      /* @__PURE__ */ y.jsx(Zt.div, { layout: "position", className: mue, children: /* @__PURE__ */ y.jsx(Fy, { children: /* @__PURE__ */ y.jsx(oae, { location: o, children: /* @__PURE__ */ y.jsxs(Lt, { element: /* @__PURE__ */ y.jsx(_ce, { currentPathname: o.pathname }), children: [
        /* @__PURE__ */ y.jsxs(Lt, { element: /* @__PURE__ */ y.jsx(Jge, {}), children: [
          /* @__PURE__ */ y.jsx(Lt, { index: !0, element: /* @__PURE__ */ y.jsx(qge, {}) }),
          /* @__PURE__ */ y.jsx(Lt, { path: "positions", element: /* @__PURE__ */ y.jsx(aye, {}) }),
          /* @__PURE__ */ y.jsx(Lt, { path: "activity", element: /* @__PURE__ */ y.jsx(ade, {}) })
        ] }),
        /* @__PURE__ */ y.jsxs(Lt, { element: /* @__PURE__ */ y.jsx(Hpe, {}), children: [
          /* @__PURE__ */ y.jsxs(Lt, { path: "activity", children: [
            /* @__PURE__ */ y.jsx(Lt, { path: "review", element: /* @__PURE__ */ y.jsx(Rfe, {}) }),
            /* @__PURE__ */ y.jsx(
              Lt,
              {
                path: ":pendingActionType/steps",
                element: /* @__PURE__ */ y.jsx(Rpe, {})
              }
            ),
            /* @__PURE__ */ y.jsx(
              Lt,
              {
                path: ":pendingActionType/complete",
                element: /* @__PURE__ */ y.jsx(Gce, {})
              }
            )
          ] }),
          /* @__PURE__ */ y.jsxs(Lt, { children: [
            /* @__PURE__ */ y.jsx(Lt, { path: "review", element: /* @__PURE__ */ y.jsx(Zge, {}) }),
            /* @__PURE__ */ y.jsx(Lt, { path: "steps", element: /* @__PURE__ */ y.jsx(eve, {}) }),
            /* @__PURE__ */ y.jsx(Lt, { path: "complete", element: /* @__PURE__ */ y.jsx(Qpe, {}) })
          ] }),
          /* @__PURE__ */ y.jsxs(Lt, { path: "positions/:integrationId/:balanceId", children: [
            /* @__PURE__ */ y.jsx(Lt, { index: !0, element: /* @__PURE__ */ y.jsx(KS, {}) }),
            /* @__PURE__ */ y.jsx(
              Lt,
              {
                path: "select-validator/:pendingActionType",
                element: /* @__PURE__ */ y.jsx(KS, {})
              }
            ),
            /* @__PURE__ */ y.jsxs(Lt, { path: "unstake", children: [
              /* @__PURE__ */ y.jsx(Lt, { path: "review", element: /* @__PURE__ */ y.jsx(fpe, {}) }),
              /* @__PURE__ */ y.jsx(Lt, { path: "steps", element: /* @__PURE__ */ y.jsx(Ope, {}) }),
              /* @__PURE__ */ y.jsx(
                Lt,
                {
                  path: "complete",
                  element: /* @__PURE__ */ y.jsx(sue, {})
                }
              )
            ] }),
            /* @__PURE__ */ y.jsxs(Lt, { path: "pending-action", children: [
              /* @__PURE__ */ y.jsx(Lt, { path: "review", element: /* @__PURE__ */ y.jsx(Ufe, {}) }),
              /* @__PURE__ */ y.jsx(Lt, { path: "steps", element: /* @__PURE__ */ y.jsx(Ppe, {}) }),
              /* @__PURE__ */ y.jsx(
                Lt,
                {
                  path: "complete",
                  element: /* @__PURE__ */ y.jsx(rue, {})
                }
              )
            ] })
          ] })
        ] }),
        /* @__PURE__ */ y.jsx(Lt, { path: "*", element: /* @__PURE__ */ y.jsx(UO, { to: "/", replace: !0 }) })
      ] }) }, u) }) }),
      /* @__PURE__ */ y.jsx(rve, {}),
      /* @__PURE__ */ y.jsx(M6, {})
    ] }) }),
    /* @__PURE__ */ y.jsx($pe, {})
  ] });
}, zve = () => {
  const [e, t] = Oe(!1);
  return Bo(() => t(!0), []), /* @__PURE__ */ y.jsx(Lve, { children: e && /* @__PURE__ */ y.jsx(Uve, {}) });
}, Tbe = (e) => {
  const t = !e.variant || e.variant === "default" ? { variant: "default" } : { variant: e.variant, chainModal: e.chainModal }, [n] = Oe(
    () => aae([{ path: "*", Component: zve }])
  );
  return /* @__PURE__ */ y.jsx(G7, { ...t, ...e, children: /* @__PURE__ */ y.jsx(z, { className: gue, children: /* @__PURE__ */ y.jsx(Eae, { router: n }) }) });
};
export {
  qe as $,
  Vt as A,
  be as B,
  Uv as C,
  uT as D,
  iG as E,
  Qn as F,
  pbe as G,
  _u as H,
  z_ as I,
  xo as J,
  Re as K,
  Np as L,
  G as M,
  mbe as N,
  vee as O,
  is as P,
  Pd as Q,
  pt as R,
  nT as S,
  KX as T,
  ybe as U,
  pn as V,
  hbe as W,
  gee as X,
  I2 as Y,
  Je as Z,
  La as _,
  gw as a,
  Tbe as a0,
  uee as a1,
  Mpe as a2,
  zX as a3,
  qf as a4,
  Gd as b,
  Xp as c,
  nq as d,
  gk as e,
  Ro as f,
  F0 as g,
  Bc as h,
  Pw as i,
  ii as j,
  Wve as k,
  Yve as l,
  pu as m,
  GM as n,
  JA as o,
  ke as p,
  bee as q,
  Fa as r,
  Jn as s,
  vr as t,
  vbe as u,
  np as v,
  qZ as w,
  de as x,
  Sy as y,
  Ua as z
};
//# sourceMappingURL=index.package-BC048X0m.js.map
