{"version":3,"file":"index-CcuXBgjD.js","sources":["../../../../../node_modules/@ledgerhq/logs/lib-es/index.js"],"sourcesContent":["let id = 0;\nconst subscribers = [];\n/**\n * Logs something\n *\n * @param type a namespaced identifier of the log (it is not a level like \"debug\", \"error\" but more like \"apdu-in\", \"apdu-out\", etc...)\n * @param message a clear message of the log associated to the type\n */\nexport const log = (type, message, data) => {\n    const obj = {\n        type,\n        id: String(++id),\n        date: new Date(),\n    };\n    if (message)\n        obj.message = message;\n    if (data)\n        obj.data = data;\n    dispatch(obj);\n};\n/**\n * A simple tracer function, only expanding the existing log function\n *\n * Its goal is to capture more context than a log function.\n * This is simple for now, but can be improved later.\n *\n * @param context Anything representing the context where the log occurred\n */\nexport const trace = ({ type, message, data, context, }) => {\n    const obj = {\n        type,\n        id: String(++id),\n        date: new Date(),\n    };\n    if (message)\n        obj.message = message;\n    if (data)\n        obj.data = data;\n    if (context)\n        obj.context = context;\n    dispatch(obj);\n};\n/**\n * A simple tracer class, that can be used to avoid repetition when using the `trace` function\n *\n * Its goal is to capture more context than a log function.\n * This is simple for now, but can be improved later.\n *\n * @param type A given type (not level) for the current local tracer (\"hw\", \"withDevice\", etc.)\n * @param context Anything representing the context where the log occurred\n */\nexport class LocalTracer {\n    constructor(type, context) {\n        this.type = type;\n        this.context = context;\n    }\n    trace(message, data) {\n        trace({\n            type: this.type,\n            message,\n            data,\n            context: this.context,\n        });\n    }\n    getContext() {\n        return this.context;\n    }\n    setContext(context) {\n        this.context = context;\n    }\n    updateContext(contextToAdd) {\n        this.context = Object.assign(Object.assign({}, this.context), contextToAdd);\n    }\n    getType() {\n        return this.type;\n    }\n    setType(type) {\n        this.type = type;\n    }\n    /**\n     * Create a new instance of the LocalTracer with an updated `type`\n     *\n     * It does not mutate the calling instance, but returns a new LocalTracer,\n     * following a simple builder pattern.\n     */\n    withType(type) {\n        return new LocalTracer(type, this.context);\n    }\n    /**\n     * Create a new instance of the LocalTracer with a new `context`\n     *\n     * It does not mutate the calling instance, but returns a new LocalTracer,\n     * following a simple builder pattern.\n     *\n     * @param context A TraceContext, that can undefined to reset the context\n     */\n    withContext(context) {\n        return new LocalTracer(this.type, context);\n    }\n    /**\n     * Create a new instance of the LocalTracer with an updated `context`,\n     * on which an additional context is merged with the existing one.\n     *\n     * It does not mutate the calling instance, but returns a new LocalTracer,\n     * following a simple builder pattern.\n     */\n    withUpdatedContext(contextToAdd) {\n        return new LocalTracer(this.type, Object.assign(Object.assign({}, this.context), contextToAdd));\n    }\n}\n/**\n * Adds a subscribers to the emitted logs.\n *\n * @param cb that is called for each future log() with the Log object\n * @return a function that can be called to unsubscribe the listener\n */\nexport const listen = (cb) => {\n    subscribers.push(cb);\n    return () => {\n        const i = subscribers.indexOf(cb);\n        if (i !== -1) {\n            // equivalent of subscribers.splice(i, 1) // https://twitter.com/Rich_Harris/status/1125850391155965952\n            subscribers[i] = subscribers[subscribers.length - 1];\n            subscribers.pop();\n        }\n    };\n};\nfunction dispatch(log) {\n    for (let i = 0; i < subscribers.length; i++) {\n        try {\n            subscribers[i](log);\n        }\n        catch (e) {\n            console.error(e);\n        }\n    }\n}\nif (typeof window !== \"undefined\") {\n    window.__ledgerLogsListen = listen;\n}\n//# sourceMappingURL=index.js.map"],"names":["id","subscribers","log","type","message","data","obj","dispatch","trace","context","LocalTracer","contextToAdd","listen","cb","i"],"mappings":"AAAA,IAAIA,EAAK,EACT,MAAMC,EAAc,CAAA,EAOPC,EAAM,CAACC,EAAMC,EAASC,IAAS,CACxC,MAAMC,EAAM,CACR,KAAAH,EACA,GAAI,OAAO,EAAEH,CAAE,EACf,KAAM,IAAI,IAClB,EACQI,IACAE,EAAI,QAAUF,GAGlBG,EAASD,CAAG,CAChB,EASaE,EAAQ,CAAC,CAAE,KAAAL,EAAM,QAAAC,EAAS,KAAAC,EAAM,QAAAI,CAAO,IAAQ,CACxD,MAAMH,EAAM,CACR,KAAAH,EACA,GAAI,OAAO,EAAEH,CAAE,EACf,KAAM,IAAI,IAClB,EACQI,IACAE,EAAI,QAAUF,GACdC,IACAC,EAAI,KAAOD,GACXI,IACAH,EAAI,QAAUG,GAClBF,EAASD,CAAG,CAChB,EAUO,MAAMI,CAAY,CACrB,YAAYP,EAAMM,EAAS,CACvB,KAAK,KAAON,EACZ,KAAK,QAAUM,CAClB,CACD,MAAML,EAASC,EAAM,CACjBG,EAAM,CACF,KAAM,KAAK,KACX,QAAAJ,EACA,KAAAC,EACA,QAAS,KAAK,OAC1B,CAAS,CACJ,CACD,YAAa,CACT,OAAO,KAAK,OACf,CACD,WAAWI,EAAS,CAChB,KAAK,QAAUA,CAClB,CACD,cAAcE,EAAc,CACxB,KAAK,QAAU,OAAO,OAAO,OAAO,OAAO,CAAA,EAAI,KAAK,OAAO,EAAGA,CAAY,CAC7E,CACD,SAAU,CACN,OAAO,KAAK,IACf,CACD,QAAQR,EAAM,CACV,KAAK,KAAOA,CACf,CAOD,SAASA,EAAM,CACX,OAAO,IAAIO,EAAYP,EAAM,KAAK,OAAO,CAC5C,CASD,YAAYM,EAAS,CACjB,OAAO,IAAIC,EAAY,KAAK,KAAMD,CAAO,CAC5C,CAQD,mBAAmBE,EAAc,CAC7B,OAAO,IAAID,EAAY,KAAK,KAAM,OAAO,OAAO,OAAO,OAAO,CAAE,EAAE,KAAK,OAAO,EAAGC,CAAY,CAAC,CACjG,CACL,CAOO,MAAMC,EAAUC,IACnBZ,EAAY,KAAKY,CAAE,EACZ,IAAM,CACT,MAAMC,EAAIb,EAAY,QAAQY,CAAE,EAC5BC,IAAM,KAENb,EAAYa,CAAC,EAAIb,EAAYA,EAAY,OAAS,CAAC,EACnDA,EAAY,IAAG,EAE3B,GAEA,SAASM,EAASL,EAAK,CACnB,QAASY,EAAI,EAAGA,EAAIb,EAAY,OAAQa,IACpC,GAAI,CACAb,EAAYa,CAAC,EAAEZ,CAAG,CACrB,MACS,CAET,CAET,CACI,OAAO,OAAW,MAClB,OAAO,mBAAqBU","x_google_ignoreList":[0]}