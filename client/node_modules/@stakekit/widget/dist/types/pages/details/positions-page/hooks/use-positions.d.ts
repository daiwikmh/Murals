import type { ValidatorDto, ValidatorSearchResultDto, YieldBalanceDto, YieldBalanceLabelDto, YieldBalancesWithIntegrationIdDto } from "@stakekit/api-hooks";
import { Maybe } from "purify-ts";
export declare const usePositions: () => {
    positionsData: {
        data: ({
            integrationId: YieldBalancesWithIntegrationIdDto["integrationId"];
            balancesWithAmount: YieldBalanceDto[];
            allBalances: YieldBalanceDto[];
            balanceId: YieldBalanceDto["groupId"];
            actionRequired: boolean;
            amount: string;
            pointsRewardTokenBalance: Maybe<YieldBalanceDto>;
            hasPendingClaimRewards: boolean;
            token: Maybe<YieldBalanceDto["token"]>;
            yieldLabelDto: Maybe<YieldBalanceLabelDto>;
        } & ({
            type: "validators";
            validatorsAddresses: string[];
        } | {
            type: "default";
        }))[];
        error: import("@stakekit/api-hooks").StakeKitErrorDto;
        isError: true;
        isPending: false;
        isLoading: false;
        isLoadingError: false;
        isRefetchError: true;
        isSuccess: false;
        status: "error";
        dataUpdatedAt: number;
        errorUpdatedAt: number;
        failureCount: number;
        failureReason: import("@stakekit/api-hooks").StakeKitErrorDto | null;
        errorUpdateCount: number;
        isFetched: boolean;
        isFetchedAfterMount: boolean;
        isFetching: boolean;
        isInitialLoading: boolean;
        isPaused: boolean;
        isPlaceholderData: boolean;
        isRefetching: boolean;
        isStale: boolean;
        refetch: (options?: import("@tanstack/query-core").RefetchOptions) => Promise<import("@tanstack/query-core").QueryObserverResult<import("../../../../domain/types/positions").PositionsData, import("@stakekit/api-hooks").StakeKitErrorDto>>;
        fetchStatus: import("@tanstack/query-core").FetchStatus;
        queryKey: import("@tanstack/query-core").QueryKey;
    } | {
        data: ({
            integrationId: YieldBalancesWithIntegrationIdDto["integrationId"];
            balancesWithAmount: YieldBalanceDto[];
            allBalances: YieldBalanceDto[];
            balanceId: YieldBalanceDto["groupId"];
            actionRequired: boolean;
            amount: string;
            pointsRewardTokenBalance: Maybe<YieldBalanceDto>;
            hasPendingClaimRewards: boolean;
            token: Maybe<YieldBalanceDto["token"]>;
            yieldLabelDto: Maybe<YieldBalanceLabelDto>;
        } & ({
            type: "validators";
            validatorsAddresses: string[];
        } | {
            type: "default";
        }))[];
        error: null;
        isError: false;
        isPending: false;
        isLoading: false;
        isLoadingError: false;
        isRefetchError: false;
        isSuccess: true;
        status: "success";
        dataUpdatedAt: number;
        errorUpdatedAt: number;
        failureCount: number;
        failureReason: import("@stakekit/api-hooks").StakeKitErrorDto | null;
        errorUpdateCount: number;
        isFetched: boolean;
        isFetchedAfterMount: boolean;
        isFetching: boolean;
        isInitialLoading: boolean;
        isPaused: boolean;
        isPlaceholderData: boolean;
        isRefetching: boolean;
        isStale: boolean;
        refetch: (options?: import("@tanstack/query-core").RefetchOptions) => Promise<import("@tanstack/query-core").QueryObserverResult<import("../../../../domain/types/positions").PositionsData, import("@stakekit/api-hooks").StakeKitErrorDto>>;
        fetchStatus: import("@tanstack/query-core").FetchStatus;
        queryKey: import("@tanstack/query-core").QueryKey;
    } | {
        data: ({
            integrationId: YieldBalancesWithIntegrationIdDto["integrationId"];
            balancesWithAmount: YieldBalanceDto[];
            allBalances: YieldBalanceDto[];
            balanceId: YieldBalanceDto["groupId"];
            actionRequired: boolean;
            amount: string;
            pointsRewardTokenBalance: Maybe<YieldBalanceDto>;
            hasPendingClaimRewards: boolean;
            token: Maybe<YieldBalanceDto["token"]>;
            yieldLabelDto: Maybe<YieldBalanceLabelDto>;
        } & ({
            type: "validators";
            validatorsAddresses: string[];
        } | {
            type: "default";
        }))[];
        error: import("@stakekit/api-hooks").StakeKitErrorDto;
        isError: true;
        isPending: false;
        isLoading: false;
        isLoadingError: true;
        isRefetchError: false;
        isSuccess: false;
        status: "error";
        dataUpdatedAt: number;
        errorUpdatedAt: number;
        failureCount: number;
        failureReason: import("@stakekit/api-hooks").StakeKitErrorDto | null;
        errorUpdateCount: number;
        isFetched: boolean;
        isFetchedAfterMount: boolean;
        isFetching: boolean;
        isInitialLoading: boolean;
        isPaused: boolean;
        isPlaceholderData: boolean;
        isRefetching: boolean;
        isStale: boolean;
        refetch: (options?: import("@tanstack/query-core").RefetchOptions) => Promise<import("@tanstack/query-core").QueryObserverResult<import("../../../../domain/types/positions").PositionsData, import("@stakekit/api-hooks").StakeKitErrorDto>>;
        fetchStatus: import("@tanstack/query-core").FetchStatus;
        queryKey: import("@tanstack/query-core").QueryKey;
    } | {
        data: ({
            integrationId: YieldBalancesWithIntegrationIdDto["integrationId"];
            balancesWithAmount: YieldBalanceDto[];
            allBalances: YieldBalanceDto[];
            balanceId: YieldBalanceDto["groupId"];
            actionRequired: boolean;
            amount: string;
            pointsRewardTokenBalance: Maybe<YieldBalanceDto>;
            hasPendingClaimRewards: boolean;
            token: Maybe<YieldBalanceDto["token"]>;
            yieldLabelDto: Maybe<YieldBalanceLabelDto>;
        } & ({
            type: "validators";
            validatorsAddresses: string[];
        } | {
            type: "default";
        }))[];
        error: null;
        isError: false;
        isPending: true;
        isLoading: true;
        isLoadingError: false;
        isRefetchError: false;
        isSuccess: false;
        status: "pending";
        dataUpdatedAt: number;
        errorUpdatedAt: number;
        failureCount: number;
        failureReason: import("@stakekit/api-hooks").StakeKitErrorDto | null;
        errorUpdateCount: number;
        isFetched: boolean;
        isFetchedAfterMount: boolean;
        isFetching: boolean;
        isInitialLoading: boolean;
        isPaused: boolean;
        isPlaceholderData: boolean;
        isRefetching: boolean;
        isStale: boolean;
        refetch: (options?: import("@tanstack/query-core").RefetchOptions) => Promise<import("@tanstack/query-core").QueryObserverResult<import("../../../../domain/types/positions").PositionsData, import("@stakekit/api-hooks").StakeKitErrorDto>>;
        fetchStatus: import("@tanstack/query-core").FetchStatus;
        queryKey: import("@tanstack/query-core").QueryKey;
    } | {
        data: ({
            integrationId: YieldBalancesWithIntegrationIdDto["integrationId"];
            balancesWithAmount: YieldBalanceDto[];
            allBalances: YieldBalanceDto[];
            balanceId: YieldBalanceDto["groupId"];
            actionRequired: boolean;
            amount: string;
            pointsRewardTokenBalance: Maybe<YieldBalanceDto>;
            hasPendingClaimRewards: boolean;
            token: Maybe<YieldBalanceDto["token"]>;
            yieldLabelDto: Maybe<YieldBalanceLabelDto>;
        } & ({
            type: "validators";
            validatorsAddresses: string[];
        } | {
            type: "default";
        }))[];
        error: null;
        isError: false;
        isPending: true;
        isLoadingError: false;
        isRefetchError: false;
        isSuccess: false;
        status: "pending";
        dataUpdatedAt: number;
        errorUpdatedAt: number;
        failureCount: number;
        failureReason: import("@stakekit/api-hooks").StakeKitErrorDto | null;
        errorUpdateCount: number;
        isFetched: boolean;
        isFetchedAfterMount: boolean;
        isFetching: boolean;
        isLoading: boolean;
        isInitialLoading: boolean;
        isPaused: boolean;
        isPlaceholderData: boolean;
        isRefetching: boolean;
        isStale: boolean;
        refetch: (options?: import("@tanstack/query-core").RefetchOptions) => Promise<import("@tanstack/query-core").QueryObserverResult<import("../../../../domain/types/positions").PositionsData, import("@stakekit/api-hooks").StakeKitErrorDto>>;
        fetchStatus: import("@tanstack/query-core").FetchStatus;
        queryKey: import("@tanstack/query-core").QueryKey;
    };
    listData: ("header" | ({
        integrationId: YieldBalancesWithIntegrationIdDto["integrationId"];
        balancesWithAmount: YieldBalanceDto[];
        allBalances: YieldBalanceDto[];
        balanceId: YieldBalanceDto["groupId"];
        actionRequired: boolean;
        amount: string;
        pointsRewardTokenBalance: Maybe<YieldBalanceDto>;
        hasPendingClaimRewards: boolean;
        token: Maybe<YieldBalanceDto["token"]>;
        yieldLabelDto: Maybe<YieldBalanceLabelDto>;
    } & ({
        type: "validators";
        validatorsAddresses: string[];
    } | {
        type: "default";
    })))[];
    importValidators: {
        foundValidatorsData: import("purify-ts/Maybe").Maybe<{
            integrationId: ValidatorSearchResultDto["integrationId"];
            validator: ValidatorDto;
        }[]>;
        onValidatorAddressOrNameChange: (validatorAddress: string) => void;
        isLoading: boolean;
        errorMessage: string | undefined;
        onClose: () => void;
        onImportValidatorImport: (val: {
            integrationId: ValidatorSearchResultDto["integrationId"];
            validator: ValidatorDto;
        }) => void;
    };
    showPositions: boolean;
};
