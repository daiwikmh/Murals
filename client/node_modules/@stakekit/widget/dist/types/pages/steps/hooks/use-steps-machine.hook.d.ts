import type { ActionDto, TransactionDto } from "@stakekit/api-hooks";
import { Maybe } from "purify-ts";
import type { GetStakeSessionError, SendTransactionError } from "./errors";
import { SignError, SubmitHashError, TXCheckError } from "./errors";
type TxMeta = {
    url: string | null;
    signedTx: string | null;
    broadcasted: boolean | null;
    signError: Error | GetStakeSessionError | SendTransactionError | SignError | null;
    txCheckError: GetStakeSessionError | null;
    done: boolean;
};
export type TxState = {
    tx: TransactionDto;
    meta: TxMeta;
};
type SignRes = {
    type: "broadcasted";
} | {
    type: "regular";
    data: {
        signedTx: string;
        broadcasted: boolean;
    };
};
export declare const useStepsMachine: ({ transactions, integrationId, }: {
    transactions: ActionDto["transactions"];
    integrationId: ActionDto["integrationId"];
}) => [import("xstate").MachineSnapshot<{
    yieldId: Maybe<string>;
    txStates: TxState[];
    currentTxMeta: Maybe<{
        idx: number;
        id: string;
    }>;
    txCheckTimeoutId: Maybe<number>;
}, {
    type: "START";
} | {
    type: "__SIGN_SUCCESS__";
    val: Extract<SignRes, {
        type: "regular";
    }>;
} | {
    type: "__SIGN_ERROR__";
    val: Error;
} | {
    type: "__BROADCAST_SUCCESS__";
} | {
    type: "__BROADCAST_ERROR__";
    val: Error | SubmitHashError;
} | {
    type: "__DONE__";
    val: TxState[];
} | {
    type: "__SIGN_RETRY__";
} | {
    type: "__BROADCAST_RETRY__";
} | {
    type: "__SIGN_NEXT_TX__";
    val: {
        newCurrentTxMeta: {
            idx: number;
            id: string;
        };
        newTxStates: TxState[];
    };
} | {
    type: "__TX_CHECK_ERROR__";
    val: Error | SignError | TXCheckError;
} | {
    type: "__TX_CHECK_RETRY__";
} | {
    type: "__TX_CHECK_RETRY_TIMEOUT__";
    val: number;
}, {}, "done" | "disabled" | "idle" | "signLoading" | "broadcastLoading" | "signError" | "txCheckLoading" | "broadcastError" | "txCheckError" | "txCheckRetry", string, import("xstate").NonReducibleUnknown, import("xstate").MetaObject, {
    readonly context: {
        readonly yieldId: import("purify-ts/Maybe").Maybe<string>;
        readonly txStates: TxState[];
        readonly currentTxMeta: import("purify-ts/Maybe").Maybe<{
            idx: number;
            id: string;
        }>;
        readonly txCheckTimeoutId: {
            isJust(): this is import("purify-ts").AlwaysJust;
            isNothing(): this is any;
            inspect(): string;
            toString(): string;
            toJSON(): never;
            equals<T>(other: import("purify-ts/Maybe").Maybe<T>): boolean;
            map<U>(_: (value: never) => U): import("purify-ts/Maybe").Maybe<U>;
            ap<U>(_: import("purify-ts/Maybe").Maybe<(value: never) => U>): import("purify-ts/Maybe").Maybe<U>;
            alt<T>(other: import("purify-ts/Maybe").Maybe<T>): import("purify-ts/Maybe").Maybe<T>;
            altLazy<T>(other: () => import("purify-ts/Maybe").Maybe<T>): import("purify-ts/Maybe").Maybe<T>;
            chain<U>(_: (value: never) => import("purify-ts/Maybe").Maybe<U>): import("purify-ts/Maybe").Maybe<U>;
            chainNullable<U>(_: (value: never) => U | undefined | null | void): import("purify-ts/Maybe").Maybe<U>;
            join<U>(this: import("purify-ts/Maybe").Maybe<import("purify-ts/Maybe").Maybe<U>>): import("purify-ts/Maybe").Maybe<U>;
            reduce<U>(_: (accumulator: U, value: never) => U, initialValue: U): U;
            extend<U>(_: (value: import("purify-ts/Maybe").Maybe<never>) => U): import("purify-ts/Maybe").Maybe<U>;
            unsafeCoerce<T>(): T;
            caseOf<U>(patterns: import("purify-ts").MaybePatterns<never, U>): U;
            orDefault<T>(defaultValue: T): T;
            orDefaultLazy<T>(getDefaultValue: () => T): T;
            toList<T>(): T[];
            mapOrDefault<U>(_: (value: never) => U, defaultValue: U): U;
            extract(): never;
            extractNullable(): never;
            toEither<L, T>(left: L): import("purify-ts").Either<L, T>;
            ifJust(_: (value: never) => any): any;
            ifNothing(effect: () => any): any;
            filter(_: (value: never) => boolean): import("purify-ts/Maybe").Maybe<never>;
            'fantasy-land/equals': <T>(other: import("purify-ts/Maybe").Maybe<T>) => boolean;
            'fantasy-land/map': <U>(_: (value: never) => U) => import("purify-ts/Maybe").Maybe<U>;
            'fantasy-land/ap': <U>(_: import("purify-ts/Maybe").Maybe<(value: never) => U>) => import("purify-ts/Maybe").Maybe<U>;
            'fantasy-land/alt': <T>(other: import("purify-ts/Maybe").Maybe<T>) => import("purify-ts/Maybe").Maybe<T>;
            'fantasy-land/chain': <U>(_: (value: never) => import("purify-ts/Maybe").Maybe<U>) => import("purify-ts/Maybe").Maybe<U>;
            'fantasy-land/reduce': <U>(_: (accumulator: U, value: never) => U, initialValue: U) => U;
            'fantasy-land/extend': <U>(_: (value: import("purify-ts/Maybe").Maybe<never>) => U) => import("purify-ts/Maybe").Maybe<U>;
            'fantasy-land/filter': (_: (value: never) => boolean) => import("purify-ts/Maybe").Maybe<never>;
        };
    };
    readonly initial: "disabled" | "idle";
    readonly states: {
        readonly idle: {
            readonly on: {
                readonly START: "signLoading";
            };
        };
        readonly disabled: {};
        readonly signLoading: {
            readonly on: {
                readonly __SIGN_SUCCESS__: {
                    readonly target: "broadcastLoading";
                    readonly actions: readonly [import("xstate").ActionFunction<{
                        yieldId: Maybe<string>;
                        txStates: TxState[];
                        currentTxMeta: Maybe<{
                            idx: number;
                            id: string;
                        }>;
                        txCheckTimeoutId: Maybe<number>;
                    }, {
                        type: "__SIGN_SUCCESS__";
                        val: Extract<SignRes, {
                            type: "regular";
                        }>;
                    }, {
                        type: "START";
                    } | {
                        type: "__SIGN_SUCCESS__";
                        val: Extract<SignRes, {
                            type: "regular";
                        }>;
                    } | {
                        type: "__SIGN_ERROR__";
                        val: Error;
                    } | {
                        type: "__BROADCAST_SUCCESS__";
                    } | {
                        type: "__BROADCAST_ERROR__";
                        val: Error | SubmitHashError;
                    } | {
                        type: "__DONE__";
                        val: TxState[];
                    } | {
                        type: "__SIGN_RETRY__";
                    } | {
                        type: "__BROADCAST_RETRY__";
                    } | {
                        type: "__SIGN_NEXT_TX__";
                        val: {
                            newCurrentTxMeta: {
                                idx: number;
                                id: string;
                            };
                            newTxStates: TxState[];
                        };
                    } | {
                        type: "__TX_CHECK_ERROR__";
                        val: Error | SignError | TXCheckError;
                    } | {
                        type: "__TX_CHECK_RETRY__";
                    } | {
                        type: "__TX_CHECK_RETRY_TIMEOUT__";
                        val: number;
                    }, undefined, never, never, never, never, never>, import("xstate").ActionFunction<{
                        yieldId: Maybe<string>;
                        txStates: TxState[];
                        currentTxMeta: Maybe<{
                            idx: number;
                            id: string;
                        }>;
                        txCheckTimeoutId: Maybe<number>;
                    }, {
                        type: "__SIGN_SUCCESS__";
                        val: Extract<SignRes, {
                            type: "regular";
                        }>;
                    }, {
                        type: "START";
                    } | {
                        type: "__SIGN_SUCCESS__";
                        val: Extract<SignRes, {
                            type: "regular";
                        }>;
                    } | {
                        type: "__SIGN_ERROR__";
                        val: Error;
                    } | {
                        type: "__BROADCAST_SUCCESS__";
                    } | {
                        type: "__BROADCAST_ERROR__";
                        val: Error | SubmitHashError;
                    } | {
                        type: "__DONE__";
                        val: TxState[];
                    } | {
                        type: "__SIGN_RETRY__";
                    } | {
                        type: "__BROADCAST_RETRY__";
                    } | {
                        type: "__SIGN_NEXT_TX__";
                        val: {
                            newCurrentTxMeta: {
                                idx: number;
                                id: string;
                            };
                            newTxStates: TxState[];
                        };
                    } | {
                        type: "__TX_CHECK_ERROR__";
                        val: Error | SignError | TXCheckError;
                    } | {
                        type: "__TX_CHECK_RETRY__";
                    } | {
                        type: "__TX_CHECK_RETRY_TIMEOUT__";
                        val: number;
                    }, undefined, never, never, never, never, {
                        type: "signSuccess";
                    }>];
                };
                readonly __SIGN_ERROR__: {
                    readonly target: "signError";
                    readonly actions: import("xstate").ActionFunction<{
                        yieldId: Maybe<string>;
                        txStates: TxState[];
                        currentTxMeta: Maybe<{
                            idx: number;
                            id: string;
                        }>;
                        txCheckTimeoutId: Maybe<number>;
                    }, {
                        type: "__SIGN_ERROR__";
                        val: Error;
                    }, {
                        type: "START";
                    } | {
                        type: "__SIGN_SUCCESS__";
                        val: Extract<SignRes, {
                            type: "regular";
                        }>;
                    } | {
                        type: "__SIGN_ERROR__";
                        val: Error;
                    } | {
                        type: "__BROADCAST_SUCCESS__";
                    } | {
                        type: "__BROADCAST_ERROR__";
                        val: Error | SubmitHashError;
                    } | {
                        type: "__DONE__";
                        val: TxState[];
                    } | {
                        type: "__SIGN_RETRY__";
                    } | {
                        type: "__BROADCAST_RETRY__";
                    } | {
                        type: "__SIGN_NEXT_TX__";
                        val: {
                            newCurrentTxMeta: {
                                idx: number;
                                id: string;
                            };
                            newTxStates: TxState[];
                        };
                    } | {
                        type: "__TX_CHECK_ERROR__";
                        val: Error | SignError | TXCheckError;
                    } | {
                        type: "__TX_CHECK_RETRY__";
                    } | {
                        type: "__TX_CHECK_RETRY_TIMEOUT__";
                        val: number;
                    }, undefined, never, never, never, never, never>;
                };
                readonly __BROADCAST_SUCCESS__: "txCheckLoading";
            };
            readonly entry: ({ context, self }: import("xstate").ActionArgs<{
                yieldId: Maybe<string>;
                txStates: TxState[];
                currentTxMeta: Maybe<{
                    idx: number;
                    id: string;
                }>;
                txCheckTimeoutId: Maybe<number>;
            }, {
                type: "START";
            } | {
                type: "__SIGN_SUCCESS__";
                val: Extract<SignRes, {
                    type: "regular";
                }>;
            } | {
                type: "__SIGN_ERROR__";
                val: Error;
            } | {
                type: "__BROADCAST_SUCCESS__";
            } | {
                type: "__BROADCAST_ERROR__";
                val: Error | SubmitHashError;
            } | {
                type: "__DONE__";
                val: TxState[];
            } | {
                type: "__SIGN_RETRY__";
            } | {
                type: "__BROADCAST_RETRY__";
            } | {
                type: "__SIGN_NEXT_TX__";
                val: {
                    newCurrentTxMeta: {
                        idx: number;
                        id: string;
                    };
                    newTxStates: TxState[];
                };
            } | {
                type: "__TX_CHECK_ERROR__";
                val: Error | SignError | TXCheckError;
            } | {
                type: "__TX_CHECK_RETRY__";
            } | {
                type: "__TX_CHECK_RETRY_TIMEOUT__";
                val: number;
            }, {
                type: "START";
            } | {
                type: "__SIGN_SUCCESS__";
                val: Extract<SignRes, {
                    type: "regular";
                }>;
            } | {
                type: "__SIGN_ERROR__";
                val: Error;
            } | {
                type: "__BROADCAST_SUCCESS__";
            } | {
                type: "__BROADCAST_ERROR__";
                val: Error | SubmitHashError;
            } | {
                type: "__DONE__";
                val: TxState[];
            } | {
                type: "__SIGN_RETRY__";
            } | {
                type: "__BROADCAST_RETRY__";
            } | {
                type: "__SIGN_NEXT_TX__";
                val: {
                    newCurrentTxMeta: {
                        idx: number;
                        id: string;
                    };
                    newTxStates: TxState[];
                };
            } | {
                type: "__TX_CHECK_ERROR__";
                val: Error | SignError | TXCheckError;
            } | {
                type: "__TX_CHECK_RETRY__";
            } | {
                type: "__TX_CHECK_RETRY_TIMEOUT__";
                val: number;
            }>) => void;
        };
        readonly signError: {
            readonly on: {
                readonly __SIGN_RETRY__: "signLoading";
            };
        };
        readonly broadcastLoading: {
            readonly on: {
                readonly __BROADCAST_SUCCESS__: {
                    readonly target: "txCheckLoading";
                    readonly actions: import("xstate").ActionFunction<{
                        yieldId: Maybe<string>;
                        txStates: TxState[];
                        currentTxMeta: Maybe<{
                            idx: number;
                            id: string;
                        }>;
                        txCheckTimeoutId: Maybe<number>;
                    }, {
                        type: "__BROADCAST_SUCCESS__";
                    }, {
                        type: "START";
                    } | {
                        type: "__SIGN_SUCCESS__";
                        val: Extract<SignRes, {
                            type: "regular";
                        }>;
                    } | {
                        type: "__SIGN_ERROR__";
                        val: Error;
                    } | {
                        type: "__BROADCAST_SUCCESS__";
                    } | {
                        type: "__BROADCAST_ERROR__";
                        val: Error | SubmitHashError;
                    } | {
                        type: "__DONE__";
                        val: TxState[];
                    } | {
                        type: "__SIGN_RETRY__";
                    } | {
                        type: "__BROADCAST_RETRY__";
                    } | {
                        type: "__SIGN_NEXT_TX__";
                        val: {
                            newCurrentTxMeta: {
                                idx: number;
                                id: string;
                            };
                            newTxStates: TxState[];
                        };
                    } | {
                        type: "__TX_CHECK_ERROR__";
                        val: Error | SignError | TXCheckError;
                    } | {
                        type: "__TX_CHECK_RETRY__";
                    } | {
                        type: "__TX_CHECK_RETRY_TIMEOUT__";
                        val: number;
                    }, undefined, never, never, never, never, never>;
                };
                readonly __BROADCAST_ERROR__: {
                    readonly target: "broadcastError";
                    readonly actions: import("xstate").ActionFunction<{
                        yieldId: Maybe<string>;
                        txStates: TxState[];
                        currentTxMeta: Maybe<{
                            idx: number;
                            id: string;
                        }>;
                        txCheckTimeoutId: Maybe<number>;
                    }, {
                        type: "__BROADCAST_ERROR__";
                        val: Error | SubmitHashError;
                    }, {
                        type: "START";
                    } | {
                        type: "__SIGN_SUCCESS__";
                        val: Extract<SignRes, {
                            type: "regular";
                        }>;
                    } | {
                        type: "__SIGN_ERROR__";
                        val: Error;
                    } | {
                        type: "__BROADCAST_SUCCESS__";
                    } | {
                        type: "__BROADCAST_ERROR__";
                        val: Error | SubmitHashError;
                    } | {
                        type: "__DONE__";
                        val: TxState[];
                    } | {
                        type: "__SIGN_RETRY__";
                    } | {
                        type: "__BROADCAST_RETRY__";
                    } | {
                        type: "__SIGN_NEXT_TX__";
                        val: {
                            newCurrentTxMeta: {
                                idx: number;
                                id: string;
                            };
                            newTxStates: TxState[];
                        };
                    } | {
                        type: "__TX_CHECK_ERROR__";
                        val: Error | SignError | TXCheckError;
                    } | {
                        type: "__TX_CHECK_RETRY__";
                    } | {
                        type: "__TX_CHECK_RETRY_TIMEOUT__";
                        val: number;
                    }, undefined, never, never, never, never, never>;
                };
            };
            readonly entry: ({ self, context }: import("xstate").ActionArgs<{
                yieldId: Maybe<string>;
                txStates: TxState[];
                currentTxMeta: Maybe<{
                    idx: number;
                    id: string;
                }>;
                txCheckTimeoutId: Maybe<number>;
            }, {
                type: "START";
            } | {
                type: "__SIGN_SUCCESS__";
                val: Extract<SignRes, {
                    type: "regular";
                }>;
            } | {
                type: "__SIGN_ERROR__";
                val: Error;
            } | {
                type: "__BROADCAST_SUCCESS__";
            } | {
                type: "__BROADCAST_ERROR__";
                val: Error | SubmitHashError;
            } | {
                type: "__DONE__";
                val: TxState[];
            } | {
                type: "__SIGN_RETRY__";
            } | {
                type: "__BROADCAST_RETRY__";
            } | {
                type: "__SIGN_NEXT_TX__";
                val: {
                    newCurrentTxMeta: {
                        idx: number;
                        id: string;
                    };
                    newTxStates: TxState[];
                };
            } | {
                type: "__TX_CHECK_ERROR__";
                val: Error | SignError | TXCheckError;
            } | {
                type: "__TX_CHECK_RETRY__";
            } | {
                type: "__TX_CHECK_RETRY_TIMEOUT__";
                val: number;
            }, {
                type: "START";
            } | {
                type: "__SIGN_SUCCESS__";
                val: Extract<SignRes, {
                    type: "regular";
                }>;
            } | {
                type: "__SIGN_ERROR__";
                val: Error;
            } | {
                type: "__BROADCAST_SUCCESS__";
            } | {
                type: "__BROADCAST_ERROR__";
                val: Error | SubmitHashError;
            } | {
                type: "__DONE__";
                val: TxState[];
            } | {
                type: "__SIGN_RETRY__";
            } | {
                type: "__BROADCAST_RETRY__";
            } | {
                type: "__SIGN_NEXT_TX__";
                val: {
                    newCurrentTxMeta: {
                        idx: number;
                        id: string;
                    };
                    newTxStates: TxState[];
                };
            } | {
                type: "__TX_CHECK_ERROR__";
                val: Error | SignError | TXCheckError;
            } | {
                type: "__TX_CHECK_RETRY__";
            } | {
                type: "__TX_CHECK_RETRY_TIMEOUT__";
                val: number;
            }>) => void;
        };
        readonly broadcastError: {
            readonly on: {
                readonly __BROADCAST_RETRY__: "broadcastLoading";
            };
        };
        readonly txCheckLoading: {
            readonly on: {
                readonly __SIGN_NEXT_TX__: {
                    readonly target: "signLoading";
                    readonly actions: import("xstate").ActionFunction<{
                        yieldId: Maybe<string>;
                        txStates: TxState[];
                        currentTxMeta: Maybe<{
                            idx: number;
                            id: string;
                        }>;
                        txCheckTimeoutId: Maybe<number>;
                    }, {
                        type: "__SIGN_NEXT_TX__";
                        val: {
                            newCurrentTxMeta: {
                                idx: number;
                                id: string;
                            };
                            newTxStates: TxState[];
                        };
                    }, {
                        type: "START";
                    } | {
                        type: "__SIGN_SUCCESS__";
                        val: Extract<SignRes, {
                            type: "regular";
                        }>;
                    } | {
                        type: "__SIGN_ERROR__";
                        val: Error;
                    } | {
                        type: "__BROADCAST_SUCCESS__";
                    } | {
                        type: "__BROADCAST_ERROR__";
                        val: Error | SubmitHashError;
                    } | {
                        type: "__DONE__";
                        val: TxState[];
                    } | {
                        type: "__SIGN_RETRY__";
                    } | {
                        type: "__BROADCAST_RETRY__";
                    } | {
                        type: "__SIGN_NEXT_TX__";
                        val: {
                            newCurrentTxMeta: {
                                idx: number;
                                id: string;
                            };
                            newTxStates: TxState[];
                        };
                    } | {
                        type: "__TX_CHECK_ERROR__";
                        val: Error | SignError | TXCheckError;
                    } | {
                        type: "__TX_CHECK_RETRY__";
                    } | {
                        type: "__TX_CHECK_RETRY_TIMEOUT__";
                        val: number;
                    }, undefined, never, never, never, never, never>;
                };
                readonly __DONE__: {
                    readonly target: "done";
                    readonly actions: import("xstate").ActionFunction<{
                        yieldId: Maybe<string>;
                        txStates: TxState[];
                        currentTxMeta: Maybe<{
                            idx: number;
                            id: string;
                        }>;
                        txCheckTimeoutId: Maybe<number>;
                    }, {
                        type: "__DONE__";
                        val: TxState[];
                    }, {
                        type: "START";
                    } | {
                        type: "__SIGN_SUCCESS__";
                        val: Extract<SignRes, {
                            type: "regular";
                        }>;
                    } | {
                        type: "__SIGN_ERROR__";
                        val: Error;
                    } | {
                        type: "__BROADCAST_SUCCESS__";
                    } | {
                        type: "__BROADCAST_ERROR__";
                        val: Error | SubmitHashError;
                    } | {
                        type: "__DONE__";
                        val: TxState[];
                    } | {
                        type: "__SIGN_RETRY__";
                    } | {
                        type: "__BROADCAST_RETRY__";
                    } | {
                        type: "__SIGN_NEXT_TX__";
                        val: {
                            newCurrentTxMeta: {
                                idx: number;
                                id: string;
                            };
                            newTxStates: TxState[];
                        };
                    } | {
                        type: "__TX_CHECK_ERROR__";
                        val: Error | SignError | TXCheckError;
                    } | {
                        type: "__TX_CHECK_RETRY__";
                    } | {
                        type: "__TX_CHECK_RETRY_TIMEOUT__";
                        val: number;
                    }, undefined, never, never, never, never, never>;
                };
                readonly __TX_CHECK_ERROR__: {
                    readonly target: "txCheckError";
                    readonly actions: import("xstate").ActionFunction<{
                        yieldId: Maybe<string>;
                        txStates: TxState[];
                        currentTxMeta: Maybe<{
                            idx: number;
                            id: string;
                        }>;
                        txCheckTimeoutId: Maybe<number>;
                    }, {
                        type: "__TX_CHECK_ERROR__";
                        val: Error | SignError | TXCheckError;
                    }, {
                        type: "START";
                    } | {
                        type: "__SIGN_SUCCESS__";
                        val: Extract<SignRes, {
                            type: "regular";
                        }>;
                    } | {
                        type: "__SIGN_ERROR__";
                        val: Error;
                    } | {
                        type: "__BROADCAST_SUCCESS__";
                    } | {
                        type: "__BROADCAST_ERROR__";
                        val: Error | SubmitHashError;
                    } | {
                        type: "__DONE__";
                        val: TxState[];
                    } | {
                        type: "__SIGN_RETRY__";
                    } | {
                        type: "__BROADCAST_RETRY__";
                    } | {
                        type: "__SIGN_NEXT_TX__";
                        val: {
                            newCurrentTxMeta: {
                                idx: number;
                                id: string;
                            };
                            newTxStates: TxState[];
                        };
                    } | {
                        type: "__TX_CHECK_ERROR__";
                        val: Error | SignError | TXCheckError;
                    } | {
                        type: "__TX_CHECK_RETRY__";
                    } | {
                        type: "__TX_CHECK_RETRY_TIMEOUT__";
                        val: number;
                    }, undefined, never, never, never, never, never>;
                };
                readonly __TX_CHECK_RETRY__: "txCheckRetry";
            };
            readonly entry: ({ self, context }: import("xstate").ActionArgs<{
                yieldId: Maybe<string>;
                txStates: TxState[];
                currentTxMeta: Maybe<{
                    idx: number;
                    id: string;
                }>;
                txCheckTimeoutId: Maybe<number>;
            }, {
                type: "START";
            } | {
                type: "__SIGN_SUCCESS__";
                val: Extract<SignRes, {
                    type: "regular";
                }>;
            } | {
                type: "__SIGN_ERROR__";
                val: Error;
            } | {
                type: "__BROADCAST_SUCCESS__";
            } | {
                type: "__BROADCAST_ERROR__";
                val: Error | SubmitHashError;
            } | {
                type: "__DONE__";
                val: TxState[];
            } | {
                type: "__SIGN_RETRY__";
            } | {
                type: "__BROADCAST_RETRY__";
            } | {
                type: "__SIGN_NEXT_TX__";
                val: {
                    newCurrentTxMeta: {
                        idx: number;
                        id: string;
                    };
                    newTxStates: TxState[];
                };
            } | {
                type: "__TX_CHECK_ERROR__";
                val: Error | SignError | TXCheckError;
            } | {
                type: "__TX_CHECK_RETRY__";
            } | {
                type: "__TX_CHECK_RETRY_TIMEOUT__";
                val: number;
            }, {
                type: "START";
            } | {
                type: "__SIGN_SUCCESS__";
                val: Extract<SignRes, {
                    type: "regular";
                }>;
            } | {
                type: "__SIGN_ERROR__";
                val: Error;
            } | {
                type: "__BROADCAST_SUCCESS__";
            } | {
                type: "__BROADCAST_ERROR__";
                val: Error | SubmitHashError;
            } | {
                type: "__DONE__";
                val: TxState[];
            } | {
                type: "__SIGN_RETRY__";
            } | {
                type: "__BROADCAST_RETRY__";
            } | {
                type: "__SIGN_NEXT_TX__";
                val: {
                    newCurrentTxMeta: {
                        idx: number;
                        id: string;
                    };
                    newTxStates: TxState[];
                };
            } | {
                type: "__TX_CHECK_ERROR__";
                val: Error | SignError | TXCheckError;
            } | {
                type: "__TX_CHECK_RETRY__";
            } | {
                type: "__TX_CHECK_RETRY_TIMEOUT__";
                val: number;
            }>) => void;
        };
        readonly txCheckRetry: {
            readonly on: {
                readonly __TX_CHECK_RETRY__: "txCheckLoading";
                readonly __TX_CHECK_RETRY_TIMEOUT__: {
                    readonly actions: import("xstate").ActionFunction<{
                        yieldId: Maybe<string>;
                        txStates: TxState[];
                        currentTxMeta: Maybe<{
                            idx: number;
                            id: string;
                        }>;
                        txCheckTimeoutId: Maybe<number>;
                    }, {
                        type: "__TX_CHECK_RETRY_TIMEOUT__";
                        val: number;
                    }, {
                        type: "START";
                    } | {
                        type: "__SIGN_SUCCESS__";
                        val: Extract<SignRes, {
                            type: "regular";
                        }>;
                    } | {
                        type: "__SIGN_ERROR__";
                        val: Error;
                    } | {
                        type: "__BROADCAST_SUCCESS__";
                    } | {
                        type: "__BROADCAST_ERROR__";
                        val: Error | SubmitHashError;
                    } | {
                        type: "__DONE__";
                        val: TxState[];
                    } | {
                        type: "__SIGN_RETRY__";
                    } | {
                        type: "__BROADCAST_RETRY__";
                    } | {
                        type: "__SIGN_NEXT_TX__";
                        val: {
                            newCurrentTxMeta: {
                                idx: number;
                                id: string;
                            };
                            newTxStates: TxState[];
                        };
                    } | {
                        type: "__TX_CHECK_ERROR__";
                        val: Error | SignError | TXCheckError;
                    } | {
                        type: "__TX_CHECK_RETRY__";
                    } | {
                        type: "__TX_CHECK_RETRY_TIMEOUT__";
                        val: number;
                    }, undefined, never, never, never, never, never>;
                };
            };
            readonly entry: ({ self }: import("xstate").ActionArgs<{
                yieldId: Maybe<string>;
                txStates: TxState[];
                currentTxMeta: Maybe<{
                    idx: number;
                    id: string;
                }>;
                txCheckTimeoutId: Maybe<number>;
            }, {
                type: "START";
            } | {
                type: "__SIGN_SUCCESS__";
                val: Extract<SignRes, {
                    type: "regular";
                }>;
            } | {
                type: "__SIGN_ERROR__";
                val: Error;
            } | {
                type: "__BROADCAST_SUCCESS__";
            } | {
                type: "__BROADCAST_ERROR__";
                val: Error | SubmitHashError;
            } | {
                type: "__DONE__";
                val: TxState[];
            } | {
                type: "__SIGN_RETRY__";
            } | {
                type: "__BROADCAST_RETRY__";
            } | {
                type: "__SIGN_NEXT_TX__";
                val: {
                    newCurrentTxMeta: {
                        idx: number;
                        id: string;
                    };
                    newTxStates: TxState[];
                };
            } | {
                type: "__TX_CHECK_ERROR__";
                val: Error | SignError | TXCheckError;
            } | {
                type: "__TX_CHECK_RETRY__";
            } | {
                type: "__TX_CHECK_RETRY_TIMEOUT__";
                val: number;
            }, {
                type: "START";
            } | {
                type: "__SIGN_SUCCESS__";
                val: Extract<SignRes, {
                    type: "regular";
                }>;
            } | {
                type: "__SIGN_ERROR__";
                val: Error;
            } | {
                type: "__BROADCAST_SUCCESS__";
            } | {
                type: "__BROADCAST_ERROR__";
                val: Error | SubmitHashError;
            } | {
                type: "__DONE__";
                val: TxState[];
            } | {
                type: "__SIGN_RETRY__";
            } | {
                type: "__BROADCAST_RETRY__";
            } | {
                type: "__SIGN_NEXT_TX__";
                val: {
                    newCurrentTxMeta: {
                        idx: number;
                        id: string;
                    };
                    newTxStates: TxState[];
                };
            } | {
                type: "__TX_CHECK_ERROR__";
                val: Error | SignError | TXCheckError;
            } | {
                type: "__TX_CHECK_RETRY__";
            } | {
                type: "__TX_CHECK_RETRY_TIMEOUT__";
                val: number;
            }>) => void;
        };
        readonly txCheckError: {
            readonly on: {
                readonly __TX_CHECK_RETRY__: "txCheckLoading";
            };
        };
        readonly done: {
            readonly type: "final";
        };
    };
}>, (event: {
    type: "START";
} | {
    type: "__SIGN_SUCCESS__";
    val: Extract<SignRes, {
        type: "regular";
    }>;
} | {
    type: "__SIGN_ERROR__";
    val: Error;
} | {
    type: "__BROADCAST_SUCCESS__";
} | {
    type: "__BROADCAST_ERROR__";
    val: Error | SubmitHashError;
} | {
    type: "__DONE__";
    val: TxState[];
} | {
    type: "__SIGN_RETRY__";
} | {
    type: "__BROADCAST_RETRY__";
} | {
    type: "__SIGN_NEXT_TX__";
    val: {
        newCurrentTxMeta: {
            idx: number;
            id: string;
        };
        newTxStates: TxState[];
    };
} | {
    type: "__TX_CHECK_ERROR__";
    val: Error | SignError | TXCheckError;
} | {
    type: "__TX_CHECK_RETRY__";
} | {
    type: "__TX_CHECK_RETRY_TIMEOUT__";
    val: number;
}) => void, import("xstate").Actor<import("xstate").StateMachine<{
    yieldId: Maybe<string>;
    txStates: TxState[];
    currentTxMeta: Maybe<{
        idx: number;
        id: string;
    }>;
    txCheckTimeoutId: Maybe<number>;
}, {
    type: "START";
} | {
    type: "__SIGN_SUCCESS__";
    val: Extract<SignRes, {
        type: "regular";
    }>;
} | {
    type: "__SIGN_ERROR__";
    val: Error;
} | {
    type: "__BROADCAST_SUCCESS__";
} | {
    type: "__BROADCAST_ERROR__";
    val: Error | SubmitHashError;
} | {
    type: "__DONE__";
    val: TxState[];
} | {
    type: "__SIGN_RETRY__";
} | {
    type: "__BROADCAST_RETRY__";
} | {
    type: "__SIGN_NEXT_TX__";
    val: {
        newCurrentTxMeta: {
            idx: number;
            id: string;
        };
        newTxStates: TxState[];
    };
} | {
    type: "__TX_CHECK_ERROR__";
    val: Error | SignError | TXCheckError;
} | {
    type: "__TX_CHECK_RETRY__";
} | {
    type: "__TX_CHECK_RETRY_TIMEOUT__";
    val: number;
}, {}, never, never, never, never, "done" | "disabled" | "idle" | "signLoading" | "broadcastLoading" | "signError" | "txCheckLoading" | "broadcastError" | "txCheckError" | "txCheckRetry", string, import("xstate").NonReducibleUnknown, import("xstate").NonReducibleUnknown, {
    type: "signSuccess";
}, import("xstate").MetaObject, {
    readonly context: {
        readonly yieldId: import("purify-ts/Maybe").Maybe<string>;
        readonly txStates: TxState[];
        readonly currentTxMeta: import("purify-ts/Maybe").Maybe<{
            idx: number;
            id: string;
        }>;
        readonly txCheckTimeoutId: {
            isJust(): this is import("purify-ts").AlwaysJust;
            isNothing(): this is any;
            inspect(): string;
            toString(): string;
            toJSON(): never;
            equals<T>(other: import("purify-ts/Maybe").Maybe<T>): boolean;
            map<U>(_: (value: never) => U): import("purify-ts/Maybe").Maybe<U>;
            ap<U>(_: import("purify-ts/Maybe").Maybe<(value: never) => U>): import("purify-ts/Maybe").Maybe<U>;
            alt<T>(other: import("purify-ts/Maybe").Maybe<T>): import("purify-ts/Maybe").Maybe<T>;
            altLazy<T>(other: () => import("purify-ts/Maybe").Maybe<T>): import("purify-ts/Maybe").Maybe<T>;
            chain<U>(_: (value: never) => import("purify-ts/Maybe").Maybe<U>): import("purify-ts/Maybe").Maybe<U>;
            chainNullable<U>(_: (value: never) => U | undefined | null | void): import("purify-ts/Maybe").Maybe<U>;
            join<U>(this: import("purify-ts/Maybe").Maybe<import("purify-ts/Maybe").Maybe<U>>): import("purify-ts/Maybe").Maybe<U>;
            reduce<U>(_: (accumulator: U, value: never) => U, initialValue: U): U;
            extend<U>(_: (value: import("purify-ts/Maybe").Maybe<never>) => U): import("purify-ts/Maybe").Maybe<U>;
            unsafeCoerce<T>(): T;
            caseOf<U>(patterns: import("purify-ts").MaybePatterns<never, U>): U;
            orDefault<T>(defaultValue: T): T;
            orDefaultLazy<T>(getDefaultValue: () => T): T;
            toList<T>(): T[];
            mapOrDefault<U>(_: (value: never) => U, defaultValue: U): U;
            extract(): never;
            extractNullable(): never;
            toEither<L, T>(left: L): import("purify-ts").Either<L, T>;
            ifJust(_: (value: never) => any): any;
            ifNothing(effect: () => any): any;
            filter(_: (value: never) => boolean): import("purify-ts/Maybe").Maybe<never>;
            'fantasy-land/equals': <T>(other: import("purify-ts/Maybe").Maybe<T>) => boolean;
            'fantasy-land/map': <U>(_: (value: never) => U) => import("purify-ts/Maybe").Maybe<U>;
            'fantasy-land/ap': <U>(_: import("purify-ts/Maybe").Maybe<(value: never) => U>) => import("purify-ts/Maybe").Maybe<U>;
            'fantasy-land/alt': <T>(other: import("purify-ts/Maybe").Maybe<T>) => import("purify-ts/Maybe").Maybe<T>;
            'fantasy-land/chain': <U>(_: (value: never) => import("purify-ts/Maybe").Maybe<U>) => import("purify-ts/Maybe").Maybe<U>;
            'fantasy-land/reduce': <U>(_: (accumulator: U, value: never) => U, initialValue: U) => U;
            'fantasy-land/extend': <U>(_: (value: import("purify-ts/Maybe").Maybe<never>) => U) => import("purify-ts/Maybe").Maybe<U>;
            'fantasy-land/filter': (_: (value: never) => boolean) => import("purify-ts/Maybe").Maybe<never>;
        };
    };
    readonly initial: "disabled" | "idle";
    readonly states: {
        readonly idle: {
            readonly on: {
                readonly START: "signLoading";
            };
        };
        readonly disabled: {};
        readonly signLoading: {
            readonly on: {
                readonly __SIGN_SUCCESS__: {
                    readonly target: "broadcastLoading";
                    readonly actions: readonly [import("xstate").ActionFunction<{
                        yieldId: Maybe<string>;
                        txStates: TxState[];
                        currentTxMeta: Maybe<{
                            idx: number;
                            id: string;
                        }>;
                        txCheckTimeoutId: Maybe<number>;
                    }, {
                        type: "__SIGN_SUCCESS__";
                        val: Extract<SignRes, {
                            type: "regular";
                        }>;
                    }, {
                        type: "START";
                    } | {
                        type: "__SIGN_SUCCESS__";
                        val: Extract<SignRes, {
                            type: "regular";
                        }>;
                    } | {
                        type: "__SIGN_ERROR__";
                        val: Error;
                    } | {
                        type: "__BROADCAST_SUCCESS__";
                    } | {
                        type: "__BROADCAST_ERROR__";
                        val: Error | SubmitHashError;
                    } | {
                        type: "__DONE__";
                        val: TxState[];
                    } | {
                        type: "__SIGN_RETRY__";
                    } | {
                        type: "__BROADCAST_RETRY__";
                    } | {
                        type: "__SIGN_NEXT_TX__";
                        val: {
                            newCurrentTxMeta: {
                                idx: number;
                                id: string;
                            };
                            newTxStates: TxState[];
                        };
                    } | {
                        type: "__TX_CHECK_ERROR__";
                        val: Error | SignError | TXCheckError;
                    } | {
                        type: "__TX_CHECK_RETRY__";
                    } | {
                        type: "__TX_CHECK_RETRY_TIMEOUT__";
                        val: number;
                    }, undefined, never, never, never, never, never>, import("xstate").ActionFunction<{
                        yieldId: Maybe<string>;
                        txStates: TxState[];
                        currentTxMeta: Maybe<{
                            idx: number;
                            id: string;
                        }>;
                        txCheckTimeoutId: Maybe<number>;
                    }, {
                        type: "__SIGN_SUCCESS__";
                        val: Extract<SignRes, {
                            type: "regular";
                        }>;
                    }, {
                        type: "START";
                    } | {
                        type: "__SIGN_SUCCESS__";
                        val: Extract<SignRes, {
                            type: "regular";
                        }>;
                    } | {
                        type: "__SIGN_ERROR__";
                        val: Error;
                    } | {
                        type: "__BROADCAST_SUCCESS__";
                    } | {
                        type: "__BROADCAST_ERROR__";
                        val: Error | SubmitHashError;
                    } | {
                        type: "__DONE__";
                        val: TxState[];
                    } | {
                        type: "__SIGN_RETRY__";
                    } | {
                        type: "__BROADCAST_RETRY__";
                    } | {
                        type: "__SIGN_NEXT_TX__";
                        val: {
                            newCurrentTxMeta: {
                                idx: number;
                                id: string;
                            };
                            newTxStates: TxState[];
                        };
                    } | {
                        type: "__TX_CHECK_ERROR__";
                        val: Error | SignError | TXCheckError;
                    } | {
                        type: "__TX_CHECK_RETRY__";
                    } | {
                        type: "__TX_CHECK_RETRY_TIMEOUT__";
                        val: number;
                    }, undefined, never, never, never, never, {
                        type: "signSuccess";
                    }>];
                };
                readonly __SIGN_ERROR__: {
                    readonly target: "signError";
                    readonly actions: import("xstate").ActionFunction<{
                        yieldId: Maybe<string>;
                        txStates: TxState[];
                        currentTxMeta: Maybe<{
                            idx: number;
                            id: string;
                        }>;
                        txCheckTimeoutId: Maybe<number>;
                    }, {
                        type: "__SIGN_ERROR__";
                        val: Error;
                    }, {
                        type: "START";
                    } | {
                        type: "__SIGN_SUCCESS__";
                        val: Extract<SignRes, {
                            type: "regular";
                        }>;
                    } | {
                        type: "__SIGN_ERROR__";
                        val: Error;
                    } | {
                        type: "__BROADCAST_SUCCESS__";
                    } | {
                        type: "__BROADCAST_ERROR__";
                        val: Error | SubmitHashError;
                    } | {
                        type: "__DONE__";
                        val: TxState[];
                    } | {
                        type: "__SIGN_RETRY__";
                    } | {
                        type: "__BROADCAST_RETRY__";
                    } | {
                        type: "__SIGN_NEXT_TX__";
                        val: {
                            newCurrentTxMeta: {
                                idx: number;
                                id: string;
                            };
                            newTxStates: TxState[];
                        };
                    } | {
                        type: "__TX_CHECK_ERROR__";
                        val: Error | SignError | TXCheckError;
                    } | {
                        type: "__TX_CHECK_RETRY__";
                    } | {
                        type: "__TX_CHECK_RETRY_TIMEOUT__";
                        val: number;
                    }, undefined, never, never, never, never, never>;
                };
                readonly __BROADCAST_SUCCESS__: "txCheckLoading";
            };
            readonly entry: ({ context, self }: import("xstate").ActionArgs<{
                yieldId: Maybe<string>;
                txStates: TxState[];
                currentTxMeta: Maybe<{
                    idx: number;
                    id: string;
                }>;
                txCheckTimeoutId: Maybe<number>;
            }, {
                type: "START";
            } | {
                type: "__SIGN_SUCCESS__";
                val: Extract<SignRes, {
                    type: "regular";
                }>;
            } | {
                type: "__SIGN_ERROR__";
                val: Error;
            } | {
                type: "__BROADCAST_SUCCESS__";
            } | {
                type: "__BROADCAST_ERROR__";
                val: Error | SubmitHashError;
            } | {
                type: "__DONE__";
                val: TxState[];
            } | {
                type: "__SIGN_RETRY__";
            } | {
                type: "__BROADCAST_RETRY__";
            } | {
                type: "__SIGN_NEXT_TX__";
                val: {
                    newCurrentTxMeta: {
                        idx: number;
                        id: string;
                    };
                    newTxStates: TxState[];
                };
            } | {
                type: "__TX_CHECK_ERROR__";
                val: Error | SignError | TXCheckError;
            } | {
                type: "__TX_CHECK_RETRY__";
            } | {
                type: "__TX_CHECK_RETRY_TIMEOUT__";
                val: number;
            }, {
                type: "START";
            } | {
                type: "__SIGN_SUCCESS__";
                val: Extract<SignRes, {
                    type: "regular";
                }>;
            } | {
                type: "__SIGN_ERROR__";
                val: Error;
            } | {
                type: "__BROADCAST_SUCCESS__";
            } | {
                type: "__BROADCAST_ERROR__";
                val: Error | SubmitHashError;
            } | {
                type: "__DONE__";
                val: TxState[];
            } | {
                type: "__SIGN_RETRY__";
            } | {
                type: "__BROADCAST_RETRY__";
            } | {
                type: "__SIGN_NEXT_TX__";
                val: {
                    newCurrentTxMeta: {
                        idx: number;
                        id: string;
                    };
                    newTxStates: TxState[];
                };
            } | {
                type: "__TX_CHECK_ERROR__";
                val: Error | SignError | TXCheckError;
            } | {
                type: "__TX_CHECK_RETRY__";
            } | {
                type: "__TX_CHECK_RETRY_TIMEOUT__";
                val: number;
            }>) => void;
        };
        readonly signError: {
            readonly on: {
                readonly __SIGN_RETRY__: "signLoading";
            };
        };
        readonly broadcastLoading: {
            readonly on: {
                readonly __BROADCAST_SUCCESS__: {
                    readonly target: "txCheckLoading";
                    readonly actions: import("xstate").ActionFunction<{
                        yieldId: Maybe<string>;
                        txStates: TxState[];
                        currentTxMeta: Maybe<{
                            idx: number;
                            id: string;
                        }>;
                        txCheckTimeoutId: Maybe<number>;
                    }, {
                        type: "__BROADCAST_SUCCESS__";
                    }, {
                        type: "START";
                    } | {
                        type: "__SIGN_SUCCESS__";
                        val: Extract<SignRes, {
                            type: "regular";
                        }>;
                    } | {
                        type: "__SIGN_ERROR__";
                        val: Error;
                    } | {
                        type: "__BROADCAST_SUCCESS__";
                    } | {
                        type: "__BROADCAST_ERROR__";
                        val: Error | SubmitHashError;
                    } | {
                        type: "__DONE__";
                        val: TxState[];
                    } | {
                        type: "__SIGN_RETRY__";
                    } | {
                        type: "__BROADCAST_RETRY__";
                    } | {
                        type: "__SIGN_NEXT_TX__";
                        val: {
                            newCurrentTxMeta: {
                                idx: number;
                                id: string;
                            };
                            newTxStates: TxState[];
                        };
                    } | {
                        type: "__TX_CHECK_ERROR__";
                        val: Error | SignError | TXCheckError;
                    } | {
                        type: "__TX_CHECK_RETRY__";
                    } | {
                        type: "__TX_CHECK_RETRY_TIMEOUT__";
                        val: number;
                    }, undefined, never, never, never, never, never>;
                };
                readonly __BROADCAST_ERROR__: {
                    readonly target: "broadcastError";
                    readonly actions: import("xstate").ActionFunction<{
                        yieldId: Maybe<string>;
                        txStates: TxState[];
                        currentTxMeta: Maybe<{
                            idx: number;
                            id: string;
                        }>;
                        txCheckTimeoutId: Maybe<number>;
                    }, {
                        type: "__BROADCAST_ERROR__";
                        val: Error | SubmitHashError;
                    }, {
                        type: "START";
                    } | {
                        type: "__SIGN_SUCCESS__";
                        val: Extract<SignRes, {
                            type: "regular";
                        }>;
                    } | {
                        type: "__SIGN_ERROR__";
                        val: Error;
                    } | {
                        type: "__BROADCAST_SUCCESS__";
                    } | {
                        type: "__BROADCAST_ERROR__";
                        val: Error | SubmitHashError;
                    } | {
                        type: "__DONE__";
                        val: TxState[];
                    } | {
                        type: "__SIGN_RETRY__";
                    } | {
                        type: "__BROADCAST_RETRY__";
                    } | {
                        type: "__SIGN_NEXT_TX__";
                        val: {
                            newCurrentTxMeta: {
                                idx: number;
                                id: string;
                            };
                            newTxStates: TxState[];
                        };
                    } | {
                        type: "__TX_CHECK_ERROR__";
                        val: Error | SignError | TXCheckError;
                    } | {
                        type: "__TX_CHECK_RETRY__";
                    } | {
                        type: "__TX_CHECK_RETRY_TIMEOUT__";
                        val: number;
                    }, undefined, never, never, never, never, never>;
                };
            };
            readonly entry: ({ self, context }: import("xstate").ActionArgs<{
                yieldId: Maybe<string>;
                txStates: TxState[];
                currentTxMeta: Maybe<{
                    idx: number;
                    id: string;
                }>;
                txCheckTimeoutId: Maybe<number>;
            }, {
                type: "START";
            } | {
                type: "__SIGN_SUCCESS__";
                val: Extract<SignRes, {
                    type: "regular";
                }>;
            } | {
                type: "__SIGN_ERROR__";
                val: Error;
            } | {
                type: "__BROADCAST_SUCCESS__";
            } | {
                type: "__BROADCAST_ERROR__";
                val: Error | SubmitHashError;
            } | {
                type: "__DONE__";
                val: TxState[];
            } | {
                type: "__SIGN_RETRY__";
            } | {
                type: "__BROADCAST_RETRY__";
            } | {
                type: "__SIGN_NEXT_TX__";
                val: {
                    newCurrentTxMeta: {
                        idx: number;
                        id: string;
                    };
                    newTxStates: TxState[];
                };
            } | {
                type: "__TX_CHECK_ERROR__";
                val: Error | SignError | TXCheckError;
            } | {
                type: "__TX_CHECK_RETRY__";
            } | {
                type: "__TX_CHECK_RETRY_TIMEOUT__";
                val: number;
            }, {
                type: "START";
            } | {
                type: "__SIGN_SUCCESS__";
                val: Extract<SignRes, {
                    type: "regular";
                }>;
            } | {
                type: "__SIGN_ERROR__";
                val: Error;
            } | {
                type: "__BROADCAST_SUCCESS__";
            } | {
                type: "__BROADCAST_ERROR__";
                val: Error | SubmitHashError;
            } | {
                type: "__DONE__";
                val: TxState[];
            } | {
                type: "__SIGN_RETRY__";
            } | {
                type: "__BROADCAST_RETRY__";
            } | {
                type: "__SIGN_NEXT_TX__";
                val: {
                    newCurrentTxMeta: {
                        idx: number;
                        id: string;
                    };
                    newTxStates: TxState[];
                };
            } | {
                type: "__TX_CHECK_ERROR__";
                val: Error | SignError | TXCheckError;
            } | {
                type: "__TX_CHECK_RETRY__";
            } | {
                type: "__TX_CHECK_RETRY_TIMEOUT__";
                val: number;
            }>) => void;
        };
        readonly broadcastError: {
            readonly on: {
                readonly __BROADCAST_RETRY__: "broadcastLoading";
            };
        };
        readonly txCheckLoading: {
            readonly on: {
                readonly __SIGN_NEXT_TX__: {
                    readonly target: "signLoading";
                    readonly actions: import("xstate").ActionFunction<{
                        yieldId: Maybe<string>;
                        txStates: TxState[];
                        currentTxMeta: Maybe<{
                            idx: number;
                            id: string;
                        }>;
                        txCheckTimeoutId: Maybe<number>;
                    }, {
                        type: "__SIGN_NEXT_TX__";
                        val: {
                            newCurrentTxMeta: {
                                idx: number;
                                id: string;
                            };
                            newTxStates: TxState[];
                        };
                    }, {
                        type: "START";
                    } | {
                        type: "__SIGN_SUCCESS__";
                        val: Extract<SignRes, {
                            type: "regular";
                        }>;
                    } | {
                        type: "__SIGN_ERROR__";
                        val: Error;
                    } | {
                        type: "__BROADCAST_SUCCESS__";
                    } | {
                        type: "__BROADCAST_ERROR__";
                        val: Error | SubmitHashError;
                    } | {
                        type: "__DONE__";
                        val: TxState[];
                    } | {
                        type: "__SIGN_RETRY__";
                    } | {
                        type: "__BROADCAST_RETRY__";
                    } | {
                        type: "__SIGN_NEXT_TX__";
                        val: {
                            newCurrentTxMeta: {
                                idx: number;
                                id: string;
                            };
                            newTxStates: TxState[];
                        };
                    } | {
                        type: "__TX_CHECK_ERROR__";
                        val: Error | SignError | TXCheckError;
                    } | {
                        type: "__TX_CHECK_RETRY__";
                    } | {
                        type: "__TX_CHECK_RETRY_TIMEOUT__";
                        val: number;
                    }, undefined, never, never, never, never, never>;
                };
                readonly __DONE__: {
                    readonly target: "done";
                    readonly actions: import("xstate").ActionFunction<{
                        yieldId: Maybe<string>;
                        txStates: TxState[];
                        currentTxMeta: Maybe<{
                            idx: number;
                            id: string;
                        }>;
                        txCheckTimeoutId: Maybe<number>;
                    }, {
                        type: "__DONE__";
                        val: TxState[];
                    }, {
                        type: "START";
                    } | {
                        type: "__SIGN_SUCCESS__";
                        val: Extract<SignRes, {
                            type: "regular";
                        }>;
                    } | {
                        type: "__SIGN_ERROR__";
                        val: Error;
                    } | {
                        type: "__BROADCAST_SUCCESS__";
                    } | {
                        type: "__BROADCAST_ERROR__";
                        val: Error | SubmitHashError;
                    } | {
                        type: "__DONE__";
                        val: TxState[];
                    } | {
                        type: "__SIGN_RETRY__";
                    } | {
                        type: "__BROADCAST_RETRY__";
                    } | {
                        type: "__SIGN_NEXT_TX__";
                        val: {
                            newCurrentTxMeta: {
                                idx: number;
                                id: string;
                            };
                            newTxStates: TxState[];
                        };
                    } | {
                        type: "__TX_CHECK_ERROR__";
                        val: Error | SignError | TXCheckError;
                    } | {
                        type: "__TX_CHECK_RETRY__";
                    } | {
                        type: "__TX_CHECK_RETRY_TIMEOUT__";
                        val: number;
                    }, undefined, never, never, never, never, never>;
                };
                readonly __TX_CHECK_ERROR__: {
                    readonly target: "txCheckError";
                    readonly actions: import("xstate").ActionFunction<{
                        yieldId: Maybe<string>;
                        txStates: TxState[];
                        currentTxMeta: Maybe<{
                            idx: number;
                            id: string;
                        }>;
                        txCheckTimeoutId: Maybe<number>;
                    }, {
                        type: "__TX_CHECK_ERROR__";
                        val: Error | SignError | TXCheckError;
                    }, {
                        type: "START";
                    } | {
                        type: "__SIGN_SUCCESS__";
                        val: Extract<SignRes, {
                            type: "regular";
                        }>;
                    } | {
                        type: "__SIGN_ERROR__";
                        val: Error;
                    } | {
                        type: "__BROADCAST_SUCCESS__";
                    } | {
                        type: "__BROADCAST_ERROR__";
                        val: Error | SubmitHashError;
                    } | {
                        type: "__DONE__";
                        val: TxState[];
                    } | {
                        type: "__SIGN_RETRY__";
                    } | {
                        type: "__BROADCAST_RETRY__";
                    } | {
                        type: "__SIGN_NEXT_TX__";
                        val: {
                            newCurrentTxMeta: {
                                idx: number;
                                id: string;
                            };
                            newTxStates: TxState[];
                        };
                    } | {
                        type: "__TX_CHECK_ERROR__";
                        val: Error | SignError | TXCheckError;
                    } | {
                        type: "__TX_CHECK_RETRY__";
                    } | {
                        type: "__TX_CHECK_RETRY_TIMEOUT__";
                        val: number;
                    }, undefined, never, never, never, never, never>;
                };
                readonly __TX_CHECK_RETRY__: "txCheckRetry";
            };
            readonly entry: ({ self, context }: import("xstate").ActionArgs<{
                yieldId: Maybe<string>;
                txStates: TxState[];
                currentTxMeta: Maybe<{
                    idx: number;
                    id: string;
                }>;
                txCheckTimeoutId: Maybe<number>;
            }, {
                type: "START";
            } | {
                type: "__SIGN_SUCCESS__";
                val: Extract<SignRes, {
                    type: "regular";
                }>;
            } | {
                type: "__SIGN_ERROR__";
                val: Error;
            } | {
                type: "__BROADCAST_SUCCESS__";
            } | {
                type: "__BROADCAST_ERROR__";
                val: Error | SubmitHashError;
            } | {
                type: "__DONE__";
                val: TxState[];
            } | {
                type: "__SIGN_RETRY__";
            } | {
                type: "__BROADCAST_RETRY__";
            } | {
                type: "__SIGN_NEXT_TX__";
                val: {
                    newCurrentTxMeta: {
                        idx: number;
                        id: string;
                    };
                    newTxStates: TxState[];
                };
            } | {
                type: "__TX_CHECK_ERROR__";
                val: Error | SignError | TXCheckError;
            } | {
                type: "__TX_CHECK_RETRY__";
            } | {
                type: "__TX_CHECK_RETRY_TIMEOUT__";
                val: number;
            }, {
                type: "START";
            } | {
                type: "__SIGN_SUCCESS__";
                val: Extract<SignRes, {
                    type: "regular";
                }>;
            } | {
                type: "__SIGN_ERROR__";
                val: Error;
            } | {
                type: "__BROADCAST_SUCCESS__";
            } | {
                type: "__BROADCAST_ERROR__";
                val: Error | SubmitHashError;
            } | {
                type: "__DONE__";
                val: TxState[];
            } | {
                type: "__SIGN_RETRY__";
            } | {
                type: "__BROADCAST_RETRY__";
            } | {
                type: "__SIGN_NEXT_TX__";
                val: {
                    newCurrentTxMeta: {
                        idx: number;
                        id: string;
                    };
                    newTxStates: TxState[];
                };
            } | {
                type: "__TX_CHECK_ERROR__";
                val: Error | SignError | TXCheckError;
            } | {
                type: "__TX_CHECK_RETRY__";
            } | {
                type: "__TX_CHECK_RETRY_TIMEOUT__";
                val: number;
            }>) => void;
        };
        readonly txCheckRetry: {
            readonly on: {
                readonly __TX_CHECK_RETRY__: "txCheckLoading";
                readonly __TX_CHECK_RETRY_TIMEOUT__: {
                    readonly actions: import("xstate").ActionFunction<{
                        yieldId: Maybe<string>;
                        txStates: TxState[];
                        currentTxMeta: Maybe<{
                            idx: number;
                            id: string;
                        }>;
                        txCheckTimeoutId: Maybe<number>;
                    }, {
                        type: "__TX_CHECK_RETRY_TIMEOUT__";
                        val: number;
                    }, {
                        type: "START";
                    } | {
                        type: "__SIGN_SUCCESS__";
                        val: Extract<SignRes, {
                            type: "regular";
                        }>;
                    } | {
                        type: "__SIGN_ERROR__";
                        val: Error;
                    } | {
                        type: "__BROADCAST_SUCCESS__";
                    } | {
                        type: "__BROADCAST_ERROR__";
                        val: Error | SubmitHashError;
                    } | {
                        type: "__DONE__";
                        val: TxState[];
                    } | {
                        type: "__SIGN_RETRY__";
                    } | {
                        type: "__BROADCAST_RETRY__";
                    } | {
                        type: "__SIGN_NEXT_TX__";
                        val: {
                            newCurrentTxMeta: {
                                idx: number;
                                id: string;
                            };
                            newTxStates: TxState[];
                        };
                    } | {
                        type: "__TX_CHECK_ERROR__";
                        val: Error | SignError | TXCheckError;
                    } | {
                        type: "__TX_CHECK_RETRY__";
                    } | {
                        type: "__TX_CHECK_RETRY_TIMEOUT__";
                        val: number;
                    }, undefined, never, never, never, never, never>;
                };
            };
            readonly entry: ({ self }: import("xstate").ActionArgs<{
                yieldId: Maybe<string>;
                txStates: TxState[];
                currentTxMeta: Maybe<{
                    idx: number;
                    id: string;
                }>;
                txCheckTimeoutId: Maybe<number>;
            }, {
                type: "START";
            } | {
                type: "__SIGN_SUCCESS__";
                val: Extract<SignRes, {
                    type: "regular";
                }>;
            } | {
                type: "__SIGN_ERROR__";
                val: Error;
            } | {
                type: "__BROADCAST_SUCCESS__";
            } | {
                type: "__BROADCAST_ERROR__";
                val: Error | SubmitHashError;
            } | {
                type: "__DONE__";
                val: TxState[];
            } | {
                type: "__SIGN_RETRY__";
            } | {
                type: "__BROADCAST_RETRY__";
            } | {
                type: "__SIGN_NEXT_TX__";
                val: {
                    newCurrentTxMeta: {
                        idx: number;
                        id: string;
                    };
                    newTxStates: TxState[];
                };
            } | {
                type: "__TX_CHECK_ERROR__";
                val: Error | SignError | TXCheckError;
            } | {
                type: "__TX_CHECK_RETRY__";
            } | {
                type: "__TX_CHECK_RETRY_TIMEOUT__";
                val: number;
            }, {
                type: "START";
            } | {
                type: "__SIGN_SUCCESS__";
                val: Extract<SignRes, {
                    type: "regular";
                }>;
            } | {
                type: "__SIGN_ERROR__";
                val: Error;
            } | {
                type: "__BROADCAST_SUCCESS__";
            } | {
                type: "__BROADCAST_ERROR__";
                val: Error | SubmitHashError;
            } | {
                type: "__DONE__";
                val: TxState[];
            } | {
                type: "__SIGN_RETRY__";
            } | {
                type: "__BROADCAST_RETRY__";
            } | {
                type: "__SIGN_NEXT_TX__";
                val: {
                    newCurrentTxMeta: {
                        idx: number;
                        id: string;
                    };
                    newTxStates: TxState[];
                };
            } | {
                type: "__TX_CHECK_ERROR__";
                val: Error | SignError | TXCheckError;
            } | {
                type: "__TX_CHECK_RETRY__";
            } | {
                type: "__TX_CHECK_RETRY_TIMEOUT__";
                val: number;
            }>) => void;
        };
        readonly txCheckError: {
            readonly on: {
                readonly __TX_CHECK_RETRY__: "txCheckLoading";
            };
        };
        readonly done: {
            readonly type: "final";
        };
    };
}>>];
export {};
